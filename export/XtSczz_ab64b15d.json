{"ver":"0.1","info":{"id":"XtSczz","date":"1507192424","viewed":356,"name":"Liquid Springs","username":"aaaidan","description":"Wave equation where Buffer A represents height (R channel), and vertical velocity (B channel) using 3x3 kernel and Euler integration. \n\n(Thanks KazimirO)\n\nSequel is at /view/XljczD","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["water","physics","buffer","harmonic","springs","shm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * HEY! CLICK AND DRAG!\n * Holding SHIFT shows the underlying model.\n * SPACEBAR resets the water.\n *\n * Modify Buf B to change the barriers, or add new ones.\n */\n\n/*\n * This program renders the \"model\" buffers into a visual form.\n * It does refraction, specularity and draws the barriers.\n * The other buffer programs do everything else.\n */\n\nconst int KEY_SHIFT = 16;\n\n#define DEPTH_GAIN 0.08\n\nbool isBorder(in vec2 uv) {\n    return texture(iChannel2, uv).r > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv_pixel = vec2(1.0) / iResolution.xy;\n    vec2 uv_dx = vec2( uv_pixel.x,        0.0 );\n    vec2 uv_dy = vec2(        0.0, uv_pixel.y );\n    \n    float seeModel = texelFetch( iChannel3, ivec2(KEY_SHIFT,0), 0 ).x;\n    \n    if (isBorder(uv)) {\n        fragColor = vec4(seeModel);\n        return;\n    }\n    \n    if (seeModel < 1.0) {\n        float depth = - texture(iChannel0, uv).r * DEPTH_GAIN + 0.5;\n        \n     \tfragColor = vec4(depth);\n    } else {\n        fragColor = texture(iChannel0, uv).bbab + 0.5;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n * This buffer governs the water simulation and mouse interaction.\n */\n\nconst int KEY_SPACE = 32;\n\n#define CIRCLE_RADIUS 10.0\n#define MOVE_RADIUS 100.0\n\n#define ACCEL 6.0\n#define DAMP 0.995\n#define ACCEL_SCALE 0.4\n\nvec4 blend(in vec4 under, in vec4 over) {\n    float outA = over.a + under.a * (1.0 - over.a);\n    vec3 outCol = vec3(0.0);\n    if (outA > 0.0) {\n    \toutCol = ( over.rgb*over.a + under.rgb*under.a*(1.0-over.a) ) / outA;\n    }\n    return vec4(outCol,outA);\n}\n\nbool isBorder(in vec2 uv) {\n    return texture(iChannel1, uv).r > 0.5;\n}\n\nbool isDropletFrame() {\n    return iFrame > 0 && iFrame < 5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float resetModel = texelFetch( iChannel3, ivec2(KEY_SPACE,0), 0 ).x;\n    if (resetModel > 0.5) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv_dx = vec2(1.0 / iResolution.x, 0.0);\n    vec2 uv_dy = vec2(0.0, 1.0 / iResolution.y);\n    bool border = isBorder(uv);\n    \n    vec4 lastFrameColor = texture(iChannel0, uv);\n    \n    vec2 circleCenter = isDropletFrame() ? vec2(150.0, 250.0) : iMouse.xy;\n    float distToCircle = length(fragCoord - circleCenter);\n    \n    float circleness;\n    if (iMouse.w > 0.0 || isDropletFrame()) {\n    \tcircleness = smoothstep(CIRCLE_RADIUS, CIRCLE_RADIUS-1.0, distToCircle);\n    } else {\n        circleness = 0.0;\n    }\n    \n\tfragColor = lastFrameColor;\n    \n    fragColor.r = fragColor.r + 0.05 * circleness;\n    fragColor.b = fragColor.b - 0.1 * circleness;\n    \n    float averageNeighbourHeight = fragColor.r;\n    averageNeighbourHeight += texture(iChannel0, uv + uv_dx).r;\n    averageNeighbourHeight += texture(iChannel0, uv - uv_dx).r;\n    averageNeighbourHeight += texture(iChannel0, uv + uv_dy).r;\n    averageNeighbourHeight += texture(iChannel0, uv - uv_dy).r;\n    \n    averageNeighbourHeight += texture(iChannel0, uv + uv_dx + uv_dy).r * 0.7;\n    averageNeighbourHeight += texture(iChannel0, uv - uv_dx + uv_dy).r * 0.7;\n    averageNeighbourHeight += texture(iChannel0, uv + uv_dx - uv_dy).r * 0.7;\n    averageNeighbourHeight += texture(iChannel0, uv - uv_dx - uv_dy).r * 0.7;\n    averageNeighbourHeight = (averageNeighbourHeight - 0.0) / (5.0 + 4.0 * 0.7);\n        \n    float accelAmt = averageNeighbourHeight - fragColor.r;\n    fragColor.b += accelAmt * ACCEL;\n    \n    if (border) {\n        fragColor.r = 0.0;\n        fragColor.b = 0.0;\n    }\n    \n    fragColor.r = fragColor.r * DAMP + 0.0;\n    fragColor.r += fragColor.b * ACCEL_SCALE;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n * This buffer defines barriers.\n */\n\n#define BARRIER_WIDTH 2.0\n#define NUM_BARRIERS 2.0\n#define BARRIER_HEIGHT 250.0\n\nbool isBorder(in vec2 fragCoord) {\n    bool border = fragCoord.x < BARRIER_WIDTH || fragCoord.x > iResolution.x - BARRIER_WIDTH ||\n        fragCoord.y < BARRIER_WIDTH || fragCoord.y > iResolution.y - BARRIER_WIDTH;\n    \n    float colSpacing = iResolution.x / NUM_BARRIERS;\n    float col2Spacing = colSpacing * 2.0;\n    \n    if ( mod(fragCoord.x,colSpacing) < BARRIER_WIDTH){\n        if ( mod(fragCoord.x, col2Spacing) > colSpacing) {\n            if (fragCoord.y < BARRIER_HEIGHT) {\n                border = true;\n            }\n        } else {\n            if (iResolution.y - fragCoord.y < BARRIER_HEIGHT) {\n                border = true;\n            }\n        }\n    }\n    \n    return border;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(isBorder(fragCoord) ? 1.0 : 0.0);\n}","name":"Buf B","description":"","type":"buffer"}]}