{"ver":"0.1","info":{"id":"MtGBRm","date":"1542106140","viewed":79,"name":"Supervision 1 work Julian","username":"J2G8W","description":"Julian Graphics Part 1A work","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["cambridge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Settings\nconst float FOV_DEG = 80.0f;\nconst int MAX_STEPS = 300;\nconst vec3 LIGHT_DIR = vec3(1.0,1.0,-1.0);\n\n// Consts / Enumerations \nconst float EPS = 0.0001f;\nconst float DEG_TO_RAD = 0.0174533f;\nconst float M_PI = 3.14159265358979323846;\nconst int FLOOR_PLANE = 1;\nconst int OBJECT = 2;\nconst int OBJECT2 = 3;\nconst int NO_HIT = 0;\n\n///////////////////////////////////////////////////////////\n\nstruct Ray\n{\n    vec3 Orgin;\n    vec3 Direction;\n};\n\n//Utils\nmat3 CreateRotationX(float rotation)\n{\n    mat3 rotateX =\n     mat3(\n        1.0, 0.0, 0.0,\n\t\t0.0, cos(rotation), -sin(rotation),\n\t\t0.0, sin(rotation), cos(rotation)\n    );\n\n    return rotateX;\n}\n\nmat3 CreateRotationY(float rotation)\n{\n    mat3 rotateY = \n     mat3(\n        cos(rotation), 0.0, sin(rotation),\n\t\t0.0, 1.0, 0.0, \n\t\t-sin(rotation), 0.0, cos(rotation)\n    );\n\n    return rotateY;\n}\n\nmat3 CreateRotationZ(float rotation)\n{\n    mat3 rotateZ =\n    mat3(\n        cos(rotation), -sin(rotation), 0.0,\n\t\tsin(rotation), cos(rotation), 0.0,\n\t\t0.0, 0.0, 1.0\n    );\n\n    return rotateZ;\n}\n\n// SDFs\nfloat SphereSDF(vec3 p)\n{\n    return length(p)-1.1;\n}\n\nfloat TorusSDF(vec3 p, float R, float r)\n{  \n    float xy = length(p.xy) - R;\n    float z = length(vec2(xy,p.z))-r; \n    return z;\n}\n\nfloat BoxSDF(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0))-0.1;\n}\n\nfloat CylinderSDF(vec3 p,float radius)\n{   \n    float d = length(p.xz)-radius;\n    d = max(d,p.y-1.0);\n    d = max(d,-p.y-1.0);\n    return d;\n}\n\nfloat PlaneSDF(vec3 p, float y)\n{\n    return p.y+y;\n}\n\nvec3 RepeatX(vec3 p, float offset)\n{\n    p.x = mod(p.x,offset) - offset/2.0;\n    return p;\n}\n\nvec3 Twist(vec3 p, float amount)\n{\n    float c = cos(amount*p.y);\n    float s = sin(amount*p.y);\n    \n    // Create 2D rotation matrix\n    mat2 rm = mat2(c,-s,s,c);\n    p.xz *=rm;\n    return p;\n}\n\n//TODO: TASK1\nvoid Phong(vec3 L, vec3 N, vec3 V, float sh, out float d, out float s)\n{\n    // IMPLEMENT PHONG MODEL HERE\n    \n     \n    vec3 R = normalize(reflect(normalize(L),N));\n    \n    float ks = 1.0;\n    float kd = 1.0;\n    \n    d = kd * max(0.0,dot(normalize(L),N));    //Arbitarily set kd, ks  \n    s = ks * pow(max(0.0,dot(-R,normalize(V))),sh); //Assumed illumination is multiplied in later on\n}\n\n//Main scene distance field function\nfloat CombineSDF(vec3 p, inout int closest)\n{\n      vec3 pn = p*vec3(1.0,0.6,1.0);;\n      pn =  Twist(pn+vec3(0,0,-0.3),sin(iTime)*0.5);//CreateRotationY(iTime)* vec4(p,0);\n      float sd = SphereSDF(pn.xyz);  \n  \n      sd = max(BoxSDF(pn.xyz,vec3(0.95)),-sd); \n      float  torus = TorusSDF(CreateRotationY(iTime)*(p + CreateRotationY(iTime*0.3)*vec3(0.0,0.0,2.5)) ,0.9f,0.4f);\n      sd = min(torus,sd);      \n      float pd =  PlaneSDF(p,23.0); \n      float fin = min(sd,pd);\n      closest = OBJECT;\n      if(fin == pd)\n      { closest = FLOOR_PLANE;}\n      else if(fin == torus) \n      {closest = OBJECT2;}\n      return fin;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    int dummy = 0;\n    return \n    normalize(vec3(\n\t\tCombineSDF(vec3(p.x + EPS, p.y, p.z), dummy) - CombineSDF(vec3(p.x - EPS, p.y, p.z), dummy),\n\t\tCombineSDF(vec3(p.x, p.y + EPS, p.z), dummy) - CombineSDF(vec3(p.x, p.y - EPS, p.z), dummy),\n\t\tCombineSDF(vec3(p.x, p.y, p.z + EPS), dummy) - CombineSDF(vec3(p.x, p.y, p.z - EPS), dummy)\n\t\t));\n}\n\nfloat Trace(Ray r,inout int hit)\n{\n    hit = 0;\n    float t = 0.0f;\n    \n    for(int i =0; i < MAX_STEPS; ++i)\n    {\n       vec3 p = r.Orgin + r.Direction * t;\n       int closest = 0;     \n       float sd = CombineSDF(p, closest);\n           \n       if(sd < EPS)\n       {\n          hit = closest;\n          return t;\n       }\n       t += sd;\n    }\n    return 0.0f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Frag coord normalization \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    // Make center of the screen be (0,0)\n    uv = uv * 2.0 - 1.0; \n    // Aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //FOV\n    float fovDist = tan(FOV_DEG  *0.5 * M_PI / 180.0); \n    uv *= fovDist;\n    \n    //TODO: TASK2\n    //CHANGE CAMERA POSITION AND ORIENTATION HERE:\n    Ray r;\n    \n    vec3 uv2 = vec3(uv,1.0);\t\t//Camera angle stuff tick\n    uv2 *= CreateRotationX(radians(35.0));\n    r.Direction = normalize(uv2);\n    r.Orgin = vec3(0,4,-5.0);\n    \n    \n    int hit = NO_HIT;   // indicates type of the object hit\n    float t = Trace(r,hit);  \n    vec3 hitAt = r.Orgin + r.Direction * t;\n    vec3 N = GetNormal(hitAt);\n    \n    float diff,spec = 0.0;\n    vec3 col = vec3(0); \n    \n    if(hit == OBJECT) // Block\n    {        \n        Phong(LIGHT_DIR,N,-r.Direction,50.0,diff,spec);\n        col =  vec3(0.2,0.04,0.2)+ vec3(0.5,0.0,0.5) * diff + vec3(1.0) * spec;\n    }\n    else if(hit == OBJECT2) // Torus\n    {\n        Phong(LIGHT_DIR,N,-r.Direction,50.0,diff,spec);\n        vec3 baseCol = vec3(clamp(cos(hitAt.y),0.0,1.0), clamp(sin(hitAt.y),0.0,1.0),0.0);\n        col =  0.3 * baseCol + 0.7 * baseCol * diff + vec3(1.0)*spec; \n    } \n    else if(hit == FLOOR_PLANE) // Floor\n    {\n        float ar = iResolution.x/iResolution.y;\n        vec2 planeUV = vec2(80.0+hitAt.x,hitAt.z)/200.0;\n        col = texture(iChannel0, planeUV).xyz; \n       \n        \n        //TODO: TASK3\n        // ADD FLOOR PATTERNS\n        \n        col *= abs(sin(hitAt.x*0.2));\t//Black pattern tick - Consant is arbitray relating to spacing\n        \n        vec3 purple = vec3(0.5,0,0.5);\n        col += 0.5 * abs(sin(hitAt.z*0.2)) * purple; //Purple pattern tick - Front constant does brightness\n\t\t\n        // Stationary Spotlight tick - uses min to avoid over brightness with close objects\n        //col = min(col*(20.0/length(hitAt)),col);\t\n        \n        //Moving Spotlight - again uses lots of arbitary constants\n        float move = abs(sin(iTime)*100.0);\n        vec3 spotPos =vec3(0,0,move); \n        col = min(col*(20.0/length(spotPos-hitAt)),col);\n    \t\n    }\n    \n    else // NO HIT - BACKGROUND COLOR\n    {\n      col = 0.5 + 0.5 * cos(uv.xyx + vec3(0,2.3,3.5));\n    }\n    \n    //TODO: TASK4\n    //SCREEN SPACE EFFECTS\n    \n    //Constant greyscale\n    //float grey = 0.21*col.x + 0.72*col.y + 0.07*col.z;\n    //col = vec3(grey);\n    \n    \n    //Left to Right transistion\n    float screenX = fragCoord.x/iResolution.x;\n    \n    float level = pow(screenX,2.8);\n    float grey = 0.21*col.x + 0.72*col.y + 0.07*col.z;\n    col = vec3(grey*(1.0-level)+col.x*level,grey*(1.0-level)+col.y*level,grey*(1.0-level)+col.z*level);\n    \n        \n    \n   // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}