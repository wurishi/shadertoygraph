{"ver":"0.1","info":{"id":"dttfzr","date":"1700916496","viewed":53,"name":"[WIP] Micro planet 1.1","username":"codeforger","description":"pixel shaded planet","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["pixel","planet"],"hasliked":0,"parentid":"DlyyWd","parentname":"[WIP] Micro Planet"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 planet = vec4(1024/2,576/2,300, 1);\nconst vec3 sunVector = vec3(1, 1, -1);\n//const vec3 sunVector = vec3(1, 0, 0);\nconst int MARCH_MAX = 100;\nconst float DST_MAX = 600.;\nconst float DST_THRESHOLD = .1;\nconst float CONTINENT_SCALE = 1.;\nconst float CONTINENT_HEIGHT = 9.;\nconst float MOUNTAIN_SCALE = 4.;\nconst float MOUNTAIN_HEIGHT = 50.;\nconst float HILL_SCALE = 8.;\nconst float HILL_HEIGHT = 50.;\n\nvec3[] colors = vec3[] (\n\n        vec3( 1.0, 0.0, 0.0 ),\n        vec3( 0.2, 0.5, 0.2 ),\n        vec3( .0, 0., 1. ),\n        vec3( 0.5, 1.0, 0.5 ),\n        vec3( 0.5, 0.5, 1.0 ),\n        vec3( 0.5, 1.0, 1.0 ),\n        vec3( 1.0, 0.5, 1.0 ),\n        vec3( 1.0, 1.0, 0.5 )\n);\n\nvec2 GetGradient(vec2 intPos, float t) {\n    \n    // Uncomment for calculated rand\n    float rand = fract(sin(dot(intPos, vec2(12.9898, 78.233))) * 43758.5453);;\n    \n    // Texture-based rand (a bit faster on my GPU)\n    //float rand = texture(iChannel0, intPos / 64.0).r; \n    \n    // Rotate gradient: random starting rotation, random rotation rate\n    float angle = 6.283185 * rand + 4.0 * t * rand;\n    return vec2(cos(angle), sin(angle));\n}\n\n\nfloat Pseudo3dNoise(vec3 pos) {\n    vec2 i = floor(pos.xy);\n    vec2 f = pos.xy - i;\n    vec2 blend = f * f * (3.0 - 2.0 * f);\n    float noiseVal = \n        mix(\n            mix(\n                dot(GetGradient(i + vec2(0, 0), pos.z), f - vec2(0, 0)),\n                dot(GetGradient(i + vec2(1, 0), pos.z), f - vec2(1, 0)),\n                blend.x),\n            mix(\n                dot(GetGradient(i + vec2(0, 1), pos.z), f - vec2(0, 1)),\n                dot(GetGradient(i + vec2(1, 1), pos.z), f - vec2(1, 1)),\n                blend.x),\n        blend.y\n    );\n    return noiseVal / 0.7; // normalize to about [-1..1]\n}\n\nfloat getNoiseHeight(vec3 vecToPlanet) {\n\n    float ang = atan(vecToPlanet.x / vecToPlanet.z) + iTime/3.;\n    float noise = (Pseudo3dNoise(vec3(cos(ang), vecToPlanet.y/(300./2.), sin(ang)) * CONTINENT_SCALE))/CONTINENT_HEIGHT;\n    noise += (Pseudo3dNoise(vec3(cos(ang), vecToPlanet.y/(300./2.), sin(ang)) * MOUNTAIN_SCALE))/MOUNTAIN_HEIGHT;\n    noise += (Pseudo3dNoise(vec3(cos(ang), vecToPlanet.y/(300./2.), sin(ang)) * HILL_SCALE))/HILL_HEIGHT;\n    \n    return noise;\n}\n\nvec4 colorAndDistanceToScene(vec3 point){\n\n    vec4 retPlanet = vec4(colors[int(planet.a)], 0);\n    vec3 vecToPlanet = planet.xyz - point;\n    float noise = getNoiseHeight(vecToPlanet);\n    float planetRawDst = distance(point, planet.xyz + noise * vecToPlanet) - 200.;\n    retPlanet.a = planetRawDst; // + (Pseudo3dNoise(vec3((point.x)/60. + iTime, point.y/60.,0))*20.);\n    retPlanet.xyz += (distance(point, planet.xyz) - 200.) / 20.;\n    if(abs(vecToPlanet.y) > 150.) {\n        retPlanet.xyz = clamp(retPlanet.xyz + (vec3(1)*((abs(vecToPlanet.y)-150.)/50.)), vec3(0), vec3(1));\n    }\n\n    if((distance(point, planet.xyz) - 200.) / 20. > .5) {\n        retPlanet.xyz = (vec3(1));\n    }\n\n    vec4 retSea = vec4(colors[2], 0);\n    retSea.a = distance(point, planet.xyz) - 200.;\n    \n    retSea.xyz -= planetRawDst / 60.;\n\n    return retPlanet.a < retSea.a ? retPlanet: retSea;\n}\n\nconst vec4 vec4Zero = vec4(0); \n\nvec4[2] march(vec2 uv) {\n    float dst = 0.;\n    for(int i = 0; i < MARCH_MAX; i++) {\n        vec4 colAndDist = colorAndDistanceToScene(vec3(uv, dst));\n        dst += colAndDist.a;\n        if(dst > DST_MAX) {\n            return vec4[2](vec4Zero, vec4(i, vec4Zero.gba));\n        }\n        \n        if(colAndDist.a < DST_THRESHOLD){\n            return vec4[2](vec4(colAndDist.xyz, dst), vec4(i, vec4Zero.gba));\n        }\n        \n    }\n    \n    return vec4[2](vec4Zero, vec4(100, vec4Zero.gba));\n}\n\nfloat marchToSun(vec3 uv) {\n    vec3 uv2 = vec3(uv.xy, uv.z - DST_THRESHOLD*4.);\n    float dst = 0.;\n    for(int i = 0; i < MARCH_MAX; i++) {\n        vec4 colAndDist = colorAndDistanceToScene(vec3(uv2 + (sunVector * dst)));\n        dst += colAndDist.a;\n        if(dst > DST_MAX) {\n            return 1.-float(i)/float(MARCH_MAX);\n        }\n        \n        if(colAndDist.a < DST_THRESHOLD){\n            return 0.;\n        }\n        \n    }\n    \n    return 1.;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    planet = vec4(iResolution.xy/2.,300, 1);\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord - vec2(ivec2(fragCoord)%8);\n    //vec2 uv = fragCoord;\n\n\n    vec4[2] marchInfo = march(uv);\n    vec4 colorAndDist = marchInfo[0],\n        hitInfo = marchInfo[1];\n    float dst = (1.-((colorAndDist.a - 100.)/DST_MAX));\n    float itrs = clamp(float(hitInfo.x)/float(MARCH_MAX), 0., .5);\n    float sunLightRaw = marchToSun(vec3(uv, colorAndDist.a));\n    float sunLightPlanet = (colorAndDist.a == DST_MAX ? 0. : sunLightRaw);\n    float sunLight = sunLightRaw;\n    float sunLightAtmos =  (((sunLightRaw) *marchToSun(vec3(uv, planet.z - sunVector.z*length(planet.xy-uv)))) / 4. * 3. + .25);\n    // Output to screen\n    fragColor = vec4(clamp(\n    colorAndDist.xyz*dst * sunLight + (vec3(.7, .7, 1) * itrs * sunLightAtmos),\n    vec3(0,0,0),\n    vec3(1,1,1)\n    ) ,1.0);\n    //fragColor = vec4(vec3(.7, .7, 1) * itrs * sunLightAtmos,1.0);\n    //fragColor = vec4(colorAndDist.aaaa);\n    //fragColor = vec4(colorAndDist.xyz, 0);\n}","name":"Image","description":"","type":"image"}]}