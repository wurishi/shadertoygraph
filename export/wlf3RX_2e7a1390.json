{"ver":"0.1","info":{"id":"wlf3RX","date":"1557104176","viewed":324,"name":"G2 Multivector-Valued Functions","username":"Dodecaplex","description":"Visualization of multivector-valued functions in the geometric algebra of R2.\nEdit inputs A and B, and their output, C = f(A,B) in the disp function.\nDrag the mouse up / down to view inputs or outputs. Drag right / left to view inputs A and B.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["geometric","clifford","multivector","bivector","spinor","rotor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// G2 MULTIVECTOR-VALUED FUNCTIONS - Tony Chiodo\n// Reference: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4361175/\n\n// G2 basis blades\n#define E00 vec4(1.0, 0.0, 0.0, 0.0)\n#define E10 vec4(0.0, 1.0, 0.0, 0.0)\n#define E02 vec4(0.0, 0.0, 1.0, 0.0)\n#define E12 vec4(0.0, 0.0, 0.0, 1.0)\n\n// multivector component indices\n#define e00 0\n#define e10 1\n#define e02 2\n#define e12 3\n\n// G2 multivector is representable with vec4\nvec4 g2mv(in float re, in float x, in float y, in float im) { return vec4(re, x, y, im); }\n\n// Grade 1 components are just regular vectors from R2\n// v = (x, y) => x*E10 + y*E02\nvec4 g2vec(in float x, in float y) { return g2mv(0.0,   x,   y, 0.0); }\nvec4 g2vec(in vec2 v)              { return g2mv(0.0, v.x, v.y, 0.0); }\n\n// Polar form vector\nvec4 g2polar(in float r, in float t) { return r*g2vec(cos(t), sin(t)); }\n\n// The even-graded subalgebra of G2 is isomorphic to the complex numbers\n// z = (re, im) => re*E00 + im*E12\nvec4 g2complex(in float re, in float im) { return g2mv( re, 0.0, 0.0,  im); }\nvec4 g2complex(in vec2 z)                { return g2mv(z.x, 0.0, 0.0, z.y); }\n\n// Polar form complex numbers (r*e**(i*t))\nvec4 g2rotor(in float r, in float t) { return r*g2complex(cos(t), sin(t)); }\n\nvec4 g2inner(in vec4 a, in vec4 b) { // symmetric part (a . b)\n    return g2mv(\n        a[e00]*b[e00] + a[e10]*b[e10] + a[e02]*b[e02] - a[e12]*b[e12],\n        a[e10]*b[e00] + a[e00]*b[e10]                                ,\n        a[e02]*b[e00]                 + a[e00]*b[e02]                ,\n        a[e12]*b[e00]                                 + a[e00]*b[e12]\n    );\n}\n\nvec4 g2outer(in vec4 a, in vec4 b) { // antisymmetric part (a ^ b)\n    return g2mv(\n\t\t          0.0                                                ,\n                                        a[e12]*b[e02] - a[e02]*b[e12],\n                      - a[e12]*b[e10]                 + a[e10]*b[e12],\n                      - a[e02]*b[e10] + a[e10]*b[e02]\n    );\n}\n\nvec4 g2mul(in vec4 a, in vec4 b) { // symmetric + antisymmetric (a.b + a^b)\n    return g2mv(\n        a[e00]*b[e00] + a[e10]*b[e10] + a[e02]*b[e02] - a[e12]*b[e12],\n        a[e10]*b[e00] + a[e00]*b[e10] + a[e12]*b[e02] - a[e02]*b[e12],\n  \t    a[e02]*b[e00] - a[e12]*b[e10] + a[e00]*b[e02] + a[e10]*b[e12],\n  \t\ta[e12]*b[e00] - a[e02]*b[e10] + a[e10]*b[e02] + a[e00]*b[e12]\n\t);\n}\n\nvec4 g2conj(in vec4 v) { return g2mv(v[e00], -v[e10], -v[e02], -v[e12]); } // ~v\nvec4 g2rev (in vec4 v) { return g2mv(v[e00],  v[e10],  v[e02], -v[e12]); } // v**R\n\nvec4 g2amp2 (in vec4 v) { return g2mul(v, g2conj(v)); } // amplitude**2\nvec4 g2norm2(in vec4 v) { return g2mul(v, g2rev (v)); } // norm**2\n\nvec4 g2inv(in vec4 v) { return g2conj(v) / g2amp2(v)[e00]; } // v**-1\n\nvec4 g2exp(in vec4 v) { // approx. e**v\n    vec4 result = E00;\n    vec4 u = v;\n    float fact = 1.0;\n    for (int i = 1; i < 16; ++i) {\n    \tresult += (u = g2mul(u,v)) / (fact *= float(i));\n    }\n    return result;\n}\n\n// color representation of a multivector\nvec3 g2rgb(in vec4 v) {\n    float scalar = sqrt(2.0)/2.0 * v[e00];\n    vec2  vector = vec2(v[e10], v[e02]);\n    float bivect = sqrt(2.0)/2.0 * v[e12];\n    return vec3(\n    \tscalar + vector.x,\n        scalar + vector.y,\n        scalar - bivect\n    );\n}\n\n// remap [-1, +1] color range to [0, 1]\n// mid-gray => g2mv(0, 0, 0, 0)\nvec3 g2col(in vec4 v) { return 0.5*(1.0 + g2rgb(v)); }\n\nvec4 disp(in vec2 p, in vec2 m) {\n    \n    vec4 A, B, C;\n\t//// EDIT: INPUT MULTIVECTOR FIELDS ////\n    \n    /* rotozoom *\n    // A is a pure vector field, plus an oscillating offset\n    A = g2vec(p);\n    A += 2.0*g2vec(cos(iTime*0.5736), sin(iTime*1.1674));\n    \n    // B is a pure complex field with time-varying phase and an oscillating magnitude\n    B = g2rotor(2.0*sin(0.33*iTime), iTime);\n    \n    // C is the geometric product, AB\n    // vectors in A are scaled and rotated by the rotors in B\n    C = g2mul(A,B);\n\t/**/\n    \n    /* multivector fractals *\n\t// A is a mostly complex field, plus a small oscillating vector component\n    A = g2complex(p);\n    A += 0.125*cos(0.75*iTime)*g2vec(p);\n    \n    // B is also a multivector field, but with a more uniform complex component\n    B = g2rotor(sin(0.33*iTime), iTime); // multivector julia set\n    // B = g2rotor(length(p), atan(p.y,p.x)); // multivector mandelbrot set\n    B += 0.5*sin(0.65*iTime)*g2vec(p);\n    \n    // iteration: C = CC + B\n    // the vector components add additional structure to the familiar pure complex form\n    C = A;\n    for (int i = 0; i < 32; ++i) {\n        C = g2mul(C,C)+B;\n    }\n    /**/\n    \n    /* mobius transformation */\n    A = g2complex(p);\n    \n    vec4 a = g2rotor(cos(iTime*0.13), iTime*0.8);\n    vec4 b = g2complex(cos(iTime*0.33), cos(iTime*0.22));\n    vec4 c = g2rotor(cos(iTime*0.59), -iTime*0.5);\n    vec4 d = g2complex(cos(iTime*0.42), cos(iTime*0.27));\n    \n    B = g2mul(g2mul(a, A) + b, g2inv(g2mul(c, A) + d));\n\n    C = g2mul(E10, B); // display (re,im) as (x,y)\n\n    /**/\n\n    /////////////////////////////////////////\n\n\treturn\n    /**\n        C; \n    /*/\n    \tstep(m.y, 1.0) > 0.0 ?\n    \tstep(m.x, 1.0) > 0.0 ? A : B : C;\n    /**/\n}\n\n#define SCALE 1.5\nvec2 rectify(vec2 v) { return SCALE*(v+v-iResolution.xy)/iResolution.y; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 m = fragCoord / iMouse.xy;\n    vec2 p = rectify(fragCoord);\n    \n    fragColor = vec4(\n        fract(g2col(disp(p,m))),\n        1.0\n    );\n}","name":"Image","description":"","type":"image"}]}