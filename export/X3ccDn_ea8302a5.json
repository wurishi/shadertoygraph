{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"\n// Noise function for geometric patterns\nfloat hash(vec2 p) {\n    p = fract(p * vec2(234.34, 435.345));\n    p += dot(p, p + 2214.23);\n    return fract(p.x * p.y);\n}\n\nfloat valueNoise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f); // Smoothstep\n    \n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    \n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nfloat geometricPattern(vec3 p) {\n    // Create hexagonal grid\n    vec2 hexCoord = p.xy * 2.0;\n    hexCoord.x *= 1.7320508; // sqrt(3)\n    vec2 r = vec2(1.0, 1.7320508);\n    vec2 h = r * 0.5;\n    vec2 a = mod(hexCoord, r) - h;\n    vec2 b = mod(hexCoord + h, r) - h;\n    \n    // Combine with triangular patterns\n    float hexDist = min(dot(a, a), dot(b, b));\n    float triPattern = abs(p.x) + abs(p.y) + abs(p.z);\n    \n    // Add noise variation\n    float noise = valueNoise(p.xy * 2.0 + iTime * 0.1) * 0.5;\n    \n    return min(hexDist, triPattern) + noise;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float time = iTime * 0.3;\n    \n    // Camera setup with angular movement\n    vec3 ro = vec3(cos(time) * 3.0, sin(time * 0.7) * 2.0, -5.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    // Rotate ray direction for more angular movement\n    float c = cos(time * 0.5);\n    float s = sin(time * 0.5);\n    rd.xz = mat2(c, -s, s, c) * rd.xz;\n    \n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    \n    // Color palette for hard surface look\n    vec3 color1 = vec3(0.2, 0.4, 0.8); // Steel blue\n    vec3 color2 = vec3(0.8, 0.2, 0.3); // Industrial red\n    vec3 color3 = vec3(0.1, 0.1, 0.2); // Dark accent\n    \n    // Ray marching loop\n    for(int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        \n        // Apply geometric transformations\n        p = abs(p);\n        p = mod(p, 4.0) - 2.0;\n        \n        float d = geometricPattern(p) * 0.5;\n        \n        if(d < 0.001 || t > 20.0) break;\n        \n        // Color based on geometric pattern\n        float pattern = geometricPattern(p * 0.5);\n        vec3 patternColor = mix(color1, color2, pattern);\n        patternColor = mix(patternColor, color3, valueNoise(p.xy + time));\n        \n        col += patternColor * 0.1 / (1.0 + abs(d) * 4.0);\n        \n        t += d * 0.5;\n    }\n    \n    // Add sharp highlights\n    col *= 1.0 + pow(max(sin(time * 2.0), 0.0), 20.0);\n    \n    // Contrast and color adjustment\n    col = pow(col, vec3(0.8));\n    col = col / (1.0 + col);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"X3ccDn","date":"1734968832","viewed":81,"name":"SomeoneMakeThisBetter...","username":"profmitchell","description":"Volumetric light kinda? idk...","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["volumetric"],"hasliked":0,"parentid":"","parentname":""}}