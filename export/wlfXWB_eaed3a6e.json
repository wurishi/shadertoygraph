{"ver":"0.1","info":{"id":"wlfXWB","date":"1564159970","viewed":507,"name":"Magic Particles Buffer","username":"TambakoJaguar","description":"I used a buffer for the positions and colors for my famous Magic Particles to make it faster!\n3000 particles ist still quite fast!","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["buffer","magicparticles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Gets the position of a particle in function of its number and the time\nvec2 getParticlePosition(int partnr)\n{  \n   vec2 pos = vec2(mod(float(partnr+1), iResolution.x)/(iResolution.x+1.), (float(partnr)/(iResolution.x))/(iResolution.y+1.));\n   return (texture(iChannel0, pos)).xy;\n}\n\n// Gets the position of the main particle in function of the time\nvec2 getParticlePosition_mp()\n{\n   vec2 ppos = vec2(harms(main_x_freq, main_x_amp, main_x_phase, time2), harms(main_y_freq, main_y_amp, main_y_phase, time2)) + middlepoint;\n   return gen_scale*ppos;\n}\n\n// Gets the rgb color of a particle in function of its intensity and number\nvec3 getParticleColor(int partnr, float pint)\n{\n   vec2 pos = vec2(mod(float(partnr+1), iResolution.x)/(iResolution.x+1.), (50. + float(partnr)/(iResolution.x))/(iResolution.y+1.));\n   return (pint*texture(iChannel0, pos)).xyz;  \n}\n\n// Gets the rgb color the main particle in function of its intensity\nvec3 getParticleColor_mp( float pint)\n{\n   float hue;\n   float saturation;\n   \n   saturation = 0.75/pow(pint, 2.5) + mp_saturation;\n   hue = hue_time_factor*time2 + mp_hue;\n\n   return hsv2rgb(vec3(hue, saturation, pint));\n}\n\n// Main function to draw particles, outputs the rgb color.\nvec3 drawParticles(vec2 uv)\n{  \n    // Here the time is \"stetched\" with the time factor, so that you can make a slow motion effect for example\n    time2 = time_factor*iTime;\n    vec3 pcol = vec3(0.);\n    // Main particles loop\n    for (int i=1; i<nb_particles; i++)\n    {\n        pst = getParticleStartTime(i); // Particle start time\n        plt = mix(part_life_time_min, part_life_time_max, random(float(i*2-35))); // Particle life time\n        time4 = mod(time2 - pst, plt);\n        time3 = time4 + pst;\n\n        runnr = floor((time2 - pst)/plt);  // Number of the \"life\" of a particle\n        vec2 ppos = getParticlePosition(i);\n        float dist = distance(uv, ppos);\n        if (dist<0.05) // When the current point is further than a certain distance, its impact is neglectable\n        {\n            // Draws the eight-branched star\n            // Horizontal and vertical branches\n            vec2 uvppos = uv - ppos;\n            float distv = distance(uvppos*part_starhv_dfac + ppos, ppos);\n            float disth = distance(uvppos*part_starhv_dfac.yx + ppos, ppos);\n            // Diagonal branches\n            vec2 uvpposd = 0.707*vec2(dot(uvppos, vec2(1., 1.)), dot(uvppos, vec2(1., -1.)));\n            float distd1 = distance(uvpposd*part_stardiag_dfac + ppos, ppos);\n            float distd2 = distance(uvpposd*part_stardiag_dfac.yx + ppos, ppos);\n            // Initial intensity (random)\n            float pint0 = mix(part_int_factor_min, part_int_factor_max, random(runnr*4. + float(i-55)));\n            // Middle point intensity star inensity\n            float pint1 = 1./(dist*dist_factor + 0.015) + part_starhv_ifac/(disth*dist_factor + 0.01) + part_starhv_ifac/(distv*dist_factor + 0.01) + part_stardiag_ifac/(distd1*dist_factor + 0.01) + part_stardiag_ifac/(distd2*dist_factor + 0.01);\n\n\n            // Intensity curve and fading over time\n            float pint = pint0*(pow(pint1, ppow)/part_int_div)*(-time4/plt + 1.);\n\n            // Initial growing of the paricle's intensity\n            pint*= smoothstep(0., grow_time_factor*plt, time4);\n            // \"Sparkling\" of the particles\n            float sparkfreq = clamp(part_spark_time_freq_fact*time4, 0., 1.)*part_spark_min_freq + random(float(i*5 + 72) - runnr*1.8)*(part_spark_max_freq - part_spark_min_freq);\n            pint*= mix(part_spark_min_int, part_spark_max_int, random(float(i*7 - 621) - runnr*12.))*sin(sparkfreq*twopi*time2)/2. + 1.;\n\n            // Adds the current intensity to the global intensity\n            pcol+= getParticleColor(i, pint);\n        }\n    }\n    // Main particle\n    vec2 ppos = getParticlePosition_mp();\n    float dist = distance(uv, ppos);\n    //if (dist<0.25)\n    //{\n        // Draws the eight-branched star\n        // Horizontal and vertical branches\n        vec2 uvppos = uv - ppos;\n        float distv = distance(uvppos*part_starhv_dfac + ppos, ppos);\n        float disth = distance(uvppos*part_starhv_dfac.yx + ppos, ppos);\n        // Diagonal branches\n        vec2 uvpposd = 0.7071*vec2(dot(uvppos, vec2(1., 1.)), dot(uvppos, vec2(1., -1.)));\n        float distd1 = distance(uvpposd*part_stardiag_dfac + ppos, ppos);\n        float distd2 = distance(uvpposd*part_stardiag_dfac.yx + ppos, ppos);\n        // Middle point intensity star inensity\n        float pint1 = 1./(dist*dist_factor + 0.015) + part_starhv_ifac/(disth*dist_factor + 0.01) + part_starhv_ifac/(distv*dist_factor + 0.01) + part_stardiag_ifac/(distd1*dist_factor + 0.01) + part_stardiag_ifac/(distd2*dist_factor + 0.01);\n        \n        if (part_int_factor_max*pint1>6.)\n        {\n            float pint = part_int_factor_max*(pow(pint1, ppow)/part_int_div)*mp_int;\n            pcol+= getParticleColor_mp(pint);\n        }\n    //}\n    return pcol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xx;\n    \n    // Background gradient\n    vec3 pcolor = vec3(0., (0.6 - uv.y)/6., (1. - uv.y)/5.);\n\n    pcolor+= drawParticles(uv);\n       \n    fragColor = vec4(pcolor, 0.);\n    //fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Gets the rgb color of a particle in function of its intensity and number\nvec3 getParticleColor(int partnr)\n{\n   float hue;\n   float saturation;\n\n   time2 = time_factor*iTime;\n   pst = getParticleStartTime(partnr); // Particle start time\n   plt = mix(part_life_time_min, part_life_time_max, random(float(partnr*2-35))); // Particle life time\n   runnr = floor((time2 - pst)/plt);  // Number of the \"life\" of a particle \n    \n   saturation = mix(part_min_saturation, part_max_saturation, random(float(partnr*6 + 44) + runnr*3.3));\n   hue = mix(part_min_hue, part_max_hue, random(float(partnr + 124) + runnr*1.5)) + hue_time_factor*time2;\n    \n   return hsv2rgb(vec3(hue, saturation, 1.0));\n}\n\n// Gets the position of a particle in function of its number and the time\nvec2 getParticlePosition(int partnr)\n{  \n   time2 = time_factor*iTime;    \n   pst = getParticleStartTime(partnr); // Particle start time\n   plt = mix(part_life_time_min, part_life_time_max, random(float(partnr*2-35))); // Particle life time\n   time4 = mod(time2 - pst, plt);\n   time3 = time4 + pst;\n   runnr = floor((time2 - pst)/plt);  // Number of the \"life\" of a particle    \n    \n   // Particle \"local\" time, when a particle is \"reborn\" its time starts with 0.0\n   float part_timefact = mix(part_timefact_min, part_timefact_max, random(float(partnr*2 + 94) + runnr*1.5));\n   float ptime = (runnr*plt + pst)*(-1./part_timefact + 1.) + time2/part_timefact;   \n   vec2 ppos = vec2(harms(main_x_freq, main_x_amp, main_x_phase, ptime), harms(main_y_freq, main_y_amp, main_y_phase, ptime)) + middlepoint;\n   \n   // Particles randomly get away the main particle's orbit, in a linear fashion\n   vec2 delta_pos = part_max_mov*(vec2(random(float(partnr*3-23) + runnr*4.), random(float(partnr*7+632) - runnr*2.5))-0.5)*(time3 - pst);\n   \n   // Calculation of the effect of the gravitation on the particles\n   vec2 grav_pos = gravitation*pow(time4, 2.)/250.;\n   return (ppos + delta_pos + grav_pos)*gen_scale;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    int i = int(fragCoord.x + floor(fragCoord.y)*iResolution.x);\n    if (i<nb_particles)\n    {\n       vec2 ppos = getParticlePosition(i);\n       fragColor = vec4(ppos, 0, 0);\n    }\n    \n    i = int(fragCoord.x + floor(fragCoord.y-50.)*iResolution.x);\n    if (i>=0 && i<nb_particles)\n    {\n       vec3 pcol = getParticleColor(i);\n       fragColor = vec4(pcol, 0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n\"Magic particles\" by Emmanuel Keller aka Tambako - December 2015\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define twopi 6.28319\n// Please be careful, setting complexity > 1 may crash your browser!\n// 1: for mac computers\n// 2: for computers with normal graphic card\n// 3: for computers with good graphic cards\n// 4: for gaming computers\n#define complexity 1\n\n// General particles constants\n#if complexity == 1\nconst int nb_particles = 3000;                                  // Number of particles on the screen at the same time. Be CAREFUL with big numbers of particles, 1000 is already a lot!\n#elif complexity == 2\nconst int nb_particles = 160;\n#elif complexity == 3\nconst int nb_particles = 280;\n#elif complexity == 4\nconst int nb_particles = 100;\n#endif\nconst vec2 gen_scale = vec2(0.60, 0.45);                      // To scale the particle positions, not the particles themselves\nconst vec2 middlepoint = vec2(0.35, 0.15);                    // Offset of the particles\n\n// Particle movement constants\nconst vec2 gravitation = vec2(-0., -4.5);                     // Gravitation vector\nconst vec3 main_x_freq = vec3(0.4, 0.66, 0.78);               // 3 frequences (in Hz) of the harmonics of horizontal position of the main particle\nconst vec3 main_x_amp = vec3(0.8, 0.24, 0.18);                // 3 amplitudes of the harmonics of horizontal position of the main particle\nconst vec3 main_x_phase = vec3(0., 45., 55.);                 // 3 phases (in degrees) of the harmonics of horizontal position of the main particle\nconst vec3 main_y_freq = vec3(0.415, 0.61, 0.82);             // 3 frequences (in Hz) of the harmonics of vertical position of the main particle\nconst vec3 main_y_amp = vec3(0.72, 0.28, 0.15);\t              // 3 amplitudes of the harmonics of vertical position of the main particle\nconst vec3 main_y_phase = vec3(90., 120., 10.);\t              // 3 phases (in degrees) of the harmonics of vertical position of the main particle\nconst float part_timefact_min = 6.;                           // Specifies the minimum how many times the particle moves slower than the main particle when it's \"launched\"\nconst float part_timefact_max = 20.;                          // Specifies the maximum how many times the particle moves slower than the main particle when it's \"launched\"\nconst vec2 part_max_mov = vec2(0.32, 0.32);                   // Maxumum movement out of the trajectory in display units / s\n\n// Particle time constants\nconst float time_factor = 1.;                                // Time in s factor, <1. for slow motion, >1. for faster movement\nconst float start_time = 2.5;                                  // Time in s needed until all the nb_particles are \"launched\"\nconst float grow_time_factor = 0.15;                          // Time in s particles need to reach their max intensity after they are \"launched\"\n#if complexity == 1\nconst float part_life_time_min = 0.8;                         // Minimum life time in s of a particle\nconst float part_life_time_max = 1.6;                         // Maximum life time in s of a particle\n#elif complexity == 2\nconst float part_life_time_min = 1.0;\nconst float part_life_time_max = 2.2;\n#elif complexity == 3\nconst float part_life_time_min = 1.1;\nconst float part_life_time_max = 3.2;\n#elif complexity == 4\nconst float part_life_time_min = 1.2;\nconst float part_life_time_max = 4.0;\n#endif\n\n// Particle intensity constants\nconst float part_int_div = 150000.;                            // Divisor of the particle intensity. Tweak this value to make the particles more or less bright\nconst float part_int_factor_min = 0.1;                        // Minimum initial intensity of a particle\nconst float part_int_factor_max = 3.2;                        // Maximum initial intensity of a particle\nconst float part_spark_min_int = 0.25;                        // Minimum sparkling intensity (factor of initial intensity) of a particle\nconst float part_spark_max_int = 0.88;                        // Minimum sparkling intensity (factor of initial intensity) of a particle\nconst float part_spark_min_freq = 2.5;                        // Minimum sparkling frequence in Hz of a particle\nconst float part_spark_max_freq = 6.0;                        // Maximum sparkling frequence in Hz of a particle\nconst float part_spark_time_freq_fact = 0.35;                 // Sparkling frequency factor at the end of the life of the particle\nconst float mp_int = 12.;                                     // Initial intensity of the main particle\nconst float dist_factor = 3.;                                 // Distance factor applied before calculating the intensity\nconst float ppow = 2.3;                                      // Exponent of the intensity in function of the distance\n\n// Particle color constants\nconst float part_min_hue = -0.13;                             // Minimum particle hue shift (spectrum width = 1.)\nconst float part_max_hue = 0.13;                              // Maximum particle hue shift (spectrum width = 1.)\nconst float part_min_saturation = 0.5;                        // Minimum particle saturation (0. to 1.)\nconst float part_max_saturation = 0.9;                        // Maximum particle saturation (0. to 1.)\nconst float hue_time_factor = 0.035;                          // Time-based hue shift\nconst float mp_hue = 0.5;                                     // Hue (shift) of the main particle\nconst float mp_saturation = 0.18;                             // Saturation (delta) of the main particle\n\n// Particle star constants\nconst vec2 part_starhv_dfac = vec2(19., 0.32);                 // x-y transformation vector of the distance to get the horizontal and vertical star branches\nconst float part_starhv_ifac = 0.22;                          // Intensity factor of the horizontal and vertical star branches\nconst vec2 part_stardiag_dfac = vec2(13., 0.61);              // x-y transformation vector of the distance to get the diagonal star branches\nconst float part_stardiag_ifac = 0.14;                        // Intensity factor of the diagonal star branches\n\n// Particle motion blur constants\n//#define motion_blur\nconst float mb_time = 0.02;                                   // Time shift of the motion blur in s\nconst int mb_nb_samples = 2;                                  // Number of steps (let number of samples to 1 unless you have a quite powerful GPU)\n\n// Variables\nfloat pst;\nfloat plt;\nfloat runnr;\nfloat time2;\nfloat time3;\nfloat time4;\n\n// From https://www.shadertoy.com/view/ldtGDn\nvec3 hsv2rgb (vec3 hsv) { // from HSV to RGB color vector\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z*(0.63*hsv.y*(cos(twopi*(hsv.x + vec3(0.0, 2.0/3.0, 1.0/3.0))) - 1.0) + 1.0);\n}\n\n// Simple \"random\" function\nfloat random(float co)\n{\n    return fract(sin(co*12.989) * 43758.545);\n}\n\n// Gets the time at which a paticle is starting its \"life\"\nfloat getParticleStartTime(int partnr)\n{\n    return start_time*random(float(partnr*2));\n}\n\n// Harmonic calculation, base is a vec4\nfloat harms(vec3 freq, vec3 amp, vec3 phase, float time)\n{\n   float val = 0.;\n   for (int h=0; h<3; h++)\n      val+= amp[h]*cos(time*freq[h]*twopi + phase[h]/360.*twopi);\n   return (1. + val)/2.;\n}\n","name":"Common","description":"","type":"common"}]}