{"ver":"0.1","info":{"id":"mtjyWd","date":"1702512512","viewed":82,"name":"Lamba Paths","username":"MisterSirCode","description":"Just a fun little twist on my normal map maker / fractal projects...\n\nFractal can be changed in the Common Tab","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["fractal","julia","normal"],"hasliked":0,"parentid":"fdcyRX","parentname":"Temporal Normal Map"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float ct = texture(iChannel2, vec2(0)).x; // grab custom time from buffer c\n    \n    // If you want a different fractal, change the \"Mandelbrot\" function in Buffer A\n    \n    vec4 fr = texture(iChannel0, uv);\n    vec4 cfr = texture(iChannel1, uv);\n    \n    cfr = mix(fr, cfr, clamp(ct, 0.0, 1.0)); \n    // Transition to the denoised image after letting the normal map sample for a couple seconds\n    \n\n    fragColor = cfr;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"bool useSquareDistribution = false;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n    vec2 uv = ((2. * fragCoord - res) / res.x) * 2.5;\n    vec4 pr = texture(iChannel0, fragCoord / res);\n    if (useSquareDistribution) {\n        vec2 pad = 1.333 * hash21(mod(iTime, 1000.)) / res;\n        uv += pad;\n    } else {\n        vec2 pad = diskPt(hash21(mod(iTime, 1000.))) / res;\n        uv += pad;\n    }\n    \n    uv += 0.5;\n    vec3 m = mandelbrot(uv, uv, 100., iTime / 4.0);\n    float fr = sqrt(m.x);\n        \n    fr = clamp(fr, 0., 1.) * 6.0;\n    fr = mix(fr, pr.x, .999);\n    \n    fragColor = vec4(vec2(fr), res);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// This layer just grabs the normal map\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n    vec2 uv = fragCoord / res;\n    vec2 pix = 1. / iResolution.xy / 32.;\n    float h = 0.0, dx = 0.0, dy = 0.0;\n    float tex;\n    for (int nml = 0; nml < 3; nml++) {\n        vec2 tuv = uv;\n        if (nml == 1) tuv += vec2(pix.x, 0.0);\n        if (nml == 2) tuv += vec2(0.0, pix.y);\n        tex = texture(iChannel0, tuv).x;\n        if (nml == 0) h = tex;\n        if (nml == 1) dx = tex;\n        if (nml == 2) dy = tex;\n    }\n    vec2 dxy = h - vec2(dx, dy);\n    vec3 norm = normalize(vec3(dxy * 0.1 / pix, 1.0));\n    norm.xy = norm.xy / 2.0 + 0.5;\n    fragColor = vec4(norm, 0.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n// This layer temporally denoises the normal map to make it look nicer\n\nbool useSquareDistribution = true;\n\n// For once it seems the square distribution is better. Not sure why, but the normal map looks nicer with it.\n\nvec2 prRes = vec2(0);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n    vec2 uv = fragCoord / res;\n    vec3 pr = texture(iChannel0, uv).xyz;\n    if (useSquareDistribution) {\n        vec2 pad = 0.5 * hash21(mod(iTime, 1000.)) / res;\n        uv += pad;\n    } else {\n        vec2 pad = diskPt(hash21(mod(iTime, 1000.))) / res;\n        uv += pad;\n    }\n    \n    vec4 fr = texture(iChannel1, uv);\n    \n    float fac = .9;\n        \n    fr.x = mix(fr.x, pr.x, fac);\n    fr.y = mix(fr.y, pr.y, fac);\n    fr.z = mix(fr.z, pr.z, fac);\n    \n    fragColor = vec4(fr.xyz, res);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Extra\n\nvec2 cMul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 cSin(vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 cCos(vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\nvec2 cDiv(vec2 a, vec2 b) {\n    float d = dot(b, b);\n    return vec2(dot(a, b), a.y * b.x - a.x * b.y ) / d;\n}\n\n// Main Fractal\n\nvec3 mandelbrot(vec2 z, vec2 c, float iter, float time) {\n    float l = 0.0;\n    for (l = 0.0; l < iter; l += 1.0) {\n        z = cMul(vec2(sin(time / 4.0), cos(time / 4.0)), cMul(z, 1.0 - z));\n        if(dot(z, z) > 65536.0) break;\n    }\n    \n    // This is a smooth iteration system. Only change the fractal above.\n\n    // Though this may not work with non-mandelbrot derived fractals. Beware.\n    \n    l = l - log2(log2(dot(z, z))) + 4.0;\n    if(dot(z, z) < 65536.0) l = iter; // color the inside white\n    l /= iter;\n    \n    // return the iterations and z for further processing.\n    return vec3(l, z);\n}\n\n\n// Stuff for the temporal denoising:\n\nvec2 hash21(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 diskPt(vec2 p) {\n    return sqrt(p.x) * vec2(sin(6.2832 * p.y), cos(6.2832 * p.y));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n// This layer basically just runs a little timer and sends the data to the mainImage\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 pr = texture(iChannel0, vec2(0));\n    float ct = pr.w; // grab current time from last frame\n    if (iTime > 2.)\n        ct += .01;\n\n    fragColor = vec4(vec2(ct), fragCoord / iResolution.xy);\n}","name":"Buffer D","description":"","type":"buffer"}]}