{"ver":"0.1","info":{"id":"mdl3RH","date":"1665688478","viewed":178,"name":"Raymarching space (Bintree)","username":"pyBlob","description":"Reconstructing the world from sdf sampled via a binary tree traversal. Looks around corners and behind walls!","likes":4,"published":3,"flags":32,"usePreview":0,"tags":["raymarching","visualization"],"hasliked":0,"parentid":"ftyfWd","parentname":"Raymarching wavefront (Bintree)"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    setup(fragCoord, iResolution, iMouse, iTime);\n\n    color = vec3(0);\n    vec4 centers = vec4(0);\n\n    int rx = int(iResolution.x);\n    float r = 0., rs = 1.;\n    for (int i=0 ; i<N ; i+=1) // try only using every 2nd sample\n    for (int j=0 ; j<rx ; j+=1) // try downsampling (eg 8x, 30x)\n    {\n        vec4 A = texelFetch(iChannel0, ivec2(j, i), 0);\n        float _r = A.x;\n        vec2 _p = A.yz;\n        if (A.w < 0.) continue;\n        \n        float cr = length(uv - _p) - abs(_r);\n        if (cr < 0.)\n            r = max(r, -cr), rs = _r; // lowerbound of sdf\n\n        vec3 fill = _r < 0. ? vec3(1,.2,0) : vec3(0,.2,1);\n        blend(fill, cr + 1. * f);\n        blend2(centers, vec3(1,0,0), (length(uv - _p)));\n    }\n    \n    if (r != 0.) color = (.5 - .5 * cos(r * 100.)) * (rs < 0. ? vec3(1,.3,0) : vec3(0,.1,1)); // safe space\n    color = mix(color, vec3(0,.8,0), clamp(1.-r/f, 0., 1.)); // unmapped territory\n    \n    fade(blend(centers), T1); // sdf evaluations\n    fade(blend(vec3(1), abs(scene(uv))), T2); // scene boundary\n    blend(vec3(1), abs(length(uv - ro) - 3. * f)); // ray origin\n\n    fragColor = vec4(sqrt(color), 1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float pi = radians(180.);\nconst int N = 16; // number of raymarching steps\n\nfloat f; vec3 color;\nvoid blend(vec4 c)\n{\n    color = mix(color, c.xyz, c.w);\n}\nvoid blend(vec3 c, float r)\n{\n    blend(vec4(c, clamp(1. - r / f, 0., 1.)));\n}\nvoid blend2(inout vec4 color, vec3 c, float r)\n{\n    color = mix(color, vec4(c, 1), clamp(1. - r / f, 0., 1.));\n}\n#define fade(block, alpha) { vec3 bg = color; block; color = mix(bg, color, alpha); }\n\nvec2 uv, ro;\nvec4 mouse;\nbool demo, down, click;\nfloat T, T1, T2;\nvoid setup(vec2 fragCoord, vec3 iResolution, vec4 iMouse, float iTime)\n{\n    f = 2. / iResolution.y;\n    uv = (fragCoord - iResolution.xy / 2.) * f;\n    mouse = (abs(iMouse) - iResolution.xyxy / 2.) * f;\n    demo = iMouse.z == 0.;\n    down = iMouse.z > 0.;\n    click = iMouse.w > 0.;\n\n    T = mod(iTime/1.2, 6.);\n    if (!demo) T = 3.;\n    //T = 0.;\n    float t = 0.2;\n    T1 = smoothstep(1.-t, 1.+t, T) - smoothstep(4.-t, 4.+t, T);\n    T2 = smoothstep(2.-t, 2.+t, T) - smoothstep(5.-t, 5.+t, T);\n\n    ro = mouse.xy;\n    if (demo)\n    {\n        float a = .3 * iTime;\n        float T=2.+pi, s=sign(T-mod(a, T+T)); a=mod(a, 2. + pi); ro=vec2(.5,0) + .5*(a<2. ? vec2(a-1., 0) : vec2(cos(a=s*(a-2.)), sin(a)));\n    }\n}\n\nfloat sdBox(vec2 p,vec2 s)\n{\n    return length(max(p=abs(p)-s,0.))+min(max(p.x,p.y),0.);\n}\n\nfloat sdLine(vec2 p,vec2 a,vec2 b)\n{\n    return length(-clamp(dot(p-=a,b-=a)/dot(b,b),0.,1.)*b+p);\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    sca = normalize(sca);\n    scb = normalize(scb);\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x > scb.x*p.y) ? dot(p,scb) : length(p);\n    return sqrt(max(0., dot(p,p) + ra*ra - 2.0*ra*k)) - rb;\n}\n\nfloat side(float r, float h)\n{\n    return sqrt(r*r - h*h);\n}\n\nfloat sdArcTo(in vec2 p, in vec2 a, in vec2 b, float r)\n{\n    vec2 m = a + b;\n    float tb = dot(m, b) / length(m);\n    float arc = sdArc(p, vec2(m.y, -m.x), vec2(side(r, tb), tb), r, 0.);\n    //return min(min(length(p-a), length(p-b)), min(length(p-m), min(arc, length(p)))) -.01;\n    return arc;\n}\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat scene(vec2 p)\n{\n    // lara: Animated Marching Visualization https://www.shadertoy.com/view/ltyGRD\n    p.x += .5;\n    float ball = length(p - vec2(1, 0)) - .3;\n    float lens = length(p - vec2(.8, 0)) - .15;\n    float wire = abs(p.y) - .05;\n    vec2 q = p; q.y = abs(q.y);\n    float eye = max(max(ball,-lens),-wire);\n    float bx = (pow(.3,2.)-pow(.15,2.)+pow(.2,2.))/(2.*.2);\n    float bh = side(.3, bx);\n    float ballArc = sdArcTo(q - vec2(1, 0), vec2(-bx,bh), vec2(side(.3,.05), .05), .3);\n    float lensArc = sdArcTo(q - vec2(.8, 0), vec2(.2-bx,bh), vec2(side(.15,.05), .05), .15);\n    float wireLine = sdLine(q, vec2(.8+side(.15,.05), .05), vec2(1.+side(.3,.05), .05));\n    float eye1 = min(min(ballArc, lensArc), wireLine) * sign(eye);\n    float socket = min(\n        sdBox(vec2(p.x,abs(p.y))-vec2(1,.6),vec2(.3,.05)),\n        sdBox(vec2(p.x,abs(p.y))-vec2(1.25,.55),vec2(.05,.05))\n    );\n    //if (false)\n        return min(eye1, socket); // proper sdf\n    return min(eye, socket); // original sdf\n}\n\nvec3 palette(float h)\n{\n    // iq: Binary Search for SDFs https://www.shadertoy.com/view/wlGcWG\n    vec3 col =    vec3(0.0,0.3,1.0);\n    col = mix(col,vec3(1.0,0.8,0.0),smoothstep(0.33-0.2,0.33+0.2,h));\n    col = mix(col,vec3(1.0,0.0,0.0),smoothstep(0.66-0.2,0.66+0.2,h));\n    col.y += 0.5*(1.0-smoothstep(0.0,0.2,abs(h-0.33)));\n    col *= 0.5 + 0.5*h;\n    return col;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"int lvl, seg;\nvoid init() { lvl = 0; seg = 0; }\nvoid up()   { --lvl; seg = seg>>1; }\nvoid near() { ++lvl; seg = seg<<1; }\nbool isfar() { return (seg & 1) == 1; }\nbool next() { while (isfar()) up(); ++seg; return lvl == 0; }\n\nfloat _r, _s; vec2 _p;\nbool close(vec2 ro, vec2 rd)\n{\n    rd *= exp2(-float(lvl));\n    _r = scene(_p = ro + rd * (float(seg) + .5));\n    float _s = length(rd) / 2.;\n    return _r < _s;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(-1);\n    int fcy = int(fragCoord.y);\n    if (fcy >= N)\n        return;\n\n    setup(fragCoord, iResolution, iMouse, iTime);\n    float a = fragCoord.x / iResolution.x * 2. * pi;\n\n    color = vec3(0);\n    blend(vec3(1), abs(scene(uv)) - .5 * f);\n\n    vec2 rd = vec2(cos(a), sin(a)) * 4.;\n\n    blend(vec3(1), abs(length(uv - ro) - 3. * f) - .5 * f);\n\n    init();\n    for (int i=0;i<N;++i)\n    {\n        if (close(ro, rd))\n        {\n            near();\n            if (lvl > 16)\n                break;\n        }\n        else if (next()) break;\n        if (i == fcy)\n            fragColor = vec4(_r, _p, 0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}