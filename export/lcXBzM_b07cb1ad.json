{"ver":"0.1","info":{"id":"lcXBzM","date":"1723540344","viewed":31,"name":"Impact | Gravity","username":"Fir3c0w","description":"Color of pixel = which planet an object thrown from that pixel crashes into\n\nSome drag is applied to the objects thrown from each pixels following the formula Drag = -d * v / |v|","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["gravity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Planet\n{\n        vec2 position;\n        float mass;\n        float radius;\n        vec3 color;\n};\n\nbool draw_planet(Planet p, vec2 coords)\n{\n    return length(coords - p.position) <= p.radius;\n}\n\nconst float G = 1.;\nconst float deltaCompute = .0005;\nconst int iteration = 1000;\nconst float drag_coef = 75.; // drag slows down the objects proportionnaly to their speed. \n\nconst int planet_count = 4;\nPlanet planets[planet_count] = Planet[]\n(\n    Planet(vec2(.5, .5), .4, .04, vec3(0.,0.,1.)),\n    Planet(vec2(1., .3), .4, .04, vec3(1.,0.,0.)),\n    Planet(vec2(.7, .8), .4, .04, vec3(0.,1.,0.)),\n    Planet(vec2(1.3, .9), .4, .04, vec3(0.,1.,1.))\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    planets[0].position = iMouse.xy / iResolution.yy;\n    \n    // Coords from (0->ar) for x and (0->1) for y\n    vec2 coords = fragCoord/iResolution.yy;\n\n    // Time varying pixel color\n    vec3 col = vec3(1.,1.,1.);\n    \n    vec2 pt = coords;\n    vec2 drag = vec2(0.,0.);\n    float mass = .1;\n    for (int i = 0; i < iteration; ++i)\n    {\n        // phys update\n        vec2 forces = vec2(0.,0.);\n        for (int p = 0; p < planet_count; ++p)\n        {\n            vec2 unit = (planets[p].position - pt) \n                        / length(planets[p].position - pt);\n            \n            forces += G * (mass * planets[p].mass) \n            / (length(planets[p].position - pt) \n            * length(planets[p].position - pt)) * unit;\n        }\n        \n        \n        // Drag computed from the LAST update : Not accurate at all \n        forces += drag;\n        vec2 acceleration = forces / mass;\n        vec2 next_pos = pt + acceleration * deltaCompute;\n        \n        drag = - drag_coef * (next_pos - pt) / length(next_pos - pt);\n        \n        pt = next_pos;\n        \n        bool breaking = false;\n        vec3 p_color = vec3(0.,0.,0.);\n        for (int p = 0; p < planet_count; ++p)\n        {\n        \n            // Checks if there is an intersection\n            // by interpolating\n            bool intersect = length(pt - planets[p].position) < planets[p].radius;\n            \n          \n            breaking = breaking || intersect;\n            if (intersect)\n            {\n                p_color = planets[p].color;\n            }\n        }\n        if (breaking)\n        {\n            col = p_color;\n            break;\n        }\n        \n        pt = next_pos;\n    }\n    \n        \n    for (int i = 0; i < planet_count; ++i)\n    {\n        if (draw_planet(planets[i], coords))\n        {\n            col = planets[i].color / 2.0;\n        }\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}