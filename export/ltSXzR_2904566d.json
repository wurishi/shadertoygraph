{"ver":"0.1","info":{"id":"ltSXzR","date":"1440964295","viewed":694,"name":"Web cam color blind filter","username":"BillyBag2","description":"A webcam version of color blind filter targeted for Android Chrome . (Shield tablet, Old nexus 7) Comments welcome on mobile compatibility.\nColors are RGB YMC (red green blue, yellow magenta cyan, [I hope])\n","likes":5,"published":1,"flags":2,"usePreview":0,"tags":["webcam","colorblind"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// This is my first shader.\n// Feedback very welcome.\n\n// When you are color blind it is dificult to tell colours apart.\n// The idea of this shader is to help when this becomes a problem.\n// I can think of two cases where I struggle with color blindness.\n// One is colored LEDs. Red and green LEDs look the same to me.\n// The other is maps with color keys,\n// for example the london underground map.\n// In these cases it is less about naming the colours and more\n// about telling colors apart.\n// Most colour blind apps try and name colours. I want a quick visual\n// clue that colors are different.\n// Ideally this shader would be in a phone/tablet app using a camera.\n\n\n// TODO:\n// I want to \"blur\" the texture so the hue value for the stripes\n// is less noisy. However may introduce color aliasing.\n\n// At the time of writing it darked the image to make the stripes.\n// If I center the stripe intensidt the avaerage brightness will\n// not change. Hoever I could \"overflow\" ? \n// As a begginner I'm not sure how to adderss this. \n\n// Label the colored squares.\n\n// Stole rgb2hsv  from...\n// http://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float angle = iTime; // A test engle for a texture.\n    float freq = 200.0; // Frequency across the screen.\n    float amp =2.0; // Amplitude of texture. \n \tvec2 xy = fragCoord.xy / iResolution.xy;\n    vec4 texColor;\n    float squareSize = 0.05;\n    float PI=3.14159265358979323846264;\n    if((xy.y > squareSize) && (xy.y < (squareSize * 2.0)) )\n    {\n        if((xy.x > squareSize) && (xy.x < (squareSize * 2.0)) )\n        {\n            texColor = vec4(1.0,0.0,0.0,1.0);\n        }\n        else if((xy.x > (squareSize * 3.0)) && (xy.x < (squareSize * 4.0)) )\n        {\n            texColor = vec4(0.0,1.0,0.0,1.0);\n        }\n        else if((xy.x > (squareSize * 5.0)) && (xy.x < (squareSize * 6.0)) )\n        {\n            texColor = vec4(0.0,0.0,1.0,1.0);\n        }\n        else    if((xy.x > (squareSize * 7.0)) && (xy.x < (squareSize * 8.0)) )\n        {\n            texColor = vec4(1.0,1.0,0.0,1.0);\n        }\n        else if((xy.x > (squareSize * 9.0)) && (xy.x < (squareSize * 10.0)) )\n        {\n            texColor = vec4(1.0,0.0,1.0,1.0);\n        }\n        else if((xy.x > (squareSize * 11.0)) && (xy.x < (squareSize * 12.0)) )\n        {\n            texColor = vec4(0.0,1.0,1.0,1.0);\n        }\n        else\n        {\n        \ttexColor= texture(iChannel0,xy);\n        }\n    }\n    else\n    {\n \t  texColor= texture(iChannel0,xy);      \n    }\n        \n   \n    vec3 hsv = rgb2hsv(texColor.xyz);\n    angle = hsv.x * PI; // Not because we do ot have a direction this is PI not 2.Pi\n    // We are making a color \"Fan\" not a color \"Wheel\"\n    \n     // quantize the angle so we get better areas of stripes.\n    angle = floor(angle * 10.0)/10.0;\n    float rotx = ((fragCoord.xy.x * cos(angle)) - (fragCoord.xy.y * sin(angle)))/iResolution.xy.x;\n    \n    amp = amp * hsv.y; // Increase mplitude for higher saturation.\n    \n    amp = clamp(amp,0.0,1.0);\n    // Set sinOffset to 0.5 to only decrease brightness.\n    // Set signOffset to 0.0 to balance the amplitude.\n    float sinOffset = 0.0;\n    float ampxy = 1.0 - (amp * (sinOffset + (0.5 * sin(rotx * freq * 2.0 * PI)))); \n    texColor = texColor * ampxy;\n    \n    //texColor = texColor * ;\n    fragColor = texColor;\n}","name":"","description":"","type":"image"}]}