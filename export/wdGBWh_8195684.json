{"ver":"0.1","info":{"id":"wdGBWh","date":"1606990977","viewed":59,"name":"Zoomcall ringlight","username":"Corstiaan","description":"Use this fullscreen as your a ringlight for in your zoom-calls.\nMouse X for width, Mouse Y for brightness","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// AntiAlias, scale with UV scale\nfloat aa(float localScale)\n{\n    float smoothness = 2.0;\n    return smoothness/iResolution.x*localScale*SCALE;\n}\n\n// SDF\nfloat sdfPoint(vec2 p)\n{\n    return length(p);\n}\n\nfloat sdfElipse(vec2 p, vec2 r)\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// Mask\nfloat Circle(vec2 p, float r, float blur)\n{\n    return 1.-thresh(length(p), r, aa(blur*1.5));\n}\n\nfloat Ring(vec2 p, vec2 radii, float blur)\n{\n    return band(length(p), radii.x, radii.y, aa(blur*1.5));\n}\n\nfloat Section(vec2 p, vec2 angles, float repeat, float blur)\n{\n    // draw smallest distance, inverse output if needed\n    float a1 = min(angles.x, angles.y);\n    float a2 = max(angles.x, angles.y);\n    \n    // halve delta (a2 and a2 in degrees)\n    float da = (a2-a1) / 2.;\n\n    // rotate to opposite of angles to give room to blur and aa\n    float rot = 180. + a1 + da;\n    p = Polar(p, -radians(rot/repeat));\n    \n    // repeat\n    p.y = fract(p.y/TWO_PI * repeat)*TWO_PI;\n    \n    // counter rotate angle to be on both sides of 180\n    a1 = fract(radians(180. - da)/360.)*360.;\n    a2 = fract(radians(180. + da)/360.)*360.;\n    \n    // scale antialias to radius (no division by zero)\n    float ab = p.x < 0.0000001 ? 2.*PI : (blur/p.x) / 2.*PI;\n    \n    float aa = aa(ab * repeat);\n    float sections;\n    \n    if (angles.y >= angles.x) sections =     band(p.y, a1, a2, aa);\n    else\t\t\t\t\t  sections = 1.- band(p.y, a1, a2, aa);\n    \n    // blend too small into black en almost complete into white\n//    if (da < 1.) sections *= smoothstep(0., 1., da);\n//    if (da > 180. - 1.) sections += smoothstep(180. - 1., 180., da);\n    return clamp(sections, 0., 1.);\n}\n\n\nfloat Elipse(vec2 p, float rot, vec2 r, float width, float sharp)\n{\n    p *= rot2d(rot);\n    return band(sdfElipse(p, r), 0.0, width, sharp);\n}\n\nfloat tween(float t, float start, float end)\n{\n    t =  max(0., min(1.,t));\n    return start + t * (end - start);\n}\n\nfloat tLoopOffset(float duration, float offset)\n{\n    return fract((iTime * SPEED - offset) / duration);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 UV = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    UV *= SCALE;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec2 cntr = vec2(0.);\n    vec3 brightness = vec3(0.5);\n\n    float loopDuration = 3.;\n    float interval = 0.5;\n   \n    vec4 col = vec4(0.);\n\n    float blur = 20.;\n    vec2 sizes = vec2(0.5 - mouse.x * 0.5, 0.5);\n    \n    float ring = Ring(UV, vec2(sizes), blur);\n    vec3 lightcolor = vec3(mouse.y * 1.5, mouse.y * 0.99 * 1.5, mouse.y * 0.8 * 1.5);\n    vec4 ringlight = vec4(lightcolor * ring, ring);\n    \n    // Output to screen\n    vec4 tex = texture(iChannel0, UV) * 0.8;\n    fragColor = ringlight; // blendAdd(tex, col * col.w, 0.5);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535897932384626433832795\n#define TWO_PI (2.0*PI)\n#define HALF_PI (0.5*PI)\n\nconst float SPEED = 0.8;\nconst float SCALE = 1.0;\nconst vec3 BRIGHTNESS = vec3(1.);\nconst vec4 BLUE = vec4(0.398,0.808,1.0, 1.0);\nconst vec4 WHITE = vec4(1.);\n\nfloat sgm(float f)\n{\n    float a = 15.;\n    return 1.0/(1.0 + exp(-(f-0.5)*a));\n}\n\nfloat clamp01(float n)\n{\n    return clamp(n,0.,1.);\n}\n\nfloat easeInQuad(float t) \n{\n    return t*t;\n}\n    \nmat2 rot2d(float deg)\n{\n    float rad = radians(deg);\n    return mat2(cos(rad), -sin(rad),\n                sin(rad), cos(rad));\n}\n\nvec2 Polar(vec2 p, float radRot)\n{\n    float rho = length(p);\n    float phi = fract((atan(p.y, p.x) + PI + radRot)/TWO_PI)*TWO_PI;\n    \n    return vec2(rho, phi);\n}\n\nvec4 blend(vec4 bot, vec4 top, float p)\n{\n \tvec3 bot2 = pow(bot.rgb, vec3(2.2));\n    vec3 top2 = pow(top.rgb, vec3(2.2));\n    float alpha = mix(bot.a, top.a, p);\n    \n    return vec4(pow(mix(bot2, top2, p), vec3(1.0 / 2.2)), alpha);\n}\n\nvec4 blendAdd(vec4 bot, vec4 top, float factor)\n{\n    float glow = 0.;\n    \n    top.rgb *= factor;\n    top.a *= (1.-glow) * factor;\n\n    vec3 rgb = top.rgb + (bot.rgb * (1.0 - top.a));\n    float a = top.a   + (bot.a   * (1.0 - top.a));\n\n    return vec4(rgb, a);\n}\n\n\nfloat thresh(float base, float val, float blur)\n{\n    // divides a gradient 0-1 in black and white with:\n    // base: the gradient / coordinate system\n    // val: middle of the threshold\n    // width: width of the threshold\n    return smoothstep(val-(blur/2.), val+(blur/2.), base);\n}\n\nfloat thick(float base, float val, float width, float blur)\n{\n    // 'thickness' around value\n    return 1.-thresh(abs(base-val)-width*0.5, 0., blur);\n}\n\nfloat band(float base, float valA, float valB, float blur)\n{\n    // similar to thick but with to endpoints\n    return thick(base, (valB+valA)*0.5, valB-valA, blur);\n}","name":"Common","description":"","type":"common"}]}