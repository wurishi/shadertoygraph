{"ver":"0.1","info":{"id":"Wlcfz4","date":"1612379513","viewed":171,"name":"Golden Triangle Zoom","username":"fizzer","description":"Another 'infinite' zoom, similar to my previous [url=https://www.shadertoy.com/view/WlcSD8]Golden Section Zoom[/url] shader. This one is based on the golden isosceles triangle, which has inner angles in ratio 1:2:2 and sides in ratio φ:φ:1.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["zoom","phi","infinite","goldenratio"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://en.wikipedia.org/wiki/Golden_triangle_(mathematics)\n\nconst float pi = 3.14159265358979323;\nconst float phi = (sqrt(5.) + 1.) / 2.;\nconst float th = pi * 2. / 5.;\n\nvec2 cMul(vec2 a, vec2 b)\n{\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 cDiv( vec2 a, vec2 b)\n{\n    return cMul(a, vec2(b.x, -b.y)) / dot(b, b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy *.5) / iResolution.y * 40.;\n\n    float t = iTime + texelFetch(iChannel0, ivec2(fragCoord.xy) & 1023, 0).r / 60.;\n    \n    vec3 col = vec3(0);\n\n    // Represent the following transformation with complex numbers:\n    // mat3(rot(pi - th)) * mat3(vec3(phi, 0, 0), vec3(0, phi, 0), vec3(vec2(-cos(th), sin(th)), 1.)); \n    vec2 c0 = vec2(cos(pi - th), sin(pi - th)) * phi;\n    vec2 c1 = vec2(cos(th), -sin(th)) / phi;\n    \n    // Solve (z - c1) * c0 - z = 0 to find the fixed point of the transformation.\n    vec2 zc = cDiv(cMul(c1, c0), c0 - vec2(1, 0));\n    \n    uv += vec2(cos(t / 3.), sin(t / 2.)) * 8.;\n    \n    float a = t;\n    mat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n    \n    // Exponential scaling transform, for a seamless (self-similar) zooming animation.\n    uv = m * uv * pow(pow(phi - 1., 10.), 1. + fract(t / 3.)) + zc;\n    \n    vec2 z = uv;\n    \n    float j = 0.;\n    \n    for(int i = 0; i < 32; ++i)\n    {\n        if(dot(z, vec2(sin(th), cos(th))) > 0.)\n        {\n            j = float(i) + floor(t / 3.) * 10.;\n            break;\n        }\n        z = cMul(z - c1, c0);\n    }\n\n    col = sin(vec3(j, j * 2., j * 3.)) * .5 + .5;\n\n    fragColor = vec4(sqrt(col), 1.0);\n}","name":"Image","description":"","type":"image"}]}