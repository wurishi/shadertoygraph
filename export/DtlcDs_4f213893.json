{"ver":"0.1","info":{"id":"DtlcDs","date":"1691350463","viewed":77,"name":"One More Implicit Plotter","username":"Envy24","description":"See Image tab header.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["template","implicit","plotter","graphs"],"hasliked":0,"parentid":"stVcDz","parentname":"Minimal Plotter"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Very ineffitient, but looks good when method from Minimal Plotter gives ulgy result.\n    More costly for thick curves, than for this.\n    Can also be used for explicit functions (see last function in implicit()).\n    \n    Left - expensive method.\n    Right - cheap method.\n    \n    Extracted method from my old shader: \n        https://www.shadertoy.com/view/slVSWV\n*/\n\n#define ORIGIN                    ( vec2(0) )\n#define SCENE_SCALE               ( 1. + (1.+sin(iTime*0.5)) * 20.0 )\n#define UNIT                      ( 3.0*SCENE_SCALE / iResolution.y )          // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    //NDC *= 2.; // Finer cell\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\n//float draw_implicit_func(vec2 NDC, float fxy, vec2 grad) { return SMAA(abs(fxy) / sqrt(grad.x*grad.x + grad.y*grad.y)); } // L2-norm\nfloat draw_implicit_func(vec2 NDC, float fxy, vec2 grad) { \n    return smoothstep(1.9*SCENE_SCALE / iResolution.y, 0., abs(fxy) / sqrt(grad.x*grad.x + grad.y*grad.y)); // for demo\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale - origin;\n}\n\n/* Some ugly test function */\nfloat dsm_rpow(float x, float y) {\n    if (x >= 0.0) return pow(x,y);\n    else {\n        float m = mod(y, 2.0);\n        if (m == 0.0) return pow(-x, y);\n        else if (m == 1.0) return -pow(-x, y);\n        else return pow(x, y);\n    }    \n}\nfloat glesmos_f0(float x, float y) { return (((((0.8)*(dsm_rpow((tanh(((1.4)*(sin(((5.0)*(sqrt(((dsm_rpow(x,(2.0)))+(dsm_rpow(y,(2.0)))))))))))),(4.0))))+(dsm_rpow((sin(((atan(y,x))+((2.0)*(sqrt(((dsm_rpow(x,(2.0)))+(dsm_rpow(y,(2.0)))))))))),(2.0))))-(0.7))+((0.1)/((dsm_rpow(x,(2.0)))+(dsm_rpow(y,(2.0))))));}\n/* Some ugly test function */\n\n// Implicit function definition.\nfloat implicit(float x, float y) \n{ \n    //return glesmos_f0(x, y);\n    return sin(x+y)-cos(x*y)+1.0;\n    //return x * y * (abs(x) + abs(y) - 1.);\n    //return pow(3.*x*x - y*y, 2.)*y*y - pow(x*x + y*y, 4.);\n    //return pow(x*x + y*y, 2.) - 2.*(x*x - y*y);\n    //return tan(x*y*sin(y*x)*cos(x*x)) ;\n    //return cos(x*x) + sin(y*x);\n    //return cos(x * y) + y * sin(x);\n    //return sin(y)+cos(x);\n    //return sin(x*40.) - y;\n    //return sin(2.*x)*sin(2.*x)*sin(2.*x) + 4.*sin(y)*sin(y)*sin(y) - 3.*sin(2.*x)*sin(y);\n}\n\n\n//float implicit(float x, float y) { return sin(x*10.) - y; }\n\n\n/* For cheap method */\nfloat delf_delx(float x, float y) \n{ \n    /* Numeric derivative. */\n    const float dx=0.001;\n    return ( implicit(x+dx, y)-implicit(x-dx, y) ) / (2.*dx);\n}\nfloat delf_dely(float x, float y) \n{ \n    /* Numeric derivative. */\n    const float dy=0.001;\n    return ( implicit(x, y+dy)-implicit(x, y-dy) ) / (2.*dy);\n}\nvec2 gradient(float x, float y) { return vec2(delf_delx(x, y), delf_dely(x, y)); }\n/**/\n\n// Expensive method.\nfloat implicitAA( in vec2 NDC )\n{\n    float coverage = 0., // You can cheat and set this variable to some negative value.\n          th = 6.,        // thickness\n          c = implicit(NDC.x, NDC.y) >= 0. ? 1. : -1.; // only sign\n    \n    vec2 ps = vec2(0.35*SCENE_SCALE/iResolution.y); // affects thickness and artifacts\n   \n    // Supersampling.\n    for (float y = -th; y <= th; y += 1.)\n        for (float x = -th; x <= th; x += 1.)\n        {\n            vec2 p = NDC + vec2(x, y)*ps;\n            float n = implicit(p.x, p.y);\n            \n            /* 1. Filled shape *\n            coverage += n >= 0.0 ? 0.0 : 1.0;\n            /* 2. Shape contour */\n            n = n >= 0.0 ? 1. : -1.;\n            coverage += c == n ? 0. : 1.;\n            /**/\n        }\n  \n    // Convert coverage into intensity (.35 is arbitrary weight for AA).\n    return smoothstep(0., th*th, coverage*0.35);\n}\n       \nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false);\n\n    vec3 color = vec3(1);\n         //color = mix( color, vec3(0.8), SMAA(cellsSDF(NDC)) );\n         //color = mix( color, vec3(0), SMAA(x_axisSDF(NDC)) );        \n\n    /* Implicit function f(x,y) */\n    if (NDC.x > 0.)\n         color = mix(color, vec3(1,0,0), draw_implicit_func(NDC, implicit(NDC.x, NDC.y), gradient(NDC.x, NDC.y)));\n    else\n         color = mix(color, vec3(1,0,0), implicitAA(NDC));\n         \n    color = mix( color, vec3(0), SMAA(y_axisSDF(NDC)) );\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}