{"ver":"0.1","info":{"id":"flBXRz","date":"1626968182","viewed":83,"name":"torus voronoi","username":"CyanMARgh","description":"3d version of 7ljSRR shader\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","torus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 cameraPos = vec3(0., 10., -13.5);\nfloat softShadow = 10.;\nfloat depthmax = 80.; \nconst float eps = 0.0001;\nvec3 backcol = vec3(.6,.7,1.);\nfloat inf = 1e20;\nfloat pi=3.14159265;\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n//additioanal operations\nstruct point {\n    vec2 p;\n    vec3 c;\n};\nfloat torusDist(vec2 a, vec2 b) {\n    a = abs(a - b);\n    return length(min(abs(a), abs(1. - a)));\n}\nmat2 ro (float a) {\n\tfloat s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\n//SDF operations\nvec4 cun(vec4 d1, vec4 d2){\n    return d1.w<d2.w?d1:d2;\n}\n//SDF\nfloat torus(vec3 p, vec3 p0, float RL, float RS) {\n    p -= p0;\n    vec3 h = vec3(0., p.y, 0.);\n    vec3 v = p - h;\n    return sqrt(pow(length(v) - RL, 2.) + p.y * p.y) - RS;\n}\nfloat box(vec3 b, vec3 p){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n//color functions\nbool cb3(vec3 p){\n    ivec3 d = ivec3(floor(p));\n    return (d.x+d.y+d.z)%2==0;\n}\nvec2 torusCoordinate(vec3 p, vec3 p0, float RL) {\n    p -= p0;\n    float phi = atan(p.z, p.x) / pi;\n    float theta = atan(p.y, length(p.xz) - RL) / pi;\n    return vec2(phi+1., theta + 1.) / 2.;\n}\nconst uint S = 8u;\nvec3 torusColor(vec2 uv) {\n    uv = mod(uv, 1.);\n    point centers[S];\n    centers[0] = point(vec2(0., 0.), vec3(0., 0., 0.));\n    centers[1] = point(vec2(.7, .7), vec3(0., 0., 1.));\n    centers[2] = point(vec2(.3, .6), vec3(0., 1., 0.));\n    centers[3] = point(vec2(.2, .2 + .1*sin(iTime)), vec3(0., 1., 1.));\n    centers[4] = point(vec2(.25 + .1 * cos(iTime+1.), .4), vec3(1., 0., 0.));\n    centers[5] = point(vec2(.4, .4), vec3(1., 0., 1.));\n    centers[6] = point(vec2(.5, .3), vec3(1., 1., 0.));\n    centers[7] = point(vec2(.1, .5 + .3 * cos(iTime)), vec3(1., 1., 1.));\n    \n    float md = 1e20;\n    vec3 col = vec3(1.);\n    for(uint i = 0u; i < S; i++) {\n        float d = torusDist(uv, centers[i].p);\n        if(d < md) {\n            md = d;\n            col = centers[i].c;\n        }\n    }\n    return col;\n}\n\n//scene SDF\nvec4 map(vec3 p){\n    vec4 d0 = vec4(1.,1.,1.,-box(vec3(20.,20.,20.),p-vec3(0.,20.,0.)));\n    d0.xyz*=cb3(p)?1.:.8;\n    vec2 uv = torusCoordinate(p, vec3(0., 6., 0.), 5.);\n    vec4 d = vec4(torusColor(uv), torus(p, vec3(0., 6., 0.), 5., 1.5));\n    d0 = cun(d0,d);    \n    return d0;\n}\n//normals\nvec3 norm(vec3 p){\n    const vec2 e = vec2(eps,0.);\n    float d = map(p).w;\n    return normalize(vec3(\n        map(p + e.xyy).w-d,\n        map(p + e.yxy).w-d,\n        map(p + e.yyx).w-d\n    ));\n}\n// color of lighting for point\nvec3 getLight(vec3 p, vec3 lp, vec3 n, vec3 lc, float po, bool mode){\n    p += n * eps;\n    vec3 ld=mode?lp:lp-p;\n    float l = length(ld);ld/=l;\n\tfloat diff = dot(ld,n);\n    \n    float h, c=eps, r=1.;\n    \n    for (float t = 0.0; t < 50.0; t++){\n        h = map(p + ld * c).w;\n        if (h < eps){\n            return vec3(0.);\n        }\n        r = min(r, h * softShadow / c);\n        c += h;//clamp(h,0.,3.0);\n        if(c>l)break;\n    }\n    \n    return lc*po*r*diff/(l*l);\n}\n// ambient occlusion by point\nfloat getOcc(vec3 ro, vec3 rd){\n    float totao = 0.0;\n    float sca = 1.0;\n    for (int aoi = 0; aoi < 2; aoi++){\n        float hr = 0.01 + 0.02 * float(aoi * aoi);\n        vec3 aopos = ro + rd * hr;\n        float dd = map(aopos).w;\n        float ao = clamp(-(dd - hr), 0.0, 1.0);\n        totao += ao * sca;\n        sca *= 0.75;\n    }\n    const float aoCoef = 0.5;\n    return totao*(1.0 - clamp(aoCoef * totao, 0.0, 1.0));\n}\nvec3 getFullLight(vec3 pos, vec3 n){   \n    pos+=eps*n;\n    vec3 col;\n\n    if (length(pos) < depthmax){\n        col = vec3(.25);\n\t\tcol += getLight(pos, vec3(11., 13., 8.), n, vec3(1.,.9,.9), 60.,false);\n        col += getLight(pos, vec3(-8.,13., 11.), n, vec3(1.,1.,1.), 60.,false);\n        col += getLight(pos, vec3(-11.,13.,-8.), n, vec3(1.,1.,1.), 60.,false);\n        col += getLight(pos, vec3(8., 13.,-11.), n, vec3(1.,.9,.9), 60.,false);\n    }else{\n        col = backcol;\n    }\n    return col;\n}\n//direction of ray by pixel coord\nvec3 getDir(vec2 fragCoord, float angle){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);    \n    vec3 eye = cameraPos;\n    float targetDepth = 2.;\n    vec3 dir = normalize(vec3(p,targetDepth));\n    dir.zy*=ro(-.25);\n    dir.xz*=ro(angle);\n    return dir;\n}\n\n//color and length of ray\nvec3 rayCast(vec3 eye, vec3 dir){\n    vec3 col = vec3(0.);\n    float k=1.;\n    \n    vec3 pos; float depth=0., sdepth=0., dist;\n    vec4 rc;\n    const int maxsteps = 500;\n    for (int i = 0; i < maxsteps; i++){\n        pos = eye + dir * depth;\n        rc = map(pos);\n        dist = rc.w;;\n\n        depth += dist;\n        sdepth += dist;\n        \n        if(dist < eps){ //intersection with object\n            break; \n        }else if(length(pos)>depthmax){ //ray \n            depth = depthmax+eps;\n            break;\n        }\n    } \n    vec3 n = norm(pos);\n    pos+=eps*n*5.;\n    col+=map(pos).xyz*k*getFullLight(pos,n);\n\tif(map(pos).w<0.)col+=vec3(1e20);\n    return col * exp(-0.003*sdepth);\n}\n//full render\nvoid mainImage(out vec4 color, in vec2 uv){\n    //direction calculation\n    float angle = iTime*.2;    \n    vec3 eye = cameraPos;\n    eye.xz*=ro(angle);\n    vec3 dir = getDir(uv,angle);\n\n    //raymarching\n    vec3 col = rayCast(eye, dir);    \n    color = vec4(1.5*log(1.+ col), 1.0);\n}","name":"Image","description":"","type":"image"}]}