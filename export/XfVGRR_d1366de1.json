{"ver":"0.1","info":{"id":"XfVGRR","date":"1712325279","viewed":232,"name":"Barren rock island on a journey","username":"Bashen","description":"The shader is rendered with raymarching.\nThe island was made by roughly following Inigo Quilez' landscape video tutorial.\nThe ocean was made with the knowledge of Acerola's \"Rendering Water With Sine Waves\" video and whatever my imagination could conjure.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","ocean","landscape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI    3.14159265359\n#define TWOPI 6.28318530718\n#define cameraPosition vec3(500. * iTime, -3000., -5000.)\n#define mountainPosition vec2(cameraPosition.x, 10000.)\n\nfloat tMin = 0.;\nfloat tMax = 100000.;\n\nconst vec3 skyColor = vec3(0.157,0.580,0.757);\nconst vec3 sunColor = vec3(1.000,0.824,0.416);\nconst vec3 terrainColor = vec3(0.600,0.443,0.369);\nconst vec3 oceanColor = vec3(0.016,0.392,0.808);\n\nconst vec3 sunPosition = normalize(vec3(1., .5, 0.));\n\nfloat hash(vec2 x)\n{\n    return fract(sin(dot(x, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat coefA(vec2 ij)\n{\n    float u = 50. * fract(ij.x / PI);\n    float v = 50. * fract(ij.y / PI);\n    return hash(vec2(u, v));\n    //return 2. * fract(u * v * (u + v)) - 1.;\n}\n\nfloat coefB(vec2 ij) { return coefA(ij + vec2(1., 0.)); }\n\nfloat coefC(vec2 ij) { return coefA(ij + vec2(0., 1.)); }\n\nfloat coefD(vec2 ij) { return coefA(ij + vec2(1., 1.)); }\n\nfloat S(float lambda) { return 3. * pow(lambda, 2.) - 2. * pow(lambda, 3.); }\n\nfloat f(vec2 xz)\n{\n    vec2 ij = vec2(floor(xz.x), floor(xz.y));\n    float i = ij.x;\n    float j = ij.y;\n    float x = xz.x;\n    float z = xz.y;\n    float a = coefA(ij);\n    float b = coefB(ij);\n    float c = coefC(ij);\n    float d = coefD(ij);\n    return a +\n           (b - a) * S(x - i) +\n           (c - a) * S(z - j) +\n           (a - b - c + d) * S(x - i) * S(z - j);\n}\n\nfloat f2(vec2 xz)\n{\n    return 600. * f(xz / 2000.);\n}\n\nfloat globalElevation(vec2 xz)\n{\n    float dist = distance(mountainPosition, xz);\n    return 1. - sqrt(exp(-.00000005 * dist * dist));\n}\n\nfloat sdPlane(vec3 pos, float altitude)\n{\n    return dot(pos, vec3(0., 1., 0.)) + altitude;\n}\n\nfloat sdTerrain(vec3 pos, int octaves)\n{\n    float terrain = sdPlane(pos, 0.);\n    \n    mat2 rotation = mat2(.8, -.6, .6, .8);\n    float k = 2.;\n    vec2 p = pos.xz;\n    for(int i=0; i<octaves; i++)\n    {\n        terrain += k * f2(p);\n        p = p * 2. * rotation;\n        k = k * .5;\n    }\n    terrain += globalElevation(pos.xz) * 5000.;\n    return terrain;\n}\n\nfloat mountain(vec3 pos)\n{\n    return sdTerrain(pos, 14);\n}\n\nvec3 mountainNormals(vec3 pos)\n{\n    vec2 h = vec2(10., .0);\n    return normalize(\n        vec3(\n            mountain(pos + h.xyy) - mountain(pos - h.xyy),\n            mountain(pos + h.yxy) - mountain(pos - h.yxy),\n            mountain(pos + h.yyx) - mountain(pos - h.yyx)\n            )\n        );\n}\n\nfloat mountainShadow(float tMin, float tMax, vec3 rayOrigin, vec3 rayDirection)\n{\n    // https://iquilezles.org/articles/rmshadows/\n    float res = 1.;\n    float distanceToObstacle = tMin;\n    for(int i=0; i<256 && distanceToObstacle < tMax; i++)\n    {\n        vec3 position = rayOrigin + distanceToObstacle * rayDirection;\n        float remainingDistance = mountain(position);\n        if(remainingDistance < 0.00000001) { return 0.; }\n        res = min(res, 12. * remainingDistance / distanceToObstacle);\n        distanceToObstacle += remainingDistance;\n    }\n    return res;\n}\n\nfloat raymarchMountain(float tMin, float tMax, vec3 rayOrigin, vec3 rayDirection)\n{\n    float distanceToMountain = tMin;\n    for(int i=0; i<256; i++)\n    {\n        vec3 position = rayOrigin + distanceToMountain * rayDirection;\n        float remainingDistance = mountain(position);\n        if(abs(remainingDistance) < 0.0001 || distanceToMountain > tMax) { break; }\n        distanceToMountain += remainingDistance;\n    }\n    return distanceToMountain;\n}\n\nfloat wave(float x, float frequency, float amplitude, float phase)\n{\n    return amplitude * exp(sin(frequency * x + phase) - 1.);\n}\n\nfloat sdOcean(vec3 pos, int octaves)\n{\n    float base = sdPlane(pos, 5500.);\n    float freq = 0.015;\n    float amp = 150.;\n    for(int i=0; i<octaves; i++)\n    {\n        base -= wave(f2(pos.xz + float(i)*1000.), freq, amp, iTime * 2.);\n        freq = freq * 1.18;\n        amp = amp * .81;\n    }\n    return base;\n}\n\nfloat ocean(vec3 pos)\n{\n    return sdOcean(pos, 8);\n}\n\nvec3 oceanNormals(vec3 pos)\n{\n    // TODO: Compute true derivative\n    vec2 h = vec2(10., .0);\n    return normalize(\n        vec3(\n            ocean(pos + h.xyy) - ocean(pos - h.xyy),\n            ocean(pos + h.yxy) - ocean(pos - h.yxy),\n            ocean(pos + h.yyx) - ocean(pos - h.yyx)\n            )\n        );\n}\n\nfloat raymarchOcean(float tMin, float tMax, vec3 rayOrigin, vec3 rayDirection)\n{\n    float distanceToOcean = tMin;\n    for(int i=0; i<256; i++)\n    {\n        vec3 position = rayOrigin + distanceToOcean * rayDirection;\n        float remainingDistance = ocean(position);\n        if(abs(remainingDistance) < 0.0001 || distanceToOcean > tMax) { break; }\n        distanceToOcean += remainingDistance;\n    }\n    return distanceToOcean;\n}\n\nvoid handleCamera(out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float dist, in float zoom, in vec2 fragCoord)\n{\n\t// get rotation coefficients\n    vec2 c = vec2(cos(rotation.x), cos(rotation.y));\n    vec4 s;\n    s.xy = vec2(sin(rotation.x), sin(rotation.y));\n    s.zw = -s.xy;\n\n\t// ray in view space\n    ray.xy = fragCoord.xy - iResolution.xy * .5;\n    ray.z = iResolution.y * zoom;\n    ray = normalize(ray);\n\n\t// rotate ray\n    ray.yz = ray.yz * c.xx + ray.zy * s.zx;\n    ray.xz = ray.xz * c.yy + ray.zx * s.yw;\n\n\t// position camera\n    pos = origin - dist * vec3(c.x * s.y, s.z, c.x * c.y);\n}\n\nfloat _lambdaFog(float t) { return exp(-.000012 * t); }\n\nvec3 fog(vec3 color, vec3 fogColor, float dist)\n{\n    return vec3(color.x * _lambdaFog(dist),\n                color.y * _lambdaFog(2.*dist),\n                color.z * _lambdaFog(4.*dist)) +\n           vec3(fogColor.x * (1. - _lambdaFog(dist)),\n                fogColor.y * (1. - _lambdaFog(2.*dist)),\n                fogColor.z * (1. - _lambdaFog(4.*dist)));\n}\n\nvec3 mountainColor(vec3 pos, vec3 normal, vec3 rd)\n{\n    float diffuseCoef = clamp(dot(normal, sunPosition), 0., 1.);\n    float specularCoef = pow(clamp(dot(reflect(sunPosition, normal), rd), 0., 1.), 8.);\n    float shadowCoef = mountainShadow(500., 10000., pos, sunPosition);\n\n    vec3 skyContribution = (.2 + normal.y/2.)*skyColor/5.;\n    vec3 terrainContribution = clamp(dot(normal, -sunPosition), .0, 1.) * terrainColor/10.;\n    vec3 ambiantColor = skyContribution + terrainContribution;\n\n    vec3 color = ambiantColor + (terrainColor * diffuseCoef + terrainColor * specularCoef * .1) * shadowCoef;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    vec3 rayOrigin, rayDirection;\n    \n    handleCamera(rayOrigin, rayDirection, cameraPosition, vec2(.2, .0), 0., 1., fragCoord);\n    \n    float tMountain = raymarchMountain(tMin, tMax, rayOrigin, rayDirection);\n    vec3 posMountain = rayOrigin + tMountain * rayDirection;\n    vec3 terrainNormal = mountainNormals(posMountain);\n    \n    float tOcean = raymarchOcean(tMin, tMax, rayOrigin, rayDirection);\n    vec3 posOcean = rayOrigin + tOcean * rayDirection;\n    vec3 oceanNormal = oceanNormals(posOcean);\n    \n    vec3 color = skyColor;\n    \n    // Mountain\n    if (tMountain < tMax && tMountain < tOcean)\n    {\n        color = mountainColor(posMountain, terrainNormal, rayDirection);\n    }\n    else if (tOcean < tMax && tOcean < tMountain)\n    {\n        float diffuseCoef = clamp(dot(oceanNormal, sunPosition), 0., 1.);\n        float specularCoef = pow(clamp(dot(reflect(sunPosition, oceanNormal), rayDirection), 0., 1.), 8.);\n        \n        // Color from the terrain below the water\n        vec3 underwaterColor = mountainColor(posMountain, terrainNormal, rayDirection);\n        // but only in shallow water\n        underwaterColor = underwaterColor * pow((1. - ((tMountain-tOcean)/tMax)), 256.);\n        // Skew underwater hue toward green/blue\n        underwaterColor = vec3(underwaterColor.x, pow(underwaterColor.y, .7), pow(underwaterColor.z, .8));\n        \n        float perturbationFactor = f(vec2(posOcean.x / (200. + 50. * cos(iTime*.71)), posOcean.z / (200. + 50. * sin(iTime*.73))));\n        vec3 baseOceanColor = oceanColor/8. * clamp(0., 1., smoothstep(-.6, 1.6, perturbationFactor));\n        color = baseOceanColor + oceanColor * pow(diffuseCoef, 4.) + specularCoef * sunColor;\n        // Fresnel ?\n        float fresnel = (abs(dot(rayDirection, oceanNormal)));\n        color = color + underwaterColor + vec3(0.5) * pow(1.-fresnel, 10.);\n    }\n    color = fog(color, skyColor, min(tMountain, tOcean));\n    \n    // Color correction\n    color = smoothstep(0., 1., color);\n    color = vec3(color.x, pow(color.y, .9), color.z) + vec3(0., 0., 1.)/16.;\n    color = sqrt(color); // Gamma correction\n    color = color + pow(max(0., dot(normalize(rayDirection), sunPosition)), 2.) * sunColor/2.; // Sun\n    \n    //Vignette\n    float xResolutionFactor = iResolution.y / iResolution.x * 0.95;\n    float yResolutionFactor = .95;\n    float vignetteStrength = 32.;\n    color = color\n            * (1. - pow(abs(uv.x * xResolutionFactor), vignetteStrength))\n            * (1. - pow(abs(uv.y * yResolutionFactor), vignetteStrength));\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}