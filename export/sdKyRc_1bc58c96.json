{"ver":"0.1","info":{"id":"sdKyRc","date":"1655361124","viewed":204,"name":"Raymarching in 4D","username":"iluha168","description":"Trying to project from 2D plane straight into 4D world","likes":4,"published":1,"flags":64,"usePreview":0,"tags":["raytracing","raymarching","4d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4l2XWD","filepath":"https://soundcloud.com/tltombstone/discord","previewfilepath":"https://soundcloud.com/tltombstone/discord","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 300\n#define SURF_DIST 0.0001\n#define PI 3.14159265359\n#define AA 0.5\nvec4 camera;\nvec2 e = vec2(.001, 0);\n\nfloat smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\nmat4 rotMat(float xy, float xz, float xw, float yz, float yw, float zw){\n    return mat4(\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, cos(xy), -sin(xy),\n        0, 0, sin(xy), cos(xy)\n    ) * mat4(\n        1, 0, 0, 0,\n        0, cos(xz), 0, -sin(xz),\n        0, 0, 1, 0,\n        0, sin(xz), 0, cos(xz)\n    ) * mat4(\n        1, 0, 0, 0,\n        0, cos(xw), -sin(xw), 0,\n        0, sin(xw), cos(xw), 0,\n        0, 0, 0, 1\n    ) * mat4(\n        cos(yz), 0, 0, -sin(yz),\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        sin(yz), 0, 0, cos(yz)\n    ) * mat4(\n        cos(yw), 0, -sin(yw), 0,\n        0, 1, 0, 0,\n        sin(yw), 0, cos(yw), 0,\n        0, 0, 0, 1\n    ) * mat4(\n        cos(zw), -sin(zw), 0, 0,\n        sin(zw),  cos(zw), 0, 0,\n        0, 0, 1, 0,\n        0, 0, 0, 1\n    );\n}\n\nfloat hypsphere(vec4 p, float r){\n    return length(p) - r;\n}\n\nfloat hypbox(vec4 p, vec4 dims){\n  vec4 q = abs(p) - dims;\n  return min(max(max(q.x,q.y),max(q.z,q.w)), 0.0) + length(max(q,0.0));\n}\n\nfloat hyptorus(vec4 p, float r, float thicc){\n  vec3 q = vec3(length(p.xy)-r,p.z,p.w);\n  return length(q)-thicc;\n}\n\nfloat hypcylinder(vec4 p, float r, float h){\n  vec2 d = abs(vec2(length(p.xyz),p.w)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat scene(vec4 p){\n    float d = 9999999999999999999.;\n    {\n        vec4 pos = p-vec4(-2.,1.8,0.5,1.5);\n        d = max(\n            hypbox(\n                pos*rotMat(iTime/9.,iTime/8.,0.,0.,0.,iTime/7.),\n                vec4(0.7)\n            ),\n            -hypsphere(pos, 1.1)\n        );\n        d = smin(d, hypcylinder(\n            pos*rotMat(iTime/4.,iTime/2.,iTime/3.,iTime,iTime/5.,0.),\n            0.3, 1.5\n        ), 4.);\n    }{ \n        vec2 m = iMouse.xy / iResolution.xy;\n        mat4 rot = rotMat(0.,0.,-m.y*6.28,-m.x*6.28,0.,0.);\n        float r = texture(iChannel0,vec2(.2, 0.))[0] - 0.2;\n        vec4 pos = (p-vec4(1.,1.5,0.,1.))*rot;\n        d = min(d, hyptorus(\n            pos, r+0.4, 0.3\n        ));\n    }\n    d = min(d, p.y);\n    return d;\n}\n\nvec4 Normal(vec4 p){\n    return normalize(\n        scene(p) - vec4(\n            scene(p-e.xyyy),\n            scene(p-e.yxyy),\n            scene(p-e.yyxy),\n            scene(p-e.yyyx)\n        )\n    );\n}\n\nfloat RayMarch(vec4 ro, vec4 rd){\n    float d0 = 0.;\n    for(int i=0; i<MAX_STEPS; i++){\n        vec4 p = ro + d0*rd;\n        float d = scene(p);\n        d0 += d;\n        if(abs(d) < SURF_DIST) break;\n    }\n    return d0;\n}\n\nfloat Light(vec4 p, vec4 l){\n    vec4 lightRay = normalize(l-p);\n    vec4 normal = Normal(p);\n    float dif = dot(normal, lightRay);\n    float d = RayMarch(p + normal*SURF_DIST*2., lightRay);\n    if(d<length(l-p)) dif *= .1;\n    return dif;\n}\n\nvec4 getPixel(vec4 rd){\n    float d = RayMarch(camera, rd);\n    vec4 p = camera + rd*d;\n    \n    vec4 col;\n    /*\n    col[0] = Light(p, vec4(1.1, 2.8, -1.0, 0.0));\n    col[1] = Light(p, vec4(1.0, 2.7, -1.0, 0.0));\n    col[2] = Light(p, vec4(1.0, 2.8, -1.1, 0.0));\n    col[0] = pow(col[0], .4545);\n    col[1] = pow(col[1], .4545);\n    col[2] = pow(col[2], .4545);\n    fragColor = col;\n    */\n    vec4 lightSource = vec4(1.0, 2.8, -1, 0);\n    col.xyz = vec3(Light(p, lightSource));\n    col.w = 1.;\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    camera = vec4(0,1.3,-1,0);\n    vec4 col = vec4(0);\n    for(float t = 0.; t < 2.*PI; t += PI*2.*AA){\n        vec2 uv = ((fragCoord+vec2(cos(t), sin(t))*0.5)-.5*iResolution.xy)/iResolution.y*4.;\n        col += getPixel(normalize(vec4(uv, 1, 1)));\n    }\n    fragColor = col*AA;\n}","name":"Image","description":"","type":"image"}]}