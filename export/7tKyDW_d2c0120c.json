{"ver":"0.1","info":{"id":"7tKyDW","date":"1716556775","viewed":81,"name":"fractal Cloud 2","username":"eriben0628","description":"good","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["dsf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0) { fragColor = vec4(iResolution.x, 0.0, 0.0, 0.0); return;} \n    float a = float(texture(iChannel0, vec2(0.0,0.0)).x != iResolution.x);\n    \n    vec4 tex = texture(iChannel0, vec2(0.0,0.0));\n    fragColor = vec4(iResolution.x, tex.x, a, tex.w + 1.0);\n    \n    if(a==1.0) fragColor.w = 0.0;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define maxIterations 15\n#define steps 100\n#define steps2 20\n#define increment 4.0/float(steps)\n#define increment2 4.0/float(steps2)\n#define fractalPos vec4(0.0, 0.0, 1.8, 0.0)\n#define LightPos vec4(0.0, 5.0, 5.5, 0.0)\n#define LightColor vec4(0.7,1.0,0.9,1.0);\n#define LightIntensity 4.0\n#define forwardScattering 0.5\n\n\nvec2 randomPos(float t) {\n    float x = fract(t*2.5)*1.0-0.5;//fract(sin(t*22.0)*103.0);\n    float y = fract(t*2.5)*1.0-0.5;//fract(sin(t*30.0)*100.0);\n    return vec2(x,y);\n}\n\nfloat squaredDistance(vec4 p) {\n    return dot(p,p);\n}\n\nvec3 imMul(vec3 a, vec3 b) {\n    vec3 c;\n    c.x = a.x*b.x - a.y*b.y - a.z*b.z + a.y*b.z - a.z*b.y;\n    c.y = a.x*b.y + a.y*b.x;\n    c.z = a.x*b.z + a.z*b.x;\n    \n    return c;\n}\n\nvec4 quaternionMul(vec4 a , vec4 b) {\n    vec4 c;\n    c.x = a.x*b.x - a.y*b.y - a.z*b.z - a.w*b.w;\n    c.y = a.y*b.x + a.x*b.y + a.z*b.w - a.w*b.z;\n    c.z = a.x*b.z + a.z*b.x + a.y*b.w - a.w*b.y;\n    c.w = a.x*b.w + a.w*b.x + a.y*b.z - a.z*a.y;\n    \n    return c;\n}\n\nfloat fractal(vec4 p) {\n    vec4 z = p;\n    vec4 c = p*0.2+vec4(0.2, 0.3, 0.7, 0.0);\n   \n    for(int i = 0; i < maxIterations; i++) {\n        if(length(z) > 2.0) {\n            return float(i)/float(maxIterations)*0.01;\n        }\n        \n        z = quaternionMul(z,z) + c;\n    }\n    \n    return 10.0;\n}\n\nvec3 trace(vec3 Origin, vec3 Dir) {\n    vec4 p = vec4(Origin, 0.0);\n    vec4 dir = normalize( vec4(Dir,0.0) );\n    float totalDensity = 0.0;\n    vec4 totalLight = vec4(0.0);\n    vec4 totalLight2 = vec4(0.0);\n    float transmittence = 1.0;\n\n    for(int i = 0; i < steps; i++) {\n        \n        vec4 LightDir = normalize(LightPos-p);\n        float density = fractal(p - fractalPos);\n        totalDensity += density*increment;\n        float transmittence2 = 1.0;//20.0/squaredDistance(p-LightPos);\n        totalLight2 = vec4(0.0);\n        vec4 p2 = p;\n        if(density >= 0.0001) {\n            for(int j = 0; j < steps2; j++) {\n                float density2 = fractal(p2-fractalPos);\n                if(density2 > 0.0001) {\n                    transmittence2 *= exp(-density2*increment2);\n                    totalLight2 += 1.0/squaredDistance(p2-LightPos) * transmittence2 * increment2 * LightColor;\n                }\n                //p2 += LightDir*(increment2+randomPos(iTime).y*increment2);\n                if(j != steps2) p2 += LightDir * (increment2+randomPos(iTime).y*increment2);\n                else p2 += LightDir*increment2;\n            }\n            \n            totalLight2 *= (abs(dot(LightDir, dir))*forwardScattering+1.0-forwardScattering) * LightIntensity;\n        }\n        transmittence *= exp(-density*increment);\n        totalLight += totalLight2*transmittence * increment * LightColor;//1.0/squaredDistance(p-LightPos) * transmittence * increment;//\n        \n        if(i != steps) p += dir * (increment+randomPos(iTime).x*increment);\n        else p += dir*increment;\n    }\n    \n    \n    return vec3(totalLight);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord + randomPos(iTime) )/iResolution.xy;\n    vec2 r = fragCoord/iResolution.xy;\n    uv = uv*2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 Dir = normalize(vec3(uv,1.));\n    vec3 col = trace(vec3(0.0, 0.0, 0.0), Dir);\n    vec4 tex0 = texture(iChannel0, r);\n    vec4 tex1 = texture(iChannel1, r);\n    vec3 p = (tex1.rgb*tex0.w+col)/(tex0.w+1.0);\n    //p = max(tex1.rgb,col);\n    \n    \n    if(iFrame == 0) fragColor = vec4(col,1.0);\n    else fragColor = vec4(p,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}