{"ver":"0.1","info":{"id":"wtscWS","date":"1592990681","viewed":106,"name":"LightD2-colored","username":"xach","description":"Light2D, colored implementation","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","math","light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MAX_STEP = 100.0;\nconst float MAX_DISTANCE = 1.5;\nconst float EPSILON = 0.0001;\nconst float SAMPLES = 128.0;\n\nconst float TWO_PI = 6.28318530718;\n\nconst float BIAS = 0.001;\nconst float MAX_DEPTH = 3.0;\n\nvec2  m;\n\nconst vec3 BLACK = vec3(0.0,0.0,0.0);\nconst vec3 WHITE = vec3(1.0,1.0,1.0);\n\n\nstruct ssDot{float sd; float reflectivity; float eta; vec3 emission; vec3 absorption;};\n\n//Color funcs\nvec3 colorAdd(vec3 a, vec3 b) {\n    return vec3( a.r + b.r, a.g + b.g, a.b + b.b);\n}\n\nvec3 colorMultiply(vec3 a, vec3 b) {\n    return vec3( a.r * b.r, a.g * b.g, a.b * b.b);\n}\n\nvec3 colorScale(vec3 a, float s) {\n    return vec3( a.r * s, a.g * s, a.b * s);\n}\n    \n    \nssDot unionOp(ssDot a, ssDot b){\n    if (a.sd < b.sd){\n        return a;\n    }else{\n        return b;\n    }\n}\nfloat fresnel(float cosi, float cost, float etai,float etat) {\n    float rs = (etat * cosi - etai * cost) / (etat * cosi + etai * cost);\n    float rp = (etai * cosi - etat * cost) / (etai * cosi + etat * cost);\n    return (rs * rs + rp * rp) * 0.5f;\n}\n\nvec3 beerLambert(vec3 a, float d) {\n    return vec3(exp(-a.r * d), exp(-a.g * d), exp(-a.b * d));\n}\n\nfloat box(float x, float y, float cx, float cy, float theta, float sx, float sy) {\n    float costheta = cos(theta), sintheta = sin(theta);\n    float dx = abs((x - cx) * costheta + (y - cy) * sintheta) - sx;\n    float dy = abs((y - cy) * costheta - (x - cx) * sintheta) - sy;\n    float ax = max(dx, 0.0f), ay = max(dy, 0.0f);\n    return min(max(dx, dy), 0.0f) + sqrt(ax * ax + ay * ay);\n}\n\nfloat circle(float x,float y,float xc,float yc,float r){\n    return sqrt((x-xc)*(x-xc)+(y-yc)*(y-yc))-r;\n}\n\nssDot scene(float x,float y){\n    ssDot r1 = ssDot(circle(x,y,0.5,0.5, 0.25), 2.0, 1.2, vec3(0.7, 0.1, 0.5), vec3(0.8,0.6,0.0));\n    //ssDot r2 = ssDot(circle(x,y,m.x,m.y, 0.25),  2.0, 1.2,vec3(0.7, 0.1, 0.5), vec3(0.8,0.6,0.0));\n    ssDot r2 = ssDot(circle(x,y,m.x,m.y, 0.1),  1.0, 0.3, vec3(1.0,0.8,0.5), vec3(0.8,0.6,0.0));\n    ssDot r3 = ssDot(circle(x,y,-0.4,0.0, 0.5), 1.0, 0.2, colorScale(WHITE, (1.0+sin(iTime))/2.0), WHITE);\n    ssDot r4 = ssDot(box(x,y,-1.4,-0.1,0.0,0.1,0.70), 0.70, 0.0, vec3(1.0,0.7,0.8), BLACK);\n    return unionOp(unionOp(unionOp(r2, r1),r3),r4);\n}\n\n\nvoid gradient(float x, float y, out float nx, out float ny) {\n    nx = (scene(x + EPSILON, y).sd - scene(x - EPSILON, y).sd) * (0.5 / EPSILON);\n    ny = (scene(x, y + EPSILON).sd - scene(x, y - EPSILON).sd) * (0.5 / EPSILON);\n}\n\nvoid reflectX(float ix, float iy, float nx, float ny, out float rx, out float ry) {\n    float idotn2 = (ix * nx + iy * ny) * 2.0f;\n    rx = ix - idotn2 * nx;\n    ry = iy - idotn2 * ny;\n}\n\nbool refractX(float ix, float iy, float nx, float ny, float eta, out float rx, out float ry) {\n    float idotn = ix * nx + iy * ny;\n    float k = 1.0f - eta * eta * (1.0f - idotn * idotn);\n    if (k < 0.0f)\n        return false; // Total internal reflection\n    float a = eta * idotn + sqrt(k);\n    rx = eta * ix - a * nx;\n    ry = eta * iy - a * ny;\n    return true;\n}\n\n/*float trace(float ox,float oy, float dx, float dy, float depth){\n    float t = 0.0;\n    for(float i = 0.0; i < MAX_STEP && t < MAX_DISTANCE; i++){\n        float x = ox + dx * t;\n        float y = oy + dy * t;\n        ssDot r = scene(x,y);\n        if (r.sd < EPSILON){\n            float sum = r.emission;\n        \tif (depth < MAX_DEPTH && r.reflectivity > 0.0f) {\n                float nx, ny, rx, ry;\n                gradient(x, y, nx, ny);\n                reflect(dx, dy, nx, ny, rx, ry);\n                sum += r.reflectivity;// * trace2(x + nx * BIAS, y + ny * BIAS, rx, ry, depth + 1.0);\n            }\n            return sum;\n        }\n        t += r.sd;\n    }\n    return 0.0;\n}*/\n\n//Yep, I'm too lazy now to convert recursive to iterational\nvec3 trace3(float ox, float oy, float dx, float dy, float depth) {\n    float t = 1e-3f;\n    float sgn = scene(ox, oy).sd > 0.0f ? 1.0f : -1.0f;\n    for (float i = 0.0; i < MAX_STEP && t < MAX_DISTANCE; i++) {\n        float x = ox + dx * t, y = oy + dy * t;\n        ssDot r = scene(x, y);\n        if (r.sd * sgn < EPSILON) {\n            vec3 sum = r.emission;\n            if (depth < MAX_DEPTH && r.eta > 0.0) {\n                float nx, ny, rx, ry, refl = r.reflectivity;\n                gradient(x, y, nx, ny);\n                float s = 1.0 / (nx * nx + ny * ny);\n                nx *= sgn * s;\n                ny *= sgn * s;\n                if (r.eta > 0.0) {\n                    if (refractX(dx, dy, nx, ny, sgn < 0.0 ? r.eta : 1.0 / r.eta, rx, ry)) {\n                        float cosi = -(dx * nx + dy * ny);\n                        float cost = -(rx * nx + ry * ny);\n                        refl = sgn < 0.0 ? fresnel(cosi, cost, r.eta, 1.0) : fresnel(cosi, cost, 1.0, r.eta);\n                        refl = max(min(refl, 1.0f), 0.0);\n                        //sum = colorAdd(sum, colorScale(trace(x - nx * BIAS, y - ny * BIAS, rx, ry, depth + 1.0), 1.0 - refl));\n                    }\n                    else\n                        refl = 1.0; // Total internal reflection\n                }\n                if (refl > 0.0) {\n                    reflectX(dx, dy, nx, ny, rx, ry);\n                    //sum = colorAdd(sum, colorScale(trace(x + nx * BIAS, y + ny * BIAS, rx, ry, depth + 1.0), refl));\n                }\n            }\n            return colorMultiply(sum, beerLambert(r.absorption, t));\n        }\n        t += r.sd * sgn;\n    }\n    return BLACK;\n}\n\nvec3 trace2(float ox, float oy, float dx, float dy, float depth) {\n    float t = 1e-3f;\n    float sgn = scene(ox, oy).sd > 0.0f ? 1.0f : -1.0f;\n    for (float i = 0.0; i < MAX_STEP && t < MAX_DISTANCE; i++) {\n        float x = ox + dx * t, y = oy + dy * t;\n        ssDot r = scene(x, y);\n        if (r.sd * sgn < EPSILON) {\n            vec3 sum = r.emission;\n            if (depth < MAX_DEPTH && r.eta > 0.0) {\n                float nx, ny, rx, ry, refl = r.reflectivity;\n                gradient(x, y, nx, ny);\n                float s = 1.0 / (nx * nx + ny * ny);\n                nx *= sgn * s;\n                ny *= sgn * s;\n                if (r.eta > 0.0) {\n                    if (refractX(dx, dy, nx, ny, sgn < 0.0 ? r.eta : 1.0 / r.eta, rx, ry)) {\n                        float cosi = -(dx * nx + dy * ny);\n                        float cost = -(rx * nx + ry * ny);\n                        refl = sgn < 0.0 ? fresnel(cosi, cost, r.eta, 1.0) : fresnel(cosi, cost, 1.0, r.eta);\n                        refl = max(min(refl, 1.0f), 0.0);\n                        //sum = colorAdd(sum, colorScale(trace3(x - nx * BIAS, y - ny * BIAS, rx, ry, depth + 1.0), 1.0 - refl));\n                    }\n                    else\n                        refl = 1.0; // Total internal reflection\n                }\n                if (refl > 0.0) {\n                    reflectX(dx, dy, nx, ny, rx, ry);\n                    //sum = colorAdd(sum, colorScale(trace3(x + nx * BIAS, y + ny * BIAS, rx, ry, depth + 1.0), refl));\n                }\n            }\n            return colorMultiply(sum, beerLambert(r.absorption, t));\n        }\n        t += r.sd * sgn;\n    }\n    return BLACK;\n}\n\nvec3 trace(float ox, float oy, float dx, float dy, float depth) {\n    float t = 1e-3f;\n    float sgn = scene(ox, oy).sd > 0.0f ? 1.0f : -1.0f;\n    for (float i = 0.0; i < MAX_STEP && t < MAX_DISTANCE; i++) {\n        float x = ox + dx * t, y = oy + dy * t;\n        ssDot r = scene(x, y);\n        if (r.sd * sgn < EPSILON) {\n            vec3 sum = r.emission;\n            if (depth < MAX_DEPTH && r.eta > 0.0) {\n                float nx, ny, rx, ry, refl = r.reflectivity;\n                gradient(x, y, nx, ny);\n                float s = 1.0 / (nx * nx + ny * ny);\n                nx *= sgn * s;\n                ny *= sgn * s;\n                if (r.eta > 0.0) {\n                    if (refractX(dx, dy, nx, ny, sgn < 0.0 ? r.eta : 1.0 / r.eta, rx, ry)) {\n                        float cosi = -(dx * nx + dy * ny);\n                        float cost = -(rx * nx + ry * ny);\n                        refl = sgn < 0.0 ? fresnel(cosi, cost, r.eta, 1.0) : fresnel(cosi, cost, 1.0, r.eta);\n                        refl = max(min(refl, 1.0f), 0.0);\n                        sum = colorAdd(sum, colorScale(trace2(x - nx * BIAS, y - ny * BIAS, rx, ry, depth + 1.0), 1.0 - refl));\n                    }\n                    else\n                        refl = 1.0; // Total internal reflection\n                }\n                if (refl > 0.0) {\n                    reflectX(dx, dy, nx, ny, rx, ry);\n                    sum = colorAdd(sum, colorScale(trace2(x + nx * BIAS, y + ny * BIAS, rx, ry, depth + 1.0), refl));\n                }\n            }\n            return colorMultiply(sum, beerLambert(r.absorption, t));\n        }\n        t += r.sd * sgn;\n    }\n    return BLACK;\n}\n\n\nfloat rand(){\n\treturn 0.0;//fract(sin(iTime)*100000.0);\n}\n\n/*float sampleFun(float x, float y){\n    float sum = 0.0;\n    for (float i = 0.0; i < SAMPLES; i++){\n        float a = TWO_PI*(i+rand())/SAMPLES;\n        sum += trace(x, y, cos(a), sin(a),0.0);\n    }\n                     \n    return sum / SAMPLES;\n}*/\n\nvec3 sampleFun(float x, float y) {\n    vec3 sum = BLACK;\n    for (float i = 0.0; i < SAMPLES; i++) {\n        //float a = TWO_PI * (i + (float)rand() / RAND_MAX) / N;\n        float a = TWO_PI * (i) / SAMPLES;\n        sum = colorAdd(sum, trace(x, y, cos(a), sin(a), 0.0));\n        if( sum.x>1000.0 ) break;\n    }\n    return colorScale(sum, 1.0 / SAMPLES);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 uv = (2.*fragCoord-iResolution.xy ) / iResolution.y;\n    \n    m  = (2.*iMouse.xy-iResolution.xy ) / iResolution.y;\n    \n    // Time varying pixel color\n    vec3 col = sampleFun(uv.x, uv.y);;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}