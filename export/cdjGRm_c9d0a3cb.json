{"ver":"0.1","info":{"id":"cdjGRm","date":"1667409496","viewed":137,"name":"Continuous vector field & paths","username":"Envy24","description":"Field can be defined in Common tab.\nClick with mouse to start new path (try to click close to stable points).\nQ - erase paths.\n\nBufferA - process field and arrows.\nBufferB - process path.\nImage - coloring.","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["field","vector","path","equations","continuous","differential","isocurve"],"hasliked":0,"parentid":"cdj3zw","parentname":"Continuous vector field (NDC)"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                         ( iResolution )\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec4 bufA = TEXF0(SC);\n    vec4 bufB = TEXF1(SC);\n            \n    O = mix( bufA, (1.-bufA)*0.5, smoothstep((SCENE_SCALE*2.5)/R.y, 0., bufB.z));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TEXF0(SC)                 ( texelFetch(iChannel0, ivec2(SC), 0) )  // (channel, integer coordinates, mipmap level)\n#define TEXF1(SC)                 ( texelFetch(iChannel1, ivec2(SC), 0) )\n\n/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float r)\n{\n    return length(C - NDC)-r;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E,\n    float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}\n\n#define X ( P.x )\n#define Y ( P.y )\n\n/*\n    Define vector field or differential equations.\n*/\n\n/**\n#define ISO_SCALE      ( 300. )  // for isocurves\n#define ISO_M          ( 1. )\n#define DIR_SCALE      ( 0.125 ) // for arrows\n#define STEP           ( 0.125 ) // for path\n#define SCENE_SCALE    ( 2.0 )\n#define ORIGIN         ( vec2(0) )\n#define T0             ( iTime )\nvec2 field(vec2 P, float t)\n{\n    //return vec2(1, 1);\n    //return vec2(P.y*P.y, -P.x);\n    //return vec2(P.y, -P.x);\n    //return vec2(2.*P.x, 2.*P.y);\n    //return rotateAroundZ(vec2(P.y, -P.x), t);\n    return rotateAroundZ(vec2(P.y*P.y, -P.x), t);\n}\n/**/\n#define ISO_SCALE      ( 3. )   // for isocurves\n#define ISO_M          ( 5. )\n#define DIR_SCALE      ( 20.0 ) // for arrows\n#define STEP           ( 10.0 ) // for path\n#define SCENE_SCALE    ( 200.0 )\n#define ORIGIN         ( vec2(200) )\n#define T0             ( iTime )\nvec2 field(vec2 P, float T)\n{\n    // Example from: https://www.shadertoy.com/view/4s23DG\n    return vec2(cos(P.x * 0.01 + P.y * 0.01) + cos(P.y * 0.005 + T), 2.0 * cos(P.y * 0.01  + T * 0.3)) * 0.5;  \n}\n/**\n#define ISO_SCALE      ( 3. )   // for isocurves\n#define ISO_M          ( 1. )\n#define DIR_SCALE      ( 20.0 ) // for arrows\n#define STEP           ( 5.0 )  // for path\n#define SCENE_SCALE    ( 200.0 )\n#define ORIGIN         ( vec2(200) )\n#define T0             ( iTime )\nvec2 field(vec2 P, float T)\n{\n    // Example from: https://www.shadertoy.com/view/4s23DG\n    return vec2(cos(P.x * 0.017 + cos(P.y * 0.004 + T * 0.1) * 6.28 * 4.0) * 3.0, cos(6.28 * cos(P.y * 0.01 + P.x * 0.007)));   \n}\n/**\n#define ISO_SCALE      ( 200. )  // for isocurves\n#define ISO_M          ( 1. )\n#define DIR_SCALE      ( 0.125 ) // for arrows\n#define STEP           ( 0.125 ) // for path\n#define SCENE_SCALE    ( 3.0 )\n#define ORIGIN         ( vec2(0.2, 0.26) )\n#define T_MIN          ( -0.5 )\n#define T_MAX          ( 0.5 )\n#define T0             ( sinOSC(T_MIN, T_MAX, iTime ) ) \nvec2 field(in vec2 P, float T)\n{    \n    P = \n        vec2(\n           -Y*T - T*X + Y,\n            X*X - T*X - X + T);\n            \n    return P;\n}\n/**/","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )                      // Aspect ratio.\n#define PIXELATE(SC, PS)          ( floor( (SC) / (PS) ) * (PS) )    // PS - pixel size\n\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool use_mouse)\n{\n    vec2 M = MOUSE_OFFSET * (use_mouse ? 1. : 0.);\n    return ((2. * (SC - M) - R.xy) / R.y) * scale - origin;\n}\nvec2 truncated_centered_cells_map(in vec2 SC, in float scale, in vec2 origin, in bool use_mouse, in float ps_size)\n{\n    return map_to_centered_ndc(PIXELATE(SC, ps_size)+vec2(ps_size*0.5), scale, origin, use_mouse);\n}\n\n// Points after point E.\nfloat arrowSDF(\n    in vec2 NDC,\n    in vec2 B,\n    in vec2 E,\n    in float r,\n    in float S) // Scale for working in screen coordinates.\n{\n    float len = length(B-E);\n    vec2 dir = len < 1e-7 ? vec2(1,0) : normalize(E-B),\n         up = cross(vec3(dir, 0.), vec3(0, 0, -1)).xy,\n         C = E - dir * 0.05 * S, //      U--\n         U = C + up  * 0.05 * S, // B----C--E--E'\n         D = C - up  * 0.05 * S; //      D--\n         E += dir * 0.05 * S;\n    \n    vec3 BARY = inverse(mat3(\n            U.x, U.y, 1.0,\n            D.x, D.y, 1.0,\n            E.x, E.y, 1.0)) * vec3(NDC.x, NDC.y, 1.0);\n    \n    float sign = \n        BARY.x >= 0.0 &&    \n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 ?  // inside triangle?\n            -1. : 1.;\n    \n    float d = segmentSDF_L2(NDC, U, D, 0.);\n          d = min(d, segmentSDF_L2(NDC, U, E, 0.));\n          d = min(d, segmentSDF_L2(NDC, D, E, 0.));\n          d = \n              len < 0.05 * S ? \n                  d :\n                  min(d, segmentSDF_L2(NDC, B, C, 0.));\n    \n    return sign*d-r;\n}\n\n#define RANGES         ( map_to_centered_ndc(R.xy, SCENE_SCALE, vec2(0), false) )\n\n#define ORDER          ( 5. )   // increase this parameter if arrows looks truncated.\n#define CELL_SIZE_SC   ( 50. )\n#define CELL_SIZE_NDC  ( (2.*CELL_SIZE_SC*SCENE_SCALE) / R.y )\nvec3 scene(in vec2 SC)\n{      \n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false),\n         CC = truncated_centered_cells_map(SC, SCENE_SCALE, ORIGIN, false, CELL_SIZE_SC),\n         ranges = RANGES;\n                        \n    vec2 CC_ = CC, F = field(NDC, T0);\n    //vec3 color = vec3(normalize(field(CC, T0)), 0.5);  // Pixelated    \n    vec3 color = vec3(normalize(F), 0.5); // Smooth\n     \n    /* On/Off isocurves. */\n    float dist = length(F) * ISO_M,\n         isocurves = abs(fract(dist)-0.5)/fwidth(dist);\n         // variants without fwidth.\n         //isocurves = abs(fract(dist)-0.5); \n         //isocurves = (1.5-clamp((fract(dist)-0.5), 0., 1.));\n         //unit = 1./(R.y), isocurves = smoothstep(-unit, unit, clamp((fract(dist)-0.5), 0., 1.));\n         //unit = 10./(R.y), isocurves = smoothstep(-unit, unit, clamp(abs(fract(dist)-0.5), 0., 1.));\n         color = mix( color, vec3(0.5), smoothstep((SCENE_SCALE*ISO_SCALE)/R.y, 0., isocurves) );\n    /**/  \n     \n    for (float y = -ORDER; y <= ORDER; y += 1.)\n    {       \n        for (float x = -ORDER; x <= ORDER; x += 1.)\n        {\n            // Calculate current cell center.\n            vec2 CC = CC_ + vec2(x*CELL_SIZE_NDC, y*CELL_SIZE_NDC);\n            \n            // Optimization 1. Truncate scene.\n            if (abs(CC.x+ORIGIN.x) > ranges.x || abs(CC.y+ORIGIN.y) > ranges.y) { continue; }\n            \n            /* Optimization 2. If NDC is far from CC, then skip this cell. *\n            vec2 diff = CC - NDC; \n            if (dot(diff, diff) > CELL_SIZE_NDC) { continue; }\n            /**/\n            \n            vec2 dir = field(CC, T0) * DIR_SCALE,\n                 E = CC + dir * 0.5; // half step forward\n                 CC -= dir * 0.5;    // half step back\n\n            float minDist = arrowSDF(NDC, CC, E, 0., 0.25*SCENE_SCALE);\n    \n            color = mix( color, vec3(1), smoothstep((3.*SCENE_SCALE)/R.y, 0., minDist));                 \n        }\n    }\n   \n    return color;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec3 color = scene(SC); // continuous and faster than second scene.\n\n    O = vec4(color,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define R                         ( iResolution )\n\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool use_mouse)\n{\n    vec2 M = MOUSE_OFFSET * (use_mouse ? 1. : 0.);\n    return ((2. * (SC - M) - R.xy) / R.y) * scale - origin;\n}\n\nvec3 scene(in vec2 SC)\n{      \n    vec3 data = texelFetch(iChannel0, ivec2(SC), 0).xyz;\n    vec2 B = data.xy;\n\n#define KEY_Q                     ( 81.5 )\n#define KEY_Q_IS_PRESSED          ( texelFetch(iChannel3,ivec2(KEY_Q,1),0).x > 0.)\n    if (iFrame == 0 || KEY_Q_IS_PRESSED == true) { return vec3(9e9); }\n\n    if (iMouse.w > 0. || iFrame == 0)\n    {\n        B = map_to_centered_ndc(iMouse.xy, SCENE_SCALE, ORIGIN, false);\n       // data.z=9e9.;  // Comment this line if you want single path.\n    }\n\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false);\n\n    /* Process trace.*/\n    float minDist = 99.;\n\n    vec2 dir = field(B, T0);\n    float mag = length(dir)*STEP;\n    vec2 E = B + normalize(dir) * mag;\n\n    minDist = segmentSDF_L2(NDC, B, E, 2.*SCENE_SCALE*0.001);        \n\n    return vec3(E.x, E.y, min(minDist, data.z));\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec3 data = scene(SC); // (x, y, min_dist)\n\n    O = vec4(data,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}