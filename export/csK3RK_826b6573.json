{"ver":"0.1","info":{"id":"csK3RK","date":"1688833305","viewed":94,"name":"Newton`s Cradle","username":"SlowMetanoia","description":"My attempt to follow the tutorial with some changes. There is a link.\nhttps://youtu.be/nd7Auhb9YN8\n\ncamera rotation by arrows\nzoom by \"I\" and \"O\"\n","likes":3,"published":1,"flags":48,"usePreview":1,"tags":["fromtutorial"],"hasliked":0,"parentid":"msGGzV","parentname":"Ray Marching template0"},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int MAT_BASE = 1;\nconst int MAT_BALL = 2;\nconst int MAT_ROPE = 3;\n\nvec2 MinV2(vec2 a, vec2 b){\n    return a.x<b.x ? a : b;\n}\n\nvec2 sdBall(vec3 p, float angle){\n    p.y -= 2.;\n    p.xy *= rot(angle);\n    p.y += 2.;\n\n    float ballR = .3;\n    float balls = sdSphere(p,ballR);\n    vec3 ringP = translate(p, vec3(0.,ballR,.0));\n    ringP = rot(ringP, vec3(PI/2.,0,0));\n    float ring = sdTorus(ringP, vec2(ballR*.15,ballR*.05));\n    \n    float line1 = sdCapsule(p, vec3(0.,ballR,.0), vec3(0,2,1),ballR*.05);\n    float line2 = sdCapsule(p, vec3(0.,ballR,.0), vec3(0,2,-1),ballR*.05);\n    float lines = min(line1, line2);\n    \n    float d = min(balls, ring);\n    d = min(lines,d);\n    \n    int mat = MAT_BALL;\n    if(d == lines) mat = MAT_ROPE;\n    return vec2(d, mat);\n}\n//----------------------Scene description------------------------\n//distance function for closest scene object\n//all distances must be calculated in there\nvec2 getDist(vec3 p){\n    float Pi=3.1415;\n    vec2 mouseUV = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    vec4 ctrl = texelFetch(iChannel0, ivec2(0,0),0);\n    float t = iTime;\n    \n    vec3 bp = translate(p, vec3(0,0,0));\n    vec3 fp1 = translate(p,vec3(0,1,-1));\n    vec3 fp2 = translate(p,vec3(0,1,1));\n\n    \n    float bd = dBox(bp, vec3(2,0,1))-.4;\n    bd += sin(p.x*7.)*.001;\n    float fd1 = length(vec2(dBox(fp1.xy, vec2(2,2)),fp1.z))-.1;\n    float fd2 = length(vec2(dBox(fp2.xy, vec2(2,2)),fp2.z))-.1;\n    \n    float a = sin(t*PI);\n    float al = min(0.,a);\n    float ar = max(0.,a);\n    float aa = a*.05;\n    \n    float r = .305;\n    \n    vec2 \n        b1 = sdBall(translate(p,vec3(r,1,0)), aa),\n        b2 = sdBall(translate(p,vec3(-r,1,0)), aa),\n        b3 = sdBall(translate(p,vec3(3.*r,1,0)), mix(al,aa,.9)),\n        b4 = sdBall(translate(p,vec3(-3.*r,1,0)), mix(ar,aa,.9)),\n        b5 = sdBall(translate(p,vec3(5.*r,1,0)), al + aa/2.),\n        b6 = sdBall(translate(p,vec3(-5.*r,1,0)), ar + aa/2.);\n    vec2 balls = MinV2(b1,MinV2(b2,MinV2(b3,MinV2(b4,MinV2(b5,b6)))));\n    \n    float planeDist = p.y;\n    float base = min(fd1,fd2);\n    base = opSmoothUnion(base, bd,.1);\n    base = subtract(base, planeDist);\n    \n    \n    float d = MAX_DISTANCE;\n    \n    \n    //d = planeDist;\n    d = min(d, base);\n    d = min(d, balls.x);\n    \n    int mat = 0;\n    \n    if(d == base) mat = MAT_BASE;\n    if(d == balls.x) mat = int(balls.y);\n\n    return vec2(d,float(mat));\n}\n\n\n\n\n//----------------------Technical things needed for ray Marching-\n//Central function in ray marching. \n//It takes camera position and ray direction as as input and returns distance of closest scene object in that direction.\n//It depends on getDist function output.\nvec2 RayMarch(vec3 ro, vec3 rd){\n    vec2 dist = vec2(0.);\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd*dist.x;\n        vec2 dS = getDist(p);\n        dist.x += dS.x;\n        dist.y = dS.y;\n        if(dist.x>MAX_DISTANCE || abs(dist.x)<SURF_DISTANCE) break;\n    }\n    return dist;\n}\n// returns approximated normal vector of scene surface closet to the point.\nvec3 gerNormal(vec3 p){\n    float d = getDist(p).x;\n    vec2 e = vec2(0.01,0.);\n    \n    vec3 n = vec3(d) - vec3(\n        getDist(p - e.xyy).x,\n        getDist(p - e.yxy).x,\n        getDist(p - e.yyx).x);\n    return normalize(n);\n}\n// returns illumination in point on the scene\nfloat getLight(vec3 p){\n    vec3 lightSource = vec3(4,4,4);//vec3(sin(iTime),3,cos(iTime));\n    vec3 l = normalize(lightSource - p);\n    vec3 n = gerNormal(p);\n    \n    vec2 d = RayMarch(p+n*1.1*SURF_DISTANCE,l);\n    \n    float dif = clamp(dot(n,l),0.,1.);\n    if (d.x < length(lightSource-p)){dif *=.5;}\n    return dif;\n}\n\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool isLast){\n    vec3 col = texture(iChannel1, rd).xyz;\n    //distance from origin to closest scene object in ray direction\n    vec2 d = RayMarch(ro,rd);\n    //position, where ray intersects closet scene object\n    vec3 p = ro + rd*d.x;\n    \n    //Diffused light in that position\n    float dif = getLight(p);\n    vec3 n = gerNormal(p);\n    \n    float frensel = pow(1.-dot(n,-rd),5.);\n    \n    if(d.x<MAX_DISTANCE){\n        \n        vec3 r = reflect(rd,n);\n        \n        //vec3 refTex = texture(iChannel1, r).xyz;\n\n        col = abs(n - vec3(0,0,0));//*dif;\n        \n        int mat = int(d.y);\n        \n        if(mat == MAT_BASE){\n            ref = vec3(mix(0.05,.4,frensel));\n            col = vec3(.4)*dif;\n        }\n        if(mat == MAT_BALL){\n            ref = vec3(.9,.7,.3);\n            col = vec3(.15)*dif;\n            if(isLast) col += texture(iChannel1, r).xyz;\n        }\n        if(mat == MAT_ROPE){\n            ref = vec3(.0);\n            col = vec3(.2)*dif;\n        }\n        //col*=dif;\n        //col = vec3(float(mat)/4.);//*dif;\n        //col = vec3(dif);\n        ro = p+n*3.*SURF_DISTANCE;\n        rd = r;\n    }\n    \n    return col;\n}\n\n//--------------------------------Main-------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouseUV = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    \n    //point, camera looking at\n    vec3 lookat = vec3(0,1,0);\n    //ro - Ray origin - where the camera is\n    vec4 ctrl = texelFetch(iChannel0, ivec2(0,0),0);\n    vec3 cyl = mouseOnCylinder(ctrl.xy, vec2(-2.,1));\n    vec3 ro = vec3(0,1.1,0) + vec3(6. + 5.*ctrl.z)*vec3(cyl.x,cyl.y,cyl.z);//vec3(6)*mouseOnSphere(mouseUV);\n\n    //rd - Ray direction - direction from camera through each pixel on the screen\n    vec3 rd = cam(uv,ro,lookat,1.);\n    \n    // rendering materials, reflections, etc.\n    vec3 ref = vec3(0.);\n    vec3 fil = vec3(1.);\n    vec3 col = render(ro,rd,ref,false);\n    \n    for(int i =0; i<BOUNCES; i++){\n        fil *= ref;\n        col += fil*render(ro,rd,ref,i==BOUNCES-1);\n    }\n    \n    //col = vec3(ref);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_STEPS 100\n#define MAX_DISTANCE 100.\n#define SURF_DISTANCE .01\n#define PI 3.1415\n#define E 2.718281\n#define BOUNCES 2\n\nfloat cutDistance(vec3 p, vec3 a, vec3 b){\n    float t = dot(p-a,b-a)/dot(b-a,b-a);\n    t = clamp(t,0.,1.);\n    vec3 c = a + t * (b-a);\n    return length(p-c);\n}\n//-------------------primitives functions-----------------------\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    return cutDistance(p,a,b)- r;\n}\nfloat sdTorus( vec3 p, vec2 t ){\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\nfloat dBox( vec3 p, vec3 b ){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat dBox(vec2 p, vec2 b){\n    vec2 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\nfloat sdSphere(vec3 p, float r){\n    return length(p) - r;\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n//----------------------Operators functions----------------------\nvec3 translate(vec3 p, vec3 d){\n    return p - d;\n}\nmat2 rot(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c,-s,s,c);\n}\nvec3 rot(vec3 p, vec3 angle){\n    p.yz*=rot(angle.x);\n    p.xz*=rot(angle.y);\n    p.xy*=rot(angle.z);\n    return p;\n}\nfloat subtract( float sdf1, float sdf2 ){\n    return max(sdf1,-sdf2);\n}\nfloat intersect(float sdf1, float sdf2 ){\n    return max(sdf1,sdf2);\n}\nfloat unite( float sdf1, float sdf2 ){\n    return min(sdf1,sdf2);\n}\nfloat morph( float sdf1, float sdf2, float k){\n    return mix(sdf1,sdf2,k);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nvec4 opElongate( in vec3 p, in vec3 h )\n{   \n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\n//camera function\n//takes uv, ray origin, looking at point and zoom, returns ray direction for current pixel\nvec3 cam(vec2 uv,vec3 ro, vec3 lookat, float zoom){\n    vec3 f = normalize(lookat - ro);\n    vec3 r = cross(vec3(0.,1.,0.), f);\n    vec3 u = cross(f,r);\n    vec3 c = ro + f*zoom;\n    vec3 i = c+uv.x*r+uv.y*u;\n    vec3 rd = i - ro;\n    return rd;\n}\nvec3 mouseOnSphere(vec2 mouseUV){\n    float Pi = 3.1415;\n    //uv : {-.5,.5}\n    //xyz: {-1,1}\n    float y = sin(mouseUV.y*Pi*2.);\n    float r = cos(mouseUV.y*Pi*2.);\n    float s = sign(r);\n    r = abs(r);\n    float x = s*r*cos(mouseUV.x*Pi*2.);\n    float z = s*r*sin(mouseUV.x*Pi*2.);\n    return normalize(vec3(x,y,z));\n}\nvec3 mouseOnCylinder(vec2 mouseUV, vec2 limits){\n    float Pi = 3.1415;\n    float y = (mouseUV.y + .5)*(limits.y - limits.x) + limits.x;\n    float x = cos(mouseUV.x*Pi*2.);\n    float z = sin(mouseUV.x*Pi*2.);\n    return vec3(x,y,z);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int _F_= 70;\nconst int _G_= 71;\nconst int _I_= 73;\nconst int _O_= 79;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //current stored values\n    vec4 inData = texelFetch(iChannel0, ivec2(0,0),0);\n    \n\n    //current arrow keys state\n    vec4 keysData = vec4(ivec4(\n        texelFetch(iChannel1,ivec2(KEY_LEFT,0),0).x,\n        texelFetch(iChannel1,ivec2(KEY_UP,0),0).x,\n        texelFetch(iChannel1,ivec2(KEY_RIGHT,0),0).x,\n        texelFetch(iChannel1,ivec2(KEY_DOWN,0),0).x\n    ));\n    \n    vec2 morhingKeys = vec2(ivec2(\n        texelFetch(iChannel1,ivec2(_G_,0),0).x,\n        texelFetch(iChannel1,ivec2(_F_,0),0).x\n    ));\n    \n    vec2 zoomKeys = vec2(ivec2(\n        texelFetch(iChannel1,ivec2(_I_,0),0).x,\n        texelFetch(iChannel1,ivec2(_O_,0),0).x\n    ));\n    \n    //camera position\n    inData.x += (keysData.z-keysData.x)/100.;\n    inData.y += (keysData.y-keysData.w)/100.;\n    inData.y = clamp(inData.y, 0.,10.);\n    \n    //some other option keys\n    inData.w += (morhingKeys.y - morhingKeys.x)/300.;\n    inData.w = clamp(inData.w, 0.,1.);\n    \n    //zoom keys\n    inData.z += (zoomKeys.y - zoomKeys.x)/100.;\n    inData.z = clamp(inData.z, -2.,2.);\n    \n    //output\n    fragColor = inData;\n}","name":"Buffer A","description":"","type":"buffer"}]}