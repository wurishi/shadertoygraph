{"ver":"0.1","info":{"id":"WtscR7","date":"1591711482","viewed":84,"name":"GiVD - CSG Shader","username":"RedReservoir","description":"Shader for testing CSG with SDFs.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["givd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_RAYMARCHING_ITERATIONS 100\n#define EPSILON 0.00001\n#define MIN_DIST 0.00001\n#define MAX_DIST 100.0\n\nstruct material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\n        \nstruct light {\n    vec3 position;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\n    \nmaterial mat_red = material(vec3(0.5, 0.5, 0.5), vec3(0.8, 0.2, 0.2), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_green = material(vec3(0.5, 0.5, 0.5), vec3(0.2, 0.8, 0.2), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_blue = material(vec3(0.5, 0.5, 0.5), vec3(0.2, 0.2, 0.8), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_orange = material(vec3(0.5, 0.5, 0.5), vec3(0.8, 0.5, 0.2), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_turquoise = material(vec3(0.5, 0.5, 0.5), vec3(0.2, 0.8, 0.5), vec3(1.0, 1.0, 1.0), 100.0);\nmaterial mat_purple = material(vec3(0.5, 0.5, 0.5), vec3(0.5, 0.2, 0.8), vec3(1.0, 1.0, 1.0), 100.0);\n\nlight[] scene_lights = light[] (\n    light(vec3(0.0, 0.0, 0.0), vec3(0.05, 0.05, 0.05), vec3(0.4, 0.4, 0.4), vec3(0.0, 0.0, 0.0)),\n    light(vec3(10.0, 10.0, 10.0), vec3(0.1, 0.1, 0.1), vec3(0.8, 0.8, 0.8), vec3(1.0, 1.0, 1.0)),\n    light(vec3(-10.0, 10.0, -10.0), vec3(0.1, 0.1, 0.1), vec3(0.8, 0.8, 0.8), vec3(1.0, 1.0, 1.0)),\n    light(vec3(10.0, -10.0, -10.0), vec3(0.1, 0.1, 0.1), vec3(0.8, 0.8, 0.8), vec3(1.0, 1.0, 1.0)),\n    light(vec3(-10.0, -10.0, 10.0), vec3(0.1, 0.1, 0.1), vec3(0.8, 0.8, 0.8), vec3(1.0, 1.0, 1.0))\n);\nint l_num = 2;\n\nvec3 background_color = vec3(0.7, 0.7, 0.9);\n\n//---------------------------------------------------------------------------------\n\nfloat mixInverse(float x, float y, float a) {\n\treturn (a - x) / (y - x);    \n}\n\nfloat unitMap(float x) {\n    return (2.0 / (1.0 + exp(-x))) - 1.0;\n}\n\nfloat unitMapInverse(float x) {\n\treturn -log((2.0 / (x + 1.0)) - 1.0);    \n}\n\nfloat unitPow(float x, float p) {\n\treturn unitMap(pow(unitMapInverse(x), p));   \n}\n\n//---------------------------------------------------------------------------------\n\nfloat sphereSDF(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat cylinderSDF(vec3 p, vec3 c, float h, float r) {\n    float inOutRadius = length(p.xy - c.xy) - r;\n    float inOutHeight = abs(p.z - c.z) - h/2.0;\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    return insideDistance + outsideDistance;\n}\n\n//---------------------------------------------------------------------------------\n\nvoid unionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat) {\n    if(d1 < d2) {\n        d = d1;\n        mat = mat_1;\n    } else {\n        d = d2;\n        mat = mat_2;\n    }\n}\n\nvoid intersectionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat) {\n    if(d1 > d2) {\n        d = d1;\n        mat = mat_1;\n    } else {\n        d = d2;\n        mat = mat_2;\n    }\n}\n\nvoid differenceSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat) {\n    if(-d1 > d2) {\n        d = -d1;\n        mat = mat_1;\n    } else {\n        d = d2;\n        mat = mat_2;\n    }\n}\n\nvoid smoothUnionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat, float k, float p) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    \n    d = mix(d2, d1, h) - k * h * (1.0 - h);\n    mat.ambient = mix(mat_2.ambient, mat_1.ambient, unitPow(h, p));\n    mat.diffuse = mix(mat_2.diffuse, mat_1.diffuse, unitPow(h, p));\n    mat.specular = mix(mat_2.specular, mat_1.specular, unitPow(h, p));\n    mat.shininess = mix(mat_2.shininess, mat_1.shininess, unitPow(h, p));\n}\n\nvoid smoothIntersectionSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat, float k, float p) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    \n    d = mix(d2, d1, h) + k * h * (1.0 - h);\n    mat.ambient = mix(mat_2.ambient, mat_1.ambient, unitPow(h, p));\n    mat.diffuse = mix(mat_2.diffuse, mat_1.diffuse, unitPow(h, p));\n    mat.specular = mix(mat_2.specular, mat_1.specular, unitPow(h, p));\n    mat.shininess = mix(mat_2.shininess, mat_1.shininess, unitPow(h, p));\n}\n\nvoid smoothDifferenceSDF(float d1, float d2, material mat_1, material mat_2, out float d, out material mat, float k, float p) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    \n    d = mix(d2, -d1, h) + k * h * (1.0 - h);\n    mat.ambient = mix(mat_2.ambient, mat_1.ambient, unitPow(h, p));\n    mat.diffuse = mix(mat_2.diffuse, mat_1.diffuse, unitPow(h, p));\n    mat.specular = mix(mat_2.specular, mat_1.specular, unitPow(h, p));\n    mat.shininess = mix(mat_2.shininess, mat_1.shininess, unitPow(h, p));\n}\n\n//---------------------------------------------------------------------------------\n\nvoid sceneSDF(vec3 pos, out float dist, out material obj_mat) {\n\tfloat dist_sphere = sphereSDF(pos, vec3(0, 0, 0), 1.0);\n    material mat_sphere = mat_red;\n    \n    float dist_cylinder = cylinderSDF(pos, vec3(0, 1, 0), 3.0, 0.7);\n    material mat_cylinder = mat_green;\n    \n    //unionSDF(dist_sphere, dist_cylinder, mat_sphere, mat_cylinder, dist, obj_mat);\n    //intersectionSDF(dist_sphere, dist_cylinder, mat_sphere, mat_cylinder, dist, obj_mat);\n    //differenceSDF(dist_sphere, dist_cylinder, mat_sphere, mat_cylinder, dist, obj_mat);\n    //differenceSDF(dist_cylinder, dist_sphere, mat_cylinder, mat_sphere, dist, obj_mat);\n    //smoothUnionSDF(dist_sphere, dist_cylinder, mat_sphere, mat_cylinder, dist, obj_mat, 0.20, 1.0);\n    //smoothIntersectionSDF(dist_sphere, dist_cylinder, mat_sphere, mat_cylinder, dist, obj_mat, 0.2, 1.0);\n    //smoothDifferenceSDF(dist_sphere, dist_cylinder, mat_sphere, mat_cylinder, dist, obj_mat, 0.2, 1.0);\n\tsmoothDifferenceSDF(dist_cylinder, dist_sphere, mat_cylinder, mat_sphere, dist, obj_mat, 0.2, 1.0);\n}\n\n//---------------------------------------------------------------------------------\n\nvec3 blinnPhong(vec3 pos, vec3 V, vec3 N, material mat, light lt) {\n    //Calculate L and H vectors\n    vec3 L = normalize(vec3(lt.position - pos));\n    vec3 H = normalize(L + V);\n\n    //Ambient\n    vec3 ambient = lt.ambient * mat.ambient;\n\n    //Diffuse\n    vec3 diffuse = lt.diffuse * mat.diffuse * max(dot(L, N), 0.0f);\n\n    //Specular\n    vec3 specular = lt.specular * mat.specular * pow(max(dot(H, N), 0.0f), mat.shininess);\n    \n    //Final color calculation\n    //vec3 color = diffuse + ambient + specular;\n    vec3 color = diffuse + ambient;\n    return color;\n}\n\n//---------------------------------------------------------------------------------\n\nvec3 estimateNormal(vec3 pos) {\n    material placeholder;\n    float nxr, nxl, nyr, nyl, nzr, nzl;\n    sceneSDF(vec3(pos.x + EPSILON, pos.y, pos.z), nxr, placeholder);\n    sceneSDF(vec3(pos.x - EPSILON, pos.y, pos.z), nxl, placeholder);\n    sceneSDF(vec3(pos.x, pos.y + EPSILON, pos.z), nyr, placeholder);\n    sceneSDF(vec3(pos.x, pos.y - EPSILON, pos.z), nyl, placeholder);\n    sceneSDF(vec3(pos.x, pos.y, pos.z + EPSILON), nzr, placeholder);\n    sceneSDF(vec3(pos.x, pos.y, pos.z - EPSILON), nzl, placeholder);\n   \n    return normalize(vec3(nxr - nxl, nyr - nyl, nzr - nzl));\n}\n\nvoid castRay(vec3 ray_origin, vec3 ray_direction, float dmin, float dmax, out float scene_dist, out material obj_mat) {    \n    scene_dist = dmin;\n    float step_dist;\n    for(int it = 0; it < MAX_RAYMARCHING_ITERATIONS; it++) {\n        vec3 ray_pos = ray_origin + (ray_direction * scene_dist);\n        sceneSDF(ray_pos, step_dist, obj_mat);\n        scene_dist += step_dist;\n        if(step_dist < EPSILON || scene_dist > dmax) { return; }\n    }\n   \n    scene_dist = dmax + 1.0;\n}\n\nvec3 calculateScreenRayDirection(vec2 fragCoord, vec2 size, float fov) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 calculateCameraMatrix(vec3 lookfrom, vec3 lookat, vec3 vup) {\n    vec3 cz = normalize(lookat - lookfrom);\n    vec3 cx = normalize(cross(cz, vup));\n    vec3 cy = cross(cx, cz);\n    return mat3(cx, cy, -cz);\n}\n\n\n//---------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //Precalculate variables\n    vec2 mouse_UV = iMouse.xy / iResolution.xy;\n    \n    //Camera calculations\n    vec3 cam_lookat = vec3(0, 0.5, 0);\n    vec3 cam_lookfrom = cam_lookat + vec3(10.0 * cos(1.2 * iTime),\n                                          1.5,\n                                          10.0 * sin(1.2 * iTime)\n                                         );\n    vec3 cam_vup = vec3(0, 1, 0);\n    mat3 cam_matrix = calculateCameraMatrix(cam_lookfrom, cam_lookat, cam_vup);\n    \n    //Apply raymarching\n    float scene_dist;\n    material obj_mat;\n    \n    vec3 ray_origin = cam_lookfrom;\n    vec3 ray_direction = cam_matrix * calculateScreenRayDirection(fragCoord, iResolution.xy, 45.0);\n    castRay(ray_origin, ray_direction, MIN_DIST, MAX_DIST, scene_dist, obj_mat);\n    \n    vec3 pos = ray_origin + (ray_direction * scene_dist);\n    vec3 norm = estimateNormal(pos);\n\n    vec3 col = vec3(0);\n    if(scene_dist < MAX_DIST) {\n        for(int l_index = 0; l_index < l_num; l_index++) {\n        \tcol += blinnPhong(pos, vec3(cam_lookfrom - pos), norm, obj_mat, scene_lights[l_index]);\n        }\n    } else {\n        col = background_color;\n    }\n    \n    //Gamma normalization\n    //col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}