{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// thanks to iq for some primitive distance functions\n\n// info: http://miss-cache.blogspot.com/2015/01/modelling-with-distance-functions-shape.html\n\n#define COLOR_PALETTE 2\n\n#if COLOR_PALETTE==1\nvec3 backgrColor = vec3(0.51, 0.85, 0.98);\nvec3 insideColor0 = vec3(0.4, 0.75, 0.34);\nvec3 insideColor1 = vec3(0.32, 0.94, 0.47);\nvec3 borderColor = vec3(0.0, 0.25, 0.06);\nvec3 glowColor = vec3(0.06, 0.12, 0.08);\nfloat glowStrength = 0.07;\n#elif COLOR_PALETTE==2\nvec3 backgrColor = vec3(0.85);\nvec3 insideColor0 = vec3(0.0);\nvec3 insideColor1 = vec3(0.73, 0.0, 0.0);\nvec3 borderColor = vec3(0.0);\nvec3 glowColor = vec3(0.36);\nfloat glowStrength = 0.85;\n#else\nvec3 backgrColor = vec3(0.0);\nvec3 insideColor0 = vec3(1.0);\nvec3 insideColor1 = vec3(1.0);\nvec3 borderColor = vec3(1.0);\nvec3 glowColor = vec3(0.43, 0.85, 1.0);\nfloat glowStrength = 0.99;\n#endif\n\n#define PI 3.14159265359\n\nfloat distBox(vec2 p, vec2 b)\n{\n\tvec2 di = abs(p) - b;\n    float mc = max(di.x, di.y);\n    return mc < 0.0 ? mc : length(max(di,0.0));\n}\n\nfloat distDisc(vec2 p, float radius) { return length(p) - radius; }\nfloat distCircle(vec2 p, float R, float r) { return abs(length(p) - R) - r; }\nfloat distCircleTaxi(vec2 p, float R, float r) { return abs(abs(p.x) + abs(p.y) - R) - r; }\nfloat distHex(vec2 p, float h) { p = abs(p); return max(p.x+p.y*0.57735,p.y)-h; }\nfloat distRouBox(vec2 p, vec2 b, float c) { return length( max( abs(p) - b + vec2(c, c), 0.0 ) ) - c; }\n\nvec2 rotate(vec2 p, float a) { return vec2(p.x*cos(a)+p.y*sin(a), p.y*cos(a)-p.x*sin(a)); }\n#define SQRT2_OVER2 0.70710678\n\nvec2 calcCoordsID(vec2 uv, int ID, float rotation)\n{\n    vec2 cellSize = vec2(PI / 16.0, PI / 20.0);\n    \n\tif(ID == 0)\n\t{\n\t\tuv = vec2(length(uv), atan(uv.y/uv.x) * 0.2);\n\t}\n\telse if(ID == 2)\n\t{\n\t\tuv = vec2(log(length(uv) + 0.001) * 2.0, atan(uv.y, uv.x)) * 0.2;\n\t}\n\telse if(ID == 3)\n\t{\n\t\tuv = vec2(uv.x*uv.y, 0.5*(uv.y*uv.y - uv.x*uv.x)) * 2.5; // Parabolic coordinates? But reversed (parabolic to carthesian)\n\t}\n\telse if(ID == 4)\n\t{\n\t\tuv = exp(uv.x)*vec2(cos(uv.y), sin(uv.y));\n\t}\n\telse if(ID == 5)\n\t{\n\t\tfloat ff = length(uv) * 3.5;\n\t\tuv =  2.5 * uv * atan(ff) / (ff + 0.01);\n\t}\n\telse if(ID == 6)\n\t{\n\t\tuv = vec2(log(length(uv) + 0.001), atan(uv.y/uv.x));\n        uv = rotate(uv, PI*0.25);\n        cellSize *= SQRT2_OVER2 * vec2(1.0, 1.0) * 2.0;\n        //uv.y += 1.0 * uv.x;\n\t}\n\telse if(ID == 7)\n\t{\n\t\tuv.x /= (1.0 + 2.0 * abs(uv.y));\n\t}\n\t    \n    vec2 uvIntMod2 = mod(floor((uv) / cellSize), 2.0);\n\tuv = mod(uv, cellSize);\n    if(abs(uvIntMod2.x) < 0.1 || abs(2.0-uvIntMod2.x) < 0.1) uv.x = cellSize.x - uv.x;\n    if(abs(uvIntMod2.y) < 0.1 || abs(2.0-uvIntMod2.y) < 0.1) uv.y = cellSize.y - uv.y;\n    \n    uv -= cellSize*0.5;\n\n\treturn uv;\n}\n\nvec2 deformCoords(vec2 uv)\n{\n    float t = mod(iTime, 20.0);\n    float t01 = 0.0;\n    if(t > 17.0) t01 = (t-17.0) / 3.0;\n    \n    int id0 = int(floor(mod(iTime/20.0, 8.0)));\n    int id1 = int(floor(mod(iTime/20.0 + 1.0, 8.0)));\n    \n\tvec2 uv1 = calcCoordsID(uv, id0, 0.0);\n\tvec2 uv2 = calcCoordsID(uv, id1, 0.0);\n\tuv = mix(uv1, uv2, t01);\n\n    return uv;\n}\n\nfloat signNoZero(float x)\n{\n\treturn x > 0.0 ? 1.0 : -1.0;\n}\n\nvec2 domainXFormID(vec2 p, int ID, float t)\n{\n\tif(ID == 0)\n\t\tp.x += p.y * t;\n\telse if(ID == 1)\n\t\tp.y += (0.045 - abs(p.x)) * t;\n\telse if(ID == 2)\n\t\tp.x -= signNoZero(p.x) * (0.05 - 0.5*abs(p.y)) * t;\n\telse if(ID == 3)\n\t\tp.y -= signNoZero(p.y) * 0.5*abs(p.x) * t;\n\telse if(ID == 4)\n\t\tp.x -= signNoZero(p.x) * 0.45 * length(p) * t;\n\telse if(ID == 5)\n\t\tp.y += 0.35 * length(p) * t;\n\telse if(ID == 6)\n\t\tp.x -= signNoZero(p.x) * 0.05 * t;\n\telse if(ID == 7)\n\t{\n\t\tp.x -= signNoZero(p.x) * 0.05 * t;\n\t\tp.y -= signNoZero(p.y) * 0.05 * t;\n\t}\n\telse if(ID == 8)\n\t\tp.x *= (1.0 + t * 80.0 * abs(p.y));\n\telse if(ID == 9)\n\t\tp.y += t * cos(p.x * 20.0 * PI) * 0.025;\n\t\n\treturn p;\n}\n\nvec2 deformPos(vec2 p)\n{\n    int id = int(floor(mod(iTime, 40.0)))/4;\n    float t02 = mod(iTime, 4.0) * 0.5;\n    float t010 = t02 > 1.0 ? 2.0 - t02 : t02;\n    t010 = smoothstep(0.0, 1.0, t010);\n    \n    return domainXFormID(p, id, t010);\n}\n\nfloat distShapeID(vec2 p, int ID, vec2 par)\n{\n\tfloat d = 0.0;\n\tif(ID == 0)\n\t\td = distCircle(p, par.x, par.y);\n\telse if(ID == 1)\n\t\td = distCircleTaxi(p, par.x, par.y);\n    else if(ID == 6)\n\t\td = distBox(p, par);\n\telse if(ID == 3)\n\t\td = distRouBox(p, vec2(par.x), par.y);\n\telse if(ID == 4)\n\t\td = distHex(p, par.x);\n\telse if(ID == 5)\n\t\td = distBox(p, vec2(30.0, par.x * 0.5));\n\telse if(ID == 2)\n\t\td = distBox(p, vec2(par.x * 0.5, 30.0));\n\telse if(ID == 7)\n\t\td = min(distBox(p, vec2(30.0, par.x * 0.5)), distBox(p, vec2(par.y * 0.5, 30.0)));\n\t\n\treturn d;\n}\n\nfloat distShapeCSG(vec2 p, int opID, int shapeID0, int shapeID1)\n{\n    vec2 param0 = vec2(4.0, 1.5);\n    vec2 param1 = vec2(4.0, 1.5);\n    if(opID == 2) param1 *= 1.2;\n    if(opID == 3) param1 *= 0.4;\n    \n\tfloat d = distShapeID(p, shapeID0, param0);\n\tfloat d2 = distShapeID(p, shapeID1, param1);\n\t\n\tif(opID == 1) \t   d = min(d,  d2);\n\telse if(opID == 2) d = max(d,  d2);\n\telse if(opID == 3) d = max(d, -d2);\n\n\treturn d;\n}\n\nfloat distShape(vec2 modpos)\n{\n\tmodpos *= 100.0;\n    float time = iTime * 0.45;\n\n    float t01 = smoothstep(0.0, 1.0, mod(time, 1.0));\n    \n    int id00 = int(floor(mod(time, 8.0)));\n    int id01 = int(floor(mod(time+5.0, 8.0)));\n    \n    int id10 = int(floor(mod(time+1.0, 8.0)));\n    int id11 = int(floor(mod(time+6.0, 8.0)));\n    \n    int op0Id = int(floor(mod(time, 4.0)));\n    int op1Id = int(floor(mod(time+1.0, 4.0)));\n    \n    float d1 = distShapeCSG(modpos, op0Id, id00, id01);\n\tfloat d2 = distShapeCSG(modpos, op1Id, id10, id11);\n\n    float d = mix(d1, d2, t01);    \n    \n    return d * 0.01;\n}\n\nvec2 rotateCoords(vec2 uv)\n{\n    float angle = 0.0;\n    float time = mod(iTime, 23.0);\n    if(time < 8.0)\n    {\n    \tangle = smoothstep(0.0, 1.0, time * 0.125) * PI ;   \n    }\n\tuv = rotate(uv, angle);\n    \n    return uv;\n}\n\nvec3 getColor(float d)\n{\n\tfloat borderOffset = 0.0033;\n\tfloat inSmooth = smoothstep(1.0, 0.0, -d < 0.01 ? 0.0 : (-d-0.01) * 200.0);\n\tvec3 inColor = inSmooth * insideColor0 + (1.0 - inSmooth) * insideColor1;\n\t\n\tfloat outSmooth = smoothstep(1.0, 0.0, d < borderOffset ? 0.0 : (d-borderOffset) * (170.0 - glowStrength * 130.0));\n\toutSmooth *= clamp(5.0 * glowStrength, 0.0, 1.0);\n\tvec3 outColor = outSmooth * glowColor + (1.0 - outSmooth) * backgrColor;\n\t\n\tvec3 color = vec3(0.0);\n\tfloat border = smoothstep(1.0, 0.0, abs(d) * 300.0);\n\tvec3 noBorderColor = d > 0.0 ? outColor : inColor;\n\tcolor = border * borderColor + (1.0 - border) * noBorderColor;\n\t\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time010 = mod(iTime, 2.0) * 1.0;\n    time010 = smoothstep(0.0, 1.0, time010 > 1.0 ? 2.0 - time010 : time010);\n    \n    vec2 uv = fragCoord.xy / iResolution.x;\n    uv = uv * 2.0 - vec2(1.0, iResolution.y/iResolution.x);\n    \n    uv = deformCoords(uv);\n    uv = rotateCoords(uv);\n\tuv = deformPos(uv);\n    \n    float d = distShape(uv);\n    \n    float color = d < 0.0 ? 1.0 : smoothstep(1.0, 0.0, d * 250.0);\n\tfragColor = vec4(color, color * 0.3, color * 0.1, 1.0);\n    fragColor = vec4(getColor(d), 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mtl3WH","date":"1421848025","viewed":3612,"name":"SHAPE","username":"mihu","description":"A prototype of an Android app I made a couple months ago.\nIt generates abstract shapes using implicit functions, but in 2D only, and uses some 2D coord. xforms to add some 3D flavour.","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","distancefunctions"],"hasliked":0,"parentid":"","parentname":""}}