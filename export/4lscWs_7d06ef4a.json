{"ver":"0.1","info":{"id":"4lscWs","date":"1517352209","viewed":234,"name":"FTL Stealth Cruiser C","username":"aw","description":"Stealth Cruiser C from FTL: Faster than Light.  I always felt like its camo would undulate and change, especially when activating stealth.  Shader runs better small, I wouldn't fullscreen it.  \n\nIt's a bit slow, but it was a fun experiment.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","postprocessing","ftl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\tFTL Stealth Cruiser C.  I always felt like this ship would have active camo, even when\n//\tfully visible, to make it hard to read against the background of space.\n//\n//\tOne day I'll learn how you wizards on Shadertoy handle particles and the like, so that\n//\tI can do things like contrails with raymarching.\n\n//\tWill add chromatic abberation.\nvec4 AddChromaticAbberation(sampler2D tex, vec2 uv, float strength)\n{\n    vec3 color;\n    color.r = texture(tex, vec2(uv.x + strength, uv.y)).r;\n    color.g = texture(tex, uv).g;\n    color.b = texture(tex, vec2(uv.x - strength, uv.y)).b;\n\n\tcolor *= (1.0 - strength * 0.5);\n\t\n    return vec4(color, 1.0);\n}\n\n\n//\tWill ddd a vignette.\nvec4 AddVignette(vec4 color, vec2 uv, float strength, float range)\n{\n    uv *=  1.0 - uv.yx;\n    float vignette = pow(uv.x * uv.y * strength, range);    \n    return vec4(color.rgb * vec3(vignette), 1.0);\n}\n\n\n//\tDraw to screen.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; \n    vec4 color = AddChromaticAbberation(iChannel0, uv, 0.0036);\n    color = AddVignette(color, uv, 60.0, 0.05);\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\tStarting point was Daedelus's raymarching tutorial, as a base for me to experiment with.\n//\tReally useful tutorial for someone who hasn't used shadertoy or raymarching before.\n//\tI've left his comments in where necessary, for future reference.\n//\thttps://www.shadertoy.com/view/XlBGDW.\n\n//\tConstants.\n#define NEAR_CLIPPING_PLANE 0.1\n#define FAR_CLIPPING_PLANE 100.0\n#define NUMBER_OF_MARCH_STEPS 150\n#define EPSILON 0.0180\n#define DISTANCE_BIAS 0.7\n\n//  Materials.\nconst float MAT_ONE = 1.0;\nconst float MAT_TWO = 2.0;\nconst float MAT_THREE = 3.0;\nconst float MAT_FOUR = 4.0;\nconst float MAT_FIVE = 5.0;\nconst float MAT_SIX = 6.0;\nconst float MAT_SEVEN = 7.0;\n\n\n// GLSL Number Printing - @P_Malin\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n\nfloat PRINTVALUE = 1.0;\n\nfloat DigitBin(const int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( const vec2 vStringCoords, const float fValue, const float fMaxDigits, const float fDecimalPlaces )\n{\n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n\n//  https://www.shadertoy.com/view/Xd23Dh\n//  More info here: https://iquilezles.org/articles/voronoise\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat iqnoise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\t\t\n\tfloat k = 1.0+63.0*pow(1.0-v,4.0);\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n\t\tfloat ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return va/wt;\n}\n\n\n//\tAll object functions are\n//\tfrom https://iquilezles.org/articles/distfunctions.\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat fmod(float a, float b)\n{\n    if(a < 0.0)\n    {\n        return b - mod(abs(a), b);\n    }\n    return mod(a, b);\n}\n\n//\thttps://www.shadertoy.com/view/MlGGDh.\nmat3 rotationMatrix(vec3 m,float a) {\n    m = normalize(m);\n    float c = cos(a),s=sin(a);\n    return mat3(c+(1.-c)*m.x*m.x,\n                (1.-c)*m.x*m.y-s*m.z,\n                (1.-c)*m.x*m.z+s*m.y,\n                (1.-c)*m.x*m.y+s*m.z,\n                c+(1.-c)*m.y*m.y,\n                (1.-c)*m.y*m.z-s*m.x,\n                (1.-c)*m.x*m.z-s*m.y,\n                (1.-c)*m.y*m.z+s*m.x,\n                c+(1.-c)*m.z*m.z);\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 smin( vec2 a, vec2 b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b.x-a.x)/k, 0.0, 1.0 );\n\treturn vec2( mix( b.x, a.x, h ) - k*h*(1.0-h), mix( b.y, a.y, h ) );\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n\nvec3 DrawShipSides(vec3 position, float distance, bool isLeft)\n{\n    //  Shape calculations.\n    float orientation = isLeft ? 1.0 : -1.0;\n    \n    vec3 translate = vec3(0.0, 0.0, 1.0);\n    vec2 res = vec2(1.0, 1.0);\n    float glow = 0.0;\n\tfloat materialID = MAT_ONE;\n\tvec3 pos = vec3(1.0);\n    \n    \n    //\tNose.\n    materialID = MAT_ONE;\n    translate = vec3(0.3, 0, .9);\n    pos = (position - translate);\n    \n    float nTip = udQuad(pos, vec3(0,0,-.12), vec3(.2,0,0), vec3(.2,.02 * orientation,0), vec3(0,.03 * orientation,-.12));    \n\tpos = (position - translate + vec3(.7,0,0));\n    float nCore = udQuad(pos, vec3(0,0,-.05), vec3(.7,0,0), vec3(.7,.03 * orientation,0), vec3(0,.005 * orientation,-.05));    \n    \n    pos = (position - translate + vec3(0, -0.05 * orientation, 0));\n    float nEdge = udQuad(pos, vec3(-.4,0,-.09), vec3(.2,-.005 * orientation ,0), vec3(.18,.02 * orientation,0), vec3(0,0.07 * orientation,0));\n    \n    materialID = MAT_FIVE;\n    distance = smin(distance, nTip, 0.0);\n    \n    if(distance > nCore) materialID = MAT_SIX;\n    distance = smin(distance, nCore, 0.0);\n    \n    if(distance > nEdge) materialID = MAT_ONE;\n    distance = smin(distance, nEdge, 0.0);\n    \n    \n    float trim = 0.0;\n    float tTwo = 0.0;\n    float tThree = 0.0;\n    float leftSide = 0.0;\n    \n    //\tEngines.\n\ttranslate = vec3(0.0, 0.0, 1.0);\n    pos = (position + vec3(0.7, 0.3 * orientation, 0.0) - translate) * rotationMatrix(vec3(0, 0, 1.0), 1.55 * orientation);\n    leftSide = udBox(pos, vec3(0.04, 0.4, 0.2));\n    \n    pos = (position + vec3(1.3, 0.3 * orientation, 0.0) - translate) * rotationMatrix(vec3(-0.35, 0.25 * orientation, 1), 1.55 * orientation);\n    trim = udBox(pos, vec3(0.1, 0.2, 0.4));\n    \n    pos = (position + vec3(1.0, 0.3 * orientation, 0.11) - translate) * rotationMatrix(vec3(-0.32, 0.3 * orientation, 1), 1.55 * orientation);    \n    tTwo = udBox(pos, vec3(0.015, 0.1, 0.1));\n    \n    pos = (position + vec3(0.5, 0.4 * orientation, 0.0) - translate) * rotationMatrix(vec3(-0.35, 0.25 * orientation, 1), 1.55 * orientation);    \n    tThree = udBox(pos, vec3(0.04, 0.4, 0.4));    \n    \n    if(distance > leftSide) materialID = MAT_TWO;\n    distance = smin(distance, leftSide, 0.0);\n    distance = smax(-trim, distance, 0.1);\n    distance = smax(-tTwo, distance, 0.07);\n    distance = smax(-tThree, distance, 0.1);\n        \n    \n    //\tWings.\n    translate = vec3(0.0, -0.5, 1.0);\n    pos = (position + vec3(1.3, 0.4 * orientation, 0) - translate);\n    \n    float wOne;\n    float wOneTip;\n    \n    if(isLeft)\n    {\n    \twOne = udQuad(pos, vec3(.6,0.37,.1), vec3(1.1,.8,0), vec3(.6,.8,0), vec3(.18,.35,.1));\n    \twOneTip = udQuad(pos, vec3(.25,.25,.15), vec3(.6,0.37,.1), vec3(.18,.35,.1), vec3(.00,.25,.15));\n    }\n    else\n    {\n\t\twOne = udQuad(pos, vec3(.62,0.62,.1), vec3(1.1,.2,0), vec3(.6,.2,0), vec3(.13,.69,.1));\n    \twOneTip = udQuad(pos, vec3(.25,.75,.15), vec3(.62,0.62,.1), vec3(.13,.7,.1), vec3(.00,.75,.15));\n    }    \n    \n    if(distance > wOne) materialID = MAT_THREE;\n    distance = smin(distance, wOne, 0.0);\n\tdistance = smin(distance, wOneTip, 0.0);\n    \n    \n    //\tFront winglets.\n    translate = vec3(0.0, 0.0, 1.1);\n    pos = (position - translate);\n    \n    float winglet = udQuad(pos, vec3(-.5,.01*orientation,-.22), vec3(.3,.01*orientation,-.2), vec3(.3,.06 * orientation,0), vec3(-.5,.27 * orientation,0));    \n    if(distance > winglet) materialID = MAT_THREE;\n    distance = smin(distance, winglet, 0.0);\n    \n    \n    //\tEngine Shields.\n    translate = vec3(-0.4, 0.0, .9);\n    pos = (position - translate);\n    \n    float eShield = udQuad(pos, vec3(-.4,.1 * orientation,-.26), vec3(.17,.1 * orientation,-.16), vec3(.11,.23 * orientation,0), vec3(-.5,.27 * orientation,-.1));    \n    if(distance > eShield) materialID = MAT_TWO;\n    distance = smin(distance, eShield, 0.0);\n    \n    \n    //\tEngines.\n    translate = vec3(-0.9, 0.0, .9);\n    pos = (position + vec3(0.05, 0.3 * orientation, 0.0) - translate) * rotationMatrix(vec3(0, 0, 1.0), 1.55 * orientation);\n    float engine = udBox(pos, vec3(0.01, 0.01, 0.01));\n    if(distance > engine) materialID = MAT_SEVEN;\n    distance = smin(distance, engine, 0.0);    \n    \n    \n    //\tIntake.\n    translate = vec3(-0.4, 0.0, .9);\n    pos = (position - translate);\n    \n    float intake = udQuad(pos, vec3(-.4,0,-.12), vec3(-.06,0,-.12), vec3(.16,.14 * orientation,0), vec3(-.5,.14 * orientation,-.1));    \n    if(distance > intake) materialID = MAT_THREE;\n    distance = smin(distance, intake, 0.0);\n    \n    \n    //\tRear.\n    if(isLeft)\n    {\n    \ttranslate = vec3(-0.7, 0.0, .9);\n   \t\tpos = (position - translate);\n    \n    \tfloat rBase = udBox(pos, vec3(.35, 0.15, 0.1));\n        translate = vec3(-0.85, 0.0, .9);\n   \t\tpos = (position - translate);\n        \n    \tfloat rCenter = udBox(pos, vec3(.3, 0.075, 0.1));\n        if(distance > rBase) materialID = MAT_FOUR;\n        if(distance > rCenter) materialID = MAT_FOUR;\n    \tdistance = smin(distance, rBase, 0.0);    \n    \tdistance = smin(distance, rCenter, 0.0);    \n    }\n        \n    return vec3(distance, materialID, 1.0);\n}\n\n\nvec3 scene(vec3 position)\n{\n    //\tFuselage.\n\tfloat materialID = 1.0;\n\tvec3 pos = vec3(1.0);        \n    float distance = FAR_CLIPPING_PLANE;\n    \n    vec3 leftShip = DrawShipSides(position, distance, false);\n    distance = leftShip.x;\n    materialID = leftShip.y;\n    \n    float oldDistance = distance;\n    vec3 rightShip = DrawShipSides(position, distance, true);\n    distance = rightShip.x;\n    if(oldDistance > distance + 0.01) materialID = rightShip.y;\n    \n    //\tWe return a vec2 packing the distance and material of the closes object together\n    return vec3(distance, materialID, 1.0);\n}\n\n\nvec3 raymarch(vec3 position, vec3 direction)\n{\n\t//\tThis function iteratively analyses the scene to approximate the closest ray-hit\n    //\tWe track how far we have moved so we can reconstruct the end-point later\n    float total_distance = NEAR_CLIPPING_PLANE;\n    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)\n    {\n        vec3 result = scene(position + direction * total_distance);\n        //\tIf our ray is very close to a surface we assume we hit it\n        //\tand return it's material\n        if(result.x < EPSILON)\n        {\n            return vec3(total_distance, result.y, result.z);\n        }\n        \n        // Accumulate distance traveled\n        // The result.x contains closest distance to the world\n        // so we can be sure that if we move it that far we will not accidentally\n        // end up inside an object. Due to imprecision we do increase the distance\n        // by slightly less... it avoids normal errors especially.\n        total_distance += result.x * DISTANCE_BIAS;\n        \n        // Stop if we are headed for infinity\n        if(total_distance > FAR_CLIPPING_PLANE)\n            break;\n    }\n    // By default we return no material and the furthest possible distance\n    // We only reach this point if we didn't get close to a surface during the loop above\n    return vec3(FAR_CLIPPING_PLANE, 0.0, 0.0);\n}\n\n\n//\tCalculate the normals.\nvec3 normal(vec3 ray_hit_position, float smoothness)\n{\t\n    //\tFrom https://www.shadertoy.com/view/MdSGDW\n\tvec3 n;\n\tvec2 dn = vec2(smoothness, 0.0);\n\tn.x\t= scene(ray_hit_position + dn.xyy).x - scene(ray_hit_position - dn.xyy).x;\n\tn.y\t= scene(ray_hit_position + dn.yxy).x - scene(ray_hit_position - dn.yxy).x;\n\tn.z\t= scene(ray_hit_position + dn.yyx).x - scene(ray_hit_position - dn.yyx).x;\n\treturn normalize(n);\n}\n\n\n//\tDraw to buffer.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 originalUV = fragCoord.xy / iResolution.xy;\n    \n    // Given the pixel X, Y coordinate and the resolution we can get 0-1 UV space\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    // Our rays should shoot left and right, so we move the 0-1 space and make it -1 to 1\n    uv = uv * 2.0 - 1.0;\n    // Last we deal with an aspect ratio in the window, to make sure our results are square\n    // we must correct the X coordinate by the stretching of the resolution\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 direction = normalize(vec3(uv, 3.5));\n    \n    // if you rotate the direction with a rotation matrix you can turn the camera to!\n    float cameraZoom = sin(iTime * 0.2) * 1.5;\n    float cameraSpeed = sin(iTime * 0.4);\n    vec3 camera_origin = vec3(0.1 - cameraSpeed, 0.0, -4.5 - cameraZoom); // you can move the camera here\n    \n    \n    vec3 result = raymarch(camera_origin, direction); // this raymarches the scene\n    \n    // arbitrary fog to hide artifacts near the far plane\n    // 1.0 / distance results in a nice fog that starts white\n    // but if distance is 0 \n    float fog = pow(1.0 / (1.0 + result.x), 0.45) + 0.1;\n    \n    //\tBackground fog.\n    if(result.y == 0.0)\n    {\n\t\tfog = 1.0;   \n    }\n    \n    //\tBackground.\n    vec3 backgroundColor = vec3(0, .063, .098);\n    \n    //\tNow let's pick a color\n    vec3 materialColor = vec3(0.0, 0.0, 0.0);\n    if(result.y == MAT_ONE)\n    {\n        materialColor = vec3(1.0, 0.753, 0.505);\n    }\n    if(result.y == MAT_TWO)\n    {\n       \tmaterialColor = vec3(0.863, 0.498, 0.106);\n    }\n    if(result.y == MAT_THREE)\n    {\n       \tmaterialColor = vec3(1.0, 0.667, 0.329);\n    }\n    if(result.y == MAT_FOUR)\n    {\n       \tmaterialColor = vec3(1.0, 0.667, 0.329);\n    }\n    if(result.y == MAT_FIVE)\n    {\n       \tmaterialColor = vec3(1.0, 0.3, 0.0);\n    }\n    if(result.y == MAT_SIX)\n    {\n       \tmaterialColor = vec3(1.1, 0.5, 0.0);\n    }\n    if(result.y == MAT_SEVEN)\n    {\n       \tmaterialColor = vec3(1.2, 0.7, 0.0);\n    }\n    \n    //\tBackground.\n    if(result.y == 0.0)\n    {\n        materialColor = backgroundColor;\n        \n        //  Background done using IQ's Voronoise.\n    \tvec2 starUV = vec2(uv.x + iTime * 0.3, uv.y);\n    \tvec2 p = 2.5 * sin(2.6 * vec2(1.01, 1.71));\n\t\n\t\tfloat f = iqnoise(60.0 * starUV, p.x, p.y);\n    \tf = clamp(f, 0.0, 0.9);\n        \n        //\tSample iChannel0 for some color.\n        vec3 starColor = texture(iChannel0, starUV * vec2(0.01)).xyz;\n    \n        materialColor += vec3(f * 0.25) + starColor * 0.05;\n        \n        //\tNow add some nebulas.\n        vec2 nebulaUV = vec2(uv.x + iTime * 0.3, uv.y);\n    \tp = 2.5 * sin(.3 * vec2(1.01, 1.71));\n\t\n\t\tf = iqnoise(5.0 * nebulaUV, p.x, p.y);\n        \n        //\tSample iChannel0 for some color.\n        vec3 nebColor = texture(iChannel0, nebulaUV * vec2(0.01)).xyz;\n        \n\t\tfloat mask = iqnoise(.6 * nebulaUV, p.x, p.y);\n    \tmask = clamp(mask, 0.0, 0.9);\n        f -= mask * 1.4;\n    \tf = clamp(f, 0.0, 0.9);\n    \n        materialColor += vec3(f * 0.25) * nebColor;\n    }\n    \n    //  Camo done using IQ's Voronoise.\n    vec2 camoUV = vec2(uv.x + iTime * 0.01, uv.y);\n    vec2 p = 2.5 * sin(iTime * vec2(1.01, 1.71));\n\t\n\tfloat f = iqnoise(45.0 * camoUV, p.x, p.y);\n    f = clamp(f, 0.25, 0.5);\n    \n    if(result.y > 0.0)\n    {\n        //\tNow at certain times, add the 'stealth effect' of the Stealth cruiser.\n        float stealthStrength = sin(iTime * 0.5) * 1.05;\n        stealthStrength = clamp(stealthStrength, 0.0, 100.0);\n        \n        materialColor += vec3(f * 0.45 - stealthStrength);\n        \n        //  Also, desaturate the colors too.  To do this, we pull the colors closer together.\n        vec3 greyscale = vec3(0.3, 0.59, 0.11);\n        float result = dot(materialColor, greyscale);\n        result = clamp(result, -0.075, 1.0);\n        materialColor *= result;\n    }   \n    PRINTVALUE = sin(iTime * 0.5) * 50.0 + 50.0; \n    \n    //\tWe can reconstruct the intersection point using the distance and original ray\n    vec3 intersection = camera_origin + direction * result.x;\n    \n    //\tThe normals can be retrieved in a fast way\n    //\tby taking samples close to the end-result sample\n    //\ttheir resulting distances to the world are used to see how the surface curves in 3D\n    //\tThis math I always steal from somewhere ;)\n    vec3 nrml = normal(intersection, 0.01);\n    \n    //\tLambert lighting is the dot product of a directional light and the normal\n    vec3 light_dir = normalize(vec3(0.0, 1.0, 0.0));\n   \tfloat diffuse = dot(light_dir, nrml);\n    \n    //\tWrap the lighting around\n    //\thttps://developer.valvesoftware.com/wiki/Half_Lambert\n    diffuse = diffuse * 0.5 + 0.5;\n\n    vec3 light_color = vec3(1.4, 1.2, 0.7);\n    vec3 ambient_color = vec3(0.2, 0.45, 0.6);\n    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);\n    \n    //\tNow add some nebulas infront of the ship.\n    vec2 nebulaUV = vec2(uv.x + iTime * 0.1, uv.y);\n    p = 2.5 * sin(.3 * vec2(1.01, 1.71));\n\n    f = iqnoise(5.0 * nebulaUV, p.x, p.y);\n\n    float mask = iqnoise(.4 * nebulaUV, p.x, p.y);\n    mask = clamp(mask, 0.0, 0.9);\n    f -= mask * 1.1;\n    f = clamp(f, 0.0, 0.6);\n\n    diffuseLit += vec3(f * 0.25);\n    \n    //  Print Shader Time for Stealth Values.\n    //  https://www.shadertoy.com/view/4sBSWW\n\tvec2 vPixelCoord1 = vec2(0.1, -20.1) * uv;\n\tfloat fIsDigit1 = PrintValue( (fragCoord - vPixelCoord1) / 10.0, PRINTVALUE, 5.0, 1.1);\n    diffuseLit = mix( diffuseLit, vec3(0.0, 1.0, 0.0), fIsDigit1);\n\n\tfragColor = vec4(diffuseLit, 1.0) * fog; /* applying the fog last */\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//\tWill pixelate the image by only sampling every nth pixel.\nvec2 GetPixelUV(vec2 fragCoord, vec2 resolution, float scale)\n{\n    int pixelSize = int(resolution.x / scale);\n    \n    int remainderX =  int(fragCoord.x) % pixelSize;\n    float pixelTargetX = fragCoord.x - float(remainderX);  \n    \n    int remainderY =  int(fragCoord.y) % pixelSize;\n    float pixelTargetY = fragCoord.y - float(remainderY);\n    \n    return vec2(pixelTargetX / resolution.x, pixelTargetY / resolution.y);\n}\n\n\n//\tWill reduce the precision of the color by the given value.\nvec3 BityFyColor(vec3 color, int quality)\n{\n    int bitDepth = 255 % quality;\n    \n    vec3 colorSampler = color * vec3(255);\n    vec3 remainder = vec3(int(colorSampler.r) % int(quality), int(colorSampler.g) % int(quality), int(colorSampler.b) % int(quality));\n        \n    return vec3((colorSampler - remainder) / vec3(255));\n}\n\n\n//\tWill add a sepia tone color grading.\nvec4 AddSepia(vec4 color, float strength)\n{\n    vec4 sepia;\n\tsepia.r = dot(color.rgb, vec3(0.393, 0.769, 0.189));\n\tsepia.g = dot(color.rgb, vec3(0.349, 0.686, 0.168));   \n\tsepia.b = dot(color.rgb, vec3(0.272, 0.534, 0.131));\n    sepia.a = 1.0;\n    \n    return mix(color, sepia, strength);\n}\n\n\n//\tWill add a vignette.\nvec4 AddVignette(vec4 color, vec2 uv, float strength, float range)\n{\n    uv *=  1.0 - uv.yx;\n    float vignette = pow(uv.x * uv.y * strength, range);    \n    return vec4(color.rgb * vec3(vignette), 1.0);\n}\n\n\n//\tWill generate a border.\nvec4 GenerateBorder(vec4 color, vec2 fragCoord, vec2 resolution, float size)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    if(uv.x < size || uv.x > 1.0 - size || uv.y < size || uv.y > 1.0 - size)\n    {\n        color = vec4(0, 0, 0, 1);\n    }\n    \n    return color;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;    \n    vec2 targetUV = GetPixelUV(fragCoord, iResolution.xy, 300.0);\n    \n\tvec4 color = texture(iChannel0, targetUV);\n    color = GenerateBorder(color, fragCoord, iResolution.xy, 0.01);\n    color = AddVignette(color, uv, 120.0, 0.1);\n    color = vec4(BityFyColor(color.rgb, 4), 1.0);\n    fragColor = color;\n}","name":"Buf B","description":"","type":"buffer"}]}