{"ver":"0.1","info":{"id":"4f33Rs","date":"1712181097","viewed":17,"name":"Entrega 1","username":"MaralGS","description":"Es un shader","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["alexgarciaselma"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Raytracing exercise 9\nvec3 Spheres[3];\nfloat SphereRadius = 0.5;\nfloat GroundY = -0.5;\n\n//Noise\nfloat hash(float n) {return fract(sin(n) * 1e4);}\n    \nfloat hash(vec2 p) {return fract(1e4 * sin(17.0 * p.x + p.y *0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\n\n//2D Random\nfloat random (in vec2 st){\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n                 }\n\n//Colors\nvec3 Blue = vec3(0.6, 0.67, 0.9);\nvec3 White = vec3(1.0,1.0,1.0);\nvec3 Grey = vec3(0.7, 0.7, 0.7);\nvec3 FogColor = vec3(0.85, 0.9, 1.0);\nvec3 Green = vec3(1,0,1);\nvec3 fresnel = vec3(0.);\n\n//lights \nvec3 light = vec3(1.,1.,1.);\nfloat TAU = 6.2832;\n\n//Camera\nvec3 cameraOrigin;\n\n//Hit struct\nstruct Hit\n{\n    vec3 normals;\n    vec3 point;\n    int objectId;\n};\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//Return true if a hit was detected with any sphere\nbool HitsSphere(in vec3 origin, in vec3 direction, inout Hit _hit, int ballId, inout float zDist )\n{\n    bool ret = false;\n\n    //Ball Vars\n    vec3 C = Spheres[ballId];\n    vec3 Oc = C - origin;\n    float r = SphereRadius;\n    \n    //Ball Formula\n    float proj = dot(Oc, normalize(direction));\n    vec3 K = origin + normalize(direction) * proj;\n    float L1 = length(C-K);\n    float L2 = sqrt(r*r - L1 * L1);\n    float tSphere = proj - L2;\n    vec3 P = origin + normalize(direction) * tSphere;\n    vec3 normals = normalize(P - C);\n    \n    float HitDepth = length(Oc + normals);\n    \n    //Print Ball\n    if(L1 < r  &&  tSphere >= 0. && (zDist >= HitDepth || zDist < 0.0))\n    {\n        _hit.normals = normals;\n        _hit.point = P;\n        _hit.objectId = ballId;\n\n        zDist = HitDepth;\n        ret = true;\n    }\n    \n    return ret;\n}\n\nbool HitsPlane(in vec3 origin, in vec3 direction, inout float tPlane, inout Hit _hit)\n{\n    bool ret = false;\n    \n    //Plane formula\n    float Py = GroundY;\n    \n    tPlane = (Py - origin.y)/(direction.y);\n    _hit.point = origin + (direction * tPlane);\n    \n    if(tPlane > 0.01)\n    {\n        _hit.objectId = -1;\n        _hit.normals = vec3(0., 1.0, 0.);\n        ret = true;\n    }\n    \n    return ret;\n}\n\nbool HitsAnySphere(vec3 origin, vec3 direction, inout Hit _hit, inout float zDepth, in int ignoreId)\n{\n    bool ret = false;\n    for(int i = 0; i < Spheres.length(); i++)\n    {\n        if(ignoreId != i && HitsSphere(origin, direction, _hit, i, zDepth))\n        {\n            ret = true;\n        }\n    }\n    return ret;\n}\n\nbool HitsAnything(in vec3 origin, in vec3 direction, inout Hit hit, in int ignoreId)\n{\n    bool ret = false;\n    float tempDepth = -1.0f;\n    float tPlane = -1.0;\n   \n    if(HitsPlane(origin, direction, tPlane, hit))\n    {\n        ret = true;\n    }\n    \n    if(HitsAnySphere(origin, direction, hit, tempDepth, ignoreId))\n    {\n        ret = true;\n    }\n       \n    return ret;\n}\n\nvec3 Fresnel(in vec3 direction, in vec3 normal)\n{\n   vec3 F0 = vec3(0.2f);\n   float cosTheta = dot(normal, -direction);\n   return F0 + (1.0-F0)*pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 CreateSkybox(in vec2 uv)\n{\n    vec3 finalColor;\n \n    float numDivisions = 1.0f;\n    \n    uv.x = uv.x + (iTime*2.0f);\n    \n    vec2 tile = floor(uv * vec2(numDivisions));\n    vec2 frac = fract(uv * vec2(numDivisions));\n    \n    float noise = hash(tile);\n    \n    float c00 = hash(tile);\n    float c10 = hash(tile + vec2(1.0,0.0));\n    float c01 = hash(tile + vec2(0.0,1.0));\n    float c11 = hash(tile + vec2(1.0,1.0));\n    \n    float m0010 = mix(c00, c10, frac.x);\n    float m0111 = mix(c01, c11, frac.x);\n    float finalColor2 = mix(m0010,m0111,frac.y);\n    \n    vec3 finalSkyColor = mix(White, Blue, finalColor2);\n    \n    finalColor = vec3(finalSkyColor);\n    \n    return finalColor;\n}\n\nvec3 CreateFloor(Hit planeHit)\n{\n    vec3 finalColor;   \n    \n    float numRows = 0.5;\n\n    // Time varying pixel color\n    vec2 uv2 = floor(planeHit.point.xz * numRows);   \n    vec3 finalColorY = vec3(mod(uv2.y,2.0));  \n    vec3 finalColorX = vec3(mod(uv2.x + finalColorY,2.0));\n    finalColor = mix(White, vec3(0.f),finalColorX);\n    \n    return finalColor; \n}\n\nvec3 DirectPassColor(vec3 rayDirection)\n{\n    \n    vec3 finalColor = mix(vec3(0.95), Blue, rayDirection.y);\n\n    // Fog parameters\n    float fogStartDistance = 10.0; // Start Distance\n    float fogEndDistance = 40.0; // End Distance\n    vec3 fogColor = FogColor; \n  \n    float tPlane = 0.0;\n    Hit planeHit;\n    \n    if(HitsPlane(cameraOrigin, rayDirection, tPlane, planeHit))\n    {\n    float fogFactor = clamp((distance(planeHit.point,cameraOrigin) - fogStartDistance) / (fogEndDistance - fogStartDistance), 0.0, 1.0);\n    finalColor = CreateFloor(planeHit);\n    finalColor = mix(finalColor, FogColor, fogFactor);\n    }\n    else\n    {\n    float fogFactor = clamp((distance(planeHit.point,cameraOrigin) - fogStartDistance) / (fogEndDistance - fogStartDistance), 0.0, 1.0);\n    finalColor = CreateSkybox(planeHit.point.xz);\n    finalColor = mix(finalColor, FogColor, fogFactor);\n    }\n    //Plane shadows\n    Hit hit;\n    float zDepth = -1.0f;\n    float tempdist = zDepth;\n    if(HitsAnySphere(planeHit.point, light, hit, zDepth, -1))\n    {\n        finalColor = vec3(0.0f);\n    }\n\n    //Sphere color\n    zDepth = -1.0f;\n    if(HitsAnySphere(cameraOrigin, rayDirection, hit, zDepth, -1))\n    {\n        if(tempdist >= zDepth || tempdist < 0.0 )\n        {\n            tempdist = zDepth;\n            // Assigning colors based on objectId\n            if (hit.objectId == 0)\n                finalColor = vec3(dot(hit.normals, light) * texture(iChannel0,hit.point.xz)); // Blue color\n            else if (hit.objectId == 1)\n                finalColor = vec3(dot(hit.normals, light) * vec3(1, 0, 0)); // Red color\n            else if (hit.objectId == 2)\n                finalColor = vec3(dot(hit.normals, light)); // Green color\n\n            // Shadow projected between spheres\n            for(int j = 0; j < 3; j++)\n            {\n                if(HitsAnySphere(hit.point + hit.normals * 0.01, light, hit, zDepth, j))\n                {\n                    finalColor = vec3(0.0f);\n                }\n            }\n        }\n    }\n    return finalColor;\n}\n\n\n\nvec3 ReflectionPassColor(vec3 rayDirection, inout vec3 aaFresnel)\n{\n    vec3 reflectionDirection = vec3(1., 1. , 1.);\n    reflectionDirection = normalize(reflectionDirection);  \n    vec3 reflectionColor = vec3(0.);\n    Hit hit;\n    \n    rayDirection = normalize(rayDirection);\n    \n    if(HitsAnything(cameraOrigin, rayDirection, hit, -1))\n    {\n            \n        reflectionColor = vec3(dot(hit.normals, light));\n        vec3 hitColor = reflectionColor;\n           \n        //Fresnel\n        if(hit.objectId == 2)\n        {\n        aaFresnel = vec3(1.0f);\n        }\n        else\n        {\n        aaFresnel = Fresnel(rayDirection, hit.normals);\n        }\n        \n        //Reflections\n        vec3 reflections = reflect(rayDirection,  hit.normals);\n        hitColor = mix(vec3(0.9f),Blue, reflections.y);\n        \n        vec3 Sky = CreateSkybox(reflections.xz);\n        hitColor *= Sky;\n        \n        if(HitsAnything(hit.point, reflections, hit, -1))\n        {\n            if(hit.objectId == -1)\n            {\n            hitColor = CreateFloor(hit);\n            }\n            else\n            {\n                if (hit.objectId == 0)\n                    hitColor = max(vec3(dot(hit.normals, light) * reflectionColor), texture(iChannel0,hit.point.xz).rgb); //reflect red\n                else if (hit.objectId == 1)\n                    hitColor = max(vec3(dot(hit.normals, light) * reflectionColor), vec3(0.8, 0, 0));\n                else \n                hitColor = max(vec3(dot(hit.normals, light) * reflectionColor), vec3(0.0f));\n            }\n        }\n        reflectionColor = hitColor;\n   }\n   else\n   { \n   \n   }\n    // Apply fog\n    float fogStartDistance = 10.0; \n    float fogEndDistance = 40.0; \n    vec3 fogColor = FogColor; \n\n    float fogFactor = clamp((distance(hit.point,cameraOrigin) - fogStartDistance) / (fogEndDistance - fogStartDistance), 0.0, 1.0);\n    reflectionColor = mix(reflectionColor, fogColor, fogFactor);\n    return reflectionColor;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //Ball Positions + Shading\n    Spheres[0] = vec3(.0f + sin(iTime) * 1.5f, 0.5 + sin(iTime)*0.5f, .0 + cos(iTime) * 1.5f);\n    Spheres[1] = vec3(.0f - sin(iTime) * 1.5f, 0.5 + sin(iTime)*0.5f, .0f - cos(iTime) * 1.5f);\n    Spheres[2] = vec3(0.f, 1.f, 0.f);\n\n    //Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - vec2(1.0,1.0);\n    uv.x *= iResolution.x / iResolution.y;  \n    \n    //Camera Matrix\n    vec3 nearCoord = vec3(2.0 * (fragCoord / iResolution.xy) - 1.0, 0.0);\n    nearCoord.x *= iResolution.x/iResolution.y;\n    \n    float xAxisIncrement = 1.0-iMouse.y/iResolution.y;\n    float yAxisIncrement = TAU*iMouse.x/iResolution.x;\n    \n    cameraOrigin = 3.0 * vec3(cos(xAxisIncrement)*cos(yAxisIncrement),\n                                   sin(xAxisIncrement),\n                                   cos(xAxisIncrement)*sin(yAxisIncrement));\n                                   \n    vec3 tgt = vec3(0.0, 1.0, 0.0);\n    vec3 zz = normalize(cameraOrigin - tgt);\n    vec3 xx = normalize(cross(vec3(0.0,1.0,0.0),zz));\n    vec3 yy = cross(zz,xx);\n    \n    //Plane Vars\n    vec3 rayDirection = normalize(xx*nearCoord.x + yy*nearCoord.y - zz* (iResolution.x / iResolution.y));\n    \n    //rayDirection = normalize(rayDirection);\n    light = normalize(light);\n    \n    float dx = dFdx(rayDirection.x);\n    float dy = dFdy(rayDirection.y);\n    \n    vec4 finalAAColor = vec4(0.0);\n    for(int x = -1; x < 2; ++x)\n    {\n        for(int y = -1; y < 2; ++y)\n        {\n            vec3 aaPixelColor;\n            vec3 aaDirection = normalize(vec3(rayDirection.x + dx * float(x),\n                                              rayDirection.y + dy * float(y),\n                                              rayDirection.z));\n            \n            vec3 aaFresnel = vec3(0.0); \n            vec3 directPass = DirectPassColor(aaDirection);\n            vec3 reflectionPass = ReflectionPassColor(aaDirection,aaFresnel);\n            finalAAColor += vec4(mix(directPass, reflectionPass, aaFresnel),1.0);\n        }\n    }\n    \n    finalAAColor /= 9.0;\n    \n   \n    \n    // Output to screen\n    fragColor = finalAAColor;\n}","name":"Image","description":"","type":"image"}]}