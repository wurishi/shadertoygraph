{"ver":"0.1","info":{"id":"WtVfWd","date":"1615299802","viewed":43,"name":"S2 GFX","username":"flowb","description":"company mondokoro rendered using sdfs. probably could use a bunch of optimizations\n\n-todo:\nimplement animation showing construction steps","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","wip"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926589793238462\n\nvec2 rotate(vec2 st, float a){\n\tst = mat2( cos(a),-sin(a),\n\t\t\t   sin(a), cos(a))\n\t\t\t   *(st-.5);\n\treturn st+.5;\n}\n\nvec2 scale(vec2 st, float _scale){\n\treturn (( st - vec2(.5) ) * (1./_scale)) + vec2(.5) ;\n}\n\nfloat _c(float _in){ \n    return clamp(_in, 0.,1.); //this is the only kind of clamping i'm doing here...\n}\n    \n\nfloat fill( float x, float size ){\n\t//return step(x,size);\n    //return 1.-step(size,x);\n    \n    float w = .001;\n    vec2 sW = vec2(size-w,size+w);\n    return 1.-smoothstep(sW.s,sW.t,x);\n   \n}\n\n//from iq\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n\tp -= vec2(.5,.5);\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n\nfloat circleSDF(vec2 st){\n\treturn length(st-.5)*2.;\n}\n\nfloat rectSDF(vec2 st, vec2 s){\n\tst = st * 2.0 - 1.0;\n\treturn max( abs(st.x/s.x), abs(st.y/s.y) );\n}\n\nfloat fCirc( vec2 pos, float size){\n\treturn fill( circleSDF(pos), size);\n}\n\nfloat fElps( vec2 pos, vec2 scale, float size){\n\treturn fill( sdEllipse(pos,scale), size);\t\n}\n\nfloat fRect( vec2 pos, vec2 scale, float size){\n\treturn fill( rectSDF(pos, scale), size);\t\n}\n\nfloat ginkgoHalfLeaf(vec2 st){\n\tfloat leafBase = \n\t_c(\n\t\t\t_c(\n\t\t\t\tfCirc(st+vec2(0.,-.1666),.5)\n\t\t\t\t-fRect(st+vec2(0.,.333),vec2(1.),1.)\n\t\t\t)\n\t\t+fRect(st+vec2(0.,0.1),vec2(.2,.6),1.)\n\t\t)\n\t\t-fRect(st+vec2(-.5,0),vec2(1.),1.);\n\t\t\n\tfloat leafCut = _c( fElps(rotate(st+vec2(.18,-0.105),PI*.05),vec2(.125,.03),.0503) );\n\tfloat stemCut = _c( fElps(rotate(st+vec2(.08,-0.105),PI*.5),vec2(.5,.024),.0501) - fRect(st+vec2(0.,-.623),vec2(1.),1.) );\n\tfloat leafTip = _c( fRect( rotate(st+vec2(.247,-.179),PI*.25) ,vec2(1.),.05) - fCirc(st+vec2(.222,-.2042),.05) );\n\tfloat stemTip = _c( fRect( rotate(st+vec2(.05,0.38),PI*-.45) ,vec2(1.),.1) - fElps(rotate(st+vec2(.0,0.35),PI*-.45),vec2(.05,.0125),.005) );\n\n\treturn _c( leafBase-leafCut-stemCut - leafTip - stemTip);\n    ;\n}\n\nfloat ginkgoLeaf( vec2 st ){\n\treturn ginkgoHalfLeaf(vec2(1.-st.s,st.t)) + ginkgoHalfLeaf(st);\n}\n\nfloat s2Ginkgo( vec2 st ){\n\treturn ginkgoLeaf(st)+ginkgoLeaf(rotate(st,PI*-.666))+ginkgoLeaf(rotate(st,PI*.666));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 iRez = iResolution.st;\n\t\n    vec2 st = fragCoord.st/iRez.tt;\n    st.s += (1.- (iRez.s/iRez.t))/2.;\n\n\t//st = rotate(st, iTime);\n\n\tfloat frameCirc = fCirc(st, 1.) - fCirc(st,.87);\n\t\n\tvec4 color = vec4(frameCirc + s2Ginkgo(scale( st, .9)));\n\tfragColor = color; \n}","name":"Image","description":"","type":"image"}]}