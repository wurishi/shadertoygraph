{"ver":"0.1","info":{"id":"XlKXWW","date":"1484367889","viewed":146,"name":"360 rotating scanlines","username":"zproxy","description":"360 rotating scanlines","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["360"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define xWebGLTexture360height iResolution.y \n#define xWebGLTexture360height iResolution.y\n\n\n#define uIPD 0.0\n    \nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1. - c;\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\n\n\n\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n \n  \nfloat stars(in vec3 p)\n{\n   \n    //vec3 q = fract(p*22.)-0.5;\n    //vec3 q = fract(p*2.)-0.5;\n    vec3 q = fract(p*3.)-0.5;\n   \n    \n\n    \n    return 1.-smoothstep(0.,.5,length(q));\n}\n\nvec3 startrails(in vec3 rd)\n{\n    //rd *= rotationMatrix(vec3(1.0, 0.0, 0.0), 90.);\n    \n    rd *= rotationMatrix(vec3(0.0, 1.0, 0.0), ((-0. -  iMouse.x) / 360.) * 3.14);\n    //rd *= rotationMatrix(vec3(0.0, 0.0, 1.0), 90.);\n    rd *= rotationMatrix(vec3(0.0, 0.0, 1.0), ((90. + cos(iTime) * 1. -  iMouse.y) / 360.) * 3.14);\n    \n\n    //        if (rd.z < 0.)\n    //    if (rd.y < 0.)\n    //if (rd.x < 0.)\n    //return vec3(1.0, 0,0);\n    \n    float col0 = stars( normalize(rotx(rd, iTime * 0.01)));\n\n    float col = col0;\n\n    for (int i = -180; i < -30; i++)\n    {\n    \tfloat col1 = stars( normalize(rotx(rd, iTime * 0.01 + (float(i) * (1./20.) ))));\n        \n    \tcol += col1;    \n    }\n    \n    \n    if (col < 0.)\n        col = 0.;\n    if (col > 1.)\n        col = 1.;\n    \n    return vec3(1.0 - col);\n}\n\n\n void mainImage0( out vec4 fragColor, in vec2 fragCoord, vec2 thetaphi, vec3 rd, float IPD )\n {\n  \n    vec3 col = startrails( rd);\n\n  \n\n    //float tOver = clamp(iTimeDelta-(1./60.),0.,1.);\n    \n    \n    //col = (col + past.rgb) * 0.995;\n    //col = (col + past.gbr) * 0.995;\n    \n    \n\tfragColor = vec4(col, 1.0);\n }\n\n \n\n// called by drawArrays\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord )\n{\n    bool drag = iMouse.w > 0.0;\n    \n    float grid = 16.;\n    float gridt = 2.;\n    \n    bool indexx = int(int(fragCoord.x  / grid) * int(grid)) == int(fragCoord.x);\n    bool indexy = int(int(fragCoord.y  / grid) * int(grid)) == int(fragCoord.y);\n    //bool indext = int(int(float(iFrame)  / grid) * int(grid)) == int(iFrame);\n    bool indext = int(int(float(iTime)  / gridt) * int(gridt)) == int(iTime);\n    \n    if (drag || (indext&&(indexy||indexx)))\n\n\n    {\n   if ( int(fragCoord.x + 2.) > int(iMouse.x))\n   if ( int(fragCoord.x - 2.) < int(iMouse.x))\n    {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n      if ( int(fragCoord.y + 2.) > int(iMouse.y))\n   if ( int(fragCoord.y - 2.) < int(iMouse.y))\n    {\n        fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n        return;\n    }\n    }\n    \n\t// can we show the noise we just was sent too?\n\n\t//if (gl_FragCoord.x < float(noiseSize))\n\t//\tif (gl_FragCoord.y < float(noiseSize))\n\t//\t{\n\t//\n\t//\t\t// if its a black bar. then we did not upload it?\n\t//\t\tgl_FragColor = texture(iChannel0, gl_FragCoord.xy / vec2(iResolution));\n\t//\t\treturn;\n\t//\t}\n\n\n\n//discard;\n\n\t// void mainImage0( out vec4 fragColor, in vec2 fragCoord, vec2 thetaphi, vec3 rd, float IPD  ) \n\t// \n\t\n\t// P:\\vr\\x360horizonclouds\n\n\t//float IPD = 0.005;\n\t//float IPD = 0.05;\n\t// frame565 cant see stereo diff?\n\t//float IPD = 5.0; \n\n\t// perhaps because IPD is not used in the underlying main?\n\t//float IPD = 50.0; \n\n\t//float IPD = 1.0; \n\t//float IPD = 0.5; //too much \n\t//float IPD = 0.05; // rocks feel bit too close.\n\t//float IPD = 0.02; // too much. thing too close.\n\t//float IPD = 0.002; // too much. thing too close.\n\t//float IPD = 0.2; // too much?\n\t//float IPD = 0.02; // too much.\n\t//float IPD = 0.01; // too much.\n\t//float IPD = 0.2; // too much\n\t//float IPD = 0.05; // could be a slider. feels ok. can we up it a bit?\n\t//float IPD = 0.1; // yellow thing bit too close? \n\t//float IPD = 0.075; // \n\t//float IPD = 0.066; // too much \n\t// float IPD = 0.01; // \n\n\t//float IPD = 0.002; // too much.\n\n\n\n\t\n\tbool RvL = true;\n\t \n\tvec4 fragColorR = vec4(1.0, 0.0, 0.0, 1.0);\n\tvec2 fragCoordR = vec2(gl_FragCoord.x, gl_FragCoord.y / 1.0);\n\tvec2 texCoordR0 = vec2((iResolution.x - fragCoordR.x)/iResolution.x, fragCoordR.y/(iResolution.y/1.0))  + vec2(0.25, 0.0);\n\tvec2 thetaphiR = ((texCoordR0 * vec2(2.0, 2.0)) - vec2(1.0)) * vec2(3.1415926535897932384626433832795, 1.5707963267948966192313216916398); \n\tvec3 rayDirectionR = vec3(cos(thetaphiR.y) * cos(thetaphiR.x ), sin(thetaphiR.y), cos(thetaphiR.y) * sin(thetaphiR.x ));\n\n\n\n    \n\tmainImage0(\n\tfragColorR, \n\t fragCoordR, \n\tthetaphiR , \n\t rayDirectionR, \n\t uIPD  \n\t\n\t);\n\t\n\t// lets not shadow the non stereo area.\n\t//fragColorLvR.rgb *= \n\t//\t1.0 - abs(RvL ? thetaphiR.y : thetaphiL.y) * 0.6;\n\t\n\tfragColor = fragColorR;\n}\n\n\n","name":"Image","description":"","type":"image"}]}