{"ver":"0.1","info":{"id":"7lySW3","date":"1641618939","viewed":117,"name":"Ray marching test- Phong shading","username":"LucasR","description":"I followed this tutorial: https://inspirnathan.com/posts/52-shadertoy-tutorial-part-6\nto make my first ray marching based scene. Shadows are somewhat custom","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","phongshading","softshadows","3drendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005; // used in calcNormal()\nconst float MIN_SHADOW = .4;\n\nmat3 rotX(float theta){ // Rotation matrix around the X axis\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotY(float theta){ // Rotation matrix around the Y axis\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotZ(float theta){ // Rotation matrix around the Z axis\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nmat3 identity(){ // Identity matrix\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nstruct Material{\n    float k_a; // ambient\n    float k_d; // diffuse\n    float k_s; // specular\n    float alpha; // shininess -- related to roughness\n};\n\nstruct Surface{\n    float sd; // signed distance\n    vec3 col; // colour\n    Material mat; // Phong shading constants\n};\n\nSurface sdSphere(vec3 p, float r, vec3 offset, vec3 col, Material mat){\n    return Surface(length(p - offset) - r, col, mat);\n}\n\nSurface sdFloor(vec3 p, vec3 col, Material mat){\n    return Surface(p.y + 1., col, mat);\n}\n\nSurface sdBox(vec3 p, vec3 b, vec3 offset, vec3 col, mat3 transform, Material mat){\n    p = (p - offset) * transform;\n    vec3 q = abs(p) - b;\n    float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    return Surface(d, col, mat);\n}\n\nSurface minWithCol(Surface s1, Surface s2){\n    if(s2.sd < s1.sd) return s2;\n    return s1;\n}\n\nSurface sdScene(vec3 p){\n    Material sphLMat  = Material(.05, .6, .2, 2.);\n    Material sphRMat  = Material(.05, 1., .6, 100.);\n    Material boxMat   = Material(.05, 1., .6, 5.);\n    Material floorMat = Material(.05, 1., .0, 10.);\n    \n    Surface sphereLeft = sdSphere(p, 1., vec3(-2.5, 0., -2.), vec3(0., .8, .8), sphLMat);\n    Surface sphereRight = sdSphere(p, 1., vec3(2.5, 0., -2.), vec3(1., 0.58, 0.29), sphRMat);\n    Surface co = minWithCol(sphereLeft, sphereRight); // closest object\n    Surface box = sdBox(p, vec3(1), vec3(0, 0.5, -4), vec3(1, 0, 0), rotY(iTime), boxMat);\n    \n    co = minWithCol(co, box);\n    vec3 floorCol = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.));\n    return minWithCol(co, sdFloor(p, floorCol, floorMat));\n}\n\nvec3 calcNormal(vec3 p){\n  vec2 e = vec2(1.0, -1.0) * EPSILON;\n  return normalize(\n    e.xyy * sdScene(p + e.xyy).sd +\n    e.yyx * sdScene(p + e.yyx).sd +\n    e.yxy * sdScene(p + e.yxy).sd +\n    e.xxx * sdScene(p + e.xxx).sd);\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end){\n    float depth = start;\n    Surface co; // closest object\n    \n    for(int i = 0; i < MAX_MARCHING_STEPS; i++){\n        vec3 p = ro + depth*rd;\n        co = sdScene(p);\n        depth += co.sd;\n        if(co.sd < PRECISION || depth > end) break;\n    }\n    co.sd = depth;\n    return co;\n}\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, Surface co){\n    // ambient light is calculated outside this function\n    // diffuse\n    float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n    vec3 diffuse = co.mat.k_d * dotLN * co.col / (co.sd * co.sd); // added falloff\n\n    // specular\n    float dotRV = clamp(dot(reflect(lightDir, normal), rd), 0., 1.);\n    vec3 i_s = vec3(1.); // reflection colour\n    vec3 specular = co.mat.k_s * pow(dotRV, co.mat.alpha) * i_s / (co.sd * co.sd); // added falloff\n    \n    return diffuse + specular;\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt){ // source: https://www.shadertoy.com/view/ltyXD3\n  float res = 1.0;\n  float t = mint;\n\n  for(int i = 0; i < 16; i++) {\n    float h = sdScene(ro + rd * t).sd;\n      res = min(res, 8.0*h/t);\n      t += clamp(h, 0.02, 0.10);\n      if(h < 0.001 || t > maxt) break;\n  }\n\n  return clamp( res, 0.0, 1.0 );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0., 0., 3.); // ray origin -- camera position\n    vec3 rd = normalize(vec3(uv, -1.)); // ray direction\n    \n    vec2 mouse = (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n    //rd *= rotX(-mouse.y) * rotY(mouse.x);// uncomment this line to be able to rotate the camera with the mouse\n    \n    Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n    \n    vec3 bgCol = vec3(.835, 1., 1.); // i_a in Phong shading\n    \n    vec3 col = vec3(0.);\n    \n    if(co.sd > MAX_DIST){\n        col = bgCol;\n    }\n    else{\n        vec3 p = ro + rd*co.sd; // point on surface\n        vec3 normal = calcNormal(p);\n        \n        vec3 lightPos1 = vec3(2., 2., 4.);\n        vec3 lightDir1 = normalize(lightPos1 - p);\n        //vec3 lightPos2 = vec3(-2., 4., -20.);\n        vec3 lightPos2 = vec3(-2., 4., -10. + 20.*sin(2.2*iTime));\n        vec3 lightDir2 = normalize(lightPos2 - p);\n        \n        float lightStr1 = 20.; // strength of lights\n        float lightStr2 = 10.;\n        \n        // ambient\n        vec3 i_a = bgCol;\n        vec3 ambient = co.mat.k_a * i_a;\n        \n        //col = ambient + lightStr1 * phong(lightDir1, normal, rd, co);\n        //col += lightStr2 * phong(lightDir2, normal, rd, co);\n        \n        vec3 colLight1 = phong(lightDir1, normal, rd, co);\n        vec3 colLight2 = phong(lightDir2, normal, rd, co);\n        \n        /*\n        // hard shadows\n        // light 1\n        vec3 shadowRO = p + normal * PRECISION * 2.; // ray origin\n        float shadowRayLength = rayMarch(shadowRO, lightDir1, MIN_DIST, MAX_DIST).sd;\n        //if(shadowRayLength < length(lightPos1 - shadowRO)) col *= 0.2; // from tutorial\n        float shadowMask = clamp(1. - (length(lightPos1 - shadowRO) - shadowRayLength), MIN_SHADOW, 1.); // own\n        \n        // light 2\n        shadowRayLength = rayMarch(shadowRO, lightDir2, MIN_DIST, MAX_DIST).sd;\n        shadowMask *= clamp(1. - (length(lightPos2 - shadowRO) - shadowRayLength), MIN_SHADOW, 1.);\n        \n        col *= shadowMask;*/\n        \n        \n        // soft shadows\n        float shadowMask1 = clamp(softShadow(p, lightDir1, 0.02, 2.5), MIN_SHADOW, 1.0);\n        float shadowMask2 = clamp(softShadow(p, lightDir2, 0.02, 2.5), MIN_SHADOW, 1.0);\n        col = ambient;\n        col += colLight1 * lightStr1 * shadowMask1;\n        col += colLight2 * lightStr2 * shadowMask2;\n        col = pow(col, vec3(.4545)); // gamma correction\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}