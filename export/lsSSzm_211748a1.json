{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Really messy, silly hacked and slimy\n\n// The ray\nstruct Ray {\n    vec3 p;\n    vec3 d;\n};\n\n// A Light\nstruct Light {\n\tvec3 p;\n    vec4 df;\n    vec4 sp;\n};\n    \n// A Sphere\nstruct Sphere {\n\tvec3 c;\n    float r;\n    int i;\n};\n    \n// Constants\nconst float EPSILON = 2.0;\nconst int MAX_ITERATIONS = 50;\n\n// Colors\nconst vec4 WHITE = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 BLACK = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 COLOR1 = vec4(0.65, 0.65, 0.55, 1.0);\n\nvec4 lightColor0 = vec4(normalize(vec3(1.0,0.95,0.9)), 1.0);\nvec4 lightColor1;\n\n// Lights\nconst int numLights = 2;\nLight lights[2];\n\n// Spheres\nconst int numSpheres = 4;\nSphere spheres[numSpheres];\n\n// taken from Neil Mendosa's awesome website http://www.neilmendoza.com/\n// to be honest: i was too lazy to write that on my own...\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n// taken from IQ's awesome website https://iquilezles.org/\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// Sphere distance function\nfloat sphere (vec3 point, Sphere sphere) {\n    //if (point.z > sphere.c.z) { return 99999.9; }\n\treturn abs(distance(point, sphere.c) - sphere.r);\n}\n\n// Define some displacement\nvec3 getDisplacement (vec3 p, vec3 n, float o) {\n\tfloat f = -1.2 - 1.1*sin(0.6*iTime + o)*sin(5.0*n.x + 0.9*iTime + o) * sin(5.0*n.y + 0.85*iTime + o) * sin(5.0*n.z + iTime + o);\n\tfloat g = 0.4 + 0.3*sin(0.2*iTime + o)*sin(30.0*n.x + 0.9*iTime + o) * sin(30.0*n.y + 0.85*iTime + o) * sin(20.0*n.z + iTime + o);\n    return vec3(p.x + (g+f) * n.x, \n                p.y + (g+f) * n.y, \n                p.z + (g+f) * n.z);\n}\n\nfloat displacedSphere (vec3 point, Sphere s) {\n    vec3 p = getDisplacement(point, normalize(point - s.c), float(s.i));    \n\tfloat d1 = sphere(p, s);\n    return d1;\n}\n\nvoid setupLights () {\n    lights[0] = Light(vec3(-200,0,0), lightColor0, lightColor0);\n    lights[1] = Light(vec3(200,0,0), lightColor1, lightColor1);\n}\n\nvoid animateLights () {\n\tfloat a = cos(0.1*iTime);\n    float b = sin(0.1*iTime);\n    lights[0].p.x = a * 100.0;\n    lights[0].p.z = b * 100.0;\n    lights[1].p.x = -a * 100.0;\n    lights[1].p.z = -b * 100.0;\n}\n\n// Define some spheres\nvoid setupSpheres () {\n    for (int i=0; i<numSpheres; ++i) {        \n    \tspheres[i] = Sphere(vec3(0.0, 0.0, 100.0), 10.0, i);\n    }\n}\n\n// Animate the spheres\nvoid animateSpheres () {\n    for (int i=0; i<numSpheres; ++i) {\n        float f = 0.5 + 0.5*float(i+1) / float(numSpheres);\n    \tspheres[i].c.x += f * cos(float(i) + 0.5*float(i+1)*iTime + spheres[i].c.x) * 12.0;\n        spheres[i].c.z += f * sin(float(i) + 0.7*float(i+1)*iTime + spheres[i].c.z) * 12.0;\n        spheres[i].c.y += f * sin(float(i) + 0.6*float(i+1)*iTime + spheres[i].c.y) * cos(float(i) * 0.06*iTime + spheres[i].c.y) * 12.0;;\n    }\n}\n\n\n\n// Scene distance function\nfloat getDistance (vec3 point) {    \n    float minDistance = displacedSphere(point, spheres[0]);\n    for (int i=1; i<numSpheres; ++i) {\n    \tminDistance = smin(minDistance, displacedSphere(point, spheres[i]), 0.4);\n    }\n    \n\treturn minDistance; \n}\n\n\nfloat dx (vec3 point) {\n\treturn getDistance(vec3(point.x + 0.5 * EPSILON, point.yz))\n        - getDistance(vec3(point.x - 0.5 * EPSILON, point.yz));\n}\n\nfloat dy (vec3 point) {\n\treturn getDistance(vec3(point.x, point.y + 0.5 * EPSILON, point.z))\n        - getDistance(vec3(point.x, point.y - 0.5 * EPSILON, point.z));\n}\n\nfloat dz (vec3 point) {\n\treturn getDistance(vec3(point.xy, point.z + 0.5 * EPSILON))\n        - getDistance(vec3(point.xy, point.z - 0.5 * EPSILON));\n}\n\nvec3 getNormal (vec3 point) {\n\treturn normalize(vec3(dx(point), dy(point), dz(point)));\n}\n\nvec3 transform (mat4 m, vec3 p) {\n    p.y += 2.0;\n    p.z -= 105.0;\n    p = (m * vec4(p, 1.0)).xyz;\n    p.z += 105.0;\n    p.y -= 2.0;\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lightColor1 = vec4(normalize(vec3(1.0) - lightColor0.rgb), 1.0);\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspectRatio = iResolution.y / iResolution.x;\n    \n    // Setup a camera\n    float depth = 1.0;\n    vec3 pos = vec3(uv - vec2(0.5), 0.0);\n    pos.y *= aspectRatio;\n    vec3 dir = normalize(pos - vec3(0,0,-depth));\n    Ray ray = Ray(pos, dir);\n    \n    float alpha = 3.14*(-(iMouse.x / iResolution.x));\n    float beta = 3.14*((-iMouse.y / iResolution.y));\n    mat4 t = mat4(1.0, 0.0, 0.0, 0.0, \n                  0.0, 1.0, 0.0, 0.0,\n                  0.0, 0.0, 1.0, 100.0,\n                  0.0, 0.0, 0.0, 1.0);\n    mat4 t_inv = mat4(1.0, 0.0, 0.0, 0.0, \n                  \t  0.0, 1.0, 0.0, 0.0,\n                      0.0, 0.0, 1.0, -100.0,\n                      0.0, 0.0, 0.0, 1.0);\n    mat4 rotx = rotationMatrix(vec3(0.0, 1.0, 0.0), alpha);\n    mat4 roty = rotationMatrix(vec3(0.0, 0.0, 1.0), beta);\n    \n    mat4 m = roty * rotx;\n    //ray.p = (m * vec4(ray.p, 1.0)).xyz;\n    //ray.d = (m * vec4(ray.d, 0.0)).xyz;\n\n    //ray.p = (m * vec4(ray.p, 1.0)).xyz;\n    //ray.d = (m * vec4(ray.d, 0.0)).xyz;\n\n    \n    setupLights();\n    \n    // Setup geometry\n    setupSpheres();\n    \n\n    \n    // Animate spheres\n    animateSpheres();\n    \n    //animateLights();\n    \n    float a = clamp(dot(normalize(lights[0].p), vec3(0.0, 0.0, -1.0)), 0.2 , 1.0); \n    float b = clamp(dot(normalize(lights[1].p), vec3(0.0, 0.0, -1.0)), 0.2 , 1.0); \n    \n    // Rendering loop\n    float currentDistance;\n\tvec4 resultColor = vec4(a * lights[0].df.rgb + b * lights[1].df.rgb, 1.0);\n    resultColor.rgb *= 0.1;\n    \n    float numHits = 0.0;\n    float normalFlip = 1.0;\n    bool blockHit = false;\n\n    for (int i=0; i < MAX_ITERATIONS; ++i) {\n        vec3 point = transform(m, ray.p);\n        \n        \n        currentDistance = getDistance(point);\n        \n        if (currentDistance < EPSILON ) {\n            resultColor = BLACK;\n            numHits += 1.0;\n            \n        \tvec3 normal = getNormal(point);\n        \tfor (int i=0; i<numLights; ++i) {       \n                vec3 lightp = transform(m, lights[i].p);\n                vec3 lightDir = normalize(lightp - point);\n                float diffuse = dot(normal, lightDir);\n                vec3 reflectedLightDir = reflect(lightDir, normal);\n                float specular = clamp(dot(reflectedLightDir, ray.d), 0.0, 1.0);                \n                specular = pow(specular, 800.1);            \n                resultColor += vec4(vec3(0.1*diffuse * lights[1-i].df + diffuse * lights[i].df + 0.5*specular * lights[i].sp), 1.0);\n                \n            }\n            break;\n        } \n        ray.p += 0.5 * currentDistance * ray.d;\n    }\n    \n    resultColor.rgb /= float(numLights);\n    \n\tfragColor = vec4(resultColor);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsSSzm","date":"1410227569","viewed":212,"name":"Schleimbold","username":"jonaskoehler","description":"slimy slimy slimy - you can move around it per drag & drop","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""}}