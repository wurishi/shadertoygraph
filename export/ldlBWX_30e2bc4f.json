{"ver":"0.1","info":{"id":"ldlBWX","date":"1498587115","viewed":363,"name":"Volume_0","username":"kenhu","description":"Volumetric test","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// SDFs\n// https://iquilezles.org/articles/distfunctions\n    float sdSphere( vec3 p, float s )\n    {\n        return length(p) - s;\n    }\n\n\tfloat sdBox( vec3 p, vec3 b )\n    {\n      vec3 d = abs(p) - b;\n      return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    }\n\n    float sdPlane( vec3 p, vec4 n )\n    {\n      // n must be normalized\n      return dot(p,n.xyz) + n.w;\n    }\n\n    float sdTorus( vec3 p, vec2 t )\n    {\n        vec2 q = vec2(length(p.xz)-t.x,p.y);\n        return length(q)-t.y;\n    }\n\n    float sdCone( vec3 p, vec3 c )\n    {\n        vec2 q = vec2( length(p.xz), p.y );\n        float d1 = -q.y-c.z;\n        float d2 = max( dot(q,c.xy), q.y);\n        return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n    }\n\n// Noise\n    float hash (float n)\n    {\n        return fract(sin(n)*43758.5453);\n    }\n\n    float noise (in vec3 x)\n    {\n        vec3 p = floor(x);\n        vec3 f = fract(x);\n\n        f = f*f*(3.0-2.0*f);\n\n        float n = p.x + p.y*57.0 + 113.0*p.z;\n\n        float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                            mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                        mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                            mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n        return res;\n    }\n\n// Environment\n    vec3 LightPosition()\n    {\n        return vec3(0.0,20.0,0);\n    }\n\n    vec3 LightDirection()\n    {\n        return normalize(vec3(-0.05,-1,0));\n    }\n\n\t// https://www.shadertoy.com/view/MsS3Wc\n    // Smooth HSV to RGB conversion \n    vec3 hsv2rgb_smooth( in vec3 c )\n    {\n        vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n        rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n        return c.z * mix( vec3(1.0), rgb, c.y);\n    }\n\n\tvec3 LightColor()\n    {\n     \treturn hsv2rgb_smooth(vec3(fract(iTime * 0.05), 0.5, 0.5)) * 0.03;\n    }\n\n// Scene\n    float Scene(vec3 pos)\n    {\n        float outerSize = 20.0;\n        \n        float outer = sdBox(pos - vec3(0,0,0), vec3(outerSize*10.0,0.5,outerSize*10.0));\n        float lower = sdBox(pos - vec3(0,-40.0,0), vec3(outerSize*10.0,0.1,outerSize*10.0));\n        \n        float theta = iTime * 1.0;\n        mat3 fast_rot = mat3(\n            cos(theta),0,sin(theta),\n            0,1,0,\n            -sin(theta),0,cos(theta));\n        vec3 fast_rot_pos = fast_rot * pos;\n        \n        theta = iTime * 0.1;\n        mat3 slow_rot = mat3(\n            cos(theta),0,sin(theta),\n            0,1,0,\n            -sin(theta),0,cos(theta));\n        vec3 slow_rot_pos = slow_rot * pos;\n        \n        float offset = 8.0;\n        float size = 4.0;\n        \n        float box0 = sdBox(slow_rot_pos - vec3(0.0, 0.0, -offset), vec3(size, 1.0, size));\n        float box1 = sdBox(slow_rot_pos - vec3(0.0, 0.0, offset),  vec3(size, 1.0, size));\n        float box2 = sdBox(slow_rot_pos - vec3(offset, 0.0, 0.0),  vec3(size, 1.0, size));\n        float box3 = sdBox(slow_rot_pos - vec3(-offset, 0.0, 0.0), vec3(size, 1.0, size));\n        \n        float boxes = min(min(box0,box1), min(box2, box3));\n        \n        float depth = min(lower, max(-boxes, outer));\n        \n        size = 2.0;\n        offset = 16.0;\n        \n        box0 = sdBox(fast_rot_pos - vec3(0.0, -20.0, -offset), vec3(size, 1.0, size));\n        box1 = sdBox(fast_rot_pos - vec3(0.0, -20.0, offset),  vec3(size, 1.0, size));\n        box2 = sdBox(fast_rot_pos - vec3(offset, -20.0, 0.0),  vec3(size, 1.0, size));\n        box3 = sdBox(fast_rot_pos - vec3(-offset, -20.0, 0.0), vec3(size, 1.0, size));\n        \n        boxes = min(min(box0,box1), min(box2, box3));\n        \n        depth = min(depth, boxes);\n\n        return depth;\n    }\n\n\tfloat Density( in vec3 pos )\n    {\n        float y = (0.0 - pos.y + 15.0) / 40.0;\n        return y;\n    }\n\n    // from https://www.shadertoy.com/view/Xds3zN\n    vec3 CalcNormal( in vec3 pos )\n    {\n        vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n        return normalize( e.xyy * Scene( pos + e.xyy ) +\n                          e.yyx * Scene( pos + e.yyx ) +\n                          e.yxy * Scene( pos + e.yxy ) +\n                          e.xxx * Scene( pos + e.xxx ) );\n    }\n\n    vec3 RayDirection()\n    {\n        float fieldOfView = 90.0;\n        vec2 xy = gl_FragCoord.xy - iResolution.xy / 2.0;\n        float z =  iResolution.y / tan(radians(fieldOfView) / 2.0);\n        vec3 dir = normalize(vec3(xy, z)); // let z goes forward\n        \n        float pitch = 0.0;\n        \n        dir += vec3(0.0,pitch,0);\n        \n        return normalize(dir);\n    }\n\n\tvec3 Origin()\n    {\n    \tfloat backwards = -70.0;\n        \n        return vec3(0, -25, backwards);\n    }\n\n    float CastRay(vec3 origin, vec3 dir, float near, float far)\n    {\n        float EPSILON = 0.01;\n        const int STEP_COUNT = 64;\n\n        float depth = near;\n        for (int i = 0; i < STEP_COUNT; i++)\n        {\n            float dist = Scene(origin + depth * dir);\n            if (dist <= EPSILON)\n            {\n                // hit\n                return depth;\n            }\n            depth += dist; // go to next possible hit\n            if (depth >= far)\n            {\n                // hit far bound\n                return far;\n            }\n        }\n    }\n\n// Volume\n    vec3 marchThroughVolume(vec3 origin, vec3 dir, float near, float far)\n    {\n        vec2 xy = gl_FragCoord.xy - iResolution.xy / 2.0;\n                \n        origin -= 1.0 * dir * (noise(vec3(2.0 * xy, 0.0)));\n        \n        const float STEP_COUNT = 64.0;\n        float stepSize = (far - near) / STEP_COUNT;\n\n        vec3 accumulation = vec3(0.0);    \n\n        float depth = near;\n        for (float i = 0.0; i < STEP_COUNT; i++)\n        {\n            vec3 pos = origin + depth * dir;\n            vec3 diff = LightPosition() - pos;\n            vec3 dir = normalize(diff);\n            vec3 lightDir = LightDirection();\n            float near = 0.0;\n            float far = length(diff);\n            float distance = CastRay(pos, dir, near, far);\n            if (distance == far)\n            {\n                accumulation += Density(pos);\n            }\n\n            depth += stepSize;\n        }\n\n        return accumulation * stepSize * LightColor();\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float near = 40.0;\n    float far = 100.0;\n    vec3 origin = Origin();\n    vec3 dir = RayDirection();\n    float depth = CastRay(origin, dir, near, far);\n    \n    fragColor = vec4(marchThroughVolume(origin, dir, near, depth), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}