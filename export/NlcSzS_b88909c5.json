{"ver":"0.1","info":{"id":"NlcSzS","date":"1639290375","viewed":138,"name":"Interactive Newton's Fractal","username":"dahart","description":"Grab the roots & move them!\nInspired by https://www.3blue1brown.com/lessons/newtons-fractal","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["fractal","numbers","complex","newton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Antialiasing level\nconst int AA = 2;\nvec2 dAA = 1. / vec2(AA,AA);\nfloat NAA = 1. / float(AA * AA);\n\n// our polynomial function\nvec2 f(vec2 z, vec2 r[NUM_ROOTS]) {\n    vec2 d = vec2(1,0);\n    for (int i = 0; i < NUM_ROOTS; i++) {\n        d = Cmul(d, z - r[i]);\n    }\n    return d;\n}\n\n// polynomial derivative\nvec2 fp(vec2 z, vec2 r[NUM_ROOTS]) {\n    // 4 roots example: [(z-a)(z-b)(z-c)(z-d)]'\n    // = (z-b)(z-c)(z-d) + (z-a)(z-c)(z-d) + (z-a)(z-b)(z-c) + (z-a)(z-b)(z-d)\n\n    vec2 d = vec2(0, 0);\n    for (int i = 0; i < NUM_ROOTS; i++) {\n        vec2 e = vec2(1, 0);\n        for (int j = 0; j < NUM_ROOTS; j++) {\n            if (i != j) e = Cmul(e, z - r[j]); // could be optimized\n        }\n        d += e;\n    }\n    return d;\n}\n\n// take one step newton iteration\nvec2 newton(vec2 z, vec2 r[NUM_ROOTS]) {\n    // z = z - f(x) / f'(z)\n    return z - Cdiv(f(z, r), fp(z, r));\n}\n\n// Newton's fractal: iterate w/ Newton's method a few times\n// Then color the result according to which root we're closest to\nvec3 newtFract(vec2 z, vec2 r[NUM_ROOTS]) {\n    const int ITERS = 16;\n    for (int i = 0; i < ITERS; i++) {\n        z = newton(z, r);\n    }\n\n    int mini = -1;\n    float minv = 1e37;\n    for (int i = 0; i < NUM_ROOTS; i++) {\n        float d = distance(z, r[i]);\n        if (d < minv) {\n            minv = d;\n            mini = i;\n        }\n    }\n    \n    switch(mini) {\n        case 0: return vec3(1,.5,0);\n        case 1: return vec3(.5,1,0);\n        case 2: return vec3(0,.5,1);\n        case 3: return vec3(1,.5,1);\n        case 4: return vec3(1,1,.5);\n        case 5: return vec3(.5,1,1);\n        case 6: return vec3(1,1,1);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    fragColor = vec4(0.);\n  \n    float margin = .5 * (iResolution.x - iResolution.y);\n    float yRcp = 1. / iResolution.y;\n    vec2 uv = (fragCoord.xy - vec2(margin,0)) / iResolution.y;\n    float dx = fwidth(length(uv)) * .75;\n\n    // load draggable UI points;\n    vec2 p[UI_MAX_POINTS];\n    for (int i = 0; i < UI_MAX_POINTS; i++) {\n        p[i] = UI_GET_POINT(iChannel0, i);\n    }\n    \n    // render our fractal with supersampling\n    for (int aax = 0; aax < AA; aax++) {\n    for (int aay = 0; aay < AA; aay++) {\n        vec2 z = uv + vec2(aax, aay) * dAA * yRcp;\n        fragColor += vec4(newtFract(z, p), 1);\n    }\n    }\n    \n    fragColor = fragColor * NAA * .9;\n    \n    // display the draggable points\n    for (int i = 0; i < UI_MAX_POINTS; i++) {\n\t\tfloat w = 0.002;\n    \tfloat d = abs(sdCircle(uv.xy, p[i].xy, UI_POINT_SIZE));\n        float u = float(i) / float(UI_MAX_POINTS);\n    \tif (d < w+dx+dx) fragColor += vec4(.5+u/2., 1.-u/2., 1, 1) * smoothstep(w+dx, w-dx, d);\n    }\n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// click & drag points\n//\n// State is stored in Buf A:\n// (0,0): previous frame mouse state\n// (1,0): is something selected? x==0:no 1:yes  y==id of current selection\n// (2,0): last point ever selected (default -1; can detect if a pt was ever selected)\n// (x,1): position of point x\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 icoord = ivec2(fragCoord);\n\n    if (iFrame == 0) {\n        if (icoord.y == 0) {\n            fragColor = vec4(0.);\n            if (icoord.x == 2) fragColor = vec4(-1,-1,0,0);\n        }\n        // initialize all points with unit [0..1] values\n        else if (icoord.y == 1) {\n            fragColor = vec4(hash42(fragCoord + 7.).xy, 0., 0.);\n        }\n        return;\n    } \n    \n    if (fragCoord.y > 2. || fragCoord.x > float(UI_MAX_POINTS+1)) {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    // copy previous frame state\n    fragColor = texelFetch(iChannel0, icoord, 0);\n\n    \n    // query previous frame mouse state\n    vec4 mStatePrev = texelFetch(iChannel0, ivec2(0), 0);\n    \n    // This has to match the screen mapping in the Image channel\n    // TODO: add better separation between UI & Image\n    float margin = .5 * (iResolution.x - iResolution.y);\n    vec4 mStateCurr = (iMouse - vec4(margin,0,0,0)) / iResolution.y; // xyxy\n    \n    bool mouseDownPrev = mStatePrev.z > 0.;\n    bool mouseDownCurr = mStateCurr.z > 0.;\n    \n    bool mouseClicked = mouseDownCurr && !mouseDownPrev;\n    bool mouseReleased = !mouseDownCurr && mouseDownPrev;\n    \n    ivec2 selectedId = ivec2(texelFetch(iChannel0, ivec2(1,0), 0).xy);\n    \n    if (mouseClicked && selectedId.x == 0) {\n        // which point did we click?\n        int imin = -1;\n        float dmin = 2.;\n\n        for (int i = 0; i < UI_MAX_POINTS; i++) {\n            float d = distance(mStateCurr.xy, UI_GET_POINT(iChannel0, i));\n            if (d < UI_POINT_SIZE && d < dmin) { dmin = d; imin = i; }\n        }\n        if (imin >= 0) selectedId = ivec2(1, imin);\n        else           selectedId = ivec2(0);\n    }\n\n    else if (mouseReleased) {\n        selectedId = ivec2(0);\n    }\n\n    // animate until UI is touched\n    if (iFrame > 0) {\n        if (UI_GET_LAST_SELECTED(iChannel0) < 0.) {\n           if (icoord.y == 1) {\n               vec4 startEnd = hash42(fragCoord + 7.); // seed needs to match init value above\n               vec4 rnd = hash42(fragCoord + 77.);\n               float slider = 1. - (cos(iTime * rnd.x * .5) * .5 + .5);\n               vec2 pos = mix(startEnd.xy, startEnd.zw, slider);\n               fragColor = vec4(pos, 0., 0.);\n           }\n        }\n    }\n\n    // store new mouse state\n    if (icoord == ivec2(0, 0)) fragColor = mStateCurr;\n    \n    // store id of any clicked point\n    else if (icoord == ivec2(1, 0)) {\n        fragColor = vec4(vec2(selectedId), 0,0);\n    }\n    \n    // store selection history\n    else if (icoord == ivec2(2, 0)) {\n        if (selectedId.x > 0) fragColor = vec4(vec2(selectedId), 0,0);\n    }\n\n    // store position of selected point\n    else if (icoord == ivec2(selectedId.y, 1)) {\n        if (mouseDownCurr && (selectedId.x != 0)) {\n            fragColor = vec4(mStateCurr.xy, 0,0);\n        }\n    }       \n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n//----------------------------------------------------------------------------------------\n// drag points\n\nconst int   UI_MAX_POINTS = 6;\nconst int   NUM_ROOTS = UI_MAX_POINTS;\nconst float UI_POINT_SIZE = .04; // relative to window size\nconst float ZOOM = 3.;\n\n#define UI_GET_POINT(channel, point) texelFetch(channel, ivec2(point, 1), 0).xy\n#define UI_GET_LAST_SELECTED(channel) texelFetch(channel, ivec2(2, 0), 0).x\n\n//----------------------------------------------------------------------------------------\n// Dave Hoskins Hash Without Sine https://www.shadertoy.com/view/4djSRW\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1. );\n    return length( pa - ba*h );\n}\n\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return distance(p,c) - r;\n}\n\n\n//----------------------------------------------------------------------------------------\n// Complex numbers\n\nvec2 Cconj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\nvec2 Cmul(vec2 a, vec2 b) {\n    return vec2(dot(a,vec2(b.x,-b.y)), dot(a.yx,b));\n}\n\nvec2 Cdiv(vec2 b, vec2 a) { // NOTE reversed args!\n    if (a == vec2(0.0, 0.0)) {\n        return a;\n    } \n    \n    if (abs(a.x) >= abs(a.y)) {\n        float r = a.y / a.x;\n        float den = a.x + r * a.y;\n        return vec2(b.x + r * b.y, b.y - r * b.x) / den;\n    } \n    \n    float r = a.x / a.y;\n    float den = a.y + r * a.x;\n    return vec2(b.x * r + b.y, b.y * r - b.x) / den;\n}\n\n// float Cabs(vec2 a) {\n// r = y / x\n// abs(x) * sqrt(1.0 + r * r)\n// |x| * sqrt(1 + y/x * y/x)\n// |x| * sqrt(1 + yy / xx)\n// |x| * sqrt((xx + yy) / xx)\n// |x| * sqrt(1/xx) * sqrt(xx + yy)\n// |x| * |1/x| * sqrt(xx + yy)\n// sqrt(xx + yy)\n\n//*\n// Is this more stable than length?\nfloat Cabs(vec2 a) {\n    if (a.x == 0.0) return abs(a.y);\n    if (a.y == 0.0) return abs(a.x);\n    if (a.x > a.y) {\n        float r = a.y / a.x;\n        return abs(a.x) * sqrt(1.0 + r * r);\n    } else {\n        float r = a.x / a.y;\n        return abs(a.y) * sqrt(1.0 + r * r);\n    }\n}\n//*/\n//float Cabs(vec2 a) { return length(a); }\n\nvec2 Csqrt(vec2 a) {\n    if ((a.x == 0.0) && (a.y == 0.0)) {\n        return vec2(0.0, 0.0);\n    } \n\n    vec2 aa = abs(a);\n    float w;\n    if (aa.x >= aa.y) {\n        float r = aa.y / aa.x;\n        w = sqrt(aa.x) * sqrt(0.5 * (1.0 + sqrt(1.0 + r * r)));\n    } else {\n        float r = aa.x / aa.y;\n        w = sqrt(aa.y) * sqrt(0.5 * (r + sqrt(1.0 + r * r)));\n    }\n\n    if (a.x >= 0.0) {\n        return vec2(w, a.y / (2.0 * w));\n    } else {\n        vec2 c;\n        c.y = (a.y >= 0.0) ? w : -w;\n        c.x = a.y / (2.0 * c.y);\n        return c;\n    }\n}\n\n// vec2 RCmul(float x, vec2 a) { return vec2(x * a.x, x * a.y); }\n\nvec2 Cpow(vec2 z, float n) {\n    float r = length(z);\n    float t = atan(z.y, z.x);\n    float nt = n * t;\n    return pow(r, n) * vec2(cos(nt), sin(nt));\n}\n\nvec2 sym(vec2 z, vec2 z_, float a, float b) {\n    return \n        Cmul(Cpow(z, a), Cpow(z_, b)) + \n        Cmul(Cpow(z, b), Cpow(z_, a));\n}\n","name":"Common","description":"","type":"common"}]}