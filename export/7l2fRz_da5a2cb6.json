{"ver":"0.1","info":{"id":"7l2fRz","date":"1651740999","viewed":150,"name":"Interactive Bezier Dist Field","username":"komrad36","description":"Distance field to Bezier curves of up to degree 11\n\nCLICK + DRAG to add or move control points\nPress E while dragging to erase a control point\nR for random curve\nD for default curve\nC to clear control points","likes":3,"published":1,"flags":48,"usePreview":1,"tags":["distancefield","bezier","curve","rootfinding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const uint kMaxPts = 12u;\nconst float g_fac[kMaxPts] = float[kMaxPts](1.0, 1.0, 2.0, 6.0, 24.0,\n    120.0, 720.0, 5040.0, 40320.0, 362880.0, 3628800.0, 39916800.0);\nvec2 g_b[kMaxPts];\nvec2 g_bp[kMaxPts];\nvec2 g_bpp[kMaxPts];\nvec2 g_c[kMaxPts];\nvec2 g_cp[kMaxPts];\nvec2 g_cpp[kMaxPts];\n\n#define MAKE_FUNCS(n, B, Bp, Bpp, DistSqr, RefineMin, FindMin)\\\nvec2 B(float t)\\\n{\\\n    vec2 s = g_c[0];\\\n    float x = t;\\\n    for (uint i = 1u; i < n; ++i)\\\n    {\\\n        s += x * g_c[i];\\\n        x *= t;\\\n    }\\\n    return s;\\\n}\\\nvec2 Bp(float t)\\\n{\\\n    vec2 s = g_cp[0];\\\n    float x = t;\\\n    for (uint i = 1u; i < n - 1u; ++i)\\\n    {\\\n        s += x * g_cp[i];\\\n        x *= t;\\\n    }\\\n    return s;\\\n}\\\nvec2 Bpp(float t)\\\n{\\\n    vec2 s = g_cpp[0];\\\n    float x = t;\\\n    for (uint i = 1u; i < n - 2u; ++i)\\\n    {\\\n        s += x * g_cpp[i];\\\n        x *= t;\\\n    }\\\n    return s;\\\n}\\\nfloat DistSqr(float t, vec2 q)\\\n{\\\n    vec2 b = q - B(t);\\\n    return dot(b, b);\\\n}\\\nfloat RefineMin(float t, vec2 q)\\\n{\\\n    for (uint i = 0u; i < 3u; ++i)\\\n    {\\\n        vec2 qmbt = q - B(t);\\\n        vec2 d = Bp(t);\\\n        vec2 d2 = Bpp(t);\\\n        t -= dot(qmbt, d) / (dot(qmbt, d2) - dot(d, d));\\\n    }\\\n    return clamp(t, 0.0, 1.0);\\\n}\\\nfloat FindMin(vec2 q)\\\n{\\\n    float bestT = 0.0;\\\n    float bestDistSqr = uintBitsToFloat(0x7F800000u);\\\n    const uint kNumSteps = 32u;\\\n    for (uint i = 0u; i < kNumSteps; ++i)\\\n    {\\\n        float t = RefineMin(float(i) / float(kNumSteps - 1u), q);\\\n        float dSqr = DistSqr(t, q);\\\n        bestT = dSqr < bestDistSqr ? t : bestT;\\\n        bestDistSqr = min(bestDistSqr, dSqr);\\\n    }\\\n    {\\\n        float dSqr = DistSqr(0.0, q);\\\n        bestT = dSqr < bestDistSqr ? 0.0 : bestT;\\\n        bestDistSqr = min(bestDistSqr, dSqr);\\\n    }\\\n    {\\\n        float dSqr = DistSqr(1.0, q);\\\n        bestT = dSqr < bestDistSqr ? 1.0 : bestT;\\\n        bestDistSqr = min(bestDistSqr, dSqr);\\\n    }\\\n    return bestT;\\\n}\n\nMAKE_FUNCS(2u,  B2,  Bp2,  Bpp2,  DistSqr2,  RefineMin2,  FindMin2)\nMAKE_FUNCS(3u,  B3,  Bp3,  Bpp3,  DistSqr3,  RefineMin3,  FindMin3)\nMAKE_FUNCS(4u,  B4,  Bp4,  Bpp4,  DistSqr4,  RefineMin4,  FindMin4)\nMAKE_FUNCS(5u,  B5,  Bp5,  Bpp5,  DistSqr5,  RefineMin5,  FindMin5)\nMAKE_FUNCS(6u,  B6,  Bp6,  Bpp6,  DistSqr6,  RefineMin6,  FindMin6)\nMAKE_FUNCS(7u,  B7,  Bp7,  Bpp7,  DistSqr7,  RefineMin7,  FindMin7)\nMAKE_FUNCS(8u,  B8,  Bp8,  Bpp8,  DistSqr8,  RefineMin8,  FindMin8)\nMAKE_FUNCS(9u,  B9,  Bp9,  Bpp9,  DistSqr9,  RefineMin9,  FindMin9)\nMAKE_FUNCS(10u, B10, Bp10, Bpp10, DistSqr10, RefineMin10, FindMin10)\nMAKE_FUNCS(11u, B11, Bp11, Bpp11, DistSqr11, RefineMin11, FindMin11)\nMAKE_FUNCS(12u, B12, Bp12, Bpp12, DistSqr12, RefineMin12, FindMin12)\n\n#define MAKE_C(f, p)\\\nvec2 f(uint n, uint j)\\\n{\\\n    uint x = 1u;\\\n    for (uint m = 0u; m < j; ++m)\\\n        x *= n - m;\\\n    vec2 s = vec2(0.0);\\\n    for (uint i = 0u; i <= j; ++i)\\\n    {\\\n        float d = g_fac[i] * g_fac[j - i];\\\n        s += uintBitsToFloat(((i + j) << 31u) ^ floatBitsToUint(p[i])) / d;\\\n    }\\\n    return float(x) * s;\\\n}\nMAKE_C(C, g_b)\nMAKE_C(Cp, g_bp)\nMAKE_C(Cpp, g_bpp)\n\nvoid mainImage(out vec4 o, in vec2 c)\n{\n    o = vec4(vec3(0.0), 1.0);\n    uint numPts = uint(texelFetch(iChannel0, ivec2(0), 0).x);\n    uint iPt = kMaxPts;\n    vec2 q;\n    for (uint i = 0u; i < numPts; ++i)\n    {\n        vec2 p = abs(texelFetch(iChannel0, ivec2(i + 1u, 0), 0).xy - c);\n        if (all(lessThan(p, vec2(7.0))))\n        {\n            iPt = i;\n            q = p;\n        }\n    }\n    \n    for (uint i = 0u; i < kMaxPts; ++i)\n        g_b[i] = texelFetch(iChannel0, ivec2(i + 1u, 0), 0).xy;\n    for (uint i = 0u; i < kMaxPts - 1u; ++i)\n        g_bp[i] = float(numPts - 1u) * (g_b[i + 1u] - g_b[i]);\n    for (uint i = 0u; i < kMaxPts - 2u; ++i)\n        g_bpp[i] = float(numPts - 2u) * (g_bp[i + 1u] - g_bp[i]);\n    for (uint i = 0u; i < kMaxPts; ++i)\n        g_c[i] = C(numPts - 1u, i);\n    for (uint i = 0u; i < kMaxPts - 1u; ++i)\n        g_cp[i] = Cp(numPts - 2u, i);\n    for (uint i = 0u; i < kMaxPts - 2u; ++i)\n        g_cpp[i] = Cpp(numPts - 3u, i);\n        \n    if (numPts >= 2u)\n    {\n        float dSqr;\n        switch (numPts)\n        {\n            case 2u:  dSqr = DistSqr2( FindMin2(c),  c); break;\n            case 3u:  dSqr = DistSqr3( FindMin3(c),  c); break;\n            case 4u:  dSqr = DistSqr4( FindMin4(c),  c); break;\n            case 5u:  dSqr = DistSqr5( FindMin5(c),  c); break;\n            case 6u:  dSqr = DistSqr6( FindMin6(c),  c); break;\n            case 7u:  dSqr = DistSqr7( FindMin7(c),  c); break;\n            case 8u:  dSqr = DistSqr8( FindMin8(c),  c); break;\n            case 9u:  dSqr = DistSqr9( FindMin9(c),  c); break;\n            case 10u: dSqr = DistSqr10(FindMin10(c), c); break;\n            case 11u: dSqr = DistSqr11(FindMin11(c), c); break;\n            case 12u: dSqr = DistSqr12(FindMin12(c), c); break;\n        }\n        float d = sqrt(dSqr);\n        float h = clamp(3.81971863421 * atan(0.02 * max(d - 3.0, 0.0)), 0.0, 6.0);\n        h = 5.0/6.0 * h + 1.0;\n        vec3 c2 = clamp(abs(mod(h + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n        c2 = c2 * c2 * (3.0 - 2.0 * c2);\n        o.xyz = mix(vec3(1.0, 0.0, 0.0), c2, smoothstep(2.0, 4.0, d));\n    }\n    \n    if (iPt != kMaxPts)\n    {\n        o.xyz = vec3(0.5);\n        if (numPts > 1u)\n            o.xyz = vec3(float(iPt) / float(numPts - 1u));\n        if (any(lessThan(abs(q - vec2(7.0)), vec2(1.5))))\n            o.xyz = vec3(0.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const uint kMaxPts = 12u;\n\nfloat Rand(float x)\n{\n    return fract(sin(mod(x*91.3458, 6.28318530718)) * 47453.5453);\n}\n\nuint Urand(uint n, float x)\n{\n    return uint(float(n) * Rand(x));\n}\n\nvoid SetDefault(inout uint numPts, inout vec4 o, uint i)\n{\n    switch (i)\n    {\n        case 0u:  o.xy = vec2(0.24, 0.23); break;\n        case 1u:  o.xy = vec2(0.36, 0.02); break;\n        case 2u:  o.xy = vec2(0.57, 0.34); break;\n        case 3u:  o.xy = vec2(0.70, 0.37); break;\n        case 4u:  o.xy = vec2(0.24, 0.56); break;\n        case 5u:  o.xy = vec2(0.76, 0.92); break;\n        case 6u:  o.xy = vec2(0.90, 0.07); break;\n        case 7u:  o.xy = vec2(0.93, 0.19); break;\n        case 8u:  o.xy = vec2(0.25, 0.37); break;\n        case 9u:  o.xy = vec2(0.78, 0.82); break;\n        case 10u: o.xy = vec2(0.53, 0.52); break;\n        case 11u: o.xy = vec2(0.97, 0.80); break;\n    }\n    o = vec4(vec2(uvec2(o.xy * iResolution.xy)) + 0.5, vec2(100.0));\n    numPts = 12u;\n}\n\nvoid mainImage(out vec4 o, in vec2 c)\n{\n    ivec2 xy = ivec2(c);\n    if (any(greaterThan(xy, ivec2(kMaxPts, 0))))\n        return;\n\n    o = texelFetch(iChannel0, xy, 0);\n    vec2 state = texelFetch(iChannel0, ivec2(0), 0).xy;\n    uint numPts = uint(state.x);\n    bool mouseWasDown = bool(state.y);\n    if (iFrame == 0)\n    {\n        numPts = 0u;\n        mouseWasDown = false;\n    }\n    \n    vec2 mouse = iMouse.xy + 0.5;\n    bool mouseDown = iMouse.z > 0.0;\n    bool mouseRelease = mouseWasDown && !mouseDown;\n    bool mouseClick = !mouseWasDown && mouseDown;\n    bool clear = texelFetch(iChannel1, ivec2(67, 1), 0).x != 0.0;\n    bool erase = texelFetch(iChannel1, ivec2(69, 0), 0).x != 0.0;\n    if (clear)\n        numPts = 0u;\n        \n    uint iPoint = kMaxPts;\n    vec2 q;\n    for (uint i = 0u; i < numPts; ++i)\n    {\n        vec2 p = texelFetch(iChannel0, ivec2(i + 1u, 0), 0).xy - mouse;\n        if (all(lessThan(abs(p), vec2(10.0))))\n        {\n            iPoint = i;\n            q = p;\n        }\n    }\n    \n    if (mouseClick && !erase)\n    {\n        if (iPoint != kMaxPts)\n        {\n            if (xy.x == int(iPoint + 1u))\n                o.zw = q;\n        }\n        else if (numPts < kMaxPts)\n        {\n            if (xy.x == int(numPts + 1u))\n                o = vec4(mouse, q);\n            ++numPts;\n        }\n    }\n    \n    vec2 t = texelFetch(iChannel0, ivec2(xy.x + 1, 0), 0).xy;\n    if (mouseDown && erase && iPoint != kMaxPts)\n    {\n        if (xy.x > int(iPoint))\n            o = vec4(t, vec2(100.0));\n        --numPts;\n    }\n    \n    bool random = texelFetch(iChannel1, ivec2(82, 1), 0).x != 0.0;\n    if (random)\n    {\n        numPts = Urand(kMaxPts - 2u, iTime) + 2u;\n        o = vec4(vec2(0.0), vec2(100.0));\n        float seed = iTime + float(xy.y) * iResolution.x + float(xy.x);\n        float x = float(Urand(uint(iResolution.x), seed)) + 0.5;\n        float y = float(Urand(uint(iResolution.y), seed + x)) + 0.5;\n        vec2 f = vec2(x, y);\n        if (xy.x <= int(numPts))\n            o.xy = f;\n    }\n    \n    bool def = texelFetch(iChannel1, ivec2(68, 1), 0).x != 0.0;\n    if (iFrame == 0)\n        def = true;\n    if (def)\n        SetDefault(numPts, o, uint(xy.x - 1));\n    \n    if (mouseRelease)\n        o.zw = vec2(100.0);\n    if (mouseDown && o.z != 100.0)\n        o.xy = mouse + o.zw;\n    if (xy.x == 0)\n        o.xy = vec2(numPts, mouseDown);\n}","name":"Buffer A","description":"","type":"buffer"}]}