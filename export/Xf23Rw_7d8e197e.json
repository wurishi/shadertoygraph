{"ver":"0.1","info":{"id":"Xf23Rw","date":"1703982171","viewed":104,"name":"centripetal force","username":"zeroDarkThirty","description":"• press [r] to reset or start\n• my first attempt at particles, using a lot from https://www.shadertoy.com/view/MdGfDc\n• should be ~ circular motion but I think it's stretched from width and height of screen","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["particle","gravity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 getParticlePosition(in int particleID)\n{\n    int iChannel0_width = int(iChannelResolution[0].x);\n\tivec2 particleCoord = ivec2(particleID % iChannel0_width, particleID / iChannel0_width);\n    return texelFetch(iChannel0, particleCoord, 0).xy;\n}\n\nfloat saturate( float x ) { return clamp( x, 0.0, 1.0 ); }\nvec3 inferno_quintic( float x )\n{\n\tx = saturate( x );\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( -0.027780558, +1.228188385, +0.278906882, +3.892783760 ) ) + dot( x2.xy, vec2( -8.490712758, +4.069046086 ) ),\n\t\tdot( x1.xyzw, vec4( +0.014065206, +0.015360518, +1.605395918, -4.821108251 ) ) + dot( x2.xy, vec2( +8.389314011, -4.193858954 ) ),\n\t\tdot( x1.xyzw, vec4( -0.019628385, +3.122510347, -5.893222355, +2.798380308 ) ) + dot( x2.xy, vec2( -3.608884658, +4.324996022 ) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 particleData = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    float d;\n    \n    float screenSize = .002 * iResolution.x;\n    \n    for(int i = 0; i < nParticles; ++i)\n    {\n        vec3 particlePos = vec3(getParticlePosition(i), 0.0);\n        float rx = fragCoord.x - particlePos.x;\n        float ry = fragCoord.y - particlePos.y;\n        float rMag = rx*rx + ry*ry;\n        d += screenSize/rMag;\n        //fragColor.xyz = inferno_quintic(d);\n    }    \n    \n    \n    float rx = fragCoord.x - iResolution.x/2.;\n    float ry = fragCoord.y - iResolution.y/2.;\n    float rMag = sqrt(rx*rx + ry*ry);\n    d += 3.*screenSize/rMag;\n    fragColor.xyz = inferno_quintic(d);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\nconst int nParticles = 200;\nconst float dt = .00002;\nconst float particlesSize = .001; // normalized uv coords\nconst float mass = 10000.; // click r to restart, centripital velocities should resolve\nconst float collisionDamping = 0.75; // should be 0 <> 1\n\n\nvec2 rotZ( float alpha, vec2 r)\n{\n    float xComp = r.x*cos(alpha) - r.y*sin(alpha);\n    float yComp = r.x*sin(alpha) + r.y*cos(alpha);\n    return vec2( xComp, yComp );\n}\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_RESET  = 82;\n#define KEY(N) texelFetch( iChannel1, ivec2( N, 0 ), 0 ).x\n\n\n/* Get random float from 1 <> 0\n   used function(s) from https://www.shadertoy.com/view/Nsf3Ws, no idea how it works\n*/\n\n//------------------------//\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\nvoid initRandomGenerator(vec2 fragCoord){\n    seed = uint(fragCoord.y*iResolution.x + fragCoord.x)+uint(iFrame)*uint(iResolution.x)*uint(iResolution.y);\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n//------------------------//\n\n\n/* Creating particles in shadertoy has been confusing to me\n   used a lot of logic from https://www.shadertoy.com/view/MdGfDc, still learning\n*/\n\nvoid initParticle(in vec2 fragCoord, inout vec2 particleVelocity, inout vec2 particlePosition)\n{\n    // need to create a random r and v, where v is 90deg xy rotated and vmag = sqrt(mass/rFromCenter)\n    // this is weird because rx and ry are in iResolution frame where velocity is in uv frame\n    // ¯\\_(ツ)_/¯ \n    \n   \n    float rx = random()*.8 + .1;\n    float ry = random()*.8 + .1;\n    vec2 randomR = vec2(iResolution.x*rx,iResolution.y*ry);\n    particlePosition = randomR;\n    randomR /= iResolution.xy;\n    randomR -= .5; // mass is at center so in uv [.5,.5]\n    float mag = sqrt((randomR.x*randomR.x) + (randomR.y*randomR.y));\n    particleVelocity =  - sqrt(mass/(mag)) * rotZ(3.141592654/2.,randomR/mag); // rotate normalized v vect\n    \n    \n    // all on x\n    //float r = 3. + 5.*random();\n\t//particlePosition = vec2(iResolution.x/r,iResolution.y/2.);\n    //particleVelocity = vec2(.0,sqrt(mass/(.5-1./r)));\n\n}\n\n\nvoid solveCollisions(inout vec2 particleVelocity, vec2 particlePosition)\n{\n    vec2 particlePositionFuture = particlePosition + particleVelocity*dt;\n    if( particlePositionFuture.x - particlesSize < 0. || particlePositionFuture.x + particlesSize > 1.)\n    {\n    \tparticleVelocity.x *= -1.*collisionDamping;\n    }   \n    if( particlePositionFuture.y - particlesSize < 0. || particlePositionFuture.y + particlesSize > 1.)\n    {\n    \tparticleVelocity.y *= -1.*collisionDamping;\n    } \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    \n\n\n    int particleID = int(floor(fragCoord.x) + iResolution.x * floor(fragCoord.y));\n    \n    \n    // keep updating data unitl nParticles\n    if(particleID >= nParticles) return;\n    \n    // get data\n    vec4 particleData = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    \n    vec2 particleVelocity = particleData.zw;\n    vec2 particlePosition = particleData.xy;\n    \n    \n    if ( KEY(KEY_RESET) > 0.5 || iFrame < 10  ) \n    {\n        initRandomGenerator(fragCoord);\n        initParticle(fragCoord, particleVelocity, particlePosition);\n    };  \n\n    // normailze\n    particlePosition = particlePosition/iResolution.xy;\n\n    // mass is at [.5 , 5.] (uv)\n    \n    float rX = particlePosition.x - 0.5;\n    float rY = particlePosition.y - 0.5;\n    \n    //float rCubedSqrt = pow(rX * rX + rY * rY, 1.5);\n    \n    float rCubedSqrt = pow(rX * rX + rY * rY, 1.5) + .00001;\n    \n    vec2 force = mass*vec2(-rX/rCubedSqrt,-rY/rCubedSqrt);\n    \n    particleVelocity = (force)*dt + particleVelocity;\n    particlePosition = (particleVelocity)*dt + particlePosition;\n\n\n    solveCollisions(particleVelocity, particlePosition);\n    \n    \n    fragColor = vec4(particlePosition*iResolution.xy, particleVelocity);\n}","name":"Buffer A","description":"","type":"buffer"}]}