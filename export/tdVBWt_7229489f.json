{"ver":"0.1","info":{"id":"tdVBWt","date":"1612189319","viewed":103,"name":"2d-015_domain_repeat.frag","username":"jorge2017a1","description":"2d-015_domain_repeat.frag","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d015domainrepeatfrag"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    daily: 015\n    author: Will Stallwood\n    insta: https://www.instagram.com/willstall/\n    \n*/\n\n//https://github.com/willstall/30-days-of-shade/blob/master/assets/shaders/015_domain_repeat.frag\n\n#define PI 3.14159265359\n#define HALF_PI 1.57079632675\n#define TWO_PI 6.283185307\n\n#define SAMPLES 34\n\n\n\n\n\nfloat linearstep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0.0, 1.0);\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat random( in vec2 st )\n{\n\treturn fract( sin( dot(st.xy, vec2(-30.950,-10.810) )) * 43758.5453123  );\t    \n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nmat2 rotate(float angle)\n{\n    return mat2( cos(angle),-sin(angle),sin(angle),cos(angle) );\n}\n\nvec2 center(vec2 st)\n{\n    float aspect = iResolution.x/iResolution.y;\n    st.x = st.x * aspect - aspect * 0.5 + 0.5;\n    return st;\n}\n\nvec3 debug_sdf(float sdf, bool full)\n{\n   vec3 color = vec3(1.0) - sign(sdf)*vec3(0.1,0.4,0.7);\n   if(full)\n   {\n\tcolor *= 1.0 - exp(-2.0*abs(sdf));\n\tcolor *= 0.89 + .5*cos(80.0*sdf);\n\tcolor = mix( color, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(sdf)) );\n   }\n\n    return color;\n}\n\nfloat cell(vec2 st)\n{\n    st -= 0.5;\n    // st /= 0.25;\n    st *= rotate(PI*.25);\n\n    float d = sdBox(st,vec2(1.5,1.5));      // change box size because of space\n    return d;\n}\n\nvec4 scene(vec2 st, float t)\n{   \n    st *= 6.0;\n\n    // timing\n    float iT = floor(t / .25);\n    float fT = fract(t / .25);\n        fT = pow(fT,.20);\n\n    float spacing = 2.0;        \n    vec2 pos = vec2(0.5,0.5);\n\n    // ugh\n    if(iT == -.0)    \n        pos += vec2(0.0,-spacing)*fT;\n    else if(iT == 1.0)    \n        pos += vec2(0.0,-spacing) +\n        vec2(-spacing,0.0)*fT;\n    else if(iT == 2.0)    \n        pos += vec2(-spacing,-spacing) + \n        vec2(0.0,spacing) *fT;\n    else if(iT == 3.0)    \n        pos += vec2(-spacing,0.0)+ \n        vec2(spacing,0.0) *fT;\n\n    \n    // crazy animation\n    st -= pos * 2.0;\n    st *= 0.8 * (1.0-fT);\n    st *= rotate( TWO_PI / 4.0 * (iT + fT));\n\n    // sdf\n    vec4 sdf = vec4(0.0);\n        sdf.x = cell(fract(st));\n\n        // sdf.y = sdBox(st-pos,vec2(.25));\n\n        // sdf.y = cell(st-pos)+1.15;\n\n    return sdf;\n}\n\nfloat traceShadows(vec2 position, vec2 lightPosition,float t){\n    vec2 direction = normalize(lightPosition - position);\n    float lightDistance = length(lightPosition - position);\n\n    float rayProgress =  0.0001;\n    float nearest = 9999.0;\n    float hardness = 8.50 + random(position) * .50;\n\n    for(int i=0 ;i<SAMPLES; i++){\n        vec4 scene = scene(position + direction * rayProgress,t);\n        float sceneDist = scene.y;\n\n        if(sceneDist <= 0.0){\n            return 0.0;\n        }\n        if(rayProgress > lightDistance){\n            return clamp(nearest,0.0,1.0);\n            //return 1.0;\n        }\n\n        nearest = min(nearest, hardness * sceneDist / rayProgress);\n        rayProgress = rayProgress + sceneDist;\n    }\n\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // space\n    vec2 st = gl_FragCoord.xy / iResolution.xy;\n    st=st*1.5;\n    st = center( st );\n    st = st * 2.0 - 1.0;\n\n    // timing\n    float seconds = 6.0;\n    float t = fract(iTime/seconds);\n\n    // sdf\n    vec4 sdf = scene(st,t);\n\n    // light & shadows\n    vec2 light = vec2(0.0,0.0);\n    float shadows = traceShadows(st,light,t);\n\n    // colors\n    vec3 background = vec3(254.0,226.0,223.0) / 255.0;\n    vec3 shadow = vec3(0.07);\n\n    vec3 cyan = vec3(51.0,180.0,182.0) / 255.0;\n    vec3 blue = vec3(36.0,39.0,90.0) / 255.0;\n    vec3 yellow = vec3(245.0,177.0,71.0) / 255.0;\n    vec3 pink = vec3(240.0,41.0,86.0) / 255.0;\n\n    const int COLOR_COUNT = 8;\n\n    vec3 colors[COLOR_COUNT];\n        colors[0] = cyan;\n        colors[1] = background;\n        colors[2] = blue;\n        colors[3] = background;\n        colors[4] = yellow;\n        colors[5] = background;\n        colors[6] = pink;\n        colors[7] = background;\n\n    // color\n    vec3 color = vec3(0.07);\n        color = background;        \n\n    // color = mix(color,vec3(0.04),smoothstep(0.0,1.0,1.0-shadows));\n    // color = mix(color,vec3(1.0), 1.0 - smoothstep(0.0,0.002,sdf.x));\n\n    // color = mix(color,pink,ceil(fract(sdf.x*10.0)+1.0));\n    // color = mix(color,pink,\n    //     floor(mod(sdf.x*10.0,4.0))\n    // );\n    t = t * float(COLOR_COUNT) - 1.0;\n\n    int color_index = int(floor(mod(sdf.x*20.0+t,float(COLOR_COUNT))));\n    // float color_index = floor(mod(sdf.x*24.0,4.0));\n\n    for(int i = 0; i < COLOR_COUNT; i++)\n    {     \n        vec3 c = colors[i];\n\n        if(i == int(color_index)){\n            color = mix(color,c,1.0 - smoothstep(0.0,0.003,sdf.x));\n        }\n    }\n\n    // color -= background*.9 * (1.0 - smoothstep(0.0,0.003,shadows));\n    // color = mix(color,shadow,smoothstep(0.0,1.0,1.0-shadows));\n\n    // color correction\n    // color -= pow(length(st)-.1,1.8) * 0.1;\n    // color += .07;\n\n    // moving cell\n    // color = mix(color,pink,1.0-sign(sdf.y));\n\n    // int color_index = int(floor(mod(sdf.x*20.0,float(COLOR_COUNT*2))));\n\n    // for(int i = 0; i < COLOR_COUNT+COLOR_COUNT; i++)\n    // {\n    //     vec3 c = colors[i];\n\n    //     if(mod(float(i),2.0) == 1.00)\n    //     {\n    //         c = background;\n\n    //     }else if(i == color_index){\n    //         color = mix(color,c,1.0 - smoothstep(0.0,0.003,sdf.x));\n    //     }\n\n    //     // color = mix(color,c*sdf.x,sdf.z)/.999;\n    // }\n\n\n\n    // color = mix(color,pink,fract(sdf.x*10.0));\n    // color = mix(color,pink,floor(mod(fract(sdf.x*10.0),2.0)+1.0));\n\n    // color = mix(color,vec3(1.0),sign(sdf.xyz));        \n    // color = mix(color,vec3(1.0),sdf.xyz);\n    // color = mix(color,debug_sdf(sdf.y,true),1.0);\n    // color = mix(color,vec3(1.0),\n    //     max(\n    //         step( -0.0015 , st.x ) * step( st.x, 0.0015 ),\n    //         step( -0.0015 , st.y ) * step( st.y, 0.0015 )\n    //     )\n    // );\n\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}