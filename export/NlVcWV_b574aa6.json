{"ver":"0.1","info":{"id":"NlVcWV","date":"1662244203","viewed":164,"name":"Sphere Ocean Basic Structure","username":"jt","description":"My attempt of recreating a \"sphere-ocean\" as seen in other shadertoy shaders.\nBasically animated Worley noise subtracted from a half-space - using DDA (voxel raycasting) for speedup.\nSuggestions for improvement are welcome.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["grid","water","sphere","voxel","ocean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/NlVcWV Sphere Ocean Basic Structure by jt\n// based on https://www.shadertoy.com/view/NstSR8 Cast Voxels March Sub-Objects\n\n// My attempt of recreating a \"sphere-ocean\" as seen in other shadertoy shaders.\n// Basically animated Worley noise subtracted from a half-space - using DDA (voxel raycasting) for speedup.\n\n// tags: water, sphere, ocean, voxel, grid\n\n//#define BOUNDING_BOX_FROM_DDA // there seems to be no speedup either way (or maybe a little?)\n\n#ifdef BOUNDING_BOX_FROM_DDA\n#else\nvec2 boxIntersection( vec2 ro, vec2 rd, vec2 boxSize ) // https://iquilezles.org/articles/intersectors\n{\n    vec2 m = 1.0/rd;\n    vec2 n = m*ro;\n    vec2 k = abs(m)*boxSize;\n    vec2 t1 = -n - k;\n    vec2 t2 = -n + k;\n    float tN = max( t1.x, t1.y );\n    float tF = min( t2.x, t2.y );\n    if( tN>tF || tF<0.0) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n#endif\n\n#define MAX_DIST 1000.0\n\nvec2 hash22(vec2 p) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat sdSphere(vec3 p, float d) // https://iquilezles.org/articles/distfunctions\n{\n    return length(p) - d;\n}\n\nfloat sdSphereR(ivec2 mapPos, vec3 p, float d)\n{\n    vec2 r = hash22(vec2(mapPos));\n    float c = cos(iTime * r.y + r.x) * 0.5/*tweak*/;\n    float s = sin(iTime * r.y + r.x) * 0.5/*tweak*/;\n    vec3 offset = vec3(c, s, 0.0);\n    return sdSphere(p + offset, d);\n}\n\nfloat sdSphere9(ivec2 mapPos, vec3 p, float r)\n{\n    float d = MAX_DIST;\n    for(int y = -1; y <= +1; y++)\n        for(int x = -1; x <= +1; x++)\n            d = min(d, sdSphereR(mapPos - ivec2(x, y), p + vec3(x, y, 0), r));\n    return d;\n}\n\nfloat scene(ivec2 mapPos, vec3 p)\n{\n    float pd = p.z; // base plane\n    p -= vec3(mapPos, 0.0);\n    //return sdSphere3(mapPos, p, 1.0);\n    return max(pd, -sdSphere9(mapPos, p, 1.2/*tweak*/));\n}\n\n#define pi 3.1415926\n\nfloat checker(vec3 p)\n{\n    return step(0.0, sin(pi * p.x + pi/2.0)*sin(pi *p.y + pi/2.0)*sin(pi * p.z + pi/2.0));\n}\n\nmat2 rotate(float t)\n{\n    return mat2(vec2(cos(t), sin(t)), vec2(-sin(t), cos(t)));\n}\n\n#define EPSILON 0.001\n\n// raymarch subobject\nfloat march(ivec2 mapPos, vec3 ro, vec3 rd, float tmin, float tmax)\n{\n    for(float t = tmin; t < tmax;)\n    {\n        float h = scene(mapPos, ro + rd * t);\n        if(h < EPSILON)\n            return t;\n        t += h;\n    }\n    return MAX_DIST;\n}\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal(ivec2 mapPos, vec3 p)\n{\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize(k.xyy * scene(mapPos, p + k.xyy * h) +\n                     k.yyx * scene(mapPos, p + k.yyx * h) +\n                     k.yxy * scene(mapPos, p + k.yxy * h) +\n                     k.xxx * scene(mapPos, p + k.xxx * h));\n}\n\n// (could also be named process_voxel or process_cell)\nvec4 process_subobject(ivec2 mapPos, vec3 ro, vec3 rd, float tmin, float tmax)\n{\n    float d = march(mapPos, ro, rd, tmin, tmax);\n    vec3 n = normal(mapPos, ro + rd * d);\n\n    d = d < tmax ? d : MAX_DIST; // should not be necessary - just in case...\n    return vec4(n, d);\n}\n\n// https://en.wikipedia.org/wiki/Digital_differential_analyzer_(graphics_algorithm)\n// \"The [voxel] raycasting code is somewhat based around a 2D raycasting tutorial found here:\n//  http://lodev.org/cgtutor/raycasting.html\" (fb39ca4)\n\n#define MAX_RAY_STEPS 32\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ndc = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    ndc.x *= iResolution.x / iResolution.y;\n    vec2 m = length(iMouse.xy) <= 10. // click in lower left corner...\n           ? pi * vec2(2.0 * fract(iTime * 0.01), 2.5 / 4.0) // ...for demo mode\n           : pi * vec2(2.0 * iMouse.x / iResolution.x, 0.5 + 0.5 * iMouse.y / iResolution.y); // mouse look\n\n    mat2 R = mat2(cos(m.x), sin(m.x), -sin(m.x), cos(m.x));\n    vec3 ro = vec3(0.0, 0.0,-2.5);\n    mat2 S = mat2(cos(m.y), sin(m.y), -sin(m.y), cos(m.y));\n    ro.yz = S * ro.yz;\n    ro.xy = R * ro.xy;\n    ro.z += 0.0;\n\n    vec3 rd = normalize(vec3(0.5 * ndc.xy, 1.0)); // NOTE: omitting normalization results in clipped edges artifact\n    rd.yz = S * rd.yz;\n    rd.xy = R * rd.xy;\n\n    vec3 color = vec3(0.0);\n    vec4 result = vec4(vec3(0.0), MAX_DIST);\n\n    {\n        vec2 deltaDist = 1.0 / abs(rd.xy);\n        ivec2 rayStep = ivec2(sign(rd));\n        ivec2 mapPos = ivec2(floor(ro));\n        vec2 sideDist = (sign(rd.xy) * (vec2(mapPos) - ro.xy) + (sign(rd.xy) * 0.5) + 0.5) * deltaDist;\n#ifdef BOUNDING_BOX_FROM_DDA\n        float tmin = length(vec2(lessThanEqual(sideDist.xy, sideDist.yx)) * sideDist) / length(rd);\n#endif\n        for (int i = 0; i < MAX_RAY_STEPS; i++)\n        //for (int i = min(iFrame,0); i < MAX_RAY_STEPS; i++) // prevent unrolling loop to prevent crash\n        {\n            {\n#ifdef BOUNDING_BOX_FROM_DDA\n                // try to reconstruct far distance to bounding box from DDA:\n                float tmax = length(vec2(lessThanEqual(sideDist.xy, sideDist.yx)) * sideDist) / length(rd); // hopefully this is correct...\n#else\n                // It appears to be safer to just do the box-intersection here (potential for optimization).\n                vec2 bounds = boxIntersection(ro.xy - vec2(mapPos) - 0.5, rd.xy, vec2(0.5)); // bounding box\n                float tmin = bounds.x; float tmax = bounds.y;\n#endif\n                if(min(ro + rd * tmin,ro + rd * tmax).z < .5) // thanks to kastorp for optimization ideas\n                {\n                    result = process_subobject(mapPos, ro - 0.5, rd, tmin, tmax);\n                    if(rd.z >.0)\n                        break;\n                }\n#ifdef BOUNDING_BOX_FROM_DDA\n                tmin = tmax;\n#endif\n                if(result.w > 0.0 && result.w < MAX_DIST)\n                {\n                    color = vec3(1.0);\n                    //color *= 0.5 + 0.5 * normalize(result.xyz);\n                    vec3 dst = ro + rd * result.w;\n                    //color *= texture(iChannel0, dst).xyz;\n                    //color *= vec3(0.5 + 0.5 * checker(dst));\n\n                    // test refraction\n                    {\n                        vec3 n = result.xyz;\n                        vec3 rd2 = refract(rd, n, 1.0/1.5); // refract: last parameter is air index / water index?\n                        float t = (-2.0-dst.z)/rd2.z; // intersection with ground plane\n                        vec3 dst2 = t * rd2 + dst;\n                        color *= vec3(0.5 + 0.5 * checker(dst2));\n                        //color *= texture(iChannel0, dst2.xy).xxx;\n                    }\n\n                    vec3 fogcolor = vec3(0.25, 0.4, 0.5); // fog\n                    color *= mix(fogcolor, color, exp(-result.w * result.w / 200.0)); // fog for depth impression & to suppress flickering\n\n                    break;\n                }\n            }\n            // Core of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting\n            bvec2 mask = lessThanEqual(sideDist.xy, sideDist.yx);\n            sideDist += vec2(mask) * deltaDist;\n            mapPos += ivec2(vec2(mask)) * rayStep;\n        }\n    }\n\n    vec3 ambient = vec3(0.1);\n    vec3 lightdir = normalize(vec3(3.0, 2.0, 1.0));\n    color *= mix(ambient, vec3(1.0), clamp(dot(lightdir, result.xyz), 0.0, 1.0));\n\n    fragColor.rgb = sqrt(color);\n}\n","name":"Image","description":"","type":"image"}]}