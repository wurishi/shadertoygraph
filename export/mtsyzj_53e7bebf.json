{"ver":"0.1","info":{"id":"mtsyzj","date":"1690984147","viewed":46,"name":"Iterative cubic Bezier (problem)","username":"Envy24","description":"If you set idx to 9, then you see closest point and problem)\nIf you set idx to 0, then you see which curve choosed, and why it cause problem.\nA - red, B - green, C - blue, D - purlpe.\nTangent at mp (black), Normal at mp (grey).","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","bezier","spline","segment"],"hasliked":0,"parentid":"7tcfDB","parentname":"Iterative Cubic Bezier Curve"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define maxIterations 10\n\n#define SCENE_SCALE               ( 1.2 )\n#define UNIT                      ( (SCENE_SCALE*4.0) / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\nfloat diskSDF(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\nstruct DATA\n{\n    vec2 mp;\n    vec2 t;\n    vec2 c;\n    vec2 p0;\n    vec2 p1;\n    vec2 p2;\n    vec2 p3;\n    vec2 p4;\n    vec2 uv;\n    bool s;\n};\n#define NUM_OF_ITERATIONS ( 10 )\nDATA data[NUM_OF_ITERATIONS + 1];\n\nfloat cubicBezierSDF(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3)\n{\n    float f = 0.25, u = 0.5;\n    \n    for(int i = 0; i < NUM_OF_ITERATIONS; ++i) \n    {\n        // CubicBezier(p0, p1, p2, p3, 0.5)\n        vec2 mp = 0.125*(p0 + 3.* (p1 + p2) + p3);\n        // CubicBezierTangent(p0, p1, p2, p3, 0.5)\n        vec2 t = 0.25*((p1 - p0) + 2.*(p2 - p1) + (p3 - p2));\n        vec2 c = 0.5*(p1 + p2);\n         \n        //which side of line (mp, t) are we?\n        if (dot(t, mp-uv) < 0.) {\n            p3 = p3;\n            p2 = 0.5*(p2 + p3);         \n            p1 = 0.5*(c + p2);\n            p0 = mp;\n            \n            u += f;\n        } else {\n            p0 = p0;\n            p1 = 0.5*(p0 + p1);\n            p2 = 0.5*(c + p1);\n            p3 = mp;\n            \n            u -= f;\n        }\n\n        f *= 0.5;\n    }\n    \n    return segmentSDF(uv, p0, p3, 0.);\n}\n// For track calculation for only one point.\nfloat cubicBezierSDF2(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3)\n{\n    float f = 0.25, u = 0.5;\n    \n    for(int i = 0; i < NUM_OF_ITERATIONS; ++i) \n    {\n        // CubicBezier(p0, p1, p2, p3, 0.5)\n        vec2 mp = 0.125*(p0 + 3.* (p1 + p2) + p3);\n        // CubicBezierTangent(p0, p1, p2, p3, 0.5)\n        vec2 t = 0.25*((p1 - p0) + 2.*(p2 - p1) + (p3 - p2));   \n        vec2 c = 0.5*(p1 + p2);\n\n        //which side of line (mp, t) are we?\n        if(dot(t, mp - uv) < 0.) {\n            p3 = p3;\n            p2 = 0.5*(p2 + p3);         \n            p1 = 0.5*(c + p2);\n            p0 = mp;\n            \n            u += f;\n        } else {\n            p0 = p0;\n            p1 = 0.5*(p0 + p1);\n            p2 = 0.5*(c + p1);\n            p3 = mp;\n            \n            u -= f;\n        }\n\n        f *= 0.5;\n        \n        data[i].mp = mp;\n        data[i].t = t;\n        data[i].c = c;\n        data[i].p0 = p0;\n        data[i].p1 = p1;\n        data[i].p2 = p2;\n        data[i].p3 = p3;\n        data[i].s = dot(t, mp - uv) < 0.;\n        data[i].uv = uv;\n    }\n    \n    return segmentSDF(uv, p0, p3, 0.);\n}\n\nvec3 draw_iteration(vec2 uv, vec3 color, int idx, vec2 A, vec2 B, vec2 C, vec2 D)\n{\n    //if (data[idx].s == true) { color *= 0.97; }\n\n    if (idx == NUM_OF_ITERATIONS) { return color; }\n    vec2 mp, t;\n    if (idx != 0) {\n        A = data[idx-1].p0; B = data[idx-1].p1;\n        C = data[idx-1].p2; D = data[idx-1].p3;\n        \n        //mp = data[idx - 1].mp;\n       // t = data[idx - 1].t;\n        //color = mix(color, vec3(0.5), SMAA(diskSDF(uv, mp, 0.01)));\n        //color = mix(color, vec3(0), SMAA(arrowSDF(uv, mp, t, 0.)));\n    }\n    /* Old knots */\n    color = mix(color, vec3(1,0,0), SMAA(diskSDF(uv, A, 0.02)));\n    color = mix(color, vec3(0,1,0), SMAA(diskSDF(uv, B, 0.02)));\n    color = mix(color, vec3(0,0,1), SMAA(diskSDF(uv, C, 0.02)));\n    color = mix(color, vec3(1,0,1), SMAA(diskSDF(uv, D, 0.02)));  \n    /* Old hull*\n    color = mix(color, vec3(0.6), SMAA(segmentSDF(uv, A, B, 0.)));\n    color = mix(color, vec3(0.6), SMAA(segmentSDF(uv, B, C, 0.)));\n    color = mix(color, vec3(0.6), SMAA(segmentSDF(uv, C, D, 0.)));\n    /**/\n        \n    vec2 pA = A, pB = B, pC = C, pD = D;\n    A = data[idx].p0; B = data[idx].p1;\n    C = data[idx].p2; D = data[idx].p3;\n\n    /* New knots */\n    color = mix(color, vec3(1,0,0), SMAA(diskSDF(uv, A, 0.01)));\n    color = mix(color, vec3(0,1,0), SMAA(diskSDF(uv, B, 0.01)));\n    color = mix(color, vec3(0,0,1), SMAA(diskSDF(uv, C, 0.01)));\n    color = mix(color, vec3(1,0,1), SMAA(diskSDF(uv, D, 0.01)));  \n    /* New hull*\n    color = mix(color, vec3(0.6), SMAA(segmentSDF(uv, A, B, 0.)));\n    color = mix(color, vec3(0.6), SMAA(segmentSDF(uv, B, C, 0.)));\n    color = mix(color, vec3(0.6), SMAA(segmentSDF(uv, C, D, 0.)));\n\n    /* Arrows */\n    color = mix(color, vec3(1,0,0), SMAA(arrowSDF(uv, pA, A, 0.)));\n    color = mix(color, vec3(0,1,0), SMAA(arrowSDF(uv, pB, B, 0.)));\n    color = mix(color, vec3(0,1,1), SMAA(arrowSDF(uv, pC, C, 0.)));\n    color = mix(color, vec3(1,0,1), SMAA(arrowSDF(uv, pD, D, 0.)));\n    /**/\n        \n    mp = data[idx].mp;\n    t = data[idx].t;\n    color = mix(color, vec3(0.5), SMAA(diskSDF(uv, mp, 0.01)));\n    color = mix(color, vec3(0), SMAA(arrowSDF(uv, mp, mp+t, 0.))); // tangent\n    vec2 n = vec2(-t.y, t.x);\n    color = mix(color, vec3(0.5), SMAA(arrowSDF(uv, mp, mp+n, 0.))); // normal\n    \n    vec2 UV = data[idx].uv;\n    color = mix(color, vec3(0.2,0.4,0.8), SMAA(arrowSDF(uv, mp, UV, 0.)));\n    \n    return color;\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), false),\n         MP = map_to_centered_ndc(iMouse.xy, SCENE_SCALE, vec2(0), false);\n\n    /**\n    vec2 A = vec2(0.05, 0.5) + vec2(0.1*sin(iTime/0.7), 0.1*cos(iTime/0.7));\n    vec2 B = vec2(0.2, 0.5 + 0.75*sin(iTime)) +  vec2(0.25*cos(iTime/0.5), 0.0);\n    vec2 C = vec2(0.7, 0.5 + 0.75*cos(iTime/2.0)) + vec2(0.25*sin(iTime/0.7), 0.0);\n    vec2 D = vec2(0.95, 0.5) + vec2(0.1*cos(iTime/0.5), 0.1*sin(iTime/0.5));\n    /* Problem set of points (non-convex hull) */\n    vec2 A = vec2(-1., -0.5); \n    vec2 B = vec2(2., -.5);\n    vec2 C = vec2(-2., .5);\n    vec2 D = vec2(1., 0.5);\n    /* Normal set of points (convex hull) *\n    vec2 A = vec2( 1.,   0.5); \n    vec2 B = vec2( 0.5, -0.5);\n    vec2 C = vec2(-0.5, -0.5);\n    vec2 D = vec2(-1.,   0.5);\n    /**/\n     \n    // Time varying pixel color\n    vec3 color = vec3(1);\n    \n    /**/\n    color = mix(color, vec3(1,0,0), SMAA(diskSDF(uv, A, 0.02)));\n    color = mix(color, vec3(0,1,0), SMAA(diskSDF(uv, B, 0.02)));\n    color = mix(color, vec3(0,0,1), SMAA(diskSDF(uv, C, 0.02)));\n    color = mix(color, vec3(1,0,1), SMAA(diskSDF(uv, D, 0.02)));\n    color = mix(color, vec3(0.6), SMAA(segmentSDF(uv, A, B, 0.)));\n    color = mix(color, vec3(0.6), SMAA(segmentSDF(uv, B, C, 0.)));\n    color = mix(color, vec3(0.6), SMAA(segmentSDF(uv, C, D, 0.)));\n    /**/\n    \n    color = mix(color, vec3(0), SMAA(diskSDF(uv, MP, 0.02)));\n\n    float d = cubicBezierSDF (uv, A, B, C, D);\n    float e = cubicBezierSDF2(MP, A, B, C, D);\n    float lineThickness = 0.001;\n    color = mix(color, vec3(0), smoothstep(4./iResolution.y, 0., d - lineThickness));\n    \n\n    int idx = 9;\n    color = draw_iteration(uv, color, idx, A, B, C, D);\n    \n    \n    // Output to screen\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float segmentSDF(in vec2 NDC, in vec2 B, in vec2 E, in float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}\nfloat arrowSDF(\n    in vec2 NDC,\n    in vec2 B,\n    in vec2 E,\n    in float R)\n{\n    float len = length(B-E);    \n    vec2 dir = normalize(E-B),\n         //up = cross(vec3(dir, 0.), vec3(0, 0, -1)).xy,   \n         up = vec2(-dir.y, dir.x),\n         C = E - dir * 0.0275, //      U--\n         U = C + up  * 0.010,  // B----C----E\n         D = C - up  * 0.010;  //      D--\n    \n    vec3 BARY = inverse(mat3(\n            U.x, U.y, 1.0,\n            D.x, D.y, 1.0,\n            E.x, E.y, 1.0)) * vec3(NDC.x, NDC.y, 1.0);\n    \n    float sign = \n        BARY.x >= 0.0 &&    \n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 ?  // inside triangle?\n            -1. : 1.;\n    \n    float d = segmentSDF(NDC, U, D, 0.);\n          d = min(d, segmentSDF(NDC, U, E, 0.));\n          d = min(d, segmentSDF(NDC, D, E, 0.));\n          d = \n              len < 0.0275 ? \n                  d :\n                  min(d, segmentSDF(NDC, B, C, 0.));\n    \n    return sign*d-R;           \n}","name":"Common","description":"","type":"common"}]}