{"ver":"0.1","info":{"id":"ddVyzh","date":"1696533729","viewed":62,"name":"3-Variable Implicits","username":"Seebone","description":"A shader for viewing implicit surfaces (and flatly rendered intersection curves) in 3 variables. Pretty much all functions should be viewable (just change implicit(x,y,z)) but some may require reducing T_STEP to render correctly.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","math","implicit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A shader for viewing implicit surfaces (and flatly rendered intersection curves) in 3 variables.\n// Pretty much all functions of three variabels should be viewable (just change implicit(x,y,z)),\n// but some may require reducing T_STEP to render correctly.\n// The code is really simple, it just finds intersections by iterating newton's method along a ray. \n\n// There are a lot of parameters\n\n/* constants */\n#define M_PI 3.1415926535897932384626433832795\n#define M_TAU 6.2831853071795864769252867665590\n#define M_SQRT2 1.4142135623730950488016887242096\n#define FLT_MAX 3.402823466e+38\n\n\n/* Bounding box */\nconst vec3 BOX_CENTER = vec3(0.);\nconst vec3 BOX_DIM = vec3(10.);\n\n\n/* View Parameters */\nconst float MIN_DIST = 1.;\nconst float MAX_DIST = length(BOX_DIM);\nconst float FOV = 1.;\n\n/* Camera Position and viewing direction */\n// These are only used to initialize these variables once.\n// Weird path:\n#define CAM_POS 20.*vec3(cos(.3333*iTime),0.,sin(.2*iTime))+vec3(0.,4.3+2.*cos(.5*iTime),0.)\n// Circular path:\n//#define CAM_POS 23.*vec3(cos(iTime*.1),0.,sin(iTime*.1))+vec3(0.,5.,0.);\n// Always look toward the origin:\n#define VIEW_DIR -camPos+vec3(0.,0.,0.)\n\n\n/* Newton root finding parameters */\n// number of guesses = MAX_DIST/T_STEP\nconst float T_STEP = MAX_DIST/15.; // Distance between algorithm guesses\nconst int MAX_ITERATIONS = 8; // Iterations per guess\n\n// Converges faster. Sometimes better, but requires second derivative and is a lot more expensive:\n//#define Q_ROOT_FINDING\n\n\n/* Different color gradients (only define one) */\n// Create a checkered pattern in the xz coordinates\n#define XZ_CHECKERED\n\n// Checker depending on the radius\n//#define R_CHECKERED\n\n// Define to be the maximum expected gradient length\n//#define GRAD_LEN 8.\n\n// Define to be the color of the curve\n//#define UNIFORM_COL BG_COL\n\n// Define to be the period of the repeating gradient\n//#define REPEATING MAX_DIST*.333\n\n\n/* Other curve visibility parameters (all can be defined at once) */\n// Not much cheaper since shadows aren't computed anyway:\n//#define NO_LIGHT\n\n// Define to be the intersection color\n//#define PAINT_INTERSECT vec3(1.000,0.000,0.000)\n\n// The way this is done suffers from numerical instability\n//#define DRAW_CONSTRAINT\nconst float BLENDING_CONST = .1; // less accurate but looks better\n\n// Intersection curve width\n#define CW .1\n\n// Should add option to show intersecting surface\n\n// Only show the intersecting regions\n//#define INTERSECT_ONLY\n\n// (Strongly recommended, AA is built on this assumption)\n#define CAM_IS_LIGHT\n\nconst float BG_AA_THRESHOLD = .2; // Lower when using strange background colors\nconst vec3 BG_COL = vec3(0.02); // Background color\n\n// Weird outline:\n//#define OUTLINE\n\n/* Function Parameters */\n// The rendered shape is implicit(x,y,z) = Z_LEVEL\n#define ZERO_LEVEL smp(iTime, -3.9, 10., 10., .7)\n//#define ZERO_LEVEL 0.\n\n/* Rendered Function */\n// Change to any function of x, y, z (y is up)\nfloat implicit(float x, float y, float z) {\n    //return cos(x)*z*y+cos(y)*x*z+cos(z)*x*y; // Good complicated function\n    return (.5*(x*x*x*x+y*y*y*y+z*z*z*z) - 8.*(x*x+y*y+z*z)+60.); // Goursat's Tangle\n    //return x*x + z*z +y*y + sin(4.*x) +  sin(4.*z) + sin(4.*y); // Desmos blobs\n    //return max(max(abs(x), abs(y)), abs(z)) - 3.; // cube\n    //return cos(x)*cos(z) - y; // A wavy surface\n    //return cos(x)+cos(z) + y*y; // Flattened blobs\n    //return cos(x)+cos(z) + cos(y); // Tunnels\n    //return x*y*z; // Very simple and intuitive\n    //return cos(x)+cos(y)+cos(z)+x; // Moving wall of blobs\n    //return abs(x+z) + abs(x-z)-1. + y; // Pyramid (square in 2D)\n    //return distance(vec2(0.),vec2(x,z))- 1. - y; // Intersection is circle\n    //return cos(x)*cos(y)*cos(z)-x*y*z; // xyz but better\n    //return x*x*y*y + y*y*z*z + z*z*x*x-1.; // 4-way tunnel\n    //return x*y*y + y*y*z*z + z*z*x-1.; // Wavy hole\n    //return z*z - (y*y - 3.*x*x)*(3.*y*y - x*x) * (1. - x); // Zoom in \n    //return cos(x * z) + z * sin(x) -1. - y; // Requires a lot of samples\n    //return x+y+z; // plane\n    //return x*x + y*y + z*z -5.; // Sphere\n}\n\n/* Constraining function */\n// Change to any function of x, y, z\nfloat constraint(float x, float y, float z) {\n    return y;\n}\n\n/* END OF PARAMETERS */\n\n// Material properties (just params, not pbr at all)\nstruct Mat {\n    vec3 col; // Color\n    float ref; // reflectivity (at point completely facing light)\n    float colRef; // How much the reflected light keeps the light color\n};\n\nstruct Light {\n    vec3 pos; // position\n    vec3 col; // color\n    float lum; // brightness\n};\n\nstruct Hit {\n    float dist;\n    vec3 pos;\n    int ID;\n};\n\n// Similar to cosine\n// https://www.desmos.com/calculator/udnerpr09b\nfloat smp(float x, float yMin, float yMax, float period, float L) {\n    period = abs(period)*.5;\n    L = clamp(L, 0., 1.)*period;\n    // Function\n    x += .5*L;\n    bool a = mod(x,2.*period) >= period;\n    x = (a ? 1. : -1.)*smoothstep(L, period, mod(x, period)) + (a ? 0. : 1.);\n    //shifting\n    return yMin + (yMax - yMin)*x;\n}\n\nfloat f(vec3 p) {\n    #ifndef DRAW_CONSTRAINT\n    return implicit(p.x, p.y, p.z) - ZERO_LEVEL;\n    #else\n    return abs((implicit(p.x, p.y, p.z) - ZERO_LEVEL)*(constraint(p.x, p.y, p.z))) - BLENDING_CONST;\n    #endif\n}\n\nfloat fC(vec3 p) {\n    return constraint(p.x, p.y, p.z) ;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b ) {\n  b *= .5;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/functions/\nfloat smoothPlatform(float x, float a, float b, float l) {\n    float c = a;\n    a = min(a,b);\n    b = max(c,b);\n    l = clamp(l, 0., .5*(b-a));\n    \n    return smoothstep(a, a+l, x) + smoothstep(b, b-l,x) - 1.;\n}\n\n// get the normalized ray coresponding to a certain point\nvec3 getRay(vec2 uv, vec3 viewDir) {\n    viewDir = normalize(viewDir);\n    // https://www.math3d.org/6EvPX6TgC\n    // Check if looking straight up or down\n    vec3 right;\n    vec3 up;\n    float vxzLen = length(vec2(viewDir.x, viewDir.z));\n    right = vec3(-viewDir.z, 0., viewDir.x)/vxzLen;\n    // First one should work, but it gets really unstable when vxzLen approaches 0\n    //up = -vec3(viewDir.x*viewDir.y/vxzLen, -vxzLen, viewDir.y*viewDir.z)/length(viewDir);\n    up = cross(right, viewDir);\n    \n    vec3 uv3D = viewDir*FOV + uv.x*right + uv.y*up;\n    \n    \n    // Normalized vector from camera\n    return normalize(uv3D);\n    \n    // not relevant to anything here: https://www.math3d.org/cJyaS7Vby\n}\n\n// Get the nth light\nLight getLight(int ID) {\n    Light light;\n    // Returning light\n    if (ID == 1) {\n        light.pos = vec3(0.);\n        light.col = vec3(1.000,1.000,1.000);\n        light.lum = 1.;\n        return light;\n    }\n\n    return light;\n}\n\nMat getMat(int ID, vec3 p) {\n    // If this function took position as an input, in could essentially apply textures to objects\n    Mat m;\n    \n    if (ID < 0) return m;\n    \n    if (ID == 1) {\n        #ifdef XZ_CHECKERED\n        float x = smp(p.x, 0., 1., 2., .97);\n        float y = smp(p.z, 0., 1., 2., .97);\n        m.col = mix(vec3(0.), vec3(1.), .5*(x+y)-x*y); \n        #endif\n\n        #ifdef R_CHECKERED\n        m.col = mix(vec3(0.), vec3(1.), smp(length(p), 0., 1., 1., .9));\n        #endif\n        \n        #ifdef GRAD_LEN\n        const vec2 h = vec2(1e-4,0.);\n        float fGradLen = length(.5* vec3(f(p + h.xyy) - f(p-h.xyy), f(p+h.yxy) - f(p-h.yxy), f(p+h.yyx) - f(p - h.yyx)) /h.x);\n        m.col = mix(vec3(0., 0., 1.), vec3(1.,0.,0.), smoothstep(0., GRAD_LEN, fGradLen));\n        #endif\n        \n        #ifdef UNIFORM_COL\n        m.col = UNIFORM_COL;\n        #endif\n        \n        #ifdef REPEATING\n        float P = REPEATING;\n        m.col = vec3(smp(p.x, 0., 1.,P, 0.), smp(p.y + .666*P, 0., 1., P, 0.), smp(p.z + 1.333*P, 0., 1., P, 0.));\n        #endif\n        m.ref = 1.;\n        m.colRef = .0;\n        return m;\n    }\n    return m;\n}\n\nbool isInViewbox(vec3 p) {\n    vec3 boxDim = .5*BOX_DIM;\n    bool x = BOX_CENTER.x - boxDim.x < p.x && p.x < BOX_CENTER.x + boxDim.x;\n    bool y = BOX_CENTER.y - boxDim.y < p.y && p.y < BOX_CENTER.y + boxDim.y;\n    bool z = BOX_CENTER.z - boxDim.z < p.z && p.z < BOX_CENTER.z + boxDim.z;\n    return x && y && z;\n    \n    //return sdBox(p - BOX_CENTER, BOX_DIM) < 0. ? true : false;\n}\n\nHit intersect(vec3 ro, vec3 rd) {\n    const float rootErr = 1e-3;\n    float t0 = sdBox(ro - BOX_CENTER, BOX_DIM);\n    t0 = t0 < 0. ? MIN_DIST : t0; // if inside box, start at camera\n    float maxDist = t0 + MAX_DIST;\n    Hit hit = Hit(maxDist, vec3(0.), -1);\n    float t00 = t0;\n    //float t0 = 0.;\n    // To be efficient, maxDist should be updated to be the distance to the other side of the box\n    // Intersections should be found instead of distance, then rays that do not pass through the box can be ignored.\n    vec3 p;\n    for (; t0 <= maxDist; t0 += T_STEP) {\n        float fVal = 10.;\n        float t = t0;\n        p = ro + t*rd;\n        fVal = f(p);\n        for (int i = 0; i < MAX_ITERATIONS; i++) {\n            \n             //This does not create nice edges.\n            /*if (!isInViewbox(p)) {\n                break;\n            }*/\n            \n            \n            #ifndef INTERSECT_ONLY\n            if ((abs(fVal) < rootErr) && (t < hit.dist) && isInViewbox(p))\n            #else\n            const vec2 hv = vec2(1e-4,0.);\n            float fCDist = abs(fC(p))/ length(.5* vec3(fC(p + hv.xyy) - fC(p-hv.xyy), fC(p+hv.yxy) - fC(p-hv.yxy), fC(p+hv.yyx) - fC(p - hv.yyx)) /hv.x);\n            if ((fCDist < CW) && (abs(fVal) < rootErr) && (t < hit.dist) && isInViewbox(p))\n            #endif\n            {\n                hit = Hit(t, p, 1);\n                break;\n            }\n          \n            #ifdef Q_ROOT_FINDING\n            const float h = 1e-2;\n            // Finding the root by finding the roots to the quadratic taylor polynomial of f\n            float fF = f(p+h*rd);\n            float fB = f(p-h*rd);\n            float Df = .5*(fF - fB)/h;\n            float DDf = (fF + fB - 2.*fVal)/(h*h);\n            float disc = (Df*Df - 2.*fVal*DDf);\n            \n\n            /* Always choosing same root:\n            t += disc < 0. ? -fVal/Df : -(Df + sqrt(disc))/DDf;\n            p = ro + t*rd;\n            fVal = f(p);\n            */\n            \n            if (disc < 0.) {\n                t -= fVal/Df;\n                p = ro + t*rd;\n                fVal = f(p);\n            } else {\n                disc = sqrt(disc);\n                float r1 = t - (Df + disc)/DDf;\n                float val1 = f(ro+r1*rd);\n                float r2 = t - (Df - disc)/DDf;\n                float val2 = f(ro+r2*rd);\n                \n                // Check what root is best\n                if (abs(val1) < abs(val2)) {\n                    // if the best root is outside bounds and the worse root is inside bounds, choose the worse\n                    if ((r1 < t00 || r1 > maxDist) && (r2 > t00 && r2 < maxDist)) {\n                        t = r2;\n                        fVal = val2;\n                    } else {\n                        t = r1;\n                        fVal = val1;\n                    }\n                } else {\n                    // same as above\n                    if ((r2 < t00 || r2 > maxDist) && (r1 > t00 && r1 < maxDist)) {\n                        t = r1;\n                        fVal = val1;\n                    } else {\n                        t = r2;\n                        fVal = val2;\n                    }\n                }\n                p = ro + t*rd;\n            }\n           \n            #else\n            const float h = 1e-4;\n            t -= 2.*h*fVal/(f(p+h*rd) - f(p-h*rd)); //central difference\n            //t -= 2.*h*fVal/(f(p+h*rd) - fVal)); // forward difference\n            p = ro + t*rd;\n            fVal = f(p);\n            #endif\n            \n            /*\n            if (t > maxDist || t < t00) {\n                break;\n            }*/\n        }\n    }\n    return hit;\n}\n\n// The normal is the gradient of the implicit\nvec3 normal( vec3 p ) {\n    const vec2 h = vec2(1e-3, 0.); \n    return normalize(vec3(f(p + h.xyy) - f(p-h.xyy), f(p+h.yxy) - f(p-h.yxy), f(p+h.yyx) - f(p - h.yyx)));\n}\n\nvec3 getCol(Hit hit, vec3 camPos, vec3 ray) {\n    vec3 col = vec3(0.);\n    if (hit.ID < 0) {\n        return BG_COL;\n    }\n    \n    vec3 p = hit.pos;\n    Mat objMat = getMat(hit.ID,p);\n    \n    #ifdef PAINT_INTERSECT\n        const vec2 h = vec2(1e-4,0.);\n        float fCDist = abs(fC(p))/ length(.5* vec3(fC(p + h.xyy) - fC(p-h.xyy), fC(p+h.yxy) - fC(p-h.yxy), fC(p+h.yyx) - fC(p - h.yyx)) /h.x);\n\n        #ifdef INTERSECT_ONLY\n        objMat.col = mix(PAINT_INTERSECT, BG_COL, smoothstep(.7*CW, CW, fCDist));\n        #else\n        objMat.col = mix(PAINT_INTERSECT, objMat.col, smoothstep(.7*CW, CW, fCDist));\n        #endif\n    #endif\n    #ifdef INTERSECT_ONLY\n    #ifndef PAINT_INTERSECT\n    const vec2 h = vec2(1e-4,0.);\n    float fCDist = abs(fC(p))/ length(.5* vec3(fC(p + h.xyy) - fC(p-h.xyy), fC(p+h.yxy) - fC(p-h.yxy), fC(p+h.yyx) - fC(p - h.yyx)) /h.x);\n    objMat.col = mix(objMat.col, BG_COL, smoothstep(.8*CW, CW, fCDist));\n    #endif\n    #endif\n\n    #ifdef NO_LIGHT\n    return objMat.col * objMat.ref;\n    #endif\n\n    Light light = getLight(1);\n    #ifdef CAM_IS_LIGHT\n    light.pos = camPos;\n    #endif\n    \n    float intensity = abs(dot(normalize(light.pos-p),normal(p)));\n    col = mix(objMat.col, light.col, objMat.colRef);\n    col = light.lum*objMat.col*intensity*objMat.ref;\n\n    #ifndef INTERSECT_ONLY\n    \n    #ifdef OUTLINE\n    col *= 1. - smoothPlatform(intensity, .2, .4, .05);\n    #endif\n    \n    // Blending with background.\n    col = mix(BG_COL, col, smoothstep(0., BG_AA_THRESHOLD, intensity));\n    #endif\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalizes x-distance to 1 while keeping aspect ratio and shifting so that (0,0) is at center of viewport.\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) / iResolution.x;\n\n    // y is height\n    vec3 camPos = CAM_POS;\n    vec3 viewDir = VIEW_DIR; // magnitude needs to be 1\n\n    vec3 ray = getRay(uv, viewDir);\n    Hit hit = intersect(camPos, ray);\n    vec3 col = getCol(hit, camPos, ray);\n\n    // Gamma correction?\n    col = pow(col, vec3(0.4545));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}