{"ver":"0.1","info":{"id":"3ss3R4","date":"1545183972","viewed":2346,"name":"Polar Night","username":"supervitas","description":"Simple raymarching terrain, thanks nimitiz for aurora","likes":58,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","terrain","aurora","winter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4tl3z4","filepath":"https://soundcloud.com/dj-finao/sun","previewfilepath":"https://soundcloud.com/dj-finao/sun","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: supervitas\n\n#define MAX_MARCHING_STEPS 256\n#define MAX_DIST 6. // far\n#define EPSILON 0.001\n#define PI 3.1415926535\n\n#define u_time iTime\n#define u_resolution iResolution\n\n\nfloat random(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec3 noise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n\n  vec2 df = 20.0*f*f*(f*(f-2.0)+1.0);\n  f = f*f*f*(f*(f*6.-15.)+10.);\n\n  float a = random(i + vec2(0.5));\n  float b = random(i + vec2(1.5, 0.5));\n  float c = random(i + vec2(.5, 1.5));\n  float d = random(i + vec2(1.5, 1.5));\n\n  float k = a - b - c + d;\n  float n = mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n\n  return vec3(n, vec2(b - a + k * f.y, c - a + k * f.x) * df);\n}\n\nmat2 terrainProps = mat2(0.8,-0.4, 0.5,0.8);\nfloat fbmM(vec2 p) {\n  vec2 df = vec2(0.0);\n  float f = 0.0;\n  float w = 0.5;\n\n  for (int i = 0; i < 8; i++) {\n    vec3 n = noise(p);\n    df += n.yz;\n    f += abs(w * n.x / (1.0 + dot(df, df)));\n    w *= 0.5;\n    p = 2. * terrainProps * p;\n  }\n  return f;\n}\n\nfloat fbmH(vec2 p) {\n  vec2 df = vec2(0.0);\n  float f = 0.0;\n  float w = 0.5;\n\n  for (int i = 0; i < 12; i++) {\n    vec3 n = noise(p);\n    df += n.yz;\n    f += abs(w * n.x / (1.0 + dot(df, df)));\n    w *= 0.5;\n    p = 2. * terrainProps * p;\n  }\n  return f;\n}\n\n\nfloat fbmL(vec2 p) {\n  vec2 df = vec2(0.0);\n  float f = 0.0;\n  float w = 0.5;\n\n  for (int i = 0; i < 2; i++) {\n    vec3 n = noise(p);\n    df += n.yz;\n    f += abs(w * n.x / (1.0 + dot(df, df)));\n    w *= 0.5;\n    p = 2. * terrainProps * p;\n  }\n  return f;\n}\n\n\n\nfloat map(vec3 p) {\n    float scene = p.y;\n    \n    float h = fbmM(p.xz);\t\n    scene -= h;\n\n  \treturn scene;\n}\n\n\nfloat raymarch(vec3 ro, vec3 rd) {\n  float d = 0.;\n  float t = 0.;\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    d = map(ro + t * rd);\n    if (d < EPSILON * t || t > MAX_DIST) break;\n    t += 0.5 * d;\n  }\n\n  return d < EPSILON * t ? t : -1.;\n}\n\nvec3 normal(vec3 pos, float t) {\n\tvec2  eps = vec2( 0.002*t, 0.0 );\n    return normalize( vec3( fbmH(pos.xz-eps.xy) - fbmH(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            fbmH(pos.xz-eps.yx) - fbmH(pos.xz+eps.yx) ) );\n}\n\nstruct light {\n  vec3 lightPosition;\n  vec3 amibnetColor;\n  float ambientIntencity;\n  vec3 directLightColor;\n  vec3 directLightIntencity;\n};\n\nvec3 diffuseLight(vec3 k_d, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity) {\n  vec3 N = normal(p, 0.01);\n  vec3 L = normalize(lightPos - p);\n\n  float dotLN = dot(L, N);\n\n  if (dotLN < 0.0) {\n    return vec3(0.0, 0.0, 0.0);\n  }\n\n  return lightIntensity * (k_d * dotLN);\n}\n\nvec3 calcLights(light data, vec3 p, vec3 eye) {\n  vec3 ambientColor = data.ambientIntencity * data.amibnetColor;\n  vec3 phongColor = diffuseLight(data.directLightColor, p, eye, data.lightPosition, data.directLightIntencity);\n\n  return ambientColor + phongColor;\n}\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = cross(ww, rr);\n  vec3 vv = cross(uu, ww);\n\n  return mat3(uu, vv, ww);\n}\n\nvoid setColor(vec3 p, vec3 n, out vec3 color) {\n  float a = smoothstep(0.440 * n.y, 0.816 * n.y, fbmM(p.xz));\n  vec3 ground = vec3(0.046,0.043,0.100);\n  color = mix(vec3(1.), ground, a);  \n}\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nfloat tri(in float x){return clamp(abs(fract(x)-.5),0.01,0.49);}\nvec2 tri2(in vec2 p){return vec2(tri(p.x)+tri(p.y),tri(p.y+tri(p.x)));}\n\nfloat fbmAurora(vec2 p, float spd) {\n    float z = 1.8;\n    float z2 = 2.5;\n\tfloat rz = 0.;\n    p *= mm2(p.x * 0.06);\n    vec2 bp = p;\n\tfor (float i = 0.; i < 5.; i++ ) {\n        vec2 dg = tri2(bp*1.85)*.75;\n        dg *= mm2(u_time*spd);\n        p -= dg/z2;\n\n        bp *= 1.3;\n        z2 *= .45;\n        z *= .42;\n\t\tp *= 1.21 + (rz-1.0)*.02;\n        \n        rz += tri(p.x+tri(p.y))*z;\n        p*= sin(u_time * 0.05) * cos(u_time * 0.01);\n\t}\n    return clamp(1. / pow(rz * 20., 1.3), 0.,1.);\n}\n\n\nvec4 aurora( vec3 rd) {\n    vec4 col = vec4(0);\n    vec4 avgCol = vec4(0);    \n\n    for (float i=0.; i < 50.; i++) {\n        float of = 0.006*random(gl_FragCoord.xy)*smoothstep(0.,15., i);\n        float pt = ((.8+pow(i,1.4)*.002)) / (rd.y * 2. + 0.4);\n        pt -= of;\n    \tvec3 bpos = 5.5 + pt * rd;\n        vec2 p = bpos.zx;\n        float rzt = fbmAurora(p, 0.06);\n        vec4 col2 = vec4(0,0,0, rzt);\n        col2.rgb = (sin(1.-vec3(2.15,-.5, 1.2) +i * 0.043) * 0.5 + 0.5)*rzt;\n        avgCol = mix(avgCol, col2, .5);\n        col += avgCol * exp2(-i*0.065 - 2.5) * smoothstep(0., 5., i);\n    }\n    col *= (clamp(rd.y*15.+.4,0.,1.));\n \n    return smoothstep(0.,1.1,pow(col,vec4(1.))*1.5);\n}\n\nvec3 stars(vec2 p) {\n    float r = fbmL(p * 20.  );\n    float isStar = step(0.707, r);\n    return vec3(r) * isStar;\n}\n\nvoid setSkyColor(vec2 uv, out vec3 color, vec3 dir) {\n   color = mix(vec3(0.006,0.026,0.095), vec3(0.007,0.011,0.035), uv.y);\n   color += stars(dir.xz / dir.y);\n   color += aurora(dir).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / u_resolution.xy;\n  vec2 p = (-u_resolution.xy + 2.0 * gl_FragCoord.xy) / u_resolution.y;\n\n  float speed = 0.002;\n  float terrainEndTime = abs(sin(u_time * speed));\n  vec3 ro = vec3(mix(0., 100., terrainEndTime), 1.2, mix(0., 100., terrainEndTime)); // cause endless will have problems with floats\n    \n  float minHeight = 0.2 + 1.1 * fbmL(ro.xz);\n  ro.y = minHeight;\n\n  float a = sin(u_time * speed * 2.);\t\n  vec3 target = ro + vec3(mix(0.9, 1.64, (sin(u_time * 0.25  ))),\n                          mix(-.1, .1, abs(sin(u_time * 0.125 + cos(u_time * 0.0125) ))),\n                          a); // revert camera when near to end\n  mat3 cam = calcLookAtMatrix(ro, target, 0.);\n  vec3 rd = cam * normalize(vec3(p.xy, 1.064));\n\n  vec3 color = vec3(0.0);\n  float scene = raymarch(ro, rd);\n  vec3 point = ro + scene * rd;\n  if (scene > -1.) {\n    light light1 = light(\n      ro + vec3(10., 150., 100.), // light position\n      vec3(0.931,0.975,0.906), 0.412, // ambient color - ambient intencity\n      vec3(0.254,1.000,0.777), vec3(0.162,0.555,0.560)); // direct light color - direct light intencity\n\n\n    vec3 nor = normal(point, scene);\n\n    setColor(point, nor, color);\n\n    color *= calcLights(light1, point, ro);\n  } else {\n    point = ro + scene * rd;\n    setSkyColor(uv, color, rd);\n  }\n\n  color = pow(color, vec3(1. / 2.2)); // gamma correction\n  color = smoothstep(0., 1.,color);\n\n  fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}