{"ver":"0.1","info":{"id":"dtSyzV","date":"1692033901","viewed":78,"name":"Walk on Spheres WNF Convergence","username":"chronos","description":"Computing winding numbers using the walk on spheres algorithm\nFork of a previous shader. This one uses russian roulette to de-bias, and shows the w = 1/2 isosurface","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["spheres","numbers","on","walk","winding","wos","walkonspheres","windingnumber"],"hasliked":0,"parentid":"Dljyzy","parentname":"Walk on Spheres Winding Numbers"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define USE_sRGB 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0);\n\n    vec4 bufA = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    \n    int segment_count = get_segment_count(iFrame);\n\n    // comment/uncomment to compare in different ways.\n    //if(iMouse.z < .5) // press to flip between\n    if(uv.x > mouse.x) // slide with mouse\n    //if(uv.x > 0.) // split vertically down middle\n    {\n        // Note that we have to divide by the alpha channel here, to average the results.\n        // This can lose precisions after a while, so a better method of accumulation\n        // that is more numerically stable for large accumulation times could be used instead.\n        float walk_on_spheres_result = bufA.r / bufA.a;        \n        color = winding_number_to_color(walk_on_spheres_result);\n    }\n    else\n    {\n        float winding_number = 0.;\n\n        for(int i = 0; i < segment_count; i++)\n        {\n            winding_number += winding_number_segment(uv, segments[i]);\n        }\n        \n        color = winding_number_to_color(winding_number);\n    }\n    \n    // This is just for visualizing error:\n    if(false)\n    {\n        float walk_on_spheres_result = bufA.r / bufA.a;\n        float winding_number = 0.;\n\n        for(int i = 0; i < num_segments; i++)\n        {\n            winding_number += winding_number_segment(uv, segments[i]);\n        }\n                \n        color = vec3(winding_number >= .9999 ? 1. : 0.);\n        \n        color = vec3(walk_on_spheres_result >= .9999 ? 1. : 0.);\n        \n        color = clamp(vec3(\n                    walk_on_spheres_result - winding_number,\n                    0.,\n                    winding_number - walk_on_spheres_result\n                ), 0., 1.);\n    }\n\n#if USE_sRGB\n    fragColor = vec4(linearToSRGB(color), 1.0);\n#else\n    fragColor = vec4(color, 1.0);\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// Walk on spheres algorithm\n// Accumulate average over time\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    fragColor = vec4(0);\n    \n    if(iFrame < 1 || restart_signal(iFrame)) return;\n        \n    int segment_count = get_segment_count(iFrame);\n        \n    vec4 buffer = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    \n    const int num_iterations = 10;\n    \n    for(int it = 0; it < num_iterations; it++)\n    {\n        \n        vec3 acc_color = vec3(0);\n        vec3 acc_weight = vec3(0);\n        \n        // Sample random segment instead of iterating over all of them\n        // for(int seg_idx = 0; seg_idx < segment_count; seg_idx++)\n        int seg_idx = int(float(segment_count) * hash(vec3(fragCoord, iFrame * num_iterations + it)));\n        \n        {\n            vec2 march_pos = uv;\n            vec2 march_pos_prev = march_pos;\n            \n            /*\n            Too low number of steps leads to increased bias, meaning that the expected value will be off / a bit wrong.\n            Maybe some scheme such as russian roulette for walk termination or some other iteration procedure will\n            be more unbiased.\n            \n            This is probably caused by the fact that limiting the number of steps is equivalent to limiting\n            the steps in the brownian motion diffusion process, meaning that the tail of the gaussian distribution will be cut.\n            If a sequence has to walk around a segment, then that sequence typically has a greater number of steps,\n            so the bias introduced will be towards the side of the starting point of the sequence / walk.\n            \n            Here I've tried to reduce the bias using russian roulette, which seems to work, but the variance seems\n            to remain.\n            \n            The paper:\n            \"A first-passage algorithm for the hydrodynamic frictionand diffusion-limited reaction rate of macromolecules\"\n            by\n            James A. Given, Joseph B. Hubbard, and Jack F. Douglas\n            \n            seems to give another possible solution by using a Green's Function in appendix B\n            it appears they solve the \"first passage\" problem by some sphere inversion method.\n            The algorithm computes whether a virtual diffusing particle first exits the sphere boundary\n            or passes the line segment (in this case). by intersecting the sphere with radius equal to the distance\n            to the closest of the two endpoint vertices (or edges in 3D) to form a smaller segment, the coord of the sphere and the line.\n            then determining probability of crossing.\n            \n            This likely explains why winding numbers can be computed by WoS, since\n            the probability of crossing the capped sphere by the line segment is likely related to the angle of the segment\n            relative to the source point.\n            \n            */\n                        \n            for(float i = 0.; i < 2560.; i++)\n            {\n                vec4 border_sample = border(march_pos, seg_idx);\n                {\n                    float dist = distance_to_segment(march_pos, segments[seg_idx]);\n\n                    vec3 col = sign( vec3(segment_side(march_pos, segments[seg_idx])) ) / 2.;\n                    border_sample.rgb = col;\n                    border_sample.a = dist;\n                }\n                \n                vec4 border_sample_prev = border(march_pos_prev, seg_idx);\n                {\n                    float dist = distance_to_segment(march_pos_prev, segments[seg_idx]);\n\n                    vec3 col = sign( vec3(segment_side(march_pos_prev, segments[seg_idx])) ) / 2.;\n                    \n                    border_sample_prev.rgb = col;\n                    border_sample_prev.a = dist;\n                }                \n                \n                // The following gives probability\n                //    product_(i=0)^10(1 - sqrt(i)/(2 + sqrt(i))) â‰ˆ 0.00061367\n                // of surviving 10 steps.\n                \n                // sqrt makes probability of terminating rise more slowly with more iterations\n                // i.e makes surviving longer more likely\n                float iteration_penalty = (i); //sqrt(i)\n                \n                // Increase to make it more likely to take more iterations\n                // Decrease to make it more likely to terminate early\n                const float survival_constant = (35.); // 2.; // for sqrt\n                \n                float russian_roulette_probability = iteration_penalty / (survival_constant + iteration_penalty);\n                float russian_roulette_weight = 1. / (1.-russian_roulette_probability);\n                \n                float russian_roulette_spin = hash(vec3(fragCoord + iResolution.xy, iFrame * num_iterations + it));\n                \n                bool should_terminate = russian_roulette_spin < russian_roulette_probability;\n                \n                if(\n                    border_sample.a < eps\n                    ||\n                    sign(border_sample_prev.a) != sign(border_sample.a)\n                    ||\n                    should_terminate\n                )\n                {                    \n                    float weight = 1./float(segment_count);\n                    //buffer += vec4(border_sample_prev.rgb, weight);\n                    \n                    acc_color += float(!should_terminate)*border_sample_prev.rgb * russian_roulette_weight;\n                    acc_weight += weight;\n                    \n                    break;\n                }\n                \n                march_pos_prev = march_pos;\n                \n                march_pos += random_point_on_sphere(border_sample.a, hash(vec3(fragCoord.xy, 10.*(float(it*128) + i) + iTime)));\n            }\n            \n        }\n        buffer += vec4(acc_color, acc_weight);\n    }\n    \n    fragColor = buffer;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265359;\nconst float eps = 0.001;\n\nconst float GAMMA = 2.4;\nfloat linearToSRGB(float channel)\n{\n    const float a = 12.92;\n    const float b = 1.055;\n    const float c = 0.055;\n    const float threshold = 0.0031308;\n    \n    return channel <= threshold ? a * channel : (b * pow(channel, 1./GAMMA) - c);\n}\nvec3 linearToSRGB(vec3 color)\n{\n    color = clamp(color, 0., 1.);\n    return vec3(linearToSRGB(color.r), linearToSRGB(color.g), linearToSRGB(color.b));\n}\n\nint get_segment_count(int frame);\nvec2 random_point_on_sphere(float radius, float rnd_01)\n{\n    float random_angle = 2. * PI * rnd_01;\n    return radius * vec2(cos(random_angle), sin(random_angle));\n}\n\nfloat hash(vec3 uv)\n{\n    uint x = floatBitsToUint(uv.x) | 1u; // 0 is a fixed point so we remove it. although this introduces duplicate 1\n    uint y = floatBitsToUint(uv.y);\n    uint z = floatBitsToUint(uv.z);\n    \n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    z ^= x;\n    z ^= z >> 13;\n    z ^= z << 17;\n    z ^= z >> 5;\n    z *= 0x1D6C45F4u;\n    \n    // Shift down by 9 to use top 23 bits in mantissa\n    // Use exponent and sign bits from 0.5\n    // floatBitsToUint(.5) is a constant so that part can be pre-computed. (0x3f000000)\n    // Since the top 23 bits are shifted right, the rest (top bits) are zero and do not need to be masked out\n    // uint w = ((z>>9) & 0x007FFFFFu) | (0xFF800000u & floatBitsToUint(.5));\n    \n    uint w = (z>>9) | 0x3f000000u; // simplified version of the above commented out line\n    \n    // re-normalize from [0.5, 1) to [0, 1)\n    // This probably loses some bits, but should still be ok\n    return 2. * uintBitsToFloat(w) - 1.;\n}\n\n\n// Line segment\nstruct segment\n{\n    vec2 from, to;\n};\n\nstruct intersect_result\n{\n    bool bIntersects;\n    float intersection_direction; // positive, negative or zero\n    vec2 position;\n};\n\n// exterior product\nfloat wedge(vec2 a, vec2 b)\n{\n    return a.x * b.y - b.x * a.y;\n}\n\nfloat segment_side(vec2 p, segment s)\n{\n    vec2 a = p - s.from;\n    vec2 b = p - s.to;\n    return wedge(a, b);\n}\n\n// was intended to be used when WoS iterations cross from one side of a segment to another,\n// due to numberical imprecision, but i dropped it, as it seems it is not necessary\n// not completed!\n/*\nintersect_result line_segment_intersection(segment a, segment b)\n{\n    float from_side = segment_side(b.from, a);\n    float to_side = segment_side(b.to, a);\n    \n    // positive: crosses from positive to negative\n    // negative: crosses from negative to positive\n    float intersection_direction = from_side;\n    \n    return intersect_result(false, intersection_direction, vec2(0));\n}\n*/\nfloat scalar_project_to_vector(vec2 point, vec2 v)\n{\n    return dot(point, v) / dot(v,v);\n}\n\nfloat scalar_project_to_line(vec2 from, vec2 to, vec2 point)\n{\n    vec2 dir = to - from;\n    return scalar_project_to_vector(point-from, dir);\n}\n\nvec2 project_point_to_segment(vec2 point, segment s)\n{\n    float t = scalar_project_to_line(s.from, s.to, point);\n    t = clamp(t, 0., 1.);\n    \n    return s.from + t * (s.to - s.from);\n}\n\nfloat distance_to_segment(vec2 point, segment s)\n{\n    return distance(project_point_to_segment(point, s), point);\n}\n\nfloat winding_number_segment(vec2 p, segment s)\n{\n    vec2 a = normalize(s.from-p);\n    vec2 b = normalize(s.to-p);\n    float d = dot(a,b);\n    float angle = acos(d);\n    angle = min(angle, 2.*PI - angle);\n    return sign(determinant(mat2(a,b))) * angle / (2. * PI);\n}\n\nvec3 winding_number_to_color(float winding_number)\n{\n    //return mix(vec3(1,0,0), vec3(0,0,1), 0.5*(1.+tanh(1.*winding_number))); // smooth, nonlinear, asymptotically towards 0 and 1\n    vec3 color = mix(vec3(1,0,0), vec3(0,0,1), 0.5*(1.+winding_number));\n    \n    // Isosurface at w = 1/2\n    color += smoothstep(.5-0.02, .5+0.0, winding_number) * smoothstep(.5 + 0.02, .5 + 0.0, winding_number);\n    return color;\n}\n\nconst int num_segments = 4;\nsegment segments[num_segments] = segment[num_segments]\n(\n    segment(vec2(-.5, -.5), vec2(  .5, -.5)),\n    segment(vec2(-.5,  .5), vec2( -.5, -.5)),\n    segment(vec2( .5, -.5), vec2(  .5,  .5)),\n    segment(vec2( .5,  .5), vec2( -.5,  .5))\n    \n);\n\nvec4 border(vec2 p, int seg_idx)\n{        \n    float dist = distance_to_segment(p, segments[seg_idx]);\n\n    // The winding number function very near a line segment is -1/2 turns on one side, and 1/2 turns on the other\n    // that is, corresponding to -180 degrees and +180 degrees respectively.\n    vec3 col = sign( vec3(segment_side(p, segments[seg_idx])) ) / 2.;\n    \n    return vec4(col, dist);\n}\n\nconst int frames_per_scene = 1200;\n\nbool restart_signal(int frame)\n{\n    return frame % frames_per_scene == 0;\n}\n\nint get_segment_count(int frame)\n{\n    return 1 + ((frame / frames_per_scene) % 4); // [1, 4] inclusive\n}\n\n// From earlier attempt. this is for when each iteration is a single walk on spheres on *all* segments at once.\n// It would be much better if this could be used, similar to how it would be done for SDF ray marching\n/*\nvec4 border(vec2 p)\n{        \n    vec3 col = vec3(0);\n    float dist = 9e9;\n\n    for(int i = 0; i < num_segments; i++)\n    {        \n        float d = distance_to_segment(p, segments[seg_idx]);\n        \n        if(d < dist)\n        {\n            dist = d;\n            \n            float seg_side = segment_side(p, segments[i]);\n            \n            col = sign( vec3(seg_side) ) / 2.;\n        }\n    }\n    \n    return vec4(col, dist);\n}\n*/","name":"Common","description":"","type":"common"}]}