{"ver":"0.1","info":{"id":"fsKSzV","date":"1635461529","viewed":61,"name":"Graphic Assignment 1","username":"bagyura","description":"Class assignment.","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["distance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Source: https://www.shadertoy.com/view/sdcSRM\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //const int k = 4;\n    //fragColor = vec4(0);\n    /*ivec2 pixel = ivec2(fragCoord);\n    for(int i=-k; i<=k; i++)\n    for(int j=-k; j<=k; j++)\n    {\n        fragColor += texelFetch(iChannel0,pixel+ivec2(i,j),0);\n    }\n    \n    fragColor /= float((2*k+1)*(2*k+1));*/\n    //fragColor = texelFetch(iChannel0,ivec2(fragCoord),0).wwww/15.;\n    fragColor = 2.*texelFetch(iChannel0,ivec2(fragCoord),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Source: https://www.shadertoy.com/view/sdcSRM\n\n// This file contains the \n// ---- SPHERE TRACING ----\n\nstruct Ray\n{\n\tvec3 P;\n\tfloat Tmin;\n\tvec3 V;\n\tfloat Tmax;\n};\n\nstruct MaterialRay\n{\n\tvec3 P;\n\tfloat Tmin;\n\tvec3 V;\n\tfloat Tmax;\n    float materialId;\n};\n\nstruct TraceResult\n{\n    float T;\t\t// Distance taken on ray\n    int flags;\t\t// bit 0:   distance condition:     true if travelled to far t > t_max\n                    // bit 1:   surface condition:      true if distance to surface is small < error threshold\n};                  // bit 2:   iteration condition:    true if took too many iterations\n\nstruct MaterialTraceResult\n{\n    float T;\t\t// Distance taken on ray\n    int flags;\t\t// bit 0:   distance condition:     true if travelled to far t > t_max\n    int materialID;  // bit 1:   surface condition:      true if distance to surface is small < error threshold\n};                  // bit 2:   iteration condition:    true if took too many iterations\n\nstruct SphereTraceDesc\n{\n    float epsilon;  //Stopping distance to surface\n    int maxiters;   //Maximum iteration count\n};\n\nTraceResult sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0);\n    float d;\n    \n    int i = 0; do\n    {\n        d = sdf(ray.P+ret.T*ray.V);\n        ret.T+=d;\n        ++i;\n    } while (\n\t\tret.T < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td\t  > params.epsilon * ret.T &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\nMaterialTraceResult material_sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    MaterialTraceResult ret = MaterialTraceResult(ray.Tmin, 0, 0);\n    Value d;\n    \n    int i = 0; do\n    {\n        /*Value d1 = materialSdf(ray.P+ret.T*ray.V);\n        Value d2 = materialSdf2(ray.P+ret.T*ray.V);\n        if(d1.sdf<d2.sdf) d=d1; else d=d2;*/\n        d = materialSdf(ray.P+ret.T*ray.V, iTime);\n        ret.T+=d.sdf;\n        ret.materialID=d.id;\n        ++i;\n    } while (\n\t\tret.T < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td.sdf\t  > params.epsilon * ret.T &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d.sdf <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\n// ---- SHADING ---- (todo!)\n\nvec3 normal(const in vec3 p)\n{\n    const float eps=0.001;\n    vec3 plus = vec3(sdf(p+vec3(eps,0,0)),sdf(p+vec3(0,eps,0)),sdf(p+vec3(0,0,eps)));\n    vec3 minu = vec3(sdf(p-vec3(eps,0,0)),sdf(p-vec3(0,eps,0)),sdf(p-vec3(0,0,eps)));\n    return normalize(plus-minu);\n}\n\nvec3 materialNormal(const in vec3 p)\n{\n    const float eps=0.001;\n    Value p1 = materialSdf(p+vec3(eps,0,0),iTime);\n    Value p2 = materialSdf(p+vec3(0,eps,0),iTime);\n    Value p3 = materialSdf(p+vec3(0,0,eps),iTime);\n    Value m1 = materialSdf(p-vec3(eps,0,0),iTime);\n    Value m2 = materialSdf(p-vec3(0,eps,0),iTime);\n    Value m3 = materialSdf(p-vec3(0,0,eps),iTime);\n    \n    vec3 plus = vec3(p1.sdf,p2.sdf,p3.sdf);\n    vec3 minu = vec3(m1.sdf,m2.sdf,m3.sdf);\n    return normalize(plus-minu);\n}\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.V).xyz,1.);\n}\nvec4 errorColor(Ray ray, float t)\n{\n    return vec4(1.,0.,0.,1.);\n}\nvec4 hitColor(Ray ray,float t, int materialId)\n{\n    float animationStep = -0.2+0.5*sin(iTime*1.0);\n    vec3 p = ray.P + ray.V*t;\n    //vec3 n = normal(p);\n    vec3 n = materialNormal(p);\n    \n    vec3 lightPos=vec3(15.+animationStep,15.,15.);\n    vec3 lightPos2=vec3(-5.,15.,-35.);\n    vec3 lightPos3=vec3(-30.,30.,30.);\n    \n    vec3 v = -ray.V;\n    vec3 l = normalize(lightPos-p);\n    vec3 l2 = normalize(lightPos2-p);\n    vec3 l3 = normalize(lightPos3-p);\n    \n    //diffuse\n    float costheta = max(dot(n,l),0.);\n    float costheta2 = max(dot(n,l2),0.);\n    float costheta3 = max(dot(n,l3),0.);\n    vec3 k_d = vec3(0.5/pi);\n    \n    //specular\n    vec3 toLight = normalize(lightPos - p);\n    vec3 toLight2 = normalize(lightPos2-p);\n    vec3 toLight3 = normalize(lightPos3-p);\n    vec3 toEye = -ray.V;\n    vec3 k_s = vec3(0.4);\n    \n    vec3 h = normalize(toLight+toEye);\n    vec3 h2 = normalize(toLight2+toEye);\n    vec3 h3 = normalize(toLight3+toEye);\n    float si = pow(clamp(dot(h,n),0.,1.),100.);\n    float si2 = pow(clamp(dot(h2,n),0.,1.),100.);\n    float si3 = pow(clamp(dot(h3,n),0.,1.),100.);\n    \n    //sum\n    vec3 col = (k_d + si*k_s)*costheta;\n    vec3 col2 = (k_d + si2*k_s)*costheta2;\n    vec3 col3 = (k_d + si3*k_s)*costheta3;\n    \n    //return vec4(materials[materialId].color,1.);\n    return vec4(materials[materialId].color +(col+col2+col3),1.);\n    //return vec4(col+col2+col3,1.);\n}\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(-4.5,0.1,1.5);\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Generate ray from pixel\n    vec3 eye; vec2 data; // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data);\n    \n    // Set epsilon and maximum iteration\n    SphereTraceDesc params = SphereTraceDesc(0.006, 102);\n    \n    // Raytrace\n    //TraceResult result = sphere_trace(ray, params);\n    MaterialTraceResult result = material_sphere_trace(ray, params);\n    \n    /* //Debug\n\tfragColor=vec4(0.,0.,0.,1.); //debug\n    if(bool(result.flags & 1)) fragColor.r=1.;\n    if(bool(result.flags & 2)) fragColor.g=1.;\n    if(bool(result.flags & 4)) fragColor.b=1.;\n    */\n    \n    if(bool(result.flags & 1))    fragColor = missColor(ray);    \n    else if(bool(result.flags&2)) fragColor = hitColor(ray, result.T, result.materialID);\n    else \t        \t\t\t  fragColor = errorColor(ray, result.T);\n\n    //vec3 prevcol = texelFetch(iChannel0,ivec2(fragCoord),0).rgb;\n    //float lambda = 0.3;\n    //fragColor.rgb = (1.-lambda)*fragColor.rgb + lambda*prevcol;\n\n    fragColor.w = result.T;\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//struct source: First assignment\n\nstruct Material {\n    vec3 color;      // [0, 1/pi]\n    float roughness; // [0,~7]\n    vec3 emission;   // [0, inf]\n    float metalness; // 0.02-0.05 for non-metals, 0.6-0.9 for metals\n};\n\nconst Material wood      = Material(vec3(91./255.,58./255.,41./255.),5.,vec3(1.,1.,1.),.02);\nconst Material stone     = Material(vec3(25./255.,250./255.,250./255.),7.,vec3(1.,1.,1.),.02);\nconst Material copper    = Material(vec3(184./255.,115./255.,51./255.),2.,vec3(1.,1.,1.),.8);\nconst Material aluminium = Material(vec3(132./510.,135./510.,137./510.),1.,vec3(1.,1.,1.),.9);\nconst Material paper     = Material(vec3(224./765., 201./765., 166./765.),3.,vec3(1.,1.,1.),.02);\nconst Material plastic   = Material(vec3(216./765.,191./765.,216./765.),1.,vec3(1.,1.,1.),.02);\n\nconst Material materials[6] = Material[](wood,stone,copper,aluminium,paper,plastic);\n\nstruct Value{\n    float sdf;\n    int id;\n};\n\n//Source: https://www.shadertoy.com/view/sdcSRM\n\n//This file contains the code for the scene\n\nconst float pi = 3.1415926535897932384626433832795;\n\n//\tPRIMITIVES are from\n//\thttps://iquilezles.org/articles/distfunctions\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nValue materialSdPlane( vec3 p, float move, int materialId)\n{\n    return Value(p.y+move,materialId);\n}\n\nValue materialSdSphere( vec3 p, float s, int materialId )\n{\n\treturn Value(length(p)-s,materialId);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nValue materialSdBox( vec3 p, vec3 b ,int materialId)\n{\n\tvec3 d = abs(p) - b;\n\treturn Value(length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0),materialId); // remove this line for an only partially signed sdf \n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nValue materialSdRoundedCylinder( vec3 p, float ra, float rb, float h, int materialId)\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return Value(min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb,materialId);\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nValue materialSdBoxFrame( vec3 p, vec3 b, float e, int materialId)\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return Value(min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0)),materialId);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nValue materialSdTorus( vec3 p, vec2 t, int materialId)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return Value(length(q)-t.y, materialId);\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nValue materialSdOctahedron( vec3 p, float s, int materialId)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return Value(m*0.57735027, materialId);\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return Value(length(vec3(q.x,q.y-s+k,q.z-k)),materialId); \n}\n\n///SDF\n\nfloat Unite(in float sdf1, in float sdf2){\n    return min(sdf1,sdf2);\n}\n\nValue Unite(in Value sdf1, in Value sdf2){\n    if(min(sdf1.sdf,sdf2.sdf) == sdf1.sdf) return sdf1;\n    else return sdf2;\n}\n\nValue Unite(in Value sdf1, float sdf2, in int id){\n    return Unite(sdf1, Value(sdf2,id));\n}\n\nValue Unite(in float sdf, in Value sdf2, in int id){\n    return Unite(sdf2, Value(sdf,id));\n}\n\nfloat Intersection(in float sdf1, in float sdf2){\n    return max(sdf1,sdf2);\n}\n\nValue Intersection(in Value sdf1, in Value sdf2){\n    if(max(sdf1.sdf,sdf2.sdf) == sdf1.sdf) return sdf1;\n    else return sdf2;\n}\n\nValue Intersection(in Value sdf1, float sdf2, in int id){\n    return Intersection(sdf1, Value(sdf2,id));\n}\n\nValue Intersection(in float sdf, in Value sdf2, in int id){\n    return Unite(sdf2, Value(sdf,id));\n}\n\nValue materialSdf(in vec3 p, float time)\n{\n    p-=vec3(0,0,2);\n    float animationStep = -0.2+0.5*sin(time*1.0);\n    Value pyramid = materialSdOctahedron(p-vec3(0,5,0), 5., 4);\n    Value hole   = Intersection(pyramid,materialSdSphere(p-vec3(0,5,0),3.,2));\n    Value f = Unite(hole,materialSdSphere(p-vec3(2.9,-.7,2.7), .1,0));\n    for(float i = 0.1; i < 5.5 ; i+=.8)\n\t{\n    \tfor(float j = 0.1; j < 5.5; j+=.8)\n    \t{\n            Value f1 = materialSdSphere(p-vec3(2.9+animationStep/(i+j),-.7+j,2.7-i), .1,0);\n        \thole = Unite(hole,f1);\n    \t}\n\t}    \n    Value g = Unite(hole,materialSdBox(p-vec3(0,-.5,0),vec3(1.2,0.2,1.2),5));\n    Value UFOBase = Unite(g,materialSdRoundedCylinder(p+vec3(0,-.3+animationStep,0),0.2,0.2,0.05,1));\n    Value boxFrame = Unite(UFOBase,materialSdBoxFrame(p+vec3(0,-2,0),vec3(3,3,3),.1, 4));\n    Value ring = Unite(boxFrame,materialSdTorus(p+vec3(0,-.3+animationStep,0), vec2(0.7,0.1),3));    \n    return Unite(ring,materialSdPlane(p,1.,5));\n}\n\nValue materialSdf2(in vec3 p)\n{\n    p-=vec3(0,0,2);\n    return materialSdOctahedron(p-vec3(5,5,0), 5., 1);\n}\n\nfloat sdf(in vec3 p)\n{\n    p-=vec3(0,0,2);\n    float animationStep = -0.2+0.5*sin(1.0*1.0);//iTime replaced with 1.0\n    float pyramid = sdOctahedron(p-vec3(0,5,0), 5.);\n    float hole   = max(pyramid,sdSphere(p-vec3(0,5,0),3.));\n    float f = min(hole,sdSphere(p-vec3(2.9,-.7,2.7), .1));\n    for(float i = 0.1; i < 5.5 ; i+=.8)\n\t{\n    \tfor(float j = 0.1; j < 5.5; j+=.8)\n    \t{\n            float f1 = sdSphere(p-vec3(2.9+animationStep/(i+j),-.7+j,2.7-i), .1);\n        \thole = min(hole,f1);\n    \t}\n\t}    \n    float g = min(hole,sdBox(p-vec3(0,-.5,0),vec3(1.2,0.2,1.2)));\n    float UFOBase = min(g,sdRoundedCylinder(p+vec3(0,-.3+animationStep,0),0.2,0.2,0.05));\n    float boxFrame = min(UFOBase,sdBoxFrame(p+vec3(0,-2,0),vec3(3,3,3),.1));\n    float ring = min(boxFrame,sdTorus(p+vec3(0,-.3+animationStep,0), vec2(0.7,0.1)));    \n    return min(ring,p.y+1.);\n}\n","name":"Common","description":"","type":"common"}]}