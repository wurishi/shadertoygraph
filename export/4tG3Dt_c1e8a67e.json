{"ver":"0.1","info":{"id":"4tG3Dt","date":"1477346354","viewed":156,"name":"Cloud Animation + Lighting","username":"laluneverte","description":"test","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["cloud","fractor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nHere is how to load the texture needed for this shader:\n - Open the javascript console of your browser:\n\t\t\t\t   Mac      /     Windows\n\tChrome:  cmd + opt + J  /  ctrl + shift J\n\tFirefox: cmd + opt + K  /  ctrl + shift K\n    IE:          na         /  F12   \n\n- Then copy the following lines in the console to load custom 2048x2048 textures:\n\ngShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/4rucyzjd1bnb6eu/b3CloudTexture.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'linear', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\nYou can use the mouse to drag around the light (while pressing the left mouse button).\n\n*/\n\nvoid getSingleTextureCoord(in vec2 uv, in vec2 res, in float tile, out vec2 result)\n{\n  float s = tile / (res.x * res.y);\n  float t = (s - floor(s)) * res.x * res.y;\n  float y = floor(t / res.x);\n  float x = floor(abs(t - res.x * y));\n  result = uv / res + vec2(x, y) / res;\n}\n\nvoid getTextureAnimCoords(in float time, in vec2 res, in vec2 uv, out vec2 uv0, out vec2 uv1, out float fraction)\n{\n    float tile = floor(time);\n    fraction = time - tile;\n    getSingleTextureCoord(uv, res, tile, uv0);\n    getSingleTextureCoord(uv, res, tile + 1., uv1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float time = iTime * 0.4 + texture(iChannel1, uv).r * 1.0;\n    //float time = 2.0 + texture(iChannel1, uv).r * 4.0;\n\n    // number of tiles\n    vec2 res = vec2(4.0, 4.0);\n    \n    vec2 uv0, uv1;\n    float fraction;\n    getTextureAnimCoords(time, res, uv, uv0, uv1, fraction);\n    \n\tfragColor = mix(texture(iChannel0, uv0), texture(iChannel0, uv1), clamp(fraction, 0.0, 1.0)) * texture(iChannel2, uv);\n\t//fragColor = mix(texture(iChannel0, uv0), vec4(1.0, 0.0, 0.0, 1.0), clamp(fraction, 0.0, 1.0));// * texture(iChannel2, uv);\n\t//fragColor = texture(iChannel0, uv);\n\t//fragColor = texture(iChannel1, uv);\n\t//fragColor = texture(iChannel2, uv);\n\t//fragColor = mix(vec4(uv0, 0.0, 1.0), vec4(uv1, 0.0, 1.0), fraction);\n\t//fragColor = vec4(fraction);\n\t//fragColor = vec4(uv0, 0.0, 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float random(float x) \n{ \n    return fract(sin(x) * 10000.);          \n}\n\nfloat noise(vec2 p) \n{\n    return random(p.x + p.y * 10000.);            \n}\n\nvec2 sw(vec2 p) { return vec2(floor(p.x), floor(p.y)); }\nvec2 se(vec2 p) { return vec2(ceil(p.x), floor(p.y)); }\nvec2 nw(vec2 p) { return vec2(floor(p.x), ceil(p.y)); }\nvec2 ne(vec2 p) { return vec2(ceil(p.x), ceil(p.y)); }\n\nfloat smoothNoise(vec2 p) \n{\n    vec2 interp = smoothstep(0., 1., fract(p));\n    float s = mix(noise(sw(p)), noise(se(p)), interp.x);\n    float n = mix(noise(nw(p)), noise(ne(p)), interp.x);\n    return mix(s, n, interp.y);        \n}\n\nfloat fractalNoise(vec2 p) \n{\n    float x = 0.;\n    x += smoothNoise(p      );\n    x += smoothNoise(p * 2. ) / 2.;\n    x += smoothNoise(p * 4. ) / 4.;\n    x += smoothNoise(p * 8. ) / 8.;\n    x += smoothNoise(p * 16.) / 16.;\n    x /= 1. + 1./2. + 1./4. + 1./8. + 1./16.;\n    return x;            \n}\n\nfloat movingNoise(vec2 p, float speed) \n{ \n    float x = fractalNoise(p + iTime * speed);\n    float y = fractalNoise(p + vec2(45.,17.) - iTime * speed * 0.71);\n    return fractalNoise(vec2(x, y) + p * 0.4);    \n}\n\nfloat nestedNoise(vec2 p, float speed) \n{    \n    float x = movingNoise(p, speed);\n    float y = movingNoise(p + 100., speed);\n    return movingNoise(p + vec2(x, y), speed);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(nestedNoise(uv * 3., 0.25));\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"float random(float x) \n{ \n    return fract(sin(x) * 10000.);          \n}\n\nfloat noise(vec2 p) \n{\n    return random(p.x + p.y * 10000.);            \n}\n\nvec2 sw(vec2 p) { return vec2(floor(p.x), floor(p.y)); }\nvec2 se(vec2 p) { return vec2(ceil(p.x), floor(p.y)); }\nvec2 nw(vec2 p) { return vec2(floor(p.x), ceil(p.y)); }\nvec2 ne(vec2 p) { return vec2(ceil(p.x), ceil(p.y)); }\n\nfloat smoothNoise(vec2 p) \n{\n    vec2 interp = smoothstep(0., 1., fract(p));\n    float s = mix(noise(sw(p)), noise(se(p)), interp.x);\n    float n = mix(noise(nw(p)), noise(ne(p)), interp.x);\n    return mix(s, n, interp.y);        \n}\n\nfloat fractalNoise(vec2 p) \n{\n    float x = 0.;\n    x += smoothNoise(p      );\n    x += smoothNoise(p * 2. ) / 2.;\n    x += smoothNoise(p * 4. ) / 4.;\n    x += smoothNoise(p * 8. ) / 8.;\n    x += smoothNoise(p * 16.) / 16.;\n    x /= 1. + 1./2. + 1./4. + 1./8. + 1./16.;\n    return x;            \n}\n\nfloat movingNoise(vec2 p, float speed) \n{ \n    float x = fractalNoise(p + iTime * speed);\n    float y = fractalNoise(p - iTime * speed);\n    return fractalNoise(p + vec2(x, y));    \n}\n\nfloat nestedNoise(vec2 p, float speed) \n{    \n    float x = movingNoise(p, speed);\n    float y = movingNoise(p + 100., speed);\n    return movingNoise(vec2(x, y), speed);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n    float f = clamp(0.5 + (1.42 - length(uv - m)) * 0.6, 0.0, 1.0);\n    f  = f * mix(1.0, nestedNoise(uv * 3., 0.15), 0.8);\n\tfragColor = vec4(f);\n}","name":"Buf C","description":"","type":"buffer"}]}