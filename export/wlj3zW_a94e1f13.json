{"ver":"0.1","info":{"id":"wlj3zW","date":"1558715166","viewed":195,"name":"basic_raytracer_2","username":"lqt0223","description":"the phase 2 of raytracer, with additional features such as ray marching, ssao and soft shadow. The noise is due to unoptimized ssao.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","ssao","softshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float epsilon = 1e-4;\n\nstruct Hit {\n    bool miss;\n    vec3 position;\n    float dist;\n    vec3 normal;\n    vec3 color;\n};\n\nstruct PointLight {\n    vec3 position;\n    float intensity;\n};\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    vec3 color;\n};\n\nstruct YPlane {\n    float y;\n    float x1;\n    float x2;\n    float z1;\n    float z2;\n    vec3 color;\n};\n\nconst Hit miss = Hit(true, vec3(0.), 1000., vec3(0.), vec3(0.));\n\nvec2 rotate2d(vec2 st, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    mat2 t = mat2(c,-s,s,c);\n    return t*st;\n}\n\nHit sdf_sphere(vec3 p, Sphere sphere) {\n    float d = length(p - sphere.center) - sphere.radius;\n    return Hit(false, p, d, normalize(p - sphere.center), sphere.color);\n}\n\nbool inBound(vec2 p, float x1, float x2, float y1, float y2) {\n    return p.x > x1 && p.x < x2 && p.y > y1 && p.y < y2;\n}\n\nbool inStripX(vec2 p, float x1, float x2) {\n    return p.x > x1 && p.x < x2;\n}\n\nbool inStripZ(vec2 p, float z1, float z2) {\n    return p.y > z1 && p.y < z2;\n}\n\nHit sdf_yplane(vec3 p, YPlane plane) {\n    float d;\n    vec3 hp = p;\n    hp.y = plane.y;\n    if (inBound(p.xz, plane.x1, plane.x2, plane.z1, plane.z2)) {\n        d = abs(p.y - plane.y);\n    } else if (inStripX(p.xz, plane.x1, plane.x2)) {\n        float l1 = length(p.yz - vec2(plane.y, plane.z1));\n        float l2 = length(p.yz - vec2(plane.y, plane.z2));\n        d = min(l1, l2);\n        hp.z = l1 < l2 ? plane.z1 : plane.z2;\n    } else if (inStripZ(p.xz, plane.z1, plane.z2)) {\n        float l1 = length(p.xy - vec2(plane.x1, plane.y));\n        float l2 = length(p.xy - vec2(plane.x2, plane.y));\n        d = min(l1, l2);\n        hp.x = l1 < l2 ? plane.x1 : plane.x2;\n    } else {\n        d = 1000.;\n        float l1 = length(p- vec3(plane.x1, plane.y, plane.z1));\n        if (l1 < d) {\n            hp.x = plane.x1;\n            hp.z = plane.z1;\n            d = l1;\n        }\n        float l2 = length(p- vec3(plane.x2, plane.y, plane.z1));\n        if (l2 < d) {\n            hp.x = plane.x2;\n            hp.z = plane.z1;\n            d = l2;\n        }\n        float l3 = length(p- vec3(plane.x1, plane.y, plane.z2));\n        if (l3 < d) {\n            hp.x = plane.x1;\n            hp.z = plane.z2;\n            d = l3;\n        }\n        float l4 = length(p- vec3(plane.x2, plane.y, plane.z2));\n        if (l4 < d) {\n            hp.x = plane.x2;\n            hp.z = plane.z2;\n            d = l4;\n        }\n    }\n    return Hit(false, hp, d, vec3(0.,1.,0.), plane.color);\n}\n\nHit sdf_scene(vec3 p) {\n    Sphere isphere1 = Sphere(vec3(0.,0.,.0), .4, vec3(1.));\n    Sphere isphere2 = Sphere(vec3(.4,-.2,.4), .2, vec3(1.));\n    Sphere sphere1 = isphere1;\n    Sphere sphere2 = isphere2;\n    sphere2.center.xz = rotate2d(isphere2.center.xz, iTime);\n    YPlane yplane = YPlane(-.4, -1.2,1.2,-1.2,1.2, vec3(1.));\n\n    Hit result = miss;\n\n    Hit sphere1Hit = sdf_sphere(p, sphere1);\n    if (sphere1Hit.dist < result.dist) {\n        result = sphere1Hit;\n    }\n    Hit sphere2Hit = sdf_sphere(p, sphere2);\n    if (sphere2Hit.dist < result.dist) {\n        result = sphere2Hit;\n    }\n    Hit yplaneHit = sdf_yplane(p, yplane);\n    if (yplaneHit.dist < result.dist) {\n        result = yplaneHit;\n    }\n    return result;\n}\n\nHit ray_march_scene(vec3 ro, vec3 rd) {\n    float depth = 0.;\n    Hit hitResult = miss;\n    for (int i = 0; i < 200; i++) {\n        Hit hit = sdf_scene(ro + depth * rd);\n        if (hit.dist < epsilon) {\n            hitResult = hit;\n            return hitResult;\n        }\n        depth += hit.dist;\n        if (depth >= 100.) {\n            return miss;\n        }\n    }\n    return miss;\n}\n\nconst float k = 8.;\n\nfloat softshadow(vec3 ro ,vec3 rd) {\n    float res = 1.0;\n    float t = 0.1;\n    for (int i = 0;i < 200;i++) {\n        float h = sdf_scene(ro + t * rd).dist;\n        if (h < epsilon) {\n            return 0.0;\n        }\n        res = min(res, k*((h)/t));\n        t += h;\n        if (t >= 100.) {\n            return res;\n        }\n    }\n    return res;\n}\n\nvec3 random3d(vec3 p){\n    p = vec3(\n        dot(p,vec3(127.1,311.7, 456.1)),\n        dot(p,vec3(269.5,183.3, 823.2)),\n        dot(p,vec3(329.5,83.3, 513.2))\n    );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat ssao(Hit p) {\n    p.position += 2. * epsilon * p.normal;\n    float result = 0.;\n    for (int i = -1; i <= 0; i++) {\n        for (int j = -1; j <= 0; j++) {\n            for (int k = -1; k <= 0; k++) {\n                vec3 disp = p.position + vec3(float(i), float(j), float(k));\n                vec3 rv = random3d(disp);\n                rv = normalize(rv);\n                disp = p.position + .1*rv;\n                Hit h = sdf_scene(disp);\n                if (h.dist < 0.0125) {\n                    result += 0.02;\n                }\n            }\n        }\n    }\n    return result;\n}\n\nconst PointLight light = PointLight(vec3(5.), .8);\nconst vec3 ambient_c = vec3(.5);\n\nvec3 calcColor(Hit h, PointLight light, vec3 camera) {\n    vec3 light_pos = normalize(light.position - h.position);\n    vec3 camera_pos = normalize(camera - h.position);\n\n    vec3 ambient = ambient_c * h.color;\n\n    float diff = clamp(dot(light_pos, h.normal), 0.,1.);\n    vec3 diffuse = diff * h.color;\n\n    vec3 refl = reflect(-light_pos, h.normal);\n    float spec = pow(max(dot(refl, camera_pos), .0), 64.);\n    vec3 specular = spec * h.color;\n\n    vec3 color = ambient + .1*diffuse + specular;\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 st = vec3(gl_FragCoord.xy / iResolution.xy, 0.);\n    st = st * 2.-1.;\n    st.z = 0.;\n    st.x*=iResolution.x/iResolution.y;\n    st.xz = rotate2d(st.xz, iTime*.15);\n\n    vec3 camera = vec3(0,0,-2.);\n    camera.xz = rotate2d(camera.xz, iTime*.15);\n    vec3 ray = st-camera;\n    ray = normalize(ray);\n\n    Hit sceneHit = ray_march_scene(camera, ray);\n    vec3 light_pos = normalize(light.position - sceneHit.position);\n    vec3 hitColor = calcColor(sceneHit, light, camera);\n    // remember when ray tracing again from hit point, the start point needs to be biased\n    if (!sceneHit.miss) {\n        vec3 reflLight = reflect(ray, sceneHit.normal);\n        Hit reflectHit = ray_march_scene(sceneHit.position + 2.*epsilon * sceneHit.normal, reflLight);\n        vec3 reflColor = calcColor(reflectHit, light, camera);\n        hitColor += .1 * reflColor;\n\n        float shadow = softshadow(sceneHit.position - 2.*epsilon*sceneHit.normal, light_pos);\n        shadow = shadow - 1.;\n        shadow = shadow / 8.;\n        hitColor += shadow;\n\n        float ao = ssao(sceneHit);\n        hitColor -= ao;\n        fragColor = vec4(hitColor,1.);\n    } else {\n        fragColor = vec4(vec3(.4),1.);\n    }\n}\n","name":"Image","description":"","type":"image"}]}