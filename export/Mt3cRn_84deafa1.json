{"ver":"0.1","info":{"id":"Mt3cRn","date":"1531329386","viewed":191,"name":"Particules 3D","username":"FlorianDuf","description":"Particules 3D simulator\n\nThis system needs improvement.\nIt will do in the next shader :)","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["3d","particules"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Light {\n    vec3 pos;\n    float energy;\n};\n    \nSphere tabS[SPHERES];\n\nfloat hash(in float seed)\n{\n    return fract(564435.54436 * sin(seed));\n}\n\nvoid initSpheres() {\n    \n    \n    float fact = 1.0/(2.0*float(SPHERES));\n    \n    for ( int i = 0; i< SPHERES; ++i )\n    {\n        \n        vec3 pos = texture(iChannel1, vec2(float(i) * 2.0* fact,0.0)).xyz;\n    \ttabS[i] = Sphere(pos, SPHERE_SIZE);   \n    }\n    \n    \n}\n\nbool spheres(out vec3 col, out float tmin)\n{\n    \n    float t_values[SPHERES];\n    vec3 normals[SPHERES];\n    bool inter_values[SPHERES];\n    \n    tmin = 1000000.0;\n    int j = 0;\n    \n    for ( int i = 0; i< SPHERES; ++i )\n    {\n        inter_values[i] = intersect(tabS[i], normals[i], t_values[i]);\n        if (t_values[i] < tmin && inter_values[i])\n        {\n            tmin = t_values[i];\n        \tj = i;\n        }\n    }\n    \n  \n    if ( inter_values[j] )\n    {\n        col = texture(iChannel0, reflect(cam.rd, normals[j])).rgb;\n    \treturn true;\n\t}\n    \n    return false;\n    \n}\n\nstruct Segment {\n\tvec3 p1;\n    vec3 p2;\n    \n};\n    \nfloat distanceLine(in vec3 ro, in vec3 rd, in vec3 p)\n{\n    \n    return length(cross(p-ro, rd)) / length(rd);\n}\n\nfloat distLineToRay(in Segment s)\n{\n   \n    vec3 center = (s.p1+s.p2)/2.0;\n    \n    float distC = distanceLine(cam.ro, cam.rd, center);\n    \n    if ( distC > length((s.p1+s.p2)/2.0) )\n        return 100000.0;\n    \n    vec3 AB = s.p1 - cam.ro;\n    \n    float produitMixte = abs(dot(cross(AB, s.p1-s.p2), cam.rd));\n    \n    return produitMixte / length(cross(s.p1-s.p2, cam.rd));\n}\n\n\n// ray-box intersection\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-cen);\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\n\treturn vec2( tN, tF );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n\tcam = Camera(vec3(0.0,2.0,-100.0), vec3(0.0), CAM_ZOOM);\n    \n    float a=iTime*0.2725;\n#ifdef ALLOW_ROTATION\n    cam.ro = rotateY(cam.ro, a);\n    //cam.ro = rotateY(cam.ro, 1.57);\n#endif    \n    target(vec3(0.0), uv);\n    \n    \n    \n    initSpheres();\n    vec3 col = texture(iChannel0, cam.rd).rgb;\n    \n    vec3 col_tmp;\n    \n    float tmin;\n    if ( spheres(col_tmp,tmin))\n        col = col_tmp;\n    \n#ifdef DOMAINE_DISPLAY\n// raytrace bounding box\n        vec3 bcen = 0.5*(domaine.p1+domaine.p2);\n        vec3 brad = 0.5*(domaine.p2-domaine.p1);\n        vec2 tbox = iBox( cam.ro, cam.rd, bcen, brad );\n        if( tbox.x>0.0 )\n        {\n            // back face\n            if( tbox.y < tmin )\n            {\n                vec3 pos = cam.ro + cam.rd*tbox.y;\n                vec3 e = smoothstep( brad-0.9, brad-0.8, abs(pos-bcen) );\n                float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n                col = mix( col, vec3(0.0), 0.25 + 0.75*al );\n            }\n            // front face\n            if( tbox.x < tmin )\n            {\n                vec3 pos = cam.ro + cam.rd*tbox.x;\n                vec3 e = smoothstep( brad-0.9, brad-0.8, abs(pos-bcen) );\n                float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n                col = mix( col, vec3(0.0), 0.15 + 0.85*al );\n            }\n        }\n    \n    \n    \n    // Domaine \n/*\n    Sphere b1 = Sphere(domaine.p1, 1.0);\n    Sphere b2 = Sphere(vec3(domaine.p2.x, domaine.p1.y, domaine.p1.z), 1.0);\n    Sphere b3 = Sphere(vec3(domaine.p1.x, domaine.p2.y, domaine.p1.z), 1.0);\n    Sphere b4 = Sphere(vec3(domaine.p1.x, domaine.p1.y, domaine.p2.z), 1.0);\n    Sphere b5 = Sphere(vec3(domaine.p2.x, domaine.p1.y, domaine.p2.z), 1.0);\n    Sphere b6 = Sphere(vec3(domaine.p2.x, domaine.p2.y, domaine.p1.z), 1.0);\n    Sphere b7 = Sphere(vec3(domaine.p1.x, domaine.p2.y, domaine.p2.z), 1.0);\n    \n    Sphere b8 = Sphere(domaine.p2, 1.0);\n    \n    \n    float t;\n    vec3 n;\n    if ( intersect(b1, n, t) )\n    \tcol = vec3(1.0);\n    if ( intersect(b2, n, t) )\n    \tcol = vec3(1.0);\n    if ( intersect(b3, n, t) )\n    \tcol = vec3(1.0);\n    if ( intersect(b4, n, t) )\n    \tcol = vec3(1.0);\n    if ( intersect(b5, n, t) )\n    \tcol = vec3(1.0);\n    if ( intersect(b6, n, t) )\n    \tcol = vec3(1.0);\n    if ( intersect(b7, n, t) )\n    \tcol = vec3(1.0);\n    \n    if ( intersect(b8, n, t) )\n    \tcol = vec3(1.0);\n\n    float size = 0.3;\n    Segment s1 = Segment(b1.c, b2.c);\n    if ( distLineToRay(s1) < size )\n        col = vec3(1.0);\n    Segment s2 = Segment(b1.c, b3.c);\n    if ( distLineToRay(s2) < size )\n        col = vec3(1.0);\n    Segment s3 = Segment(b1.c, b4.c);\n    if ( distLineToRay(s3) < size )\n        col = vec3(1.0);\n    Segment s4 = Segment(b2.c, b5.c);\n    if ( distLineToRay(s4) < size )\n        col = vec3(1.0);\n    Segment s5 = Segment(b2.c, b6.c);\n    if ( distLineToRay(s5) < size )\n        col = vec3(1.0);\n    Segment s6 = Segment(b3.c, b6.c);\n    if ( distLineToRay(s6) < size )\n        col = vec3(1.0);\n    Segment s7 = Segment(b3.c, b7.c);\n    if ( distLineToRay(s7) < size )\n        col = vec3(1.0);\n    Segment s8 = Segment(b4.c, b7.c);\n    if ( distLineToRay(s8) < size )\n        col = vec3(1.0);\n    Segment s9 = Segment(b4.c, b5.c);\n    if ( distLineToRay(s9) < size )\n        col = vec3(1.0);\n    Segment s10 = Segment(b8.c, b5.c);\n    if ( distLineToRay(s10) < size )\n        col = vec3(1.0);\n    Segment s11 = Segment(b8.c, b7.c);\n    if ( distLineToRay(s11) < size )\n        col = vec3(1.0);\n    Segment s12 = Segment(b8.c, b6.c);\n    if ( distLineToRay(s12) < size )\n        col = vec3(1.0);*/\n#endif  \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define SPHERES 18\n#define SPEED 1.0\n#define DOMAINE 25.0\n#define DOMAINE_DISPLAY\n#define CAM_ZOOM 1.0\n#define SPHERE_SIZE 1.0\n#define ALLOW_ROTATION\n\n// Camera\n\nstruct Camera {\n\tvec3 ro;\n    vec3 rd;\n    \n    float zoom;\n};\n\nCamera cam = Camera(vec3(0.0,0.0,-3.0), vec3(0.0), 1.0); //init\n\nvoid target(in vec3 lookat, in vec2 uv)\n{\n\tvec3 front = normalize(lookat - cam.ro);\n    vec3 right = cross(vec3(0.0,1.0,0.0), front);\n    vec3 up = cross(front, right);\n    \n    vec3 c = cam.ro + front* cam.zoom;\n    \n    vec3 i = c + uv.x*right + uv.y*up;\n    \n    cam.rd = i - cam.ro;\n}\n\n// Sphere \n\nstruct Sphere {\n\tvec3 c;\n    float r;\n};\n   \n    \n// Particules\n    \nstruct Particule {\n    vec3 pos;\n    vec3 dir;\n};\n    \nstruct Box {\n\tvec3 p1;\n    vec3 p2;\n};\n \nBox domaine = Box(vec3(-DOMAINE), vec3(DOMAINE));\n    \n// with help of Julien Alamelle\nbool intersect(in Sphere s, out vec3 n, out float t)\n{\n\n    vec3 m = cam.ro - s.c;\n    float a = dot(cam.rd, cam.rd);\n    float b = 2.0 * dot(cam.rd, m);\n    \n    float c = dot( m,m) - s.r*s.r;\n    \n    float discr = b*b-4.0*a*c;\n    \n    if ( discr < 0.0) return false;\n\n    t= 0.0;\n    \n    t = -b - sqrt(discr);\n    t /= 2.0 * a;\n    \n    if ( t < 0.0 ) return false;\n    \n    n = (m + t * cam.rd );\n    \n    return true;\n    \n   \n}\n\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat signRandom(in float seed)\n{\n    float randNum = sin(hash(seed*120.565454)*10.0);\n    if (randNum == 0.0)\n        randNum == 1.0;\n    return randNum / abs(randNum);\n}\n\nvec3 dirRandom(in float seed, in float dist)\n{\n\tfloat x = signRandom(seed*0.114245) * hash(seed*0.114245);\n    float y = signRandom(seed* 0.252424) * hash(seed* 0.252424);\n    float z = signRandom(seed* 0.52424) * hash(seed* 0.982424);\n    \n    return normalize(vec3(x,y,z)) * dist;\n}\n\nbool bounding(in vec3 pos, in vec3 oldDir, out vec3 newdir)\n{\n \n    bool ret = true;\n    \n    \n    if ( pos.x <= domaine.p1.x && oldDir.x < 0.0)\n    {\n        newdir = reflect(oldDir, vec3(1.0,0.0,0.0));\n    \tret = false;   \n    }\n    if ( pos.x >= domaine.p2.x  && oldDir.x > 0.0)\n    {\n        newdir = reflect(oldDir, vec3(-1.0,0.0,0.0));\n    \tret = false; \n    }\n    if ( pos.y <= domaine.p1.y && oldDir.y < 0.0)\n    {\n        newdir = reflect(oldDir, vec3(0.0,1.0,0.0));\n    \tret = false;   \n    }\n    if ( pos.y >= domaine.p2.y && oldDir.y > 0.0)\n    {\n        newdir = reflect(oldDir, vec3(0.0,-1.0,0.0));\n    \tret = false;  \n    }\n    if ( pos.z <= domaine.p1.z && oldDir.z < 0.0)\n    {\n        newdir = reflect(oldDir, vec3(0.0,0.0,1.0));\n    \tret = false;   \n    }\n    if ( pos.z >= domaine.p2.z && oldDir.z > 0.0)\n    {\n        newdir = reflect(oldDir, vec3(0.0,0.0,-1.0));\n    \tret = false;   \n    }\n        \n    return ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    float fact = 1.0/(2.0*float(SPHERES));\n    \n    float i =  uv.x*(2.0*float(SPHERES));\n    \n    \n    if (i >= floor(i) -0.1 && floor(i) + 0.1 >= i )\n    {\n\t\t\n        if (iFrame == 0)\n        {\n            if ( int(i) % 2 == 0) \n\t\t\t\tfragColor = vec4(vec3(0.0),1.0);\n            else\n                fragColor = vec4(dirRandom(i, SPEED),1.0);\n            \n            return;\n        }\n        else {\n\n\t\t\tParticule p;\n            \n        \t\n            if ( int(i) % 2 == 0) \n            {\n                p.pos = texture(iChannel0, uv).xyz;\n                p.dir = texture(iChannel0, vec2(uv.x+fact, 0.0)).xyz;\n            \tp.pos += SPEED * p.dir ;\n                \n                fragColor = vec4(p.pos,1.0);\n            \n            return;   \n            }\n            else {\n               \tp.pos = texture(iChannel0, vec2(uv.x-fact, 0.0)).xyz;\n            \tp.dir = texture(iChannel0, uv).xyz;\n                \n                vec3 nDir = vec3(0.0);\n                if ( bounding(p.pos, p.dir, nDir) )\n                \tfragColor = vec4(p.dir,1.0);\n                else\n                    fragColor = vec4(nDir,1.0);\n                \n            \n            \treturn;   \n            \t\n            }\n            \n            \n                     \n\n        }\n        \n    }\n\n    fragColor = vec4(0.0,0.0,0.0,0.0);\n}","name":"Buf A","description":"","type":"buffer"}]}