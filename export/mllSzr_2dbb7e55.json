{"ver":"0.1","info":{"id":"mllSzr","date":"1674228084","viewed":125,"name":"raymarching with camera","username":"ZeroSkyline","description":"raymarching with camera","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct ray \n{\n    vec3 p;\n    float t;\n    vec3 d;\n};\nstruct hit\n{\n    float t;\n    vec3 p;\n    vec3 n;\n};\nfloat sd_cube(vec3 p, vec3 c, vec3 e) {\n    vec3 d = abs(p - c) - e;\n    float i = min(max(d.x, max(d.y, d.z)), 0.);\n    float o = length(max(d, 0.));\n    return i + o;\n}\nfloat sd_sphere(vec3 p, vec3 c, float r) \n{\n    return length(p-c)-r; \n}\nfloat sdf(vec3 p)\n{\n    float d0 = sd_cube(p, vec3(0.), vec3(1.));\n    float r = abs(sin(iTime));\n    float d1 = sd_sphere(p, vec3(1,0.,0.), r);\n    float d2 = sd_sphere(p, vec3(-1,0.,0.), r);\n    float d3 = sd_sphere(p, vec3(0.,0.,1), r);\n    float d4 = sd_sphere(p, vec3(0.,0.,-1), r);\n    float d5 = sd_sphere(p, vec3(0.), r*4.);\n    return max(max(d0, max(-d1, max(-d2, max(-d3, -d4)))),d5);\n}\nvec3 pixel_dir(float fov, vec2 fragCoord) \n{\n    vec3 dir;\n    dir.xy = fragCoord-iResolution.xy*.5;\n    dir.z = -iResolution.y*.5/tan(radians(fov)*.5);\n    return normalize(dir);\n}\nvec3 get_normal(vec3 p)\n{\n    float d = .001;\n    float x = sdf(vec3(p.x+d,p.y,p.z)) - sdf(vec3(p.x-d, p.y, p.z));\n    float y = sdf(vec3(p.x,p.y+d,p.z)) - sdf(vec3(p.x, p.y-d, p.z));\n    float z = sdf(vec3(p.x,p.y,p.z+d)) - sdf(vec3(p.x, p.y, p.z-d));\n    return normalize(vec3(x,y,z));\n}\nhit marching(ray r) \n{\n    hit h;\n    float t = r.t;\n    for(int i = 0; i != 256; i++) \n    { \n        vec3 p = r.p + vec3(t) * r.d;\n        float sd = sdf(p);\n        if(sd < .0001) \n        {\n            h.n = get_normal(p); \n            h.t = t;\n            h.p = p;\n            return h;\n        } \n        t += sd; \n    }\n    return h; \n} \nfloat blinn_phong(vec3 l, vec3 v, vec3 n, vec3 p)\n{\n    vec3 h = normalize(l + v);\n    return dot(n, h);\n}\nmat4 viewMtx(vec3 p, vec3 lookAt, vec3 up)\n{\n    vec3 f = normalize(lookAt-p);\n    vec3 r = normalize(cross(f,up));\n    vec3 u = cross(r, f);\n    mat4 m = mat4(\n                 vec4(r,0.),\n                 vec4(u,0.),\n                 vec4(-f,0.),\n                 vec4(0.,0.,0.,1.));\n    return m;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    float rotY;\n    if (iMouse.z > 0.)\n    {\n        rotY = radians(iMouse.x / iResolution.x * 360. - 180.);\n    }\n    else\n    {\n        rotY=iTime;\n    }\n    vec3 cameraPos = vec3(sin(rotY)*4.,sin(iTime)*2.,cos(rotY)*4.);\n    \n    mat4 V = viewMtx(cameraPos, vec3(0.), vec3(0, 1.,0));\n    \n    vec3 viewDir = pixel_dir(45., fragCoord);;\n    vec3 worldDir = (V * vec4(viewDir, 0.)).xyz;\n    vec3 dirLightDir = normalize(vec3(1.));\n\n    \n    ray r; \n    r.p = cameraPos;\n    r.d = worldDir;\n    \n    hit res = marching(r);\n    \n    if(res.t > 0.)\n    {\n        float nl = dot(res.n,dirLightDir);\n        vec3 v = normalize(cameraPos-res.p);\n        vec3 h = normalize(v + dirLightDir);\n        \n        vec3 dirLightCol = vec3(3.14);\n        vec3 envCol = vec3(.1,.2,.4);\n        \n        float lambert = max(nl,0.);\n        \n        vec3 indirL = envCol;\n        vec3 dirL = dirLightCol * lambert;\n        vec3 diff = (dirL + indirL) / 3.14;\n        \n        float blinn_phong = pow(max(dot(h, res.n),0.),30.)*max(nl,0.) / 3.14;\n        float F = .04 + pow(1.-dot(res.n, v), 5.);\n        vec3 spec = dirLightCol * blinn_phong + envCol * F;\n        \n        vec3 col = spec + diff;\n        \n        col = pow(col, vec3(.45));\n        \n        fragColor = vec4(col,1.);\n    }\n    else\n    {\n        fragColor = vec4(.1,.2,.4,1.);\n    }\n}","name":"Image","description":"","type":"image"}]}