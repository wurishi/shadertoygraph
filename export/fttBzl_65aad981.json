{"ver":"0.1","info":{"id":"fttBzl","date":"1663514049","viewed":107,"name":"Vortex Pawn Textured","username":"vsratbatat","description":"Homework 2","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["hw","mipt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3  eye      = vec3 ( 0, 0, 6.0 );\nconst vec3  light    = vec3  ( -3.0, 2.0, 10.0 );\nconst int   maxSteps = 70;\nconst float eps      = 0.01;\nconst float gamma = 2.5;\nconst float pi = 3.1415926;\nconst float FDiel = 0.02; \n\nconst int MAT_PAWN     = 1;\nconst int MAT_PLANE    = 2;\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat cylinderVortex ( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba   = b  - a;\n    vec3  pa   = pos - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x    = length(pa*baba-ba*paba) - r*baba;\n    float y   = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n\n    return sign(d)*sqrt(abs(d))/baba + 0.02 * sin(20.0*pos.z + 20.0*pos.x + 10.0 * iTime);\n}\n\nfloat Cylinder ( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba   = b  - a;\n    vec3  pa   = pos - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x    = length(pa*baba-ba*paba) - r*baba;\n    float y   = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n\nfloat Sphere ( vec3 p, in vec3 c )\n{\n\treturn length ( p - c ) - 0.5;\n}\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\nfloat sdfPawn ( in vec3 p, in mat3 m )\n{\n    vec3 q = m * p;\n    \n\treturn smin(smin(cylinderVortex (q, vec3 ( 0, 0, -1.0 ), vec3 ( 0, 0, 1.5 ), 0.2), Sphere(q, vec3 ( 0, 0, 2.0 )), 2.0),\n    Cylinder (q, vec3 ( 0, 0, -2.0 ), vec3 ( 0, 0, -1.5 ), 1.5),\n    2.0);\n}\n\nfloat Plane( vec3 p, vec3 n, float h )\n{\n    return dot(p, n) + h;\n}\n\nint getMaterial ( vec3 p, mat3 m) \n{\n    vec3 q = m * p;\n    \n    float pawnDist  = sdfPawn(p, m);    \n    float planeDist = Plane(q, vec3(0., 0., 0.5), 1.1);\n    float dist = min(planeDist, pawnDist);\n    \n    int material = 0;   \n    \n    if (dist == pawnDist)\n        material = MAT_PAWN;\n        \n    else if (dist == planeDist)\n        material = MAT_PLANE;\n    \n    return material;\n}\n\nfloat sdf ( in vec3 p, in mat3 m )\n{\n    vec3 q = m * p;\n    \n\treturn smin(smin(smin(cylinderVortex (q, vec3 ( 0, 0, -1.0 ), vec3 ( 0, 0, 1.5 ), 0.2), Sphere(q, vec3 ( 0, 0, 2.0 )), 2.0),\n        Cylinder (q, vec3 ( 0, 0, -2.0 ), vec3 ( 0, 0, -1.5 ), 1.5),\n        2.0),\n    Plane (q, vec3(0., 0., 0.5), 1.2),\n    20.0);\n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m );\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nfloat ambientOcclusion(in vec3 pos, in vec3 normal, mat3 m)\n{\n    float occ = .1;\n    float sca = 1.;\n    for (int i = 0; i < 5; i++)\n    {\n        float h = 0.01 + 0.12 * float(i) / 4.0;\n        float d = sdf(pos + h * normal, m);\n        occ += (h - d) * sca;\n        sca *= 0.95;\n        if (occ > 0.35) \n            break;\n    }\n    return clamp( 1.0 - 3.0 * occ, 0.0, 1.0) * (0.5 + 1.5 * normal.y);\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvec3 fresnel(in vec3 f0, in float product)\n{\n    product = clamp(product, 0., 1.);\n    return mix(f0, vec3(1.), pow(1.-product, 5.));\n}\n\nfloat D_GGX ( in float roughness, in float NdH )\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float NdH2 = NdH * NdH;\n    float d = (m2 - 1.0) * NdH2 + 1.0;\n    return m2 / (pi * d * d);\n}\n\nfloat G_schlick ( in float roughness, in float nv, in float nl )\n{\n    float k = roughness * roughness * 0.5;\n    float V = nv * (1.0 - k) + k;\n    float L = nl * (1.0 - k) + k;\n    return 0.25 / (V * L);\n}\n\nvec3 cookTorrance ( in float nl, in float nv, in float nh, in float vh, in vec3 f0, in float roughness )\n{\nfloat D = D_GGX ( roughness, nh );\nfloat G = G_schlick ( roughness, nv, nl );\nreturn f0 * D * G;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z - 0.5);\n    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);\n    vec2 scale = 10.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 0.1, 0.1, 0.1, 1 );\n    vec3 p     = trace ( eye, dir, hit, m );\n    vec3 q = m * p;\n    vec3 base  = vec3(0.9, 0.9, 0.9);\n\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 20.0 );\n        float metallness = 0.0;\n        float roughness = 0.0;\n        float fDiel = 0.04;\n        vec3  lightColor = vec3 ( 1.0 );\n        float nv = max ( 0.0, dot ( n, v ) );\n        float nh = max ( 0.0, dot ( n, h ) );\n        float hl = max ( 0.0, dot ( h, l ));\n        float vh = max ( 0.0, dot ( h, v ));\n        \n        int material = getMaterial(p, m);\n        \n        if (material == MAT_PAWN)\n        {\n            metallness = 0.5;\n            roughness = texture ( iChannel0, q.xz * 1.95).x;\n            \n            base = texture(iChannel0, q.xz * 0.95).rgb * vec3(0.5);\n        }\n        else if (material == MAT_PLANE)\n        {            \n            metallness = 0.25;\n            roughness = texture ( iChannel1, q.xz / scale + 1.1).x;\n       \n            base = texture(iChannel1, q.yx * 0.4).rgb * vec3(2.5);\n        }\n        \n        \n        vec4 colorDiffuse = vec4(0.5, 0, 0.5, 1);\n        vec4 colorPhong = vec4(0.5, 0, 0.5, 1);\n        vec4 colorAbmient = vec4(1.5, 0, 0.5, 1);\n        //color = colorDiffuse * vec4(nl) + colorPhong * sp + 0.1 * colorAbmient * ambientOcclusion(p, n, m);\n        \n        base = pow(base, vec3(gamma));\n        \n        vec3 F0 = mix ( vec3 ( fDiel ), base, metallness );\n        vec3 specFresnel = fresnel ( F0, nv );\n        vec3 spec = cookTorrance ( nl, nv, hn, vh, specFresnel, roughness ) * nl /\n            max ( 0.003, 2.0 * nl * nv );\n        vec3 diff = (vec3(1.0) - specFresnel) * nl / pi;\n                \n        color *= vec4((diff * mix(base, vec3(0.0), metallness) + spec) * lightColor, 1.0);\n        color = pow(color, vec4(0.5 / gamma));\n\t} \n\n    fragColor = color;\n}\n\n\n","name":"Image","description":"","type":"image"}]}