{"ver":"0.1","info":{"id":"3lcczS","date":"1609304031","viewed":250,"name":"Shuffled Scrambled Sobol (2D)","username":"jaybird","description":"Toy implementation of \"Practical Hash-based Owen Scrambling\" (Burley 2020)\nhttp://www.jcgt.org/published/0009/04/01/\nCode mostly transliterated from the paper.\nWanted 4D, but haven't found a nice Sobol implementation for dimension > 2.\n","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["quasirandom","sobol","owenscrambling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ^^ [Buffer A] is what you're looking for\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"uint laine_karras_permutation(uint x, uint seed) {\n    x += seed;\n    x ^= x*0x6c50b47cu;\n    x ^= x*0xb82f1e52u;\n    x ^= x*0xc7afe638u;\n    x ^= x*0x8d22f6e6u;\n    return x;\n}\n\n// GLSL 4+ has bitfieldReverse(), HLSL has reversebits(), here we do it manually\nuint reverse_bits(uint x) {\n    x = ((x >>  1u) & 0x55555555u) | ((x & 0x55555555u) <<  1u);\n    x = ((x >>  2u) & 0x33333333u) | ((x & 0x33333333u) <<  2u);\n    x = ((x >>  4u) & 0x0f0f0f0fu) | ((x & 0x0f0f0f0fu) <<  4u);\n    x = ((x >>  8u) & 0x00ff00ffu) | ((x & 0x00ff00ffu) <<  8u);\n    x = ((x >> 16u)              ) | ((x              ) << 16u);\n    return x;\n}\n\nuint nested_uniform_scramble(uint x, uint seed) {\n    x = reverse_bits(x);\n    x = laine_karras_permutation(x, seed);\n    x = reverse_bits(x);\n    return x;\n}\n\n// lifted from boost\nuint hash_combine(uint seed, uint v) {\n    return seed ^ (v + 0x9e3779b9u + (seed << 6u) + (seed >> 2u));\n}\n\n// from https://www.shadertoy.com/view/3ldXzM\nuvec2 sobol_2d(uint index) {\n    uvec2 p = uvec2(0u);\n    uvec2 d = uvec2(0x80000000u);\n\n    for(; index != 0u; index >>= 1u) {\n        if((index & 1u) != 0u) {\n            p ^= d;\n        }\n\n        d.x >>= 1u;  // 1st dimension Sobol matrix, is same as base 2 Van der Corput\n        d.y ^= d.y >> 1u; // 2nd dimension Sobol matrix\n    }\n    \n    return p;\n}\n\nvec2 shuffled_scrambled_sobol_2d(uint index, uint seed) {\n    index = nested_uniform_scramble(index, seed);\n    uvec2 p = sobol_2d(index);\n    p.x = nested_uniform_scramble(p.x, hash_combine(seed, 0u));\n    p.y = nested_uniform_scramble(p.y, hash_combine(seed, 1u));\n    return vec2(p)*exp2(-32.);\n}\n\nfloat shade(vec2 p) {\n\treturn 1. - smoothstep(0., 0.00001, dot(p, p));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord/iResolution.xx;\n\n    fragColor.rgb = vec3(0.);\n    \n    const uint seed_a = 0x55555555u;\n    const uint seed_b = 0xAAAAAAAAu;\n    const uint n_per_frame = 16u;\n    for (uint i = 1u; i <= n_per_frame; i++) {\n    \n        uint sobol_index = uint(iFrame)*n_per_frame + i;\n        vec2 p;\n\n        p = shuffled_scrambled_sobol_2d(sobol_index, seed_a);\n        fragColor.rgb += shade(p - uv) * vec3(1.f, 0.f, 1.f);\n\n        p = shuffled_scrambled_sobol_2d(sobol_index, seed_b);\n        fragColor.rgb += shade(p - uv) * vec3(0.f, 1.f, 0.f);\n    }\n\n    fragColor.rgb += texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    fragColor.a   = 1.;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}