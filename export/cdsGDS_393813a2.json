{"ver":"0.1","info":{"id":"cdsGDS","date":"1666967543","viewed":65,"name":"[RagePly] Inverse","username":"RagePly","description":"Controls:\n  * Zoom in/out: mouse up/down\n  * Grid-width -/+: mouse left/right","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["complexcalculus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define complex vec2\n#define pi 3.14159\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\ncomplex cmult( in complex z, in complex w ) {\n    return complex(z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n}\n\ncomplex cconj( in complex z ) {\n    return complex(z.x, -z.y);\n}\n\n\n\nfloat im( in complex z) {\n    return z.y;\n}\n\nfloat re( in complex z) {\n    return z.x;\n}\n\nfloat modulo( in complex z ) {\n    return sqrt(z.x*z.x + z.y*z.y);\n}\n\ncomplex cinv( in complex z ) {\n    return cconj(z) / pow(modulo(z), 2.0);\n}\n\nfloat arg( in complex z ) {\n    if (z.x == 0.0) {\n        if (z.y == 0.0) {\n            return 0.0;\n        } else if (z.y > 0.0) {\n            return pi / 2.0;\n        } else {\n            return 3.0 * pi / 2.0;\n        }\n    }\n    \n    float phi = atan(z.y, z.x);\n    if (phi < 0.0) {\n        return 2.0 * pi + phi;\n    } else {\n        return phi;\n    }\n}\n\nvec3 ccolor( in complex z , in float r_factor) {\n    float r = modulo(z);\n    float phi = arg(z);\n    \n    if (r == 0.0) {\n        return vec3(0.0,0.0,0.0);\n    } else {\n        return hsv2rgb(vec3(phi / 2.0 / pi, pow(min(r_factor, 1.0), -r), 1.0));\n    }\n}\n\nfloat gridfactor( in float grid , float thickness) {\n    float t = clamp(thickness, 0.0, 1.0);\n    float left = smoothstep(1.0 - t, 1.0, 1.0-grid);\n    float right = smoothstep(1.0 - t, 1.0, grid);\n    return left + right;\n}\n\nvec2 c2pol( in complex z ) {\n    return vec2(modulo(z), arg(z));\n}\n\ncomplex pol2c( in vec2 pol ) {\n    return pol.x * complex(cos(pol.y), sin(pol.y));\n}\n\ncomplex cpow( in complex x, in complex y ) {\n    vec2 xpol = c2pol(x);\n    float a = y.x;\n    float b = y.y;\n    float r = xpol.x;\n    float phi = xpol.y;\n    \n    float wmod = pow(r, a) * exp(-b * phi);\n    float warg = a*phi + log(pow(r, b));\n    \n    return pol2c(vec2(wmod, warg));\n}\n\ncomplex f( in complex z ) {\n    return cpow(z, vec2(cos(smoothstep(1.0, 15.0, iTime)*pi), 0.0));\n}\n\ncomplex finv( in complex z ) {\n    return f(z);\n}\n\nfloat approach( in float x ) {\n    float y = clamp(x, 0.0, 1.0);\n    return y + (1.0 - y) * sqrt(y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float ratio = iResolution.x / iResolution.y;\n    vec2 p = fragCoord/iResolution.xy - vec2(0.5, 0.5);\n    float s = 5.0*(1.0 - approach(iMouse.y / iResolution.y));\n    vec2 z = vec2(p.x * ratio, p.y)*s;\n    vec2 w = finv(z);\n    vec3 col = ccolor(f(z), 2.0-iMouse.y/iResolution.y);\n    // vec3 col = ccolor(z);\n\n    // Output to screen\n    float gridx = mod(w.x, 1.0);\n    float gridy = mod(w.y, 1.0);\n    float t = smoothstep(0.2, 1.0, iMouse.x/iResolution.x);\n    fragColor = vec4(col,1.0) - \n        (gridfactor(gridx, t) + gridfactor(gridy, t))*vec4(1.0,1.0,1.0,0.0);\n}","name":"Image","description":"","type":"image"}]}