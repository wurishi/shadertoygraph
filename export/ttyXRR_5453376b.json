{"ver":"0.1","info":{"id":"ttyXRR","date":"1582043877","viewed":337,"name":"Raycast DDA Maze","username":"spalmer","description":"forked [url]https://shadertoy.com/view/wtXSW8[/url] and [url]https://shadertoy.com/view/XdKGWK[/url]\n\nadded some antialiasing and using maze as map, working on dda.  controls: Arrow keys, WASD+QE","likes":11,"published":1,"flags":48,"usePreview":0,"tags":["raycast","antialias","dda","maze"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork mashup of unnick's https://shadertoy.com/view/wtXSW8\n// but with stb's maze from https://shadertoy.com/view/XdKGWK\n\n// added antialiasing on walls\n// FIXME need rez pixel or other guard of window size changes\n// TODO cleanup DDA\n// TODO collision w/ walls - halfway in\n// TODO fix maze scale - done? I think?\n// TODO controls! better now\n// TODO perspective, has been adjusted somewhat already\n// TODO lighting? at least now 4 walls distinguishable by shade\n// TODO texturing? not a big deal but may as well\n// list continues...\n\nvec3[4] colors = vec3[](vec3(1), vec3(1, 0, 0), vec3(0, 1, 0), vec3(.2, .2, 1));\n\n#if 1\n// visualizer of raycaster results; \"first person\" view\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    vec2 pos = (p * 2. - R.xy) / R.y;\n    vec4 a = texelFetch(iChannel3, ivec2(int(p.x),0), 0); //texture(iChannel3, vec2(p.x / R.x, 0.));\n    float dist = a.z\n    , d = .5 - abs(pos.y) * dist\n    // proper antialiasing\n    , blur = 1.*abs(dFdy(d))\n    , f = clamp(.5 - d/blur, 0., 1.)\n//    , fog = exp2(-.1*-dist) //d) // TODO - it's complicated; for one, dist isn't a real distance, it's flat projected already\n    ;\n    int id = int(a.x);\n    c = mix(vec4(colors[id-1], 1.) * a.y, vec4(.25), f);\n//    c.rgb = mix(vec3(.01), c.rgb, fog); // can't do fog here, would need to handle the ceilings&floors differently\n    float mmsize = 2.;\n    if (all(lessThan(p, vec2(MazeSize)*mmsize))) { // minimap?\n\t\t// use BufferC as the minimap\n        c = texture(iChannel2, p / mmsize / R);\n        if (c.x > 2.5)\n            c.rgb *= colors[2]; // show exit\n        else if (c.x > 1.5)\n            c.rgb *= colors[1]; // entrance\n        vec4 v = texelFetch(iChannel0, ivec2(0), 0);\n        c.rgb += exp2(-1.7*(distance(p / mmsize, v.xy) - .5)) * colors[3]; \n    }\n    c = vec4(pow(c.rgb, vec3(1./2.2)), 1);\n}\n// antialiasing hacks junk:\n// //2.*fwidth(d) //12./R.y // dFdy(d-) //12./R.y\n//smoothstep(blur, -blur, d); //step(.5, .5-d); //\n\n\n#elif 1\n// debug maze overhead view\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    vec2 fMazeSize = vec2(MazeSize); //iChannelResolution[2].xy; //texelFetch(iChannel1, ivec2(0), 0).zw;\n    vec2 q = (p + vec2(.001)) * fMazeSize / R;\n    vec2 s = (p + vec2(.001)) * vec2(MazeSmall) / R;\n    \n    // hide the mess outside the maze\n    q = clamp(q, vec2(.5), fMazeSize-.5);\n    //q = s; //q = p; //\n    c = texelFetch(iChannel2, ivec2(q), 0).xxxx;\n//    c = texelFetch(iChannel2, ivec2(p), 0).xxxx;\n    if (c.x > 1.5) c.rgb = colors[int(c.x)-1];\n    vec4 v = texelFetch(iChannel0, ivec2(0), 0);\n    if (distance(q, v.xy) < .5) c = vec4(1,0,1,1);\n//    if (distance(p, v.xy) < 4.) c = vec4(.5,.5,1,1);\n//    c = texelFetch(iChannel1, ivec2(p), 0) + .5; // debug maze creation gradients\n//    c = texelFetch(iChannel1, ivec2(s), 0) + .5; // zoomed in\n}\n\n#elif 1 \n// copy of maze renderer from Buffer C \n// so I can figure out how Buffer B works directly\n\nfloat maze_stb(vec2 q)\n{\n    vec2 p = q * vec2(MazeSmall) / vec2(MazeSize);\n    float d = dWall4(p, iChannel1);\n    return 1. - step(.0, d);\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    float f = clamp(maze_stb(p * vec2(MazeSize) / R), 0., 1.);\n    c = vec4(vec3(pow(f, 1./2.2)), 1);\n}\n\n#else\n// just show BufferC, stretched\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    vec3 v = texture(iChannel2, p * vec2(MazeSize) / R / R, 0.).rgb;\n    c = vec4(vec3(pow(v, vec3(1./2.2))), 1);\n}\n\n#endif\n\n\n// FIXME on odd sized windows, there's a weird line down the middle of the screen","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// TODO could do it all in one buffer:\n\n// column 0 is data pixels\n\n// row 0 is the raycast results that get rendered by Image tab\n\n// rest is maze\n\n// can actually overlap quite a bit of stuff instead\n// since maze wall directions (small maze)\n// only uses .xy, and everything else can pack into .zw\n// can still use row 0 for rendering\n// at least that keeps from needing separate regions for sm and lg maze\n\n// I wouldn't need sm and lg mazes separate except\n// the raycaster works on tiles, not straight distances.\n// I might still be able to work something out.\n\n#define R iResolution.xy\n\nconst int mazespacing = 3; // FIXME 1 doesn't work :(\nconst ivec2 MazeSmall = ivec2(16, 9) * 1;\nconst ivec2 MazeSize = MazeSmall * (mazespacing * 2 - 1); //MazeSmall * (mazespacing + 1); //\n\nbool is_solid(int id)\n{\n    return id == 1; //((id ^ (id >> 1)) & 1) != 0;\n}\n\nvec2 rotateTo(vec2 p, vec2 a) \n{\n    float s = a.x, c = a.y;\n    return mat2(c,s,-s,c) * p;\n}\n\n// from from https://www.shadertoy.com/view/XdKGWK\nconst float WThk = .25/float(mazespacing); //0.125; // wall thickness\n// returns signed distance\nfloat dWall(vec2 p, vec2 dir) \n{\n    p = fract(rotateTo(p, dir)) - .5;\n    \n    // square ends\n    return 2. * max(-p.y, abs(p.x)) - WThk;\n    \n    // round ends\n    //p.y = max(0., -p.y);\n    //return 2. * length(p) - WThk;\n}\n\n// converted to function, was in mainImage / maze_stb\nfloat dWall4(vec2 p, sampler2D ch)\n{\n  #define T(_) texelFetch(ch, ivec2(p-_), 0).xy\n    // hide the mess outside the maze\n    p = clamp(p, vec2(.5), vec2(MazeSmall)-.5);\n    const vec3 o = vec3(1, -1, 0); // save chars    \n    // initial wall 'distance'\n    float d = dWall(p, T(o.zz));\n    const vec2 D[4] = vec2[] (o.xz, o.yz, o.zx, o.zy);\n    // evaluate neighbors to fill in wall gaps\n    for (int i = 0; i < D.length(); ++i) {\n        vec2 w = D[i], t = T(w);\n        if (w == t) //all(equal(w, t)))\n            d = min(d, dWall(p, -t));\n    }\n    return d;\n  #undef T\n}\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// it disturbs me in the worst possible way to waste an entire buffer\n// on one data pixel, but it's what I'm doing until I get the\n// rest sorted out better.\n\n#if 1\n// duplicate of code in Buffer D for collision detection purposes\nint T(ivec2 p)\n{\n    ivec2 r = MazeSize;\n    p.x = p.x % r.x; // idk how necessary the wrapping is\n    if(p.x < 0) p.x += r.x;\n    p.y = p.y % r.y;\n    if(p.y < 0) p.y += r.y;\n    return int(texelFetch(iChannel2, p, 0).x);\n} // TODO hack id = 2 for start, id = 3 for end? related to 0,0 and iResolution\n#endif\n\n#if 1 // walk camera controls\n\n#define A_LEFT  37 // arrow\n#define A_RIGHT 39\n#define A_DOWN  40\n#define A_UP    38\n#define R_LEFT  81 // Q\n#define R_RIGHT 69 // E\n#define LEFT    65 // A\n#define RIGHT   68 // D\n#define DOWN    83 // S\n#define UP      87 // W\n\n// key down\n#define Kf(k) texelFetch(iChannel3, ivec2(k,0), 0).x // step(.5,_) // as float\n#define Kb(k) (Kf(k) > .5) // as bool\n\nvoid WalkCameraControls(inout vec2 p, inout vec2 d)\n{\n    float r = 5.*iTimeDelta, a = r * .8;\n    //if (max(iMouse.z,iMouse.w) > .5) // TODO\n    //{ a += 12.*(iMouse.x - prevMouse.x)/R.x; prevMouse.x = iMouse.x; }\n    float c = cos(a), s = sin(a);\n    mat2 rot = mat2(c,s,-s,c);\n    if(Kb(R_RIGHT)||Kb(A_RIGHT)) d = d * rot;\n    if(Kb(R_LEFT )||Kb(A_LEFT )) d = rot * d;\n    d = normalize(d);\n    vec2 e = vec2(d.y, -d.x)\n    , q = p + r * (\n        d * (max(Kf(A_UP),Kf(UP)) - max(Kf(A_DOWN),Kf(DOWN)))\n      + e * (Kf(RIGHT) - Kf(LEFT))\n        );\n    ivec2 qi = ivec2(floor(q));\n    bool ok = true;\n    if (true && is_solid(T(qi))) {\n  #if 0\n    // seems like unnick attempted collision detection\n    // but it's really easy to get stuck in the walls\n        vec2 pos_wtile = fract(p);\n        vec2 apos = abs(pos_wtile - .5);\n        int side = 0;\n        if(apos.y > apos.x) side = 1;\n        ivec2 b = ivec2(pos_wtile.x > .5 ? 1 : -1, pos_wtile.y > .5 ? 1 : -1);\n        if(is_solid(T(qi + b))) {\n            float c = q[side];\n            q = step(.5, q) * 1.02 - .01;\n            q[side] = c;\n        } else {\n            q[side] += (.51 - apos[side]) * (pos_wtile[side] > .5 ? 1. : -1.);\n        }\n  #else\n        // my crap barely works\n    \t// what I should be doing is:\n    \t// calculate the closest point on the wall surface (nearby wall cells' surfaces)\n    \t// to the query point.  Then after repulsing\n    \t// the center, can further repulse by the radius\n        // can't properly repulse unless we go into this block even when near a collision\n        // and should really be scanning the 4 neighbors, not just the cell we're moving into\n        // otherwise we can't actually have a nonzero radius; we're only checking the center point now!\n        // but if we are going to go to that trouble, may as well use the original\n        // clever thin wall distance stuff stb had.  Hmm.\n        // Lemme see if I can extract that easily. TODO\n    \t// TODO easiest thing I can think of is to push disc out by a square at the collide pos\n        vec2 w = q; // in wall pos\n        q = round(q); //step(.5,q); // just round, basically, to get surface point\n        vec2 push = q - w;\n        if (dot(push,push) > 0.) {\n            if (abs(push.x) > abs(push.y)) push.y = 0.; else push.x = 0.; // 4 dir only\n        \tq += .01 * normalize(push); // probably bouncy because we only checked a point\n        } else \n            q = mix(q, p, .5); // just go back a little bit\n  #endif\n\t    qi = ivec2(floor(q));\n        ok = !is_solid(T(qi)); // recheck\n    }\n\tif (ok) // only if won't be in a wall\n        p = q; // actually update position\n}\n\nvoid mainImage(out vec4 newcamera, vec2 p)\n{\n    if (any(greaterThanEqual(p, vec2(1.)))) return;\n    if (iFrame < 3) { //iFrame == 0) { // thumbnail issues\n        newcamera = vec4(vec2(1+mazespacing),0,1);\n    } else {\n    \t// there's only one data pixel, entire buffer wasted :(\n    \tvec4 o = texelFetch(iChannel0, ivec2(0.), 0);\n    \tWalkCameraControls(o.xy,o.zw);\n    \tnewcamera = o;\n    }\n}\n\n#endif\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// (not fabrice's this time!)\n#if 1\n// from https://shadertoy.com/view/XdKGWK\n// the maze, from original BufferA tab\n\n// only the xy components mean anything;\n// it's the direction to the neighbor wall,\n// or zero if maze still being built.\n\n// hash without sine - https://shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 v = fract(vec3(p.xyx) * vec3(443.8975,397.2973, 491.1871));\n    v += dot(v, v.yzx + 19.19);\n    return fract((v.x + v.y) * v.z);\n}\n\nvec2 qspin(int q)\n{\n    float a = (q & 2) != 0 ? 1. : -1.;\n    return (q & 1) != 0 ? vec2(0,a) : vec2(a,0);\n}\n\n\t\t// FIXME should be a 4 element table or something; no sense involving sin/cos for right angles\n        //const float hpi = 1.57079633;\n        //vec2 r = floor(.5 + sin(hpi * (vec2(0, 1) + a)));\n\n// create maze walls incrementally\nvec2 mazeWallDir(ivec2 i)\n{\n\t#define T(o) texelFetch(iChannel1, i+ivec2(o), 0).xy\n    vec2 d = T(vec2(0)); // cell's stored wall direction, if any        \n    // is this cell empty?\n    if (d == vec2(0)) { //dot(d, d) == 0.) { //\n\t    float seed = mod(iDate.w, 128.);\n        // a random, cardinal direction\n        int a = int(floor(4. * hash12(vec2(i) + seed)));\n        vec2 r = qspin(a);\n        if (T(r) != vec2(0)) // if wall exists in direction r,\n            d = r; // become a new wall connecting that direction\n    }\n\t#undef T\n    return d;\n}\n\n// init wall boundaries\nvec2 mazeWallDirInit(ivec2 i, ivec2 s)\n{\n    const vec3 o = vec3(1, -1, 0); // save a few chars\n    vec2 d;\n    if (i.y == 0)\n        d = o.xz;\n    else if (i.y == s.y-1)\n        d = o.yz;\n    if (i.x == 0)\n        d = o.zx;\n    else if(i.x == s.x-1)\n        d = o.zy;\n    return d;\n}\n\n// output to Buffer B\nvoid mainImage(out vec4 c, vec2 p)\n{\n    ivec2 i = ivec2(p);\n    vec2 d = iFrame < 3 //iFrame == 0 // thumbnail issues\n      ? mazeWallDirInit(i, MazeSmall)\n      : mazeWallDir(i);\n    c = vec4(d,0,0); // store wall direction\n}\n     // || texelFetch(Keyboard, ivec2(82, 0)).x > .5) {\n    // store maze size (for window resizing/fullscreen)\n//    if (fg == ivec2(0))\n//       c.zw = vec2(MazeSize);\n\n#endif\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#if 1 \n// from https://shadertoy.com/view/XdKGWK\n// the maze, Image tab\n\n// returns a (float) tile id of what's in integer cell\nfloat maze_stb_io(vec2 q)\n{\n    vec2 fMazeSize = vec2(MazeSmall);\n    vec2 p = q * fMazeSize / vec2(MazeSize); // account for mazespacing\n    float d = dWall4(p, iChannel1);\n    d = step(.0, d);\n    if (d == 1.) {\n    \tif (all(lessThan(p, vec2(1.5,.7))))\n            return 2.;\n    \tif (all(lessThan(vec2(MazeSmall) - vec2(1.5,.7), p)))\n            return 3.;\n    }\n    return 1.-d;\n}\n// I could use the wall directions in Buffer B directly,\n// but I think it's easier to deal with the corridor spacing\n// and simplifies some other voxel-y things considerably\n// if we just render it into a solid/clear tilemap in BufferC\n#endif\n\n#if 0\n// trying not to use it this time though!  but for now its 1-thin walls will work better w the busted collision detection\n// I get a lot of mileage out of Fabrice's maze snippet\n// https://shadertoy.com/view/lt2cRR\n// it's fast but the mazes are very biased\nfloat mazeFabrice(vec2 p)\n{\n    const float spc = float(mazespacing + 1);\n\treturn mod(p[int(1e4*length(ceil(p/spc)))&1],spc) >= 1. ? 0. : 1.;\n}\n// in case you want to see what it looks like\n// to be a snake or cheese sniffer\n#endif\n\n\nvoid mainImage(out vec4 c, vec2 q)\n{\n    //if (iFrame > 3) return texelFetch(iChannel2, ivec2(p), 0).x;\n    float wall = maze_stb_io(q); //mazeFabrice(q); //   \n    c = vec4(vec3(wall), 1.);\n}\n\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n// use maze from buffer C\n// duplicate of Buffer A and Image\nint tile_at(ivec2 p) \n{\n\tivec2 r = MazeSize;\n    p.x = p.x % r.x;\n    if (p.x < 0) p.x += r.x;\n    p.y = p.y % r.y;\n    if (p.y < 0) p.y += r.y;\n    return int(texelFetch(iChannel2, p, 0).x);\n}\n\n\n#if 1\n// see also https://shadertoy.com/view/wt3SW8 which I want to integrate this into also\n//ivec2 qi; // see main\nvec2 _qf;\nint _id;\nfloat _lum, _dist;\n\nbool Condition(ivec2 q)\n{\n\tif (0 != (_id = tile_at(q)))\n         return true;    \n    return false;\n}\n    \nbool Traverse(ivec2 q)\n{\n    _dist = distance(_qf, vec2(q)); // _lum = 1.; //\n    // compute precise intersection _dist, _lum, _id from BufferC \n    return false; // stop at first solid tile\n}\n\nvoid Scan2F(vec2 pa, vec2 pb)\n{ // not quite!  must initialize the error better\n\tvec2 d = pb - pa;\n    ivec2 s = ivec2(sign(d)), p = ivec2(floor(pa));\n    vec2 a = abs(d), b = a + a;\n\tfloat e = a.y - a.x;\n    int n = int(ceil(a.x) + ceil(a.y));\n    for (int i = 0; i <= n; ++i) {\n\t\tif (Condition(p)) // your condition\n            if (!Traverse(p)) // your traversal function\n                break;\n\t\tif (e < 0.) {\n\t\t\tp.x += s.x;\n\t\t\te += b.y;\n\t\t} else {\n\t\t\tp.y += s.y;\n\t\t\te -= b.x;\n\t\t}\n    }\n}\nfloat rayCastMaze2(vec2 ro, vec2 rd, int nsteps, out int id, out float lum)\n{\n    _qf = ro; _id = -1; _lum = 1.; _dist = 3.4e38;\n    Scan2F(ro, ro + rd * (float(nsteps) + .5));\n    id = _id; lum = _lum;\n    //_dist /= rd[side]; // un-fish-eye, \"flatten\" wall appearance\n    _dist /= 4.; // wall height scaling - increase apparent height, closeness\n    return _dist;\n}\n#endif\n\n// the dda raycaster\n\n// dda march thru tiles in Buffer C\nfloat rayCastMaze1(vec2 ro, vec2 rd, int nsteps, out int id, out float lum)\n{ \n    vec2 nrd = normalize(rd)\n    , dd = 1. / abs(nrd)\n    , pos = ro\n    , sd = fract(pos);\n    ivec2 mp = ivec2(floor(pos)) // starting tile\n    , st = ivec2(sign(rd)); //ivec2(rd.x > 0. ? 1 : -1, rd.y > 0. ? 1 : -1); // tile stepping direction\n    int side = 0;\n    if (st.x > 0) sd.x = 1. - sd.x;\n    if (st.y > 0) sd.y = 1. - sd.y;\n    sd *= dd;\n    id = 1;\n    for (int i = nsteps; --i >= 0; ) { // limit march range just in case\n      #if 1 \n        // may scale to 3d better, seems a bit nicer\n        side = int(sd.x >= sd.y);\n        switch (side) {\n            case 0: sd.x += dd.x; mp.x += st.x; break;\n        \tcase 1: sd.y += dd.y; mp.y += st.y; break;\n        }\n      #elif\n        1 // think it's faster, no indexing of vec2 registers; gets even more unwieldy in 3D\n        if (sd.x < sd.y) {\n            side = 0; sd.x += dd.x; mp.x += st.x;\n        } else {\n            side = 1; sd.y += dd.y; mp.y += st.y;\n        }\n      #else\n        // seems \"cleaner\" but indexing of vec2 registers is probably not efficient\n        side = sd.x >= sd.y ? 1 : 0; //int(sd.x >= sd.y); //\n        sd[side] += dd[side]; mp[side] += st[side];\n        // too bad they're doing it below\n      #endif\n        // masking (multiply one component by zero, then accumulating) probably not efficient either\n        if (0 != (id = tile_at(mp)))\n            break;\n    }\n    float dist = float(mp[side]) - pos[side];\n    dist += float((1 - st[side]) / 2);\n    dist /= rd[side];\n    dist /= 4.; // wall height scaling - increase apparent height, closeness\n\tlum = float(st[side]) * .2 + float(side) * .1 + .7; // fake lighting\n    return dist;\n    //vec2 normal = vec2(0.);\n    //normal[side] = float(st[side]); // TODO resurrect\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    if (p.y >= 1.) return; // FIXME entire rest of buffer wasted; could be maze, camera data pixels\n    vec4 cam = texelFetch(iChannel0, ivec2(0), 0); //vec4(8,8,0,1); //.7,.7); //\n    vec2 ro = cam.xy // starting position\n    , vd = cam.zw\n    , rd = vec2((p.x * 2. - R.x) * .5 / R.y, 1);\n    rd = vec2(rd.x*vd.y + rd.y*vd.x, rd.y*vd.y - rd.x*vd.x); // rotate to world\n    int id;\n    float lum //= 0. // brightness\n    , d = rayCastMaze1(ro, rd, 48, id, lum);\n    o = vec4(id, lum, d, 0);\n}\n\n","name":"Buffer D","description":"","type":"buffer"}]}