{"ver":"0.1","info":{"id":"Wd3XR7","date":"1650300984","viewed":47,"name":"IDma's Metaball","username":"idma88","description":"-","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["metaball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI\t\t\t\t3.1415926535\n\n#define CFG_STEPPER\t\t2\n#define CFG_STEP\t\t0.85\n#define CFG_STEPSMOOTH\t0.05\n\n#define CFG_GRAD\t\t!true\t// Work if CFG_STEPPER == 0\n#define CFG_GRAD_STEPS\t15.0\n\n#define CFG_CLAMP\t\ttrue\t// Work if CFG_STEPPER == 0\n\n#define CFG_POINTS\t\t25\n\n#define __RADIUS\t\t0.03\n\n\nstruct SPoint {\n    vec2 pos;\n    vec3 color;\n    float radius;\n};\n\nfloat aspect;\nSPoint points[CFG_POINTS];\n\nvec2 FixAspect(vec2 pnt) {\n    pnt.x *= aspect;\n    return pnt;\n}\n\nvec3 RGB2HSV(vec3 clr) {\n    float r = clamp(clr.r, 0.0, 1.0);\n    float g = clamp(clr.g, 0.0, 1.0);\n    float b = clamp(clr.b, 0.0, 1.0);\n\n    float _min = min(min(r, g), b);\n    float _max = max(max(r, g), b);\n\n    float h;\n    float s;\n    float v = _max;\n\n    if (_max == 0.0)\n        s = 0.0;\n    else\n        s = 1.0 - _min/_max;\n\n    if (_min == _max) \t\t\th = 0.0;\n    if ((_max == r) && (g > b)) h = 60.0 * (g - b) / (_max - _min) + 0.0;\n    if ((_max == r) && (g < b)) h = 60.0 * (g - b) / (_max - _min) + 360.0;\n    if (_max == g)\t\t\t\th = 60.0 * (b - r) / (_max - _min) + 120.0;\n    if (_max == b)\t\t\t\th = 60.0 * (r - g) / (_max - _min) + 240.0;\n\n    return vec3(h, s, v);\n}\n\nvec3 HSV2RGB(vec3 clr) {\n    float h = mod(clr.x, 360.0);\n    float s = clamp(clr.y, 0.0, 1.0);\n    float v = clamp(clr.z, 0.0, 1.0);\n\n    float c = v * s;\n    float x = c * (1.0 - abs(mod(h / 60.0, 2.0) - 1.0));\n    float m = v - c;\n\n    if ((0.0 <= h) && (h < 60.0)) \t return vec3(c + m, x + m, 0.0 + m);\n    if ((60.0 <= h) && (h < 120.0))  return vec3(x + m, c + m, 0.0 + m);\n    if ((120.0 <= h) && (h < 180.0)) return vec3(0.0 + m, c + m, x + m);\n    if ((180.0 <= h) && (h < 240.0)) return vec3(0.0 + m, x + m, c + m);\n    if ((240.0 <= h) && (h < 300.0)) return vec3(x + m, 0.0 + m, c + m);\n    if ((300.0 <= h) && (h < 360.0)) return vec3(c + m, 0.0 + m, x + m);\n\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvoid Init() {\n    aspect = iResolution.x / iResolution.y;\n\n    for (int i = 0; i < CFG_POINTS; i++)\n    {\n        float speed = 0.5; // * float(i + 1);\n        float shift = -0.1 * float(i);\n\n        float _i = float(i) / float(CFG_POINTS);\n\n        points[i] = SPoint(\n            FixAspect(\n                vec2(0.5, 0.5) +\n                vec2(cos(1.7 * (iTime * speed + shift)), sin(3.1 * (iTime * speed + shift))) / 2.5\n            ),\n            vec3(1., 1., 1.), //HSV2RGB(vec3(0.0 + 0.3 * 360.0 * _i, 0.0, 1.0)),\n            __RADIUS // * (0.001 + abs(0.999 * cos(2.0*PI * _i)))\n        );\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Init();\n\n    vec2 mouse = FixAspect(iMouse.xy/iResolution.xy);\n    //points[0].pos = mouse;\n\n    vec2 uv = FixAspect(fragCoord/iResolution.xy);\n\n    vec3 uOut3 = vec3(0.0, 0.0, 0.0);\n\n    for (int i = 0; i < CFG_POINTS; i++) {\n        vec2 dist = uv - points[i].pos;\n\n        float _u = points[i].radius;// __RADIUS;\n        float uDen = pow(dist.x, 2.0) + pow(dist.y, 2.0);\n\n        if (uDen != 0.0) _u = _u / uDen;\n        _u = clamp(_u, 0.0, 1.0 / points[i].radius/*__RADIUS*/);\n\n        //if (length(dist) > 2.0 * __RADIUS) continue;\n\n        if (!true) {\n            float _x = 0.0;\n            if (length(dist) <= __RADIUS) _x = float(CFG_POINTS);\n\n            //uOut3 += vec3(1.0, 1.0, 1.0) * _x;\n            uOut3 += points[i].color * _x;\n\n        } else {\n            uOut3 += points[i].color * _u;\n        }\n    }\n\n    uOut3 /= (float(CFG_POINTS) / 1.0);\n\n    if (CFG_CLAMP) {\n        float hLimit = 0.9;\n        uOut3 = vec3(\n            clamp(uOut3.r, 0.0, hLimit),\n            clamp(uOut3.g, 0.0, hLimit),\n            clamp(uOut3.b, 0.0, hLimit)\n        );\n    }\n\n    if (CFG_GRAD) {\n        uOut3 = floor(uOut3 * CFG_GRAD_STEPS) / CFG_GRAD_STEPS;\n    }\n\n    switch (CFG_STEPPER)\n    {\n        case 1:\n            uOut3 = step(CFG_STEP, uOut3);\n            break;\n        case 2:\n            uOut3 = smoothstep(CFG_STEP - CFG_STEPSMOOTH, CFG_STEP + CFG_STEPSMOOTH, uOut3);\n            break;\n    }\n\n    uOut3 *= vec3(0., 133./255., 207./255.);\n    \n    // Output to sceen\n    fragColor = vec4(uOut3,1.0);\n}","name":"Image","description":"","type":"image"}]}