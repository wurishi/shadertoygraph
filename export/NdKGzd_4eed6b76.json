{"ver":"0.1","info":{"id":"NdKGzd","date":"1631976635","viewed":133,"name":"Floating Amoebas","username":"sagieL","description":"Simple, silly shader of floating amoebas eating and splitting from each other","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","colors","perlin","fluid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Floating Amoebas\" by Sagie Levy 2021.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email:sagielevy21@gmail.com\n\n#define bgColor vec3(0.086, 0.411, 0.478)\n#define effectColor vec3(0.509, 0.752, 0.8)\n#define effectColor2 vec3(0.8, 0.350, 0.168) \n\nfloat ameobasIntensity(vec2 uv, int layer, float freq, float amp, float movespeed, int octaves) {\n    float heightmapSum = 0.;\n    \n    for (int i = 0; i < octaves; i++) {\n        float randSeed = random(float(i + layer * 5345));\n        float dirX = fract(randSeed * 42.) > 0.5 ? 1. : -1.; // Could be optimized but im lazy\n        float dirY = fract(randSeed * 5253.) > 0.5 ? 1. : -1.;\n        vec2 offset = vec2(dirX * randSeed * movespeed * iTime + 3822. * randSeed,\n                           dirY * randSeed * movespeed * iTime - 475. * randSeed);\n                           \n        vec2 pos = (randSeed * 100. + uv) * freq + offset;\n        heightmapSum += perlin2d(pos) * amp;\n    }\n    \n    return heightmapSum;\n}\n\nvec3 ameobasEffect(float intensity, float effect1Thresh, float effect1Range, \n                   float effect2Thresh, float effect2Range, vec3 currBGColor, float variance) {\n    float effectFactor = smoothstep(effect1Thresh, effect1Thresh + effect1Range, intensity);\n    float effectFactor2 = smoothstep(effect2Thresh, effect2Thresh + effect2Range, intensity);\n        \n    vec3 col = mix(currBGColor, effectColor * variance, effectFactor);\n    col = mix(col, effectColor2 * variance, effectFactor2);\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.y;\n\n    float effectSum = ameobasIntensity(uv, 0, 7., 1., .7, 5);\n    \n    float minEffectThreshold = 0.465;\n    vec3 col = vec3(0.);\n   \n    vec3 currBGColor = (perlin2d(uv * 2. + iTime * 0.1) * 2.5 * bgColor) + 0.1;\n    float variance = mix(.8, 1., perlin2d(uv * 20. + vec2(.4 * iTime, .2 * iTime)));\n    \n    if (effectSum < minEffectThreshold) { // Second layer is occluded by first layer amoebas\n        effectSum = ameobasIntensity(uv, 1, 10., .7, .2, 5);\n        col = ameobasEffect(effectSum, minEffectThreshold, .35, .87, .25, currBGColor, variance);\n        col = mix(col, currBGColor, 0.4);\n    } else {\n        col = ameobasEffect(effectSum, minEffectThreshold, .035, .87, .03, currBGColor, variance);\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Returns a psuedo-random float between 0 and 1 for a given float c\nfloat random(float c)\n{\n    return fract(43758.5453123 * sin(c));\n}\n\n// Returns a psuedo-random vec2 with componenets between -1 and 1 for a given vec2 c \nvec2 random2(vec2 c)\n{\n    c = vec2(dot(c, vec2(127.1, 311.7)), dot(c, vec2(269.5, 183.3)));\n\n    vec2 v = -1.0 + 2.0 * fract(43758.5453123 * sin(c));\n    return v;\n}\n\n// Interpolates a given array v of 4 vec2 values using biquintic interpolation\n// at the given ratio t (a vec2 with components between 0 and 1)\nfloat biquinticInterpolation(float v[4], vec2 t)\n{\n    vec2 u = t * t  * t * (10.0 - 15.0 * t + 6.0 * t * t); // Quintic interpolation\n\n    // Interpolate in the x direction\n    float x1 = mix(v[0], v[1], u.x);\n    float x2 = mix(v[2], v[3], u.x);\n\n    // Interpolate in the y direction and return\n    return mix(x1, x2, u.y);\n}\n\n// Interpolates a given array v of 8 vec3 values using triquintic interpolation\n// at the given ratio t (a vec3 with components between 0 and 1)\nfloat triquinticInterpolation(float v[8], vec3 t)\n{\n    float v1[] = float[]( v[0], v[1], v[2], v[3] );\n    float v2[] = float[]( v[4], v[5], v[6], v[7] );\n\n    float z1 = biquinticInterpolation(v1, vec2(t.x, t.y));\n    float z2 = biquinticInterpolation(v2, vec2(t.x, t.y));\n\n    // Interpolate in the z direction and return\n    return mix(z1, z2, t.z);\n}\n\n// Returns the value of a 2D Perlin noise function at the given coordinates c\nfloat perlin2d(vec2 c)\n{\n    vec2 topRight = vec2(ceil(c.x), floor(c.y));\n    vec2 topLeft = vec2(floor(c.x), floor(c.y));\n    vec2 bottomRight = vec2(ceil(c.x), ceil(c.y));\n    vec2 bottomLeft = vec2(floor(c.x), ceil(c.y));\n\n    vec2 trGradient = random2(topRight);\n    vec2 tlGradient = random2(topLeft);\n    vec2 brGradient = random2(bottomRight);\n    vec2 blGradient = random2(bottomLeft);\n    \n    vec2 trDistance = topRight - c;\n    vec2 tlDistance = topLeft - c;\n    vec2 brDistance = bottomRight - c;\n    vec2 blDistance = bottomLeft - c;\n\n    vec2 t = fract(c);\n    float v[] = float[]( dot(tlGradient, tlDistance), dot(trGradient, trDistance), dot(blGradient, blDistance), dot(brGradient, brDistance) );\n\n    return biquinticInterpolation(v, t);\n}","name":"Common","description":"","type":"common"}]}