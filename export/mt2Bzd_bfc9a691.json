{"ver":"0.1","info":{"id":"mt2Bzd","date":"1694592904","viewed":32,"name":"framework truchet (zv)","username":"zerovolts","description":"Figuring out how to rotate the canvas around the screen center while moving in a fixed direction was by far the most time consuming part of this. Open to ideas about how to resolve the rounded staircase corners problem explained in the code.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["truchet","rotation","tile"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// CONTROLS\n\nconst float GRID_SIZE = 8.;\n// seconds to complete a full turning cycle\nconst float CYCLE_PERIOD = 6.;\n// should be half or less than CYCLE_PERIOD\n// as there are two turns in a period.\nconst float TURNING_TIME = .4;\n\n// DERIVED / CONSTANT\n\nconst float FULL_TURN = 6.2831853071;\nconst float HALF_TURN = FULL_TURN / 2.;\nconst float QUARTER_TURN = HALF_TURN / 2.;\n\nconst float THIRD = 1. / 3.;\n\nconst vec2 NE = vec2(1., 1.);\nconst vec2 NW = vec2(0., 1.);\nconst vec2 SE = vec2(1., 0.);\nconst vec2 DN = vec2(.5, 1.);\nconst vec2 DS = vec2(.5, 0.);\n\n// MATH FUNCTIONS\n\n// 0.0-0.5 : constant : floor(x)\n// 0.5-1.0 : linearly increasing : floor(x) - floor(x + 1)\nfloat paused_linear(float x) {\n    return floor(x) + max(0., fract(x) - .5) * 2.;\n}\n\n// produces a staircase pattern in 2d space\nvec2 staircase(float x) {\n    return vec2(\n        paused_linear(x - .5),\n        paused_linear(x)\n    );\n}\n\n// square wave with rounded corners\nfloat rounded_square_wave(float x, float knee_width) {\n    return smoothstep(\n        .5 - knee_width,\n        .5 + knee_width,\n        1. - abs(fract(x) - .5) * 2.\n    );\n}\n\nvec2 rotate(vec2 uv, float angle) {\n    return mat2(\n        cos(angle), -sin(angle),\n        sin(angle), cos(angle)\n    ) * uv;\n}\n\nfloat rand(vec2 p){\n    return fract(sin(dot(p.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 make_grid(vec2 uv) {\n    vec2 coord = floor(uv * GRID_SIZE);\n    vec2 cell_uv = fract(uv * GRID_SIZE);\n    return vec4(coord, cell_uv);\n}\n\nfloat aa_step(float d, float x) {\n    float aa = 5. / iResolution.y;\n    return smoothstep(d - aa, d + aa, x);\n}\n\n// CELL CONSTRUCTORS\n\n// T cell\nvec3 t_cell_masks(vec2 st) {\n    float shared = st.y > THIRD * 2. ? 1. : 0.;\n    shared -= 1. - aa_step(THIRD / 2., length(st - DN));\n    \n    vec3 masks = vec3(1. - shared, shared, 1.);\n    \n    masks.x -= 1. - aa_step(THIRD, length(st));\n    masks.x -= 1. - aa_step(THIRD, length(st - SE));\n    \n    masks.y -= 1. - aa_step(THIRD, length(st - NW));\n    masks.y -= 1. - aa_step(THIRD, length(st - NE));\n    \n    masks.z -= masks.x;\n    masks.z -= masks.y;\n    \n    return masks;\n}\n\n// รท cell\nvec3 i_cell_masks(vec2 st) {\n    vec3 masks = vec3(0., 1., 0.);\n    vec2 qr = .5 - abs(st - .5);\n    \n    masks.x = (st.y > THIRD && st.y < THIRD * 2.) ? 1. : 0.;\n    masks.x += 1. - aa_step(THIRD / 2., length(st - DS));\n    masks.x += 1. - aa_step(THIRD / 2., length(st - DN));\n    \n    masks.z = 1. - aa_step(THIRD, length(qr));\n    \n    masks.y -= masks.x;\n    masks.y -= masks.z;\n    \n    return masks;\n}\n\n// + cell\nvec3 cross_cell_masks(vec2 st) {\n    vec3 masks = vec3(1., 0., 1.);\n    vec2 qr = .5 - abs(st - .5);\n    \n    masks.z -= aa_step(THIRD, length(qr));\n    masks.x = 1. - masks.z;\n    \n    return masks;\n}\n\n// empty cell\nvec3 empty_cell_masks(vec2 st) {\n    vec3 masks = vec3(1.);\n    \n    // octagonal reflection\n    vec2 qr = .5 - abs(st - .5);\n    qr = qr.x > qr.y ? qr : vec2(qr.y, qr.x);\n    qr = qr.x + qr.y <= 1. ? qr : 1. - qr;\n    \n    masks.x -= aa_step(THIRD / 2., length(qr - DS));\n    masks.z -= aa_step(THIRD, length(qr));\n    masks.y -= masks.x + masks.z;\n    \n    return masks;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    float angle = rounded_square_wave(\n        (iTime + 1.5) / CYCLE_PERIOD,\n        TURNING_TIME / CYCLE_PERIOD\n    ) * QUARTER_TURN;\n    uv = rotate(uv, angle);\n    // TODO: The combination of the smooth rotation with the hard corners\n    // of the staircase movement causes visual issues that are more obvious\n    // when TURNING_TIME is higher than 1.5s or so. The corners of the\n    // staircase movement should be smoothed to fix this (probably with a\n    // change to paused_linear).\n    uv += staircase(iTime / CYCLE_PERIOD);\n    \n    vec4 grid = make_grid(uv);\n    \n    float h = rand(grid.xy / 100.);\n    vec2 st = grid.zw;\n    \n    // randomly rotate tile\n    st = h > .5 ? st : vec2(st.y, st.x);\n    \n    // randomly flip tile\n    st.y = h > .25 && h < .75 ? st.y : 1. - st.y;\n    \n    vec3 masks = vec3(0);\n    int type = int(h * 57.) % 4;\n    switch (type) {\n        case 0:\n            masks = t_cell_masks(st);\n            break;\n        case 1:\n            masks = i_cell_masks(st);\n            break;\n        case 2:\n            masks = cross_cell_masks(st);\n            break;\n        case 3:\n            masks = empty_cell_masks(st);\n            break;\n    }\n    \n    vec3 color = vec3(0);\n    color += vec3(.01, .01, .01) * masks.x;\n    color += vec3(0.06, 0.75, 0.23) * masks.y;\n    color += vec3(.9, .9, .9) * masks.z;\n\n    vec3 srgb = pow(color.rgb, vec3(1. / 2.2));\n    fragColor = vec4(srgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}