{"ver":"0.1","info":{"id":"XddSRl","date":"1460983721","viewed":140,"name":"fixed physical timestep","username":"Marqin","description":"Bouncing ball with fixed physical timestep.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["2d","game","pong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst vec2 txBall = vec2(0.0, 0.0);\n\nbool inCircle( in vec2 pt, in vec2 center, in float size ) {\n    \n bool isIn = (pow(pt.x - center.x,2.0) + pow(pt.y - center.y,2.0) < size*size);\n return isIn;\n}\n\n\nvec4 loadValue( in vec2 re )\n{\n    // loadValue from iq's shader - https://www.shadertoy.com/view/MddGzf\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 ballP = loadValue(txBall).xy;\n    float size = 5.0;\n    \n    if( inCircle(fragCoord.xy, ballP, size) ) {\n      \tvec2 uv = 2.0*fragCoord.xy / iResolution.xy  - 1.0;\n        vec3 tmp = vec3(uv,0.5+0.5*sin(iTime))/1.05;\n\t\tfragColor = vec4(tmp, 1.0);\n    } else {\n      fragColor = vec4(0.95,0.85,0.95,1);\n    }\n        \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// loadValue(),storeValue() from iq's shader - https://www.shadertoy.com/view/MddGzf\n\n\n\nconst float INFINITY = 1.0 / 0.000000001;\nconst float PHYSICS_STEP = 0.01;\n\n#define KEY_Z 90.0/255.0\n#define KEY_X 88.0/255.0\n#define KEY_LEFT 37.0/255.0\n#define KEY_UP 38.0/255.0\n#define KEY_RIGHT 39.0/255.0\n#define KEY_DOWN 40.0/255.0\n\n\nconst vec2 txBall = vec2(0.0, 0.0);\nconst vec2 txAccu = vec2(1.0, 0.0);\n//const vec2 txPosition = vec2(1.0, 0.0);\n\nstruct Box {\n   float x0, x1, y0, y1;\n};\n\nstruct Ray {\n    vec2 origin;\n    vec2 direction;\n};\n//\n\n//vec2 collide_box ( Box b, vec2 ab ) {}\n\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n\nvec2 collide_walls(in vec2 ballP, in vec2 ballV ) {\n    if(ballV.x > 0.0 && ballP.x >= iResolution.x) {\n        ballV.x *= -1.0;\n    }\n\n    if(ballV.x < 0.0 && ballP.x <= 0.0) {\n        ballV.x *= -1.0;\n    }\n\n    if(ballV.y > 0.0 && ballP.y >= iResolution.y) {\n        ballV.y *= -1.0;\n    }\n\n    if(ballV.y < 0.0 && ballP.y <= 0.0) {\n        ballV.y *= -1.0;\n    }\n    \n    return ballV;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ballP = iResolution.xy/2., ballV = vec2(175.,50.);\n    float accu = 0.0;\n    \n    if( iFrame > 1 ) {\n       ballP = loadValue(txBall).xy;\n       ballV = loadValue(txBall).zw;\n       accu = loadValue(txAccu).x;\n    }\n        \n    accu += iTimeDelta;\n    \n    vec2 oldPos = ballP;\n    \n    float loop_end = accu/PHYSICS_STEP;\n    accu -= PHYSICS_STEP*floor(loop_end);\n\n    for(float i = 0.0; i < INFINITY; i++) {\n        if(i >= loop_end) {\n            break;\n        }\n        oldPos = ballP;\n        ballP += ballV * PHYSICS_STEP;\n        \n        ballV = collide_walls(ballP, ballV);\n    }\n    \n    float alpha = accu / PHYSICS_STEP;\n    \n    ballP = ballP*alpha + oldPos*(1.0-alpha);\n    ballV = collide_walls(ballP, ballV);\n    \n    storeValue( txBall, vec4(ballP, ballV), fragColor, fragCoord );\n    storeValue( txAccu, vec4(accu, 0.,0.,0.), fragColor, fragCoord );\n}\n","name":"Buf A","description":"","type":"buffer"}]}