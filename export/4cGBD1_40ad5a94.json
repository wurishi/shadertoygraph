{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define MOUTH_OPEN -(PI * 0.3)\n#define PAC_MAN_MAT Material(vec3(0.969, 0.969, 0.0), 1.0)\n#define PELLET_MAT Material(vec3(0.969, 0.563, 0.0), 2.0)\n#define POWER_PELLET_MAT Material(vec3(0.969, 0.969, 0.969), 3.0)\n#define WALL_MAT Material(vec3(0.0, 0.0, 0.719), 4.0)\n#define GHOST_RED_MAT Material(vec3(0.969, 0.0, 0.0), 5.0)\n#define GHOST_BLUE_MAT Material(vec3(0.0, 0.0, 0.813), 7.0)\n#define GHOST_WHITE_MAT Material(vec3(0.969, 0.969, 0.969), 6.0)\n#define FLASH_COLOR vec3(1.5)\n\nstruct Material {\n    vec3 color;\n    float id;\n};\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 stretch, float r) {\n    vec3 q = p / stretch;\n    return length(q) - r;\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h) {\n    return dot(p, n) + h;\n}\n\nfloat sdRoundedBox(vec3 p, vec3 b, float r) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) - r + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCylinder(vec3 p, float r, float h) {\n    vec2 d = abs(vec2(length(p.xz) - r, p.y - h * 0.5)) - vec2(r, h * 0.5);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nmat3 zrot(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, -s, 0.0,\n        s,  c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nfloat pacman(vec3 pos, float t) {\n    float radius = 1.0;\n    float mouthAngle = t * MOUTH_OPEN;\n\n    vec3 upperPos = zrot(mouthAngle) * pos;\n    vec3 lowerPos = zrot(-mouthAngle) * pos;\n\n    // Small buffer offset to prevent a gap\n    float offset = 0.008 * (1.0 - t);\n    float planeOffset = radius * -0.1 * t + offset;\n\n    float dUpper = max(\n        sdSphere(upperPos, radius),\n        -sdPlane(upperPos, vec3(0.0, -1.0, 0.0), planeOffset)\n    );\n\n    float dLower = max(\n        sdSphere(lowerPos, radius),\n        -sdPlane(lowerPos, vec3(0.0, 1.0, 0.0), planeOffset)\n    );\n\n    return min(dUpper, dLower);\n}\n\nfloat pellets(vec3 pos) {\n    vec3 pelletHalfSize = vec3(0.1, 0.1, 0.1); // Half-size of the box\n    float cornerRadius = 0.1;\n    pos.x += mod(iTime * PELLET_SPEED, -PELLET_SPACING);\n\n    float pelletDistance = 100.0;\n    for (int i = 0; i <= 5; ++i) {\n        float xOffset = float(i) * -PELLET_SPACING;\n        float d = sdRoundedBox(pos + vec3(xOffset, 0.0, 0.0), pelletHalfSize, cornerRadius);\n        pelletDistance = min(pelletDistance, d);\n    }\n\n    return pelletDistance;\n}\n\nfloat powerPellets(vec3 pos, float freq) {\n    float pelletRadius = 0.4;\n    float pelletSpacing = -PELLET_SPACING * POWER_UP_INTERVAL;\n    float offsetTime = iTime - TIME_OFFSET;\n    pos.x += mod(offsetTime * PELLET_SPEED + 0.001, pelletSpacing);\n\n    float pelletDistance = 100.0;\n    for (int i = 0; i <= 1; i++) {\n        float xOffset = float(i) * pelletSpacing;\n        float d = sdSphere(pos + vec3(xOffset, 0.0, 0.0), pelletRadius);\n        pelletDistance = min(pelletDistance, d);\n    }\n\n    return pelletDistance;\n}\n\nfloat walls(vec3 pos) {\n    vec3 wallSize = vec3(20.0, 0.05, 1.0);\n    float topWall = sdRoundedBox(pos - vec3(0.0, 1.2, 0.0), wallSize, 0.1); // Top wall\n    float bottomWall = sdRoundedBox(pos - vec3(0.0, -1.2, 0.0), wallSize, 0.1); // Bottom wall\n\n    return min(topWall, bottomWall);\n}\n\n\nfloat ghostSkirt(vec3 p, float skirtHeight) {\n    float waveHeight = 0.12;\n    float waveFrequency = 9.0;\n    float animFreq = 0.5;\n    float animTime = abs(mod(iTime, animFreq) / animFreq * 2.0 - 1.0);\n    animTime = min(floor(animTime * 1.99) * 0.5, 1.0) * 6.0;\n    float wave = sin(animTime + p.x * waveFrequency - 1.6) * waveHeight;\n    \n    return p.y - (skirtHeight + wave);\n}\n\nfloat ghostBody(vec3 p) {\n    float dome = sdSphere(p - vec3(0.0, 0.0, 0.0), 1.0);\n    float body = sdEllipsoid(p - vec3(0.0, 0.0, 0.0), vec3(1.0, 4.0, 1.0), 1.0);\n    float topSlice = sdPlane(p, vec3(0.0, -1.0, 0.0), 0.0);\n    float skirt = ghostSkirt(p, -0.8);\n    \n    float combinedBody = min(dome, max(body, -topSlice));\n    return max(combinedBody, -skirt);\n}\n\nfloat ghostEyes(vec3 p, bool afraid) {\n    vec3 leftEye, rightEye, scale;\n    if (afraid) {\n        leftEye = vec3(-0.26, 0.19, -0.82);\n        rightEye = vec3(0.26, 0.19, -0.82); \n        scale = vec3(0.3, 0.3, 0.3);\n    } else {\n        leftEye = vec3(-0.18, 0.02, -0.42);\n        rightEye = vec3(0.18, 0.02, -0.42); \n        scale = vec3(1.0, 1.16, 1.0);\n    }\n    float leftEyeDist = sdEllipsoid(p - leftEye, scale, 0.58);\n    float rightEyeDist = sdEllipsoid(p - rightEye, scale, 0.58);\n    return min(leftEyeDist, rightEyeDist);\n}\n\nfloat ghostPupils(vec3 p) {\n    vec3 leftPupil = p - vec3(-0.46, 0.1, -0.76);\n    vec3 rightPupil = p - vec3(0.24, 0.1, -0.86);\n    vec3 scale = vec3(1.0, 1.15, 1.0);\n    float leftPupilDist = sdEllipsoid(leftPupil, scale, 0.18);\n    float rightPupilDist = sdEllipsoid(rightPupil, scale, 0.18);\n    return min(leftPupilDist, rightPupilDist);\n}\n\nfloat ghostMouth(vec3 p) {\n    float mouthHeight = -0.36;\n    float waveFrequency = 11.6;\n    float waveAmplitude = 0.1;\n    float mouthThickness = 0.032;\n    float mouthWidth = 1.53;\n\n    vec2 mouthPos = vec2(p.x, p.y - mouthHeight);\n    float clampedX = clamp(mouthPos.x, -mouthWidth * 0.5, mouthWidth * 0.5);\n    float wave = cos(clampedX * waveFrequency) * waveAmplitude;\n    float distToWave = abs(mouthPos.y - wave);\n    float falloff = smoothstep(mouthWidth * 0.5, mouthWidth * 0.53, abs(mouthPos.x));\n    distToWave += falloff * 0.1;\n    return distToWave - mouthThickness;\n}\n\nfloat ghost(vec3 p, float animTime, inout Material mat) {\n    bool afraid = animTime > 0.5;\n    \n    float body = ghostBody(p);\n    float eyes = ghostEyes(p, afraid);\n    float pupils = ghostPupils(p);\n    float mouth = afraid ? ghostMouth(p) : 100.0; // Only show the mouth when afraid\n\n    if (afraid && mouth < min(eyes, body)) {\n        mat = GHOST_WHITE_MAT; // Define a material for the mouth\n    } else if (!afraid && pupils < eyes && pupils < body) {\n        mat = GHOST_BLUE_MAT;\n    } else if (eyes < body) {\n        mat = GHOST_WHITE_MAT;\n    } else if (afraid) {\n        mat = GHOST_BLUE_MAT;\n    } else {\n        mat = GHOST_RED_MAT;\n    }\n        \n    return body;\n}\n\n\nvec3 pacmanColor(float powerUp) {\n    float flash = abs(sin(iTime * 10.0));\n    return mix(PAC_MAN_MAT.color, FLASH_COLOR, flash * powerUp);\n}\n\nfloat map(vec3 pos, float animTime, out Material material) {\n\n    float distances[5];\n    Material materials[5];\n    \n    float offsetTime = iTime - TIME_OFFSET;\n    float pelletFrequency = offsetTime * PELLET_SPEED / PELLET_SPACING;\n    float powerUpFrequency = pelletFrequency * (PI / POWER_UP_INTERVAL);\n    float powerUp = step(sin(powerUpFrequency * -2.0), 0.0);\n    \n    // Pac-Man\n    distances[0] = pacman(pos, animTime);\n    materials[0] = Material(pacmanColor(powerUp), 1.0);\n\n    // Regular pellets\n    distances[1] = pellets(pos);\n    materials[1] = PELLET_MAT;\n    \n    // Power-up pellets\n    distances[2] = powerPellets(pos, powerUpFrequency);\n    materials[2] = POWER_PELLET_MAT;\n\n    // Walls\n    distances[3] = walls(pos);\n    materials[3] = WALL_MAT;\n    \n    // Ghost\n    Material ghostMat;\n    float powerUpTime = mod(pelletFrequency, POWER_UP_INTERVAL) * 2.0 - POWER_UP_INTERVAL;\n    float ghostTime = step(powerUpTime, 0.0);\n    float ghostPosOffset = abs(powerUpTime) * 0.65 -10.0;\n    distances[4] = ghost(pos + vec3(ghostPosOffset, 0.0, 0.0), ghostTime, ghostMat);\n    materials[4] = ghostMat;\n\n    // Find the closest object\n    float closestDist = distances[0];\n    material = materials[0];\n    for (int i = 1; i < 5; i++) {\n        if (distances[i] < closestDist) {\n            closestDist = distances[i];\n            material = materials[i];\n        }\n    }\n\n    return closestDist;\n}\n\nvec3 calcNormal(vec3 pos, float t) {\n    vec3 delta = vec3(0.001, 0.0, 0.0);\n    Material dummyMaterial;\n\n    float dx = map(pos + delta.xyz, t, dummyMaterial) - map(pos - delta.xyz, t, dummyMaterial);\n    float dy = map(pos + delta.yxz, t, dummyMaterial) - map(pos - delta.yxz, t, dummyMaterial);\n    float dz = map(pos + delta.zyx, t, dummyMaterial) - map(pos - delta.zyx, t, dummyMaterial);\n\n    return normalize(vec3(dx, dy, dz));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float focalLength = 0.3;\n    vec3 rayOrigin = vec3(5.0, 0.0, -12.0);\n    vec3 rayDir = normalize(vec3(uv * focalLength, 1.0));\n\n    // Animation timing\n    float animTime = abs(mod(iTime + 0.3, ANIM_TIME) / ANIM_TIME * 2.0 - 1.0);\n    animTime = min(floor(animTime * 2.99) * 0.66, 1.0);\n\n    // Ray marching loop\n    float totalDist = 0.0;\n    const int maxSteps = 128;\n    const float maxDist = 50.0;\n    const float minDist = 0.001;\n\n    bool hit = false;\n    vec3 pos;\n    Material material;\n\n    for (int i = 0; i < maxSteps; ++i) {\n        pos = rayOrigin + totalDist * rayDir;\n\n        float dist = map(pos, animTime, material);\n        if (dist < minDist) {\n            hit = true;\n            break;\n        }\n\n        if (totalDist > maxDist) break;\n        totalDist += dist;\n    }\n\n    vec3 color = vec3(0.0);\n\n    if (hit) {\n        // Lighting\n        vec3 normal = calcNormal(pos, animTime);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));\n        float diff = max(dot(normal, lightDir), 0.05);\n        \n        vec3 backlightDir = normalize(vec3(-1.0, -1.0, 1.0));\n        float backlight = max(dot(normal, backlightDir), 0.0);\n        vec3 backlightColor = vec3(1.0, 0.0, 1.0);\n\n        color = diff * material.color + backlight * backlightColor;\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"float SquareWave50(float f, float t)\n{\n    return floor(2.0 * floor( f * t) - floor( 2.0 * f * t ) + 1.0);\n}\n\nfloat SquareWave25(float f, float t)\n{\n    return floor(4.0 * floor(f * t) - floor( 4.0 * f * t ) + 1.0);\n}\n\nfloat PulseWave(float f, float t, float width) {\n    return step(fract(t * f), width) * 2.0 - 1.0;\n}\n\nfloat Noise(float x)\n{\n    return fract(sin(123523.9898 * x) * 43758.5453);\n}\n\nfloat Wa(float time) {\n    float ret = 0.0;\n    if (time < 0.15) {\n        float duration = time / 0.15;\n        float freq = mix(150.0, 220.0, duration);\n        ret += SquareWave50(freq * 1.2, time) * clamp(duration + 0.3, 0.0, 1.0);\n        ret += PulseWave(freq, time, 0.05) * 0.4;\n\n        if (time < 0.1) {\n            ret += Noise(time * freq) * clamp(1.0 - time / 0.1, 0.0, 1.0) * 0.15;\n        }\n    }\n    return ret;\n}\n\nfloat Ka(float time) {\n    float ret = 0.0;\n    if (time < 0.15) {\n        float duration = time / 0.15;\n        float invDuration = clamp(1.0 - duration, 0.0, 1.0);\n        float freq = mix(265.0, 240.0, duration);\n        \n        ret += SquareWave50(freq, time) * invDuration;\n        ret += PulseWave(freq, time, 0.05) * 0.4;\n\n        if (time < 0.1) {\n            ret += Noise(time * freq) * invDuration * 0.15;\n        }\n    }\n    return ret;\n}\n\nfloat PoweredUp(float time) {\n    float ret = 0.0;\n\n    if (time < 0.09) {\n        float duration = time / 0.12;\n        float invDuration = clamp(1.0 - duration, 0.0, 1.0);\n\n        float freq = mix(180.0, 340.0, duration);\n        float harmonicFreq = freq * 1.25;\n        float subFreq = freq / 2.0;\n\n        float square = SquareWave25(freq, time) * 0.5 * invDuration;\n        float pulse = PulseWave(subFreq, time, 0.1) * 0.3 * invDuration;\n        float subBass = sin(subFreq * time * 2.0 * 3.14159) * 0.4 * invDuration;\n        float noise = Noise(time * freq) * invDuration * 0.2;\n\n        float distorted = tanh(square + pulse + subBass) * 0.8;\n        float crushed = floor(distorted * 16.0) / 16.0;\n\n        ret += crushed + noise;\n    }\n\n    return ret;\n}\n\n\n\nvec2 mainSound(in int samp, float time) {   \n    time -= TIME_OFFSET;\n    \n    float ret = 0.0;\n    \n    ret += Wa(mod(time - 0.8, 0.34)) * 0.3;\n    ret += Ka(mod(time - 0.24, 0.34)) * 0.2;\n    \n    float left = ret;\n    float right = ret;\n\n    float pelletFrequency = time * PELLET_SPEED / PELLET_SPACING;\n    float powerUpFrequency = pelletFrequency * (PI / POWER_UP_INTERVAL);\n    float powerUp = step(sin(powerUpFrequency * -2.0), 0.0);\n    \n    if (powerUp >= 0.5) {\n        float powerUpSound = PoweredUp(mod(time - 0.4, 0.135));\n        // Oscillation between left and right speakers\n        float pan = sin(time * PI);\n        left += powerUpSound * (0.5 + 0.5 * pan);\n        right += powerUpSound * (0.5 - 0.5 * pan);\n    }\n\n    return vec2(left, right);\n}","name":"Sound","description":"","type":"sound"},{"outputs":[],"inputs":[],"code":"#define PI 3.14159\n#define ANIM_TIME 0.34\n#define PELLET_SPEED 5.8823529411764705882352941176471\n#define PELLET_SPACING 2.0\n#define POWER_UP_INTERVAL 10.0\n#define TIME_OFFSET (POWER_UP_INTERVAL / PELLET_SPEED) + 0.001","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":true,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4cGBD1","date":"1734061097","viewed":132,"name":"Pac-Man 3D v1.1","username":"MojX","description":"This is my first shader here. A little ray marching experiment with Pac-Man.\nI couldn't quite get the sounds right... any tips? Cheers.","likes":16,"published":1,"flags":8,"usePreview":0,"tags":["3d","raymarching","sound","sdf","pacman"],"hasliked":0,"parentid":"","parentname":""}}