{"ver":"0.1","info":{"id":"NtjBzK","date":"1652442474","viewed":163,"name":"cmyk halftone zoom","username":"HaleyHalcyon","description":"a.,ua,","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["a","u","u","ua"],"hasliked":0,"parentid":"NtBBzV","parentname":"cmyk halftone"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TURN 6.283185\n#define HEX(x) vec3((ivec3(x) >> ivec3(16, 8, 0)) & 255) / 255.\n#define ROT(theta) mat2(cos(theta+vec4(0,33,11,0)))\n\n// how much to smooth the color stripes\n#define COLOR_SMOOTHING 1.\n\nvec3 color(float x) {\n    float factor = fract(x) * 3.0;\n    float f0 = smoothstep(0., 0. + COLOR_SMOOTHING, factor);\n    float f1 = smoothstep(1., 1. + COLOR_SMOOTHING, factor);\n    float f2 = smoothstep(2., 2. + COLOR_SMOOTHING, factor);\n    return (\n        HEX(0x009BE8) * (f0 - f1) +\n        HEX(0xEB0072) * (f1 - f2) +\n        HEX(0xfff100) * (f2 - f0 + 1.)\n    );\n}\n\n// returns a grid of distances from the center. don't threshold it with anything over 1.0\nfloat dots(vec2 uv)\n{\n    uv = fract(uv) - vec2(0.5); // fractional component with dots centered at (0.5, 0.5)\n    return sqrt(uv.x * uv.x + uv.y * uv.y);\n}\n\n\n// returns the coordinates of the center of the closest dot\nvec2 uvGrid(vec2 uv)\n{\n    return floor(uv) + vec2(0.5);\n}\n\n#define LOOPLEN 4.\n#define LAYERS 16.\n#define ZOOMSCALE 0.01\n#define LAYERSCALE 0.9\n#define LAYERROT 0.01\n#define LAYERSPERLOOP 3.\n#define ROTALLSCALE -0.25\n#define FARFADE 0.5\n#define OUTLINE 0.002\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 colOutline = HEX(0x010a31);\n\n    float t = fract(iTime / LOOPLEN);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / length(iResolution.xy);\n    uv *= 0.0625 * ZOOMSCALE;\n    \n    // camera distortion\n    float dist = 1. - length(uv);\n    uv *= 100. * dist*dist*dist*dist*dist;\n\n    // Time varying pixel color\n    vec3 col = colOutline;\n    \n    for (float i = 0.; i < LAYERS; i++) {\n        float layerAlpha = clamp(\n            (LAYERS - i - t * LAYERSPERLOOP) * 3.0\n            , 0.0, 1.0\n        );\n        float depth = LAYERS - i - t * LAYERSPERLOOP;\n        vec2 layerUV = uv * ROT(TURN * (\n            ROTALLSCALE * -t + depth * LAYERROT\n        ));\n        \n        // offset center by how much the whole graphic is turning\n        vec2 layerCenter = vec2(\n            cos(-t * (TURN * (1. + ROTALLSCALE))),\n            sin(-t * (TURN * (1. + ROTALLSCALE)))\n        ) * 0.2;\n        \n        layerUV = layerUV * exp2(LAYERSCALE * depth) - layerCenter;\n        vec2 layerGrid = uvGrid(layerUV);\n        \n        float aa = fwidth(layerUV.x) * 1.5;\n        float thres = 0.20 + 0.15 * sin(TURN * (\n            0.5 + \n            log(\n                length(layerGrid) + 0.1\n            ) * 0.7\n            + t * -2.\n            + depth * 0.1\n            \n            - t * ROTALLSCALE // offsets gloabl rotation\n        ) - atan(layerGrid.y, layerGrid.x)\n        );\n        float dots = dots(layerUV);\n        float dotsAlpha = smoothstep(0., aa, thres - dots);\n        \n        vec3 layerCol = mix(\n            colOutline,\n            color(i / 3.),\n            smoothstep(0., aa, thres - dots - OUTLINE) * clamp(\n            (i + (t - 1.) * LAYERSPERLOOP) * FARFADE\n            , 0., 1.)\n        );\n        col = mix(\n            col,\n            layerCol,\n            layerAlpha * dotsAlpha\n        );\n    }\n    \n    //col = fract(128. * uv.xyx);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}