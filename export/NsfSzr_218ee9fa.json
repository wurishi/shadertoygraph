{"ver":"0.1","info":{"id":"NsfSzr","date":"1618169461","viewed":143,"name":"3d Dot product raymarching","username":"leopard","description":"based of tutorial in \"art of code\" YT channel: https://www.youtube.com/watch?v=-adHIyjIYgk inspirited me to try that one too!\nno movable camera or anything special, just got nice shape while following YT channel tutorial.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 50\n#define MAX_DIST 300.\n#define SURF_DIST 0.02\n\nfloat sdSphere(vec3 p, vec4 s){\n    return length(p-s.xyz)-s.w;\n}\nfloat distPlane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) * n.w;\n}\n\n\nfloat dotti(in vec3 p, in float scale, in float thickness, in float bias )\n{\n    p*=scale;\n    return abs(dot(sin(p), cos(p.zxy))-bias)/scale-thickness;\n}\n\nfloat GetDist(vec3 p) {\n    vec3 pallon_keskipiste= vec3(0., 0., 11.);\n    vec3 q =p;\n    q.x+=sin(iTime/1.)*2.;\n    q.y+=cos(iTime/1.)*2.;\n    \n    float sphere =sdSphere(q, vec4(pallon_keskipiste, 4.0 )); \n   \n    float sphere1 =dotti(p, 1.15,   0.13, 0.41);\n    float sphere2 =dotti(p, 4.88,  0.03, 0.5);\n    float sphere3 =dotti(p, 15.,  0.03, 0.5);\n    float sphere4 =dotti(p, 23.,  0.03, 0.5);\n    float sphere5 =dotti(p, 34.,  0.03, 0.5);\n\n    sphere +=sin(iTime*0.5)*sphere1*1.4;  //kohouma vai laavakuoppa +/-\n    sphere -=sphere2*0.3;\n    sphere +=sphere3*0.25;\n    sphere -=sphere4*0.2;\n    sphere +=sphere5*0.15;\n    \n    //boolean operaattori\n    float d=100.;\n    d = min(d, sphere*0.4);\n\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(0.01,0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n        \n        return normalize(n);\n}\n\nfloat GetLight(vec3 p){\n    \n    vec3 lightPos = vec3(2,5,-6);\n\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l),0.,1.);\n    float d = RayMarch(p+n*SURF_DIST*1.5,l);\n    if( d<length(lightPos-p) )   dif *=0.3;\n    return (dif);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5 (y) and x is -0,8 to 0.8 (or something)\n    vec2 uv = (fragCoord -.5*iResolution.xy)/iResolution.y;\n\n    //testipixeli!\n    vec2 pixelPos= vec2(0.0, 0.0); //x & y\n    float pixelColor = smoothstep(0.02,.01,length(pixelPos-uv));\n\n    vec3 ro = vec3(-0.0,-0.0,-25);\n    vec3 rd = normalize(vec3(uv.x,uv.y,3.));\n\n    float d = RayMarch(ro,rd);\n\n    vec3 p = ro+rd*d;\n\n    float dif = 0.0;\n    dif = GetLight(p);\n    \n    vec3 col = vec3(0);\n    \n    if(length(p)<MAX_DIST){\n        vec3 n = normalize(p);\n        col += dif+n*0.1;\n        \n        float sphere2 =dotti(p, 1.15,   0.13, 0.41);\n        float red = 0.4+18.*abs(smoothstep(.5,.0,sphere2+.5));\n        red += 0.4*abs(smoothstep(.6,.4,sphere2+.5));\n        \n        float green = 0.4+0.4*abs(smoothstep(1.28,2.0,sphere2+0.5));\n        green += 0.1*abs(smoothstep(0.8,0.1,sphere2+.5));\n        \n        float blue = .25;\n        blue += 0.1*abs(smoothstep(.9,.2,sphere2+.5));\n        col*=vec3(red,green, blue);\n        \n    }\n    // Output to screen\n    //col.x += pixelColor;    //testpixel at 0,0\n    fragColor = vec4(col,0.4);\n}","name":"Image","description":"","type":"image"}]}