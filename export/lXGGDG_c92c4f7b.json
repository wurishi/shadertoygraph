{"ver":"0.1","info":{"id":"lXGGDG","date":"1718217888","viewed":51,"name":"NormalsFromDepth","username":"joaquin","description":"Compute normals from depth","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["normals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat getDepth(vec2 uv) {\n    // Use a texture image\n    return (1.0 - texture(iChannel0, uv).r) * 1.0;\n    // Or use a programtic image\n    //if (uv.y > 0.5) {\n    //    return uv.y - 0.5;\n    //} else if (uv.x > 0.5) {\n    //    return uv.x - 0.5;\n    //} else {\n    //   return 0.5 - uv.x;\n   //}\n}\n\nvec3 to3D(vec2 f, vec2 c, vec2 imageSize, vec2 center, vec2 offset) {\n    vec2 uv = center + offset / imageSize;\n    vec4 packedDepth = vec4(getDepth(uv));\n    float z = packedDepth.r * 1.0;\n    float x = (imageSize.x * uv.x - c.x) * z / f.x;\n    float y = (imageSize.y * uv.y - c.y) * z / f.y;\n    return vec3(x, y, z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    vec2 f = vec2(127, 127);\n    vec2 c = iChannelResolution[0].xy / 2.0;\n    vec2 imageSize = iChannelResolution[0].xy;\n    //vec2 imageSize = iResolution.xy;\n    \n    vec3 pCenter = to3D(f, c, imageSize, uv, vec2( 0.0,  0.0));\n    vec3 pLeft   = to3D(f, c, imageSize, uv, vec2(-1.0,  0.0));\n    vec3 pRight  = to3D(f, c, imageSize, uv, vec2( 1.0,  0.0));\n    vec3 pBottom = to3D(f, c, imageSize, uv, vec2( 0.0, -1.0));\n    vec3 pTop    = to3D(f, c, imageSize, uv, vec2( 0.0,  1.0));\n\n    vec3 n = cross(pRight - pLeft, pTop - pBottom);\n    vec3 normal = normalize(n);\n    normal = normal.yxz; // swizzle due to camera texture orientation\n\n    fragColor = vec4(normal / 2.0 + 0.5,1.0);\n    //fragColor = vec4(vec3(getDepth(uv)),1.0);\n}","name":"Image","description":"","type":"image"}]}