{"ver":"0.1","info":{"id":"MXlyzj","date":"1726492943","viewed":10,"name":"sdfCircle_Kovalenko_Ivan","username":"ivankovalenko","description":"1.2","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["12"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat sdfCircle(vec2 uv, float r, vec2 offset) {\n    float d = length(uv - offset) - r;\n    return step(0.0, -d);\n}\n\nvec3 applyLighting(vec3 color, vec2 uv, vec2 lightPos, float intensity) {\n    // Рассчитываем расстояние от uv до позиции света\n    float dist = length(uv - lightPos);\n    \n    // Освещение уменьшается с расстоянием (чем ближе к свету, тем ярче)\n    float attenuation = clamp(1.0 - dist / intensity, 0.0, 1.0);\n    \n    // Увеличиваем яркость цвета, добавляя эффект освещения\n    return color + vec3(attenuation);\n}\n\nvec3 drawScene(vec2 uv, vec2 mousePos, inout vec2 blueCircleOffset, bool isTouchingPlatform) {\n    vec3 col = vec3(0.0);  // Начальный цвет сцены\n\n    // Поднимаем синий круг немного выше\n    blueCircleOffset.y += 0.1;\n\n    // Рисуем синий круг, который становится красным при касании платформы\n    float blueCircle = sdfCircle(uv, 0.1, blueCircleOffset);\n    \n    // Если синий круг касается платформы, он становится красным\n    vec3 circleColor = isTouchingPlatform ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 0.0, 1.0);\n    col = mix(col, circleColor, blueCircle);  // Синий или красный круг\n\n    // Рисуем белый круг, управляемый мышью\n    float whiteCircle = sdfCircle(uv, 0.05, mousePos);\n    col = mix(col, vec3(1.0), whiteCircle);  // Белый круг (управляемый мышкой)\n    \n    // Применяем освещение от белого круга к синему (или красному) кругу\n    if (blueCircle > 0.0) {\n        col = applyLighting(col, uv, mousePos, 0.5);  // Свет от белого круга\n    }\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;  // Приведение координат к диапазону <0, 1>\n    uv.x *= iResolution.x / iResolution.y;  // Исправление соотношения сторон\n\n    // Координаты мыши\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    mousePos.x *= iResolution.x / iResolution.y;  // Исправление соотношения сторон для мыши\n\n    // Получаем смещение синего круга из Buffer A\n    vec2 blueCircleOffset = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n\n    // Рендеринг платформ\n    float platformWidth = 0.5;\n    float platformHeight = 0.05;\n    float fallSpeed = 0.5;  // Скорость падения платформ\n\n    // Положение платформы по оси Y\n    float platformY = 1.0 - mod(iTime * fallSpeed, 1.0);\n    // Случайное положение платформы по оси X\n    float platformX = random(vec2(floor(iTime / 2.0), 0.0));\n\n    // Проверяем, касается ли платформа синего круга\n    float circleRadius = 0.1;  // Радиус синего круга\n    bool isTouchingPlatform = \n        blueCircleOffset.x + circleRadius > platformX && \n        blueCircleOffset.x - circleRadius < platformX + platformWidth && \n        blueCircleOffset.y + circleRadius > platformY && \n        blueCircleOffset.y - circleRadius < platformY + platformHeight;\n\n    // Если касание произошло, перемещаем круг в середину по оси X\n    if (isTouchingPlatform) {\n        blueCircleOffset.x = 0.5;  // Центрируем по оси X\n    }\n\n    // Отрисовка сцены\n    vec3 col = drawScene(uv, mousePos, blueCircleOffset, isTouchingPlatform);\n\n    // Рисуем платформу\n    if (uv.x > platformX && uv.x < platformX + platformWidth &&\n        uv.y > platformY && uv.y < platformY + platformHeight) {\n        fragColor = vec4(1.0, 0.5, 0.0, 1.0);  // Оранжевая платформа\n    } else {\n        fragColor = vec4(col, 1.0);  // Рендер сцены с освещением\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_LEFT  = 65;  // A\nconst int KEY_RIGHT = 68;  // D\n\nvec2 handleKeyboard(vec2 offset) {\n    float velocity = 1. / 100.; // Скорость перемещения\n    vec2 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec2(-1, 0);\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec2(1, 0);\n    \n    offset += (left + right) * velocity;\n\n    return offset;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Получаем текущее смещение синего круга\n    vec2 offset = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    \n    // Обрабатываем ввод с клавиатуры\n    offset = handleKeyboard(offset);\n\n    // Сохраняем смещение\n    fragColor = vec4(offset, 0.0, 0.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}