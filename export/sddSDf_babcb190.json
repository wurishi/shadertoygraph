{"ver":"0.1","info":{"id":"sddSDf","date":"1634240402","viewed":68,"name":"amateur attempt at julia set","username":"hggg","description":"college debts and sleep deprivation are not cool, but 3Blue1Brown is.\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractals"],"hasliked":0,"parentid":"NdtSWX","parentname":"newtons fractals"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// z_n+1 = z_n^2 + c\nvec2 C = vec2(0.0, 1.0);\n// colours\nvec3 solcol[3] = vec3[3](vec3(1.0, .0, .0), vec3(.0, 1.0, .0), vec3(.0, .0, 1.0));\n\nvec2 next_step(vec2 x) { // step = -f(x)/f'(x)\n    return cmplxsqr(x) + C;\n}\n\nconst float s = 5.0; // tiles/screenW\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n    vec2 t = iResolution.xx/s; // tile dimension\n    vec2 uv = fc/iResolution.xy;\n    vec2 c = (fc.xy-(iResolution.xy/2.0) )/t.xy;\n    vec2 fmou = (iMouse.xy-iResolution.xy/2.0)/t.xy;\n    float borderw = 1.0/iResolution.x*s;\n    \n    C = fmou - vec2(0.25, 0.0);\n    \n    vec2 rem = vec2(abs(round(c.x) - c.x), abs(round(c.y) - c.y));\n    vec3 col = vec3(0.0); /*(0.25 + 0.5*step(0.5, 1.0-min(round(abs(c.x) + 0.4), round(abs(c.y) + 0.4)))\n        ) * vec3(0.0, 1.0, 1.0) * (1.0 - min(\n        step(0.5, 1.0-(0.5 + borderw - rem.x) ),\n        step(0.5, 1.0-(0.5 + borderw - rem.y) )\n    ));*/\n    \n    vec2 x = vec2(c.x-0.5, c.y-0.0);\n    vec2 nstep;\n    //float ii = 0.0; // sum\n    int i = 0;\n    #define max_iter 100\n    for (; i <= max_iter; i++) {\n        nstep = next_step(x);\n        x += nstep;\n        //x += next_step(x);\n\n        //ii += -(length(nstep));\n        \n        if (length(x) >= 4.0) {\n            //ii = log(ii);\n            //ii -= (length(x) - 4.0);\n            break;\n        } \n    }\n    \n    float d = 9999999999999999.0;\n    \n    #define fff 0.05\n    if (i < max_iter) {\n        float ii = float(i);\n        col += (1.0-pow(0.8, 0.5*(ii)))\n            *vec3(sin(ii*fff), sin(ii*fff+PI/3.0), sin(ii*fff+PI/3.0*2.0));\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265358979323\n\n// i derived them so idk if theyre actually correct\nvec2 cmplxmult(vec2 a, vec2 b) { // complex multiplication\n    return vec2(a.x*b.x - a.y*b.y, a.y*b.x + a.x*b.y);\n}\nvec2 cmplxcjg(vec2 x) { // conjugation\n    return vec2(x.x, - x.y);\n}\nvec2 cmplxdiv(vec2 a, vec2 b) { // complex division a/b\n    return cmplxmult(a, cmplxcjg(b)) / (b.x*b.x + b.y*b.y);\n}\nvec2 cmplxsqr(vec2 x) {\n    return vec2(x.x*x.x-x.y*x.y, 2.0*x.x*x.y);\n}\n//vec2 cmplxexp()","name":"Common","description":"","type":"common"}]}