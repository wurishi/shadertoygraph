{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"const float TAU = 6.2831853;\nconst float TAU_2 = 3.141592653589793;\nconst float TAU_4 = 1.5707963267948966;\nconst float GRAD_EPS = 0.0001;\n\nfloat asqrt(float x) {\n\treturn x > 0.0 ? sqrt(x) : 0.0;\n}\n\n\n\nvec4 ellipj(float u, float m) {\n    const float eps = 0.0001;\n    float ai, b, phi, t, twon;\n    float a[9];\n    float c[9];\n    \n    if (m < eps) {\n        t = sin(u);\n        b = cos(u);\n        ai = 0.25 * m * (u - t * b);\n    \treturn vec4(\n            t - ai * b,\n      \t\tb + ai * t,\n      \t\t1.0 - 0.5 * m * t * t,\n      \t\tu - ai\n            );\n    }\n    \n    if (m >= 1.0 - eps) {\n    \tai = 0.25 * (1.0 - m);\n    \tb = cosh(u);\n    \tt = tanh(u);\n    \tphi = 1.0 / b;\n    \ttwon = b * sinh(u);\n    \treturn vec4(\n            t + ai * (twon - u) / (b * b),\n      \t\tphi - ai * t * phi * (twon - u),\n      \t\tphi + ai * t * phi * (twon + u),\n      \t\t2.0 * atan(exp(u)) - TAU_4 + ai * (twon - u) / b\n            );\n    }\n    \n    a[0] = 1.0;\n    a[1] = 0.0;\n    a[2] = 0.0;\n    a[3] = 0.0;\n    a[4] = 0.0;\n    a[5] = 0.0;\n    a[6] = 0.0;\n    a[7] = 0.0;\n    a[8] = 0.0;\n    \n    c[0] = sqrt(m);\n    c[1] = 0.0;\n    c[2] = 0.0;\n    c[3] = 0.0;\n    c[4] = 0.0;\n    c[5] = 0.0;\n    c[6] = 0.0;\n    c[7] = 0.0;\n    c[8] = 0.0;\n    \n    b = sqrt(1.0 - m);\n    twon = 1.0;\n    for (int i = 0; i < 8; i++) {\n        ai = a[i];\n        c[i + 1] = 0.5 * (ai - b);\n        a[i + 1] = 0.5 * (ai + b);\n        b = asqrt(ai * b);\n        twon *= 2.0;\n    }\n    phi = twon * a[8] * u;\n    for (int i = 0; i < 8; i++) {\n        b = phi;\n   \t\tt = c[8 - i] * sin(b) / a[8 - i];\n    \tphi = 0.5 * (asin(t) + phi);\n    }\n    t = cos(phi);\n    return vec4(sin(phi), t, t / cos(phi - b), phi);\n}\n\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT2_2 = 0.7071067811865476;\n\nvec2 rotate(vec2 v, float alpha) {\n    float c = cos(alpha);\n    float s = sin(alpha);\n    mat2 m = mat2(c, s, -s, c);\n    return m * v;\n}\n\nvec2 quincuncial_intermediate(vec2 p) {\n    if (abs(p.x) > 2.0 || abs(p.y) > 1.0) {\n        return vec2(0.0);\n    }\n    \n}\n\nfloat mixfix(float a, float b, float t) {\n    // this piece is nonsensical but without it\n    // we get a black screen, fuck you nVidia\n    // fuck you with a rusty rake\n    // (pls fix your floating point)\n    float u;\n    t = clamp(t, 0.0, 1.0);\n    u = 1.0 - t;\n    u = clamp(u, 0.0, 1.0);\n    return a * u + b * t;\n}\n\n/*acutally a half-space*/\nfloat plane(vec3 p, vec3 c, vec3 n) {\n    return dot(n, p) - dot(n, c);\n}\n\nfloat dplaneray_dt(vec3 p, vec3 c, vec3 n, vec3 ray) {\n    return dot(n, ray);\n}\n\n/*cube with 3 lengths*/\nfloat cube(vec3 p, vec3 c, vec3 vr) {\n    vec3 bmin = c - vr;\n    vec3 bmax = c + vr;\n    vec3 dmin = bmin - p;\n    vec3 dmax = p - bmax;\n    vec3 max1 = max(dmin, dmax);\n    vec2 max2 = max(max1.xy, max1.z);\n    return max(max2.x, max2.y);\n}\n\nfloat dcuberay_dt(vec3 p, vec3 c, vec3 vr, vec3 ray) {\n    // differentiate everything and you're just left with\n    // finding the max coordinate of -ray\n    // which is what you'd expect given that we're\n    // computing the intersection of 6 \"plane\"s\n    // note: actually half-spaces\n    vec3 max1 = -ray;\n    vec2 max2 = max(max1.xy, max1.z);\n    return -max(max2.x, max2.y);\n}\n\n/*proper cube*/\nfloat cube(vec3 p, vec3 c, float r) {\n    vec3 vr = vec3(r, r, r);\n    return cube(p, c, vr);\n}\n\nfloat dcuberay_dt(vec3 p, vec3 c, float r, vec3 ray) {\n    vec3 vr = vec3(r, r, r);\n    return dcuberay_dt(p, c, vr, ray);\n}\n\n/*sphere*/\nfloat sphere(vec3 p, vec3 c, float r) {\n    return distance(c, p) - r;\n}\n\nfloat dsphereray_dt(vec3 p, vec3 c, float r, vec3 ray) {\n    // okay so the derivative for the sphere is a bit shitty\n    // vector from p + t*ray to centre\n    vec3 vt = p - c;\n    return dot(vt, ray) / length(vt);\n}\n\n/*torus*/\n/*rc - radius to centre of tube*/\n/*rt - radius of tube*/\nfloat torus(vec3 p, vec3 c, vec3 n, float rc, float rt) {\n    // equation is\n    // (rmax - sqrt(dot(p.xy))) ** 2 + z**2 - rmin**2\n    // for torus symmetric around z\n    float z = dot(p, n) - dot(c, n);\n    vec3 p1 = p - z * n;\n    float xy2 = dot(p1 - c, p1 - c);\n    float b = rc - sqrt(xy2);\n    return sqrt(b * b + z * z) - rt;\n}\n\nfloat dtorusray_dt(vec3 p, vec3 c, vec3 n, float rc, float rt, vec3 ray) {\n    // lol goodenough\n    float e = 0.5 * GRAD_EPS;\n    return (torus(p + e * ray, c, n, rc, rt) - torus(p - e * ray, c, n, rc, rt)) / GRAD_EPS;\n}\n\n/*cylinder with spherical caps at ends*/\n/* a, b - centres of the caps, r - radius */\nfloat cylinder_caps(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 n = normalize(b - a);\n    vec3 p1 = p - a;\n    float d = dot(n, p1);\n    vec3 c = d * n;\n    if (dot(n, c) < 0.0) {\n        return sphere(p, a, r);\n    }\n    if (dot(n, c) > distance(a, b)) {\n        return sphere(p, b, r);\n    }\n    float daxis = length(p1 - d * n);\n    return daxis - r;\n}\n\nfloat dcylinder_capsray_dt(vec3 p, vec3 a, vec3 b, float r, vec3 ray) {\n    // nope not calculating this today\n    return -1.0;\n}\n\n/* tile vec3 around the centre with radius r */\nvec3 tile(vec3 p, vec3 r) {\n    return 2.0 * (fract((p + r) / (2.0 * r)) - vec3(0.5, 0.5, 0.5)) * r;\n}\n\nfloat timing(float seconds) {\n    return fract(iTime / seconds);\n}\n\nfloat timing2(float seconds) {\n    return 1.0 - 2.0 * abs(timing(seconds) - 0.5);\n}\n\nfloat dist_object_1(vec3 p) {\n    return max(\n        mix(\n        \ttorus(p, vec3(0.1, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.5, 0.0625),\n\t        cube(p, vec3(0.1, 0.0, 0.0), 0.45),\n\t        timing2(30.0)),\n        -sphere(p, vec3(0.5, 0.5, 0.5), 0.43));\n}\n\nvoid dist_dt_object_1(out float dist, out float dt, in vec3 p, in vec3 ray) {\n    float d1 = mix(\n        torus(p, vec3(0.1, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.5, 0.0625),\n        cube(p, vec3(0.1, 0.0, 0.0), 0.45),\n        timing2(30.0));\n    float d2 = -sphere(p, vec3(0.5, 0.5, 0.5), 0.43);\n    if (d1 > d2) {\n        dist = d1;\n        dt = mix(\n        \tdtorusray_dt(p, vec3(0.1, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.5, 0.0625, ray),\n        \tdcuberay_dt(p, vec3(0.1, 0.0, 0.0), 0.45, ray),\n        \ttiming2(30.0));\n    } else {\n        dist = d2;\n        dt = -dsphereray_dt(p, vec3(0.5, 0.5, 0.5), 0.43, ray);\n    }\n    dt = -1.0;\n}\n\nfloat dist_object_2(vec3 p) {\n\treturn plane(p, vec3(0.0, -0.7, 0.0), vec3(0.0, 1.0, 0.0));\n}\n\nfloat dist_object_any(vec3 p) {\n    return min(dist_object_1(p), dist_object_2(p));\n}\n\nfloat ddist_object_2ray_dt(vec3 p, vec3 ray) {\n\tfloat e = GRAD_EPS * 0.5;\n    return (dist_object_2(p + e * ray) - dist_object_2(p - e * ray)) / GRAD_EPS;\n}\n\n/* gradient */\nvec3 grad_1(vec3 p) {\n    float eps = GRAD_EPS;\n    return normalize(vec3(\n                dist_object_1(p - vec3(eps, 0.0, 0.0)) - dist_object_1(p + vec3(eps, 0.0, 0.0)),\n                dist_object_1(p - vec3(0.0, eps, 0.0)) - dist_object_1(p + vec3(0.0, eps, 0.0)),\n                dist_object_1(p - vec3(0.0, 0.0, eps)) - dist_object_1(p + vec3(0.0, 0.0, eps))));\n}\n\n/* gradient */\nvec3 grad_2(vec3 p) {\n    float eps = GRAD_EPS;\n    return normalize(vec3(\n                dist_object_2(p - vec3(eps, 0.0, 0.0)) - dist_object_2(p + vec3(eps, 0.0, 0.0)),\n                dist_object_2(p - vec3(0.0, eps, 0.0)) - dist_object_2(p + vec3(0.0, eps, 0.0)),\n                dist_object_2(p - vec3(0.0, 0.0, eps)) - dist_object_2(p + vec3(0.0, 0.0, eps))));\n}\n\n/* trace from point p along ray r */\nvec4 trace_1(vec3 p, vec3 r) {\n    vec3 p1 = p;\n    float epsilon = 2.0e-04;\n    float t = 0.0;\n    float d;\n    float ddray_dt;\n    dist_dt_object_1(d, ddray_dt, r, p1);//, r, d, ddray_dt);\n    for (int i = 0; i < 128; i++) {\n        // escape if too long\n        if (dot(p1 - p, p1 - p) > 16.0 * 16.0) {\n            return vec4(p1, 0.0);\n        }\n        if (abs(d) < epsilon) {\n            break;\n        }\n        t = t - d / ddray_dt;\n        p1 = p + t * r;\n        dist_dt_object_1(d, ddray_dt, r, p1);\n    }\n    if (abs(d) > epsilon) {\n        return vec4(p1, 0.0);\n    } else {\n        return vec4(p1, 1.0);\n    }\n}\n\n/* trace from point p along ray r */\nvec4 trace_2(vec3 p, vec3 r) {\n    vec3 p1 = p;\n    float epsilon = 2.0e-04;\n    float t = 0.0;\n    float d;\n    float ddray_dt;\n    d = dist_object_2(p1);//, r, d, ddray_dt);\n    for (int i = 0; i < 64; i++) {\n        // escape if too long\n        if (dot(p1 - p, p1 - p) > 16.0 * 16.0) {\n            return vec4(p1, 0.0);\n        }\n        if (abs(d) < epsilon) {\n            break;\n        }\n        ddray_dt = ddist_object_2ray_dt(p1, r);\n        ddray_dt = clamp(ddray_dt, -1.0, -0.9);\n        t = t - d / ddray_dt;\n        p1 = p + t * r;\n\t    d = dist_object_2(p1);//, r, d, ddray_dt);\n    }\n    if (abs(d) > epsilon) {\n        return vec4(p1, 0.0);\n    } else {\n        return vec4(p1, 1.0);\n    }\n}\n\nvec4 trace_any(vec3 p, vec3 r) {\n    vec3 p1 = p;\n    float epsilon = 2.0e-04;\n    float t = 0.0;\n    float d;\n    d = dist_object_any(p1);//, r, d, ddray_dt);\n    for (int i = 0; i < 64; i++) {\n        // escape if too long\n        if (dot(p1 - p, p1 - p) > 16.0 * 16.0) {\n            return vec4(p1, 0.0);\n        }\n        if (abs(d) < epsilon) {\n            break;\n        }\n        t = t + d;\n        p1 = p + t * r;\n\t    d = dist_object_any(p1);//, r, d, ddray_dt);\n    }\n    if (abs(d) > epsilon) {\n        return vec4(p1, 0.0);\n    } else {\n        return vec4(p1, 1.0);\n    }\n}\n\nvec3 texgen_1(vec3 p, vec3 n) {\n//    return (vec3(1.0, 1.0, 1.0) + n) * 0.5;\n//    return vec3(1.0, 1.0, 1.0);\n    \n    // glTexGen GL_SPHERE_MAP\n    vec3 u = normalize(p);\n    vec3 f = u - 2.0 * dot(n, u) * n;\n    float m = 2.0 * sqrt(f.x * f.x + f.y * f.y + (f.z + 1.0) * (f.z + 1.0));\n    vec2 t = f.xy / m + vec2(0.5, 0.5);\n\n    // :/\n//    float sblue = sin(dot(t, t) * 18 * TAU);\n//    sblue = (sblue + 1) * 0.5;\n    //float sblue = step(0.5, fract((t.x * t.x + t.y * t.y) * 1.5));\n    //float sblue = step(0.5, fract((t.x + t.y) * 1.5));\n    //return mix(srgb(89, 132, 50), srgb(148, 174, 22), sblue);\n    //return mix(srgb(246, 200, 44), srgb(250, 236, 147), sblue);\n    //return vec3(t, 0.3 + 0.4 * timing2(12345));\n    float c = distance(vec2(0.5, 0.5), t) * 1.8;\n    return vec3(1.0, 1.0 - c, 1.0 - c);\n}\n\nvec3 texgen_2(vec3 p, vec3 n) {\n    return vec3(0.5, 0.5, 0.5);\n}\n\nconst vec3 light1 = vec3(-0.0, -1, -0.0);\nconst vec3 light2 = vec3(0.7071067811865475, -0.7071067811865475, -0.0);\nvec3 light3_pos = vec3(-0.2, 0, 2.5);\nvec3 shade_any(vec3 p, vec3 n) {\n    vec3 light3 = normalize(p - light3_pos);\n    vec4 m1 = trace_any(p - light1 * 0.05, -light1);\n    vec4 m2 = trace_any(p - light2 * 0.05, -light2);\n    vec4 m3 = trace_any(light3_pos, light3);\n    m3.xyz -= p;\n    float see1 = 1.0 - m1.w;\n    float see2 = 1.0 - m2.w;\n    float see3 = (1.0 - step(0.01, dot(m3.xyz, m3.xyz)) * m3.w);\n    float factor1 = see1 * dot(n, light1);\n    float factor2 = see2 * dot(n, light2);\n    float factor3 = see3 * dot(n, light3);\n\n/*\n    vec3 light1c = vec3(1, 1, 1);\n    vec3 light2c = vec3(1, 1, 1);\n    vec3 light3c = vec3(1, 1, 1);\n*/\n    vec3 light1c = vec3(0.9, 0.1, 0.1);\n    vec3 light2c = vec3(0.1, 0.9, 0.1);\n    vec3 light3c = vec3(0.1, 0.1, 0.9);\n    // no light shadows only\n//    return c * ((2.0 - m1.w - m2.w) * 2.0 / 3.0 + 1.0 / 3.0);\n    // three lights\n//*\n     return (\n     max(factor1, 0.0) * light1c +\n     max(factor2, 0.0) * light2c +\n     max(factor3, 0.0) * light3c\n     ) / (light1c + light2c + light3c);\n//*/\n    // debug normals\n//    return 0.5 * (vec3(1.0, 1.0, 1.0) + n);\n    // debug shadows\n//    return vec3(see1, see2, see3);\n    // debug space\n//    return 0.5 * (vec3(1.0, 1.0, 1.0) + p);\n}\n\nvec4 go(vec3 p, vec3 ray) {\n    // wavy effect1\n    \n    /*\n    float phi = TAU * 2.0 * (ray.x + ray.y);\n    p.z += sin(phi) * cos(phi) * 0.01;\n    //*/\n\n    // wavy effect2\n    /*\n    float phi = TAU * timing2(15.0);\n    ray.x *= sin(phi + ray.x);\n    //*/\n\n    vec4 q1 = trace_1(p, ray);\n    vec4 q2 = trace_2(p, ray);\n    if (q1.w < 1.0 && q2.w < 1.0) {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    vec3 c;\n    vec3 n;\n    float lq1 = distance(p, q1.xyz);\n    float lq2 = distance(p, q2.xyz);\n    if (q2.w > 0.0 && (lq2 < lq1 || q1.w < 1.0)) {\n        p = q2.xyz;\n        n = grad_2(p);\n        c = texgen_2(p, n);\n    } else {\n        p = q1.xyz;\n        n = grad_1(p);\n        c = texgen_1(p, n);\n    }\n    vec3 lightness = shade_any(p, n);\n    return vec4(lightness * c, 1.0);\n}\n\nvec3 srgb_from_rgb(vec3 rgb) {\n    vec3 a = vec3(0.055, 0.055, 0.055);\n    vec3 ap1 = vec3(1.0, 1.0, 1.0) + a;\n    vec3 g = vec3(2.4, 2.4, 2.4);\n    vec3 ginv = 1.0 / g;\n    vec3 select = vec3(greaterThan(rgb, vec3(0.0031308, 0.0031308, 0.0031308)));\n    vec3 lo = rgb * 12.92;\n    vec3 hi = ap1 * pow(rgb, ginv) - a;\n    return select * hi + (vec3(1.0, 1.0, 1.0) - select) * lo;\n}\n\nvec3 rgb_from_srgb(vec3 srgb) {\n    vec3 a = vec3(0.055, 0.055, 0.055);\n    vec3 ap1 = vec3(1.0, 1.0, 1.0) + a;\n    vec3 g = vec3(2.4, 2.4, 2.4);\n\tvec3 select = vec3(greaterThan(srgb, vec3(0.04045, 0.04045, 0.04045)));\n    vec3 hi = srgb / 12.92;\n    vec3 lo = pow((srgb + a) / ap1, g);\n    return select * hi + (vec3(1, 1, 1) - select) * lo;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 lookat = vec3(0.1, 0.0, 0.0);\n    vec2 angle = vec2(-0.1, 0.0) * TAU;\n    //(iMouse.yx / iResolution.yx - vec2(0.5)) * TAU;\n    vec2 sa = sin(angle);\n    vec2 ca = cos(angle);\n    mat3 rotmat = mat3(\n        vec3( ca.y,  sa.x * sa.y,  ca.x * sa.y),\n        vec3(    0,         ca.x,        -sa.x),\n        vec3(-sa.y,  sa.x * ca.y,  ca.x * ca.y));\n    vec3 e1 = rotmat[0];\n    vec3 e2 = rotmat[1];\n    vec3 e3 = rotmat[2];\n    vec2 pixelcentre = fragCoord;\n    pixelcentre /= max(iResolution.x, iResolution.y);\n    vec2 midpoint = 0.5 * iResolution.xy / max(iResolution.x, iResolution.y);\n    pixelcentre = (pixelcentre - midpoint) * 2.0;\n    vec3 gm = lookat - 2.0 * e3;\n    vec3 p = pixelcentre.x * e1 + pixelcentre.y * e2 + gm;\n    vec3 t = lookat - 2.8 * e3;\n\n    //light3_pos = lookat - light3_pos.x * e1 - light3_pos.z * e3;\n    //light3_pos = (vec4(light3_pos, 1.0)).xyz;\n    //p = (camera * vec4(p, 1.0)).xyz;\n\n    vec3 tr;\n    vec3 ray = normalize(p - t);\n    vec4 result = go(p, ray);\n\tfragColor = vec4(srgb_from_rgb(result.xyz), result.w);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XlX3Ws","date":"1426095476","viewed":157,"name":"Faster distance march","username":"moshev","description":"Marching using linear approximation","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""}}