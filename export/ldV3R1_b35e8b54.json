{"ver":"0.1","info":{"id":"ldV3R1","date":"1453332119","viewed":625,"name":"particles - portal method","username":"stb","description":"Particles repel each other using a distance field and normal map. Particles detect neighbors thanks to tiny portals in their centers :)\nKeys:\n1: view the distance field\n2: view the normal map\n1+2: view particles only\nR: create new particles","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["2d","normals","particles","distance","field"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"const vec3 PtColor   = vec3(1., .9, .3);\nconst vec3 DistColor = vec3(0., .7, 1.);\n\nconst float KEY_1 = 49.5 / 256.;\nconst float KEY_2 = 50.5 / 256.;\n\n#define isKeyHeld(KEY_) (texture(iChannel3, vec2(KEY_, 0.)).r>0.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 res = iResolution.xy;\n    vec2 uv = fragCoord / res;\n    \n    float dist = texture(iChannel0, uv).a;\n    vec2 dir = texture(iChannel1, uv).rg;\n    vec3 RGB;\n    vec3 ptCol = 1.5*dist*PtColor-.25;\n    \n    if(isKeyHeld(KEY_2)) {\n    \tRGB = vec3(.5+.5*dir, 0.);\n    \t\tif(isKeyHeld(KEY_1))\n                RGB = mix(vec3(0.), ptCol, smoothstep(.5-8./res.y, .5+8./res.y, dist));    \n    }\n    else\n        if(isKeyHeld(KEY_1))\n        \tRGB = vec3(dist);\n    \t\t\telse\n        \t\t\tRGB = mix(DistColor*vec3(dist), ptCol, smoothstep(.5-8./res.y, .5+8./res.y, dist));    \n    \n    fragColor = vec4(RGB, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int   NumPts    = 44;   // number of particles\nconst float PtRad     = 0.2;  // particle radius (relative to screen size)\nconst float PtSpeed   = 0.01; // the speed particles move away from each other\nconst float PortalRad = 1.5;  // particle portal radius (in pixels)\nconst bool  WrapPts   = true; // toroidal mapping on/off\n\nconst float KEY_R = 82.5 / 256.;\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p) {\n    vec3 MOD3 = vec3(443.8975, 397.2973, 491.1871);\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 res = iResolution.xy;\n    vec2 uv  = fragCoord / res;\n    vec2 p   = fragCoord / res.y;\n    \n    float df = 0.;\n    vec2 pPosOut=vec2(0.), pPos;\n    \n    for(int i=0; i<NumPts; i++) {\n        if(iFrame==0 || texture(iChannel3, vec2(KEY_R, 0.)).r>0.)\n            // set initial particle positions\n\t\t\tpPos = hash22(vec2(mod(float(i)+iTime/100., 100.), 0.));\n        else {\n            // get particle positions\n            pPos = texture(iChannel0, vec2((float(i)+.5)/res.x, 0.)).rg;\n        \tif(WrapPts)\n                pPos = fract(pPos);\n        }   \n        \n        // distance field normals from Buf B\n        vec2 norm = texture(iChannel1, pPos).rg;\n        \n        // distance field from this buffer\n        float dist = texture(iChannel0, pPos).a;\n        \n        // move particles away from each other\n        if(dist>0.)\n        \tpPos += PtSpeed * norm * dist;\n        \n        // distance for this particle\n        float circ;\n        if(WrapPts)\n            circ = length(mod(p-vec2(res.x/res.y, 1.)*pPos+.5, vec2(res.x/res.y, 1.))-.5);\n        else\n            circ = length(p-vec2(res.x/res.y, 1.)*pPos) ;\n        \n        // create portal in circle's center\n        if(circ<PortalRad/res.y)\n            circ = 1.;\n        \n        // combine circle into overall distance\n        df = max(df, 1.-circ/PtRad);\n        \n        // for writing positions to buffer\n        if(floor(fragCoord)==vec2(float(i), 0.))\n            pPosOut = pPos;\n    }\n    \n    fragColor = vec4(pPosOut, 0., df);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 ps = 1. / iResolution.xy;\n    \n    vec2 norm =\n        normalize(\n            vec2(\n                texture(iChannel0, uv-vec2(ps.x, 0.)).a-texture(iChannel0, uv+vec2(ps.x, 0.)).a,\n                texture(iChannel0, uv-vec2(0., ps.y)).a-texture(iChannel0, uv+vec2(0., ps.y)).a\n            )\n\t\t);\n    \n    fragColor = vec4(norm.xy, 0., 0.);\n}","name":"Buf B","description":"","type":"buffer"}]}