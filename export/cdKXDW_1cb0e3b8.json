{"ver":"0.1","info":{"id":"cdKXDW","date":"1681204943","viewed":124,"name":"Marching Square","username":"yonng","description":"Marching Square Implementations\n\nOriginal Implementation are from Taichi Examples\nhttps://github.com/taichi-dev/taichi/pull/6851\n","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","dynamicarray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ref https://github.com/taichi-dev/taichi/pull/6851\nint grid_size = 16;\nfloat level = 0.15;\n\nvec4 edge_table[16]\n=vec4[](\n   vec4(-1,-1,-1,-1),\n   vec4(3,0,-1,-1),\n   vec4(0,1,-1,-1),\n   vec4(1,3,-1,-1),\n   \n   vec4(1,2,-1,-1),\n   vec4(0,1,2,3),\n   vec4(0,2,-1,-1),\n   vec4(2,3,-1,-1),\n   \n   vec4(2,3,-1,-1),\n   vec4(0,2,-1,-1),\n   vec4(0,3,1,2),\n   vec4(1,2,-1,-1),\n   \n   vec4(1,3,-1,-1),\n   vec4(0,1,-1,-1),\n   vec4(3,0,-1,-1),\n   vec4(-1,-1,-1,-1)\n);\n\n\nvec2 hash22(vec2 p)\n{\n    float n = sin(dot(p, vec2(41, 289)));\n    \n    return sin(fract(vec2(262144, 32768)*n)*6.28 + iTime);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 ip = floor(p);\n    p -= ip;\n    vec4 v = vec4(dot(hash22(ip), p),\n        dot(hash22(ip + vec2(1,0)), p-vec2(1,0)),\n        dot(hash22(ip + vec2(0,1)), p-vec2(0,1)),\n        dot(hash22(ip + vec2(1,1)), p-vec2(1,1))\n    );\n    \n    p = p*p*p*(p*(p*6.-15.)+10.);\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n}\n\nfloat isofunc(vec2 p)\n{\n    return noise(p/4. + 1.0);\n}\n\n\nvec2 interp(vec2 p1, vec2 p2, float v1, float v2, float interp_val)\n{\n    return mix(p1, p2, (interp_val - v1)/(v2-v1));\n    \n}\n\n\nvec2 get_vertex(int vertex_id, vec4 values, float isovalue)\n{\n    vec2 v = vec2(0.);\n    vec2[4] square = vec2[](vec2(0.0), vec2(0.0, 1.0), vec2(1., 1.), vec2(1., 0.));\n    \n    switch(vertex_id)\n    {\n      case 0: v = interp(square[0], square[1], values.x, values.y, isovalue); break;\n      case 1: v = interp(square[1], square[2], values.y, values.z, isovalue); break;\n      case 2: v = interp(square[2], square[3], values.z, values.w, isovalue); break;\n      case 3: v = interp(square[3], square[0], values.w, values.x, isovalue); break;\n      default: break;\n    \n    }\n\n    return v;\n}\n\n\n\nvec2[4] marching_square(vec2 uv)\n{\n    vec2 edge[4] = vec2[](vec2(-50.), vec2(-50.),vec2(-50.), vec2(-50.));   //hard-coded out-range values for sanity check\n    float x_range = ceil(float(grid_size) * iResolution.x/iResolution.y);\n    float y_range = float(grid_size);\n    uv.x = floor(uv.x);\n    uv.y = floor(uv.y);   //marching square from the grid edges\n    \n    \n    int t_id = 0;\n    vec4 grid_values = vec4(isofunc(vec2(uv.x,uv.y)),\n    isofunc(vec2(uv.x, uv.y+1.)), isofunc(vec2(uv.x+1., uv.y+1.)),\n    isofunc(vec2(uv.x+1., uv.y)));\n    \n    if (grid_values.x >level) t_id |=1;\n    if (grid_values.y >level) t_id |=2;\n    if (grid_values.z >level) t_id |=4;\n    if (grid_values.w >level) t_id |=8;\n       \n    if(t_id ==5 || t_id ==10)\n    {\n        float center_val = isofunc(vec2(uv.x+0.5, uv.y+0.5));\n        if(center_val >level) t_id = 15 - t_id;\n    }\n    \n    //check whether to return the edges\n    \n    if(edge_table[t_id].x!=-1.)\n    {\n       int ind_1 = int(edge_table[t_id].x);\n       int ind_2 = int(edge_table[t_id].y);\n       edge[0] = uv + get_vertex(ind_1, grid_values, level);\n       edge[1] = uv + get_vertex(ind_2, grid_values, level);\n    }\n    \n    if(edge_table[t_id].z!=-1.)\n    {\n       int ind_1 = int(edge_table[t_id].z);\n       int ind_2 = int(edge_table[t_id].w);\n       edge[2] = uv + get_vertex(ind_1, grid_values, level);\n       edge[3] = uv + get_vertex(ind_2, grid_values, level);\n    }\n     \n\n    //return the two end on the edge\n    return edge;\n}\n\n\nfloat dseg(vec2 p, vec2 a, vec2 b)\n{\n    p-=a; b-=a;\n    float h = clamp(dot(p,b)/dot(b, b), 0.0, 1.0);\n    return length(p-h*b);\n\n}\n\nvec4 render(in vec2 uv)\n{\n  //define the return color\n  //grid_uv - [-1.0, 1.0] * grid_size\n  vec2 grid_uv = 2.0* uv * float(grid_size);  //use constructor to perform the conversion\n  vec4 col = vec4(0.3, 0.6, 0.8, 1.0);\n  if (isofunc(grid_uv) > level) col.rgb = vec3(1.0, 0.8, 0.3);\n  \n  //draw the background grid\n  vec2 q = abs(fract(grid_uv)-0.5);\n  vec2 dd = vec2(0.5) - q;\n  float dgrid = min(dd.x, dd.y);\n  col.rgb = mix(col.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.04, dgrid-0.02));\n  \n  //draw edges\n  float dedge = 1e5;\n  float dv = 1e5;\n  vec2 s, e;\n  \n  vec2[4] edges = marching_square(grid_uv);\n  \n  if(edges[0].x!=-50.0)  //if edges get updated\n  {\n    s = edges[0]; e = edges[1];\n    dedge = min(dedge, dseg(grid_uv, s, e));\n    dv = min(min(dv, length(grid_uv-s)), length(grid_uv-e));\n  }\n  if(edges[2].x!=-50.0)\n  {\n    s = edges[2]; e = edges[3];\n    dedge = min(dedge, dseg(grid_uv, s, e));\n    dv = min(min(dv, length(grid_uv-s)), length(grid_uv-e));\n   \n  }\n  \n  col.rgb = mix(col.rgb, vec3(1.0, 0.0, 0.0), 1.- smoothstep(0.0, 0.05, dedge-0.02));\n  \n  //draw small circles at the boundary\n  col.rgb = mix(col.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.05, dv-0.1));\n  col.rgb = mix(col.rgb, vec3(1.0), 1.0-smoothstep(0.0, 0.05, dv-0.08));\n  \n  //apply gamma corrections\n  col.r = pow(col.r, 1.0/2.);\n  col.g = pow(col.g, 1.0/2.);\n  col.b = pow(col.b, 1.0/2.);\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates [-0.5 0.5]\n    // and make it squared\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    //perform the rendering\n    vec4 col = render(uv);\n\n    // Output to screen\n    fragColor = col; //vec4(uv,0.0, 1.0);\n}","name":"Image","description":"","type":"image"}]}