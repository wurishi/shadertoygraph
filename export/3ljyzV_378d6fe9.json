{"ver":"0.1","info":{"id":"3ljyzV","date":"1595508167","viewed":219,"name":"2d physic engine","username":"linlin64","description":"simple physic engine","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["collision","sat","repulsion","physic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int fragCoordx = int(fragCoord.x);\n    int fragCoordy = int(fragCoord.y);\n    \n    vec2 uv = fragCoord.xy * 7.0 /iResolution.x;\n\n    fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\n    for(int polygonIndex = 0; polygonIndex < polygonNumber; ++polygonIndex) {\n        vec2 pos = texelFetch(iChannel0, ivec2(posenum, polygonIndex), 0).xy;\n        float angle = texelFetch(iChannel0, ivec2(angleenum, polygonIndex), 0).x;\n       \n        int vertexNumber = int(texelFetch (iChannel0, ivec2(vertexnumberenum, polygonIndex), 0).x);\n\n        float cosan = cos(angle);\n        float sinan = sin(angle);\n\n\t\tvec2 vertexlist[4];\n        for(int vertexindex = 0; vertexindex < vertexNumber; ++vertexindex) {\n            vec2 vt = texelFetch(iChannel0, ivec2(vertexlistenum + vertexindex, polygonIndex), 0).xy;\n\n            vec2 pt = vec2(\n                vt.x * cosan - vt.y * sinan,\n                vt.x * sinan + vt.y * cosan);\n\n            vec2 pos = vec2(pos.x + pt.x, pos.y + pt.y);\n            if (vertexindex == 0) {\n                vertexlist[0] = pos;\n            } else if (vertexindex == 1) {\n                vertexlist[1] = pos;\n            } else if (vertexindex == 2) {\n                vertexlist[2] = pos;\n            } else {\n                vertexlist[3] = pos;\n            }\n        }\n        \n        bool ligne;\n        for(int vertexindex = 0; vertexindex < vertexNumber; ++vertexindex) {\n            if (vertexindex == vertexNumber - 1) {\n                if (sdLine(uv, vertexlist[0], vertexlist[vertexindex])) {\n                \tligne = true;\n                }\n            } else {\n                if (sdLine(uv, vertexlist[vertexindex], vertexlist[vertexindex+1])) {\n                \tligne = true;\n                }\n            }\n        }\n\n        if (ligne) {\n            fragColor = vec4(0.0, 1.0, 0.0, 0.0);\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Dynamic Polygone\n// Cube1\nint vertexNumberCube1 = 4;\nvec2 vertex1Cube1 = vec2(-0.3, -0.3);\nvec2 vertex2Cube1 = vec2(-0.3, 0.3);\nvec2 vertex3Cube1 = vec2(0.3, 0.3);\nvec2 vertex4Cube1 = vec2(0.3, -0.3);\nvec2 vertexlistCube1[4];\n\n// Triangle\nint vertexNumberCube2 = 3;\nvec2 vertex1Cube2 = vec2(-0.3, -0.2);\nvec2 vertex2Cube2 = vec2(0.3, -0.2);\nvec2 vertex3Cube2 = vec2(0, 0.3);\nvec2 vertexlistCube2[3];\n\n// Static Cube2\nint vertexNumberCube3 = 4;\nvec2 vertex1Cube3 = vec2(-2.5, -10.1);\nvec2 vertex2Cube3 = vec2(-2.5, 0.1);\nvec2 vertex3Cube3 = vec2(2.5, 0.1);\nvec2 vertex4Cube3 = vec2(2.5, -10.1);\nvec2 vertexlistCube3[4];\n\nvec4 handleVertex(in vec2 fragCoord) {\n    int fragCoordx = int(fragCoord.x);\n    int fragCoordy = int(fragCoord.y);\n    \n    for(int polygonIndex = 0; polygonIndex < polygonNumber; ++polygonIndex) {\n        if (fragCoordy != polygonIndex) {\n        \tcontinue;\n        }\n        \n        int staticCube = int(texelFetch (iChannel0, ivec2(staticenum, polygonIndex),0 ).x);\n        float mass = texelFetch (iChannel0, ivec2(massenum, polygonIndex),0 ).x;\n        float inertie = texelFetch (iChannel0, ivec2(inertieenum, polygonIndex), 0).x;\n        int vertexNumber = int(texelFetch (iChannel0, ivec2(vertexnumberenum, polygonIndex), 0).x);\n\n\t\tvec2 vertexlist[4];\n        for(int iv = 0; iv < vertexNumber; ++iv) {\n            vertexlist[iv] = texelFetch (iChannel0, ivec2(vertexlistenum+iv, polygonIndex), 0).xy;\n        }\n\n        if (vertexNumber == 0) {\n            if (polygonIndex == 0) {\n                staticCube = 1;\n                mass = 10000.0;\n                inertie = mass * (3.0 * 3.0 + 2.0 * 2.0) / 12.0f;\n                vertexlist[0] = vertex1Cube3;\n                vertexlist[1] = vertex2Cube3;\n                vertexlist[2] = vertex3Cube3;\n                vertexlist[3] = vertex4Cube3;\n                vertexNumber = 4;\n            } else {\n            \tint randomtype = int(2.0 * random(vec2(polygonIndex + 3, polygonIndex + 1)));\n                if (randomtype == 0) {\n\t                staticCube = 0;\n                    mass = 1.0;\n                    inertie = mass * (3.0 * 3.0 + 2.0 * 2.0) / 12.0f;\n                    vertexlist[0] = vertex1Cube2;\n                    vertexlist[1] = vertex2Cube2;\n                    vertexlist[2] = vertex3Cube2;\n                    vertexNumber = 3;\n                } else {\n\t                staticCube = 0;\n                    mass = 1.0;\n                    inertie = mass * (3.0 * 3.0 + 2.0 * 2.0) / 12.0f;\n                    vertexlist[0] = vertex1Cube1;\n                    vertexlist[1] = vertex2Cube1;\n                    vertexlist[2] = vertex3Cube1;\n                    vertexlist[3] = vertex4Cube1;\n                    vertexNumber = 4;\n                }\n            }\n        }\n\n        // staticCube\n        if(fragCoordx == staticenum) {\n            return vec4(staticCube, 0.0, 0.0, 0.0);\n        }\n        \n        // mass\n        if(fragCoordx == massenum) {\n            return vec4(mass, 0.0, 0.0, 0.0);\n        }\n        \n        // inertie\n        if(fragCoordx == inertieenum) {\n            return vec4(inertie, 0.0, 0.0, 0.0);\n        }\n        \n        // vertexnumber\n        if(fragCoordx == vertexnumberenum) {\n            return vec4(vertexNumber, 0.0, 0.0, 0.0);\n        }\n\n        // vertex\n        for(int iv = 0; iv < vertexNumber; ++iv) {\n            if (fragCoordx == vertexlistenum + iv) {\n                return vec4(vertexlist[iv].x, vertexlist[iv].y, 0.0, 0.0);\n            }\n        }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int fragCoordx = int(fragCoord.x);\n    int fragCoordy = int(fragCoord.y);\n    \n    if (fragCoordy >= polygonNumber) {\n    \treturn;\n    }\n    \n    // Données immutables\n    if(fragCoordx < vertexlistenum + 4) {\n        fragColor = handleVertex(fragCoord);\n        return;\n    }\n\n    // Données qui nécessitent d'être récupérer en même tant pour calculer la physique\n    if(fragCoordx >= vertexlistenum + 4 && fragCoordx <= initenum) {\n    \n        for(int polygonIndex = 0; polygonIndex < polygonNumber; ++polygonIndex) {\n            if (fragCoordy != polygonIndex) {\n                continue;\n            }\n\n            int staticCube = int(texelFetch (iChannel0, ivec2(staticenum, polygonIndex),0 ).x);\n            float mass = texelFetch (iChannel0, ivec2(massenum, polygonIndex), 0).x;\n            float inertie = texelFetch (iChannel0, ivec2(inertieenum, polygonIndex), 0).x;\n            \n            int vertexNumber = int(texelFetch (iChannel0, ivec2(vertexnumberenum, polygonIndex), 0).x);\n\n            vec2 vertexlist[4];\n            for(int iv = 0; iv < vertexNumber; ++iv) {\n                vertexlist[iv] = texelFetch (iChannel0, ivec2(vertexlistenum + iv, polygonIndex), 0).xy;\n            }\n            \n            vec2 pos = texelFetch (iChannel0, ivec2(posenum, polygonIndex), 0).xy;\n            float angle = texelFetch (iChannel0, ivec2(angleenum, polygonIndex), 0).x;\n            vec2 speed = texelFetch (iChannel0, ivec2(speedenum, polygonIndex), 0).xy;\n            float angleSpeed = texelFetch (iChannel0, ivec2(angleSpeedenum, polygonIndex), 0).x;\n            int init = int(texelFetch (iChannel0, ivec2(initenum, polygonIndex), 0).x);\n            \n            vec2 diffpos = texelFetch (iChannel1, ivec2(diffposenum, polygonIndex), 0).xy;\n            vec2 diffspeed = texelFetch (iChannel1, ivec2(diffspeedenum, polygonIndex), 0).xy;\n            float diffangularspeed = texelFetch (iChannel1, ivec2(diffangularspeedenum, polygonIndex), 0).x;\n\n            if (init == 0) {\n                if (polygonIndex == 0) {\n                    pos.xy = vec2(3.4, 0.5);\n                    speed.xy = vec2(0.0);\n                    angle = 0.0;\n                    angleSpeed = 0.0;\n                } else {\n                    pos.xy = vec2(1.0 + 5.0 * random(vec2(polygonIndex + 1, polygonIndex + 1)), 2.0 + float(polygonIndex));\n                    speed.xy = vec2(0.0, 0.0);\n                    angle = -1.0 + 2.0 *random(vec2(polygonIndex + 1, polygonIndex + 1));\n                    angleSpeed = 0.0;\n                }\n            }\n            if (staticCube == 0 && inertie != 0.0) {\n                // Euler\n                speed += g * timeElasped; // m/s2 * s => m/s\n                speed += diffspeed; // m/s\n                \n                pos += speed * timeElasped; // m/s * s => m \n\t\t\t\tpos += diffpos; // m\n                \n                angleSpeed += diffangularspeed; // rad/s\n                angle += angleSpeed * timeElasped; // rad => (rad/s) * s \n                \n                if(pos.x < -1.0 || pos.x > 7.0) {\n                \tpos.y = 7.0;\n                \tpos.x = 3.5;\n                    speed.x = 0.0;\n                }\n                \n                if(pos.y < -1.0) {\n                \tpos.y = 7.0;\n                \tpos.x = 3.5;\n                    speed.x = 0.0;\n                }\n            }\n\n            // Position\n            if (fragCoordx == posenum) {\n                fragColor = vec4(pos.x, pos.y, 0.0, 0.0);\n                return;\n\n            // angle\n            } else if (fragCoordx == angleenum) {\n                fragColor = vec4(angle, 0.0, 0.0, 0.0);\n                return;\n\n            // speed\n            } else if (fragCoordx == speedenum) {\n                fragColor = vec4(speed.x, speed.y, 0.0, 0.0);\n                 return;\n\n            // angleSpeed\n            } else if (fragCoordx == angleSpeedenum) {\n                fragColor = vec4(angleSpeed, 0.0, 0.0, 0.0);\n                return;\n\n            // init\n            } else if (fragCoordx == initenum) {\n                fragColor = vec4(1.0, 0.0, 0.0, 0.0);\n                return;\n            }\n    \t}\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"struct Collision {\n\tvec2 axis;\n    float penetration;\n};\n    \nstruct CollisionResult {\n    vec2 diffspeed;\n    float diffangularspeed;\n    vec2 diffpos;\n};\n    \nstruct ContactPoints {\n    vec2 contactPoints[2];\n    int contactNumber;\n};\n\nstruct Polygon {\n    vec2 speed;\n    float mass;\n    float angleSpeed;\n    vec2 position;\n    vec2 vertexList[4];\n    int vertexNumber;\n    float inertie;\n}; \n\nContactPoints FindClosedContactPoints(Polygon polygon, vec2 axis) {\n    ContactPoints contactPoints;\n    vec2 contactPoint[2];\n    int contactNumber = 0;\n        \n    float projection[4];\n    float projectionBest = 10000.0;\n    for(int pointIndex = 0; pointIndex < polygon.vertexNumber; ++pointIndex) {\n        projection[pointIndex] = dot(polygon.vertexList[pointIndex], axis);\n        if(projection[pointIndex] < projectionBest) {\n            projectionBest = projection[pointIndex];\n        }\n    }\n\n    projectionBest += 0.001f;\n    \n    for(int pointIndex = 0; pointIndex < polygon.vertexNumber; ++pointIndex) {\n        if(projection[pointIndex] <= projectionBest) {\n            contactPoint[contactNumber] = polygon.vertexList[pointIndex];\n            ++contactNumber;\n        }\n    }\n    \n    contactPoints.contactPoints = contactPoint;\n    contactPoints.contactNumber = contactNumber;\n    return contactPoints;\n}\n\nbool IsPolygonABeforePolygonB(Polygon polygonA, Polygon polygonB, vec2 axis) {\n    float minAxisA;\n    float maxAxisA;\n    minAxisA = dot(polygonA.vertexList[0], axis);\n    maxAxisA = minAxisA;\n    for(int pointIndex = 1; pointIndex < polygonA.vertexNumber; ++pointIndex) {\n        float value = dot(polygonA.vertexList[pointIndex], axis);\n        if(value < minAxisA) {\n            minAxisA = value;\n        } else if(value > maxAxisA) {\n            maxAxisA = value;\n        }\n    }\n\n    float minAxisB = dot(polygonB.vertexList[0], axis);\n    float maxAxisB = minAxisB;\n    for(int pointIndex = 1; pointIndex < polygonB.vertexNumber; ++pointIndex) {\n        float valueB = dot(polygonB.vertexList[pointIndex], axis);\n        if(valueB < minAxisB) {\n            minAxisB = valueB;\n        } else if(valueB > maxAxisB) {\n            maxAxisB = valueB;\n        }\n    }\n\n    return (minAxisA + maxAxisA) < (minAxisB + maxAxisB);\n}\n\nvec2 GetContactPoint(Polygon polygonA, Polygon polygonB, vec2 axis) {\n    ContactPoints contactPointListA = FindClosedContactPoints(polygonA, axis);\n    ContactPoints contactPointListB = FindClosedContactPoints(polygonB, -axis);\n\n  \tvec2 contactPoint;\n\tif(contactPointListA.contactNumber == 1) {\n\t\tcontactPoint = contactPointListA.contactPoints[0];\n\t} else if(contactPointListB.contactNumber == 1) {\n\t\tcontactPoint = contactPointListB.contactPoints[0];\n\t} else {\n\t\tvec2 axisOrtho = vec2(-axis.y, axis.x);\n\n\t\tint minIndexA;\n\t\tfloat minAxisA = dot(contactPointListA.contactPoints[0], axisOrtho);\n\t\tfloat maxAxisA = dot(contactPointListA.contactPoints[1], axisOrtho);\n        if(minAxisA > maxAxisA) {\n\t\t\tfloat temp = minAxisA;\n\t\t\tminAxisA = maxAxisA;\n\t\t\tmaxAxisA = temp;\n\t\t\tminIndexA = 1;\n\t\t} else {\n\t\t\tminIndexA = 0;\n\t\t}\n        \n\t\tfloat minAxisB = dot(contactPointListB.contactPoints[0], axisOrtho);\n\t\tfloat maxAxisB = dot(contactPointListB.contactPoints[1], axisOrtho);\n\t\tif(minAxisB > maxAxisB) {\n\t\t\tfloat temp = minAxisB;\n\t\t\tminAxisB = maxAxisB;\n\t\t\tmaxAxisB = temp;\n\t\t}\n\n\t\tif(minAxisB < minAxisA && maxAxisA < maxAxisB) {\n\t\t\tcontactPoint = (contactPointListA.contactPoints[0] + contactPointListA.contactPoints[1]) / 2.0;\n\t\t} else if(minAxisA < minAxisB && maxAxisB < maxAxisA) {\n\t\t\tcontactPoint = (contactPointListB.contactPoints[0] + contactPointListB.contactPoints[1]) / 2.0;\n        } else {\n\t\t\tfloat k = (min(maxAxisA, maxAxisB) + max(minAxisA, minAxisB)) / 2.0;\n\t\t\tk -= minAxisA;\n\t\t\tcontactPoint = contactPointListA.contactPoints[minIndexA] + axisOrtho * k;\n        }\n\t}    \n    \n    return contactPoint;\n}\n    \nbool CheckAABBCollision(Polygon polygonA, Polygon polygonB) {\n    // polygonA\n    float minXA = polygonA.vertexList[0].x;\n    float maxXA = minXA;\n    float minYA = polygonA.vertexList[0].y;\n    float maxYA = minYA;\n    for(int index = 1; index < polygonA.vertexNumber; ++index) {\n        minXA = min(polygonA.vertexList[index].x, minXA);\n        maxXA = max(polygonA.vertexList[index].x, maxXA);\n        minYA = min(polygonA.vertexList[index].y, minYA);\n        maxYA = max(polygonA.vertexList[index].y, maxYA);\n    }\n    \n    // polygonB\n    float minXB = polygonB.vertexList[0].x;\n    float maxXB = minXB;\n    float minYB = polygonB.vertexList[0].y;\n    float maxYB = minYB;\n    for(int index = 1; index < polygonB.vertexNumber; ++index) {\n        minXB = min(polygonB.vertexList[index].x, minXB);\n        maxXB = max(polygonB.vertexList[index].x, maxXB);\n        minYB = min(polygonB.vertexList[index].y, minYB);\n        maxYB = max(polygonB.vertexList[index].y, maxYB);\n    }\n    \n    return !(maxXA < minXB\n       || maxXB < minXA\n       || maxYA < minYB\n       || maxYB < minYA);\n}\n\nvec2 Cross(float a, vec2 v) {\n  return vec2(-a*v.y, a*v.x);\n}\n\nfloat Cross(vec2 a, vec2 b) {\n  return a.x * b.y - a.y * b.x;\n}\n\n// http://www.dyn4j.org/2010/01/sat/\nbool CheckPolygonSatCollision(Polygon polygonA, Polygon polygonB, out Collision collision) {\n    vec2 separatingAxis[4];\n    int separatingAxisNumber = 0;\n    for(int index = 0; index < polygonA.vertexNumber; ++index) {\n        vec2 axis;\n        if(index + 1 == polygonA.vertexNumber) {\n            axis = polygonA.vertexList[0] - polygonA.vertexList[index];\n        }\n        else {\n            axis = polygonA.vertexList[index + 1] - polygonA.vertexList[index];\n        }\n\n        // Optimisation : don't take separating axis already added\n        bool axisFound = false;\n        for(int axisIndex = 0; axisIndex < separatingAxisNumber; ++axisIndex) {\n            if(abs(dot(axis, separatingAxis[axisIndex])) < 0.001f) {\n                axisFound = true;\n                break;\n            }\n        }\n\n        // Axis not found : new separating axis\n        if(!axisFound) {\n            vec2 test = vec2(-axis.y, axis.x);\n            float norm = length(test);\n            separatingAxis[separatingAxisNumber] = test / norm;\n            ++separatingAxisNumber;\n        }\n    }\n\n    // Get min/max on the separating axis for the polygonA\n    float minAxisAList[4];\n    float maxAxisAList[4];\n    for(int separatingAxisIndex = 0; separatingAxisIndex < separatingAxisNumber; ++separatingAxisIndex) {\n        minAxisAList[separatingAxisIndex] = dot(polygonA.vertexList[0], separatingAxis[separatingAxisIndex]);\n        maxAxisAList[separatingAxisIndex] = minAxisAList[separatingAxisIndex];\n        for(int pointIndex = 1; pointIndex < polygonA.vertexNumber; ++pointIndex) {\n            float value = dot(polygonA.vertexList[pointIndex], separatingAxis[separatingAxisIndex]);\n            if(value < minAxisAList[separatingAxisIndex]) {\n                minAxisAList[separatingAxisIndex] = value;\n            } else if(value > maxAxisAList[separatingAxisIndex]) {\n                maxAxisAList[separatingAxisIndex] = value;\n            }\n        }\n    }\n    \n    \n    // Get min/max on the separating axis for the polygonB\n    // and compare them to the polygonA\n    collision.penetration = 10000.0;\n    for(int separatingAxisIndex = 0; separatingAxisIndex < separatingAxisNumber; ++separatingAxisIndex) {\n        float minAxisA = minAxisAList[separatingAxisIndex];\n        float maxAxisA = maxAxisAList[separatingAxisIndex];\n\n        float minAxisB = dot(polygonB.vertexList[0], separatingAxis[separatingAxisIndex]);\n        float maxAxisB = minAxisB;\n        for(int pointIndex = 1; pointIndex < polygonB.vertexNumber; ++pointIndex) {\n            float valueB = dot(polygonB.vertexList[pointIndex], separatingAxis[separatingAxisIndex]);\n            if(valueB < minAxisB) {\n                minAxisB = valueB;\n            } else if(valueB > maxAxisB) {\n                maxAxisB = valueB;\n            }\n        }\n\n        // If there is at least a gap, there is no collision\n        if(maxAxisA < minAxisB || maxAxisB < minAxisA) {\n            return false;\n        }\n        \n        float penetration = min(maxAxisA,maxAxisB) - max(minAxisA, minAxisB);\n        if(penetration < collision.penetration) {\n        \tcollision.penetration = penetration;\n\t        collision.axis = separatingAxis[separatingAxisIndex];\n        }\n    }\n    \n    return true;\n}\n\nCollisionResult DoPhysicRepulsion(Polygon polygonA, Polygon polygonB, vec2 contactPoint, vec2 collisionaxis, float collisionpenetration) {\n    CollisionResult collisionResult;\n    \n    // Repulsion, friction    \n    float massInverseSum = (1.0f / polygonA.mass) + (1.0f / polygonB.mass);\n    \n    vec2 rAC = vec2(contactPoint.x - polygonA.position.x, contactPoint.y - polygonA.position.y);\n\tvec2 speedContactPointOnA = polygonA.speed + Cross(polygonA.angleSpeed, rAC); // m/s + m . rad/s => m/s\n\n    vec2 rBC = vec2(contactPoint.x - polygonB.position.x, contactPoint.y - polygonB.position.y);\n\tvec2 speedContactPointOnB = polygonB.speed + Cross(polygonB.angleSpeed, rBC); // m/s + m . rad/s => m/s\n    \n    vec2 speed = speedContactPointOnB - speedContactPointOnA; // m/s\n    float speedNormal = dot(speed, collisionaxis);\n\t// Seulement si les polygones se rentrent dedans\n    if(speedNormal > 0.0f) {\n\t\tfloat valueA = Cross(collisionaxis, rAC);\n\t\tfloat valueB = Cross(collisionaxis, rBC);\n\t\tfloat elasticty = 0.5f;\n\t\tfloat impulse = ((1.0f + elasticty) * speedNormal) / (massInverseSum + (valueA * valueA / polygonA.inertie) + (valueB * valueB / polygonB.inertie));\n \t\t\t\t\t\t\t// (m/s) / ((1/kg) + (m2/s2)/(kg.m2) + ...)\n        \t\t\t\t\t// (m/s) / ((1+s2+s2)/kg))\n                            //    (m.kg)/s\n\t\tvec2 force = collisionaxis * impulse;\n\n\t\tvec2 tangentAxis = speed - collisionaxis * speedNormal;\n\t\tfloat speedTangent = sqrt(tangentAxis.x*tangentAxis.x+tangentAxis.y*tangentAxis.y);\n\t\tif(speedTangent != 0.0f)\n\t\t{\n\t\t\ttangentAxis /= speedTangent;\n\n\t\t\tfloat valueA = Cross(rAC, tangentAxis);\n\t\t\tfloat valueB = Cross(rBC, tangentAxis);\n\t\t\tfloat friction = 0.5f;\n\t\t\tfloat impulseFriction = friction * speedTangent / (massInverseSum + (valueA * valueA / polygonA.inertie) + (valueB * valueB / polygonB.inertie));\n\n\t\t\tforce += tangentAxis * impulseFriction;\n\t\t}\n\n\t\tcollisionResult.diffspeed = force / polygonA.mass; //(kg.m/s)/kg => m/s\n\n\t\tcollisionResult.diffangularspeed = Cross(rAC, force) / polygonA.inertie; // ((kg.m/s).m.rad)/(kg.m2) => (rad/s)\n\t}\n    \n  \tfloat value = collisionpenetration / massInverseSum; // m / (1/kg) => m.kg\n\tcollisionaxis *= value;\n\n    collisionResult.diffpos.x = collisionaxis.x / polygonA.mass; // (m.kg) / kg => m\n    collisionResult.diffpos.y = collisionaxis.y / polygonA.mass; // (m.kg) / kg => m\n\n\treturn collisionResult;\n}\n    \nbool CheckPolygonCollision(Polygon polygonA, Polygon polygonB, out CollisionResult collisionResult) {\n    // Check AABB\n    if (!CheckAABBCollision(polygonA, polygonB)) {\n    \treturn false;\n    }\n    \n    // Computed separating axis theorem\n    Collision collisionA;\n    Collision collisionB;\n    if (!CheckPolygonSatCollision(polygonA, polygonB, collisionA)) {\n    \treturn false;\n    }\n    \n    if (!CheckPolygonSatCollision(polygonB, polygonA, collisionB)) {\n    \treturn false;\n    }\n    \n    Collision collision;\n\n    if (collisionA.penetration <= collisionB.penetration) {\n        collision.axis = collisionA.axis;\n\t\tcollision.penetration = collisionA.penetration;\n    } else {\n        collision.axis = collisionB.axis;\n\t\tcollision.penetration = collisionB.penetration;\n    }\n\n    // Check if we need to inverse the normal\n    bool isPolygonABeforePolygonB = IsPolygonABeforePolygonB(polygonA, polygonB, collision.axis);\n    if (isPolygonABeforePolygonB) {\n        collision.axis = -collision.axis;\n    } else {\n        collision.axis = collision.axis;\n    }\n    \n    // Find the contact point\n    // https://www.gamedev.net/forums/topic.asp?topic_id=453179\n    vec2 contactPoint = GetContactPoint(polygonA, polygonB, collision.axis);\n\n    CollisionResult cr = DoPhysicRepulsion(polygonA, polygonB, contactPoint, collision.axis, collision.penetration);\n    collisionResult.diffspeed = cr.diffspeed;\n    collisionResult.diffangularspeed = cr.diffangularspeed;\n    collisionResult.diffpos = cr.diffpos;\n\n    return true;\n}\n\nPolygon GetInfoPolygon(in sampler2D channel, int polygonIndex) {\n    Polygon polygon;\n    \n    vec2 position = texelFetch (channel, ivec2(posenum, polygonIndex), 0).xy;\n    polygon.position = position;\n\n    int vertexNumber = int(texelFetch (channel, ivec2(vertexnumberenum, polygonIndex), 0).x);\n    polygon.vertexNumber = vertexNumber;\n\n    float mass = texelFetch (channel, ivec2(massenum, polygonIndex), 0).x;\n    polygon.mass = mass;\n\n    vec2 speed = texelFetch (channel, ivec2(speedenum, polygonIndex), 0).xy;\n    polygon.speed = speed;\n\n    float angleSpeed = texelFetch (channel, ivec2(angleSpeedenum, polygonIndex), 0).x;\n    polygon.angleSpeed = angleSpeed;\n\n\n    float inertie = texelFetch (channel, ivec2(inertieenum, polygonIndex), 0).x;\n    polygon.inertie = inertie;\n\n    float angle = texelFetch (channel, ivec2(angleenum, polygonIndex), 0).x;\n\n    float cosan = cos(angle);\n    float sinan = sin(angle);\n\n    for(int vertexindex = 0; vertexindex < vertexNumber; ++vertexindex) {\n        vec2 vt = texelFetch (channel, ivec2(vertexlistenum + vertexindex, polygonIndex), 0).xy;\n\n        vec2 pt = vec2(\n            vt.x * cosan - vt.y * sinan,\n            vt.x * sinan + vt.y * cosan);\n\n        vec2 pos = vec2(position.x + pt.x, position.y + pt.y);\n        polygon.vertexList[vertexindex] = pos;\n    }\n    \n    return polygon;\n}\n\nCollisionResult CheckCollision(int polygonIndexToCheck) {\n    Polygon mypoly = GetInfoPolygon(iChannel0, polygonIndexToCheck);\n    \n    vec2 diffpos = vec2(0.0, 0.0);\n    vec2 diffspeed = vec2(0.0, 0.0);\n    float diffangularspeed = 0.0;\n    vec2 contactpoint;\n    for(int polygonIndex = 0; polygonIndex < polygonNumber; polygonIndex++) {\n        if (polygonIndex == polygonIndexToCheck) {\n            continue;\n        }\n        \n        Polygon poly = GetInfoPolygon(iChannel0, polygonIndex);\n\n        CollisionResult collisionResult;\n        if (CheckPolygonCollision(mypoly, poly, collisionResult)) {\n            diffpos += collisionResult.diffpos;\n            diffspeed += collisionResult.diffspeed;\n            diffangularspeed += collisionResult.diffangularspeed;\n        }\n    }\n    CollisionResult collisionResult;\n    collisionResult.diffpos = diffpos;\n    collisionResult.diffspeed = diffspeed;\n    collisionResult.diffangularspeed = diffangularspeed;\n    return collisionResult;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int fragCoordx = int(fragCoord.x);\n    int fragCoordy = int(fragCoord.y);\n    \n    if (fragCoordy >= polygonNumber) {\n        return;\n    }\n    \n    if (fragCoordx > diffangularspeedenum) {\n    \treturn;\n    }\n    \n    for(int polygonIndex = 0; polygonIndex < polygonNumber; ++polygonIndex) {\n        if (fragCoordy != polygonIndex) {\n            continue;\n        }\n        \n        if(fragCoordx == diffposenum) {\n            CollisionResult collisionResult = CheckCollision(polygonIndex);\n            fragColor = vec4(collisionResult.diffpos.x, collisionResult.diffpos.y, 0.0, 0.0);\n            return;\n        }\n        \n        if(fragCoordx == diffspeedenum) {\n            CollisionResult collisionResult = CheckCollision(polygonIndex);\n            fragColor = vec4(collisionResult.diffspeed.x, collisionResult.diffspeed.y, 0.0, 0.0);\n            return;\n        }\n        \n        if(fragCoordx == diffangularspeedenum) {\n            CollisionResult collisionResult = CheckCollision(polygonIndex);\n            fragColor = vec4(collisionResult.diffangularspeed, 0.0, 0.0, 0.0);\n            return;\n        }\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float timeElasped = 0.01;\n\nvec2 g = vec2(0, -9.81); // m/s2 ou N/kg\n\nint staticenum = 0;\nint massenum = 1;\nint inertieenum = 2;\nint vertexnumberenum = 3;\nint vertexlistenum = 4;\nint posenum = 8; //(vertexlistenum+4)\nint angleenum = 9;\nint speedenum = 10;\nint angleSpeedenum = 11;\nint initenum = 12;\n\nint diffposenum = 0;\nint diffspeedenum = 1;\nint diffangularspeedenum = 2;\n\nint polygonNumber = 30;\n\nbool sdLine( in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    if(length( pa - ba*h ) <= 0.02) {\n    \treturn true;\n    }\n    return false;\n}","name":"Common","description":"","type":"common"}]}