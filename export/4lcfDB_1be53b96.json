{"ver":"0.1","info":{"id":"4lcfDB","date":"1540818769","viewed":4795,"name":"Octahedral Voxel Tracing","username":"fizzer","description":"Raytracing octahedron-shaped voxels with analytic intersections.","likes":107,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","voxel","octahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Similarly to https://www.shadertoy.com/view/XdSyzK, this ray traversal works\n// by finding the nearest octahedron in a certain irregular octahedron tessellation\n// and testing the ray against the inner sides of that octahedron.\n\n// The method of finding the nearest octahedron in this type of arrangement is\n// re-used from my own article here: http://amietia.com/slashmaze.html\n\n#define AA 2 // Anti-aliasing factor\n\nfloat time;\n\n// Camera path\nvec2 path(float z)\n{\n    vec2 p = vec2(0);\n    p.x += cos(z / 4.) * 2. * sin(z / 6.) * .7 + cos(z / 2. + sin(z * .5) / 2.) * 3. * sin(z / 5.);\n    p.y += sin(z / 3.) * 2. + cos(z / 5.) / 3. + sin(z / 5. + cos(z * 1.) / 3.) * 3.;\n    return p;\n}\n\n// Voxel solid/empty function\nfloat f(vec3 p)\n{\n    vec3 op = p;\n    p.xy += path(p.z);\n    float d = -(length(p.xy) - 4.);\n    op.z = mod(op.z, 21.) - 10.5;\n    return d + cos(p.x * 80.) + cos(p.y * 180.);\n}\n\n// Traces a ray\nfloat trace(vec3 ro, vec3 rd, float maxt)\n{\n    vec3 p = ro, c, ofs;\n    vec3 n;\n\n    for(int i = 0; i < 64; ++i)\n    {\n        // Snap to nearest octahedron\n        vec3 cp = fract(p) - .5; \n        vec3 acp = abs(cp); \n        ofs = step(acp.yzx, acp) * step(acp.zxy, acp) * sign(cp); \n        c = floor(p) + .5 + ofs * .5;\n\n        // If this octahedron is solid then break out\n        if(f(c) < 0.)\n            break;\n\n        // Get the 4 side plane normals that the ray is facing\n        vec3 n0 = ofs + ofs.yzx;\n        vec3 n1 = ofs - ofs.yzx;\n        vec3 n2 = ofs + ofs.zxy;\n        vec3 n3 = ofs - ofs.zxy;\n\n        // Dot product of ray direction with side normals\n        float d0 = dot(rd, n0);\n        float d1 = dot(rd, n1);\n        float d2 = dot(rd, n2);\n        float d3 = dot(rd, n3);\n\n        // Get intersection distances\n        float t0 = (sign(d0) * .5 - dot(ro - c, n0)) / d0;\n        float t1 = (sign(d1) * .5 - dot(ro - c, n1)) / d1;\n        float t2 = (sign(d2) * .5 - dot(ro - c, n2)) / d2;\n        float t3 = (sign(d3) * .5 - dot(ro - c, n3)) / d3;\n\n        float mint = min(t0, min(t1, min(t2, t3)));\n        \n        // Update current point along ray\n        p = ro + rd * (mint + 1e-3);\n        \n        if(mint > maxt)\n            break;\n    }\n\n    return distance(p, ro);\n}\n\nvec3 image(vec2 fragCoord)\n{\n    vec4 fragColor;\n    \n    // Set up primary ray direction\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    vec2 t = uv.xy;\n    t.x *= iResolution.x / iResolution.y;\n      \n    vec3 ro = vec3(0., 0., -time) + 1e-3, rd = normalize(vec3(t, 1.1));\n    vec3 targ = ro;\n\n    targ.z -= 4.;\n\n    // Offset ray origin and camera target by path displacement\n    ro.xy -= path(ro.z);\n    targ.xy -= path(targ.z);\n\n    // Camera coordinate system\n    vec3 dir = normalize(targ - ro);\n    vec3 left = normalize(cross(dir, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(left, dir));\n\n    rd = rd.z * dir + rd.x * left + rd.y * up;\n\n    // Trace primary ray\n    float dist = trace(ro, rd, 100.);\n    vec3 p = ro + rd * dist, n;\n\n    // Snap to nearest octahedron\n    vec3 cp = fract(p) - .5; \n    vec3 acp = abs(cp); \n    vec3 ofs = step(acp.yzx, acp) * step(acp.zxy, acp) * sign(cp); \n    vec3 c = floor(p) + .5 + ofs * .5;\n\n    // Get surface normal\n    vec2 u = vec2(dot(p - c, ofs.yzx), dot(p - c, ofs.zxy));\n    u = step(abs(u).yx, abs(u)) * sign(u);\n    n = normalize(u.x * ofs.yzx + u.y * ofs.zxy + sign(dot(p - c, ofs)) * ofs);\n\n    // Directional shadow ray direction\n    vec3 ld = normalize(vec3(1, 2, 3)) * 1.5;\n\n    fragColor.a = 1.;\n    \n    // Distance darkening and directional light cosine term\n    fragColor.rgb = vec3(exp(-dist / 5.) * pow(.5 + .5 * dot(n, normalize(ld)), 2.));\n\n    // Colour selection\n    float cs = (.5 + cos(c.z * 4. + 5. + c.x + c.y * 7.) * .5);\n    \n    // Apply colour\n    fragColor.rgb *= mix(vec3(1),\n                         mix(vec3(.1), vec3(1, .4, .15), step(.66, cs)), step(.33,cs));\n    \n    // Darkening at octahedron edges\n    float edges = \tsmoothstep(0.01, .02, abs(dot(p - c, ofs))) *\n        \t\t\tsmoothstep(0.01, .02, abs(dot(p - c, ofs.yzx + ofs.zxy))) *\n        \t\t\tsmoothstep(0.01, .02, abs(dot(p - c, ofs.yzx - ofs.zxy)));\n        \n    fragColor.rgb *= mix(.5, 1., edges);\n\n    // Trace directional shadow ray\n    float st = trace(p + n * 2e-3, ld, length(ld) * 2.);\n\n    // Apply (attenuated) directional shadow\n    fragColor.rgb *= mix(.2, 1., clamp(st / length(ld), 0., 1.));\n    \n    // Fake AO\n    fragColor.rgb *= 1. - smoothstep(2., 5.8, distance(p.xy, -path(p.z)));\n\n    // Specular highlight\n    fragColor.rgb *= 1. + pow(clamp(dot(normalize(ld), reflect(rd,n)), 0., 1.), 8.) * 4.;\n\n    // Texture map\n    vec2 tu;\n    tu.x = dot(p, ofs.yzx) / 2.;\n    tu.y = dot(p, ofs.zxy) / 2.;\n    fragColor.rgb *= pow(texture(iChannel0,tu).r, 1.5) * 1.1;\n    \n    // Fog\n    fragColor.rgb = mix(vec3(.5), fragColor.rgb, exp(-dist / 1000.));\n\n\treturn fragColor.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n\n    fragColor.rgb = vec3(0);\n    \n    // Multisampling loop\n    for(int y = 0; y < AA; ++y)\n\t    for(int x = 0; x < AA; ++x)\n        {\n            // Jittered time for motionblur\n    \t\ttime = iTime - texelFetch(iChannel1, ivec2(mod(fragCoord * float(AA) + vec2(x, y), 1024.)), 0).r * .02;\n    \t\tfragColor.rgb += image(fragCoord + vec2(x, y) / float(AA));\n        }\n    \n    fragColor.rgb /= float(AA * AA);\n    \n    // Vignette\n    fragColor.rgb *= 1. - (pow(abs(uv.x), 5.) + pow(abs(uv.y), 5.)) * .3;\n    \n    // Tonemapping\n    fragColor.rgb /= (fragColor.rgb + vec3(.4)) * .5;\n    \n    // Gamma\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n}\n\n\n","name":"Image","description":"","type":"image"}]}