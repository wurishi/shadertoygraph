{"ver":"0.1","info":{"id":"XsyGRy","date":"1455847086","viewed":226,"name":"Igloos","username":"abs","description":"Snow and igloos\n\nWASD + mouse navigation\nR to reset position","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","clouds","mountains","snow","wind","igloo","village","firstpersoncamera"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Gradient + Depth-Based FXAA\n#define THRESHOLD 0.8\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 scal = 1. / iChannelResolution[0].xy;\n \tvec2 uv = fragCoord / iChannelResolution[0].xy;\n    vec4 col = texture(iChannel0, uv);\n\t\n    // get neighbors\n    vec4 nw = texture(iChannel0, uv + vec2(-1.0,-1.0) * scal);\n    vec4 ne = texture(iChannel0, uv + vec2(1.0,-1.0) * scal);\n    vec4 se = texture(iChannel0, uv + vec2(1.0,1.0) * scal);\n    vec4 sw = texture(iChannel0, uv + vec2(-1.0,1.0) * scal);\n  \n    // weight towards green channel, then red, then blue\n    vec3 lumaWeight = vec3(0.22, 0.66, 0.11);\n    float colLuma = dot(col.xyz, lumaWeight);\n    float nwLuma = dot(nw.xyz, lumaWeight); \n    float neLuma = dot(ne.xyz, lumaWeight);\n    float seLuma = dot(se.xyz, lumaWeight); \n    float swLuma = dot(sw.xyz, lumaWeight);\n              \n    // gradient based off of luminance\n    vec2 gradL = vec2(-(neLuma + seLuma) + (nwLuma + swLuma),\n                     -(seLuma + swLuma) + (neLuma + nwLuma));\n   \t// gradient based off of distance\n    vec2 gradD = vec2(-(ne.w + se.w) + (nw.w + sw.w),\n                      -(se.w + sw.w) + (ne.w + nw.w));\n    \n    // average bordering pixels if either luminance or distance threshold exceeds threshold\n    if(length(gradD) > THRESHOLD || length(gradL) > THRESHOLD ){\n        vec4 n = texture(iChannel0, uv + vec2(0.0,-1.0) * scal);\n    \tvec4 s = texture(iChannel0, uv + vec2(0.0,1.0) * scal);\n    \tvec4 e = texture(iChannel0, uv + vec2(1.0,0.0) * scal);\n    \tvec4 w = texture(iChannel0, uv + vec2(-1.0,0.0) * scal);\n        fragColor = (nw + ne + se + sw + n + s + e + w + col) / 9.0;\n    }\n    else{\n        fragColor = col;    \n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec2 txPosition = vec2(0.0, 0.0);\nconst vec2 txVelocity = vec2(1.0, 0.0);\nconst vec2 txAcceleration = vec2(2.0, 0.0);\nconst vec2 txTime = vec2(3.0, 0.0);\nconst vec2 txState = vec2(4.0, 0.0);\nconst vec2 txGoalVelocity = vec2(5.0, 0.0);\nconst vec2 txLook = vec2(6.0, 0.0);\n\nconst float PI = 3.1415926;\n\nconst float KEY_W = 87.5/256.0;\nconst float KEY_A = 65.5/256.0;\nconst float KEY_S = 83.5/256.0;\nconst float KEY_D = 68.5/256.0;\nconst float KEY_R = 82.5/256.0;\n\nfloat inside(vec2 p, vec2 c) { \n    vec2 d = abs(p - 0.5 - c) - 0.5; \n    return -max(d.x , d.y); \n}\n\nbool onKeyPress(float key){\n\treturn texture(iChannel1, vec2(key, 0.0)).x > 0.0;\n}\n\nvec4 load(in vec2 tx){\n    return texture(iChannel0, (0.5 + tx) / iChannelResolution[0].xy);\n}\n\nvoid store(in vec2 tx, in vec4 value, inout vec4 fragColor, in vec2 fragCoord){\n    fragColor = (inside(fragCoord, tx) > 0.0 ) ? value : fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){   \n    vec4 position = load(txPosition);\n    vec4 velocity = load(txVelocity);\n    vec4 acceleration = load(txAcceleration);\n    vec4 goalVelocity = load(txGoalVelocity);\n    float state = load(txState).x;\n    float oldTime = load(txTime).x;\n    float time = iTime;\n    vec4 look = load(txLook);\n    \n    if(iFrame == 0) state = 0.0;\n    \n    if(state == 0.0){\n   \t\tstate = 1.0;\n        position = vec4(-2.0, 1.5, 3.5, 0.0);\n        velocity = vec4(0.0);\n        acceleration = vec4(0.0);\n        goalVelocity = vec4(0.0);\n        oldTime = iTime;\n        look = vec4(0);\n    }\n    \n    if(state == 1.0){\n        vec2 mouse = iMouse.xy / iResolution.xy;\n        if(mouse == vec2(0)) {\n        \tmouse = vec2(-0.175, 0.47);\n        }\n\t    float yaw = mouse.x * 2.0 * PI;\n    \tfloat pitch = (mouse.y) * 1.0 * PI - PI / 2.0;\n    \tlook = vec4(cos(yaw), sin(pitch), sin(yaw), 0.0); // world space camera location\n        vec4 dir = normalize(look);\n        vec4 perp = vec4(dir.z, 0, -dir.x, 0);\n        perp = normalize(perp);\n        if(onKeyPress(KEY_W)){\n        \tvelocity += dir * 1.0;\n        }\n        if(onKeyPress(KEY_S)){\n         \tvelocity -= dir * 1.0;   \n        }\n        if(onKeyPress(KEY_A)){\n         \tvelocity += perp * 1.0;   \n        }\n        if(onKeyPress(KEY_D)){\n         \tvelocity -= perp * 1.0;\n        }\n        if(onKeyPress(KEY_R)){\n        \tposition = vec4(-2.0, 1.5, 3.5, 0.0);\n        }\n        float deltaTime = time - oldTime;\n        vec4 acceleration = vec4(0.0);\n        acceleration = 3.0 * (goalVelocity - velocity);\n        velocity += acceleration * deltaTime;\n        position += velocity * deltaTime;\n    }\n\t\n    fragColor = vec4(0.0);\n    \n    store(txPosition, position, fragColor, fragCoord);\n    store(txVelocity, velocity, fragColor, fragCoord);\n    store(txAcceleration, acceleration, fragColor, fragCoord);\n    store(txTime, vec4(time, 0.0, 0.0, 0.0), fragColor, fragCoord);\n    store(txState, vec4(state, 0.0, 0.0, 0.0), fragColor, fragCoord);\n    store(txGoalVelocity, goalVelocity, fragColor, fragCoord);\n    store(txLook, look, fragColor, fragCoord);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define CLOUDS 1\n#define WIND 1\n\nconst vec2 txPosition = vec2(0.0, 0.0);\nconst vec2 txLook = vec2(6.0, 0.0);\n\nconst float SPHERE_RADIUS = 0.5;\nconst int STEPS = 300;\nconst float TMIN = 0.0;\nconst float TMAX = 65.0;\nconst float PI = 3.1415926;\nconst float THRESHOLD = 0.0001;\nconst float EPS = 0.00001;\n\nconst vec3 SPHERE_POS = vec3(0, -SPHERE_RADIUS + 0.1, 0);\nconst vec3 LIGHT_COLOR = vec3(1.0, 0.9, 0.9);\nconst vec3 SNOW_COLOR = vec3(0.7, 0.7, 1.0);\nconst vec3 DIR_LIGHT = \tnormalize(vec3(0.5, 1.0, 0.5));\n\nvec3 rotateX(vec3 p, float angle){\n\tvec3 q = p;\n    q.y = cos(angle) * p.y - sin(angle) * p.z;\n    q.z = sin(angle) * p.y + cos(angle) * p.z;\n    return q;\n}\n\nvec3 rotateY(vec3 p, float angle){\n\tvec3 q = p;\n    q.x = cos(angle) * p.x + sin(angle) * p.z;\n    q.z = -sin(angle) * p.x + cos(angle) * p.z;\n    return q;\n}\n\nvec3 rotateZ(vec3 p, float angle){\n\tvec3 q = p;\n    q.x = cos(angle) * p.x - sin(angle) * p.y;\n    q.y = sin(angle) * p.x + cos(angle) * p.y;\n    return q;\n}\n\nfloat plane(vec3 p){\n\treturn p.y;\n}\n\nfloat sphere(vec3 p, float r){\n\treturn length(p) - r;\n}\n\nfloat cylinder(vec3 p, float r, float h){\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat box( vec3 p, vec3 b )\n{\n\treturn length(max(abs(p)-b,0.0));\n}\n\nfloat ellipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat displacement(float primitive, float disp){\n    return primitive + disp;\n}\n\nfloat blend(float p1, float p2, float k){\n    float h = clamp( 0.5+0.5*(p2-p1)/k, 0.0, 1.0 );\n    return mix(p2, p1, h ) - k*h*(1.0-h);\n}\n\nfloat sub(float p1, float p2){\n    return max(p1, -p2);\n}\n\nfloat add(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat intersect(float d1, float d2) {\n    return max(d1, d2);\n}\n\nvec2 propose(vec2 val, vec2 pVal){\n    return (pVal.x < val.x) ? pVal : val;\n}\n\nfloat noise(vec2 p, int seed){\n    float n = dot(vec3(p, seed), vec3(67.0, 121.0, 113.0));\n\treturn fract(sin(n) * 11137.7543);   \n}\n\nfloat noise(vec3 p, int seed){\n \tfloat n = dot(vec4(p, seed), vec4(67.0, 121.0, 113.0, 257.0));\n    return fract(sin(n) * 11137.7654);\n}\n\nfloat interpolatedNoise2D(vec2 xy, int seed){\n    vec2 p = floor(xy);\n    vec2 f = fract(xy);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix(noise(p, seed), noise(vec2(p.x + 1.0, p.y), seed), f.x), \n               mix(noise(vec2(p.x, p.y + 1.0), seed), noise(vec2(p.x + 1.0, p.y + 1.0), seed),f.x), f.y);\n}\n\nfloat interpolatedNoise3D(vec3 xyz, int seed){\n    vec3 p = floor(xyz);\n    vec3 f = fract(xyz);\n    f = f*f*(3.0-2.0*f);\n    \n    return  mix(mix(mix(noise(p, seed), noise(vec3(p.x + 1.0, p.y, p.z), seed), f.x), \n               mix(noise(vec3(p.x, p.y + 1.0, p.z), seed), noise(vec3(p.x + 1.0, p.y + 1.0, p.z), seed),f.x), f.y),\n        \tmix(mix(noise(vec3(p.x, p.y, p.z + 1.0), seed), noise(vec3(p.x + 1.0, p.y, p.z + 1.0), seed), f.x), \n               mix(noise(vec3(p.x, p.y + 1.0, p.z + 1.0), seed), noise(vec3(p.x + 1.0, p.y + 1.0, p.z + 1.0), seed),f.x), f.y), f.z);\n}\n\nfloat perlinNoise2D(vec2 xy, float freq, float amp, const int octaves, int seed){\n    float total = 0.0;\n    float freq_curr = freq;\n    float amp_curr = amp;\n    for(int i = 0; i < 5; i++){\n        if(i > octaves) break;\n        total += interpolatedNoise2D(vec2(abs(xy.x) * freq_curr, abs(xy.y) * freq_curr), seed) * amp_curr;\n        freq_curr *= 2.0;\n        amp_curr /= 2.0;\n    }\n    return (total + amp) / (2.0);\n}\n\nfloat perlinNoise3D(vec3 xyz, float freq, float amp, const int octaves, int seed){\n    float total = 0.0;\n    float freq_curr = freq;\n    float amp_curr = amp;\n    for(int i = 0; i < 5; i++){\n        if(i > octaves) break;\n        total += interpolatedNoise3D(vec3(abs(xyz.x) * freq_curr, abs(xyz.y) * freq_curr, abs(xyz.z) * freq_curr), seed) * amp_curr;\n        freq_curr *= 2.0;\n        amp_curr /= 2.0;\n    }\n    return (total + amp) / (2.0);\n}\n\n\nfloat igloo(in vec3 pos){\n    float iggy = sub(sphere(pos - SPHERE_POS, SPHERE_RADIUS), sphere(pos - SPHERE_POS, 0.9 * SPHERE_RADIUS));\n    float entranceBig = cylinder(rotateZ(pos - SPHERE_POS + vec3(-0.5, 0.075, 0), PI/2.0), 0.175, 0.1);\n    float entranceSmall = cylinder(rotateZ(pos - SPHERE_POS + vec3(-0.5, 0.075, 0), PI/2.0), 0.125, 0.11);\n    float entrance = sub(entranceBig, entranceSmall);\n    float igloo = sub(iggy, entranceBig);\n    igloo = add(igloo, entrance);\n\treturn igloo;\n}\n\nfloat snowMap(in vec3 pos, float isBump){\n    float a = smoothstep(0.0, 5.5, length(pos + vec3(1, -5, 1.5)));\n    float bump = perlinNoise2D(pos.xz, 2.0, 0.07, 4, 82);\n\n    return perlinNoise2D(pos.xz, 0.115, a, 3, 0) + bump*step(0.5, isBump);\n}\n\nfloat sledMap(in vec3 pos, float h){\n    float bottom = ellipsoid(pos + vec3(0.25, -h - 0.07, -1.4), vec3(0.04, 0.06, 0.01));\n\tfloat top = ellipsoid(pos + vec3(0.25, -h - 0.27, -1.4), vec3(0.04, 0.06, 0.01));\n    float sled = blend(bottom, top, 0.035);\n    float hole = ellipsoid(pos + vec3(0.25, -h - 0.25, -1.4), vec3(0.03, 0.04, 0.03));\n    float nut = ellipsoid(pos + vec3(0.25, -h - 0.25, -1.4), vec3(0.02, 0.02, 0.01));\n    float cut = sub(sled, hole);\n    sled = blend(cut, nut, 0.001);\n    return sled;\n}\n\nvec2 snow(in vec3 pos){\n    vec2 res = vec2(TMAX, -1.0);\n   \n\tfloat h = snowMap(pos, 0.0);\n\n    res = propose(res, vec2(pos.y - h, 3.0));\n\n    res = propose(res, vec2(igloo(pos + vec3(0.0, -h - SPHERE_RADIUS, 0.0)), 2.0));\n    res = propose(res, vec2(igloo(pos + vec3(1.0, -h - SPHERE_RADIUS, 1.0)), 2.0));\n    res = propose(res, vec2(igloo(pos + vec3(0.0, -h - SPHERE_RADIUS, 2.0)), 2.0));\n    res = propose(res, vec2(igloo(pos + vec3(-2.0, -h - SPHERE_RADIUS, 1.0)), 2.0));\n    \n    res = propose(res, vec2(cylinder(rotateX(pos + vec3(0.25, -h - 0.07, -1.0), -PI/25.), 0.013, 0.14), 5.0));\n    res = propose(res, vec2(cylinder(rotateZ(pos + vec3(0.2, -h - 0.07, 1.4), PI/20.), 0.013, 0.14), 5.0));\n    res = propose(res, vec2(cylinder(rotateZ(pos + vec3(-0.1, -h - 0.07, 1.4), -PI/20.), 0.01, 0.14), 5.0));\n    res = propose(res, vec2(cylinder(pos + vec3(0.2, -h - 0.07, 1.0), 0.01, 0.14), 5.0));\n\n\tres = propose(res, vec2(sledMap(pos + vec3(0.5, 0.1, -0.2), h), 6.0));\n    res = propose(res, vec2(sledMap(pos + vec3(0.37, 0.1, -0.2), h), 6.0));\n    res = propose(res, vec2(sledMap(pos + vec3(0.25, 0.1, -0.18), h), 6.0));\n    res = propose(res, vec2(sledMap(pos + vec3(0.13, 0.1, -0.23), h), 6.0));\n    \n    return res;\n}\n\nfloat mountainMap(in vec3 pos, float isBump){\n    float ma = 12.0 * smoothstep(0.0, 100.0, length(pos));\n    float m =  perlinNoise2D(pos.xz, 0.15, ma, 3, 0);\n    \n\tfloat bump = perlinNoise2D(pos.xz, 2.0, 0.1, 4, 52); \n    return m + bump*step(0.5, isBump);\n\n}\n\nvec2 mountains(in vec3 pos){\n    float m = mountainMap(pos, 0.0);\n\treturn vec2(pos.y - m, 4.0);   \n}\n\nfloat cloudMap(in vec3 pos){\n   vec3 temp = pos - iTime*vec3(0.4, 0.0, 0.0);\n\n   return max(perlinNoise3D(temp, 0.5, 2.0, 3, 435) - \n               perlinNoise3D(temp, 0.1, 1.9, 3, 50)-.15, 0.0);\n}\n\nfloat wind(in vec3 p)\n{\n    p -= vec3(5.0, 2.0, 5.0) * iTime;\n    return max(perlinNoise3D(p*.03, 2., 0.1, 3, 10) + \n               perlinNoise3D(p*.03, 2.5, 0.01, 3, 100) -.12, 0.0);\n}\n\nvec4 clouds(in vec3 ro, in vec3 rd)\n{\n\tvec4 tot = vec4(0.0);\n\n\tfloat t = 0.0;\n\tfor(int i = 0; i < 200; i++){ \n        vec3  pos = ro + t*rd; \n        float d = cloudMap(pos) * smoothstep(0.0, 40.0, pos.y);\n        if(d > EPS) {\n             vec3 diff = mix(vec3(0.5, 0.5, 1.0), vec3(0.5), d);\n             vec4 col = vec4(diff, d);\n             col.rgb *= col.a * 0.2;\n             tot += col*(1.0-tot.a);\n        }\n        t += max(0.1, 0.03*t);\n        if( tot.a > 0.99 || t > TMAX) break;\n    }\n    return clamp(tot, 0.0, 1.0);\n}\n\nvec2 map(in vec3 pos){\n    vec2 res = vec2(TMAX, -1.0);\n\tres = propose(res, snow(pos));\n    res = propose(res, mountains(pos));\n    return res;\n}\n\nvec2 raycast(in vec3 ro, in vec3 rd, out float w){\n    float t = TMIN;\n    float mat = -1.0;\n    w = 0.0;\n    for(int i = 0; i < STEPS; i++){\n        vec3 pos = ro + rd * t;\n    \tvec2 res = map(pos);\n        t += res.x;\n        mat = res.y;\n        #if WIND\n        \tw += wind(pos);\n        #endif\n        if(t > TMAX || res.x < THRESHOLD) break;\n    }\n    w = min(w, 1.0);\n    if(t > TMAX) mat = -1.0;\t\n    return vec2(t, mat);\n}\n\nfloat shadows(in vec3 ro, in vec3 rd){\n    float t = 0.1;\n    float res = 1.0;\n    for( int i = 0; i < 16; i++ )\n    {\n\t\tfloat h = map(ro + rd * t).x;\n        res = min(res, 2.0 * h / t);\n        t += clamp(h, 0.01, 0.012);\n        if(t > 2.5 || h < THRESHOLD) break;\n    }\n    return clamp(res, 0.3, 1.0);\n}\n\nvec3 normal(in vec3 pos){\n    vec3 eps = vec3(EPS, 0, 0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n    nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n    nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n    return normalize(nor);\n}\n\nfloat dirLightDiffuse(vec3 nor, vec3 lightDir){\n    return clamp(dot(nor, lightDir), 0.2, 1.0);\n}\n\nfloat dirLightSpec(vec3 nor, vec3 lightDir, vec3 rd, float shiny){\n\treturn clamp(pow(clamp(dot(reflect(rd, nor), lightDir), 0.0, 1.0), shiny), 0.0, 1.0);    \n}\n\nvec3 sky(vec3 rd){\n    vec3 col = vec3(0.6, 0.35, 0.8) * (1.0 - 0.99 * rd.y) * 0.6;\n    col = mix( col, vec3(0.7, 0.75 ,0.9), pow(1.0 - 0.99 * rd.y, 12.0));\n    return col;\n}\n\nvec4 getColor(vec3 pos, vec3 nor, vec3 rd, vec2 res, float w){\n    vec3 col = vec3(0);\n    vec3 diffuseCol = vec3(0);\n    float mat = res.y;\n    if(res.x > TMAX){\n        res.x = TMAX;\n        col = sky(rd);   \n    }\n    else{\n        if(mat == 2.0){\n            vec2 uv = vec2(atan(nor.x, nor.z), acos(nor.y));\n            nor += 0.1*texture(iChannel2, uv).xyz;\n            nor = normalize(nor);\n            diffuseCol += 0.3 * texture(iChannel2, uv).yzz + 0.7*SNOW_COLOR;\n        }\n        else if(mat == 3.0){\n            nor.y = pos.y - snowMap(pos, 1.0);\n            nor.x = pos.y - snowMap(pos + vec3(EPS, 0, 0), 1.0) - nor.y;\n            nor.z = pos.y - snowMap(pos + vec3(0, 0, EPS), 1.0) - nor.y;\n            nor.y = EPS;\n            nor = normalize(nor);\n\n            vec3 snowCol = vec3(0.9, 0.9, 1.0);\n            float diffuse = dirLightDiffuse(nor, DIR_LIGHT);\n\n            diffuseCol += (0.1 + (0.2 * dirLightSpec(nor, DIR_LIGHT, rd, 2.0) + 0.5 * diffuse)) * snowCol;\n            diffuseCol += 0.18 * sky(reflect(rd, nor));\n            diffuseCol += 0.5 * diffuse * vec3(1.0, 1.25, 1.3) * pow(clamp(1.0 + dot(nor, rd), 0.01, 1.0), 2.0);\n            diffuseCol = clamp(diffuseCol, 0.0, 1.0);\n        }\n        else if (mat == 4.0){\n            nor.y = pos.y - mountainMap(pos, 1.0);\n            nor.x = pos.y - mountainMap(pos + vec3(EPS, 0, 0), 1.0) - nor.y;\n            nor.z = pos.y - mountainMap(pos + vec3(0, 0, EPS), 1.0) - nor.y;\n            nor.y = EPS;\n            nor = normalize(nor);\n            diffuseCol = vec3(0.1, 0.1, 0.24);\n            diffuseCol = mix(diffuseCol, vec3(1.0), smoothstep(1.0, 11.0, pos.y));\n        }\n        else if(mat == 5.0){\n         \tdiffuseCol = vec3(0.8, 0.3, 0.3);   \n        }\n        else if(mat == 6.0){\n         \tvec2 uv = vec2(atan(nor.x, nor.z), acos(nor.y));\n            diffuseCol += 0.4 * texture(iChannel1, uv).yzz + 0.7*vec3(0.3, 0.4, 1.0);\n        }\n        else{\n            diffuseCol = vec3(0.0);\n        }\n        float dld = dirLightDiffuse(nor, DIR_LIGHT) * shadows(pos, DIR_LIGHT);\n        float dls = 0.5*dirLightSpec(nor, DIR_LIGHT, rd, 20.0);\n\n        col += vec3(0.1);\n        vec3 light = clamp((diffuseCol + dls) * LIGHT_COLOR, 0.0, 1.0);\n        col += clamp(dld * light, 0.0, 1.0);\n\t\tcol = mix(vec3(0.5), col, exp(-0.001 * pow(res.x , 1.3)));\n        col = mix(col, vec3(0.7), w);\n    }\n\t\treturn vec4(col, res.x);\n}\n\nvec4 render( in vec3 ro, in vec3 rd )\n{ \n    float w = 0.0;\n\tvec2 res = raycast(ro, rd, w);\n    vec3 pos = ro + rd * res.x;\n    vec3 nor = normal(pos);\n    vec4 col = vec4(0);\n\tcol = getColor(pos, nor, rd, res, w);\n    #if CLOUDS\n  \t\tvec4 clo = clouds(ro, rd);\n    \tcol.xyz = col.xyz * (1.0 - clo.w) + clo.xyz;\n    #endif\n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // camera\n    vec3 eye = texture( iChannel0, (txPosition+0.5)/iChannelResolution[0].xy).xyz;\n\n    vec3 look = texture( iChannel0, (txLook+0.5)/iChannelResolution[0].xy).xyz;\n\tvec3 up = vec3( 0.0, 1.0, 0.0 ); // up axis of world\n\tfloat d = 3.5; // distance between eye and focal plane\n    \n    vec3 w = normalize(look);\n\tvec3 u = normalize(cross(w,up));\n\tvec3 v = normalize(cross(u,w));\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv; // pixel space of the focal plane\n    p.x *= iResolution.x/ iResolution.y;\n    vec3 rd = normalize( p.x * u + p.y * v + d * w );\n    vec4 col = render( eye, rd );\n    col.xyz = pow(clamp(col.xyz, 0.0, 1.0), vec3(0.8));\n\n    fragColor= col;\n}","name":"Buf B","description":"","type":"buffer"}]}