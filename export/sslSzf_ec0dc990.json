{"ver":"0.1","info":{"id":"sslSzf","date":"1619005462","viewed":126,"name":"Question about shadows!","username":"julianlumia","description":"When I run this shader on my macbook without a second monitor attached the shadows look good, but when I plug in a second display the whole shader gets darker more contrasted colors and a very vissible glitch appears in the shadows at some point. whatsup?","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["question"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FAR 20.\n\n\nfloat smin(float a, float b, float k)\n{\n     float h = clamp (0.5+0.5*(b-a)/k,0.,1.);\n     return mix(b, a, h) - k*h*(1.0-h);\n        \n        \n}\nmat2 Rot (float a)\n{\n            \n    float s = sin(a);\n\tfloat c = cos(a);\n    return mat2(c,-s,s,c);\n            \n}\n\nvec3 doTwist(in vec3 p)\n{\n\tfloat f = sin(iTime)*1.;\n\tfloat c = cos(f*p.y);\n\tfloat s = sin(f*p.y);\n\tmat2  m = mat2(c,-s,s,c);\n\treturn vec3(p.y,m*p.xz);\n}\n\nvec3 doTwist2(in vec3 p)\n{\n\tfloat f = sin(iTime)*.5;\n\tfloat c = cos(f*p.y);\n\tfloat s = sin(f*p.y);\n\tmat2  m = mat2(c,-s,s,c);\n\treturn vec3(p.y,m*p.xz);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\t\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat g1;\nfloat g2;\nfloat g3;\n\nfloat g4;\n\n\nfloat map (vec3 p)\n{\n  vec3 p2 = p;  \n  float gap = 1.;\np2.x = mod(p.x + gap,2.0 * gap) - gap;\n  \n   vec3 q = fract(p ) * 2. - 1.;\n   vec3 q2 = p;\n   q2.xz= fract(p.xz ) * 2. - 1.;\n\n   vec3 s = vec3(1.,.05,1.);\n   \n   float bd3= length (max (abs((q2))-s,0.)); \n    \n    vec3 boxQ = q;\n    boxQ += vec3(0.,0.5,0.);\n    vec3 s6 = vec3(0.1,2.,.1); \n    \n    float bd6= length (max (abs((q2-vec3(.0,.0,-.0)))-s6,0.)); \n    \n  \n    vec3 torusQ = q;\n    torusQ -= vec3(0.0,0.95,0);\n    float torus = sdTorus(torusQ,vec2(.90,0.5));\n    \n    \n    vec3 torusQ2 = q;\n    torusQ2 += vec3(0.0,0.95,0);\n    float torus2 = sdTorus(torusQ2,vec2(.90,0.5));\n\n    vec3 s2 = vec3(.05,.01,1.);\n    vec3 i = q;\n    i +=.0;\n     float bd4= length (max (abs(doTwist2(i))-s2,0.)); \n        float sp = sdSphere(q-vec3(0.,0.,0.),.6);\n \n    //circle\n   float sd5;\n   float x = sin(iTime);\n   abs (x);\n   sd5 = length(q) -.5;\n \n   float smbd = min(bd3,sp);\n\n   g1 +=(sin(iTime))+p.z*.2/(.1+pow(abs(sp),10.));\n   g2 +=1./(0.2+pow(abs(bd3),5.));\n\n\n    return smbd;\n     \n}\n\n\n\n float GetDist (vec3 p) \n    {\n      \n     \tfloat d;\n        \n        return  d ;\n    }\n    \n\n\nfloat trace(vec3 o, vec3 r)\n{\n float t = 0.0,d;\n    for(int i=0; i< 128; i++){\n    vec3 p = o + r * t;\n   \n        float d = map(p);\n   \n     \n        if(abs(d)<.00001 || t>FAR) break;        \n        \n        t += d*.6; \n    }\n    return t;\n}\n\n//second trace for reflections\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i = 0; i < 100; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.0001 || t>FAR) break;\n        \n        t += d*.9; \n    }\n    \n    return t;\n}\n\n//3rd trace for reflections\nfloat traceRef2(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i = 0; i < 60; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.0005 || t>FAR) break;\n        \n              t += d*1.; \n\n    }\n    \n    return t;\n}\n\nfloat traceRef3(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i = 0; i < 5; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.00001 || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return t;\n}\n\nfloat traceRef4(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i = 0; i < 3; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.00001 || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return t;\n}\n\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    const int maxIterationsShad = 50; \n    \n    vec3 rd = (lp-ro);\n\n    float shade = .5;\n    float dist = .050;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n    \n        shade = min(shade, smoothstep(0., 1., k*h/dist)); \n\n        dist += clamp(h, .5, .0);\n        \n        if (h<0. || dist > end) break; \n    }\n\n    return min(max(shade, 0.) + .1, 1.); \n}\n\n\n\nvec3 getObjectColor(vec3 p){\n    \n    vec3 col = vec3(1);\n   \n    if(fract(dot(floor(p), vec3(.4))) > .1) col = vec3(.5, .1, 0.);\n    if(fract(dot(floor(p), vec3(.4))) > .6) col = vec3(.5, .0, 0.5);\n    if(fract(dot(floor(p), vec3(.3))) > .8) col = vec3(0., .2, 1.);\n    return col;\n    \n}\n\n\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t){\n    \n    vec3 ld = lp-sp;\n    float lDist = max(length(ld), .001);\n    ld /= lDist;\n    \n    float atten = 1. / (1. + lDist*.5 + lDist*lDist*.1);\n   \n    float diff = max(dot(sn, ld), 0.5);\n \n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 6.);\n\n    vec3 objCol = getObjectColor(sp);\n\n    vec3 sceneCol = (objCol*(diff + .15) + vec3(1., 1., 1.)*spec*1.) * atten;\n    \n    \n    float fogF = smoothstep(0., .3, t/FAR);\n \n    sceneCol = mix(sceneCol, vec3(0), fogF); \n\n\n    return sceneCol;\n    \n}\n\n\n\n\nvec3 getNormal( in vec3 p ){\n\n  \n    vec2 e = vec2(.00035, -.00035); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec2 uv = fragCoord/iResolution.xy;\n\t\t\n    uv = uv * 2.0 - 1.0;\n\t\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv,2.));\n \n    float the = iTime *0.25;\n    r.xz *= Rot(-the);\n    vec3 o = vec3(.2,.5,1.);\n    o.xz *= Rot(the);\n    float t = trace(o,r);\n    \n    vec3 lp = o + vec3(0., 1., 0.5);\n    \n    o += r*t;\n    \n    vec3 sn = getNormal(o);\n\n   vec3 col = vec3(0);\n\n\n     col = abs(vec3(-0.2,.8*uv.y,1.)+.1);\n    \n    float t5 = t;\n    \n    \n    vec3 sceneColor = doColor(o, r, sn, lp, t );\n    \n    sceneColor = mix(col, sceneColor,.5)  ;\n    \n    \n    float sh;\n    \n//reflections:\n//--- pass 1\nr = reflect(r, sn);\n  \n    t = traceRef(o +  r*.01, r);\n     \n    o += r*t;\n    \n    sn = getNormal(o);\n    \n    sceneColor += doColor(o, r, sn, lp, t)*3.5;\n//--- pass 2\n    r = reflect(r, sn);\n    sh += softShadow(o, lp,2.)*.5;\n   \n   t = traceRef2(o +  r*.01, r);\n    o += r*t;\n\n    sn = getNormal(o);\n    \n    \n   sceneColor += doColor(o, r, sn, lp, t)*2.;\n    \n        sceneColor = mix(col, sceneColor,.9)  ;\n\n//---  pass 3\n      r = reflect(r, sn);\n     sh += softShadow(o, lp,3.)*.2;\n\n    t = traceRef3(o +  r*0.01, r);\n    o += r*t;\n    \n    sn = getNormal(o);\n    \n    \n   sceneColor += doColor(o, r, sn, lp, t)*1.0;\n    \n    \n    sceneColor = mix(col, sceneColor,.9)  ;\n\n\n\n//--- pass 4\n \n    r = reflect(r, sn);\n    t = traceRef4(o +  r*.8, r);\n    o += r*t;\n    \n    \n    \n sceneColor += doColor(o, r, sn, lp, t)*.3;\n //---\n \n \nsceneColor +=g2*vec3(0.00015)*vec3(0.,3.,0.);   \n\n\n    \n    \n    sceneColor *= sh;\n    \n    \n    float fog = 1. / (2. + t * t * .1);\n    \n    vec3 fc = vec3(fog);\n    \n    sceneColor *= fc;\n    sceneColor*=1.5;\n    \n    fragColor = vec4(sqrt(clamp(sceneColor, 0.,1.)), t5);\n    \n    \n}","name":"Image","description":"","type":"image"}]}