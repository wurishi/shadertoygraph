{"ver":"0.1","info":{"id":"wtBczh","date":"1696519068","viewed":133,"name":"Hex Lattice 2D","username":"spalmer","description":"a simple voxel system based on hexagonal lattice","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["grid","hexagon","minimal","lattice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* */\n\n// just inline everything.  384 ch and counting!  almost codegolf territory now.\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    mat2 M = // triangle lattice transform rotates and scales hexagons\n        //1. * (mat2(1) + .5 * (sqrt(3.) - 1.)) // diagonal\n        //.7 * mat2(.5 * sqrt(3.), .5, 0, 1) // flat top\n        .7 * mat2(1, 0, .5, .5 * sqrt(3.)) // flat side\n        ;\n    vec2 r = iResolution.xy;\n    float s = 15./r.y;\n    vec2 q = s * u * M,\n        i = floor(q), h = i, f = q - i;\n    int z = (int(i.s) + int(i.t)) % 3; if (z < 0) z += 3;\n    if (z > 0) if (z > 1) ++h[int(f.s < f.t)]; else ++h; // -15 ch vs. switch and saves a comparison sometimes\n    float d = abs(f.s - f.t);\n    vec2 a = abs(q - h);\n    d = min(z != 2 ? 1. - d : d, 1. - max(a.s, a.t));\n    o = sqrt(min(d * .25 / s, 1.) * (sin(.9 / s * d) * .1 + .9) \n      * (cos(vec4(0,2,4,6) + (h.s + 99. * h.t) * 1.76) * .3 + .7));\n}\n\n// I have a feeling the golfing has only just begun though\n\n    //u -= 1e2; // stress negative coords\n    \n    // just do this in integer arithmetic, \n    // but int modulo has funky negative number behavior\n    //if (z > 1) ++h[int(f.s < f.t)]; else if (z > 0) ++h; // -14 ch vs. switch\n    \n    //ivec3 w = ivec3(i, i.s + i.t) % 3;\n    //switch (z < 0 ? 2 - z : z) { // handle silly -%  ... wth, this was working, I swear!   Did my gpu change overnight?\n    //switch (z < 0 ? 3 + z : z) { // handle silly -%  .. still not working.\n    //    //default: break;\n    //    case 1: ++h; break;\n    //    case 2: ++h[int(f.s < f.t)]; break;\n    //} // switch is still wordy tho\n    //if ((z < 0 ? z = 2 - z : z) != 0)\n    //    if (z < 2) ++h;\n    //    else ++h[int(f.s < f.t)]; // -14 ch\n    //int z = int(mod(i.s + i.t, 3.)); // easy but apparently works only for smaller floats\n\n    //ivec3 w = ivec3(mod(vec3(i, i.s + i.t), 3.));\n    //switch (w.z) { //(w.x + w.y) % 3) {\n    //    case 0: break;\n    //    case 1: ++h; break;\n    //    case 2: ++h[int(f.s < f.t)]; break;\n    //}\n    // ok I guess that is better!  :D\n    //switch (w.x + 3 * w.y) {\n    //    default: break;\n    //    case 2: case 4: case 6: ++h[int(f.s < f.t)]; break;\n    //    case 1: case 3: case 8: ++h; break;\n    //}\n\n/* * /\n\n// at 662 ch, it's not exactly golfed, but it's a good minimal example involving minimal operations\n\n// skew coordinate to hexagon/triangle lattice\n// there's a few ways to do this, and it's needed for both pixel and mouse\n\n// but we ultimately must warp both to and from this skewed lattice coordinate system;\n// for a matrix mat2 just use inverse intrinsic, otherwise it's much more awkward.\nconst float F2 = .5 * (sqrt(3.) - 1.); //.366 //\nconst mat2 M =\n    //mat2(1) + F2 // medium diagonal\n    //.71 * (mat2(1) + F2) // large diagonal\n    //1.4 * (mat2(1) + F2) // small diagonal\n    //mat2(.5 * sqrt(3.), .5, 0, 1) // flat top hex, large\n    //mat2(sqrt(3.), 1, 0, 2) // flat top hex, small\n    mat2(1, 0, .5, .5 * sqrt(3.)) // flat side hex, large\n    //mat2(2, 0, 1, sqrt(3.)) // flat side hex, small\n    //mat2(1) // leave square\n    ;\n\n// find hex center given position, input and output both in triangle lattice so, UV.\n// In glsl, can't use .uv as swizzle but can use .st to distinguish from .xy   :)\n// You will notice that a hex grid repeats in both U and V every 3 cells,\n// regarding which way a subcell rounds toward the nearest hexagon cell center,\n// which is a point on the triangle grid lattice.  So I make a kind of 9-entry LUT.\n// there is probably a more clever way to decompose this operation.\n// one thing to note is that the resulting table is symmetrical along diagonal.\n// Most folks do compare squared distances to two candidate centers, so this seems less wasteful.\nvec2 H(vec2 q)\n{\n    vec2 i = floor(q);\n    switch (int(mod(i.s, 3.) + 3. * mod(i.t, 3.))) {\n        default: break; //case 0: case 5: case 7: break; //\n        case 2: case 4: case 6: ++i[int(q.s-i.s < q.t-i.t)]; break;\n        case 1: case 3: case 8: ++i; break;\n    }\n    return i;\n}\n// the switch seems a bit wordy for golfing\n\n// interior distance to cell wall, voronoi cell edge distance\n// TODO should probably merge with the cell decomposition as some of the data is recomputed there in H fn\n// should just require input q to be relative to center h already, do in caller\nfloat D(vec2 q, vec2 h)\n{\n    vec2 i = floor(q), f = q - i;\n    float d = abs(f.s - f.t);\n    // another mod by 3, can be done in concert with the other 2 in H()\n #if 1\n    q -= h;\n    if (int(mod(i.s + i.t, 3.)) != 2)\n        d = 1.-d;\n    vec2 a = abs(q);\n    return min(d, 1.-max(a.s, a.t));\n #elif 1\n    if (int(mod(i.s + i.t, 3.)) != 2)\n        d = 1.-d;\n    vec2 a = abs(q - h);\n    return min(d, 1.-max(a.s, a.t));    //return min(d, min(1.-a.s, 1.-a.t)); //\n #else\n    if (int(mod(i.s + i.t, 3.)) == 2)\n        d = 1.-d; // gets undone later, so can be merged; needs more optimization\n    vec2 a = abs(q - h);\n    d = max(d, max(a.s, a.t));\n    return 1.-d; // shift iso to outside of hexagon (don't need for triangles)\n #endif\n}\n\n// demands integer inputs for sensible results; just use on result of H() and things will be fine.\nfloat Id(vec2 i)\n{\n    //i = floor(i); // should have already been done, but do again to be sure for now\n    return i.s + 500.*i.t; // TODO improve; this isn't the important part\n}\n\n// starting over, trying to summarize all these various approaches and distill the core essence.\n// in other words, golf attempt number N + 1 ensues!\nvoid mainImage(out vec4 o, vec2 u)\n{\n    vec2 r = iResolution.xy;\n    //vec2 b = .3*r; // exercise negative inputs\n    //b += 2.*iTime; // stress AA\n    //u -= b; // shift everything, u in shifted screen space\n    float s = 15./r.y; // tiling scale\n    vec2 q = s * u * M, // q is in triangular skewed UV coordinates where U and V are not orthogonal\n      h = H(q); // skewed center position\n    //vec2 c = h * inverse(M); // unused\n    float d = D(q, h);\n    o = vec4(clamp(d * .25 / s, 0., 1.) * mix(sin(.9/s*d), 1., .9)); //.6*iTime + \n    float id = Id(h);\n    // mouse debugging duplicates much code  :(  trim for golfing?\n//    vec2 m = s * (iMouse.xy - b) * M,\n//      mh = H(m);\n//    o *= clamp(length(u - mh * inverse(M)/s) - .125/s, 0., 1.);\n    //if (id != Id(mh))\n    o *= cos(vec4(0,2,4,6) + id * 1.7358) * .3 + .7; // colorize cells by id; surprisingly finicky\n    o = sqrt(o); // gamma\n}\n\n//vec2 S(vec2 q)\n//{\n//    q = q * M; // via matrix; I'm still used to hlsl operand order  :shrug:  why can't everyone agree on conventions!  ;)\n//    // I don't have inverses for these handy although they're not too hard, I'm lazy and the matrix inverse is easy in glsl.\n//    //q += (q.x + q.y) * F2; // hex skew diagonally, result not aligned with either x or y of viewport\n//    //q.y =  q.y*sqrt(3.) + q.x; q.x *= 2.; // flat side hex, small\n//    //q.y = (q.y*sqrt(3.) + q.x) * .5; // flat side hex, large\n//    //q.x =  q.x*sqrt(3.) + q.y; q.y *= 2.; // flat top hex, small\n//    //q.x = (q.x*sqrt(3.) + q.y) * .5; // flat top hex, large\n//    return q;\n//}\n\n/* * /\n\n// fork of FabriceNeyret2's Logarithmic Moebius Spiral 11 at http://shadertoy.com/view/tt2yRz\n\n// I simplified it down to just the hexagonal voxel on plane part\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    const mat2 M = mat2(1, 0, .5, .5*sqrt(3.));\n    vec2 R = iResolution.xy,\n         U = (u - .5*R) / R.y,\n         z = fwidth(U),\n         I;\n    U *= 12.5*M; // scale\n    I = floor(U); U = fract(U); \n    float s = float(U.x-U.y > 0.), v,   // parallelogram = 2 triangles\n          i = mod(I.x + I.y , 3.), id; \n    I += i==0. ? vec2(0) : i==1. ? vec2(1) : vec2(s, 1.-s);\n    id = I.x + 7.81*I.y; // FIXME can we get an integer here please?\n    vec4 V = vec4(1.-2.*abs(U.x-U.y), abs(U*2.-1.), 0);\n    v = V[i<2. ? 2-int(i+s)%2 : 0];\n    U = i==0. ? U : i==1. ? 1.-U : s==0. ? vec2(U.x, U.y-1.) : vec2(1.-U.x, -U.y);\n    U *= inverse(M); // back to screen space\n    O  = smoothstep(.7, -.7, (length(U)-.95) / (abs(z.x-z.y) > 1. ? .1 : 2.*z.y))\n        * (.6 + .6 * cos( id  + vec4(0,23,21,0)));         // color\n    //if (fract(iTime/6.)<.4)\n      O += smoothstep(-.7, .7, (v-.97) / 20./z.y);  // draw AA tiles\n}\n    // FIXME what's that junk in the tile center?  something about v isn't quite right\n\n/* */\n\n/* * /\n// TODO I should reconsider based on what folks are doing w swizzled cube coordinates, clever stuff:\n\n// Branchless (Suslik, http://shadertoy.com/view/Dddfz7)\nvec3 CubeToHex(vec3 pcube)\n{\n    vec3 i = round(pcube),\n      d = abs(i - pcube);\n    return mix(i, -i.yzx - i.zxy, step(d.yzx, d) * step(d.zxy, d));\n}\n\n// alternative formulation, 3 floor + 3 round:\n// http://justinpombrio.net/programming/2020/04/28/pixel-to-hex.html\nvec3 CubeToTri(vec3 pcube)\n{\n    return floor(pcube - pcube.zxy);\n}\n\nvec3 TriToHex(vec3 ptri)\n{\n    return round((ptri - ptri.yzx) / 3.);\n}\n\n/* */\n\n// TODO bring to Hex Lattice Golf (still private) http://shadertoy.com/view/DdfyW8\n// see also Nano Hex http://www.shadertoy.com/view/Wt3XWN\n// see also Suslik's tiling http://shadertoy.com/view/cdKyz3 and new http://shadertoy.com/view/Dddfz7\n// see also Shane's Minimal http://shadertoy.com/view/Xljczw\n// see also jt's grouped http://shadertoy.com/view/cdcyRH\n// see also FordPerfect's http://shadertoy.com/view/dtySDy\n// a nice resource that I did not use here http://redblobgames.com/grids/hexagons/","name":"Image","description":"","type":"image"}]}