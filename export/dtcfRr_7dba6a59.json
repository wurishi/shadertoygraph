{"ver":"0.1","info":{"id":"dtcfRr","date":"1700865355","viewed":56,"name":"Dynamic SDF evaluation by tape","username":"Fl0wless","description":"This is a proof-of-concept tape evaluator for having dynamic objects without recompiling the shader.\nThe op tape and constants are generated externally with a small f-rep kernel.\nAlso dual numbers are used to get the exact gradient.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","dualnumbers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/// Constants and tape ops generated by script, can both be read from a texture\nfloat consts[9] = float[9] (\n1.5, 1.0, 1.0, 2.0, 0.0, 1.0, 1.0, 0.0, 0.1\n);\n\nconst int ops[180] = int[180] (\n0, 0, -1, -1,\n1, 4, -1, -1,\n11, 1, -1, -1,\n4, 0, 2, -1,\n0, 1, -1, -1,\n10, 1, -1, -1,\n9, 5, -1, -1,\n4, 4, 6, -1,\n2, 3, 7, -1,\n8, 8, -1, -1,\n1, 5, -1, -1,\n3, 9, 10, -1,\n4, 0, 5, -1,\n4, 4, 2, -1,\n2, 12, 13, -1,\n8, 14, -1, -1,\n1, 6, -1, -1,\n3, 15, 16, -1,\n6, 11, 17, -1,\n1, 7, -1, -1,\n6, 11, 19, -1,\n4, 20, 20, -1,\n6, 17, 19, -1,\n4, 22, 22, -1,\n2, 21, 23, -1,\n12, 24, -1, -1,\n14, 18, 25, 18,\n4, 0, 0, -1,\n4, 4, 4, -1,\n2, 27, 28, -1,\n12, 29, -1, -1,\n1, 0, -1, -1,\n3, 30, 31, -1,\n1, 2, -1, -1,\n3, 0, 33, -1,\n4, 34, 34, -1,\n1, 3, -1, -1,\n3, 4, 36, -1,\n4, 37, 37, -1,\n2, 35, 38, -1,\n12, 39, -1, -1,\n1, 1, -1, -1,\n3, 40, 41, -1,\n7, 32, 42, -1,\n7, 26, 43, -1\n);\n\n/// Per-pixel tape evaluation\nfloat eval(vec2 p) {\n    float slots[ops.length()/4];\n    for(int i = 0; i < ops.length(); i++) {\n        int op = ops[4*i];\n        int arg1 = ops[4*i+1];\n        int arg2 = ops[4*i+2];\n        int arg3 = ops[4*i+3];\n        switch (op) {\n            case 0: // LoadParam\n            slots[i] = p[arg1];\n            break;\n            \n            case 1: // LoadConst\n            slots[i] = consts[arg1];\n            break;\n            \n            case 2: // Add\n            slots[i] = slots[arg1] + slots[arg2];\n            break;\n            \n            case 3: // Sub\n            slots[i] = slots[arg1] - slots[arg2];\n            break;\n            \n            case 4: // Mul\n            slots[i] = slots[arg1] * slots[arg2];\n            break;\n            \n            case 5: // Div\n            slots[i] = slots[arg1] / slots[arg2];\n            break;\n            \n            case 6: // Max\n            slots[i] = max(slots[arg1], slots[arg2]);\n            break;\n            \n            case 7: // Min\n            slots[i] = min(slots[arg1], slots[arg2]);\n            break;\n            \n            case 8: // Abs\n            slots[i] = abs(slots[arg1]);\n            break;\n            \n            case 9: // Neg\n            slots[i] = -slots[arg1];\n            break;\n            \n            case 10: // Sin\n            slots[i] = sin(slots[arg1]);\n            break;\n            \n            case 11: // Cos\n            slots[i] = cos(slots[arg1]);\n            break;\n            \n            case 12: // Sqrt\n            slots[i] = sqrt(slots[arg1]);\n            break;\n            \n            case 13: // ==0.0?\n            slots[i] = slots[arg1] == 0.0 ? slots[arg2] : slots[arg3];\n            break;\n            \n            case 14: // >0.0?\n            slots[i] = slots[arg1] > 0.0 ? slots[arg2] : slots[arg3];\n            break;\n            \n            case 15: // <0.0?\n            slots[i] = slots[arg1] < 0.0 ? slots[arg2] : slots[arg3];\n            break;\n            \n            case 16: // >=0.0?\n            slots[i] = slots[arg1] >= 0.0 ? slots[arg2] : slots[arg3];\n            break;\n            \n            case 17: // <= 0.0?\n            slots[i] = slots[arg1] <= 0.0 ? slots[arg2] : slots[arg3];\n            break;\n        }\n    }\n    return slots[ops.length() / 4 - 1];\n}\n\nvec3 dual_const(float f) {\n    return vec3(f, 0.0, 0.0);\n}\n\nvec3 dual_x(float f) {\n    return vec3(f, 1.0, 0.0);\n}\n\nvec3 dual_y(float f) {\n    return vec3(f, 0.0, 1.0);\n}\n\nvec3 dual_abs(vec3 d) {\n    if(d.x == 0.0) {\n        return vec3(0.0, d.yz);\n    }\n    return vec3(\n        abs(d.x),\n        (d.x / abs(d.x)) * d.yz);\n}\n\nvec3 dual_sqrt(vec3 d) {\n    float v = sqrt(d.x);\n    float dx = (d.x == 0.0 && d.y == 0.0) ? 0.0 : (d.y / (2.0 * v));\n    float dy = (d.x == 0.0 && d.z == 0.0) ? 0.0 : (d.z / (2.0 * v));\n    return vec3(v, dx, dy);\n}\n\nvec3 dual_sin(vec3 d) {\n    return vec3(sin(d.x), d.yz * cos(d.x));\n}\n\nvec3 dual_cos(vec3 d) {\n    return vec3(cos(d.x), -d.yz * sin(d.x));\n}\n\nvec3 dual_max(vec3 a, vec3 b) {\n    return vec3(max(a.x, b.x), a.x >= b.x ? a.yz : b.yz);\n}\n\nvec3 dual_min(vec3 a, vec3 b) {\n    return vec3(min(a.x, b.x), a.x <= b.x ? a.yz : b.yz);\n}\n\nvec3 dual_add(vec3 a, vec3 b) {\n    return a + b;\n}\n\nvec3 dual_sub(vec3 a, vec3 b) {\n    return a - b;\n}\n\nvec3 dual_mul(vec3 a, vec3 b) {\n    return vec3(a.x * b.x, b.x * a.yz + a.x * b.yz);\n}\n\nvec3 dual_div(vec3 a, vec3 b) {\n    return vec3(a.x / b.x, (b.x * a.yz - a.x * b.yz) / (b.x * b.x));\n}\n\nvec3 dual_neg(vec3 d) {\n    return -d;\n}\n\n/// Per-pixel 2D dual number tape evaluation\nvec3 eval_dual(vec2 p) {\n    vec3 slots[ops.length()/4];\n    for(int i = 0; i < ops.length(); i++) {\n        int op = ops[4*i];\n        int arg1 = ops[4*i+1];\n        int arg2 = ops[4*i+2];\n        int arg3 = ops[4*i+3];\n        switch (op) {\n            case 0: // LoadParam\n            if(arg1 == 0) {\n                slots[i] = dual_x(p.x);\n            } else if (arg1 == 1) {\n                slots[i] = dual_y(p.y);\n            } else {\n            discard;\n            }\n            break;\n            \n            case 1: // LoadConst\n            slots[i] = dual_const(consts[arg1]);\n            break;\n            \n            case 2: // Add\n            slots[i] = dual_add(slots[arg1], slots[arg2]);\n            break;\n            \n            case 3: // Sub\n            slots[i] = dual_sub(slots[arg1], slots[arg2]);\n            break;\n            \n            case 4: // Mul\n            slots[i] = dual_mul(slots[arg1], slots[arg2]);\n            break;\n            \n            case 5: // Div\n            slots[i] = dual_div(slots[arg1], slots[arg2]);\n            break;\n            \n            case 6: // Max\n            slots[i] = dual_max(slots[arg1], slots[arg2]);\n            break;\n            \n            case 7: // Min\n            slots[i] = dual_min(slots[arg1], slots[arg2]);\n            break;\n            \n            case 8: // Abs\n            slots[i] = dual_abs(slots[arg1]);\n            break;\n            \n            case 9: // Neg\n            slots[i] = dual_neg(slots[arg1]);\n            break;\n            \n            case 10: // Sin\n            slots[i] = dual_sin(slots[arg1]);\n            break;\n            \n            case 11: // Cos\n            slots[i] = dual_cos(slots[arg1]);\n            break;\n            \n            case 12: // Sqrt\n            slots[i] = dual_sqrt(slots[arg1]);\n            break;\n            \n            case 13: // ==0.0?\n            slots[i] = slots[arg1].x == 0.0 ? slots[arg2] : slots[arg3];\n            break;\n            \n            case 14: // >0.0?\n            slots[i] = slots[arg1].x > 0.0 ? slots[arg2] : slots[arg3];\n            break;\n            \n            case 15: // <0.0?\n            slots[i] = slots[arg1].x < 0.0 ? slots[arg2] : slots[arg3];\n            break;\n            \n            case 16: // >=0.0?\n            slots[i] = slots[arg1].x >= 0.0 ? slots[arg2] : slots[arg3];\n            break;\n            \n            case 17: // <= 0.0?\n            slots[i] = slots[arg1].x <= 0.0 ? slots[arg2] : slots[arg3];\n            break;\n        }\n    }\n    return slots[ops.length() / 4 - 1];\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Fixed aspect ratio coords\n    vec2 uv = fragCoord/iResolution.xy;\n    float scale = 10.0;\n    uv = (uv * scale) - vec2(scale * 0.5);\n    uv.y *= iResolution.y/iResolution.x;\n    \n    // Animate radius and rotation angle, as a crutch instead of a dynamic texture\n    consts[0] = 1.0 + 0.5 * cos(iTime);\n    consts[4] = iTime * 0.1;\n\n    vec3 v = eval_dual(uv);\n    float d = v.x * 0.5; // / length(v.yz); //  / scale;\n    // float d = eval(uv);\n    \n    // SDF visualization by iq, with gradient as color\n    vec3 col = vec3(0.0);\n    float px = 2.0/iResolution.y;\n    col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    // col = (d>0.0) ? vec3(1.0) : vec3(0.0);\n    col *= 1.0 - exp2(-24.0*abs(d));\n    col *= 0.8 + 0.2*cos(120.0*abs(d));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(-px,px,abs(d)-0.005) );\n  \n    col = mix(col, vec3(v.yz, 1.0), 0.5);\n  \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}