{"ver":"0.1","info":{"id":"WdtyW7","date":"1601047725","viewed":182,"name":"Raymarching w/ConeTracingPrePass","username":"bekorn","description":"Optimization technique from https://twitter.com/SebAaltonen/status/978189264520441856\n\nGallery: https://imgbox.com/g/iwb3INIUc4","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["optimization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raymarched 3D Voronoi without optimizations:\n// https://www.shadertoy.com/view/wljcDW\n\n\n// ! config is in the Common Tab\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 prepass_uv = (fragCoord - 0.5) / PREPASS_SCALE / iResolution.xy;\n    vec4 prepass = texture(iChannel0, prepass_uv);\n\t\n    if (SHOW_PRE_PASS)\n    {\n        fragColor = prepass;\n        return;\n    }\n\t\n    vec2 uv = (fragCoord - iResolution.xy / 2.) / iResolution.y;\n    vec2 normalized_mouse = iMouse.xy / iResolution.xy - 0.5;\n\t\n    vec3 color;\n    \n    vec3 ray_origin, ray_dir;\n    setRay(uv, ray_origin, ray_dir);\n\t\n    float prepass_dist = prepass.w;\n\n\tif (SHOW_STEP_COUNT)\n    {\n        float _stepCount = RayMarchStepCount(ray_origin, ray_dir, USE_PREPASS ? prepass_dist : 0., iTime);\n\n        const vec4 _low = vec4(0, 1, 0, 1);\n        const vec4 _mid = vec4(0, 0, 1, 1);\n        const vec4 _high = vec4(1, 0, 0, 1);\n\n        // TODO: choose a way, dynmic or static ranges\n        const float _MAX_STEPS_LOW = 8.; //float(MAX_STEPS) / 4.;\n        const float _MAX_STEPS_MID = 32.; //float(MAX_STEPS) / 2.;\n        const float _MAX_STEPS_HIGH = 128.; //float(MAX_STEPS);\n\n        if (_stepCount < _MAX_STEPS_LOW)\n            fragColor = mix(vec4(0), _low, _stepCount / _MAX_STEPS_LOW);\n        else if (_stepCount < _MAX_STEPS_MID)\n            fragColor = mix(_low, _mid, (_stepCount - _MAX_STEPS_LOW) / (_MAX_STEPS_MID - _MAX_STEPS_LOW));\n        else\n            fragColor = mix(_mid, _high, (_stepCount - _MAX_STEPS_MID) / (_MAX_STEPS_HIGH - _MAX_STEPS_MID));\n\n        return;\n    }\n\n    float dist = RayMarchDist(ray_origin, ray_dir, USE_PREPASS ? prepass_dist : 0., iTime);\n\n    if (dist > MAX_DIST)\n    {\n        color = vec3(1, 1, 0.4);\n    }\n    else\n    {\n        vec3 p = ray_origin + ray_dir * dist;\n        \n        vec3 n = GetNormal(p, iTime);\n        vec3 surface_color = GetSceneColor(p, iTime);\n\n        vec3 to_light = normalize(light_pos - p);\n        color = (dot(n, to_light) + 0.2) * surface_color * 1.1;\n\n        //\tsimple fog, puts contrast between front and back\n        color *= smoothstep(-1.5, 0.5, p.z);\n    }\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Config\n\nconst int MAX_STEPS = 128;\nconst float MAX_DIST = 100.;\nconst float MIN_DIST = .001;\n\nconst bool USE_PREPASS \t\t= bool(1);\nconst float PREPASS_SCALE \t= 8.;\n\nconst bool SHOW_PRE_PASS\t= bool(0);\nconst bool SHOW_STEP_COUNT\t= bool(0);\n// Step count color legend\n// black: 0, green: 8, blue: 32, red: 128\n\nconst bool MOVE_SPHERES = bool(0);\n\n\n//////////////////////////////////////////  SDFs  ///////////////////////////////////////////\n\nvec3 R33(vec3 p)\n{\n\tvec4 a = fract(p.xzyx * vec4(123.34, 234.34, 345.65, 987.54));\n    a += dot(a + 0.0157, a + 34.45);\n    return fract(vec3(a.x * a.w, a.y * a.z, a.z * a.w));\n}\n\nfloat SphereDist(vec3 p, vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\n// https://youtu.be/l-07BXzNdPw, Voronoi Explained! - The Art of Code\nfloat VoronoiDist(vec3 p, float threshold, out vec3 color)\n{\n    float min_dist = MAX_DIST;\n        \n    vec3 local_p = fract(p); // range [0., +1.]\n    \n    for(int x = -1; x <= 1; x++)\n        for(int y = -1; y <= 1; y++)\n            for(int z = -1; z <= 1; z++)\n            {\n                vec3 offset = vec3(x, y, z);\n                vec3 id = floor(offset + p);\n\n                vec3 local_center = R33(id);\n                vec3 center = id + local_center;\n                \n                float dist = length(p - center);\n                \n                if (dist < min_dist)\n                {\n                    min_dist = dist;\n                    color = R33(id);\n                }\n            }\n    \n    return min_dist - threshold;\n}\n\n// https://github.com/blender/blender/blob/2d1cce8331f3ecdfb8cb0c651e111ffac5dc7153/intern/cycles/kernel/shaders/node_voronoi_texture.osl\nfloat VoronoiEdgeDist(vec3 p, float threshold, out vec3 color)\n{\n    vec3 local_p = fract(p); // range [0., +1.]\n    \n  \tvec3 vector_to_closest;\n    float min_dist = MAX_DIST;\n    \n    for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)\n            for (int z = -1; z <= 1; z++)\n            {\n                vec3 offset = vec3(x, y, z);\n                vec3 id = floor(offset + p);\n\n                vec3 local_center = R33(id);\n                vec3 center = id + local_center;\n\n                vec3 point_to_center = center - p;\n                float dist = length(point_to_center);\n\n                if (dist < min_dist)\n                {\n                    min_dist = dist;\n                    color = R33(id);\n                    vector_to_closest = point_to_center;\n                }\n            }\n\n    \n    min_dist = MAX_DIST;\n    \n    for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)\n            for (int z = -1; z <= 1; z++)\n            {\n                vec3 offset = vec3(x, y, z);\n                vec3 id = floor(offset + p);\n                \n                vec3 local_center = R33(id);\n                vec3 center = id + local_center;\n                \n                vec3 point_to_center = center - p;\n\n                vec3 perpendicularToEdge = point_to_center - vector_to_closest;\n                \n                if (length(perpendicularToEdge) < 0.01)\n                    continue;\n\n                float distanceToEdge = dot(\n                    (vector_to_closest + point_to_center) / 2.0,\n                    normalize(perpendicularToEdge)\n                );\n                \n                min_dist = min(min_dist, distanceToEdge);\n            }\n\n    return min_dist - threshold;\n}\n\n\n\n/////////////////////////////////////////  SCENE  //////////////////////////////////////////\n\nconst float PI = 3.14159265;\n\nconst vec3 cam_pos = vec3(0, 0, 3.0);\nconst vec3 cam_look_at = vec3(0, 0, 0);\nconst float cam_fov = PI / 18. * 9.;\nconst float image_height = tan(cam_fov / 2.) * 2.;\n\nconst vec3 cam_forward = normalize(cam_look_at - cam_pos);\nconst vec3 cam_right = normalize(cross(cam_forward, vec3(0, 1, 0))) * image_height / 2.;\nconst vec3 cam_up = normalize(cross(cam_right, cam_forward)) * image_height / 2.;\n\nvoid setRay(vec2 uv, out vec3 ray_origin, out vec3 ray_dir)\n{\n    ray_origin = cam_pos;\n    ray_dir = normalize(uv.x * cam_right + uv.y * cam_up + cam_forward);\n}\n\n\nconst vec3 light_pos = cam_pos + cam_up;\n\n\nfloat GetSceneDist(vec3 p, float iTime)\n{\n    float dist = MAX_DIST;\n\n    float voronoi_scale = cos(iTime / 6.) * 5. + 2.;\n\n    { // Left side, center distance\n        vec3 c = vec3(-1.1, 0, MOVE_SPHERES ? cos(iTime / 3. + (PI / 2. * 3.)) * 1.4 : 0.);\n        float sphere_dist = SphereDist(p, c, 1.);\n        float inner_sphere_dist = SphereDist(p, c, 0.92);\n        float hollow_sphere_dist = max(sphere_dist, -inner_sphere_dist);\n        \n        // optimization\n        if (hollow_sphere_dist <= MIN_DIST * 2.)\n        {\n          vec3 voronoi_color; // not used\n          float voronoi_dist = VoronoiDist(p * voronoi_scale, 0.4, voronoi_color);\n          voronoi_dist /= voronoi_scale;\n\n          dist = min(dist, max(voronoi_dist, hollow_sphere_dist));\n        }\n        else\n        {\n            dist = min(dist, hollow_sphere_dist);\n        }\n    }\n\n    { // Right side, edge distance\n        vec3 c = vec3(1.1, 0, MOVE_SPHERES ? cos(iTime / 3. + PI / 2.) * 1.4 : 0.);\n        float sphere_dist = SphereDist(p, c, 1.);\n        float inner_sphere_dist = SphereDist(p, c, 0.92);\n        float hollow_sphere_dist = max(sphere_dist, -inner_sphere_dist);\n\n        if (hollow_sphere_dist <= MIN_DIST * 2.)\n        {\n            vec3 voronoi_color; // not used\n            float voronoi_dist = VoronoiEdgeDist(p * voronoi_scale, 0.08, voronoi_color);\n            voronoi_dist /= voronoi_scale;\n\n            dist = min(dist, max(voronoi_dist, hollow_sphere_dist));\n        }\n        else\n        {\n            dist = min(dist, hollow_sphere_dist);\n        }\n    }\n\n    return dist;\n}\n\nvec3 GetSceneColor(vec3 p, float iTime)\n{\n    vec3 color;\n    \n    float voronoi_scale = cos(iTime / 6.) * 5. + 2.;\n    VoronoiDist(p * voronoi_scale, 0., color);\n    \n    return color;\n}\n\n\n\n/////////////////////////////////////////////  MARCHING  /////////////////////////////////////////////\n\nfloat RayMarchDist(vec3 ray_origin, vec3 ray_dir, float initial_dist, float iTime)\n{\n    float dist = initial_dist;\n    \n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        vec3 p = ray_origin + ray_dir * dist;\n        \n        float nearest = GetSceneDist(p, iTime);\n        \n        if (nearest < MIN_DIST)\n            break;\n        \n        dist += nearest;\n        \n        if (dist > MAX_DIST)\n            break;\n    }\n    \n    return dist;\n}\n\nfloat RayMarchStepCount(vec3 ray_origin, vec3 ray_dir, float initial_dist, float iTime)\n{\n    float dist = initial_dist;\n    \n    int i = 0;\n    for (; i < MAX_STEPS; ++i)\n    {\n        vec3 p = ray_origin + ray_dir * dist;\n        \n        float nearest = GetSceneDist(p, iTime);\n        \n        if (nearest < MIN_DIST)\n            break;\n        \n        dist += nearest;\n\n        if (dist > MAX_DIST)\n            break;\n    }\n    \n    return float(i);\n}\n\nvec3 GetNormal(vec3 p, float iTime)\n{\n    const vec2 delta = vec2(MIN_DIST, 0.);\n    \n    vec3 n = GetSceneDist(p, iTime) - vec3(\n        GetSceneDist(p - delta.xyy, iTime),\n        GetSceneDist(p - delta.yxy, iTime),\n        GetSceneDist(p - delta.yyx, iTime)\n    );\n    \n    return normalize(n);\n}\n\n\n// https://www.shadertoy.com/view/wlSSzc\nfloat ConeTraceDist(vec3 beam_origin, vec3 beam_dir, float beam_radius, float iTime)\n{\n    float dist = 0.;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        float cap_radius = dist * beam_radius;\n        \n        vec3 p = beam_origin + beam_dir * dist;\n        \n        float nearest = GetSceneDist(p, iTime);\n\n        if (nearest <= cap_radius)\n        \tbreak;\n\n        dist += nearest - cap_radius;\n\n        if (dist > MAX_DIST)\n            break;\n    }\n    \n    return dist;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (!USE_PREPASS)\n        return;\n    \n    vec2 prepass_uv = (fragCoord - 0.5) * PREPASS_SCALE / iResolution.xy;\n    bool in_region = all(lessThanEqual(prepass_uv, vec2(1.)));\n    if (!in_region) return;\n    \n    vec2 uv = (fragCoord * PREPASS_SCALE - iResolution.xy / 2.) / iResolution.y;\n\t\n    vec3 ray_origin, ray_dir;\n    setRay(uv, ray_origin, ray_dir);\n    \n    float radius = PREPASS_SCALE * image_height / iResolution.y * 0.5;\n    float dist = min(MAX_DIST - 1., ConeTraceDist(ray_origin, ray_dir, radius, iTime));\n\t\n    vec3 p = ray_origin + ray_dir * dist;\n\t\n    fragColor = vec4(p, dist);\n}","name":"Buffer A","description":"","type":"buffer"}]}