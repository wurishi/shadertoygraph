{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"const float i_MAXD = 100.;\nconst int i_STEPS = 50;\n\nfloat t;\nvec3 eps = vec3(.02, 0., 0.);\n\n\nfloat smin( float a, float b ) {\n\tfloat k = 1.;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat sdGrid(vec3 p, vec3 q) {\t\t\n\tfloat w = 0.1;\t\n  \treturn smin(\n\t\t\tsmin(\n\t\t\t\tlength(p.xy)-w,\n\t\t\t\tlength(p.xz)-w\n\t\t\t\t),\n\t\t\tlength(p.yz)-w\n\t\t);\n}\n\nvec2 field(in vec3 q) {\t\t\n\tfloat grid = 5. + .1*length(q);\n\t\t\n\tfloat c = .2*cos(.05*q.y);\n    float s = .2*sin(.05*q.z);\n\tmat2 m = mat2(c,-s,s,c);\n    vec3 p = mix(vec3(m*q.xy,q.z), q, .4 + .23*sin(.11*t));\n\tvec3 w = .2*p;\n\t\n\tvec3 pp = 4.*vec3(sin(1.+.94*t), cos(1.12*t), 1.5+sin(2.+0.73*t)*cos(.81*t));\n\tfloat sp = sdSphere(p + pp, 1.3);\n\t\n\tvec3 g = mod(p, grid) - .5*grid;\t\n\treturn vec2(smin(sdGrid(g, q), sp), 0.);\n}\n\nvec3 normal(vec3 p) {\n\treturn normalize(vec3(\n\t\tfield(p+eps.xyz).x - field(p-eps.xyz).x,\n\t\tfield(p+eps.yxz).x - field(p-eps.yzx).x,\n\t\tfield(p+eps.yzx).x - field(p-eps.yzx).x\n\t\t));\n}\n\nint istep = 0;\n\nvec4 intersect(in vec3 ro, in vec3 rd) {\t\n    \tfloat k = 0.;\n    \tvec2 r = vec2(0.1);\n    \tint j = 0;\n    \tfor(int i=0; i<i_STEPS; i++ ) {\n\t\t\tif (istep > i_STEPS) continue;\n        \tif(abs(r.x) < eps.x || k>i_MAXD) continue;        \t\t\t\t\n\t    \tr = field(ro+rd*k);\n\t    \tk += r.x;\n\t\t\tj += 1;\n\t\t\tistep += 1;\n    \t}\n\n    \tif(k>i_MAXD) r.y=-1.0;\n    \treturn vec4( k, j, r.yx );\n}\n\nvec3 FresnelSchlick(vec3 SpecularColor,vec3 E,vec3 H) {\n    return SpecularColor + (1.0 - SpecularColor) * pow(1.0 - clamp(dot(E, H), 0., 1.), 5.);\n}\n\n\nvec3 shade(vec4 h, vec3 p, vec3 rd, vec3 n) {\n\tvec3 color = vec3(0.);\n\tif (h.z >= 0.) {\t\n\t\tvec3 L = (-rd);\n\t\tfloat D = clamp(dot(L, n), 0., 1.);\n\t\tvec3 H = normalize(L - rd);\n\t\tvec3 R = reflect(rd, n);\n\t\t\t\n\t\tvec3 tex = texture(iChannel0, R).xyz;\n\t\tvec3 dcolor = 0.1+0.3*tex;\n\t\tvec3 scolor = vec3(0.4, 0.3, 0.2 );\n\t\t\n\t\t// L = light\n\t\t// N = normal\n\t\t// R = reflected ray\n\t\t// V = viewer, -1* ray dir\n\t\t// H = halfway vector H = .5*(L + V)\n\t\t\n\t\tfloat spec = 64.;\t\t\n\t\t\t\n\t\tcolor = dcolor*1.*(D + .01);\n\t\tcolor += FresnelSchlick(scolor, L, H) * ((spec + 2.) / 8. ) * pow(clamp(dot(n, H), 0., 1.), spec) * D;\t\t\n\t\t\n\t\tcolor *= smoothstep(0., 1., 6./h.x);\t\n\t}\t\t\n\t\n\treturn color;\n}\n\n// Stolen somewhere\nvec2 HmdWarp(vec2 uv) {\n\t// screen space transform(Side by Side)\n\tuv = vec2((mod(uv.x,1.0)-0.5)*2.0+0.2*sign(uv.x), uv.y);\n\n\t// HMD Parameters\n\tvec2 ScaleIn = vec2(1.0);\n\tvec2 LensCenter = vec2(0.0,0.0);\n\tvec4 HmdWarpParam = vec4(1.0,0.22, 0.240, 0.00);\n\tvec2 Scale = vec2(1.1);\n\n\t// Distortion\n\tvec2 theta  = (uv - LensCenter) * ScaleIn; // Scales to [-1, 1]\n\tfloat  rSq    = theta.x * theta.x + theta.y * theta.y;\n\tvec2 rvector= theta * (HmdWarpParam.x + HmdWarpParam.y * rSq\n\t\t\t       + HmdWarpParam.z * rSq * rSq\n\t\t\t       + HmdWarpParam.w * rSq * rSq * rSq);\n\treturn LensCenter + Scale * rvector;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime;\n \n\tvec2 uv = fragCoord.xy / iResolution.xy;\t\n\tvec3 mouse = vec3(2.*iMouse.xy / iResolution.xy - 1., 0.);\n\tmouse.y *= -1.;\n\t\n\tvec2 xy = HmdWarp(2.*uv - 1.);\n\t\n\tvec3 ct = vec3(.5*cos(t), .5*sin(t), 0.) + 5.*mouse;\n\tvec3 cp = vec3(0., 0., -13.);\n\tvec3 cd = normalize(ct-cp);\t\t\n\t\n\tvec3 side = cross(vec3(0., 1., 0.), cd);\n\tvec3 up = cross(cd, side);\n\tvec3 rd = normalize(cd + 1.65*(xy.x*side + xy.y*up)); // FOV\n\t\n    //-----------------------------------------------------\t\n\t\n\tvec4 h = intersect(cp, rd);\t\t\t\n\tvec3 p = cp + h.x*rd;\n\tvec3 color = vec3(0.);\t\n\tif (h.z >= 0.) {\n\t\tvec3 n = normal(p-rd*0.01);\n\t\tvec3 R = reflect(rd, n);\n\t\tcolor = shade(h, p, rd, n);\n\t}\t\n\t\n\tcolor = pow( clamp(color,0.0,1.0), vec3(0.45) );\n\tcolor = pow( color, vec3(1.1)) * sqrt( 64.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y) );\n\tfragColor = vec4(color, 0.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdfSRj","date":"1403870532","viewed":311,"name":"Cardboard Grid","username":"bysse","description":"Testing a home made cardboard viewer.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","cardboard"],"hasliked":0,"parentid":"","parentname":""}}