{"ver":"0.1","info":{"id":"wstBW4","date":"1611413188","viewed":279,"name":"0-2. Ray Marching Study","username":"rito15","description":"studying..","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST  100.0\n#define SURF_DIST 0.01\n\n// 광원\nvec3 g_lightPos = vec3(0., 5., 1.);\n\n/**************************************************************************************************\n * 3D Objects\n * https://iquilezles.org/articles/distfunctions\n * https://www.youtube.com/watch?v=Ff0jJyyiVyw\n **************************************************************************************************/\nstruct Plane\n{\n    vec3  normal; // 평면 법선 벡터의 방향\n    float height; // 높이 : 원점에서 normal벡터 방향으로 더한 값\n    vec3  color; // TODO\n};\n    \nstruct Sphere\n{\n    vec3  pos;\n    float radius;\n    vec3  color;\n};\n    \nstruct Box\n{\n    vec3 pos;\n    vec3 size;\n    vec3 color;\n};\n    \n// 속이 빈 박스\nstruct BoundingBox\n{\n    vec3  pos;\n    vec3  size;\n    float e;    // edge Thickness\n    vec3  color;\n};\n\n// 도넛형\nstruct Torus\n{\n    vec3 pos;\n    vec2 radius; // (out radius, in radius)\n};\n\n/**************************************************************************************************\n * 3D Object Distance Functions\n **************************************************************************************************/\n// GetMinDist : 지점 p로부터 오브젝트 o위의 정점으로의 거리 중 가장 가까운 거리 찾아 리턴\nfloat SD(vec3 p, Sphere o)\n{\n    return length(p - o.pos) - o.radius;\n}\nfloat SD(vec3 p, Plane o)\n{\n    return dot(p, normalize(o.normal)) - o.height;\n}\nfloat SD(vec3 p, Box o)\n{\n    vec3 q = abs(p - o.pos) - o.size;\n  \treturn length(max(q, 0.0)) + min( max(q.x, max(q.y,q.z) ), 0.0);\n}\nfloat SD(vec3 p, BoundingBox o)\n{\n    vec3  b = o.size;\n    float e = o.e;\n    \n    p = abs(p - o.pos )-b;\n  \tvec3 q = abs(p+e)-e;\n    \n  \treturn min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat SD(vec3 p, Torus o)\n{\n    p = p - o.pos;\n    vec2 r = o.radius;\n    \n    vec2 q = vec2(length(p.xz)-r.x,p.y);\n  \treturn length(q)-r.y;\n}\n\n/**************************************************************************************************\n * Ray Marching Functions\n **************************************************************************************************/\n// 현재 진행중인 레이 위의 점에서 다음 지점(특정 오브젝트 표면 또는 플레인) 발견하여 리턴\n// 현재 위치 p에서 구형범위로 탐색하여, 어떤 물체든 찾아 가장 작은 구체의 반지름을 리턴하는 것과 같음\nfloat GetDist(vec3 p)\n{\n    Plane pl;\n    pl.normal = vec3(0.0, 1.0, 0.0);\n    pl.height = 0.0;\n    \n    Sphere s;\n    s.pos    = vec3(-6.0, 1.0, 6.0);\n    s.radius = 1.0;\n    \n    Box b;\n    b.pos   = vec3(-2.0, 1.0, 6.0);\n    b.size  = vec3(1.0, 1.0, 1.0);\n    \n    BoundingBox bb;\n    bb.pos  = vec3(1.0, 1.0, 6.0);\n    bb.size = vec3(1.0, 1.0, 1.0);\n    bb.e    = 0.1;\n    \n    Torus t;\n    t.pos   = vec3(5.0, 1.0, 6.0);\n    t.radius = vec2(1.0, 0.4);\n    \n    float dPlane  = SD(p, pl); //p.y;\n    float dSphere = SD(p, s);\n    float dBox    = SD(p, b);\n    float dBBox   = SD(p, bb);\n    float dTorus  = SD(p, t);\n    \n    // 발견한 다음 지점들 중 가장 가까운 지점 리턴\n    float d = min(dPlane, dSphere);\n          d = min(d, dBox);\n          d = min(d, dBBox);\n          d = min(d, dTorus);\n    \n    return d;\n}\n\n// ro(카메라)로부터 rd 방향(모든 uv 픽셀)으로 레이 발사\n// 리턴값 : 카메라로부터 레이 방향에서 찾은 가장 가까운 정점\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    // RayMarch Distance From Origin : Ray Origin(카메라)에서부터의 거리\n    float dO = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * dO;\n        float dS = GetDist(p);   // Distance to the Scene : 레이 내에서 다음 스텝으로 전진시킬 거리\n        dO += dS;                // 레이 한 스텝 전진\n        \n        // 레이 제한 거리까지 도달하거나\n        // 레이가 물체의 정점 또는 땅에 닿은 경우 레이 마칭 종료\n        if(dO > MAX_DIST || dS < SURF_DIST)\n            break;\n    }\n    \n    return dO;\n}\n\n// 각 정점에서 노멀 벡터 계산\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2  e = vec2(0.001, 0.0);\n    \n    // x, y, z 좌표를 0.01씩 움직인 3개의 방향벡터로 각각 GetDist를 통해 해당 방향에 있는 물체의 정점까지 거리를 찾고,\n    // 이를 x, y, z 성분으로 사용한 노멀 벡터 생성\n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n    \n    return normalize(n);\n}\n\n// 각 정점에서 라이팅 계산\nfloat GetLight(vec3 p)\n{\n    vec3 L = normalize(g_lightPos - p);\n    vec3 N = GetNormal(p);\n    \n    // Shade(Diffuse)\n    float dif = saturate( dot(N, L) );\n    \n    // Shadow\n    // 정점(3D 물체 표면이 위치하는 모든 지점)에서 광원을 향해 레이마칭하여 얻은 거리가\n    // 정점에서 광원까지의 거리보다 작다면,\n    // 그 사이에 또다른 정점이 가로막고 있다는 뜻이므로 이 정점은 그림자가 생김\n    \n    // SURF_DIST만큼의 거리를 더해주는 이유 : 레이가 정점을 찾아내는 최소 거리(Threshold)이므로\n    // SURF_DIST에 1.0 초과 숫자를 곱해주는 이유 : 의도치 않은 음영이 생길 수 있으므로\n    \n    float d = RayMarch(p + N * SURF_DIST * 2.0, L);\n    if(d < length(g_lightPos - p) )\n        dif *= 0.1;\n    \n    return dif;\n}\n\nfloat DistLine(vec3 ro, vec3 rd, vec3 p)\n{\n    return length(cross(p - ro, rd)) / length(rd);\n}\n\n/**************************************************************************************************\n * Main\n **************************************************************************************************/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV ================================================================================================\n    vec2 uv = fragCoord/iResolution.xy;\t\t\t\t\n           uv = (uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) *2.0; // Square Area  -1.0 ~ 1.0\n    \n    float zoom = 1.3;\n    uv /= zoom;\n    \n    vec2 mPos = iMouse.xy/iResolution.xy;\n           mPos = (mPos - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) *2.0;\n    mPos /= zoom;\n    \n    // Final Variables ===================================================================================\n    vec3 shp = vec3(0.0); // Shapes\n    vec3 col = vec3(0.0); // Colors of Shapes\n    \n    // Ray Origin\n    vec3 ro = vec3(0.0, 1.1, 0.0);// + vec3(sin(mPos.x), 0., cos(mPos.x));\n    \n    // Ray Direction : ro -> uv screen\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    float t = iTime;\n    \n    float d;  // Distance from point\n    vec3  p;  // Result of RayMarching (3D Shapes)\n    float dif;// Diffuse\n    \n    \n    /*****************************************************************************************************************\n    * Body Start                                                                                                     *\n    *****************************************************************************************************************/\n    \n    g_lightPos += vec3(sin(t), 0., cos(t)) * 3.0;\n    \n    d = RayMarch(ro, rd);\n    p = ro + rd * d;\n    dif = GetLight(p);\n    \n    /*****************************************************************************************************************\n    *                                                                                                       Body End *\n    *****************************************************************************************************************/\n    \n    \n    // Draw Shapes =======================================================================================\n    shp += dif;\n        \n    // Apply Colors ======================================================================================\n    col += vec3(1.0, 1.0, 0.9);\n    \n    // End Point =========================================================================================\n    fragColor.a = 1.0;\n    fragColor.rgb = shp * col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/**************************************************************************************************\n * DEFINITIONS : Unity Compatibility\n **************************************************************************************************/\n#define float2   vec2\n#define float3   vec3\n#define float4   vec4\n#define float2x2 mat2\n#define float3x3 mat3\n#define float4x4 mat3\n\n#define frac(x)     fract(x)\n#define saturate(x) clamp(x, 0., 1.)\n\n#define atan2(x,y)    atan(y,x)\n#define tex2D(s,t)    texture(s,t)\n#define mul(mat,vec)  vec*mat;\n\n#define lerp(a,b,t) mix(a,b,t)\n\n/**************************************************************************************************\n * DEFINITIONS - Constant\n **************************************************************************************************/\n#define PI 3.141592653589793\n\n/**************************************************************************************************\n * DEFINITIONS - Function\n **************************************************************************************************/\n#define S(a, b, t) smoothstep(a, b, t)\n\n// Remap : (0 ~ 1) => (a, b)\n#define R01(t, a, b) (b - a) * t + a\n\n// Remap : (-1 ~ 1) => (a, b)\n#define R11(t, a, b) (b - a) * (1. - t) * 0.5 + a\n\n/**************************************************************************************************\n * DEFINITIONS - float3 Colors\n **************************************************************************************************/\n#define BLACK float3(0.0, 0.0, 0.0)\n#define WHITE float3(1.0, 1.0, 1.0)\n\n#define RED   float3(1.0, 0.0, 0.0)\n#define GREEN float3(0.0, 1.0, 0.0)\n#define BLUE  float3(0.0, 0.0, 1.0)\n\n#define YELLOW  float3(1.0, 1.0, 0.0)\n#define CYAN    float3(0.0, 1.0, 1.0)\n#define MAGENTA float3(1.0, 0.0, 1.0)\n\n/**************************************************************************************************\n * Functions\n **************************************************************************************************/\n// Smooth Max\nfloat3 smax(float3 a, float3 b, float k)\n{\n    float3 h = clamp((b - a) / k + 0.5, 0.0, 1.0);\n    return mix(a, b, h) + h * (1.0 - h) * k * 0.5;\n}\n\n/**************************************************************************************************\n * DEBUG Functions \n **************************************************************************************************/\nfloat3 debugCenterLine(float2 uv)\n{\n    if(uv.x > 0.498 && uv.x < 0.502 || uv.y > 0.498 && uv.y < 0.502)\n        return float3(1., 0., 0.);\n}\nfloat3 debugOutLine(float2 uv)\n{\n    if(uv.x > 1.0 && uv.x <= 1.004 || uv.x < 0.0 && uv.x >= -0.004)\n        return float3(0., 0., 1.);\n}\nfloat3 debugGrid(float2 uv, float interval)\n{\n    if(interval <= 0.0) return float3(0.);\n    \n    // interval마다 그리드 디버그\n    float grid = 0.;\n    float gridZ = 0.;\n    float2 gridXY = float2(0.);\n    \n    float th = 0.002; // thickness\n    \n    for(float f = interval; f < 1.0; f += interval)\n    {\n        // 가로선 || 세로선\n        if(uv.y >= f - th && uv.y <= f + th && uv.x > 0. && uv.x < 1. ||\n           uv.x >= f - th && uv.x <= f + th)\n        {\n            grid = 0.7;\n            gridXY = uv + float2(0.2, 0.4);\n            \n            if( frac(f * 4.) < 0.01 )\n            {\n                grid = 1.;\n                gridZ = 1.;\n            }\n        }\n    }\n    \n    return float3(0., grid, gridZ);\n    //return float3(gridXY, gridZ); //알록달록\n}","name":"Common","description":"","type":"common"}]}