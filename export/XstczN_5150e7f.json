{"ver":"0.1","info":{"id":"XstczN","date":"1518083143","viewed":241,"name":"Poisson equation - Direct method","username":"Ultraviolet","description":"Solving the Poisson equation in 1D using a closed form solution for the inverse Laplacian matrix.\nAnybody nowing where that noise might come from?","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["poissonequation","directmethod"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This shader displays the curve stored in buf A and the laplacian of the curve computed in buf B.\n// see https://www.shadertoy.com/view/4d3cRN for details on the drawing.\n\n\n#define BG_COLOR vec3(.9)\n#define FG_COLOR_1 vec3(.6, .6, .8)\n#define FG_COLOR_2 vec3(.8, .6, .6)\n#define FG_COLOR_3 vec3(.6,.8,  .6)\n#define ST_COLOR_1 vec3(.1, .1, .2)\n#define ST_COLOR_2 vec3(.2, .1, .1)\n#define ST_COLOR_3 vec3(.1,.2,  .1)\n\n// Utility for curve display\nfloat PointSegDistance(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// Original value (RHS of the Poisson equation)\nfloat valO(int n)\n{\n    return texelFetch(iChannel0, ivec2(n, 0),0).r;\n}\n\n// Computed solution\nfloat valR(int n)\n{\n    float val = 0.;\n    for(float i=0.; i<NB_LAYERS; ++i)\n    \tval += texelFetch(iChannel1, ivec2(n, i),0).r;\n    \n    return val / NB_LAYERS;\n}\n\n// Laplacian of the computed solution (LHS of the Poisson equation)\nfloat LvalR(int n)\n{    \n    return (2.*valR(n) - valR(n+1) - valR(n-1));\n}\n\n// Smoothed version of the above\nfloat LvalR_smooth(int n)\n{    \n    return (LvalR(n) + LvalR(n-1) + LvalR(n+1))/3.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    int x = int(fragCoord.x);\n    float dx = 1./iResolution.x;\n    float v = valO(x);\n    vec2 p  = vec2(uv.x   , v       );\n    vec2 pp = vec2(uv.x+dx, valO(x+1));\n    vec2 pm = vec2(uv.x-dx, valO(x-1));\n    \n    //*\n    if(x == 0)\n        pm = pp;\n    \n    if(x == int(iResolution.x)-1)\n        pp = pm;\n\t//*/\n        \n    float dp = min(PointSegDistance(uv,p, pp),PointSegDistance(uv,p, pm));\n    \n    float stroke_alpha = clamp(mix(1., 0., dp * iResolution.y), 0., 1.);\n    float bg_alpha = clamp((v-uv.y)* iResolution.y, -1., 1.)*.5+.5;\n    \n    \n    vec3 c = mix(BG_COLOR, FG_COLOR_1, bg_alpha*.5);\n    c = mix(c, ST_COLOR_1, stroke_alpha);\n    \n    \n    \n    v = LvalR(x);\n    p  = vec2(uv.x   , v       );\n    pp = vec2(uv.x+dx, LvalR(x+1));\n    pm = vec2(uv.x-dx, LvalR(x-1));\n    \n    //*\n    if(x == 0)\n        pm = pp;\n    \n    if(x == int(iResolution.x)-1)\n        pp = pm;\n\t//*/\n        \n    dp = min(PointSegDistance(uv,p, pp),PointSegDistance(uv,p, pm));\n    \n    stroke_alpha = clamp(mix(1., 0., dp * iResolution.y), 0., 1.);\n    bg_alpha = clamp((v-uv.y)* iResolution.y, -1., 1.)*.5+.5;\n    \n    c = mix(c, FG_COLOR_2, bg_alpha*.5);\n    c = mix(c, ST_COLOR_2, stroke_alpha);\n    \n    \n    \n    \n    \n    v = abs(LvalR(x) - valO(x));\n    p  = vec2(uv.x   , v       );\n    pp = vec2(uv.x+dx, abs(LvalR(x+1) - valO(x+1)));\n    pm = vec2(uv.x-dx, abs(LvalR(x-1) - valO(x-1)));\n    \n    //*\n    if(x == 0)\n        pm = pp;\n    \n    if(x == int(iResolution.x)-1)\n        pp = pm;\n\t//*/\n        \n    dp = min(PointSegDistance(uv,p, pp),PointSegDistance(uv,p, pm));\n    \n    stroke_alpha = clamp(mix(1., 0., dp * iResolution.y), 0., 1.);\n    bg_alpha = clamp((v-uv.y)* iResolution.y, -1., 1.)*.5+.5;\n    \n    c = mix(c, FG_COLOR_3, bg_alpha*.5);\n    c = mix(c, ST_COLOR_3, stroke_alpha);\n    \n    \n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This shader holds the right-hand side of the Poisson equation in its first row.\n// It allows you to edit it by clicking (see https://www.shadertoy.com/view/4d3cRN).\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifragCoord = ivec2(floor(fragCoord));\n    \n    if(ifragCoord.y != 0)\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    vec4 val = texelFetch(iChannel0, ifragCoord,0);\n    \n    // Initilization\n    if(iFrame == 0)\n    {\n        val.x = 0.5+0.2*sin(10.*fragCoord.x/iResolution.x);\n    }\n    \n    // Mouse edits\n    if(iMouse.z>.5 && val.w<.5 && int(iMouse.x) == ifragCoord.x)\n    {\n        val.x = iMouse.y/iResolution.y;\n    }\n    \n    if(iMouse.z>.5 && val.w>.5)\n    {\n        float t = (fragCoord.x - val.y)/(iMouse.x - val.y);\n        if(0.<t && t<1.)\n            val.x = mix(val.z/iResolution.y, iMouse.y/iResolution.y, t);\n            //val.x = mix(val.z/iResolution.y*SCALING, iMouse.y/iResolution.y*SCALING, t);\n    }\n    \n    // Note: mouse state is backed up\n    fragColor = vec4(val.x , iMouse.xyz);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// This shader compute a solution U to the Poisson equation ∇²U = F.\n// It uses a closed-form equation for the coefficients of the inverse laplacian matrix.\n\n\n// Value to be matched (rhs of the equation)\nfloat valO(int n)\n{\n    return texelFetch(iChannel0, ivec2(n, 0),0).r;\n}\n\n// Computes the (i,j)th coefficient of the inverse laplacian matrix (size is irrelevant)\n// Note: it is put here for clarity purposes, no used\n// (no need to compute the laplacian, would be quite inefficient to do it by full matrix multiplication anyway).\nfloat LaplaceCoefficient(int i, int j)\n{\n    if(i==j)\n        return 2.;\n    if(abs(i-j) == 1)\n        return -1.;\n    return 0.;\n}\n\n\n\n// computes the (i,j)th coefficient of the inverse laplacian matrix of size N\nfloat InverseLaplaceCoefficient(int N, int i, int j)\n{\n    i++;\n    j++;\n    \n    if (j==1)\n    {\n      return float(N-i);\n      //return float(N-i)/float(N-1);\n    }\n    \n    if (j==N)\n    {\n      return float(i-1);\n      //return float(i-1)/float(N-1);\n    }\n    \n    if (i==1 || i==N)\n    {\n      return 0.;\n    }\n\n    i = N-i+1;\n\n    if (i+j> N+1)\n    {\n      int k=i;\n      i=N-j+1;\n      j=j+(i-k);\n    }\n\n    return float(j-1+(i-2)*(j-1));\n    //return float(j-1+(i-2)*(j-1))/float(N-1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifragCoord = ivec2(floor(fragCoord));\n    \n    //if(ifragCoord.y != 0)\n    if(fragCoord.y > NB_LAYERS)\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    int i = ifragCoord.x;\n    int N = int(iResolution.x);\n    float U = 0.;\n    \n    // a scale is used in order to counter numerical dispersion effects\n    float scale = 1. + (fragCoord.y-.5)*iResolution.x;\n    \n    //scale = pow(10., fragCoord.y-.5);\n    \n    // simple matrix-vector multiplication \n    for(int j=0; j<N; ++j)\n    {\n        U += InverseLaplaceCoefficient(N, i, j) * (valO(j)*scale);\n    }\n    \n    // normalisation \n    U /= float(N-1)*scale;\n    \n    fragColor = vec4(U, 0., 0., 0.);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define NB_LAYERS\t20.","name":"Common","description":"","type":"common"}]}