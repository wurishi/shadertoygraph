{"ver":"0.1","info":{"id":"4tycDd","date":"1539207195","viewed":260,"name":"Pixel Movement Prediction Test","username":"slerpy","description":"The \"trace\" function, which renders the geometry is called only once every 300 frames. The shader is trying to guess how the next frame should look like, knowing the last frame and which way the scene is rotating.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["3d","test","experiment","post","procedual"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(exp(-0.1*texelFetch(iChannel0, ivec2(fragCoord), 0).z));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"mat2 rot(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat map(vec3 p)\n{\n    p.xy *= rot(.5);\n    p.yz *= rot(.3);\n    p = abs(abs(p)-1.)-.4;\n    return max(p.x, max(p.y, p.z));\n}\n\nvec3 trace(vec2 coord)\n{\n    vec2 uv = (2.*coord - iResolution.xy) / iResolution.y;\n    \n    vec3 rd = vec3(0, 0, 1);\n    vec3 ro = vec3(2. * uv, -100);\n    \n    float m, t = .0;\n    \n    const int iter = 80;\n    mat2 rm = rot(iTime);\n    \n    for(int i=0; i<iter; i++)\n    {\n        vec3 p = ro + rd * t;\n        p.xz *= rm;\n        t += m = map(p);\n        \n        if(m < 0.01)break;\n    }\n    \n    return ro + rd * t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dt = iTimeDelta;\n    vec3 pos = texelFetch(iChannel1, ivec2(fragCoord), 0).xyz;\n    \n    bool fetch = (iFrame % 300) == 0;\n    \n#if 0\n    uvec2 temp = uvec2(fragCoord.xy) + 1234u * uint(iFrame);\n    uint hash = temp.x * temp.y;\n    fetch = (hash % 1000u == 0u) || fetch;\n#endif\n    \n    if(iFrame < 5 || fetch)\n    {\n        pos = trace(fragCoord);\n    }\n    \n    vec3 new = pos;\n    new.xz *= rot(-dt);\n    \n    vec2 uv = 0.5 * new.xy;\n    vec2 coord = 0.5 * (uv * iResolution.y + iResolution.xy);\n    \n    fragColor = vec4(new, coord.x);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1) / 0.0;\n    \n    const int range = 40;\n    for(int i = -range; i < range; i++)\n    {\n        ivec2 coord = ivec2(fragCoord) + ivec2(i,0);\n        \n        if(coord.x < 0 || coord.x >= int(iResolution.x)) continue;\n        \n        vec4 tex = texelFetch(iChannel0, coord, 0);\n        \n        float prec = 0.8;\n        if(abs(tex.w-fragCoord.x) < prec)\n        {\n            fragColor = tex;\n            return;\n        }\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}