{"ver":"0.1","info":{"id":"mllBDX","date":"1693554042","viewed":127,"name":"Anisotropic Kuwahara shader","username":"p4vv37","description":"Generalized Kuwahara filter, based on work of Acerola, basically his code rewritten to Shadertoy\n- https://www.youtube.com/watch?v=LDhN-JK3U9g\n- https://github.com/GarrettGunnell/Post-Processing/tree/main/Assets/Kuwahara%20Filter","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["kuwahara","anisotropic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nGeneralized Kuwahara filter, based on work of Acerola\nBasically Acerola code rewritten to Shadertoy\n- https://www.youtube.com/watch?v=LDhN-JK3U9g\n- https://github.com/GarrettGunnell/Post-Processing/tree/main/Assets/Kuwahara%20Filter\n*/\n\nconst int _KernelSize = 6;\nconst int N = 8;\nconst float alpha = 1.0;\nconst float q = 18.;\nconst float PI = 3.14159265358979323846;\nconst float _Hardness = 10.;\n\n\nfloat gaussian(float sigma, float pos) {\n    return (1.0f / sqrt(2.0f * PI * sigma * sigma)) * exp(-(pos * pos) / (2.0f * sigma * sigma));\n}\n        \n\nfloat casin(float x) {\n\tfloat negate = float(x < 0.0);\n\tx = abs(x);\n\tfloat ret = -0.0187293;\n\tret *= x;\n\tret += 0.0742610;\n\tret *= x;\n\tret -= 0.2121144;\n\tret *= x;\n\tret += 1.5707288;\n\tret = 3.14159265358979*0.5 - sqrt(1.0 - x)*ret;\n\treturn ret - 2.0 * negate * ret;\n}\nfloat atan2(float y, float x) {\n    float absx, absy, val;\n\n     if (x == 0.0 && y == 0.0) {\n        return 0.0;\n    }\n    absy = y < 0.0 ? -y : y;\n    absx = x < 0.0 ? -x : x;\n    if (absy - absx == absy) {\n        return y < 0.0 ? -3.1415*2.0 : 3.1415*2.0;\n    }\n\n    if (absx - absy == absx) {\n        val = 0.0;\n    } else {\n        val = casin((y/x)/sqrt(1.0+((y/x)*(y/x))));\n    }\n    if (x > 0.0) {\n        return val;\n    }\n    if (y < 0.0) {\n        return val - 3.1415;\n    }\n    return val + 3.1415;\n}\n\nvoid blur2(out vec4 fragColor, vec2 uv) {\n\n    int kernelRadius = 5;\n\n    vec4 col = vec4(0);\n    float kernelSum = 0.0f;\n\n    for (int y = -kernelRadius; y <= kernelRadius; ++y) {\n        vec3 c = texture ( iChannel2 , uv + vec2(0, y) * 1.0/iResolution.xy). xyz;\n        float gauss = gaussian(2.0f, float(y));\n\n        col += vec4(c, 1) * gauss;\n        kernelSum += gauss;\n    }\n\n    vec3 g = col.rgb / kernelSum;\n\n    float lambda1 = 0.5f * (g.y + g.x + sqrt(g.y * g.y - 2.0f * g.x * g.y + g.x * g.x + 4.0f * g.z * g.z));\n    float lambda2 = 0.5f * (g.y + g.x - sqrt(g.y * g.y - 2.0f * g.x * g.y + g.x * g.x + 4.0f * g.z * g.z));\n\n    vec2 v = vec2(lambda1 - g.x, -g.z);\n    \n    vec2 t = length(v) > 0.0 ? normalize(v) : vec2(0.0f, 1.0f);\n    float phi = -atan2(t.y, t.x);\n    //fragColor = vec4(phi, 0., 0., 0.);\n    //return;\n\n    float A = (lambda1 + lambda2 > 0.0f) ? (lambda1 - lambda2) / (lambda1 + lambda2) : 0.0f;\n\n    fragColor = vec4(t, phi, A);\n}\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord )\n {\n    vec2 uv=fragCoord/iResolution.xy;\n    vec4 t = texture ( iChannel2 , uv);\n    \n    // structureTensors(t, uv);\n    // blur1(t, uv);\n    blur2(t, uv);\n    //fragColor = t;\n    //return;\n    \n \n    int kernelRadius = _KernelSize / 2;\n    float a = float((kernelRadius)) * clamp((alpha + t.w) / alpha, 0.1f, 2.0f);\n    float b = float((kernelRadius)) * clamp(alpha / (alpha + t.w), 0.1f, 2.0f);\n    \n    \n    float cos_phi = cos(t.z);\n    float sin_phi = sin(t.z);\n    \n    mat2x2 R = mat2x2(cos_phi, -sin_phi, sin_phi, cos_phi);\n    mat2x2 S = mat2x2(0.5f / a, 0.0f, 0.0f, 0.5f / b);\n    \n    mat2x2 SR = S * R;\n    \n    int max_x = int(sqrt(a * a * cos_phi * cos_phi + b * b * sin_phi * sin_phi));\n    int max_y = int(sqrt(a * a * sin_phi * sin_phi + b * b * cos_phi * cos_phi));\n    \n    float zeta = 2.0f / float(kernelRadius);\n    zeta = 0.01;\n    \n    float zeroCross = 2.;\n    \n    float sinZeroCross = sin(zeroCross);\n    float eta = (zeta + cos(zeroCross)) / (sinZeroCross * sinZeroCross);\n    int k;\n    vec4 m[8];\n    vec3 s[8];\n    \n    \n    for (k = 0; k < N; ++k) {\n        m[k] = vec4(0.0f);\n        s[k] = vec3(0.0f);\n    }\n    \n    \n    for (int y = -kernelRadius; y <= kernelRadius; ++y) {\n        for (int x = -kernelRadius; x <= kernelRadius; ++x) {\n            vec2 v = SR * vec2(x, y);\n            vec3 c = texture ( iChannel0 , uv + vec2(x, y) * 1.0/iResolution.xy). xyz;\n            c = clamp(c,0.0,1.0) ;\n            float sum = 0.;\n            float w[8];\n            float z, vxx, vyy;\n\n            /* Calculate Polynomial Weights */\n            vxx = zeta - eta * v.x * v.x;\n            vyy = zeta - eta * v.y * v.y;\n            z = max(0., v.y + vxx); \n            w[0] = z * z;\n            sum += w[0];\n            z = max(0., -v.x + vyy); \n\n\n            w[2] = z * z;\n            sum += w[2];\n            z = max(0., -v.y + vxx); \n            w[4] = z * z;\n            sum += w[4];\n            z = max(0., v.x + vyy); \n            w[6] = z * z;\n            sum += w[6];\n            v = sqrt(2.0f) / 2.0f * vec2(v.x - v.y, v.x + v.y);\n            vxx = zeta - eta * v.x * v.x;\n            vyy = zeta - eta * v.y * v.y;\n            z = max(0., v.y + vxx); \n            w[1] = z * z;\n            sum += w[1];\n            z = max(0., -v.x + vyy); \n            w[3] = z * z;\n            sum += w[3];\n            z = max(0., -v.y + vxx); \n            w[5] = z * z;\n            sum += w[5];\n            z = max(0., v.x + vyy); \n            w[7] = z * z;\n            sum += w[7];\n            \n            \n            float g = exp(-3.125f * dot(v,v)) / sum;\n\n            for (int k = 0; k < 8; ++k) {\n                float wk = w[k] * g;\n                m[k] += vec4(c * wk, wk);\n                s[k] += c * c * wk;\n            }\n        }\n        \n    }\n    \n    \n    vec4 ou = vec4(0.);\n    for (k = 0; k < N; ++k) {\n        m[k].rgb /= m[k].w;\n        s[k] = abs(s[k] / m[k].w - m[k].rgb * m[k].rgb);\n\n        float sigma2 = s[k].r + s[k].g + s[k].b;\n        float w = 1.0f / (1.0f + pow(_Hardness * 1000.0f * sigma2, 0.5f * q));\n\n        ou += vec4(m[k].rgb * w, w);\n    }\n\n    fragColor = clamp((ou / ou.w),0.0,1.0);\n }","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void structureTensors ( out vec4 fragColor, in vec2 uv ) {\n    vec2 src_size = vec2(iResolution.x, iResolution.y);\n    vec2 d = 1.0 / iResolution.xy ;\n    vec3 c = texture(iChannel0, uv).xyz;\n    vec3 u = (\n    1.0 * texture(iChannel0, uv + vec2 (- d.x , -d. y )).xyz +\n    2.0 * texture ( iChannel0 , uv + vec2 (- d.x , 0.0)). xyz +\n    1.0 * texture ( iChannel0 , uv + vec2 (- d.x , d.y)). xyz  +\n    -1.0 * texture ( iChannel0 , uv + vec2 (d.x , -d.y)). xyz +\n\n    -2.0 * texture ( iChannel0 , uv + vec2 ( d.x , 0.0)). xyz  +\n    -1.0 * texture ( iChannel0 , uv + vec2 ( d.x , d.y)). xyz\n    ) / 4.0;\n    vec3 v = (\n    1.0 * texture ( iChannel0 , uv + vec2 (- d.x , -d. y )). xyz +\n    2.0 * texture ( iChannel0 , uv + vec2 ( 0.0 , -d. y )). xyz +\n    1.0 * texture ( iChannel0 , uv + vec2 ( d.x , -d. y )). xyz +\n    -1.0 * texture ( iChannel0 , uv + vec2 (- d.x , d. y )). xyz +\n    -2.0 * texture ( iChannel0 , uv + vec2 ( 0.0 , d. y )). xyz +\n    -1.0 * texture ( iChannel0 , uv + vec2 ( d.x , d. y )). xyz\n    ) / 4.0;\n    fragColor = vec4 ( dot (u , u), dot (v , v), dot (u , v ), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 o;\n    structureTensors(o, uv);\n    fragColor = o;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const float PI = 3.14159265358979323846;\n\nfloat gaussian(float sigma, float pos) {\n    return (1.0f / sqrt(2.0f * PI * sigma * sigma)) * exp(-(pos * pos) / (2.0f * sigma * sigma));\n}\n\nvoid blur1(out vec4 fragColor, vec2 uv) {\n    int kernelRadius = 5;\n\n    vec4 col = vec4(0);\n    float kernelSum = 0.0f;\n\n    for (int x = -kernelRadius; x <= kernelRadius; ++x) {\n        vec3 c = texture ( iChannel1 , uv + vec2(x, 0) * 1./iResolution.xy). xyz;\n        float gauss = gaussian(2.0f, float(x));\n\n        col += vec4(c, 1) * gauss;\n        kernelSum += gauss;\n    }\n\n    fragColor = col / kernelSum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 o;\n    blur1(o, uv);\n    fragColor = o;\n}","name":"Buffer B","description":"","type":"buffer"}]}