{"ver":"0.1","info":{"id":"lcGczd","date":"1732244108","viewed":66,"name":"Ice Cream Shadows","username":"Akeniston","description":"Shadows","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["icecream"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis code creates shadows and subsurface scattering from a height map. This is the data: \niChannel0: HeightMap\niChannel1: Normal Map (for comparison: You can use arrow buttons) \niChannel2: Keyboard\n*/\n\n\n\nconst float pi=3.1416;\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\n\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat smooth_step( float min, float max, float x )\n{\n    float t =(x - min) / (max - min);\n    t = clamp(t, 0.0, 1.0);\n    t = t * t * (3.0 - 2.0 * t); // smoothstep formula   \n    return t;\n}\n\nfloat step2( float min, float max, float x )\n{\n    float t =(x - min) / (max - min);\n    t = clamp(t, 0.0, 1.0); \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy; //Normalized pixel coordinates\n    \n    vec4 col = vec4(0.0);\n    vec4 img0 = texture(iChannel0, uv);\n    vec4 img1 = texture(iChannel1, uv);\n    vec4 img2 = vec4(0.0,0.0,0.0,1.0);\n    vec4 img3 = vec4(1.0,1.0,1.0,1.0);\n    \n    vec3 normals= 2.0*img1.rgb - vec3(1.0); \n    normals = normals/length(normals); \n    \n    \n    int num_of_Samples=100; \n    float d=0.5;\n    float R=d; \n    vec3 shader_point=vec3(fragCoord,(1.0+d)*img0.x-d);\n    float a=5.0;\n    \n    vec3 light_position = vec3(iMouse.x,iMouse.y,3.00); \n    vec3 light_vector = light_position - shader_point;\n    vec3 light_dir=light_vector/length(light_vector); \n    \n    \n    for (int i=0; i<num_of_Samples; i++) {\n    vec3 pos=shader_point+float(i)*d*a*light_dir+ 0.00125*vec3(random(shader_point.xy));\n    vec2 pos_uv= pos.xy/iResolution.xy; \n    vec4 H = texture(iChannel0,pos_uv);\n    if(H.x>pos.z) R=R+d; \n    }\n    \n    float t=d/R;\n    t=2.0*pow(t,0.45);\n    t=clamp(t,0.0,1.0);\n    \n    float dif= 0.5*dot(light_dir,normals)+0.5;\n    float W=pow(dif,10.0);\n    \n    if(texelFetch( iChannel2, ivec2(KEY_UP,0),0).x == 1.0) t=dif;\n    if(texelFetch( iChannel2, ivec2(KEY_DOWN,0),0).x == 1.0)\n    {float W=0.10; t=W*dif+(1.0-W)*t;}\n    if(texelFetch( iChannel2, ivec2(KEY_LEFT,0),0).x == 1.0)\n    {W=W/2.0; t=W*dif+(1.0-W)*t;}\n    if(texelFetch( iChannel2, ivec2(KEY_RIGHT,0),0).x == 1.0)\n    {W=W/3.0; t=W*dif+(1.0-W)*t;}\n    \n    \n    col = img2*(1.0-t)+img3*t;  \n \n    fragColor = vec4(col);    // Output to screen\n}","name":"Image","description":"","type":"image"}]}