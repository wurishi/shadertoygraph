{"ver":"0.1","info":{"id":"MdtBz2","date":"1526038067","viewed":636,"name":"Voronoi Noise Grid","username":"csbdev","description":"Many different types of voronoi noise. Made this a while ago, thought it might be worth sharing.","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TILING 12.0\n\n// distance functions\n#define DISTANCE 0\n#define SQR_DISTANCE 1\n#define MINKOWSKI 2\n#define MANHATTAN 3\n#define CHEBYCHEV 4\n#define QUADRATIC 5\n\n// voronoi types\n#define CLOSEST_1 0\n#define CLOSEST_2 1\n#define DIFFERENCE_21 2\n#define CRACKLE 3\n\nfloat sqr_distance(vec3 a, vec3 b)\n{\n    vec3 d = a - b;\n    return dot(d, d);\n}\n\nfloat manhattan(vec3 a, vec3 b)\n{\n    vec3 d = abs(a - b);\n    return d.x + d.y + d.z;\n}\n\nfloat chebychev(vec3 a, vec3 b)\n{\n    return max(max(abs(a.x - b.x), abs(a.y - b.y)), abs(a.z - b.z));\n}\n\nfloat quadratic(vec3 a, vec3 b)\n{\n    vec3 d = a - b;\n    return (d.x*d.x+d.y*d.y+d.z*d.z+d.x*d.y+d.x*d.z+d.y*d.z);\n}\n\nfloat minkowski(vec3 a, vec3 b)\n{\n    vec3 d = a - b;\n    float p = 0.5;\n    \n    return pow(dot(pow(abs(d), vec3(p)), vec3(1.0)), 1.0 / p);\n}\n\n// iq\nvec3 random3f( vec3 p )\n{\n    return fract(sin(vec3( dot(p,vec3(1.0,57.0,113.0)), \n                           dot(p,vec3(57.0,113.0,1.0)),\n                           dot(p,vec3(113.0,1.0,57.0))))*43758.5453);\n}\n\nfloat voronoi3(vec3 p, int dist_func, int type)\n{\n    vec3 fp = floor(p);\n    \n    float d1 = 1./0.;\n    float d2 = 1./0.;\n    \n    for(int i = -1; i < 2; i++)\n    {\n        for(int j = -1; j < 2; j++)\n        {\n            for(int k = -1; k < 2; k++)\n            {\n                vec3 cur_p = fp + vec3(i, j, k);\n                \n                vec3 r = random3f(cur_p);\n                \n                float cd = 0.0;\n                \n                if(dist_func == DISTANCE)\n                \tcd = distance(p, cur_p + r);\n                else if(dist_func == SQR_DISTANCE)\n                \tcd = sqr_distance(p, cur_p + r);\n                else if(dist_func == MANHATTAN)\n                \tcd = manhattan(p, cur_p + r);\n                else if(dist_func == CHEBYCHEV)\n                    cd = chebychev(p, cur_p + r);\n                else if(dist_func == QUADRATIC)\n                    cd = quadratic(p, cur_p + r);\n                else if(dist_func == MINKOWSKI)\n                    cd = minkowski(p, cur_p + r);\n                \n                d2 = min(d2, max(cd, d1));\n                d1 = min(d1, cd);\n            }\n        }\n    }\n    \n    if(type == CLOSEST_1)\n    \treturn d1;\n    else if(type == CLOSEST_2)\n        return d2;\n    else if(type == DIFFERENCE_21)\n        return d2 - d1;\n    else if(type == CRACKLE)\n        return clamp(max(0.5, 16.0 * (d2-d1)), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screen = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0);\n    \n    // determine the voronoi type and distance function to use\n    int voronoi_type = int((1.0 - screen.y) / (2./4.));\n    int dist_func = int((screen.x + 1.0) / (2./6.));\n    \n    // get the value at this pixel\n    screen.x *= iResolution.x / iResolution.y;\n    vec3 pos = vec3(screen * TILING, iTime * 0.5);\n    float h = voronoi3(pos, dist_func, voronoi_type);\n    \n    // invert every 4 seconds\n    float invert_time = mod(iTime, 8.0);\n    if(invert_time > 4.0) h = 1.0 - h;\n    \n    fragColor = vec4(vec3(1.0f - h), 1);\n}\n","name":"Image","description":"","type":"image"}]}