{"ver":"0.1","info":{"id":"mdyyzd","date":"1696460978","viewed":47,"name":"00GraphicsClassLesson10","username":"foodini","description":"Bump Mapping","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","bumpmapping"],"hasliked":0,"parentid":"DdtyDN","parentname":"00GraphicsClassLesson06"},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Things to have a student do:\n// * MAKE IT PRETTY! I'm color blind, so you're going to have to fix the colors yourself!!!\n// * Explain why the ground plane has blinking band in the distance. Why does it bend\n//   near the object? How might it be reduced? How might it be elimininated (almost)\n//   entirely with minimal computational cost?\n// * Write a function that can be used to recenter any object to <0.5, 0.5, 0.5>\n//   * Use this function to get rid of the hard-coded offset in map_ground_plane\n//   * Instance the recentered object. (In-person only.)\n// * Make the object reflective. GLSL has a reflect() function.\n// * How would you support lots of unrelated objects, each with their own shading \n//   functions? What are the advantages/drawbacks of doing a trace of the whole world\n//   in one loop, versus having one loop for each compound object?\n// * Multiple light sources? If you put several light sources close enough together,\n//   it can look like you have \"soft\" shadows.\n\nconst float PI = 3.141592657;\n\nfloat map_composite_object( in vec3 p) {\n    //p = mod(p, 10.0) - 5.0;\n    if(true) {\n        float dist = sdf_sphere(p - vec3(1.0,0.0,0.0), 1.5);\n        //return hard_intersection(dist, sdf_sphere(p + vec3(1.0,0.0,0.0), 1.5));\n        //return hard_subtraction(sdf_sphere(p + vec3(1.0,0.0,0.0), 1.5), dist);\n        return smooth_union(\n            dist, \n            sdf_sphere(p + vec3(1.0,0.0,0.0), 1.5),\n            0.1);\n    }\n\n    if(false) {\n        mat4 rot_x = rotation_x(p.x);\n        p.xyz = (vec4(p, 1.0) * rot_x).xyz;\n        vec2 torus_radii = vec2(1.5, 0.12);\n        float dist = sdTorus(p, torus_radii);\n        return dist;\n    }\n\n    if(true) {\n        vec2 torus_radii = vec2(1.5, 0.12);\n        float dist = sdTorus(p, torus_radii);\n        mat4 composite = rotation_z(300.0 + iTime/10.0 + PI/5.0); // IT IS DANGEROUS TO REPEATEDLY ALTER FLOATS....\n        composite *= rotation_y(333.3 + iTime/12.1 + PI/7.0);\n        //composite *= rotation_z(673.6 + iTime/17.3 + PI/9.0);\n        for(float rad=PI/12.0; rad<PI; rad += PI/12.0) {\n            p.xyz = (vec4(p, 1.0) * composite).xyz;\n            dist = smooth_union(dist, sdTorus(p, torus_radii), 0.1);\n        }\n        return dist;   \n    }\n    \n    if(false) {\n        float dist;\n        float dn;\n        float sphere_r;\n        vec3 sphere_pos;\n        sphere_pos = vec3(sin(iTime), cos(iTime*1.2), .7*sin(iTime*0.6));\n        sphere_r = 0.5 + 0.3*sin(iTime*9.0);\n        dist = sdf_sphere(p-sphere_pos, sphere_r);\n        \n        sphere_pos = vec3(-0.5*sin(2.7*iTime), 1.2*cos(iTime*0.5), .2*sin(iTime*1.3));\n        sphere_r = 0.6 + 0.2*sin(iTime*3.6);\n        dn = sdf_sphere(p-sphere_pos, sphere_r);\n        dist = smooth_union(dist, dn, sphere_r);\n\n        sphere_pos = vec3(-0.57*sin(1.3*iTime), 0.74*cos(iTime*7.5), .475*sin(iTime*6.3));\n        sphere_r = 0.49 + 0.355*sin(iTime*6.12);\n        dn = sdf_sphere(p-sphere_pos, sphere_r);\n        dist = smooth_union(dist, dn, sphere_r);\n\n        sphere_pos = vec3(-0.75*sin(3.14*iTime), 1.77*cos(iTime*5.29), .392*sin(iTime*3.98));\n        sphere_r = 0.73 + 0.297*sin(iTime*5.12);\n        dn = sdf_sphere(p-sphere_pos, sphere_r);\n        dist = smooth_union(dist, dn, sphere_r);\n\n        sphere_pos = vec3(-0.23*sin(1.19*iTime), 0.53*cos(iTime*0.92), .297*sin(iTime*0.95));\n        sphere_r = 0.35 + 0.297*sin(iTime*0.12);\n        dn = sdf_sphere(p-sphere_pos, sphere_r);\n        dist = smooth_union(dist, dn, sphere_r);\n\n        return dist;\n    }\n    \n    if(false) {\n        return smooth_subtraction(\n            sdf_rounded_box(p, vec3(1.0), 0.425),\n            sdf_sphere(p, 1.74),\n            0.2);\n    }\n    if(false) {\n        float dist = hard_intersection(\n            hard_subtraction(\n                sdf_rounded_box(p, vec3(1.0), 0.425),\n                sdf_sphere(p, 1.74)),\n            sdf_sphere(p, 1.9));\n        vec3 dx = vec3(1.0, 0.0, 0.0);\n        vec3 dy = vec3(0.0, 1.0, 0.0);\n        vec3 dz = vec3(0.0, 0.0, 1.0);\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx + dy + dz, 0.3), 0.1);\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx + dy - dz, 0.3), 0.1);\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx - dy + dz, 0.3), 0.1);\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx - dy - dz, 0.3), 0.1);\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx + dy + dz, 0.3), 0.1);\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx + dy - dz, 0.3), 0.1);\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx - dy + dz, 0.3), 0.1);\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx - dy - dz, 0.3), 0.1);\n        return dist;\n    } \n    if(true) {\n        float mod_time = mod(iTime, 22.0);\n        float dist = sdf_rounded_box(p, vec3(1.0), 0.425);\n        if(mod_time < 2.0) return dist;\n        dist = hard_subtraction(dist, sdf_sphere(p, 1.74));\n        if(mod_time < 4.0) return dist;\n        dist = hard_intersection(dist, sdf_sphere(p, 1.9));\n\n        vec3 dx = vec3(1.0, 0.0, 0.0);\n        vec3 dy = vec3(0.0, 1.0, 0.0);\n        vec3 dz = vec3(0.0, 0.0, 1.0);\n        if(mod_time < 6.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx + dy + dz, 0.3), 0.1);\n        if(mod_time < 8.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx + dy - dz, 0.3), 0.1);\n        if(mod_time < 10.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx - dy + dz, 0.3), 0.1);\n        if(mod_time < 12.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p + dx - dy - dz, 0.3), 0.1);\n        if(mod_time < 14.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx + dy + dz, 0.3), 0.1);\n        if(mod_time < 16.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx + dy - dz, 0.3), 0.1);\n        if(mod_time < 18.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx - dy + dz, 0.3), 0.1);\n        if(mod_time < 20.0) return dist;\n        dist = smooth_subtraction(dist, sdf_sphere(p - dx - dy - dz, 0.3), 0.1);\n\n        return dist;\n    }\n}\n\nbool dist_to_composite_object( in vec3 p, in vec3 d, out float total_dist, out int iterations ) {\n    total_dist = 0.0;\n    for(int iterations=0; iterations<150; iterations++) {\n        float dist = map_composite_object(p);\n        total_dist += dist;\n        if(dist < 0.001) {\n            return true;\n        }\n        if(total_dist > 10.0) {\n            return false;\n        }\n        p += dist * d;\n    }\n    return false;\n}\n\nbool dist_to_ground_plane( in vec3 p, in vec3 d, out float total_dist) {\n    // Set our ground plane 2 units down;\n    p.y += 2.5;\n    \n    // If d points downward, p had better be above the ground plane and vice-versa:\n    if(p.y * d.y > 0.0) {\n        return false;\n    }\n    \n    // This computes \"how many\" ds we need to travel from p to get to the plane:\n    float scale = -p.y/d.y;\n    \n    // Assuming d is normalized (which it should be), this just returns scale:\n    total_dist = length(d*scale);\n    return true;\n}\n\nfloat map_ground_plane( in vec3 p) {\n    return p.y + 2.0;\n}\n\nvec3 calc_normal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    vec3 normal = normalize( \n        vec3(map_composite_object(p+h.xyy) - map_composite_object(p-h.xyy),\n             map_composite_object(p+h.yxy) - map_composite_object(p-h.yxy),\n             map_composite_object(p+h.yyx) - map_composite_object(p-h.yyx) ) );\n    return normal;\n}\n\n// Nothing says the light_col is limited to values <= 1.0!!!\nvec3 light_col = vec3(0.8, 0.6, 1.0);\nvec3 light_pos = vec3(2.0, 5.0, 2.0);\nfloat light_size = 1.0;\n\nbool is_shadowed(in vec3 p, in vec3 normal, in vec3 light_pos) {\n    float distance_travelled = 0.0;\n    \n    // p is already very close to a surface. If we just check to see how far from\n    // that surface we are and assume we've hit it when d<0.001, we'll always think\n    // we've hit it in the first iteration. What happens if this value is too small?\n    p += normal * 0.002;\n    vec3 light_dir = light_pos - p;\n    float dist_to_light = length(light_dir);\n    //normalize light_dir:\n    light_dir /= dist_to_light;\n    \n    for(int iterations = 0; iterations < 40; iterations++) {\n        float d = map_composite_object(p);\n        distance_travelled += d;\n        if(distance_travelled > dist_to_light) {\n            return false;\n        }\n        if(d < 0.001) {\n            return true;\n        }\n        p += d * light_dir;\n    }\n    \n    // you could make an argument to go either way... true is probably better.\n    return true;\n}\n    \n// MAKE VERY SURE THAT to_viewpoint and normal ARE NORMALIZED (length == 1.0)\nvec3 lighting(in vec3 p, in vec3 to_viewpoint, in vec3 normal, in vec3 light_col, in vec3 light_pos, in vec3 surface_col) {\n    float shadow_test_count = 1.0;\n    vec3 lit_color = vec3(0.0);\n    for(float shadow_test=1.0; shadow_test<=shadow_test_count; shadow_test++) {\n        vec3 area_light_pos = light_pos + rand_vec3() * light_size;\n    \n        vec3 area_light_dir = normalize(area_light_pos - p);\n        float diffuse_brightness = dot(normal, area_light_dir);\n        if(diffuse_brightness > 0.0) {\n            if(!is_shadowed(p, normal, area_light_pos)) {\n                lit_color += diffuse_brightness * light_col * surface_col;\n                \n                vec3 reflection = 2.0 * normal * dot(normal, area_light_dir) - area_light_dir;\n                float cos_refl_viewpt = dot(reflection, to_viewpoint);\n                if(cos_refl_viewpt > 0.0) {\n                    lit_color += light_col * pow(cos_refl_viewpt, 100.0);\n                }\n            }\n        }\n    }\n    \n    return lit_color/shadow_test_count;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    srand(fragCoord, iResolution, iFrame);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // We want 0,0 to be the center of the screen, so rescale and recenter:\n    uv *= 2.0;\n    uv -= 1.0;\n    \n    // The pixels in the image now go from <-1.0, -1.0> at the bottom left to\n    // <1.0, 1.0> at the top right. This means our pixels are squashed. Rescale\n    // in the y direction to compensate:\n    uv.y /= (iResolution.x/iResolution.y);\n    \n    // Set up the camera:\n    float camera_distance_from_origin = 7.0;\n    vec3 camera_position = vec3(\n        sin(iTime/2.0) * camera_distance_from_origin,\n        -0.5,\n        cos(iTime/2.0) * camera_distance_from_origin);\n        \n    vec3 camera_lookat_point = vec3(0.0, 0.0, 0.0);\n    \n    // Setting up the camera takes a bit of magic. The cross product of two vectors gives\n    // you a third vector at right angles to both of the input vectors. Our camera is at \n    // some arbitrary point in space, pointing at some other arbitrary point in space. To\n    // figure out which way is up and which way is right, we have to do some assuming. We\n    // want the camera to be level, so the right vector must be perpendicular to <0, 1, 0>\n    // AND the look direction, so let's start with that:\n    // !!!!NOTE!!!!\n    // This all goes to hell if your camera is directly above or below the lookat point,\n    // because the cross product of the look vector and <0, 1, 0> is undefined. Don't.\n    vec3 look_direction = normalize(camera_lookat_point - camera_position);\n    vec3 right = normalize(cross(look_direction, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, look_direction));\n    \n    // To get the direction a \"reverse photon\" travels from the eyepoint, we put the uv \n    // \"screen\" in front of the eyepoint and find the vector from the eyepoint through\n    // the pixel we're currently processing:\n    float eyepoint_to_screen_distance = 2.0;\n    vec3 pixel_location = camera_position + eyepoint_to_screen_distance * look_direction +\n        right * uv.x + up * uv.y;\n    vec3 ray_direction = normalize(pixel_location - camera_position);\n    \n    // 1) Start at the camera position.\n    // 2) Check to see how far current_position is from object(s).\n    // 3) Move along the camera->pixel direction by that distance.\n    // 4) goto 2, until you've either gone too far from objects to expect to ever hit them,\n    //    or, you're so close to one that we'll assume you've hit the object.\n    // 5) If you hit the compound object, find its normal and just use that as its color,\n    //    otherwise, you hit the ground plane and choose a color that paints the grid.\n    // 6) If you've iterated too many times, give up and return blinking green to draw\n    //    attention to the issue.\n    vec3 current_position = camera_position;\n\n    int obj_iterations;\n    float obj_dist;\n    float plane_dist;\n    bool obj_isect;\n    bool plane_isect;\n    vec3 obj_isect_point;\n    vec3 plane_isect_point;\n    \n    for(float reflection_count=0.0; reflection_count<10.0; reflection_count++) {\n        obj_isect = dist_to_composite_object(current_position, ray_direction, obj_dist, obj_iterations);\n        plane_isect = dist_to_ground_plane(current_position, ray_direction, plane_dist);\n        if(obj_isect) {\n            obj_isect_point = current_position + ray_direction * obj_dist;\n        }\n        if(plane_isect) {\n            plane_isect_point = current_position + ray_direction * plane_dist;\n        }\n\n        if(obj_isect) {\n            //HUGE ASSUMPTION HERE that the object is ALWAYS closer than the ground plane:\n            vec3 normal = calc_normal(obj_isect_point);\n            current_position = obj_isect_point + normal * 0.01;\n            ray_direction = reflect(ray_direction, normal);\n        } else {\n            if(plane_isect) {\n                vec3 c = vec3(1.0, 0.0, 0.0);\n                if((int(plane_isect_point.x+1000.0) + int(plane_isect_point.z + 1000.0)) % 2 == 0) {\n                    c = vec3(0.0, 0.0, 1.0);\n                }\n                fragColor.rgb = lighting(plane_isect_point, -ray_direction, vec3(0.0, 1.0, 0.0), light_col, light_pos, c);\n                //fragColor.rgb=c;\n                return;\n            }\n        }\n    }\n    fragColor = texture(iChannel0, ray_direction);\n    //fragColor.rgb = vec3(0.0, (1.0-ray_direction.y)/1.5, 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float hard_union( float d0, float d1 ) {\n    return(min(d0, d1));\n}\n\nfloat hard_subtraction( float d0, float d1 ) {\n    return(max(d0, -d1));\n}\n\nfloat hard_intersection( float d0, float d1 ) {\n    return(max(d0, d1));\n}\n\nfloat smooth_union( float d0, float d1, float k ) {\n    float h = clamp( 0.5 + 0.5*(d0-d1)/k, 0.0, 1.0 );\n    return mix( d0, d1, h ) - k*h*(1.0-h); }\n\nfloat smooth_subtraction( float d0, float d1, float k ) {\n    float h = clamp( 0.5 - 0.5*(d0+d1)/k, 0.0, 1.0 );\n    return mix( d0, -d1, h ) + k*h*(1.0-h); }\n\nfloat smooth_intersection( float d0, float d1, float k ) {\n    float h = clamp( 0.5 - 0.5*(d0-d1)/k, 0.0, 1.0 );\n    return mix( d0, d1, h ) + k*h*(1.0-h); }\n\n// TODO: \n// * more shapes!\n\n// If you're looking toward the origin from a point on the positive x axis, \n// this is a clockwise rotation.\nmat4 rotation_x(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, c,  -s,   0.0,\n                0.0, s,   c,   0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\n// If you're looking toward the origin from a point on the positive x axis, \n// this is a clockwise rotation.\nmat4 rotation_y(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(c,   0.0, -s,  0.0,\n                0.0, 1.0, 0.0, 0.0,\n                s,   0.0, c,   0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\n// If you're looking toward the origin from a point on the positive x axis, \n// this is a clockwise rotation.\nmat4 rotation_z(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat4(c,   -s,  0.0, 0.0,\n                s,   c,   0.0,  0.0,\n                0.0, 0.0, 1.0,  0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\n// If you're looking toward the origin from a point along the rotation axis,\n// this is a clockwise rotation (in our left-handed coordinate system.)\nmat4 rotation_arbitrary(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat4 translate(vec4 delta) {\n    return mat4(1.0, 0.0, 0.0, delta.x,\n                0.0, 1.0, 0.0, delta.y,\n                0.0, 0.0, 1.0, delta.z,\n                0.0, 0.0, 0.0, 1.0);\n}\n\n// LOOK AT https://iquilezles.org/articles/distfunctions/ for the best SDF reference\n// anywhere.\n\n// The \"signed distance function\" for a box with rounded corners. \nfloat sdf_rounded_box( in vec3 p, in vec3 r, in float radius) {\n    return length(max(abs(p) - r, 0.0)) - radius;\n}\n\nfloat sdf_sphere( in vec3 p, in float radius) {\n    return length(p) - radius;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n//Adapted from: https://gist.github.com/keijiro/24f9d505fac238c9a2982c0d6911d8e3\nuint rand_seed;\n\nuint hash()\n{\n    rand_seed ^= 2747636419u;\n    rand_seed *= 2654435769u;\n    rand_seed ^= rand_seed >> 16;\n    rand_seed *= 2654435769u;\n    rand_seed ^= rand_seed >> 16;\n    rand_seed *= 2654435769u;\n    return rand_seed;\n}\n\nfloat random()\n{\n    return float(hash()) / 4294967295.0; // 2^32-1\n}\n\nconst int rand_vec_retries = 5;\n\nvec2 rand_vec2() {\n    vec2 retval;\n    float len;\n    for(int i=0; i<rand_vec_retries; i++) { // AGH!\n        retval = vec2(random(), random());\n        len = length(retval);\n        if(len < 1.0)\n            return normalize(retval);\n    }\n    return normalize(retval);\n}\n\nvec3 rand_vec3() {\n    vec3 retval;\n    float len;\n    for(int i=0; i<rand_vec_retries; i++) { // AGH!\n        retval = vec3(random(), random(), random());\n        len = length(retval);\n        if(len < 1.0)\n            return normalize(retval);\n    }\n    return normalize(retval);\n}\n\nvec4 rand_vec4() {\n    vec4 retval;\n    float len;\n    for(int i=0; i<rand_vec_retries; i++) { // AGH!\n        retval = vec4(random(), random(), random(), random());\n        len = length(retval);\n        if(len < 1.0)\n            return normalize(retval);\n    }\n    return normalize(retval);\n}\n\nvoid srand(vec2 fragCoord, vec3 iResolution, int iFrame){\n    rand_seed = uint(fragCoord.y*iResolution.x + fragCoord.x)+uint(iFrame)*uint(iResolution.x)*uint(iResolution.y);\n}\n","name":"Common","description":"","type":"common"}]}