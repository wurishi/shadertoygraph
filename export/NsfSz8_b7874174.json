{"ver":"0.1","info":{"id":"NsfSz8","date":"1618323672","viewed":321,"name":"Improved Perlin Noise 3D","username":"khalladay","description":"\"Improved\" 3D Perlin noise (from the \"Improving Noise\" paper) used to distort the surface of a sphere. Perlin noise also used for background and sphere surface color because yolo. Click and drag to rotate the camera around the sphere","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_OCTAVES 2\n\n//uncomment below for original recipe perlin noise\n//#define OLD_PERLIN\n\n//not perfect, but the best looking hash function that I found after\n//trying out a couple. No jarring discontinuities as UVs scroll and less\n//repetitive than others I tried. Taken from https://www.shadertoy.com/view/4djSRW\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//the \"fade\" function defines the value used to blend values\n//from each corner of the unit cube\n//The \"Improving Noise\" paper updates\n//this from 3t^2-2t^3 to 6t^5-15t^4+10t^3\nfloat fade(float t)\n{\n#ifdef OLD_PERLIN\n    return t * t * (3.0-2.0*t);\n#else\n    return  t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n#endif\n}\n\n//original perlin noise calculates gradient functions randomly, whereas \"improved\" perlin\n//selects randomly from a fixed array of vectors.\nvec3 grad(vec3 p)\n{\n#ifdef OLD_PERLIN\n    return -1.0 + 2.0 *vec3(hash31(p.xyz), hash31(p.yxy), hash31(p.zyx));\n#else\n    float r = hash31(p)*16.0;\n    int ri = int(r);\n    \n    vec3 grads[16];\n\n    grads[0] = vec3(1.0, 1.0, 0.0);\n    grads[1] = vec3(-1.0, 1.0, 0.0);\n    grads[2] = vec3(1.0, -1.0, 0.0);\n    grads[3] = vec3(-1.0, -1.0, 0.0);\n    \n    grads[4] = vec3(1.0, 0.0, 1.0);\n    grads[5] = vec3(-1.0, 0.0, 1.0);\n    grads[6] = vec3(1.0, 0.0, -1.0);\n    grads[7] = vec3(-1.0, 0.0, 1.0);\n\n    grads[8] = vec3(0.0, 1.0, 1.0);\n    grads[9] = vec3(0.0, -1.0, 1.0);\n    grads[10] = vec3(0.0, 1.0, -1.0);\n    grads[11] = vec3(0.0, -1.0, -1.0);\n\n    //pad array to 16 to avoid the cost of dividing by 12\n    grads[12] = vec3(1.0, 1.0, 0.0);\n    grads[13] = vec3(-1.0, 1.0, 0.0);\n    grads[14] = vec3(0.0, -1.0, 1.0);\n    grads[15] = vec3(0.0, -1.0, -1.0);\n\n    return grads[ri%16];\n#endif\n}\n\nfloat perlin3d(vec3 p)\n{\n    //floorP is used to generate the gradient vectors for the 4 corners of the unit cube\n    //that surround point p. Since we already need floorP, it's easier to get fractP\n    //via subtraction than a fract()\n    vec3 floorP = floor(p);\n    vec3 fractP = p - floorP;\n    \n    //calculate distance vectors from the input coordinate to the 4 corners of the unit cube\n    //these are used to weight the contributions from each corner's gradient vector\n    \n    // \"near\" corners (z == 0)\n    vec3 ntopLeft = fractP - vec3(0.0, 1.0, 0.0);\n    vec3 ntopRight = fractP - vec3(1.0,1.0, 0.0);\n    vec3 nbottomLeft = fractP;\n    vec3 nbottomRight = fractP - vec3(1.0,0.0, 0.0);\n    \n    // \"far\" corners (z > 0)\n    vec3 ftopLeft = fractP - vec3(0.0, 1.0, 1.0);\n    vec3 ftopRight = fractP - vec3(1.0,1.0, 1.0);\n    vec3 fbottomLeft = fractP - vec3(0.0,0.0,1.0);\n    vec3 fbottomRight = fractP - vec3(1.0,0.0, 1.0);\n\n    //determine gradient vectors for each corner of the cube\n    //must be uniform for all sample points within the same \"tile\" of the noise plane.\n    //(so (2.4,1.2)'s gradient vectors will be the same as (2.7,1.6)'s)\n    vec3 ntopLeftGrad = grad(floorP + vec3(0.0, 1.0, 0.0));\n    vec3 ntopRightGrad = grad(floorP + vec3(1.0, 1.0, 0.0));\n    vec3 nbottomLeftGrad = grad(floorP);\n    vec3 nbottomRightGrad = grad(floorP + vec3(1.0, 0.0, 0.0));\n    \n    vec3 ftopLeftGrad = grad(floorP + vec3(0.0, 1.0, 1.0));\n    vec3 ftopRightGrad = grad(floorP + vec3(1.0, 1.0, 1.0));\n    vec3 fbottomLeftGrad = grad(floorP + vec3(0.0, 0.0, 1.0));\n    vec3 fbottomRightGrad = grad(floorP + vec3(1.0, 0.0, 1.0));\n    \n    float ng1 = dot(ntopLeft, ntopLeftGrad);\n    float ng2 = dot(ntopRight, ntopRightGrad);\n    float ng3 = dot(nbottomLeft, nbottomLeftGrad);\n    float ng4 = dot(nbottomRight, nbottomRightGrad);\n    \n    float fg1 = dot(ftopLeft, ftopLeftGrad);\n    float fg2 = dot(ftopRight, ftopRightGrad);\n    float fg3 = dot(fbottomLeft, fbottomLeftGrad);\n    float fg4 = dot(fbottomRight, fbottomRightGrad);\n\n    //mix 2 bottom influences together, left to right, according to fade(fractP.x)\n    //then blend them bottom to top according to fade(fractP.y)\n    float nmix = mix( mix(ng3,ng4,fade(fractP.x)), mix(ng1,ng2,fade(fractP.x)), fade(fractP.y) );\n    float fmix = mix( mix(fg3,fg4,fade(fractP.x)), mix(fg1,fg2,fade(fractP.x)), fade(fractP.y) );\n    return mix(nmix, fmix, fade(fractP.z));\n}\n\nfloat fbm( in vec3 x)\n{    \n    float H = 1.0;\n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<NUM_OCTAVES; i++ )\n    {\n        t += a*perlin3d(f*x);\n        f *= 2.0;\n        a *= -G/1.5;\n    }\n    return t;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nfloat map(vec3 at)\n{\n  return sdSphere(at, 3.0) + fbm(at * 1.25);\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e);\n    }\n    return normalize(n);   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mouseX = (-iMouse.x / iResolution.x) * 10.0;\n    \n    //xz coords for camera are a circle\n    vec3 CAM_OFFSET = 6.0 * (vec3( cos(mouseX), 0.0 , sin(mouseX) ));    \n\tvec3 CAM_UP = vec3(0.0, 1.0, 0.0);\n\tvec3 CAM_POS = vec3(0,3,0) + CAM_OFFSET;\n\tvec3 CAM_LOOKPOINT = vec3(0.0, 0.0, 0.0);\n\t\n\tvec3 lookDirection = normalize(CAM_LOOKPOINT - CAM_POS);\n\tvec3 viewPlaneU = normalize(cross(CAM_UP, lookDirection));\n\tvec3 viewPlaneV = cross(lookDirection, viewPlaneU);\n\tvec3 viewCenter = lookDirection + CAM_POS;\n\t\n    //remap uvs to -1 - +1\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n\n\tvec3 fragWorldPos = viewCenter + (uv.x * viewPlaneU * iResolution.x / iResolution.y) + (uv.y * viewPlaneV);\n\tvec3 camPosToFragWorld = normalize(fragWorldPos - CAM_POS);\n\n\tconst float farClip = 50.0;\n\t\n\tvec3 col = mix(vec3(perlin3d(vec3(fragCoord.xy*0.05,iTime*0.5))) * vec3(0.25), vec3(0.3,0.5,0.95)*vec3(1.0+perlin3d(vec3(fragCoord.xy*0.025,iTime*0.5))), fragCoord.y/iResolution.y);\n    \n    vec3 light1 = normalize(vec3(1,1,-1));\n\n\tvec3 p = CAM_POS;\n\tfor (int i = 0; i < 128; ++i)\n    {\n        float s=map(p);\n\n        if ( abs(s) < 0.001 )\n\t\t{\n            vec3 nrm = (calcNormal(p));\n            vec3 sphereCol = mix(vec3(0.95,0.25,0.25), vec3(1,1,1), 0.5+perlin3d(p*0.5));\n              \n            vec3 halfVec = normalize(light1 + camPosToFragWorld);\n            float spec = pow(max(dot(nrm, halfVec), 0.0), 32.0);\n\n\n            col = sphereCol * max(0.0, dot(nrm, light1));\n            col += sphereCol * spec;\n            col += sphereCol * 0.25;\n\n            break;\n\t\t}\n       \n        if (s > 10.0) break;\n        \n        //we don't have a true distance function, so we need to \n        //reduce the size of our steps to eliminate holes in the render\n\t\tp += camPosToFragWorld*s*0.4;\n\n    }\n  \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}