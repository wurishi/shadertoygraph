{"ver":"0.1","info":{"id":"7dcyDs","date":"1654233982","viewed":212,"name":"moon noise","username":"Carandiru","description":"moon noise generation (heightmap)\nexcellent craters, great moonscape","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_DISTINCT_GROUND_HEIGHTS 15\n#define GRID_SIZE (2048.0)\n#define NOISE_SCALAR_HEIGHT (13.0) * (GRID_SIZE / 512.0)\n#define EDGE_DETECTION_THRESHOLD 236\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\n// iq - value - https://www.shadertoy.com/view/lsf3WH\nfloat vnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nvec2 hash2( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// iq - simplex - https://www.shadertoy.com/view/Msf3WH\nfloat snoise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash2(i+0.0)), dot(b,hash2(i+o)), dot(c,hash2(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv - 0.5f;\n    \n    uv = uv * 0.25f * (0.0125f + smoothstep(0.0f, 1.0f, abs(sin(iTime * 0.0625f))));\n\n    float f = 0.0f;\n    \n    float s = snoise(uv * NOISE_SCALAR_HEIGHT);\n    float v = vnoise(uv * 0.5f * NOISE_SCALAR_HEIGHT);\n    float b = textureLod(iChannel0, (fragCoord + vec2(s*iTime,v*iTime))/1024.0f, 0.0f).r * (1.0f/float(NUM_DISTINCT_GROUND_HEIGHTS + 1));\n      \n    s = 0.5 + 0.5*s;\n    v = 0.5 + 0.5*v;\n\t\n    uint index = uint(floor(mod(iTime, 4.0f)));\n    \n    b = mix(0.0f, b * 0.5f, bool(index > 1u));\n    \n    f = (s * v + b) * 2.0f * 255.0f;\n    \n    float fLog = 255.0f - mix(0.0f, 255.0f, log(f) / log(255.0f));\n    \n    float fLerp = mix(0.0f, 255.0f, f / 255.0f);\n    \n    int opXOR = int(fLerp) ^ int(uint(fLog));\n    int opSUB = int(fLerp - fLog);\n    int opEDGES = opSUB ^ opXOR;\n    \n    int opSHADED = opEDGES > EDGE_DETECTION_THRESHOLD ? 106 : opXOR;\n    \n    uv = fragCoord/iResolution.xy;\n    \n    bvec4 cycle = bvec4(uv.x < 0.5f, uv.y < 0.5f, uv.x > 0.5f, uv.y > 0.5f);\n    \n    f = mix(abs(float(opEDGES)), abs(float(opSHADED)), cycle[index]) / 255.0f;\n    \n    vec3 color = vec3(f);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}