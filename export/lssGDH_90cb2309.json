{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const float PI = 3.14159265358979;\nconst float\tBASE_LEAF_THICKNESS = 0.2;\nconst float\tSIDE_VEINS_THICKNESS = 0.5;\nconst float SIDE_VEINS_COUNT = 12.0;\n\nconst float\tSMALL_VEIN_DISTANCE_MIN =  0.005;\nconst float\tSMALL_VEIN_DISTANCE_MAX = -0.002;\n\nconst float\tOPTTHICK_LEAF_MIN = 1.0;\nconst float\tOPTTHICK_LEAF_MAX = 2.0;\nconst float\tOPTTHICK_VEIN_MIN = 0.8;\t\t\t// Veins let more light through\nconst float\tOPTTHICK_VEIN_MAX = 0.65;\t\t\t// Veins let more light through\nconst float\tOPTTHICK_SIDE_VEINS = 0.5;\t\t\t// Veins let more light through\nconst float\tOPTTHICK_SIDE_SMALL_VEINS = 0.5;\t// Veins let more light through\n\n#define saturate( a )\tclamp( (a), 0.0, 1.0 )\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n\n\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+ 57.0);\n    float d = hash(n+ 58.0);\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t30.0*f*f*(f*(f-2.0)+1.0)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n\n    return res;\n}\n\nfloat rmf( vec3 p )\n{\np += PI;\n\t\n    float f = 0.0;\n\n\tvec4\tN;\n\tN.x = noise( p ); p = p*2.02;\n\tN.y = noise( p ); p = p*2.03;\n\tN.z = noise( p ); p = p*2.01;\n\tN.w = noise( p );\n\tN = abs( N - vec4( 0.5 ) );\n\t\n    f += 0.5000*N.x;\n    f += 0.2500*N.y*N.x;\n    f += 0.1250*N.y*N.z;\n    f += 0.0625*N.z*N.w;\n\n    return f/0.9375;\n}\nfloat\trmf2( vec3 p )\n{\n\treturn rmf( p ) + 0.5 * rmf( p * 16.0 ) + 0.25 * rmf( p * 256.0 );\n}\n\nmat2 m2 = mat2(1.6,-1.2,1.2,1.6);\n\nfloat\tfbm( vec3 p )\n{\np += PI;\n\t\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\t\n}\n\nvec2\tdisplace( vec2 p )\n{\np += PI;\n\t\n   \tvec2 f = vec2( 0.0 );\n\n\tf.x += 0.5000*noise( p ); p = p*2.02;\n    f.x += 0.2500*noise( p ); p = p*2.03;\n    f.x += 0.1250*noise( p ); p = p*2.01;\n    f.x += 0.0625*noise( p );\n\n\tp = p / 8.0 + 12358.3446;\n\tf.y += 0.5000*noise( p ); p = p*2.02;\n    f.y += 0.2500*noise( p ); p = p*2.03;\n    f.y += 0.1250*noise( p ); p = p*2.01;\n    f.y += 0.0625*noise( p );\n\n    return f/0.9375;\t\n}\n\nfloat \tPoly3( vec4 _coeffs, vec2 _Ranges, float t )\n{\n\tt = _Ranges.x + t * (_Ranges.y - _Ranges.x);\n\treturn _coeffs.x + t * (_coeffs.y + t * (_coeffs.z + t * _coeffs.w));\n}\nfloat \tPoly4( vec4 _coeffs, float _coeffs2, vec2 _Ranges, float t )\n{\n\tt = _Ranges.x + t * (_Ranges.y - _Ranges.x);\n\treturn _coeffs.x + t * (_coeffs.y + t * (_coeffs.z + t * (_coeffs.w + t * _coeffs2)));\n}\nfloat\tSmoothSingleStep( vec2 _Ranges, vec2 _Values, float t )\n{\n\treturn mix( _Values.x, _Values.y, smoothstep( _Ranges.x, _Ranges.y, t ) );\n}\nfloat\tSmoothDoubleStep( vec3 _Ranges, vec3 _Values, float t )\n{\n\treturn step( t, _Ranges.y ) * mix( _Values.x, _Values.y, smoothstep( _Ranges.x, _Ranges.y, t ) )\n\t\t+ step( _Ranges.y, t ) * mix( _Values.y, _Values.z, smoothstep( _Ranges.y, _Ranges.z, t ) );\n}\nfloat\tSmoothTripleStep( vec4 _Ranges, vec4 _Values, float t )\n{\n\tvec3\tSteps = vec3( step( t, _Ranges.y ), step( _Ranges.y, t ), step( _Ranges.z, t ) );\n\treturn Steps.x * mix( _Values.x, _Values.y, smoothstep( _Ranges.x, _Ranges.y, t ) )\n\t\t+ Steps.y*(1.0-Steps.z) * mix( _Values.y, _Values.z, smoothstep( _Ranges.y, _Ranges.z, t ) )\n\t\t+ Steps.z * mix( _Values.z, _Values.w, smoothstep( _Ranges.z, _Ranges.w, t ) );\n}\n\n// Returns an equivalent of smoothstep( 0, 1, t ) but reversed along the y=x diagonal\n// Not exactly the reciprocal of the s-curve since tangents are not infinite at the\n//\t0 & 1 boundaries but close enough!\nfloat\tReverseSCurve( float t, float _TangentStrength )\n{\n//\tconst float TANGENT_STRENGTH = 4.0;\t// You can increase the slope at edges at the risk of losing the S shape\n\tfloat\ta = 1.0 / _TangentStrength;\n\tfloat\tb = 1.0 - a;\n\t\n\tfloat\tx = saturate( 1.0 - abs( 1.0 - 2.0 * t ) );\t// 0 at t=0, 1 at t=0.5, then back to 0 at t=1\n\tfloat\tcurve = abs( (a/(b*x+a)-a) / b );\t\t\t// Some sort of 1/x but making sure we have 1 at x=0 and 0 at x=1\n\treturn 0.5 * mix( 1.0 - curve, 1.0 + curve, t );\t// Mix the 2 mirrored curves\n}\nfloat\tReverseSmoothstep( float a, float b, float t, const float _TangentStrength )\n{\n\treturn ReverseSCurve( saturate( (t-a) / (b-a) ), _TangentStrength );\n}\n\n// Gets the length of the leaf in the specified slanted direction knowing the current position\n// Also returns the source of the leaf direction emanating from the center vein along given direction\nfloat\tGetLeafLength( vec2 _Pos, vec2 _Direction, out vec2 _CenterSource )\n{\n\t_CenterSource = _Pos - (_Pos.x / _Direction.x) * _Direction;\t// Source of the leaf in the provided direction\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The y value is in [0,1] and can help us determine the height within the leaf\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// So we can use it to know that it's broad at base and thinning at the tip...\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// But we can also use it to know the size of side veins depending on their position on the leaf, etc.\n\tfloat\tLength = 1.0 * SmoothTripleStep( vec4( -0.15, 0.02, 0.1, 1.0 ), vec4( 0.0, 0.38, 0.41, 0.0 ), _CenterSource.y ); \n\t\t\tLength *= 1.0 + 0.03 * sin(1.0*PI*SIDE_VEINS_COUNT*_CenterSource.y) * SmoothDoubleStep( vec3( 0.0, 0.2, 1.0 ), vec3( 0.5, 1.0, 0.5 ), _CenterSource.y );\n\treturn Length;\n}\n\nfloat\tGrid( vec2 p, float _Attenuation )\n{\n\tvec2\tGridPos = vec2( fract( 50.0 * p.x ), fract( 50.0 * p.y ) );\n\tvec2\tGridPosC = vec2(1.0) - GridPos;\n\tfloat\tGridX = exp( -_Attenuation*GridPos.x*GridPos.x )+exp( -_Attenuation*GridPosC.x*GridPosC.x );\n\tfloat\tGridY = exp( -_Attenuation*GridPos.y*GridPos.y )+exp( -_Attenuation*GridPosC.y*GridPosC.y );\n\treturn GridX + GridY;\n}\n\nvec2\tSmallVeinsThickness( vec2 _Base0, vec2 _Base1, vec2 _Pos, vec3 _Dist )\n{\n\tvec2\tOrtho = normalize( _Base1 - _Base0 );\n\tvec2\tAlong = vec2( Ortho.y, -Ortho.x );\n\tvec2\tGridPos = vec2( _Dist.x, dot( _Pos - _Base0, Ortho ) );\n\t\n\tfloat\tDisplacementAmplitude = mix( 0.0, 0.1, 2.0 * min( _Dist.y, _Dist.z ) / (_Dist.y+_Dist.z) );\t// Less near the veins\n\tvec2\tDisplacement = displace( 30.0*_Pos );\n\tGridPos += DisplacementAmplitude*(Displacement-0.4);\t// Torture the grid position to give an organic look\n\tGridPos -= 0.5*DisplacementAmplitude*length(Displacement)*Along; // Further displace along the vein's direction\n\t\n\tfloat\tGridLow = Grid( GridPos, 100.0 );\n\tfloat\tGridHi = Grid( 2.0 * GridPos, 50.0 );\n\tfloat \tGridThickness = (1.0/1.5) * (GridLow + 0.5 * GridHi);\n\n\t// Compute signed distance to vein (an approximation here)\n\tfloat\tSignedDist2Vein = mix( SMALL_VEIN_DISTANCE_MIN, SMALL_VEIN_DISTANCE_MAX, GridThickness );\n\t\t\n\treturn vec2( 1.0 - 0.5*GridThickness, SignedDist2Vein );\n}\n\nvec2\tSideVeins( vec2 _Pos, vec2 _Direction, float _IsLeft )\n{\n\t// We need to find the distance to the 2 closest veins\n\tfloat\tSecondClosestVein = 0.0;\n\tvec2\tSecondClosestVeinPos = vec2(0.0, -0.2);\n\tfloat\tClosestVein = 1e4;\n\tfloat\tClosestDistanceAlongVein = 1e4;\n\tfloat\tClosestLeafRatio = 0.0;\n\tvec2\tClosestVeinPos = vec2(0.0);\n\tfor ( int ii=0; ii < int(SIDE_VEINS_COUNT)+1; ii++ )\n\t{\n\t\tfloat\ti = float(ii);\n\n\t\t// Determine the base position and line direction\n\t\tvec2\tDirection = normalize( _Direction + vec2( 0.0, 0.05 * i ) );\n\t\tvec2\tVeinOrtho = vec2( -Direction.y, Direction.x );\n\t\tvec2\tVeinBase = vec2( 0.0, -0.18 + 1.02 * pow( (i + 0.5 * _IsLeft)/SIDE_VEINS_COUNT, 1.2 ) );\t// Source of the vein on the center vein. The pow is here just to pack a little more veins near the base\n\t\t\n\t\tfloat\tDistanceAlongVein = 1.05 * dot( _Pos - VeinBase, Direction );\n\n\t\t// Find the length of the leaf in that direction\n\t\tvec2\tCenterSource;\n\t\tfloat\tLeafLength = GetLeafLength( _Pos, Direction, CenterSource );\n\t\tfloat\tLeafRatio = DistanceAlongVein / LeafLength;\t// 0 at center, 1 at the edge\n\t\t\n\t\t// Here we code a curved offset that varies with position along the vein to avoid stoopid straight veins\n\t\tfloat\tVeinOffset = 0.05 * (ReverseSmoothstep( 0.0, 1.1, LeafRatio, 4.0 )-0.4);\n\t\tvec2\tVeinPos = VeinBase + Direction * DistanceAlongVein + VeinOffset * VeinOrtho;\n\n\t\t// Fast measure of the distance to that vein\t\t\n\t\tfloat\tDistance2Vein = abs(dot( _Pos - VeinPos, VeinOrtho ));\n\t\tif ( Distance2Vein < ClosestVein )\n\t\t{\t// That one is better!\n\t\t\tSecondClosestVein = ClosestVein;\n\t\t\tSecondClosestVeinPos = ClosestVeinPos;\n\t\t\tClosestVein = Distance2Vein;\n\t\t\tClosestDistanceAlongVein = DistanceAlongVein;\n\t\t\tClosestVeinPos = VeinPos;\n\t\t\tClosestLeafRatio = LeafRatio;\n\t\t}\n\t}\n\t\n\t// Determine its size based on distance from the center\n\tfloat\tVeinSize = SmoothSingleStep( vec2( 0.0, 0.85 ), vec2( 0.008, 0.003 ), ClosestLeafRatio );\n\t\t\tVeinSize = max( 0.0, VeinSize - step( 1.1, ClosestLeafRatio ) );\n\t\n\t// Make it round\n\tfloat\tVeinThickness = 3.0 * sqrt( 1.0 - min( 1.0, ClosestVein*ClosestVein / (VeinSize*VeinSize) ) );\n\t\n\t// What I'm doing here is computing a vein thickness with slower decay\n\t//\tso I can subtract it with actual thickness to isolate the borders\n\t// This way I can increase leaf optical thickness near the veins...\n//\tfloat\tVeinThickness2 = 2.5 * exp( -0.9*ClosestVein*ClosestVein / (VeinSize*VeinSize) );\n//\tfloat\tOpticalThickness = 2.0 * (VeinThickness2 - VeinThickness);\t// Negative inside the vein, positive outside with a burst nead the vein\n//\n//\tOpticalThickness = mix( OPTTHICK_SIDE_VEINS,// * -OpticalThickness,\n//\t\t\t\t\t\t\tmix( OPTTHICK_LEAF_MIN, OPTTHICK_LEAF_MAX, OpticalThickness ),\n//\t\t\t\t\t\t    step( 0.0, OpticalThickness ) );\t\n\t\n\t// Compute signed distance to vein\n\tfloat\tSignedDist2Vein = ClosestVein - VeinSize;\n\t\n\t// Add small veins pattern in between (a displaced grid really)\n\tvec2\tSmallVeinsInfos = SmallVeinsThickness( ClosestVeinPos, SecondClosestVeinPos, _Pos, vec3( ClosestDistanceAlongVein, ClosestVein, SecondClosestVein ) );\n\tVeinThickness = max( VeinThickness, 1.5 * SmallVeinsInfos.x );\n\n//\tSignedDist2Vein = min( SignedDist2Vein, SmallVeinsInfos.y );\n\t\n\treturn vec2( VeinThickness, SignedDist2Vein );\n}\n\nvec2\tLeafThickness( vec2 _Pos )\n{\n\t// Tweak pos so Y=0 is at the base and 1 at the tip\n\t_Pos = vec2( 0.14, 0.16 ) * (_Pos + vec2( 0, 2.5 ));\t// Actual world base is at (0,-3) and tip at (0,4)\n\t\n\tfloat\tIsLeft = step( _Pos.x, 0.0 );\n\t_Pos.x = abs( _Pos.x );\n\n\tfloat\tThickness = 0.0;\n\t\n\t// Central vein\n\tfloat\tVeinSize = 0.0004 * ReverseSmoothstep( 1.0, -0.2, _Pos.y, 10.0 );\n\t\t\tVeinSize = VeinSize * mix( 1.0, 0.1, saturate( 1.5 * _Pos.y ) );\n\t\t\tVeinSize = _Pos.y < -0.2 || _Pos.y > 0.97 ? 0.0 : VeinSize;\n\t\n\t// Make it round\n\tfloat\tCentralVein = sqrt( 1.0 - min( 1.0, _Pos.x*_Pos.x / VeinSize ) );\n\tThickness = max( Thickness, CentralVein );\n\n\t// Compute signed distance to vein\n\tfloat\tSignedDist2Vein = _Pos.x - sqrt(VeinSize);\n\t\n\t// Add side veins\n\tvec2\tDirection = normalize( vec2( 1, mix( 0.2, 0.5, _Pos.y ) ) );\n\tvec2\tCenterSource;\n\tfloat\tLeafLength = GetLeafLength( _Pos, Direction, CenterSource ); \n\t\n\tfloat\tDistance2Center = dot( _Pos - CenterSource, Direction );\n\tfloat\tSideRatio = Distance2Center / LeafLength;\n\tfloat\tLeafThickness = SmoothSingleStep( vec2( 0.98, 1.0 ), vec2( 1.0, 0.0 ), SideRatio );\t\t// Attenuate leaf with distance\n\tfloat\tSideVeinsThickness = SmoothSingleStep( vec2( 0.90, 1.0 ), vec2( 1.0, 0.0 ), SideRatio );// Attenuate side veins with distance\n\t\n\tvec2\tSideVeinsInfos = SideVeins( _Pos, Direction, IsLeft );\n\tLeafThickness = BASE_LEAF_THICKNESS * (1.5*LeafThickness + SideVeinsThickness*SideVeinsInfos.x);\n\n\tThickness = max( Thickness, LeafThickness );\n\tSignedDist2Vein = min( SignedDist2Vein, SideVeinsInfos.y );\n\n\treturn vec2( Thickness, SignedDist2Vein );\n}\n\nvec4\tComputeLighting( vec2 _Pos, vec3 _Normal, vec3 _ToLight, vec3 _View )\n{\n\t// Compute leaf thickness\n\tvec2\tLeaf = LeafThickness( _Pos );\n\n\tvec3\tLightColor = 10.0*vec3( 1.0, 0.99, 0.97 );\n\tfloat\tNdotL = saturate( -dot( _ToLight, _Normal ) );\n\tvec3\tDiffuse = LightColor * NdotL;\n\t\t\tDiffuse *= mix( 1.0, 5.0, pow( dot( _ToLight, _View ), 20.0 ) );\n\t\n\tfloat\tOpticalDepth;\n\tif ( Leaf.y >= 0.0 )\n\t{\n\t\tOpticalDepth = 1.0*mix( 20.0, 80.0, exp( -20.0*Leaf.y ) );\n\t}\n\telse\n\t{\n\t\tOpticalDepth = 1.0*mix( 20.0, 30.0, Leaf.x*saturate(-Leaf.y/0.01) );\n\t}\n\t\n\tvec3\tTransmittance = vec3( 0.3, 0.2, 0.8 ) * (OpticalDepth / PI);\n\tvec3\tExtinction = exp( -Transmittance * Leaf.x );\n\t\n\treturn vec4( Diffuse * Extinction, step( 1e-3, Leaf.x ) );\n}\n\nvec3\tComputeDOFBackground( vec3 _Pos, vec3 _View )\n{\n// Tried to adapt Kali's cosmos to make a background but don't like creases\n/*\tvec3\tp = 0.0001 * (_Pos + vec3( 17.0, 12.3123, 18.15123 ) + 20.0 * _View);\n\tfor ( int i=0; i<18; i++)\n\t\tp = abs(p) / dot(p,p) * 2.0 - 1.0;\n\n\tfloat\ts = 0.005;\n\tfloat\tv = 0.15*pow( max( 0.0, length(p) - 1.0 ), 2.0);//*(0.75-s)*0.15;\n\treturn vec3( v );*/\n\t\n\t// Let's split the view as an angular grid\n\tfloat\tPhi = 0.8 * atan( _View.x, -_View.z );\n\tfloat\tTheta = 0.8*acos( _View.y );\n\tconst float\tdAngle = 0.3;\n\tPhi /= dAngle;\n\tTheta /= dAngle;\n\tint\tiX = int(floor( Phi ));\n\tint\tiY = int(floor( Theta ));\n\tvec3\tAccum = vec3( 0.0 );\n\tfor ( int yc=-1; yc<=1; yc++ )\n\t{\n\t\tint\ty = iY + yc;\n\t\tfor ( int xc=-1; xc<=1; xc++ )\n\t\t{\n\t\t\tint\t\tx = iX + xc;\n\t\t\tfloat\tHashKey = float(-13*x+17*y);\n\t\t\tvec2\tBokehCenter = 0.25 * vec2( hash( HashKey ), hash( HashKey + 127.8641 ) );\n\t\t\tfloat\tBokehDistance = length( vec2( Phi, Theta ) - vec2( float(x)+BokehCenter.x, float(y)+BokehCenter.y ) );\n\t\t\tfloat\tBokehHue = 2.0*hash( HashKey - 17.45191 );\n\t\t\tfloat\tBokehIntensity = 100.0*pow( hash( HashKey - 231.519 ), 10.0 );\n\t\t\t\t\tBokehIntensity *= smoothstep( 0.51, 0.45, BokehDistance );\n\n\t\t\tvec3\tBokehColor = BokehIntensity * pow( vec3( mix( 1.0, 0.1, saturate( BokehHue ) ), mix( 0.1, 1.0, saturate( BokehHue ) )*mix( 1.0, 0.4, saturate( BokehHue-1.0) ), mix( 0.2, 1.0, saturate( BokehHue-1.0) ) ), vec3( 4.0 ) );\n\t\t\tAccum += BokehColor;\n\t\t}\n\t}\n\t\n\treturn 0.1*vec3( 0.05, 0.1, 0.4 ) + Accum;\n}\n\nvec3 HDR( vec3 _HDR )\n{\n\tvec3\tLDR = 1.8 * (1.0 - exp( -0.1 * _HDR ));\n\treturn pow( LDR, vec3( 1.0 / 2.2 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tuv = fragCoord.xy / iResolution.xy;\n\tvec3\tPos = vec3( 0, 0, 4 );\n\tvec3\tView = normalize( vec3( vec2( iResolution.x / iResolution.y, 1.0 ) * (2.0 * uv - 1.0), -1.0 ) );\n\n\tfloat\tMouseAngle = 0.5 * (iMouse.x / iResolution.x - 0.5) * PI;\n\tmat3\tRot = mat3( cos( MouseAngle ), 0, -sin( MouseAngle ),\n\t\t\t\t\t    0, 1, 0,\n\t\t\t\t\t    sin( MouseAngle ), 0, cos( MouseAngle ) );\n\t\n\tPos = Pos * Rot;\n\tView = View * Rot; \n\t\n\tvec3\tPlanePos = vec3( 0, 0, 0 );\n\tvec3\tPlaneNormal = vec3( 0, 0, 1 );\n\tvec3\tDelta = PlanePos - Pos;\n\tfloat\tHitDistance = dot( Delta, PlaneNormal ) / dot( View, PlaneNormal );\n\t\n\tvec3\tHit = Pos + HitDistance * View;\n\n\t// Bend a little\n\tfloat\tAngle = -0.4 * sin( 4.0*iTime );\n\tvec3\tPivot = vec3( 6.0*sign(Angle), 0, 0 );\n\t\t\tAngle = Angle * sin( 0.2*Hit.y );\n\tvec3\tD = Hit - Pivot;\n\tmat3\tRot2 = mat3( cos( Angle ), sin( Angle ), 0,\n\t\t\t\t\t\t -sin( Angle ), cos( Angle ), 0,\n\t\t\t\t\t\t 0, 0, 1 );\n\tHit = Pivot + D * Rot2;\n\t\n\t\n\tvec3\tToLight = normalize( vec3( 0.5*MouseAngle, 0, -1 ) ) * Rot;\t// From behind\n\tvec4\tLeaf = ComputeLighting( Hit.xy, PlaneNormal, ToLight, View );\n\tvec3\tBackground = vec3( mix( 5.0, 40.0, abs(MouseAngle) ) * pow( dot( ToLight, View ), 10.0 ) );\n\t\t\tBackground += ComputeDOFBackground( Pos, View );\t// Add funky background\n\tvec3\tFinalColor = mix( Background, Leaf.xyz, Leaf.w );\n\t\n\tfragColor = vec4( HDR( FinalColor ), 1.0 );\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lssGDH","date":"1369519100","viewed":1123,"name":"Leaf","username":"Patapom","description":"Dancing \"translucent\" leaf... (don't ask)","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["leaf","translucency","choubidou","funkybokeh"],"hasliked":0,"parentid":"","parentname":""}}