{"ver":"0.1","info":{"id":"M323Rh","date":"1708208969","viewed":94,"name":"volumetric cloud testing","username":"int_45h","description":"trying to do volumetric cloud rendering","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["e"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 80\n#define FOV 60.\n#define MIN_DIST .001\n#define MAX_DIST 100.\n#define ABSORPTION 2.\n\nvec2 sd_sphere(vec3 p, float r, float id){ return vec2(length(p)-r,id); }\nvec2 sd_box(vec3 p, vec3 b, float id)\n{\n    vec3 q = abs(p)-b;\n    float d = length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n    return vec2(d,id);\n}\n\nvec2 get_dist(vec3 p)\n{\n    vec3 b = vec3(1.5,1.5,1.5);\n    vec3 o = vec3(0.,-1.,7.);\n    \n    //return sd_sphere(p-vec3(0.,0.,5.),1.,1.5);\n    return sd_box(p-o,b,1.5) ;\n}\n\nvec3 get_normals(vec3 p)\n{\n    float e = .001;\n    vec2 k = vec2(1,-1);\n    \n    return normalize(\n        k.xyy*get_dist(p+k.xyy*e).x+\n        k.yyx*get_dist(p+k.yyx*e).x+\n        k.yxy*get_dist(p+k.yxy*e).x+\n        k.xxx*get_dist(p+k.xxx*e).x\n    );\n}\n/*\nvec3 get_normals(vec3 p)\n{\n    float e = .001;\n    vec2 k = vec2(e,0);\n    \n    return normalize(vec3(\n        get_dist(p+k.xyy).x-get_dist(p-k.xyy).x,\n        get_dist(p+k.yxy).x-get_dist(p-k.yxy).x,\n        get_dist(p+k.yyx).x-get_dist(p-k.yyx).x\n    ));\n}\n*/\n\nvec4 raymarch(vec2 uv)\n{\n    float ar = iResolution.y/iResolution.x;\n    vec2 uv_p = uv*2.-1.;\n    uv_p *= vec2(1.,ar)*tan((FOV*PI/180.)*.5);\n    \n    vec3 o = vec3(0.,1.,0.);\n    vec3 d = normalize(vec3(uv_p, 1.));\n    d = lookAt(vec3(0.,-.2,1.))*d;\n    \n    float t = 0.;\n    \n    vec4 col = mix(\n        vec4(.1,.1,.2,1.),\n        vec4(.0,.0,.1,1.),\n        d.y\n    );\n    \n    for (int i=0; i<STEPS; i++)\n    {\n        vec3 p = o+d*t;\n        vec2 res = get_dist(p);\n        t += res.x;\n        \n        if (t >= MAX_DIST)\n            break;\n            \n        if (res.x <= MIN_DIST)\n        {\n            if (res.y < 1.) // Regular shading, unused\n            {\n                vec3 n = get_normals(p);\n                vec3 l = vec3(0.,5.,5.)-p;\n                float a = length(l);\n                a = 10./(a*a);\n                \n                l = normalize(l);\n                \n                vec3 k_d = vec3(.5,.7,.7)*max(dot(n,l),0.);\n                vec3 k_a = vec3(.2,.4,.4);\n                col = vec4(k_d+k_a,1.);\n                break;\n            }\n            else if (res.y < 2.) // Volumetric cloud rendering\n            {\n                float dist = 0.;\n                float seg = 0.;\n                \n                float d_threshold = .04;\n                \n                for (int j=0; j<STEPS; j++)\n                {\n                    seg += max(.02*seg, .05);\n                    t += seg;\n                    \n                    vec2 s = get_dist(o+d*t)*vec2(-1., 1.);\n                    if (s.x < 0.)\n                        break;\n                        \n                    float de = fbm3D(p + iTime * .2, 4)*min(s.x,1.);\n                    dist += de*seg;\n                }\n                \n                float beer = 1.-clamp(exp(-dist * ABSORPTION),0.,1.);\n                col += vec4(beer);\n                col = clamp(col, 0., 1.);\n                break;\n            }\n            else break;\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    //vec4 color = vec4(fbm3D(vec3(uv*vec2(8.,6.), iTime), 4));\n    //vec4 color = vec4(value3D(vec3(uv*vec2(8.,6.), iTime)));\n    \n    vec4 color = raymarch(uv);\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p)\n{\n\tp  = fract(p * .1031);\n    p += dot(p, p.zyx + 31.32);\n    return fract((p.x + p.y) * p.z);\n}\n\nfloat value3D(vec3 p)\n{\n    vec3 p_grid = floor(p);\n    vec3 p_cell = fract(p);\n    \n    // Pick 8 points\n    float p0 = hash13(p_grid + vec3(0,0,0));\n    float p1 = hash13(p_grid + vec3(1,0,0));\n    float p2 = hash13(p_grid + vec3(0,1,0));\n    float p3 = hash13(p_grid + vec3(1,1,0));\n    float p4 = hash13(p_grid + vec3(0,0,1));\n    float p5 = hash13(p_grid + vec3(1,0,1));\n    float p6 = hash13(p_grid + vec3(0,1,1));\n    float p7 = hash13(p_grid + vec3(1,1,1));\n    \n    // Blend\n    //vec3 s = p_cell*p_cell*(3.-2.*p_cell);\n    vec3 s = smoothstep(0.,1.,p_cell);\n    \n    // Interpolate\n    float i0 = mix(\n        mix(p0, p1, s.x),\n        mix(p2, p3, s.x),\n        s.y\n    );\n    float i1 = mix(\n        mix(p4, p5, s.x),\n        mix(p6, p7, s.x),\n        s.y\n    );\n    return mix(i0, i1, s.z);\n}\n\nfloat fbm3D(vec3 p, int oct)\n{\n    float a = .5;\n    float s = 1.;\n    float n = 0.;\n    \n    for (int i = 0; i < oct; i++)\n    {\n        n += value3D(p*s)*a;\n        a *= .5;\n        s *= 2.;\n    }\n    \n    return n;\n}\n\n// Camera functions\n// SUPER INEFFICIENT\nvec3 rotate_vec(vec3 p, vec3 ypr)\n{\n    mat3 rot_matrix = mat3(\n        1.,0.,0.,\n        0.,cos(ypr.x),-sin(ypr.x),\n        0.,sin(ypr.x), cos(ypr.x)\n    ) * mat3(\n        cos(ypr.y),0.,-sin(ypr.y),\n        0.,0.,0.,\n        sin(ypr.y),0., cos(ypr.y)\n    ) * mat3(\n        cos(ypr.z),-sin(ypr.z),0.,\n        sin(ypr.z), cos(ypr.z),0.,\n        0.,0.,0.\n    );\n    return normalize(rot_matrix*p);\n}\n\nmat3 lookAt(vec3 dir)\n{\n    vec3 front = normalize(dir);\n    vec3 right = cross(front, vec3(0.,1.,0.));\n    vec3 up = cross(right, front);\n    \n    return mat3(right, up, front);\n}\n","name":"Common","description":"","type":"common"}]}