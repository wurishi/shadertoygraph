{"ver":"0.1","info":{"id":"XflSzj","date":"1705453171","viewed":108,"name":"Confusing Circle","username":"spalmer","description":"I found this by accident while doing something else.\nDrag with mouse!","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["mouse","math","circle","distance","dot","golf","bounding","boundsphere","innerproduct"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Click with mouse, and drag!\n/**/\nvoid mainImage(out vec4 o, vec2 f)\n{\n    o = iMouse; o = vec4(dot(f - o.xy, f - abs(o.zw)));\n}\n\n// I was doing something else and stumbled upon this circle.\n// then I antialiased it.  Fun!\n\n// perhaps one of you can find a use for this!\n\n// \"standard\" sdf gradient debugging    \n/** /\nvec3 DebugSDF(float d)\n{\n    vec3 col = vec3(1) - sign(d)*vec3(.1,.5,.9);\n\tcol *= 1. - exp(-2.*abs(d));\n\tcol *= .8 + .2*cos(120.*d);\n    return mix(col, vec3(1), 1. - smoothstep(.0,.02,abs(d))); // white at zero\n}\n/** /\nvoid mainImage(out vec4 o, vec2 f)\n{\n    o = iMouse;\n    vec2 r = iResolution.xy,\n        a = abs(o.xy), b = abs(o.zw);\n    float orgshift = 0.; //.03;\n    a -= orgshift*r; b -= orgshift*r; f -= orgshift*r; // testing shifted origin - really helps if done *after* abs of iMouse DOH\n    vec2 h = (a + b) / 2.;\n    // what does this measure?!!\n    float d = dot(a - f, b - f); //dot(f - a, f - b); //\n    float x2 = .25 * dot(a - b, a - b), x = sqrt(x2); //.5 * distance(a, b);\n    //float x3 = dot(a, b);\n    //if (abs(x2 - abs(x3)) < 1e-1) { o = vec4(0,1,0,1); return; }\n    float e = sqrt(d + x2) - x;\n    float g = e;\n    o = vec4(clamp(g, 0., 1.));\n    //o = vec4(DebugSDF(e * .003), 1); // * 2e-5\n    if (any(lessThan(f, vec2(0.*r)))) o *= .8;\n}\n/**/\n    //d = dot(h - f, h - f) - .25*dot(a - b, a - b); // AHA! I found it!\n    //o = sin(e/5. + vec4(0,1,2,3.)/3. * radians(360.));\n//d -= sqrt(dot(h, h));\n\n// does the 'infinite line between a and b' thing:\n//  o = vec4(cross(vec3(f - o.xy, 0), vec3(f - abs(o.zw), 0)).z);\n// more fun with vectors!\n\n/*\nfinally got Maxima to tackle this and agree:\n(%i1)\ta:[a_x,a_y];\n(a)\t[a_x,a_y]\n(%i2)\tb:[b_x,b_y];\n(b)\t[b_x,b_y]\n(%i3)\tp:[p_x,p_y];\n(p)\t[p_x,p_y]\n(%i4)\tc:(a+b)/2;\n(c)\t[(b_x+a_x)/2,(b_y+a_y)/2]\n(%i5)\trr:(a-c).(a-c);\n(rr)\t(a_y-(b_y+a_y)/2)^2+(a_x-(b_x+a_x)/2)^2\n(%i6)\tratsimp((p-a).(p-b) + rr - (p-c).(p-c));\n(%o6)\t0\n*/\n\n// big thank you to @mla for helping me reach enlightenment\n\n// now if I can just extract this r^2 quantity in a useful way...\n// or find some other use for this fact.\n\n// I have a funny feeling it relates to area of parallelogram somehow;\n// if area of circle is also related to radius by A = pi*r^2,\n// isn't this a simple way to compute the squared radius of a circle\n// that fits between two points?  just a dot product?\n// no, because still must subtract out the squared length to the center\n// from the query/origin; computing that takes more work.\n// And if you subtract that c vector out first,\n// you're left with simple length squared calculation.  Saved nothing.\n// Getting the actual distance back is too complicated because\n// must compute the center of the circle and the squared radius\n// just to correct for the offset so can utilize sqrt!\n// fine, can obtain  r*r  via  (a-b) . (a-b) / 4 \n// instead of  (a-c) . (a-c)  or  (sqrt((a-b) . (a-b)) / 2)^2\n// It does implement a really fast inside/outside test\n// for the circle included between any two points;\n// idk how often that'd turn up in practice.\n/*\n// let's compare two ways to obtain d^2 from midpoint\n\nfloat midpointquadranceA(vec2 q, vec2 a, vec2 b)\n{\n    return dot(q - a, q - b)       // D*3-1 adds, D muls\n        - .25 *                    // 1 add, 1 mul\n        dot(a - b, a - b);         // D*2-1 adds, D muls\n}   // total D*5-1 adds, D*2+1 muls\nfloat midpointquadranceB(vec2 q, vec2 a, vec2 b)\n{\n    vec2 c = .5 * (a + b);         // D adds, D muls\n    return dot(q - c, q - c);      // D*2-1 adds, D muls\n}   // total D*3-1 adds, D*2 muls\n\n// obviously the 'naive' way of finding the midpoint first\n// is cheaper and scales way better to higher dimensions.\n*/\n// but it still might be a useful property of the dot product a.b\n// that isn't widely known, that not only does it give the |a|*|b|*cos(a,b)\n// but that apparently is just another way to write |c|+r^2\n// so this may have some useful properties somehow,\n// I just can't see any obvious applications rn.\n// someone should make an addendum on Wikipedia!  ;)\n\n// apparently @mla's k*p.p - p.n = 0 at http://shadertoy.com/view/ssl3zH\n// is yet another useful way to construct offset circles, in plane normal n,radius k form\n\n// All this is simply consequences of the laws of addition and multiplication.\n// Well that was a fun rabbit hole to fall down!  Now, get me out of here!","name":"Image","description":"","type":"image"}]}