{"ver":"0.1","info":{"id":"fssfzj","date":"1645110210","viewed":83,"name":"IntroShader, R&D","username":"LouiG","description":"Initiation à Shadertoy","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["basics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Projet #2 : les fragments\n// Production R&D\n// Romain Lopez-Rostain\n\n\n// ======= Méthodes usuelles =======\n// vec3.x / vec3.xz / vec3.zxy (on peu prendre le nombre d'attribut qu'on veut et dans l'ordre qu'on veut)\n// 5. <- un flottant\n// length(vec_) \n// dot(vec_)\n// normalize(vec_)\n// pow(n, exp)\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n// Dans un shader standard, on définit les paramètres en entrée (in) \n// et ceux en sortie pour les fonctions GL seulement (out).\nbool inside_circle(in vec2 frag, in vec2 center, in float radius)\n{\n    return length(frag - center) < radius;\n}\n\n// Boite noire\n// On peut utiliser cette fonction de bruit continu pour l'effet de secousse\nfloat noise2D(in float val, in float amplitude, in int granularite)\n{\n    float res = 0.;\n    for (int i = 0; i < granularite; i++)\n    {\n        res += sin(val * 158. + 79.) * amplitude;\n        amplitude = amplitude / 2.;\n    }\n    \n    return res;\n}\n\n\n\nvec4 DrawTriangle(in vec2 pos1, in vec2 pos2, in vec2 pos3, in vec2 fragCoord, in vec4 fragColor, in vec4 TriangleColor)\n{\n    vec4 col = fragColor;\n    if(fragCoord.y > pos1.y && fragCoord.y < pos2.y)\n        if(fragCoord.x < pos2.x && cross(vec3(pos2 - pos1, 0), vec3(fragCoord - pos2, 0)).z < 1.0)\n            col = TriangleColor;\n        else if(fragCoord.x > pos2.x && cross(vec3(pos3 - pos2, 0), vec3(fragCoord - pos2, 0)).z < 1.0)\n            col = TriangleColor;\n        \n    return col;\n        \n}\n\n\n// La fonction principale\n// fragColor : la couleur (vec4) que doit prendre le fragment\n// fragCoord : les coordonnées (xy) du fragment dont on doit déterminer la couleur\nfloat topy = 0.0;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Position normalisée du pixel [0, 1]\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Fond noir\n    vec4 col = vec4(1, 0, 0, 1); \n    \n    if(fragCoord.x / fragCoord.y < iResolution.x / iResolution.y)\n        col = vec4(0, sin(iTime * 6.), 1.0 * cos(iTime * 5. + 0.5), 1);\n    else\n        col = vec4(1.0 * cos(iTime * 5.), sin(iTime * 6.), 0, 1);\n    \n    \n    \n    float interpolation = (iTime -  float(int(iTime)));\n    \n    \n    float updatedValue = (sin(noise2D(iTime * 0.05 + 5., -5., 5)) * 2.0);\n    \n    /*if(iMouse.w > 0.0)\n        topy = iMouse.w;*/\n    \n    vec2 p1 = vec2(iResolution.x / 2.0 + updatedValue, iResolution.y / 4.0 * 3.0/*topy*/ + updatedValue);\n    vec2 p2 = vec2(iResolution.x / 3.0 + updatedValue, iResolution.y / 2.0 + updatedValue);\n    vec2 p3 = vec2(iResolution.x / 3.0 * 2.0 + updatedValue, p2.y);\n    vec2 p4 = vec2(iResolution.x / 6.0 + updatedValue, iResolution.y / 4.0 + updatedValue);\n    vec2 p5 = vec2(p1.x, p4.y);\n    vec2 p6 = vec2(iResolution.x / 6.0 * 5.0 + updatedValue, p4.y);\n    \n    \n    //if(iMouse.w > 0.0)\n        col = DrawTriangle(p2, p1, p3, fragCoord, col, vec4(1,1,1,1)); // TOP\n    col = DrawTriangle(p4, p2, p5, fragCoord, col, vec4(0,1,1,1)); // Left\n    col = DrawTriangle(p5, p3, p6, fragCoord, col, vec4(1,1,0,1)); // Right\n    \n    col = DrawTriangle(iMouse.xy - vec2(30,0) + updatedValue, iMouse.xy + vec2(0,30) + updatedValue, iMouse.xy + vec2(30,0) + updatedValue, fragCoord, col, vec4(1,1,1,1)); // Mouse\n    \n    // La couleur du pixel dépend du temps et de sa position\n    // 1s loop \n    // Le temps est passé dans un sinus pour donner l'impression de respiration\n    // La secousse est crée en modifiant aléatoirement la position du cercle\n    //bool main_disc = inside_circle(\n    //    fragCoord, \n    //    iResolution.xy / 2. + vec2(\n    //        noise2D(iTime * 0.05 + 5., 2., 5), \n    //        noise2D(iTime * 0.05 + 81., 2., 5)), \n    //    (sin(iTime * 5.) * iResolution.y / 40.) + iResolution.y / 4.);\n    // On passe l'interpolation à la racine dans le calcul pour aller vite, puis lentement !\n    //bool small_disc = inside_circle(fragCoord, iResolution.xy / 2., sqrt(interpolation) * iResolution.y * 1.);\n    //bool big_disc = inside_circle(fragCoord, iResolution.xy / 2., sqrt(interpolation) * iResolution.y * 1.05);\n    \n\n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}