{"ver":"0.1","info":{"id":"X3GXWy","date":"1730652611","viewed":144,"name":"Audio scope - FM Synth","username":"dray","description":"Play with the numbers and code in Common.\nUse the restart button to resync.\nRecompile changes.\nRestart after 180 seconds of computed sound.\n","likes":10,"published":1,"flags":8,"usePreview":0,"tags":["sound","fm","scope","synthfest"],"hasliked":0,"parentid":"4fVXz1","parentname":"Fork Fork 2023- swarthy 642"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fun stuff is in Common, not here, unless looking at how the oscilliscope works\n// Originally https://www.shadertoy.com/view/4fVXz1 swarthy; There are others\n\nfloat tAtX(float x) {\n    float scale = 4./FREQ; // show 4 cycles of this frequency\n    return x/iResolution.x*scale + floor(iTime/scale)*scale;\n}\n\nfloat yAt(float x) {\n    float t = tAtX(x);\n    float s = t >= 0. ? sound(t) : 0.;\n    return s * iResolution.y / 2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragCoord.y -= iResolution.y / 2.;\n    \n    float tx = fragCoord.x;\n    float y0 = yAt(tx-1.),\n          y1 = yAt(tx),\n          y2=yAt(tx+1.), y=fragCoord.y;\n    float y01 = (y0+y1)*.5,\n          dy01 = abs(y0-y1)*.5;\n    float y12 = (y1+y2)*.5,\n          dy12 = abs(y1-y2)*.5;\n    float dy = max(0., max(y01-y, y-y01)-dy01);\n    dy = min(dy, max(0., max(y12-y, y-y12)-dy12));\n    float dist = sqrt(dy*dy + 1.);\n    float col = smoothstep(2., 1., dist);\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592653589793\n#define TAU (2.*PI)\n\n// These tend to preserve quality after many seconds:\n#define SIN(X) sin(mod(X,TAU))\n#define COS(X) cos(mod(X,TAU))\n\n// Used to stabilize the 'scope display to the frequency\n#define FREQ  220.\n\n// Sandbox here ...\n\n#define DECAY(t) exp( - fract(t*  .5 ) *  6.  )\n\nfloat sound(float t) {\n    float s = 0.;\n    \n    s += SIN( TAU*t*FREQ*   1.\n        +    4.   * DECAY(t) * SIN( TAU*t*FREQ*     1.01\n            +    7.   * COS(t) * SIN(TAU*t*FREQ)\n        )\n    );\n    \n    return s * 0.25;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* \nfloat phase_freq(float f, float t) { return fract(f * t); }\n\nfloat osc_saw(float p) { return p*2.-1.; }\nfloat osc_tri(float p) { return min(p*4.-1., 3.-4.*p); }\nfloat osc_sin(float p) { return sin(p * 6.2831); }\nfloat osc_squ(float p) { return step(p,.5)*2.-1.; }\n\nfloat mtof(float m) { return 22. * pow(2., m / 12.); }\n\nfloat inst1(float t) {\n    t = mod(t, 2.);\n    float n = floor(t/.5);\n    t = mod(t, .5);\n    \n    float freq = mtof(54.);\n    if (n==1.) freq = mtof(56.);\n    if (n==2.) freq = mtof(61.);\n    if (n==3.) freq = mtof(59.);\n\n    float p = phase_freq(freq, t);\n    \n    float env = exp(-3.0*t);\n    float s = 0.;\n    s = osc_tri(p);\n    //s = osc_sin(p);\n    //s = osc_saw(p);\n    //s = osc_squ(p);\n    \n    s *= env;\n    return s;\n}\n\nvec2 sound(float t) {\n    float s = 0.;\n    //s = inst1(t) + .5*inst1(t-.33) + .25*inst1(t-.66) + .125*inst1(t-.99);\n    return vec2(s);\n}\n*/","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"\n// Fun stuff is in Common, not here\n\nvec2 mainSound( int samp, float time ) {\n    return vec2(sound(time));\n}\n","name":"Sound","description":"","type":"sound"}]}