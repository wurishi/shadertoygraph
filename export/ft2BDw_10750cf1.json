{"ver":"0.1","info":{"id":"ft2BDw","date":"1652296132","viewed":148,"name":"Nebula Crystal","username":"Hyeve","description":"...yeah this is quite pretty.  I added a fps limiter for performance, by default it runs at 30fps (if your monitor is 60hz, at least), but you can change it in the Common tab.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","transparency","glass","reflections","crystal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define DTR 0.01745329\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n\nvec2 uv;\nvec3 cp,cn,cr,ss,oc,gl,vb;\nvec4 fc,cc;\nfloat tt,cd,sd,md,io,oa,td,tc;\nint es=0,ec;\n\n\nfloat tor(vec3 p,vec2 t){return length(vec2(length(p.xz)-t.x,p.y))-t.y;}\nfloat smin(float a, float b, float k){float h=clamp(0.5+0.5*(b-a)/k,0.,1.);return mix(b,a,h)-k*h*(1.-h);}\n\n\nfloat shatter(vec3 p, float d, float n, float a, float s)\n{\n\tfor(float i=0.;i<n;i++)\n\t{\n\t\tp.xy*=rot(a);p.xz*=rot(a*0.5);p.yz*=rot(a+a);\n\t\tfloat c=mod(i,3.)==0.?p.x:mod(i,3.)==1.?p.y:p.z;\n\t\tc=abs(c)-s;d=max(d,-c);\n\t}\n\treturn d; \n}\n\nfloat mp(vec3 p)\n{\n\t\tp.z -= tt;\n\t\tvec3 pp=p;\n\n\t\tfloat inr = length(p);\n    \n\t\tfor(float i = 0.; i < 8.; i++)\n\t\t{\n\t\t\tp.xy *= rot(i+tt*0.1);\n\t\t\tp.xz *= rot(i+tt*0.2);\n\t\t\tinr = smin(inr,tor(p,vec2(i,0.5+i*0.1)),1.);\n\t\t}\n\t\n\t\tfloat sph = abs(length(pp)-7.)-0.001;\n\n\t\tsph = shatter(pp, sph, 3., sin(tt)*0.1+tt*0.1, 1.5);\n\t\t\n\n\t\t\n\t\tsd=min(sph,inr);\n\t\t\n\t\tvec3 gc = normalize(p*p);\n\t\tgc.xz += gc.y;\n\t\tgc.y *= 0.5;\n        gc.z += 0.3;\n\t\tgc = mix(gc, vec3(length(gc)/3.),0.2);\n\t\t\n\t\tgl += exp(-inr*0.01) * gc * 0.1;\n\t\t\t\n\t\tp=pp;\n\t\tp.z+=tt;\n\t\tp.z = mod(p.z,20.)-10.;\n\t\t \n        for(float i = 0.; i < 5.; i++)\n\t\t{\n\t\t\tp.x = abs(p.x) - 1.;\n\t\t\tp.xy *= rot(i*3.+tt*0.05+uv.y*0.1);\n\t\t\tp.yz = abs(p.yz) - 1.;\n\t\t\tp.xz *= rot(i+tt*0.05+uv.x*0.1);\n\t\t}\n\t\t\n\t\tfloat stars = length(p);\n\t\t\n\t\t\n\t\tif(length(pp) > 10.) gl += exp(-stars*4.)*mix(vec3(0.7,0.4,0.5),vec3(0.2,0.5,0.7),sin(pp.x+pp.z)*0.5+0.5)*2.;\n\t\t\n\t\tsd = min(sd,stars);\n\t\t\n\t\tsd=abs(sd)-0.001;\n\t\n\t\n\t\tif(sd<0.01)\n\t\t{\t\n\t\t\tio=sph<inr?1.8:-1.;\n\t\t\toc=vec3(0.05,0.1,0.2);\n\t\t\toa=stars<sd+0.01?1.:(io<0.?0.5:0.1);\n\t\t\tss=vec3(0);\n\t\t\tec=2;\t\n\n\t\t}\n\t\treturn sd;\n}\n\nvoid nm(){mat3 k=mat3(cp,cp,cp)-mat3(.001);cn=normalize(mp(cp)-vec3(mp(k[0]),mp(k[1]),mp(k[2])));cn=normalize(cn);}\n\nfloat tr(vec3 ro, vec3 rd)\n{cd=0.;md=64.;for(tc=1.;tc<256.;tc++){mp(cp=ro+rd*cd);cd+=sd;td+=sd;\nif(sd<md&&sd<cd-0.1)md=sd;if(sd<0.0001||cd>64.)break;}nm();return cd;}\n\n\nvoid px(vec3 rd)\n{\n  cc.rgb=vec3(0,0,0.1)+length(pow(abs(rd+vec3(0,0,0)),vec3(10)))*vec3(0.)+gl/tc;\n  if(cd>64.){cc.a=1.;return;}cc.a=oa;\n\tvec3 ld = -normalize(cp+cn-vec3(0.,10,-30));\n  float df=clamp(length(cn*ld),0.,1.),\n\tsp=(1.-length(cross(rd,cn*ld)))*0.5,\n\tao=min(mp(cp+cn*0.3)-0.3,0.3)*0.;\n  vec3 fr=pow(1.-abs(dot(rd,-cn)),3.)*mix(cc.rgb,vec3(0.5),0.9)*0.;\n  cc.rgb=(oc*(df+fr+ss)+fr+sp+ao+gl/tc);tr(cp+cn*0.1,ld);\n\tfloat sh=1.-mix(1.-clamp(md/0.1,0.,1.),clamp(dot(cn,-ld),0.,1.),0.1)*(io>0.?oa:1.)*0.2;\n\tcc.rgb=mix(mix(vec3(sh),oc,0.5),cc.rgb,sh)*sh;\n}\n\n\nvoid render(vec2 frag, vec2 res, float time, out vec4 col)\n{\n  uv=vec2(frag.x/res.x,frag.y/res.y);\n  uv-=0.5;uv/=vec2(res.y/res.x,1);\n  tt=mod(time,256.)+40.;\n\t\n  vec3 ro=vec3(0.,0,-22.+sin(tt*0.3)*3.+tt),rd=normalize(vec3(uv,1.));\n\t\n\t\n\tfor(int i=0;i<8;i++)\n  {\n\t\tfloat d=tr(ro,rd);\n\t\tro=cp-cn*(io<0.?-0.01:0.01);\n\t\tcr=refract(rd,cn,i%2==0?1./io:io);\n\t\ti=io<0.?i+1:i;\n    if((length(cr)==0.&&es<=0)||io<0.)\n\t\t{cr=reflect(rd,cn);es=(io<0.?es:ec);}\n\t\tpx(rd); if(max(es,0)%3==0&&d<64.)rd=cr;es--;\n\t\tfc=fc+vec4(cc.rgb*cc.a,cc.a)*(1.-fc.a);\n\t\tif(fc.a>=1.)break;\n  }\n  col = fc/fc.a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(mod(float(iFrame), 60./FPS) == 1.) render(fragCoord.xy,iResolution.xy,iTime,fragColor);\n    else fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define FPS 30.","name":"Common","description":"","type":"common"}]}