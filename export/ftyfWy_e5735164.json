{"ver":"0.1","info":{"id":"ftyfWy","date":"1665129866","viewed":100,"name":"Sphere orbiting","username":"invivel","description":"Â ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","color"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n#define MAX_MARCHING_STEPS 255\n#define DISTANCE 25.0\n#define EPSILON 0.0001\n\nvec3 hue(float t) {\n    return clamp(vec3(-1.0 + 3.0 * abs(mod(t*2.0+vec3(0, 4.0 / 3.0, 2.0 / 3.0), 2.0) -1.0)), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 m = (iMouse.xy / iResolution.xy);\n\n    float aspect_ratio = iResolution.x / iResolution.y;\n    vec3 uv = vec3((gl_FragCoord.xy / iResolution.xy - 0.5) * vec2(aspect_ratio, 1), 1.0);\n    \n    vec2 camera_lock_at = vec2(-0.33, 0.005);\n    vec3 camera_position = vec3(1.0, 0.1, -3.0);\n\n    vec2 cam_sin = sin(camera_lock_at);\n    vec2 cam_cos = cos(camera_lock_at);\n\n    float dp_w = uv.z * cam_cos.y + uv.y * cam_sin.y;\n\n    vec3 ray_dir = normalize(\n      vec3(\n        uv.x * cam_cos.x + dp_w * cam_sin.x,\n        uv.y * cam_cos.y - uv.z * cam_sin.y,\n        dp_w * cam_cos.x - uv.x * cam_sin.x\n      )\n    );\n\n    vec3 ray = vec3(camera_position);\n\n    float sphere_rotation = iTime * (m.x * 8.0 + PI * 2.0) / 60.0;\n    float sphere_rot_x = sin(sphere_rotation);\n    float sphere_rot_z = cos(sphere_rotation);\n\n    for(int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float square    = max(abs(ray.x), abs(ray.z));\n        float box       = max(abs(ray.y), square) - 0.5;\n        float solid_box = sign(-box + EPSILON);\n        vec3  box_color = vec3(1.0, 0.5, 0.25);\n\n        float sphere       = length(ray - vec3( 1.0 * sphere_rot_x * 2.5, 0.0, 1.0 * sphere_rot_z * 2.5)) - 0.5;\n        float solid_sphere = sign(-sphere + EPSILON);\n        vec3  sphere_color = vec3(hue(iTime / 4.0));\n\n        float surface       = abs(ray.y + 0.5);\n        float solid_surface = sign(-surface+ EPSILON);\n        float square_wave_z = floor(mod(ray.z, 2.0));\n        float chess_pattern = floor(mod(ray.x - square_wave_z, 2.0));\n        vec3  surface_color = vec3(chess_pattern);\n\n        float scene = min(min(surface, box), sphere);\n\n        if(scene < EPSILON) {\n            vec3 color = vec3(\n                max(solid_sphere * sphere_color,\n                max(solid_box * box_color,solid_surface * surface_color)\n            ));\n            fragColor = vec4(color, 1.0);\n            break;\n        } else {\n            float depth = length(vec3(ray) - vec3(camera_position));\n            if(depth > DISTANCE) {\n                fragColor = vec4(0.0, 0.9, 1.0, 1.0);\n                break;\n            }\n        };\n\n        ray += ray_dir * scene;\n\n        fragColor = vec4(0.0, 0.9, 1.0, 1.0);\n    };\n}","name":"Image","description":"","type":"image"}]}