{"ver":"0.1","info":{"id":"slyBDG","date":"1667655722","viewed":676,"name":"Physically Based Sky/Atmosphere","username":"TheTurk","description":"Physically based Sky/Atmosphere with precomputed transmittance and multiple scattering contribution as described in \"Production Ready Atmosphere Rendering\" by SÃ©bastien Hillaire.\n\nPress \"C\" to switch between cameras.","likes":35,"published":1,"flags":48,"usePreview":0,"tags":["sun","light","earth","sky","planet","sunlight","scattering","transmittance","atmosphere","rayleigh","mie","atmospheric","ozone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool keyIsToggled(int key) {\n\treturn texelFetch(iChannel3, ivec2(key, 2), 0).x > 0.0;\n}\n\nvec3 transmittanceFromTexture(float height, float angle) {\n    float u = (angle + 1.0) * 0.5;\n    float v = height / (topRadius - bottomRadius);\n    return texture(iChannel0, vec2(u, v)).xyz;\n}\n\nvec3 multipleScatteringContributionFromTexture(float height, float angle) {\n    float u = (angle + 1.0) * 0.5;\n    float v = height / (topRadius - bottomRadius);\n    return texture(iChannel1, vec2(u, v)).xyz; \n}\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 aces(vec3 color) {\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((color * (a * color + b)) / (color * (c * color + d ) + e), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float cameraCount = 3.0;\n    float cameraIndex = round(texelFetch(iChannel2, ivec2(0, 0), 0).x * (cameraCount - 1.0));\n    mat3 cameraOrientation = mat3(1.0);\n\tvec3 cameraPosition; \n    if (cameraIndex == 2.0) { // from space\n        float yaw = 0.0;\n        if (iMouse.z > 0.0) {\n            vec2 delta = iMouse.xy - abs(iMouse.zw);\n            float mouseSensitivity = 0.5;\n            yaw = -delta.x * 1.0 / 60.0 * mouseSensitivity;\n        }\n        cameraOrientation = rotationMatrixAxisAngle(vec3(0.0, 1.0, 0.0), yaw + 1.5);\n        cameraPosition = cameraOrientation * vec3(0.0, 0.0, bottomRadius * 3.0);\n    } else if (cameraIndex == 1.0) { // from atmosphere\n        cameraOrientation = rotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), 0.08);\n        cameraPosition = vec3(0.0, bottomRadius + 50e3, 0.0);\n    } else { // from ground\n        cameraOrientation = rotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), 0.08);\n        cameraPosition = vec3(0.0, bottomRadius + 0.2e3, 0.0);\n    }\n\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    float fieldOfView = 50.0;\n    float z = 1.0 / tan(fieldOfView * 0.5 * pi / 180.0);\n    vec3 rayDirection = normalize(vec3(uv, -z));\n    rayDirection = cameraOrientation * rayDirection;\n  \n    vec3 lightDirection;;\n    if (cameraIndex == 2.0) {\n        lightDirection = normalize(vec3(1.0, 1.0, -1.0));\n    } else {\n       float pitch = 0.0;\n       if (iMouse.z > 0.0) {\n           vec2 delta = iMouse.xy - abs(iMouse.zw);\n           float mouseSensitivity = 0.25;\n           pitch = clamp(delta.y * 1.0 / 60.0 * mouseSensitivity, -pi * 0.5, pi * 0.5);\n       }\n       mat3 orientation = rotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), pitch + 0.08);\n       lightDirection = orientation * vec3(0.0, 0.0, -1.0);\n    }\n\n    int sampleCount = 32;\n    vec3 light = vec3(0.0);\n    vec3 transmittanceFromCameraToSpace = vec3(1.0);\n    float offset = 0.0;\n    float distanceToSpace = 0.0;\n    if (intersectSphere(cameraPosition, rayDirection, topRadius, offset, distanceToSpace)) {\n        vec3 rayOrigin = cameraPosition;\n        if (offset > 0.0) { // above atmosphere\n            rayOrigin += rayDirection * offset; // intersection of camera ray with atmosphere\n        }\n        float height = length(rayOrigin) - bottomRadius;\n        float rayAngle = dot(rayOrigin, rayDirection) / length(rayOrigin);\n        bool cameraBelow = rayAngle < 0.0;\n        transmittanceFromCameraToSpace = transmittanceFromTexture(height, cameraBelow ? -rayAngle : rayAngle);\n        float phaseAngle = dot(lightDirection, rayDirection);\n        float rayleighPhase = rayleighPhase(phaseAngle);\n        float miePhase = miePhase(phaseAngle);\n        float distanceToGround = 0.0;\n        bool hitGround = intersectSphere(cameraPosition, rayDirection, bottomRadius, distanceToGround) && distanceToGround > 0.0;\n        float segmentLength = ((hitGround ? distanceToGround : distanceToSpace) - max(offset, 0.0)) / float(sampleCount);\n        float t = segmentLength * 0.5;\n        vec3 transmittanceCamera; \n        vec3 transmittanceLight; \n        for (int i = 0; i < sampleCount; i++) {\n            vec3 position = rayOrigin + t * rayDirection;\n            float height = length(position) - bottomRadius; \n            vec3 up = position / length(position);\n            float rayAngle = dot(up, rayDirection);\n            float lightAngle = dot(up, lightDirection);\n            // shadow is ommitted because it can create banding artifacts with low sample counts\n            // float distanceToGround;\n            // float shadow = intersectSphere(position, lightDirection, bottomRadius, distanceToGround) && distanceToGround >= 0.0 ? 0.0 : 1.0;         \n            float shadow = 1.0;\n            vec3 transmittanceToSpace = transmittanceFromTexture(height, cameraBelow ? -rayAngle : rayAngle);\n            transmittanceCamera = cameraBelow ? (transmittanceToSpace / transmittanceFromCameraToSpace) : (transmittanceFromCameraToSpace / transmittanceToSpace);\n            transmittanceLight = transmittanceFromTexture(height, lightAngle);\n            vec2 opticalDensity = exp(-height / vec2(rayleighScaleHeight, mieScaleHeight));\n            vec3 scatteredLight = transmittanceLight * (rayleighScatteringCoefficient * opticalDensity.x * rayleighPhase + mieScatteringCoefficient * opticalDensity.y * miePhase);\n            scatteredLight += multipleScatteringContributionFromTexture(height, lightAngle) * (rayleighScatteringCoefficient * opticalDensity.x + mieScatteringCoefficient * opticalDensity.y);  \n            light += shadow * transmittanceCamera * scatteredLight * segmentLength;\n            t += segmentLength;\n        }\n        \n        light *= sunIntensity;\n\n        if (hitGround) {\n            vec3 hitPoint = cameraPosition + rayDirection * distanceToGround;\n            vec3 up = hitPoint / length(hitPoint);\n            float diffuseAngle = max(dot(up, lightDirection), 0.0);\n            float lightAngle = dot(up, lightDirection);\n            float groundAlbedo = 0.05;\n            light += transmittanceCamera * (groundAlbedo / pi) * multipleScatteringContributionFromTexture(height, lightAngle) * sunIntensity;\n            light += transmittanceCamera * transmittanceLight * (groundAlbedo / pi) * diffuseAngle * sunIntensity;\n        }\n    }     \n    \n    // sun disk\n    float distanceToGround;\n    bool hitGround = intersectSphere(cameraPosition, rayDirection, bottomRadius, distanceToGround) && distanceToGround > 0.0;\n    if (!hitGround) {\n        float angle = dot(rayDirection, lightDirection);\n        if (angle > cos(sunAngularRadius)) {\n           light += sunIntensity * transmittanceFromCameraToSpace;\n        }\n    }\n\n    vec3 color = light;\n    // tone mapping\n    // float exposure = 10.0;\n    // color = (1.0 - exp(color * -exposure));\n    color *= 8.0;\n    color = aces(color);\n    color = pow(color, vec3(1.0 / 2.2));\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame > 1) {\n       \tfragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n    vec2 uv = fragCoord / iResolution.xy;\n    float height = uv.y * (topRadius - bottomRadius);\n    float angle = uv.x * 2.0 - 1.0;\n    fragColor = vec4(transmittance(height, angle), 0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float pi = 3.141592;\nfloat bottomRadius = 6360e3;\nfloat topRadius = 6460e3;\nfloat rayleighScaleHeight = 8e3;\nfloat mieScaleHeight = 1.2e3;\n// rayleightScatteringCoefficient from waveLength\n// vec3 waveLength = vec3(680e-9, 550e-9, 440e-9);\n// rayleighScatteringCoefficient = (1.0 / pow(waveLength, vec3(4.0))) * 1.241e-30;\nvec3 rayleighScatteringCoefficient = vec3(5.8e-6, 13.5e-6, 33.1e-6);\nfloat mieScatteringCoefficient = 3.996e-06;\nfloat mieExtinctionCoefficient = 4.440e-06;\nvec3 ozoneAbsorptionCoefficient = vec3(0.650e-6, 1.881e-6, 0.085e-6);\nfloat sunAngularRadius = 0.004685 * 2.0;\nfloat sunIntensity = 1.0;\n\nfloat rayleighPhase(float angle) {\n    return 3.0 / (16.0 * pi) * (1.0 + (angle * angle));\n}\n\nfloat miePhase(float angle) {\n    float g = 0.8;\n    return 3.0 / (8.0 * pi) * ((1.0 - g * g) * (1.0 + angle * angle)) / ((2.0 + g * g) * pow(1.0 + g * g - 2.0 * g * angle, 1.5));\n}\n\nmat3 rotationMatrixAxisAngle(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    vec3 column1 = axis * axis.x * (1.0 - c) + vec3(c, axis.z * s, -axis.y * s);\n    vec3 column2 = axis * axis.y * (1.0 - c) + vec3(-axis.z * s, c, axis.x * s);\n    vec3 column3 = axis * axis.z * (1.0 - c) + vec3(axis.y * s, -axis.x * s, c);\n    return mat3(column1, column2, column3);\n}\n\nbool intersectSphere(vec3 rayOrigin, vec3 rayDirection, float radius, inout float t1, inout float t2) {\n    float b = dot(rayDirection, rayOrigin);\n    float c = dot(rayOrigin, rayOrigin) - radius * radius;\n    float d = b * b - c;\n    if (d < 0.0) {\n        return false;\n    }\n    t1 = -b - sqrt(d);\n    t2 = -b + sqrt(d);\n    return true;\n}\n\nbool intersectSphere(vec3 rayOrigin, vec3 rayDirection, float radius, inout float t) {\n    float b = dot(rayDirection, rayOrigin);\n    float c = dot(rayOrigin, rayOrigin) - radius * radius;\n    float d = b * b - c;\n    if (d < 0.0) {\n        return false;\n    }\n    t = -b - sqrt(d);\n    return true;\n}\n\nvec3 opticalDepth(float height, float angle) {\n\tint sampleCount = 32;\n    vec3 rayOrigin = vec3(0.0, bottomRadius + height, 0.0);\n    vec3 rayDirection = vec3(sqrt(1.0 - angle * angle), angle, 0.0);\n    float t1;\n    float t2;\n    intersectSphere(rayOrigin, rayDirection, topRadius, t1, t2);\n    float segmentLength = t2 / float(sampleCount);\n\tfloat t = segmentLength * 0.5;\n    vec3 opticalDepth = vec3(0.0);\n\tfor (int i = 0; i < sampleCount; i++) {\n        vec3 position = rayOrigin + t * rayDirection;\n        float height = length(position) - bottomRadius;\n        opticalDepth.xy += exp(-height / vec2(rayleighScaleHeight, mieScaleHeight)) * segmentLength;\n        // density of the ozone layer is modeled as a triangular function that is 30 km wide and centered at 25 km altitude\n        opticalDepth.z += (1.0 - min(abs(height - 25e3) / 15e3, 1.0)) * segmentLength;  \n        t += segmentLength;\n    }\n    return opticalDepth;\n}\n\nvec3 transmittance(float height, float angle) {\n    vec3 opticalDepth = opticalDepth(height, angle);\n    return exp(-(rayleighScatteringCoefficient * opticalDepth.x + mieExtinctionCoefficient * opticalDepth.y + ozoneAbsorptionCoefficient * opticalDepth.z));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 transmittanceFromTexture(float height, float angle) {\n    float u = (angle + 1.0) * 0.5;\n    float v = height / (topRadius - bottomRadius);\n    return texture(iChannel0, vec2(u, v)).xyz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame > 1) {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n        return;\n    }\n    vec2 uv = fragCoord / iResolution.xy;\n    float height = uv.y * (topRadius - bottomRadius);\n    float angle = uv.x * 2.0 - 1.0;\n    vec3 rayOrigin = vec3(0.0, bottomRadius + height, 0.0);\n    vec3 up = rayOrigin / length(rayOrigin);\n    vec3 lightDirection = vec3(sqrt(1.0 - angle * angle), angle, 0.0);\n    float isotropicPhase = 1.0 / (4.0 * pi);\n    int sqrtSampleCount = 8;\n    vec3 light = vec3(0.0);\n    vec3 lightTransferFactor = vec3(0.0);\n    for (int i = 0; i < sqrtSampleCount; i++) {\n        for (int j = 0; j < sqrtSampleCount; j++) {    \n            float u = ((0.5 + float(i)) / float(sqrtSampleCount)) * 2.0 - 1.0;\n            float v = (0.5 + float(j)) / float(sqrtSampleCount);\n            float r = sqrt(1.0 - u * u);\n            float theta = 2.0 * pi * v;\n            vec3 rayDirection = vec3(cos(theta) * r, sin(theta) * r, u);\n            \n            int sampleCount = 32;\n            float rayAngle = dot(up, rayDirection);\n            bool cameraBelow = rayAngle < 0.0;\n            vec3 transmittanceFromCameraToSpace = transmittanceFromTexture(height, cameraBelow ? -rayAngle : rayAngle);\n            float offset = 0.0;\n            float distanceToSpace = 0.0;\n            intersectSphere(rayOrigin, rayDirection, topRadius, offset, distanceToSpace);\n            float distanceToGround = 0.0;\n            bool hitGround = intersectSphere(rayOrigin, rayDirection, bottomRadius, distanceToGround) && distanceToGround > 0.0;\n            float segmentLength = (hitGround ? distanceToGround : distanceToSpace) / float(sampleCount);\n            float t = segmentLength * 0.5;\n            vec3 transmittanceCamera;\n            vec3 transmittanceLight; \n            for (int k = 0; k < sampleCount; k++) {\n                vec3 position = rayOrigin + t * rayDirection;\n                float height = length(position) - bottomRadius;\n                vec3 up = position / length(position);\n                float rayAngle = dot(up, rayDirection);\n                float lightAngle = dot(up, lightDirection);\n                float distanceToGround;\n                float shadow = intersectSphere(position, lightDirection, bottomRadius, distanceToGround) && distanceToGround >= 0.0 ? 0.0 : 1.0;\n                vec3 transmittanceToSpace = transmittanceFromTexture(height, cameraBelow ? -rayAngle : rayAngle);\n                transmittanceCamera = cameraBelow ? (transmittanceToSpace / transmittanceFromCameraToSpace) : (transmittanceFromCameraToSpace / transmittanceToSpace);\n                transmittanceLight = transmittanceFromTexture(height, lightAngle);\n                vec2 opticalDensity = exp(-height / vec2(rayleighScaleHeight, mieScaleHeight));        \n                vec3 scatteredLight = transmittanceLight * (rayleighScatteringCoefficient * opticalDensity.x + mieScatteringCoefficient * opticalDensity.y) * isotropicPhase;\n                light += shadow * transmittanceCamera * scatteredLight * segmentLength;\n                lightTransferFactor += transmittanceCamera * (rayleighScatteringCoefficient * opticalDensity.x + mieScatteringCoefficient * opticalDensity.y) * segmentLength;\n                t += segmentLength;\n            }\n        \n            if (hitGround) {\n                vec3 hitPoint = rayOrigin + rayDirection * distanceToGround;\n                vec3 normal = normalize(hitPoint);\n                float diffuseAngle = max(dot(normal, lightDirection), 0.0); \n                vec3 earthAlbedo = vec3(0.3);\n                light += transmittanceCamera * transmittanceLight * (earthAlbedo / pi) * diffuseAngle;\n            }\n        }\n    }\n    light /= float(sqrtSampleCount * sqrtSampleCount);\n    lightTransferFactor /= float(sqrtSampleCount * sqrtSampleCount);\n    vec3 color = light / (1.0 - lightTransferFactor); \n    fragColor = vec4(color, 0.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"bool keyIsPressed(int key) {\n\treturn texelFetch(iChannel3, ivec2(key, 1), 0).x > 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (fragCoord.x > 1.0 || fragCoord.y > 1.0) {\n        discard;\n    }\n    float cameraCount = 3.0;\n    float index = round(texelFetch(iChannel0, ivec2(fragCoord), 0).x * (cameraCount - 1.0));\n    if (keyIsPressed(67)) {\n        if (index < cameraCount - 1.0) {\n           index += 1.0;\n        } else {\n           index = 0.0;\n        }\n    }\n    fragColor = vec4(index / (cameraCount - 1.0), 0.0, 0.0, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}