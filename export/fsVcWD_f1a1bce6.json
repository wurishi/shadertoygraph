{"ver":"0.1","info":{"id":"fsVcWD","date":"1654880147","viewed":119,"name":"Distorted Glass Caustics","username":"saalty","description":"A little experiment I made, caustics from distorted glass using raytracing. Drag your mouse over the viewport to look around the scene. It refracts light rays from the blue plane onto the light blue plane.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 unit = vec2(1.0) / iResolution.xy;\n    // Applying some quick and fast blur\n    fragColor = (\n                texture(iChannel0, uv) + \n                texture(iChannel0, uv + unit * vec2(-1, 0)) + \n                texture(iChannel0, uv + unit * vec2(0, 1)) +\n                texture(iChannel0, uv + unit * vec2(1, 0)) +\n                texture(iChannel0, uv + unit * vec2(0, -1))\n                ) / 5.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define AMBIENT 0.5\n#define IOR 1.57\n#define SAMPLECOUNT 64\n#define SPEED 20.0\n#define DISTORTION 0.5\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 final = vec3(0.0);\n    mat4 camrotY = rotationMatrix(vec3(0, 1, 0), iMouse.x / iResolution.x * 6.282);\n    for (int ri = 0;ri < SAMPLECOUNT;ri++)\n    {\n        vec3 ro = (camrotY * vec4(0.0, iMouse.y / iResolution.y * 25.0, 12.0, 0.0)).xyz + vec3(4.0, 0.0, 4.0);\n        vec3 rd = (camrotY * (vec4(normalize(vec3(uv / vec2(0.5, 1.0) - vec2(0.5 / 0.5, 0.5), 1.0)),0.0))).xyz;\n        vec3 rc = vec3(AMBIENT);\n        int steps = 0;\n        float eta = IOR;\n        bool keepgoing = true;\n        while (steps < 10 && keepgoing)\n        {\n            float mindist = 1000000.0;\n            int mini = -1;\n            for (int i = 0;i < planes.length();i++)\n            {\n                float dist = planeIntersect(ro, rd, planes[i].p0, planes[i].p1, planes[i].p2);\n                if (dist < mindist && dist > 0.0)\n                {\n                    mindist = dist;\n                    mini = i;\n                    \n                }\n            }\n            if (mindist != 1000000.0)\n            {\n                ro = ro + rd * mindist;\n                if (planes[mini].isRefract) eta = 1.0 / eta;\n                vec3 p0 = \n                vec3(\n                    ro.x, \n                    texture(iChannel1, (ro.xz * 0.01 * DISTORTION + iTime * 0.01 * SPEED) * 0.1).x / 2.0,\n                    ro.z\n                    );\n                vec3 p1 = \n                vec3(\n                    ro.x + 0.1, \n                    texture(iChannel1, (ro.xz * 0.01 * DISTORTION + iTime * 0.01 * SPEED) * 0.1 + vec2(0.1, 0)).x / 2.0,\n                    ro.z\n                    );\n                vec3 p2 = \n                vec3(\n                    ro.x, \n                    texture(iChannel1, (ro.xz * 0.01 * DISTORTION + iTime * 0.01 * SPEED) * 0.1 + vec2(0, 0.1)).x / 2.0,\n                    ro.z + 0.1\n                    );\n                vec3 newnormal = normalize(cross(p2 - p0, p1 - p0));\n                rd = tweakRay(\n                    planes[mini].isRefract ? refract(rd, newnormal, eta) \n                    : reflect(rd, planes[mini].normal), planes[mini].scatter, float(ri) * iTime);\n                ro += rd * 0.001;\n                rc *= planes[mini].color;\n                if (planes[mini].isLight)\n                {\n                    break;\n                }\n            }\n            steps++;\n        }\n        final = final * 0.95 + rc * 0.05;\n    }\n    fragColor = vec4(clamp(final, 0.0, 1.0), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"struct Plane\n{\n    vec3 p0;\n    vec3 p1;\n    vec3 p2;\n    bool isLight;\n    float scatter;\n    bool isRefract;\n    vec3 color;\n    vec3 normal;\n};\nPlane planes[] = Plane[](\n    Plane(\n        vec3(0, -1, 0), \n        vec3(0, -1, 1000), \n        vec3(-10, -1, 0),\n        false,\n        4.0,\n        false,\n        vec3(0.5, 0.5, 0.5),\n        vec3(0.0, 1.0, 0.0)\n    ),\n    Plane(\n        vec3(0, 20, 0), \n        vec3(0, 20, 1000), \n        vec3(-10, 20, 0),\n        false,\n        0.0,\n        true,\n        vec3(0.2, 0.2, 0.5),\n        vec3(0.0, -1.0, 0.0)\n    ),\n    Plane(\n        vec3(0, 200000, 0), \n        vec3(0, 200000, 1000), \n        vec3(-10, 200000, 0),\n        true,\n        10.0,\n        true,\n        vec3(100.0, 100.0, 100.0),\n        vec3(0.0, -1.0, 0.0)\n    )\n);\nfloat rand(float co) { return fract(cos(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(cos(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat random(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nmat4 rotationMatrix(vec3 axis, float angle) // Source: https://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 tweakRay(vec3 v, float r, float c)\n{\n    vec3 updated = normalize(v + \n    \n    vec3(\n        (rand((v.x) * c) - 0.5) * r, \n        (rand((v.y) * c) - 0.5) * r, \n        (rand((v.z) * c) - 0.5) * r\n        )\n    );\n    return updated;\n}\nfloat planeIntersect(vec3 r0, vec3 rd, vec3 p0, vec3 p1, vec3 p2)\n{\n    vec3 N = cross(p1-p0, p2-p0);\n    float X = dot(p0 - r0, N) / dot(rd, N);\n    return X;\n}","name":"Common","description":"","type":"common"}]}