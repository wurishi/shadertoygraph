{"ver":"0.1","info":{"id":"WsKcRt","date":"1603486789","viewed":148,"name":"Gray Scott simulation","username":"athibaul","description":"The Gray Scott model is a diffusion-reaction system with some lifelike properties. Mouse enabled. If the screen goes black, try restarting the simulation.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["simulation","diffusion","reaction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Source:\n// https://groups.csail.mit.edu/mac/projects/amorphous/GrayScott/\n\n// Quick implementation, pretty unstable.\n// \n\nvoid mainImage( out vec4 o, in vec2 p)\n{\n    o = texture(iChannel0, (p/scale)/iResolution.xy);\n    o = 4.*o.y * vec4(1.,0.7,0.3,1.) + o.x*vec4(0.1,0.2,0.5,1.);\n    o = pow(o, vec4(0.8));\n    //o = vec4(iMouse.zw / iResolution.xy, iMouse.z<0.?1:0, 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n#define T(p) textureLod(iChannel0, clamp(((p-0.5)+0.5)/iResolution.xy,0.,1./scale), 0.)\n//#define L(p) ((T(p+ex)+T(p-ex)+T(p+ey)+T(p-ey)-4.*T(p))/(dx*dx))\n// Nine-point stencil\n#define L(p) ((.5*(T(p+ex)+T(p-ex)+T(p+ey)+T(p-ey))+.25*(T(p+ex+ey)+T(p+ex-ey)+T(p+ey-ex)+T(p-ex-ey))-3.*T(p))/(dx*dx))\n\nvec4 initCond(vec2 p)\n{\n    p *= scale/iResolution.xy;\n    return mix(vec4(1,0,0,0), vec4(0,1,0,0),\n               smoothstep(0.3,0.2,length(p-vec2(0.5,0))));\n}\n\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    if(iFrame == 0)\n    {\n        o = initCond(p);\n    }\n    else if(p.x*scale < iResolution.x && p.y*scale<iResolution.y)\n    {\n        vec2 ex = vec2(1,0), ey = vec2(0,1);\n        float dx = scale*60./iResolution.y;\n        float dt = dx*dx*25.0*REDUCE_DT;\n        float r_u = 0.01;\n        float f = scale*p.x/iResolution.x * 0.04 + 0.01;\n        float k = scale*p.y/iResolution.y * 0.02+0.035;\n        //f += 0.01*sin(2.*3.1416*iTime/60.); // Force them to adapt to horizontal variation\n        k += f * 0.5;\n        //float f = 0.04, k = 0.06;\n        float r_v = 0.005;\n\n        float u = T(p).x, v = T(p).y;\n        float u_ = u + dt*(r_u * L(p).x - u*v*v + f*(1.-u));\n        float v_ = v + dt*(r_v * L(p).y + u*v*v - (f+k)*v);\n        \n        if(iMouse.z > 0.)\n        {\n            v_ += 0.01*dt*smoothstep(20., 0., length(p*scale-iMouse.xy));\n        }\n        \n        o = vec4(u_, v_, 0, 0);\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Downscaling factor (for faster simulation)\n// Set it back down to 1 if you feel like waiting\n#define scale 2.5\n\n// In case of numerical instability, reduce this number (slows the simulation)\n#define REDUCE_DT 1.0","name":"Common","description":"","type":"common"}]}