{"ver":"0.1","info":{"id":"4XfBDB","date":"1728827694","viewed":60,"name":"domain warping ksastro","username":"ksastro","description":"domain wrapping","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["domainwrapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\nuniform vec2 u_resolution;\nuniform float u_time;\n\nconst int NOISE_ITERATION_LIMIT = 7;\nconst vec3 PATTERN_SHIFT = vec3(1234.,9675.,71713.);\n\nvec3 paletteBrownish (float t){\n    vec3 a = vec3(0.5, 0.31, 0.15);\n    vec3 b = vec3(0.37, 0.18, 0.15);\n    vec3 c = vec3(0.5, 0.5, 0.5);\n    vec3 d = vec3(0.5,0.5,0.);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nuint hashUint (in uint seed){ //murmur type of hash from https://t.ly/bKdP7\n    seed ^= seed >> 17;\n    seed *= 0xed5ad4bbU;\n    seed ^= seed >> 11;\n    seed *= 0xac4c1b51U;\n    seed ^= seed >> 15;\n    seed *= 0x31848babU;\n    seed ^= seed >> 14;\n    return seed;\n}\n\nfloat hashFloat2d(in vec2 seed){\n    uint hashX = hashUint(uint(seed.x + PATTERN_SHIFT.x));\n    uint hashXY = hashUint(hashX + uint(seed.y + PATTERN_SHIFT.y));\n    return float(hashXY) / float(0xFFFFFFFFU);\n}\n\nvec2 hashVec2Unit(in vec2 seed){\n    float hashAngle = 2.*3.1415*hashFloat2d(seed);\n    return (rotate2d (hashAngle) * vec2(1.,0.));\n}\n\nfloat singleCornerNoise2d (vec2 gridCorner, vec2 point){      \n    float res;\n    res = dot(gridCorner - point, hashVec2Unit(gridCorner));\n    res = atan(res)* 2./3.1415;     //map to (-1;1)\n    return (res);\n}\n\n\nfloat lerp (in float leftValue, in float rightValue, in float offset){  //offset от 0 до 1\n    return (leftValue + (rightValue - leftValue) * (smoothstep(0.,1.,offset)));\n}\n\nfloat noise2d(in vec2 uv, float frequency){\n    uv *= frequency;\n    vec2 gridCornerCoords[4];\n    gridCornerCoords[0] = vec2(floor(uv));              //bottom left\n    gridCornerCoords[1] = vec2(floor(uv)) + vec2(1,0);  //bottom right\n    gridCornerCoords[2] = vec2(floor(uv)) + vec2(0,1);  //top left\n    gridCornerCoords[3] = vec2(floor(uv)) + vec2(1,1);  //top right\n    float gridCornerValues[8];\n    for (int i = 0; i<4; i++){gridCornerValues[i] = singleCornerNoise2d(gridCornerCoords[i],uv);}\n    float bottom = lerp(gridCornerValues[0],gridCornerValues[1], fract(uv.x));\n    float top = lerp(gridCornerValues[2],gridCornerValues[3], fract(uv.x));\n    return (lerp(bottom, top, fract(uv.y)));\n}\n\nfloat fbm (float startingFrequency, vec2 position){\n    float noiseValue = 0.;\n    float frequency = startingFrequency;\n    float  amplitude = 1./frequency;\n    //float angle = 0.;\n    for(int i = 0; i < NOISE_ITERATION_LIMIT; i++){\n        noiseValue += amplitude*noise2d(position, frequency);\n        amplitude *= 0.5;\n        frequency *= 2.;\n        position += PATTERN_SHIFT.xy;\n        //uv+= 0.1*rotate2d(angle)*vec2(u_time);\n        //angle += 2.*3.1415/float(NOISE_ITERATION_LIMIT);\n    }\n    return noiseValue; \n}\n\nvec2 fbm2d (float startingFrequency, vec2 position){\n    return 3.5*vec2 (fbm(startingFrequency, position), fbm(startingFrequency, position + PATTERN_SHIFT.xy));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float t = iTime * .2; //anim speed\n    vec2 uv = (fragCoord.xy * 2. - iResolution.xy)/iResolution.y;\n    //uv.x = fract(5.*(uv.x))*2.-1.;    //paving\n    //uv.y = 5.*uv.y;\n    float noiseValue = 0.;\n    vec2 noiseVec2 = vec2(0.);\n    vec3 col = vec3(0.,0.,.0);\n    noiseVec2 = fbm2d(1., uv);\n    for(int i = 0; i < 2; i++){\n        noiseVec2 = fbm2d(1., uv + noiseVec2 + vec2(t));\n    }\n    noiseValue = fbm(1., uv + noiseVec2);\n    noiseValue = (noiseValue + 1.)*.5; //map to (0,1) from (-1,1)\n    col = paletteBrownish(noiseValue);\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}