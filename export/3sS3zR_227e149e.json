{"ver":"0.1","info":{"id":"3sS3zR","date":"1547886711","viewed":189,"name":"Guzzle","username":"syuji_higa","description":"Raymarching.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n#define EPS 1e-4\n\nstruct Ray {\n  vec3 pos;\n  vec3 dir;\n};\n\nfloat easeOutQuad (float t) {\n  return -1. * t * (t - 2.);\n}\n\nfloat progress (float s, float d) {\n  float i = fract(iTime / 120.);\n  return easeOutQuad(min(max(i - s, 0.) / d, 1.));\n}\n\nfloat interpolate(float a, float b, float x){\n  float f = (1. - cos(x * PI)) * .5;\n  return a * (1. - f) + b * f;\n}\n\nfloat random (vec2 p) {\n  return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat irandom(vec2 p){\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  vec4 v = vec4(\n    random(vec2(i.x,      i.y     )),\n    random(vec2(i.x + 1., i.y     )),\n    random(vec2(i.x,      i.y + 1.)),\n    random(vec2(i.x + 1., i.y + 1.))\n  );\n  return interpolate(interpolate(v.x, v.y, f.x), interpolate(v.z, v.w, f.x), f.y);\n}\n\nfloat smoothMin(float d1, float d2, float k) {\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\nfloat distBallFunc(vec3 p, float s, float r, vec3 o) {\n  return length(vec3(\n    p.x + o.x * 15.,\n    p.y + o.y * 15.,\n    p.z - 70. + sin(iTime * 2.) * 15.\n  )) - s * (.5 + (o.z * .5)) * r;\n}\n\nfloat distLiquidFunc(vec3 p, vec4 r) {\n  return length(\n    vec3(\n      p.x + (.5 - irandom(p.yy * .1 + iTime)) * 10. * r.y,\n      p.y + (.5 - irandom(p.zz * .1 + iTime)) * 10. * r.y,\n      p.z - 100.\n    )) - (40. - 14. * (1. - exp(sin(iTime * 3.) * 2.) / exp(2.)) * r.w) * r.x;\n}\n\nfloat distBlocksFunc(vec3 p, vec4 r) {\n  vec3 o = p;\n  vec4 v = vec4(p, 1.);\n  mat4 tr = mat4(\n    abs(cos(iTime * .2)) * 2. * r.z + (1. - r.z), 0., p.y * sin(iTime * .5) * .1 * r.z, 0.,\n    0., abs(sin(iTime * .2)) * 2. * r.z + (1. - r.z), p.x * cos(iTime * .5) * .1 * r.z, 0.,\n    0., 0., 1., 0.,\n    0., 0., 0., 1.\n  );\n  v = tr * v;\n  p = vec3(\n    v.x + 2. + fract(iTime * .5) * 3.,\n    v.y + 2. + fract(iTime * .5) * 3.,\n    v.z - pow(length(p.xy), 1.2) - fract(iTime * .5) * 20.\n  );\n  float s = (.3 + (.7 - exp(sin(iTime * 6.) * 4.) / exp(4.) * .8) * r.y) * r.x;\n  vec3 d = abs(vec3(\n    (mod(p.x, 3.) - 1.5),\n    (mod(p.y, 3.) - 1.5),\n    (mod(p.z, 20.) - 10.) + random(floor(v.xy)) * 30. * r.w\n  )) - s;\n  return (length(max(d, 0.)) - .1 + min(max(d.x, max(d.y, d.z)), 0.));\n}\n\nfloat distFunc(vec3 p) {\n  float r_ball1 = progress(.030, .010) - progress(.200, .030);\n  vec3 oBall1 = vec3(cos(iTime * 2.), sin(iTime * 2.), abs(sin(iTime)));\n  float dBall1 = distBallFunc(p, 13., r_ball1, oBall1);\n  float dBall1S = distBallFunc(p, 15., r_ball1, oBall1);\n\n  float r_ball2 = progress(.090, .020) - progress(.200, .030);\n  vec3 oBall2 = vec3(sin(iTime * 2.), cos(iTime * 2.), cos(sin(iTime)));\n  float dBall2 = distBallFunc(p, 13., r_ball2, oBall2);\n  float dBall2S = distBallFunc(p, 15., r_ball2, oBall2);\n  \n  vec4 r_liquid = vec4(\n    progress(.120, .050) - progress(.980, .003),\n    progress(.170, .030),\n    progress(.180, .030) - progress(.230, .020),\n    progress(.210, .050)\n  );\n  float dLiquid = distLiquidFunc(p, r_liquid);\n\n  vec4 r_blocks = vec4(\n    progress(.300, .100) - progress(.978, .003),\n    progress(.400, .100) - progress(.965, .010),\n    progress(.650, .030) - progress(.820, .030),\n    progress(.850, .100)\n  );  \n  float dBlocks = distBlocksFunc(p, r_blocks);\n  \n  float dBalls = smoothMin(dBall1, dBall2, .4);\n  float dBallsS = smoothMin(dBall1S, dBall2S, .4);\n  \n  if(r_blocks.x != 0.) {\n    return smoothMin(dBlocks, dLiquid, 4.);\n  }\n  if(r_liquid.x != 0.) {\n    return smoothMin(max(-dBallsS, dLiquid), dBalls, 4.);\n  }\n  if(r_ball2 != 0.) {\n    return dBalls;\n  }\n  return dBall1;\n}\n\nvec3 normalFunc(vec3 p) {\n  float d = distFunc(p);\n  return normalize(vec3(\n    distFunc(p + vec3(EPS, 0., 0.)) - d,\n    distFunc(p + vec3(0., EPS, 0.)) - d,\n    distFunc(p + vec3(0., 0., EPS)) - d\n  ));\n}\n\nvec3 hsv(float h, float s, float v){\n  vec4 t = vec4(1., 2. / 3., 1. / 3., 3.);\n  vec3 p = abs(fract(vec3(h) + t.xyz) * 6. - vec3(t.w));\n  return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0., 1.), s);\n}\n\nvec3 colorFunc(vec3 n) {\n  float r_hsv = progress(.500, .010);\n  vec3 c = vec3(.5, .5, .5);\n  c = c * (1. - r_hsv);\n  c = c + hsv(abs(sin(iTime * .1) * r_hsv), .2, .6) * r_hsv;\n\n  vec3 l0 = normalize(vec3(0., 0., -1.));\n  vec3 l1 = normalize(vec3(-1., 1., -1.));\n  vec3 l2 = normalize(vec3(1., 1., -1.));\n  vec3 l3 = normalize(vec3(1., -1., -1.));\n  vec3 l4 = normalize(vec3(-1., -1., -1.));\n\n  float r_light = progress(.250, .050);\n  vec3 c0 = dot(n, l0) * c;\n  vec3 c1 = dot(n, l1) * c * .6 * r_light;\n  vec3 c2 = dot(n, l2) * c * .6 * r_light;\n  vec3 c3 = dot(n, l3) * c * .6 * r_light;\n  vec3 c4 = dot(n, l4) * c * .6 * r_light;\n\n  c1 = c1 + vec3(pow(c1.r, 4.), pow(c1.g, 4.), pow(c1.b, 4.)) * 10.;\n  c2 = c2 + vec3(pow(c2.r, 4.), pow(c2.g, 4.), pow(c2.b, 4.)) * 10.;\n  c3 = c3 + vec3(pow(c3.r, 4.), pow(c3.g, 4.), pow(c3.b, 4.)) * 10.;\n  c4 = c4 + vec3(pow(c4.r, 4.), pow(c4.g, 4.), pow(c4.b, 4.)) * 10.;\n\n  vec3 t = c0;\n  t = max(max(max(max(c0, c1), c2), c3), c4);\n  t = t + vec3(pow(t.r, 4.), pow(t.g, 4.), pow(t.b, 4.)) * 25.;\n  return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 pos = (fragCoord.xy * 2. - iResolution.xy) / max(iResolution.x, iResolution.y);\n\n  vec3 camPos = vec3(0., 0., -3.);\n  vec3 camTop = normalize(vec3(1. - 2. * (exp(sin(iTime)) / exp(1.)), 1., 0.));\n  vec3 camDir = normalize(vec3(sin(iTime) * .2, cos(iTime) * .2, 1.));\n  vec3 camSid = normalize(cross(camTop, camDir));\n\n  Ray ray;\n  ray.pos = camPos;\n  ray.dir = normalize(pos.x * camSid + pos.y * camTop + camDir);\n\n  float dist = 0.;\n  float total = 0.;\n\n  for(int i = 0; i < 128; i++) {\n    dist = distFunc(ray.pos);\n    if(dist < .0001 || total > 100.) {\n      break;\n    }\n    total += min(\n      min(\n        (step(0., ray.dir.x) - fract(ray.pos.x)) / ray.dir.x,\n        (step(0., ray.dir.z) - fract(ray.pos.z)) / ray.dir.z\n      ) + .01, dist\n    );\n    ray.pos = camPos + total * ray.dir;\n  }\n\n  vec3 norm = normalFunc(ray.pos) * (1. - pow(total * .01, 2.));\n  vec3 col = colorFunc(norm);\n  vec3 baseCol = vec3(0., .1, .15);\n  col = max(col, baseCol);\n  col = vec3(pow(col.x, 2.), pow(col.y, 2.), pow(col.z, 2.));\n\n  if(dist < .0001) {\n    fragColor = vec4(col, 1.);\n  } else {\n    float r_bg = progress(.000, .020) - progress(.985, .015);\n    fragColor = vec4((baseCol + vec3(pow(length(pos), 4.)) * .05) * r_bg, 1.);\n  }\n}","name":"Image","description":"","type":"image"}]}