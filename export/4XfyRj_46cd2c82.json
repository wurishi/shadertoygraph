{"ver":"0.1","info":{"id":"4XfyRj","date":"1726403641","viewed":23,"name":"Archimedes Spiral #1","username":"cesio","description":"Arichmedes spiral variation with ellipses changing their radiuses","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["archimedesspiral"],"hasliked":0,"parentid":"l3XcDH","parentname":"Bouncing balls #2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// a number of seconds - loop\n#define N 12. \n// A coefficient for the spirala formula\n#define A -0.2\n// a ball rad0ius\n#define R 0.05\n// speed of a ball\n#define S 2.\n// a number of balls\n#define NB 50\n// a time slot between balls in seconds\n#define TS 0.25\n#define PI 3.14159265359\n\nvec4 circle (vec2 st, vec2 pos, float radius,vec3 color){\n    float pct = distance(st,pos);\n    vec3 colorR = vec3(smoothstep(radius,radius * 0.9,pct)) * color;\n //   vec3 colorR = vec3(step(pct,radius)) * color;\n\treturn vec4(colorR, 1.0);\n}\n\n// taken from thebookofshaderx.com\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec4 drawEllipse(vec2 st, vec2 center, vec2 radii,vec3 color) {\n    vec2 pos = st - center;\n    vec3 retCol = color;\n    float ellipse = (pos.x * pos.x) / (radii.x * radii.x) +\n                    (pos.y * pos.y) / (radii.y * radii.y);\n\n    return vec4(vec3(step(ellipse, 1.0) * color), 1.);\n  //  return vec4(vec3(smoothstep(ellipse, ellipse * 0.9,pos.x))* color, 1.);\n//return vec4(vec3(smoothstep(vec2(ellipse), vec2(ellipse * 0.9),pos) * color), 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Remap the space to -1. to 1.\n    uv = uv *2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // ### PLAY WITH SPACE START ### move space from the center to the vec2(0.0)\n    //uv -= vec2(0.5);\n    // rotate the space\n    uv = rotate2d( sin(iTime)*PI ) * uv;\n            \n    float ballsOffset = (2.) / float (NB + 1);\n    //vec3 color2 = vec3(0.0, 0.0, 0.0);\n    vec3 color1 = vec3(0.2, 0.2, 1.);\n    \n\n    vec4 col = vec4(0.);\n    \n    for (int i = 0; i < NB; i++) {\n        float offsetTime = iTime - TS * float(i);\n        \n      \n        // check whether it is time to start Nth ball\n        if (offsetTime >= 0.) {\n            // we want to limit time to cycle of N seconds\n            float localTime = mod(offsetTime,float(N));\n            // we want to increase the speed as time passes by\n            float speed = S;//+ pow(1.4, localTime);\n            \n            // we calculate x,y coordinates of the ball using well known formulas\n            float x = -A * localTime * cos(localTime*S);\n            float y = -A * localTime * sin(localTime*S);\n\n            //col += circle(uv, vec2(x,y),R*localTime,vec3(localTime/N) * color1);\n            float ce = localTime/N;\n            float rX = R * localTime;// * (sin(iTime * S * 2.) /2. + 1.);\n            float rY = (R - rX)  / 4.;\n            \n\n\n            col += drawEllipse(uv, vec2(x,y),vec2(rX, rY),vec3(ce) * color1);\n            col = max(col,drawEllipse(uv, vec2(x,y),vec2(rY, rX),vec3(ce) * color1));\n\n           //col += circle(uv, vec2(x,y),R*localTime,vec3(1.));\n        }\n    }\n    \n    // ### PLAY WITH SPACE END ### move the space back to the original place\n    // rotate the space back\n    uv = rotate2d( sin(iTime)*PI ) * uv;\n    //uv += vec2(0.5);\n            \n    // Time varying pixel color\n    vec3 colBg = 0.3 - 0.2*cos(uv.xxy);\n\n\n    fragColor = vec4(colBg, 1.);\n    fragColor += col;\n }\n    ","name":"Image","description":"","type":"image"}]}