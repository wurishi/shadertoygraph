{"ver":"0.1","info":{"id":"WdSXRW","date":"1553001113","viewed":175,"name":"GGX Distribution","username":"PhiWei","description":"A simple visualization of the disk-projected GGX Distribution (Trowbridge-Reitz distribution).\nClick on disk for setting (theta/phi)\nTo modify rougness in x and y use the arrow keys.","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["brdf","distribution","ggx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI     3.14159265358979323846\n#define INV_PI 0.31830988618\n#define u_Gamma 1.0\n#define u_Scale 1.0\n\n#define sqr(a) ( (a)*(a) )\n\n#define EPSILON 0.004\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n//                            Trigonometrix Helpers                          //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n\nfloat CosTheta(vec3 w) { return w.z; }\n\nfloat Cos2Theta(vec3 w) { return w.z * w.z; }\n\nfloat Sin2Theta(vec3 w) {\n    return max(0.0, 1.0 - Cos2Theta(w));\n}\n\nfloat SinTheta(vec3 w){\n    return sqrt(Sin2Theta(w));\n}\n\nfloat Tan2Theta(vec3 w) {\n    return Sin2Theta(w) / Cos2Theta(w);\n}\n\nfloat CosPhi(vec3 w) {\n    float sinTheta = SinTheta(w);\n    return ((sinTheta == 0.0) ? 1.0 : clamp(w.x / sinTheta, -1.0, 1.0));\n}\n\nfloat SinPhi(vec3 w) {\n    float sinTheta = SinTheta(w);\n    return ((sinTheta == 0.0) ? 0.0 : clamp(w.y / sinTheta, -1.0, 1.0));\n}\n\nfloat Cos2Phi(vec3 w) {\n    return CosPhi(w) * CosPhi(w);\n}\nfloat Sin2Phi(vec3 w) {\n    return SinPhi(w) * SinPhi(w);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n//                             GGX Distribution                              //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n\nfloat GGX_D(vec3 wi, vec3 wo, vec3 n, float a_x,float a_y) {\n    vec3  wh     = normalize(wi+wo);\n    \n    float tan2Theta = Tan2Theta(wh);\n    float cos4Theta = Cos2Theta(wh) * Cos2Theta(wh);\n    float e = (Cos2Phi(wh) / (a_x * a_x) +\n               Sin2Phi(wh) / (a_y * a_y)) * tan2Theta;\n    return 1.0 / (PI * a_x * a_y * cos4Theta * (1.0 + e) * (1.0 + e));\n}\n\n/// Compute the effective roughness projected on direction \\c v\nfloat projectRoughness(vec3 v,float alpha_x,float alpha_y) {\n    float sin2Theta = Sin2Theta(v);\n    float invSinTheta2 = sin2Theta == 0.0 ? 0.0 : 1.0 / sin2Theta;\n\n    if (invSinTheta2 <= 0.0)\n        return alpha_x;\n\n    float cosPhi2 = v.x * v.x * invSinTheta2;\n    float sinPhi2 = v.y * v.y * invSinTheta2;\n\n    return sqrt(cosPhi2 * alpha_x * alpha_x + sinPhi2 * alpha_y * alpha_y);\n}\n\n/* Smith GGX geometric functions\n */\nfloat GGX_G1(vec3 v, vec3 n,float alpha_x, float alpha_y) {\n    float a =  projectRoughness(v,alpha_x, alpha_y);\n    float NdotV = dot(v,n);\n\n    float a2 = sqr(a);\n    return 2.0/(1.0 + sqrt(1.0 + a2 * (1.0-sqr(NdotV)) / sqr(NdotV) ));\n}\n\n/* Smith uncorrelated shadowing/masking function anisotropic.\n */\nfloat GGX_G(vec3 wi, vec3 wo,float alpha_x,float alpha_y) {\n    vec3 n = vec3(0.0,0.0,1.0);\n    return GGX_G1(wi,n,alpha_x,alpha_y) * GGX_G1(wo,n,alpha_x,alpha_y);\n}\n\n\nfloat GGX_Reflection(vec3 wi, vec3 wo, vec3 n, float a_x,float a_y){\n    vec3  wh     = normalize(wi+wo);\n    float cosThetaWh = dot(n, wh);\n    float cosThetaWi = dot(n, wi);\n    float cosThetaWo = dot(n, wo);\n\n    float G = GGX_G(wi, wo, a_x,a_y);\n    float D = GGX_D(wi, wo, vec3(0.0, 0.0, 1.0),a_x,a_y);\n\n    return G*D/(abs(4.0*cosThetaWi));\n}\n\n/* Gamma transformation\n */\nvec3 Gamma(vec3 R) {\n    return exp(u_Gamma * log(u_Scale * R));\n}\n\n/* Evaluate an emissive term\n */\nvec3 Emission(vec3 wi,vec3 wo, float a_x, float a_y) {\n    return GGX_Reflection(wi, wo, vec3(0.0, 0.0, 1.0),a_x,a_y) * vec3(1.0);\n}\n\nvec3 drawGrid(in vec3 fragColor ,in float sinTo){\n    for(float i = 0.0 ; i < PI/2.0 ; i += PI/12.0){\n        if(asin(sinTo+EPSILON) >= i && asin(sinTo) <= i){\n            return vec3(0.1,0.5,0.6); \n        }\n    }\n    return fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 thetaPhi = (2.* iMouse.xy - iResolution.xy ) / iResolution.y;\n\tvec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n\n    vec3 wi = vec3(thetaPhi,0);\n    wi.z = sqrt(1.0 - length(wi.xy));\n    \n    float alpha_x = texelFetch(iChannel1,ivec2(0,0), 0 ).x;\n\tfloat alpha_y = texelFetch(iChannel1,ivec2(0,0), 0 ).y;\n    if(alpha_x <= 0.0)\n        alpha_x = 0.005; \n    if(alpha_y <= 0.0)\n    \talpha_y = 0.005;\n    \n    vec3 wo = vec3(uv,0);\n    float sinTo = length(wo.xy);\n    if(sinTo <= 1.0) {\n \n        wo.z = sqrt(1.0 - sinTo*sinTo);\n        \n        // Evaluate the GGX Distribution\n        fragColor.xyz = Gamma(Emission(wi,wo, alpha_x,alpha_y) * vec3(1,1,1));\n        fragColor.w   = 1.0;\n\n        // draws a grid for theta\n        fragColor.xyz = drawGrid(fragColor.xyz,sinTo);\n    } else {\n        fragColor = vec4(0.0);\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst float alpha_x = 0.01;\nconst float alpha_y = 0.01;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if(texelFetch( iChannel0, ivec2(KEY_LEFT,1),0 ).x == 1.0){\n        if(texture(iChannel1,fragCoord).x > 0.0)\n      \t\tfragColor.xy = texture(iChannel1,fragCoord).xy + vec2(-alpha_x,0);\n    }else if(texelFetch( iChannel0, ivec2(KEY_RIGHT,1),0 ).x == 1.0){\n        if(texture(iChannel1,fragCoord).x < 1.0)\n      \t\tfragColor.xy = texture(iChannel1,fragCoord).xy + vec2(alpha_x,0);\n    }else if(texelFetch( iChannel0, ivec2(KEY_UP,1),0 ).x == 1.0){\n      \tif(texture(iChannel1,fragCoord).y < 1.0)\n            fragColor.xy = texture(iChannel1,fragCoord).xy + vec2(0,alpha_y);\n    }else if(texelFetch( iChannel0, ivec2(KEY_DOWN,1),0 ).x == 1.0){\n      \tif(texture(iChannel1,fragCoord).y > 0.0)\n            fragColor.xy = texture(iChannel1,fragCoord).xy + vec2(0,-alpha_y);\n    }\n    else{\n    \tfragColor.xy = texture(iChannel1,fragCoord).xy;\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}