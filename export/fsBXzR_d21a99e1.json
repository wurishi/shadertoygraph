{"ver":"0.1","info":{"id":"fsBXzR","date":"1619530776","viewed":280,"name":"Analytic closest 3D Pts (beta)","username":"iapafoto","description":"line/line ok, caps/caps ok, caps/disk (ok?), disk/disk approx\nThe idea is to find closest points by orienting 2 caps inside the disks\nMay be enought precise when close to use it for collision in physic engine shader. To be continued... :)","likes":23,"published":1,"flags":0,"usePreview":1,"tags":["collision","disk","caps","tools","closest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// closest distance caps caps (seems ok)\n// \n// Also: trying to find closest from cheese Disks\n// by correctly orienting 2 caps but sometimes not good\n\n\n// --------------------------------------------\n// Decomment to display construction lines\n\n#define CAPS      1\n#define DISK      2\n#define SPHERE    3\n#define POLY      4  // convex poly\n\n#define PLANE     5\n#define SEGMENT   6\n#define DISK_FLAT 7\n#define DOT       8\n#define POLY_FLAT 9 // convex poly\n\n#define iTime (iTime*1.5)\n\n#define SHOW_DISTANCE \n //#define DEBUG\n// #define SHAPE_1 POLY\n// #define SHAPE_2 POLY\n// #define TEST_PARALLEL\n\n\n\n// --------------------------------------------\n\n// Without thickness\n// -----------------\n//         +------+------+------+-------+------+------+\n//         |  pt  | line | seg  | plane | disk | poly |\n// +-------+------+------+------+-------+------+------+\n// | pt    |  ok  |  ok  |  ok  |  ok   |  ok  |  ok  |\n// +-------+------+------+------+-------+------+------+\n// | line  |  ok  |  ok  |      |   /   |      |  /   |\n// +-------+------+------+------+-------+------+------+\n// | seg   |  ok  |      |  ok  |  ok   | appx |  ok  |\n// +-------+------+------+------+-------+------+------+\n// | plane |  ok  |   /  |  ok  |   /   |  ok  |  ok  |\n// +-------+------+------+------+-------+------+------+\n// | disk  |  ok  |      | appx |  ok   | appx |      |\n// +-------+------+------+------+-------+------+------+\n// | poly  |  ok  |   /  |  ok  |  ok   |  /   |  ok  |\n// +-------+------+------+------+-------+------+------+\n\n\n// With thickness\n// --------------\n//                1      2      3      4\n//            +------+------+------+-------+------+\n//            | caps |sphere| disk | plane | poly |\n//    +-------+------+------+------+-------+------+\n//  1 | caps  |  ok  |  ok  | appx |  ok   |  ok  |\n//    +-------+------+------+------+-------+------+\n//  2 | sphere|  ok  |  ok  |  ok  |  ok   |  ok  |\n//    +-------+------+------+------+-------+------+\n//  3 | disk  | appx |  ok  | appx |  ok   |      |\n//    +-------+------+------+------+-------+------+\n//  4 | plane |  ok  |  ok  |  ok  |   /   |  ok  |\n//    +-------+------+------+------+-------+------+\n//  5 | poly  |  ok  |  ok  |  /   |  ok   |  ok  |\n//    +-------+------+------+------+-------+------+\n\nint gShape1, gShape2;\nbool inside;\nvec3 seg00, seg01, seg10, seg11;\nfloat ep0, ep1; \nvec3 pt0, pt1, pt2, pt3, pt4, pt5;\n\nfloat glow;\nfloat r0,r1;\nvec3 c0,c1,n0,n1;\nvec3 poly0[POLY_SZ];\nvec3 poly1[POLY_SZ];\n\n// add thickness\nbool removeThickness(float e0, float e1, out vec3 out0, out vec3 out1) {\n    float d = length(out0 - out1);\n    bool inside = d < e0+e1;\n    if (d>0.) {\n        vec3 v = normalize(out0 - out1);\n        out0 -= e0*v;\n        out1 += e1*v;\n    }\n    return inside;\n}\n\n// project vector on plane\nvec3 projVecOnPlane(vec3 u, vec3 n) {\n    return u - dot(u,n)*n;\n}\n\n// project point on plane\nvec3 projPtOnPlane(vec3 p, vec3 pPlane, vec3 nPlane) {\n    return pPlane + projVecOnPlane(p-pPlane, nPlane) ;\n}\n\n\n/**********************************************************************/\n/*                 BASIC SHAPES (WITHOUT TICKNESS)                    */\n/**********************************************************************/\n\n//---------------------------------------------------------\n// Find the closest point on a infinite line\n//---------------------------------------------------------\nvec3 closestPtLine(vec3 p, vec3 pLine, vec3 nLine) {\n\treturn pLine + nLine * dot(p - pLine, nLine);\n}\n\n//---------------------------------------------------------\n// Find the closest point on segment\n//---------------------------------------------------------\nvec3 closestPtSeg(vec3 p, vec3 pLine1, vec3 pLine2) {\n\tvec3 pa = p-pLine1, ba = pLine2-pLine1;\n\treturn pLine1 + ba*clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n}\n\n//---------------------------------------------------------\n// Find the closest point on plane\n//---------------------------------------------------------\nvec3 closestPtPlane(vec3 p, vec3 pPlane, vec3 nPlane) {\n\treturn projPtOnPlane(p, pPlane, nPlane);\n}\n\n//---------------------------------------------------------\n// Find the closest point on disk\n//---------------------------------------------------------\nvec3 closestPtDisk(vec3 p, vec3 cDisk, vec3 nDisk, float rDisk) {\n    vec3 n = cDisk - projPtOnPlane(p, cDisk, nDisk);\n    float d = length(n);\n    return d == 0. ? cDisk : cDisk - (n/d)*clamp(d, 0., rDisk);\n}\n\n//---------------------------------------------------------\n// Find the closest points between a segment and a plane\n//---------------------------------------------------------\nvoid closestSegmentPlane(vec3 p1Line, vec3 p2Line, vec3 pPlane, vec3 nPlane, out vec3 out0, out vec3 out1) {\n    // if intersect : get intersection\n    vec3 rd = normalize(p2Line - p1Line);\n    vec3 pdk;\n\n    float a = dot(rd, nPlane);\n    float d = -(dot(p1Line, nPlane)-dot(nPlane,pPlane))/a;\n    if (d>0. && d<distance(p1Line, p2Line)) {\n        out1 = out0 = p1Line + rd * d;\n    } else {\n        // Just project sommets of line on plane and select the closest\n        vec3 p1OnPlane = projPtOnPlane(p1Line, pPlane, nPlane),\n             p2OnPlane = projPtOnPlane(p2Line, pPlane, nPlane);   \n        if (distance(p1Line, p1OnPlane) < distance(p2Line, p2OnPlane)) {\n            out0 = p1Line;\n            out1 = p1OnPlane;\n        } else {\n            out0 = p2Line;\n            out1 = p2OnPlane;\n        }\n    }\n}\n\n\n//---------------------------------------------------------\n// Find the closest points between a disk and a plane\n//---------------------------------------------------------\nvoid closestDiskPlane(vec3 cDisk, vec3 nDisk, float rDisk, vec3 pPlane, vec3 nPlane, out vec3 out0, out vec3 out1) {   \n    float dt = dot(nDisk,nPlane);\n    if (dt == 1.) { // planes are paralleles \n        out0 = cDisk;\n    } else {\n        vec3 rd = normalize(cross(cross(nPlane,nDisk),nDisk));\n        float a = dot(rd, nPlane);\n        a = (dot(cDisk,nPlane)-dot(pPlane,nPlane))/a;\n        out0 = cDisk - rd * sign(a) * min(abs(a), rDisk); // min if disk cross the plane\n    }\n    // project solution on plane\n    out1 = out0 - nPlane*dot(out0-pPlane,nPlane);\n}\n\n//---------------------------------------------------------\n// Find the closest points between two infinite lines\n//---------------------------------------------------------\nvoid closestLineLine(vec3 p00, vec3 p01, vec3 p10, vec3 p11, out vec3 out0, out vec3 out1) {\n    vec3   u = p01 - p00, v = p11 - p10, w = p00 - p10;\n    float  a = dot(u,u), b = dot(u,v), c = dot(v,v),\n           k0, k1, k = a*c - b*b;\n    if (k < 1e-5) { // the lines are almost parallel return centers\n        k0 = k1 = .5; // Not good \n    } else {\n        float e = dot(v,w), d = dot(u,w); \n        k1 = (a*e - b*d)/k;\n        k0 = (b*e - c*d)/k;\n    }\n    out0 = p00 + u * k0;\n    out1 = p10 + v * k1;\n}\n\n\n//---------------------------------------------------------\n// Find the closest points between two segments\n//---------------------------------------------------------\nvoid closestSegmentSegment(vec3 p00, vec3 p01, vec3 p10, vec3 p11, out vec3 out0, out vec3 out1) {\n    vec3   u = p01 - p00, v = p11 - p10, w = p00 - p10;\n    float  a = dot(u,u), b = dot(u,v), c = dot(v,v),\n           k0, k1, k = a*c - b*b;\n    if (k < 1e-6) { \n        // the lines are almost parallel\n        k0 = dot(u,p10-p00) / a;\n        k1 = dot(u,p11-p00) / a;\n             if (max(k1,k0)<0.) { out0 = p00; out1 = k1>k0 ? p11 : p10;}\n        else if (min(k1,k0)>1.) { out0 = p01; out1 = k1>k0 ? p10 : p11;}\n        else { out0 = p00 + u * clamp(k1, 0., 1.);\n               out1 = out0 + (p10 - (p00 + k0*u)); \n        }\n        return;\n    } else {\n        float e = dot(v,w), d = dot(u,w); \n        k0 = b*e - c*d;\n        k1 = k0 > k ? (e+b)/c : k0 < 0. ? e/c : (a*e - b*d)/k;\n        k0 = k1 < 0. ? -d/a : k1 > 1. ? (b-d)/a : clamp(k0/k, 0., 1.);\n    }\n    out0 = p00 + u * clamp(k0, 0., 1.);\n    out1 = p10 + v * clamp(k1, 0., 1.);\n}\n\n//---------------------------------------------------------\n// Find the closest points between disks and segment\n// Seem quite good but not 100% ok \n//---------------------------------------------------------\nvoid closestDiskSegApprox(vec3 c0, vec3 n0, float r0, vec3 p0, vec3 p1, out vec3 out0, out vec3 out1) {             \n    // find closest segment / disk surface\n    closestSegmentPlane(p0, p1, c0, n0, out0, out1);\n    if (distance(out1,c0)<r0) {\n        return;\n    }\n    // find closest segment / disk contour\n    // The hard way: https://www.geometrictools.com/Documentation/DistanceToCircle3.pdf\n    // A disk / line: https://fr.mathworks.com/matlabcentral/fileexchange/59800-distance-of-a-circle-to-a-line-in-3d\n    \n    // The hacky/buggy way\n    vec3 cc1 = closestPtSeg(c0, p0, p1);\n    vec3 n1p = normalize(cc1 - c0);\n    n1p = normalize(projVecOnPlane(n1p, n0));\n    \n#ifdef DEBUG\n    pt2 = p0;\n    pt3 = cc1;     \n    pt5 = c0 + r0*n1p; \n    pt4 = c0 - r0*n1p;\n#endif\n    // find closest on caps \n    closestSegmentSegment(c0 - r0*n1p, c0 + r0*n1p, p0, p1, out0, out1);\n}\n\n\n//---------------------------------------------------------\n// Find the closest points between disks and segment\n//---------------------------------------------------------\nvoid closestDiskSegApprox1(vec3 cDisk, vec3 nDisk, float rDisk, vec3 p0, vec3 p1, out vec3 out0, out vec3 out1) {             \n    // project seg on DiskPlane\n    vec3 dp0 = projPtOnPlane(p0, c0, n0),\n         dp1 = projPtOnPlane(p1, c0, n0),\n         rd = normalize(dp1 - dp0);\n    // clamp segment on disk limits\n    float d1,d2;\n    if (cylIntersect(dp0, rd, cDisk, nDisk, rDisk, d1, d2)) {\n    #ifdef DEBUG\n        pt2 = dp0 + rd*d1;\n        pt3 = dp0 + rd*d2;\n    #endif\n        closestSegmentSegment(dp0 + rd*d1, dp0 + rd*d2, p0, p1, out0, out1);\n    } else {\n        rd = cross(nDisk, rd);        \n        out0 = cDisk + rDisk*rd;\n    #ifdef DEBUG\n        pt2 = cDisk;\n        pt3 = out0;\n    #endif\n        out1 = closestPtSeg(out0, p0, p1);\n    }\n}\n\n\n//---------------------------------------------------------\n// Find the closest points between two disks \n// Maybe some problems in particular cases\n//---------------------------------------------------------\nvoid closestDiskDiskApprox(\n        vec3 c0, vec3 n0, float r0,\n        vec3 c1, vec3 n1, float r1,\n        out vec3 out0, out vec3 out1) {             \n   \n    vec3 o00, o10, o01, o11;\n    // find the projection of center of disk in other disk plane \n    vec3 n0p = normalize(projVecOnPlane(c1-c0, n0)),\n         n1p = normalize(projVecOnPlane(c0-c1, n1));\n    // find closest en caps \n    closestSegmentSegment(c0, c0 + r0*n0p, c1, c1 + r1*n1p, out0, out1);\n    \n    // On recherche le point le plus proche dans le plan du disque 0\n    closestDiskPlane(c1,n1,r1, c0,n0, o01,o00);\n    \n    // On recherche le point le plus proche dans le plan du disque 1\n    closestDiskPlane(c0,n0,r0, c1,n1, o11,o10);\n\n    float best = distance(out0,out1);\n    if (distance(o00,c0) < r0 && distance(o00,o01)<best) {\n        out0 = o00;\n        out1 = o01;\n        \n    } if (distance(o10,c1) < r1 && distance(o10,o11)<best) {\n        out0 = o11;\n        out1 = o10;\n    } \n}\n\n\n/**********************************************************************/\n/*               COMPOSED SHAPES (WITHOUT TICKNESS)                   */\n/**********************************************************************/\n\nbool insidePolygon(in vec3 p, in vec3[POLY_SZ] v) {\n    const int num = v.length();\n    vec3 nor = cross(v[1]-v[0], v[0]-v[num-1]);\n    for(int i=ZERO, j=num-1; i<num; j=i, i++) {\n        vec3 e = v[i] - v[j], w = p - v[j];\n        if (dot(cross(e,nor),w)<0.) \n            return false;\n    }\n    return true;\n}\n\n\n// https://www.shadertoy.com/view/sdBGWK\nvec3 closestPtPoly(in vec3 p, in vec3[POLY_SZ] v) {\n    const int num = v.length();\n    vec3 nor = cross(v[1]-v[0], v[0]-v[num-1]);\n    for(int i=ZERO, j=num-1; i<num; j=i, i++) {\n        vec3 e = v[i] - v[j], w = p - v[j];\n        if (dot(cross(e,nor),w)<0.) \n            return v[j]+e*clamp(dot(w,e)/dot(e,e), 0.0, 1.0 );\n    }\n    // Project p on plane\n    return p - nor*dot(nor,p-v[0])/dot(nor,nor);\n}\n\nvoid closestPolySeg(in vec3[POLY_SZ] poly, vec3 p1Seg, vec3 p2Seg, out vec3 out0, out vec3 out1) {\n    const int num = poly.length();\n    vec3 o0, o1, nPoly = normalize(cross(poly[1]-poly[0], poly[0]-poly[num-1]));\n    float dmin = 1e5; \n    // Test intersect\n    vec3 rd = normalize(p2Seg - p1Seg);\n    vec3 pdk;\n    float a = dot(rd, nPoly);\n    float d = -(dot(p1Seg, nPoly)-dot(nPoly, poly[0]))/a;\n    if (d>0. && d<distance(p1Seg, p2Seg)) {\n        if (insidePolygon(p1Seg + rd * d, poly)) {\n            out1 = out0 = p1Seg + rd * d;\n            return;\n        }   \n    }\n    // Test segments\n    for(int i=ZERO, j=num-1; i<num; j=i, i++) {\n        closestSegmentSegment(poly[i], poly[j], p1Seg, p2Seg, o0, o1);\n        float d = distance(o0,o1);\n        if (d<dmin) {\n            out0 = o0;\n            out1 = o1;\n            dmin = d;\n        }\n    }\n    // Project sommets of line on plane and select the closest\n    vec3 p1OnPlane = projPtOnPlane(p1Seg, poly[0], nPoly);\n    vec3 p2OnPlane = projPtOnPlane(p2Seg, poly[0], nPoly);\n    if (distance(p1OnPlane,p1Seg) < distance(p2OnPlane,p2Seg)) {\n        if (distance(p1OnPlane,p1Seg)<dmin && insidePolygon(p1OnPlane,poly)) {\n            out0 = p1OnPlane;\n            out1 = p1Seg;\n            dmin = distance(out0, out1);\n        }\n    } else if (distance(p2OnPlane,p2Seg)<dmin && insidePolygon(p2OnPlane,poly)) {\n        out0 = p2OnPlane;\n        out1 = p2Seg;\n        dmin = distance(out0, out1);\n    }\n}\n\nvoid closestPolyPlane(in vec3[POLY_SZ] v, vec3 pPlane, vec3 nPlane, out vec3 out0, out vec3 out1) {\n    const int num = v.length();\n    vec3 o0, o1, nPoly = normalize(cross(v[1]-v[0], v[0]-v[num-1]));\n    float dmin = 1e5; \n    if (dot(nPoly,nPlane) == 0.) { // paralelle\n        out0 = v[0];\n        out1 = projPtOnPlane(v[0],pPlane, nPlane);\n    } else {\n        // Test segments\n        for(int i=ZERO, j=num-1; i<num; j=i, i++) {\n            closestSegmentPlane(v[i], v[j], pPlane, nPlane, o0, o1);\n            float d = distance(o0,o1);\n            if (d<dmin) {\n                out0 = o0;\n                out1 = o1;\n                dmin = d;\n            }\n        }\n    }\n}\n\n\nvoid closestPolyPoly(in vec3[POLY_SZ] poly, in vec3[POLY_SZ] poly2, out vec3 out0, out vec3 out1) {\n    const int num = poly.length();\n    vec3 o0, o1, nPoly = normalize(cross(poly[1]-poly[0], poly[0]-poly[num-1]));\n    float dmin = 1e5; \n\n    // Test segments\n    for(int i=ZERO, j=num-1; i<num; j=i, i++) {\n        closestPolySeg(poly2, poly[i], poly[j], o1, o0);\n        float d = distance(o0,o1);\n        if (d<dmin) {\n            out0 = o0;\n            out1 = o1;\n            dmin = d;\n        }\n    }\n    \n    // Test surface\n    closestPolyPlane(poly2, poly[0], nPoly, o1, o0);\n    if (distance(o0,o1)<dmin && insidePolygon(o0,poly)) {\n        out0 = o0;\n        out1 = o1;\n        dmin = distance(out0, out1);\n    }\n}\n\n\nbool insideQuad(in vec3 p, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    vec3 nor = cross(b-a, a-d);\n    if (dot(cross(a-d,nor),p-a)<0. || \n        dot(cross(b-a,nor),p-b)<0. ||\n        dot(cross(c-b,nor),p-c)<0. ||\n        dot(cross(d-c,nor),p-d)<0.) return false;\n    return true;\n}\n\n\nvec3 closestPtPolyH(in vec3 p, in vec3[POLY_SZ] v, float h) {\n    const int num = v.length();\n    vec3 nor = cross(v[1]-v[0], v[0]-v[num-1]);\n    vec3 r1,r2, nh = normalize(nor)*h;\n    for(int i=ZERO, j=num-1; i<num; j=i, i++) {\n        vec3 e = v[i] - v[j], w = p - v[j];\n        if (dot(cross(e,nor),w)<0.) {\n            r1 = v[j] + e*clamp(dot(w,e)/dot(e,e),    0., 1.);\n            float dmin = distance(r1,p);\n            r2 = v[j]+nh + e*clamp(dot(w-nh,e)/dot(e,e), 0., 1.);\n            if (distance(r2,p)<dmin) {\n                dmin = distance(r2,p);\n                r1 = r2;\n            }\n            // project p on side plane\n            vec3 n = cross(nor,e);\n            r2 = p - n*dot(n,p-v[j])/dot(n,n);\n            return dmin < distance(r2,p) ? r1 : r2;\n        }\n    }\n    \n    // Project p on planes\n    r1 = p - nor*dot(nor,p-v[0]   )/dot(nor,nor);\n    r2 = p - nor*dot(nor,p-v[0]-nh)/dot(nor,nor);\n    return distance(r1,p) < distance(r2,p) ? r1 : r2;\n}\n\n\n/**********************************************************************/\n/*                 GENERALISATION WITH THICKNESS                      *\n/**********************************************************************/\n\n\n//---------------------------------------------------------\n// Find the closest points between sphere and plane\n//---------------------------------------------------------\nbool closestSpherePlane(vec3 cSphere, float rSphere, vec3 pPlane, vec3 nPlane, out vec3 out0, out vec3 out1) {\n    out0 = cSphere; out1 = projPtOnPlane(cSphere, pPlane, nPlane);\n    return removeThickness(rSphere, 0., out0, out1);\n}\n\n//---------------------------------------------------------\n// Find the closest points between sphere and plane\n//---------------------------------------------------------\nbool closestSphereDisk(vec3 cSphere, float rSphere, vec3 cDisk, vec3 nDisk, float rDisk, float eDisk, out vec3 out0, out vec3 out1) {\n    out0 = cSphere; out1 = closestPtDisk(cSphere, cDisk, nDisk, rDisk);\n    return removeThickness(rSphere, eDisk, out0, out1);\n}\n\n//---------------------------------------------------------\n// Find the closest points between sphere and polygon\n//---------------------------------------------------------\nbool closestSpherePoly(vec3 cSphere, float rSphere, vec3 poly[POLY_SZ], float ePoly, out vec3 out0, out vec3 out1) {\n    out0 = cSphere; out1 = closestPtPoly(cSphere, poly);\n    return removeThickness(rSphere, ePoly, out0, out1);\n}\n\n//---------------------------------------------------------\n// Find the closest point on a capsule\n//---------------------------------------------------------\nbool closestPtCaps(vec3 pt, vec3 pLine1, vec3 pLine2, float ep, out vec3 out0, out vec3 out1) {\n    out0 = pt; out1 = closestPtSeg(pt, pLine1, pLine2);\n    return removeThickness(0., ep, out0, out1);\n}\n\n//---------------------------------------------------------\n// Find the closest points between sphere and capsule\n//---------------------------------------------------------\nbool closestSphereCaps(vec3 cSphere, float rSphere, vec3 pLine1, vec3 pLine2, float ep, out vec3 out0, out vec3 out1) {\n    out0 = cSphere; out1 = closestPtSeg(cSphere, pLine1, pLine2);\n    return removeThickness(rSphere, ep, out0, out1);\n}\n\n\n//---------------------------------------------------------\n// Find the closest points between sphere and capsule\n//---------------------------------------------------------\nbool closestSphereSphere(vec3 cSphere1, float rSphere1, vec3 cSphere2, float rSphere2, out vec3 out0, out vec3 out1) {\n    out0 = cSphere1; out1 = cSphere2;\n    return removeThickness(rSphere1, rSphere2, out0, out1);\n}\n\n//---------------------------------------------------------\n// Find the closest point on a capsule and a plane\n//--------------------------------------------------------\nbool closestCapsPlane(vec3 p1Line, vec3 p2Line, float ep, vec3 pPlane, vec3 nPlane, out vec3 out0, out vec3 out1) {\n    closestSegmentPlane(p1Line, p2Line, pPlane, nPlane, out0, out1);\n    return removeThickness(ep, 0., out0, out1);\n}\n\n//---------------------------------------------------------\n// Find the closest point on a polygone and a capsule\n//--------------------------------------------------------\nbool closestPolyCaps(vec3 poly[POLY_SZ], float epPoly, vec3 p1Line, vec3 p2Line, float ep, out vec3 out0, out vec3 out1) {\n    closestPolySeg(poly, p1Line, p2Line, out0, out1);\n    return removeThickness(epPoly, ep, out0, out1);\n}\n\n//---------------------------------------------------------\n// Find the closest point on a polygone and a plane\n//--------------------------------------------------------\nbool closestPolyPlane(vec3 poly[POLY_SZ], float epPoly, vec3 pPlane, vec3 nPlane, out vec3 out0, out vec3 out1) {\n    closestPolyPlane(poly, pPlane, nPlane, out0, out1);\n    return removeThickness(epPoly, 0., out0, out1);\n}\n\n//---------------------------------------------------------\n// Find the closest point on 2 polygones\n//--------------------------------------------------------\nbool closestPolyPoly(vec3 poly[POLY_SZ], float epPoly, vec3 poly2[POLY_SZ], float epPoly2, out vec3 out0, out vec3 out1) {\n    closestPolyPoly(poly, poly2, out0, out1);\n    return removeThickness(epPoly, epPoly2, out0, out1);\n}\n\n\n//---------------------------------------------------------\n// Find the closest points between a disk and a plane\n//---------------------------------------------------------\nbool closestDiskPlane(vec3 cDisk, vec3 nDisk, float rDisk, float eDisk, vec3 pPlane, vec3 nPlane, out vec3 out0, out vec3 out1) {\n     closestDiskPlane(cDisk,nDisk,rDisk, pPlane,nPlane, out0,out1);\n     return removeThickness(eDisk, 0., out0, out1);\n}\n\n//---------------------------------------------------------\n// Find the closest points between two caps\n//---------------------------------------------------------\nbool closestCapsCaps(vec3 p00, vec3 p01, float e0, vec3 p10, vec3 p11, float e1, out vec3 out0, out vec3 out1) {\n    closestSegmentSegment(p00, p01, p10, p11, out0, out1);\n    return removeThickness(e0, e1, out0, out1);\n}\n\n//---------------------------------------------------------\n// Find the closest points between disks and caps\n// Seem quite good but not 100% sure \n//---------------------------------------------------------\nbool closestDiskCapsApprox(vec3 c0, vec3 n0, float r0, float e0, vec3 p0, vec3 p1, float e1, out vec3 out0, out vec3 out1) {  \n     closestDiskSegApprox(c0, n0, r0, p0, p1, out0, out1);  \n     return removeThickness(e0, e1, out0, out1);\n}\n\n//---------------------------------------------------------\n// Find the closest points between 2 disks\n// Approximation \n//---------------------------------------------------------\nbool closestDiskDiskApprox(vec3 c0, vec3 n0, float r0, float e0, vec3 c1, vec3 n1, float r1, float e1, out vec3 out0, out vec3 out1) { \n     closestDiskDiskApprox(c0,  n0, r0,c1, n1, r1, out0,  out1);\n     return removeThickness(e0, e1, out0, out1);\n}\n\n\n\n\n\n\n\n// ---------------------------------------------------------------------\n#define ID_SHAPE_1 3.\n#define ID_SHAPE_2 5.\n#define ID_LINK    4.\n#define ID_GROUND  1.\n#define ID_DEBUG   2.\n\nvec2 map(in vec3 pos) {\n    vec2 res = vec2( 1e10, 0.0 );\n \n         if (gShape1 == DISK)   res = opU( res, vec2( sdCylinder( pos, c0, c0+.001*n0, r0  ) - ep0, ID_SHAPE_1 ) );\n    else if (gShape1 == CAPS)   res = opU( res, vec2( sdCapsule( pos, seg00, seg01, ep0  ), ID_SHAPE_1 ) );\n    else if (gShape1 == SPHERE) res = opU( res, vec2( length(pos-c0)-r0, ID_SHAPE_1 ) ); \n    else if (gShape1 == POLY)   res = opU( res, vec2( udPoly(pos, poly0)-ep0, ID_SHAPE_1 ) ); \n\n         if (gShape2 == DISK)   res = opU( res, vec2( sdCylinder( pos, c1, c1+.001*n1, r1  ) - ep1, ID_SHAPE_2 ) );\n    else if (gShape2 == CAPS)   res = opU( res, vec2( sdCapsule( pos, seg10, seg11, ep1  ), ID_SHAPE_2 ) );\n    else if (gShape2 == SPHERE) res = opU( res, vec2( length(pos-c1)-r1, ID_SHAPE_2 ) );\n    else if (gShape2 == POLY)   res = opU( res, vec2( udPoly(pos, poly1)-ep1, ID_SHAPE_2 ) );\n       \n    // Link\n    res = opU( res, vec2( length( pos-pt0)- 0.04 , ID_LINK ) );\n    res = opU( res, vec2( length( pos-pt1)- 0.04, ID_LINK ) );\n    res = opU( res, vec2( sdCapsule( pos,pt0, pt1, 0.01  ), ID_LINK ) );\n    \n#ifdef DEBUG    \n\n        res = opU( res, vec2( sdSphere( pos-pt3, 0.03 ), ID_DEBUG ) );\n        res = opU( res, vec2( sdCapsule( pos, pt2, pt3, 0.03  ), ID_DEBUG ) );\n        res = opU( res, vec2( sdCapsule( pos, pt4, pt5, 0.03  ), ID_DEBUG ) );\n    \n    \n#endif\n\n    return res;\n}\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = .1;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (-1.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n\n    glow = 999.;\n    float t = tmin;\n    for( int i=0; i<170 && t<tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n        if (h.x<glow) glow = h.x;\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\n\n#define ID_SHAPE_1 3.\n#define ID_SHAPE_2 5.\n#define ID_LINK    4.\n#define ID_GROUND  1.\n#define ID_DEBUG   2.\n\n\nvec3 getColor(float m, vec3 pos, vec3 nor) {\n#ifdef SHOW_DISTANCE\n    float id = m;\n    float d;\n    vec3 out0;\n    \n    if (inside) return vec3(.2,.2,.4);\n    if (id != ID_SHAPE_1 && id != ID_SHAPE_2) {\n        if (id == ID_LINK) {\n            return 2.*vec3(.01,.01,.8);\n        }\n        return 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );  \n        \n    } else if (id == ID_SHAPE_1) {\n        if (gShape2 == DISK) d = sdCylinder(pos, c1, c1+.001*n1, r1) - ep1;\n        else if (gShape2 == CAPS) d = sdCapsule(pos, seg10, seg11, ep1);\n        else if (gShape2 == SPHERE) d = length(pos-c1)-r1;\n        else if (gShape2 == POLY) d = udPoly(pos, poly1)-ep1;\n        else d = pos.y+1.;\n    } else {\n        if (gShape1 == DISK) d = sdCylinder(pos, c0, c0+.001*n0, r0) - ep0;\n        else if (gShape1 == CAPS) d = sdCapsule(pos, seg00, seg01, ep0);\n        else if (gShape1 == SPHERE) d = length(pos-c0)-r0;\n        else if (gShape1 == POLY) d = udPoly(pos, poly0)-ep0; \n        else d = pos.y+1.;\n    }\n    \n    d -= distance(pt0, pt1);\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n    col = mix(vec3(1,0,0),col, smoothstep(0.,.01,d));\n    return col;\n#else\n    return 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n#endif    \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy ) { \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = getColor(m, pos, nor);\n        float ks = 1.0;\n        \n        if( m < ID_GROUND+.5 )\n        {\n            \n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n            if (gShape2 == PLANE) {\n                col = mix(col, getColor(ID_SHAPE_2, pos, nor), .1);\n            }\n            ks = 0.4;\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    gShape1 = 1+int(iTime/40.)%4;\n    gShape2 = 1+(gShape1+int(iTime/10.))%5;\n   \n#ifdef SHAPE_1\n    gShape1 = SHAPE_1;\n#endif\n#ifdef SHAPE_2\n    gShape2 = SHAPE_2;\n#endif\n\n    if (gShape2 == PLANE && gShape1 == PLANE) {\n        gShape2 = CAPS;\n    }\n    \n    glow = 999.;\n    // random postions\n    \n    seg00 = vec3(.7*cos( .2*iTime + vec2(0.0,1.00)+.5) + vec2(.7,0.),cos(iTime));\n\tseg01 = vec3(.7*cos( iTime + vec2(0.0,3.00)) + vec2(.7,.5),0.);\n    ep0 = .01+.3*(0.5+0.5*cos(iTime*.3));\n    seg10 = vec3(.5*cos(-.7* iTime + vec2(0.2,.10)) + vec2(.3,.0),1.);\n\tseg11 = vec3(.5*cos( iTime + vec2(0.0,3.00)) + vec2(.3,.3),1.);\n    ep1 = .1+.1*(0.5+0.5*cos(iTime*1.1+1.0));\n\n    vec3 n2 = vec3(1,0,0);\n    n2.xy *= rot(.2*iTime);\n    n2.xz *= rot(.1107*iTime);\n    \n\tseg11 = vec3(.5*cos( iTime + vec2(0.0,3.00)) + vec2(.3,.3),1.);\n    ep1 = .1+.1*(0.5+0.5*cos(iTime*1.1+1.0));\n\n        // random disks\n    r0= .4+.3*(0.5+0.5*cos(iTime*.21));\n    r1= .4+.3*(0.5+0.5*cos(iTime*.13));\n     \n    c0 = seg00;\n    c1 = seg10;\n    n0 = normalize(seg00-seg01);\n    n1 = normalize(seg10-seg11);\n\n\n    if (gShape1 == SPHERE) r0 *=.35;\n    if (gShape2 == SPHERE) r1 *=.75;\n    if (gShape1 == DISK) ep0 *=.25;\n    if (gShape2 == DISK) ep1 *=.25;\n    if (gShape1 == POLY) ep0 *=.5; //r0 = .2+.5*r0;}\n    if (gShape2 == POLY) ep1 *=.5; //r1 = .2+.5*r1;}\n    \n    \n    for (int i=0; i<POLY_SZ; i++) {\n        vec3 n = vec3(0,1,0);\n        n.yz *= rot(float(i)*6.28/float(POLY_SZ));\n        vec3 v = (.2+r0)*n;\n        v.yx *= rot(.5*iTime);\n        poly0[i] = c0 + v+vec3(0,.15,0);;\n        \n    }\n    \n    for (int i=0; i<POLY_SZ; i++) {\n        //vec3 n = normalize(n2);\n        vec3 n = vec3(0,1,0);\n        n.yz *= rot(.5+float(i)*6.28/float(POLY_SZ));\n        vec3 v = (.2+r0)*n;\n        v.yx *= rot(.21*iTime);\n        poly1[i] = c1 + v+vec3(0,.15,0);\n    }\n    \n    \n    if (gShape1 > 5) {\n        gShape1 -= 5;\n        ep0 = .01;\n    }\n    if (gShape2 > 5) {\n        gShape2 -= 5;\n        ep1 = .01;\n    }\n    \n#ifdef TEST_PARALLEL   \n    seg11 = seg10 + length(seg11-seg10)*n0;\n    seg10 -= 1.*n0;\n    seg11 -= 1.*n0;\n#endif\n\n    if (gShape1 == DISK && gShape2 == DISK) {        \n        inside = closestDiskDiskApprox(c0, n0, r0, ep0, c1, n1, r1, ep1, pt0, pt1);        \n    } else if (gShape1 == CAPS && gShape2 == CAPS) {\n        inside = closestCapsCaps(seg00, seg01, ep0, seg10, seg11, ep1, pt0, pt1);\n    } else if (gShape1 == DISK && gShape2 == CAPS) {\n        inside = closestDiskCapsApprox(c0, n0, r0, ep0, seg10, seg11, ep1, pt0, pt1);\n    } else if (gShape1 == CAPS && gShape2 == DISK) {\n        inside = closestDiskCapsApprox(c1, n1, r1, ep1, seg00, seg01, ep0, pt1, pt0);\n    } else if (gShape1 == CAPS && gShape2 == PLANE) {\n        inside = closestCapsPlane(seg00, seg01, ep0, vec3(0,-1,0), vec3(0,1,0), pt0, pt1);\n    } else if (gShape1 == PLANE && gShape2 == CAPS) {\n        inside = closestCapsPlane(seg10, seg11, ep1, vec3(0,-1,0), vec3(0,1,0), pt0, pt1);\n    } else if (gShape1 == SPHERE && gShape2 == SPHERE) {\n        inside = closestSphereSphere(c0, r0, c1, r1, pt0, pt1);\n    } else if (gShape1 == SPHERE && gShape2 == PLANE) {\n        inside = closestSpherePlane(c0, r0, vec3(0,-1,0), vec3(0,1,0), pt0, pt1);\n    } else if (gShape1 == PLANE && gShape2 == SPHERE) {\n        inside = closestSpherePlane(c1, r1, vec3(0,-1,0), vec3(0,1,0), pt0, pt1);\n    } else if (gShape1 == SPHERE && gShape2 == CAPS) {\n        inside = closestSphereCaps(c0, r0, seg10, seg11, ep1, pt0, pt1);\n    } else if (gShape1 == CAPS && gShape2 == SPHERE) {\n        inside = closestSphereCaps(c1, r1, seg00, seg01, ep0, pt0, pt1);\n    } else if (gShape1 == SPHERE && gShape2 == DISK) {\n        inside = closestSphereDisk(c0, r0, c1, n1, r1, ep1, pt0, pt1);\n    } else if (gShape1 == DISK && gShape2 == SPHERE) {\n        inside = closestSphereDisk(c1, r1, c0, n0, r0, ep0, pt0, pt1);\n    } else if (gShape1 == PLANE && gShape2 == DISK) {\n        inside = closestDiskPlane(c1, n1, r1, ep1, vec3(0,-1,0), vec3(0,1,0), pt0, pt1);\n    } else if (gShape1 == DISK && gShape2 == PLANE) {\n        inside = closestDiskPlane(c0, n0, r0, ep0, vec3(0,-1,0), vec3(0,1,0), pt0, pt1);\n    } else if (gShape1 == POLY && gShape2 == SPHERE) {\n        inside = closestSpherePoly(c1, r1, poly0, ep0, pt0, pt1);\n    } else if (gShape1 == SPHERE && gShape2 == POLY) {\n        inside = closestSpherePoly(c0, r0, poly1, ep1, pt0, pt1);\n    } else if (gShape1 == CAPS && gShape2 == POLY) {\n        inside = closestPolyCaps(poly1, ep1, seg00, seg01, ep0, pt0, pt1);\n    } else if (gShape1 == POLY && gShape2 == CAPS) {\n        inside = closestPolyCaps(poly0, ep0, seg10, seg11, ep1, pt0, pt1);\n    } else if (gShape1 == PLANE && gShape2 == POLY) {\n        inside = closestPolyPlane(poly1, ep1, vec3(0,-1,0), vec3(0,1,0), pt0, pt1);\n    } else if (gShape1 == POLY && gShape2 == PLANE) {\n        inside = closestPolyPlane(poly0, ep0, vec3(0,-1,0), vec3(0,1,0), pt0, pt1);\n    } else if (gShape1 == POLY && gShape2 == POLY) {\n        inside = closestPolyPoly(poly1, ep1, poly0, ep0, pt0, pt1);\n    } else if (gShape1 == POLY && gShape2 == POLY) {\n        inside = closestPolyPoly(poly0, ep0, poly1, ep1, pt0, pt1);\n    }\n \n    \n// -- Classical ray marching stuff -------------------------------------\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0.5, -0.5, -0.6 );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 1.3 + 2.0*mo.y, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // focal length\n        const float fl = 2.5;\n        \n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,fl) );\n        vec3 rdy = ca * normalize( vec3(py,fl) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        if (inside) {\n            float BloomFalloff = 3000.; //mix(1000.,5000., Anim);\n            col += 4.*vec3(.1,.3,1)*col/(1.+glow*glow*glow*BloomFalloff);\n        }\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define POLY_SZ 5\n\n#define ZERO (min(iFrame,0))\n\n#define AA 1   // make this 2 or 3 for antialiasing\n\nmat2 rot(float a) {\n   return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\n/*\n// return a point and the vector of the intersection line\nbool planePlaneIntersection(const vec3 n1, float w1, const vec3 n2, float w2, out vec3 p, out vec3 n) {\n    float d = n1.x * n2.y - n1.y * n2.x;\n    if (abs(d) > 1e-5)\n    {\n        // this case should be handled by switching axes...\n         p = vec3(w2*n1.y - w1*n2.y, w1*n2.x - w2*n1.x, 0.)/d;\n    } else {\n        d = n1.x * n2.z - n1.z * n2.x;\n        p = vec3(w2*n1.z - w1*n2.z, 0., w1*n2.x - w2*n1.x)/d;\n    }\n    n = cross(n1, n2);\n    if(length(n) == 0.0f) {\n        return false;\n    }\n    n = normalize(n);\n    return true;\n}\n*/\n// https://iquilezles.org/articles/intersectors\nbool iPlane( in vec3 ro, in vec3 rd,\n              in vec3 planeNormal, in float planeDist, out vec3 p0) {\n    float a = dot(rd, planeNormal);\n    float d = -(dot(ro, planeNormal)+planeDist)/a;\n    p0 = ro+d*rd;\n    if (a > 0.) {\n        return false;\n    } else {\n    \treturn true;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\nbool cylIntersect(in vec3 ro, in vec3 rd, in vec3 cb, in vec3 cn, float cr, out float d1, out float d2) {\n    vec3  oc = ro - cb;\n    float cnrd = dot(cn,rd),\n          cnoc = dot(cn,oc),\n          a = 1. - cnrd*cnrd,\n          b = dot(oc, rd) - cnoc*cnrd,\n          c = dot(oc, oc) - cnoc*cnoc - cr*cr,\n          h = b*b - a*c;\n    if (h<0.) return false; //no intersection\n    h = sqrt(h);\n    d1 = (-b-h)/a;\n    d2 = (-b+h)/a;\n    return true;\n}\n\n\n//------------------------------------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n//float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n/*\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctogonPrism( in vec3 p, in float r, float h )\n{\n  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2 \n                       0.3826834323,   // sqrt(2-sqrt(2))/2\n                       0.4142135623 ); // sqrt(2)-1 \n  // reflections\n  p = abs(p);\n  p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n  p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n  // polygon side\n  p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n*/\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n/*\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n*/\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n/*\n// vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n\nfloat udQuad(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d) {\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 dc = d - c; vec3 pc = p - c;\n  vec3 ad = a - d; vec3 pd = p - d;\n  vec3 nor = cross( ba, ad );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n*/\n\nfloat udPoly(vec3 p, vec3 v[POLY_SZ]) {\n    const int num = v.length();\n    vec3 nor = cross(v[1]-v[0],v[0]-v[num-1]);\n    float s = 0., d = 1e3;\n    for(int i=0, j=num-1; i<num; j=i, i++) {\n        vec3 ba = v[i] - v[j], \n             pa =    p - v[j];\n        s += sign(dot(cross(ba,nor),pa));\n        d = min(d, dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.,1.)-pa));\n    }\n    vec3 paa = p-v[0];\n    return sqrt(s < float(num-1) ? d : dot(nor,paa)*dot(nor,paa)/dot2(nor));\n}\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n","name":"Common","description":"","type":"common"}]}