{"ver":"0.1","info":{"id":"WsSBWw","date":"1590109136","viewed":98,"name":"partition noise","username":"TheNosiriN","description":"partition noise","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define _PerlinPrecision 0.9\n#define _PerlinOctaves 2.0\n#define _PerlinSeed 1.0\n#define RES 200.0\n\nconst float sideWalkCol = 0.1;\n\nvec2 hash(vec2 v) \n{\n\tvec2 n;\n\tn.x = fract(cos(v.y - v.x * 841.0508) * (v.y + v.x) * 3456.7821);\n\tn.y = fract(sin(v.x + v.y * 804.2048) * (v.x - v.y) * 5349.2627);\n\treturn n;\n}\n\n\n//noise\nfloat rnd(vec2 xy)\n{\n    return fract(sin(dot(xy, vec2(12.9898-_PerlinSeed, 78.233+_PerlinSeed)))* (43758.5453+_PerlinSeed));\n}\nfloat inter(float a, float b, float x)\n{\n    //return a*(1.0-x) + b*x; // Linear interpolation\n\n    float f = (1.0 - cos(x * 3.1415927)) * 0.5; // Cosine interpolation\n    return a*(1.0-f) + b*f;\n}\nfloat perlin(vec2 uv)\n{\n    float a,b,c,d, coef1,coef2, t, p;\n\n    t = _PerlinPrecision;\t\t\t\t\t// Precision\n    p = 0.0;\t\t\t\n\n    for(float i=0.0; i<_PerlinOctaves; i++)\n    {\n        a = rnd(vec2(floor(t*uv.x)/t, floor(t*uv.y)/t));\t//\ta---b\n        b = rnd(vec2(ceil(t*uv.x)/t, floor(t*uv.y)/t));\t\t//\t|   |\n        c = rnd(vec2(floor(t*uv.x)/t, ceil(t*uv.y)/t));\t\t//\tc---d\n        d = rnd(vec2(ceil(t*uv.x)/t, ceil(t*uv.y)/t));\n\n        if((ceil(t*uv.x)/t) == 1.0)\n        {\n            b = rnd(vec2(0.0, floor(t*uv.y)/t));\n            d = rnd(vec2(0.0, ceil(t*uv.y)/t));\n        }\n\n        coef1 = fract(t*uv.x);\n        coef2 = fract(t*uv.y);\n        p += inter(inter(a,b,coef1), inter(c,d,coef1), coef2) * (1.0/pow(2.0,(i+0.6)));\n        t *= 2.0;\n    }\n    return p;\n}\n\n\n\n\nfloat partition_noise(vec2 p) \n{\n\tvec2 id;\n\t\n\tid = floor(floor(p)-.5);\n\t\n\tp *= floor(hash(id) * 2.)+1.;\n\tid = floor(p);\n\t\n\tp.yx *= floor(hash(id) * 3.)-4.0;\n\tid -= floor(p);\n\n\tp *= floor(hash(id) * 2.)+1.;\n\tid = floor(p);\n\t\n    p -= id;\n\n\tvec2 u = abs(p - .5) * 3. ;\n\n\treturn 1.0-max(u.x, u.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv\t= fragCoord/RES;\n\t\n\tfloat result = partition_noise(uv);\n    result = smoothstep(0.0, 0.6, result);\n    if (result > 0.5){\n     \tresult = 1.0;\n    }else{\n     \tif (result < 0.1){\n        \tresult = 0.0;\n        }else{\n         \tresult = sideWalkCol;   \n        }\n    }\n    \n    \n    float noise = perlin(floor( fragCoord/(RES / 10.0) ));\n    \n    float col = result;\n    if (col == 1.0){\n        col = noise;\n    }\n\t\n\t\n\tfragColor = vec4(vec3(col), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}