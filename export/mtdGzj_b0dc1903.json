{"ver":"0.1","info":{"id":"mtdGzj","date":"1682770046","viewed":69,"name":"SkyColorSpinner","username":"Eddy","description":"2023/4/29 SESSIONS GLSL Compo ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","fbm","sky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi acos(-1.0)\n#define twoPi acos(-1.0) * 2.0\n#define COLOR_N vec3(0.15, 0.34, 0.6)\n\nvec2 mainPoint;\nfloat voronoiStrength = 0.022;\nfloat spinnerAt = 0.0;\n\nmat2 rotate(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 random2d2d(vec2 p){\n    return fract(sin(vec2(dot(p.xy,vec2(12.532,95.235)), dot(p.xy,vec2(42.532,65.235))))*24627.1245);\n}\n\nfloat random1d2d(vec2 p){\n    return fract(sin(dot(p.xy, vec2(12.532, 95.235))) * 24627.1245);\n}\n\nfloat random(vec3 v) { \n\treturn fract(sin(dot(v, vec3(12.9898, 78.233, 19.8321))) * 43758.5453);\n}\n\nfloat valueNoise(vec3 v) {\n\tvec3 i = floor(v);\n\tvec3 f = smoothstep(0.0, 1.0, fract(v));\n\treturn  mix(\n\t\tmix(\n\t\t\tmix(random(i), random(i + vec3(1.0, 0.0, 0.0)), f.x),\n\t\t\tmix(random(i + vec3(0.0, 1.0, 0.0)), random(i + vec3(1.0, 1.0, 0.0)), f.x),\n\t\t\tf.y\n\t\t),\n\t\tmix(\n\t\t\tmix(random(i + vec3(0.0, 0.0, 1.0)), random(i + vec3(1.0, 0.0, 1.0)), f.x),\n\t\t\tmix(random(i + vec3(0.0, 1.0, 1.0)), random(i + vec3(1.0, 1.0, 1.0)), f.x),\n\t\t\tf.y\n\t\t),\n\t\tf.z\n\t);\n}\n\nfloat fbm(vec3 v) {\n\tfloat n = 0.0;\n\tfloat a = 0.5;\n\tfor (int i = 0; i < 5; i++) {\n\t\tn += a * valueNoise(v);\n\t\tv *= 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn n;\n}\n\nfloat sdPlane(vec3 p, vec4 n) \n{\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat dPlaneBottom(vec3 p) \n{\n    return sdPlane(p, vec4(0.0, 1.0, 0.0, 1.0)) * 0.8 + sin(p.z*4.0 + iTime*2.0)*0.05;\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCappedCylinder(vec3 p, float h, float r){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(vec3 p, vec2 c, float h){\n    vec2 q = h * vec2(c.x/c.y, -1.0);\n    \n    vec2 w = vec2(length(p.xz), p.y);\n    vec2 a = w - q * clamp(dot(w,q)/dot(q,q), 0.0, 1.0);\n    vec2 b = w - q * vec2(clamp(w.x/q.x, 0.0, 1.0), 1.0);\n    float k = sign(q.y);\n    float d = min(dot(a, a), dot(b, b));\n    float s = max(k*(w.x*q.y - q.x*w.y), k*(w.y-q.y));\n    return sqrt(d) * sign(s);\n}\n\nfloat sdSpinner(vec3 p){\n    float c = 0.0;\n    vec3 p1 = p;\n    p1.xy *= rotate(pi);\n    c += sdCone(p1 - vec3(0.0, 0.5722, 0.0), vec2(1.122, 0.82), 0.472);\n\n    vec3 p2 = p;\n    float cyl = sdCappedCylinder(p2, 0.12, 0.622);\n    c = min(c, cyl);\n\n    vec3 p3 = p;\n    float axis = sdCappedCylinder(p3 - vec3(0.0, -0.1, 0.0), 0.62, 0.032);\n    c = min(c, axis);\n\n    return c;\n}\n\nfloat dSpinner(vec3 p){\n    // p *= 1.2;\n    p  -= vec3(0.0, 0.0, 2.0);\n    p.y += 0.36;\n    p.xz *= rotate(iTime);\n    p.xy *= rotate(0.2);\n    return sdSpinner(p);\n}\n\nfloat smoothMin(float a, float b, float k){\n    float h = clamp(0.5 + 0.5 * (b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat distanceFunction(vec3 p)\n{\n    vec3 p1 = p;\n    float d = 0.0;\n    d += dSpinner(p1);\n    spinnerAt += 0.4/(0.4+abs(d));\n\n    vec3 p2 = p;\n    d = smoothMin(d, dPlaneBottom(p2), 0.01);\n\n    return d;\n}\n\nvec3 getNormal(vec3 p){\n    vec2 err = vec2(0.01, 0.0);\n    return normalize(vec3(\n        distanceFunction(p + err.xyy) - distanceFunction(p - err.xyy),\n        distanceFunction(p + err.yxy) - distanceFunction(p - err.yxy),\n        distanceFunction(p + err.yyx) - distanceFunction(p - err.yyx)\n    ));\n}\n\nfloat starOrb(vec2 uv, vec2 p, float flare){\n    float c = 0.0;\n    uv -= p;\n    float d = length(uv);\n    c += 0.2/d;\n\n    float ray = max(0.0, 1.0 - abs(uv.x*uv.y*200.0));\n    c += ray*flare;\n    uv *= rotate(pi/4.0);\n    ray = max(0.0, 1.0 - abs(uv.x*uv.y*500.0));\n    c += ray*0.2*flare;\n\n    c *= smoothstep(0.4, 0.2, d);\n\n    return c;\n}\n\nvec3 latticeStarField(vec2 uv, float s, vec2 subPos){\n    vec3 color = vec3(0.0);\n\n    uv *= s;\n    uv += subPos;\n\n    vec2 fPos = fract(uv) - 0.5;\n    vec2 iPos = floor(uv);\n\n    for(float y = -1.0; y <= 1.0; y+=1.0){\n        for(float x = -1.0; x <= 1.0; x+=1.0){\n            vec2 offset = vec2(x, y);\n            float n = random1d2d(iPos+offset);\n            float s = fract(n*4052.22);\n            float star = starOrb(fPos-offset, vec2(n, fract(n*34.24)), smoothstep(0.1, 0.02, s)); \n            color += pow(star * s, 2.0);\n        }\n    }\n    \n    return color;\n}\n\nvec3 skyTexture(vec2 uv, float size, vec3 baseColor, float scrollSpeed, float timeSeed){\n    vec2 uv2 = uv * size;\n    vec3 col = vec3(0.0);\n\n    vec3 noiseCol = pow(vec3(fbm(vec3(uv2 + vec2(0.0, iTime*(scrollSpeed + 0.1) + timeSeed), 122.2))), vec3(2.0));\n    noiseCol += pow(vec3(fbm(vec3(uv2 + vec2(0.0, iTime*(scrollSpeed + 0.2) + timeSeed), 422.2))), vec3(3.2));\n    noiseCol += pow(vec3(fbm(vec3(uv2 + vec2(0.0, iTime*(scrollSpeed + 0.3) + timeSeed), 522.2))), vec3(4.0));\n    noiseCol += pow(vec3(fbm(vec3(uv2 + vec2(0.0, iTime*(scrollSpeed + 0.4) + timeSeed), 622.2))), vec3(7.0));\n    noiseCol += pow(vec3(fbm(vec3(uv2 + vec2(0.0, iTime*(scrollSpeed + 0.5) + timeSeed), 722.2))), vec3(9.0));\n\n    col += mix(baseColor, vec3(1.0), pow(noiseCol, vec3(3.0)));\n\n    return col;\n}\n\nvec3 voronoi(vec2 uv, float s)\n{   \n    vec2 uv2 = uv * s;\n\n    vec2 iPos= floor(uv2);\n    vec2 fPos = fract(uv2);\n\n    vec3 returnParam = vec3(0.0);\n    float dist = 999.0;\n    vec2 point = vec2(8.0);\n    vec2 offset = vec2(8.0);\n    vec2 diff = vec2(8.0);\n    for(int y = -1; y <= 1; y++){\n        for(int x = -1 ; x <= 1; x++){\n            vec2 o = vec2(float(x), float(y));\n            vec2 p = random2d2d(iPos + o);\n\n            p = 0.5 + 0.5 * sin(iTime*0.2 + twoPi * p);\n\n            vec2 di = o + p - fPos;\n            float d = dot(di, di);\n\n            //    edge > x\n            // if(dist > d){\n            //     returnDist = d;\n            //     dist = returnDist;\n            // }\n            // dist = min(dist, d);\n            point = mix(point, p, (1.0 - step(dist, d)));\n            offset = mix(offset, o, (1.0 - step(dist, d)));\n            diff = mix(diff, di, (1.0 - step(dist, d)));\n            dist = mix(dist, d, (1.0 - step(dist, d)));\n        }\n    }\n    \n    // https://thebookofshaders.com/edit.php#12/2d-voronoi.frag\n    dist = 999.0;\n    for(int y = -2; y <= 2; y++){\n        for(int x = -2 ; x <= 2; x++){\n            vec2 o = offset + vec2(float(x), float(y));\n            vec2 p = random2d2d(iPos + o);\n\n            p = 0.5 + 0.5 * sin(iTime*0.2 + twoPi * p);\n\n            vec2 di = o + p - fPos;\n\n            dist = mix(dist, min(dist, dot(0.5*(diff+di), normalize(di-diff))), (1.0 - step(dot(diff-di, diff-di), 0.0001)));\n        }\n    }\n\n    mainPoint = point;\n    returnParam = vec3(dist, diff);\n\n    return returnParam;\n}\n\nfloat easeInOutExpo(float t)\n{\n    if (t == 0.0 || t == 1.0) {\n        return t;\n    }\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * pow(2.0, 10.0 * (t - 1.0));\n    } else {\n        return 0.5 * (-pow(2.0, -10.0 * (t - 1.0)) + 2.0);\n    }\n}\n\nfloat linearStep(float start, float end, float t)\n{\n    return clamp((t - start) / (end - start), 0.0, 1.0);\n}\n\nvec3 background(vec3 rayDir){\n    float k = rayDir.y * 0.5 + 0.5;\n    vec3 color = vec3(0.0);\n    for(float i = 0.0; i <= 1.0; i+=1.0/5.0){\n        float depth = fract(iTime*0.2 + i);\n        float scale = mix(3.0, 0.1, depth);\n        float fade = depth*smoothstep(10.0, 0.001, depth);\n        color.r += latticeStarField(rayDir.xy*rotate(i*234.25), scale, vec2(i*222.87)).r*(fade*(sin(i*200.0+iTime*4.0) * 0.1 + 0.1));\n\n        depth = fract(iTime*0.2 + i + 0.01);\n        scale = mix(3.0, 0.1, depth);\n        fade = depth*smoothstep(10.0, 0.001, depth);\n        color.g += latticeStarField(rayDir.xy*rotate(i*234.25), scale, vec2(i*222.87)).g*(fade*(sin(i*200.0+iTime*4.0) * 0.1 + 0.1));\n\n        depth = fract(iTime*0.2 + i - 0.01);\n        scale = mix(3.0, 0.1, depth);\n        fade = depth*smoothstep(10.0, 0.001, depth);\n        color.b += latticeStarField(rayDir.xy*rotate(i*234.25), scale, vec2(i*222.87)).b*(fade*(sin(i*200.0+iTime*4.0) * 0.1 + 0.1));\n    }\n    return mix(vec3(1.0), color, k);\n}\n\nvec3 renderingFunc(vec2 uv){\n    vec3 color = vec3(0.0);\n    vec3 camPos = vec3(0.0, 0.5, -2.5);\n    vec3 objectPos = vec3(0.0, 0.0, 0.0);\n    vec3 forward = normalize(objectPos - camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    float fov = 0.0;\n    float it = iTime * 0.5;\n    float fTime = mod(it, 7.5);\n    float t1 = linearStep(0.5, 1.0, fTime);\n    float t2 = linearStep(3.0, 3.5, fTime);\n    float t3 = linearStep(5.5, 6.0, fTime);\n    fov = mix(1.0, 2.0, easeInOutExpo(t1));\n    fov = mix(fov, 0.5, easeInOutExpo(t2));\n    fov = mix(fov, 1.0, easeInOutExpo(t3));\n    vec3 rayDir = normalize(uv.x * right + uv.y * up + fov * forward);\n\n    float d = 0.0;\n    float df = 0.0;\n    vec3 p = vec3(0.0);\n    bool isHit = false;\n    for(int i = 0; i < 300; i++){\n        p = camPos + rayDir * d;\n        df = distanceFunction(p);\n        if(df <= 0.001){\n            isHit = true;\n            break;\n        }\n        if(df > 100.0){\n            break;\n        }\n        d += df;\n    }\n\n    if(isHit){\n        if(dPlaneBottom(p) <= 0.001){\n            vec2 mappingUv = p.xz;\n            float voro = voronoiStrength/voronoi(mappingUv + vec2(iTime*0.01, 0.0), 2.0).x;\n            float stepVoro = step(0.01, voro);\n            vec3 skyColor = skyTexture(mappingUv + voro*0.5, 2.0, mix(COLOR_N, vec3(1.0), smoothstep(0.0, 102.0, d)), 1.0, 2.0);\n            color += skyColor;\n            color += voro*0.1;\n        }\n\n        if(dSpinner(p) <= 0.001){\n            vec3 skyColor = skyTexture(rayDir.xy, 9.0, mix(COLOR_N, vec3(1.0), smoothstep(0.0, 32.0, d)), 0.2, 2.0);\n            color = skyColor;\n        }\n\n    }else{\n        vec3 skyColor = skyTexture(rayDir.yx, 20.0, COLOR_N, 0.1, 2.0);\n        color +=  skyColor;\n    }\n\n    color += pow(background(rayDir), vec3(12.0))*smoothstep(0.0, 32.0, d);\n    color += pow(spinnerAt * 0.05, 8.0);\n    color = pow(color, vec3(0.4545));\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv * 2.0;\n\n    // Time varying pixel color\n    vec3 color = renderingFunc(uv);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}