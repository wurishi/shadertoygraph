{"ver":"0.1","info":{"id":"MttcRr","date":"1531377980","viewed":166,"name":"Ray marching practice 6","username":"lnae","description":"trying some shapes and shadows","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 64.\n#define EPS 0.0001\n#define EPSN 0.001\n#define PI 3.14159\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat distSphere(vec3 p, float r){\n\treturn length(p) - r;\n}\n\nvec2 repeat(vec2 p, float t){\n\tt = 2. * PI / t;\n    float angle = mod(atan(p.y, p.x), t) - 0.5 * t;\n    return length(p.xy) * vec2(cos(angle), sin(angle));\n}\n\n\nfloat distScene(vec3 pos){\n\t\n    pos.yz = rot(0.45) * pos.yz;\n    pos.y += 0.1;\n    \n    //floor\n    vec3 p = pos - vec3(0., -1.5, 0.);\n    float r = length(p.xz);\n    float dist = distSphere(p, 1.5) + 0.003 * (sin(150. * r - iTime));\n    \n    \n    //floating things\n    float time = 2. * iTime;\n    float tr = 0.15 * (0.5 + 0.5 * sin(time + 2. * PI / 3.));\n    p = pos - vec3(-0.25, tr + 0.1, 0.);\n    p.xz = rot(iTime) * p.xz;\n    p.xz = repeat(p.xz, 12.);\n    \n    float dist1 = p.y - 0.095;\n    dist1 = max(dist1, length(p.xy) - 0.1);\n    dist = min(dist, dist1);\n    \n    tr = 0.1 * (0.5 + 0.5 * sin(time));\n    p = pos - vec3(0., tr + 0.1, 0.);\n    p.xz = rot(iTime) * p.xz;\n    p.xz = repeat(p.xz, 12.);\n    p.xy = repeat(p.xy, 14.);\n    dist1 = length(p.yz) - 0.01;\n    dist1 = max(dist1, distSphere(p, 0.1));\n    dist = min(dist, dist1);\n    \n    tr = 0.1 * (0.5 + 0.5 * sin(time - 2. * PI / 3.));\n    p = pos - vec3(0.25, tr + 0.1, 0.);\n    p.xz = rot(iTime) * p.xz;\n    p.xy = repeat(p.xy, 12.);\n    dist1 = length(p.yz) - 0.02 + 0.05 * abs((fract(8. * p.x) - 0.5));\n    dist1 = max(dist1, distSphere(p, 0.1));\n    dist = min(dist, dist1);\n    \n\treturn dist;\n}\n\nvec3 getNormal(vec3 p){\n\treturn(normalize(vec3(distScene(p + vec3(EPSN, 0., 0.)) - distScene(p - vec3(EPSN, 0., 0.)),\n    \t\t\t\t\t  distScene(p + vec3(0., EPSN, 0.)) - distScene(p - vec3(0., EPSN, 0.)),\n    \t\t\t\t\t  distScene(p + vec3(0., 0., EPSN)) - distScene(p - vec3(0., 0., EPSN)))));\n}\n\nvec3 render(vec2 uv){\n\t//background\n    vec3 col = vec3(0., 0.13, 0.2);\n    \n    vec3 eye = vec3(0., 0., 5.);\n    vec3 ray = normalize(vec3(uv, 1.) - eye);\n    \n    //raymarch\n    float step, dist;\n    vec3 pos = eye;\n    bool hit = false;\n    \n    for(step = 0.; step < STEPS; step++){\n    \tdist = distScene(pos);\n        if(abs(dist) < EPS){\n        \thit = true;\n            break;\n        }\n        pos += dist * ray;\n    }\n    \n    vec3 normal = getNormal(pos);\n    \n    //shade\n    vec3 light = vec3(10., 10., 10.);\n    vec3 l = normalize(light - pos);\n    \n    if(hit){\n        col = vec3(step / STEPS, 0.3, 0.6) + 0.25 * (0.5 + 0.5 * normal);\n    \tcol *= 0.2 + 0.8 * dot(normal, l); //diffuse\n        \n        //shadow\n        vec3 p = pos + 2. * EPS * normal;\n        float shadow = 1.;\n        float totalDist = length(p - pos);\n        for(step = 0.; step < 40.; step++){\n    \t\tdist = distScene(p);\n            totalDist += dist;\n            shadow = min(shadow, 10. * dist / totalDist);\n        \tif(abs(dist) < EPS){\n                shadow = 0.;\n            \tbreak;\n        \t}\n        \tp += dist * l;\n    \t}\n        col = mix(vec3(0.1, 0.1, 0.2), col, shadow);\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    vec3 col = vec3(0);\n    \n    float aa = 1.;\n    for (float i = 0.; i < aa; i++){\n    \tfor (float j = 0.; j < aa; j++){\n    \t\tcol += render(uv + vec2(i, j) / (aa * iResolution.xy));\n    \t}\n    }\n    fragColor = vec4(col / (aa * aa),1.0);\n}","name":"Image","description":"","type":"image"}]}