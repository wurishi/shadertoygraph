{"ver":"0.1","info":{"id":"tdVXWG","date":"1574975112","viewed":139,"name":"trihexagonal tiling?","username":"cmarangu","description":"https://twitter.com/LucasVB/status/1156705137026580480\nmy first time attempting raymarched shadows -mostly figured it out myself with help from codeparades video, like several other things in this one, which is why its very laggy and inefficient","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["tiling","noneuclidian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// i know more\nconst float PI = 3.141592653589793;\n\nvec3 sund () {\n    // return normalize(\n    //     vec3(\n    //         cos(iTime*1.+PI*.5),\n    //         1.,\n    //         sin(iTime*1.+PI*.5)\n    //     )\n    // );\n    return normalize(\n        vec3(\n            3.,\n            3.,\n            2.\n        )\n    );\n}\n\nvec3 skycol (vec3 d) {\n    return vec3(0., 0., 100./255.)+pow(clamp(dot(sund(), d), 0., 1.), 300.)*2.;\n}\n\nfloat SDFobj (vec3 p) {\n    float SDFobjp = 1e4;\n    SDFobjp = length(p-vec3(0., 2., 0.))-2.;\n    vec3 q = vec3(abs(p.x), abs(p.y-1.), abs(p.z));\n    // rigid (/slightly discontinuous)\n    // return max(max(p.x, p.y), p.z)-1.;\n    // new rounded some help from iq\n    float w = 1.;\n    float l = 1.;\n    float h = 1.;\n    q = vec3(max(q.x-w, 0.), max(q.y-h, 0.), max(q.z-l, 0.));\n    SDFobjp = length(q)-.115;\n    SDFobjp = max(SDFobjp, mix(0., 3.6, .5+.5*sin(iTime*.5))-length(p-vec3(1., 2., -1.)) );\n    return SDFobjp;\n}\n\nfloat SDFfloor (vec3 p) {\n    return p.y+0.;\n}\n\nfloat SDF (vec3 p) {\n    float SDFp = 1e40;\n    SDFp = min(SDFp, SDFobj(p));\n    SDFp = min(SDFp, SDFfloor(p));\n    return SDFp;\n}\n\nvec3 dSDF (vec3 p) {\n    float SDFp = SDF(p);\n    return normalize(\n        vec3(\n            SDF(vec3(p.x+1e-4, p.y, p.z))-SDFp,\n            SDF(vec3(p.x, p.y+1e-4, p.z))-SDFp,\n            SDF(vec3(p.x, p.y, p.z+1e-4))-SDFp\n        )\n    );\n}\n\nint idSDF (vec3 p) {\n    if (SDFobj(p) < SDFfloor(p)) {\n        return 1;\n    }\n    return 0;\n}\n\nfloat SHADOW_MARCH (vec3 p) {\n    p = p+sund()*.1;\n    float closestDE = 1e3;\n    for (float i=0.; i<35.; ++i) {\n        float SDFp = SDF(p);\n        if (SDFp < 1e-2) {\n            return .8;\n        }\n        p = p+sund()*SDFp*.99;\n        closestDE = min(closestDE, SDFp);\n        if (SDFp > 7.) {\n            break;\n        }\n    }\n    return 1.;\n}\n\nvec3 TEX (vec3 p, vec3 d) {\n    int idSDFp = idSDF(p);\n    vec3 dSDFp = dSDF(p);\n    vec3 r = reflect(d, dSDFp);\n    vec3 TEXp = vec3(1.)*(.8+.2*sin(p.x*16.+sin(p.z)*6.));\n    if (idSDFp == 1) {\n        TEXp = vec3(0., .7, .7)*mod(\n            floor(p.x*3.)+\n            floor(p.y*3.)+\n            floor(p.z*3.),\n            2.\n        );\n    }\n    // just some pureley artistic-based lighting\n    // becasue i cant figure out this BRDF thinh\n    float lighting = 0.;\n    lighting += clamp(dot(sund(), dSDFp), 0., 1.)*.3;\n    lighting += clamp(dot(sund(), dSDFp)*.2+.4, 0., 1.);\n    // lighting += clamp(1.-dot(r, dSDFp), 0., 1.)*.3;\n\tlighting = clamp(lighting, 0., 1.);\n    float spec = pow(clamp(dot(sund(), r), 0., 1.), 2.)*.25;\n    if (idSDFp == 1) {\n        spec = pow(clamp(dot(sund(), r), 0., 1.), 3.)*.75;\n    }\n    if (idSDFp == 0) {\n        lighting *= SHADOW_MARCH(p);\n        spec *= SHADOW_MARCH(p);\n    }\n\treturn vec3(\n        clamp(TEXp.r*lighting+spec, 0., 1.),\n        clamp(TEXp.g*lighting+spec, 0., 1.),\n        clamp(TEXp.b*lighting+spec, 0., 1.)\n    );\n}\n\nvec3 march (vec3 p, vec3 d) {\n    float compoundedD = 0.;\n    float rxcount = 0.;\n    float rxindex = .3;\n    vec3 finalcol = vec3(0.);\n    for (float i=0.; i<60.; ++i) {\n        float SDFp = SDF(p);\n        float DE = SDFp;\n        DE *= .999;\n        if (SDFp < 1e-2) {\n            p = p+d*SDFp*.99;\n            int idSDFp = idSDF(p);\n            vec3 TEXpd = TEX(p, d);\n            if (idSDFp == 0) {\n                finalcol = TEX(p, d);\n                d = reflect(d, dSDF(p));\n                p = p+d*.1;\n                ++rxcount;\n                continue;\n            }\n            if (rxcount == 0.) {\n                return TEX(p, d);\n            }\n            return finalcol*(1.-rxindex)+rxindex*TEX(p, d);\n        }\n        p = p+d*DE;\n        compoundedD += DE;\n        if (compoundedD > 20. || SDFp > 7.) {\n            break;\n        }\n    }\n    if (rxcount > 0.) {\n        finalcol = (1.-rxindex)*finalcol+rxindex*skycol(d);\n        return finalcol;\n    }\n    return skycol(d);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 maus = iMouse.xy;\n    if (maus.x == 0.) { maus.x = iResolution.x/2.+iResolution.x*.04; }\n    if (maus.y == 0.) { maus.y = iResolution.y/2.+iResolution.y*.07; }\n    vec2 screen = (fragCoord*2.-iResolution.xy)/iResolution.x;\n    vec3 dir1 = vec3(screen.x, screen.y, 1.);\n    dir1 = normalize(dir1);\n\tfloat dir1zytheta = atan(dir1.z, dir1.y);\n    float dir1zyr = sqrt(dir1.z*dir1.z+dir1.y*dir1.y);\n    float dir2phi = dir1zytheta+clamp((maus.y-iResolution.y/2.)/iResolution.x*10.+0., -PI/4., PI/2.);\n    dir1.y = dir1zyr*cos(dir2phi);\n    dir1.z = dir1zyr*sin(dir2phi);\n    float dir1zxtheta = atan(dir1.z, dir1.x);\n    float dir1zxr = sqrt(dir1.z*dir1.z+dir1.x*dir1.x);\n    float dir2theta = dir1zxtheta+(maus.x-iResolution.x/2.)/iResolution.x*10./2.*2.;\n    dir1.x = dir1zxr*cos(dir2theta);\n    dir1.z = dir1zxr*sin(dir2theta);\n    // dir1 = normalize(dir1);\n    vec3 retina = march(vec3(2., 4., -5.), dir1);\n    fragColor = vec4(retina, 1.);\n}","name":"Image","description":"","type":"image"}]}