{"ver":"0.1","info":{"id":"4ljfWd","date":"1517593603","viewed":130,"name":"rayspheres2","username":"inantop","description":"ray casting","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["ray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_SPHERE = 36;\nint NUM_SPHERE;\n\n\n/* Define World */\nstruct Spheres\n{\n    vec3 position[MAX_SPHERE];\n    float radius[MAX_SPHERE];\n    vec3 color[MAX_SPHERE];\n    float shininess[MAX_SPHERE];\n} spheres;\n    \nvoid InitSpheres()\n{\n    int i = -1;\n    \n    const int EDGE = 6;\n    for (i = 0; i < EDGE*EDGE; i++)\n    {\n\t\tspheres.position[i] = vec3(EDGE - 1, -1, 0.0) + vec3(-i % EDGE * 2, 0, -i / EDGE * 2);\n    \tspheres.radius[i] = .8;\n    \tspheres.color[i] = vec3(float(i) / 9.0, 1.0, float(i % EDGE));\n        spheres.shininess[i] = 128.0;\n    }\n    \n    NUM_SPHERE = ++i;\n}\n\nvoid AnimateScene(float iTime)\n{\n\tspheres.position[1] = vec3(sin(iTime), 0.0, cos(iTime)) * 3.0;\n    spheres.position[2] = vec3(sin(iTime), cos(iTime), 0.0) * 2.0;\n    spheres.position[3] = vec3(2.0, sin(iTime), sin(iTime) * cos(iTime)) * (2.0 + cos(iTime));\n    spheres.position[4] = vec3(sin(iTime), 0.0, cos(iTime)) * 2.0 + spheres.position[3];\n}\n\n/* Matrix Utilities */\n\nmat4 perspective(float fovy, float aspect, float near, float far)\n{\n\tmat4 result;\n    float rad = fovy * 3.14159265 / 180.0;\n    float tanHalfFovy = tan(rad / 2.0);\n    result[0][0] = 1.0 / (aspect * tanHalfFovy);\n    result[1][1] = 1.0 / tanHalfFovy;\n    result[2][2] = - (far + near) / (far - near);\n    result[2][3] = - 1.0;\n    result[3][2] = - (2.0 * far * near) / (far - near);\n    return result;\n}\n\nmat4 lookAt(vec3 eye, vec3 center, vec3 up)\n{\n    mat4 Result = mat4(1.0);\n    \n    vec3  f = normalize(center - eye);\n    vec3  u = normalize(up);\n    vec3  s = normalize(cross(f, u));\n    \n    u = cross(s, f);\n    Result[0][0] = s.x;\n    Result[1][0] = s.y;\n    Result[2][0] = s.z;\n    Result[0][1] = u.x;\n    Result[1][1] = u.y;\n    Result[2][1] = u.z;\n    Result[0][2] =-f.x;\n    Result[1][2] =-f.y;\n    Result[2][2] =-f.z;\n    Result[3][0] =-dot(s, eye);\n    Result[3][1] =-dot(u, eye);\n    Result[3][2] = dot(f, eye);\n    return Result;   \n}\n\n\n\nvec3 unproject(vec3 win, mat4 mvp, vec4 vp)\n{\n    mat4 inv = inverse(mvp);\n\n    vec4 tmp = vec4(win, 1.0);\n    tmp.x = (tmp.x - vp.x) / vp.z;\n    tmp.y = (tmp.y - vp.y) / vp.w;\n    tmp.x = tmp.x * 2.0 - 1.0;\n    tmp.y = tmp.y * 2.0 - 1.0;\n\n    vec4 obj = inv * tmp;\n    obj /= obj.w;\n\n    return vec3(obj);\n}\n\n/* Rays */\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nbool RaySphereCollision(in Ray ray, int sphereIndex, out vec3 collision)\n{\n    vec3 p = ray.origin;\n    vec3 d = ray.direction;\n    \n    vec3 s = spheres.position[sphereIndex];\n    float r = spheres.radius[sphereIndex];\n    vec3 v = s - p;\n    \n    if(dot(v,d) > 0.0)\n    {\n        //Sphere is in front of ray\n        //Compute distance from sphere center to ray\n        vec3 c = cross(s - p, d);\n        float dist = length(c);\n        \n        if (dist < r)\n        {\n            //The distance from the center to the point on the ray is \"dist\"\n            //The distance from the point on the ray to the surface of the sphere is \"x\"\n            //The distance from the center to the surface of the sphere is \"r\"\n            //These form a right triangle\n            float x = sqrt(r * r - dist * dist);\n            \n            //The collision is a point on the ray \"x\" distance back toward the origin.            \n            vec3 pointOnRayClosestToSphereCenter = p + dot(v,d) * d;\n            collision = pointOnRayClosestToSphereCenter - (d * x);\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    else\n    {\n        //Sphere is behind ray\n        return false;\n    }    \n}\n\nRay ScreenToWorldRay(in Ray screenRay, mat4 mvp, vec4 vp)\n{\n\tRay ret;\n    ret.origin = unproject(screenRay.origin, mvp, vp);\n    ret.direction = normalize(unproject(screenRay.origin + screenRay.direction, mvp, vp) - ret.origin);\n    \n    return ret;\n}\n\n/* Lighting */\nvec3 DoPhong(vec3 color, float shininess, vec3 lightColor, vec3 eyeToPoint, vec3 lightToPoint, vec3 normal)\n{\n    vec3 l = normalize(lightToPoint);\n    vec3 e = normalize(eyeToPoint);\n    vec3 r = normalize(-reflect(lightToPoint, normal));\n    vec3 n = normalize(normal);\n    \n    float att = 10.0 / length(lightToPoint);\n                       \n    vec3 combinedColor = color * lightColor;\n\tvec3 ambient = combinedColor * 0.2;\n    vec3 diffuse = combinedColor * max(dot(n, l), 0.0) * att;\n    diffuse = clamp(diffuse, 0.0, 1.0);\n    \n    vec3 specular = combinedColor * pow(max(dot(r, e), 0.0), 0.3 * shininess) * att * att;\n    specular = clamp(specular, 0.0, 1.0);\n    \n    return ambient + diffuse + specular;\n}\n\n/* Main */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitSpheres();\n    //AnimateScene(iTime);\n    \n\tRay pixelRay;\n    pixelRay.origin = vec3(fragCoord, 0.0);\n    pixelRay.direction = vec3(0.0, 0.0, 1.0);\n    \n    vec3 worldEye = vec3(0.0, sin(iTime) + 3., cos(iTime / 4.0) * 10. + 10.);\n    \n    vec3 worldTarget = vec3(0.0, 0.0, 0.0);\n    \n    vec3 worldLight = vec3(0.0, 2.0, 0.0);\n    vec3 lightColor = vec3(.2);\n    \n    vec4 viewport = vec4(0.0, 0.0, iResolution.x, iResolution.y);\n    mat4 mvp = perspective(45.0f, iResolution.x / iResolution.y, 0.1, 1000.0) * lookAt(worldEye, worldTarget, vec3(0.0, 1.0, 0.0));\n    \n    Ray worldRay = ScreenToWorldRay(pixelRay, mvp, viewport);\n      \n    for (int r = 0; r < 4; r++)\n    {\n        vec3 collision;\n        float minDepth = 100000000.0;\n        for (int i = 0; i < NUM_SPHERE; i++)\n        {\n            if (RaySphereCollision(worldRay, i, collision))\n            {\n                if (collision.z < minDepth)\n                {\n                    minDepth = collision.z;\n                    vec3 normal = normalize(collision - spheres.position[i]);\n                    \n                    if (dot(normal, worldRay.direction) < 0.0)\n                    {\n                    \tfragColor += vec4(DoPhong(spheres.color[i], spheres.shininess[i], lightColor, worldEye - collision, worldLight - collision, normal), 1.0);\n                    \n                    \tworldRay.origin = collision;\n                    \tworldRay.direction = reflect(normalize(worldRay.direction), normal);\n                    }\n                    \n                    break;\n                }\n            }\n        }    \n    }\n}","name":"Image","description":"","type":"image"}]}