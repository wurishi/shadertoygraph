{"ver":"0.1","info":{"id":"WtjfzW","date":"1598431157","viewed":5323,"name":"Freely orientable microstructure","username":"ThibaultTricard","description":"Top Left : raw noise\nTop Right : iterated align.\nBottom Left : eval. filter\nBottom Right :  iterated align. + eval. filter\n\nClick to move the separator.\n\narticle : https://hal.inria.fr/hal-02524371\nhttps://mfx.loria.fr/\nhttps://maverick.inria.fr/","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["siggraphasia2020"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// This is a 2D vesion of the technique described in \"Freely orientable microstructures \n// for designing deformable 3D prints\" SIGGRAPH Asia 2020 by T. Tricard, V. Tavernier, C. Zanni\n// J. Mart√≠nez, P-A. Hugron, F. Neyret, S. Lefebvre\n//\n// Feel free to reuse, please cite our work\n//\n// Link to paper : https://hal.inria.fr/hal-02524371\n// Research Teams :\n// https://mfx.loria.fr/\n// https://maverick.inria.fr/\n// =====================================================================\n// This shader computes an phasor noise following an orientation field BuffA\n//    optimized so as to avoid curve discontinuities.\n// BuffB compute the initial distribution and optimize neighbor kernels phase.\n// The result is phase-filtered here, then the procedural texture is displayed.\n// Author : Thibault Tricard 2020\n\n\n// What is shown :\n// - Top Left : raw noise\n// - Top Right : iterated align.\n// - Bottom Left : eval. filter\n// - Bottom Right :  iterated align. + eval. filter\n\n// Controls : \n// Click and drag to move the separator cross\nfloat cellsize = 1./30.,\n     _b = 1.,\n     _a = 1.,\n     dir;\n\n\n//closed form of the phasor kernel filtered to reduce \nvec2 phasorkernel(vec2 x, float fj, vec2 dj, float phi, float filtering){ \n    float fx = fj;//in this case the frequency field is constant so fx = fj; \n    vec2  dx =  CosSin(dir),\n        djx = ( fj*dj - fx*dx ) * filtering;\n    float a =  _a*_a * M_PI,\n          b =  _b*_b * M_PI,\n       gaus =   exp( -    a*b    / (a+b) * dot( x , x ) ) \n              * exp( - M_PI*M_PI / (a+b) * dot(djx,djx) ),\n        osc =   TAU * dot(x, dj) * fj  \n              - TAU * dot(x,djx) * a / (a+b)\n              + phi;\n    \n    return gaus * CosSin(osc);  \n}\n\nbool   optimPhase,                    // use flags for eval_cell\n      filterPhase;\n\n//evaluation on one cell of the noise\nvec2 eval_cell(ivec2 gij, vec2 at ){  \n    vec2 res = vec2(0);\n    int gidx = coord2index(gij,grid_size);\n    for(int i = 0; i< nb_Kernel; i++ ) {\n        //compute the kernel coordinate id\n        int kid = gidx * nb_Kernel * 2 + i * 2;\n        //compute the kernel coordinate in the buffer \n        ivec2 c1 = index2coord( kid ,resx),\n              c2 = index2coord(kid+1,resx);\n        //fetch the kernel k\n\t\tvec4  k1 = texelFetch(iChannel0,c1,0),\n              k2 = texelFetch(iChannel0,c2,0);\n        //flag for the interface\n        float    phi = optimPhase  ? k1.w : 0.,\n           filtering = filterPhase ? 1.   : 0.;\n        //computing the impacte of the phasor kernel\n        res += phasorkernel( at-k1.xy, k2.w, k2.xy, phi,filtering); \n    }\n    return res;\n}\n\n//evaluation of the phasor noise\nvec2 phasor(ivec2 gij, vec2 ij) {      \n    vec2 res = vec2(0);\n    //loop on the neighbor cells\n    for(int i =-2; i<=2; i++)\n    \tfor(int j =-2; j<=2; j++)\n            //evaluation of the cell\n        \tres += eval_cell( gij + ivec2(i,j), ij - vec2(i,j) );\n\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord,   \n      mouse = iMouse.xy;\n    if ( mouse == vec2(0) ) mouse = iResolution.xy/2.;\n   \n    vec2 pos = fragCoord/iResolution.x/cellsize,\n          ij = fract(pos),\n         gij = floor(pos+1.),\n          xy = ( ij + gij ) / float(grid_size) * iResolution.y;\n    dir = texelFetch(iChannel1, ivec2(xy),0).x * TAU;\n\n    optimPhase  = ( uv.x > mouse.x );\n    filterPhase = ( uv.y < mouse.y );\n    vec2 n = phasor(ivec2(gij),ij);\n \n    pos = abs(uv - mouse);\n    if( min(pos.x,pos.y) < 2. ) fragColor = vec4(1);\n    else                        fragColor = vec4(atan(n.y,n.x)/TAU +.5);\n\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//===============================================================================\n// Compute a procedural guaussian orientation field as in Procedural Phasor Noise\n//     used as stub user input data.\n// It returns an angle normalised between 0. and 1.\n\n\nfloat _bandwith = 4.,                         \n      _kernelRadius;\nint _impPerKernel = 10,\n    _seed = 1;\n\n\nfloat gaussian(vec2 X, float b)\n{   return exp(- M_PI * b*b * dot(X,X) ); }\n\nvoid init_grid()                       \n{   _kernelRadius = sqrt( -log(0.05) / M_PI) / _bandwith; }\n\n\nvec2 cell(ivec2 ij, vec2 uv, float b)   \n{\n\tint  nImpulse = _impPerKernel,\n                s = morton(ij.x,ij.y) + 333;\n\tfloat  cellsz = 2. * _kernelRadius;\n\tvec2    noise = vec2(0);\n\tseed( s +_seed );\n    \n\tfor ( int impulse = 0; impulse <= nImpulse ; impulse++ ) {\n\t\tvec2 impulse_centre = vec2( uni_0_1() , uni_0_1() ),\n\t\t     d = ( uv - impulse_centre ) *cellsz;\n\t\tfloat omega = uni( -2.4, 2.4 );\n\t\tnoise += gaussian(d, b) *  CosSin(omega);\t\t\n\t}\n\treturn noise;\n}\n\nvec2 eval_noise(vec2 uv, float b)       \n{   \n\tfloat cellsz = 2. *_kernelRadius;\n\tvec2  _ij = uv / cellsz,\n           ij = floor(_ij),\n\t      fij = fract(_ij ),\n\t    noise = vec2(0);\n    \n\tfor (int j = -2; j <= 2; j++)\n\t\tfor (int i = -2; i <= 2; i++) {\n\t\t\tvec2 nij = vec2(i,j);\n\t\t\tnoise += cell( ivec2(ij + nij) , fij - nij, b );\n\t\t}\n\n    return noise;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    uv.y = -uv.y;\n    init_grid();\n\n    vec2 gaussian_field = normalize( eval_noise(uv,_bandwith) );\n\n    float angle = atan( gaussian_field.y, gaussian_field.x ) / TAU;\n    fragColor = vec4( angle, 0, 0, 1 ); \n \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//=================================================================\n// Build a sparse distribution of kernels ( as for Gabor noise ) \n//    nb_Kernel taken uniformly in each cell of a grid_size x grid_size grid.\n// Then process 50 steps of kernel phase optimization\n//    so as to better align neighboor phases.\n//\n// Data structure:\n// this buffer stores particles:  8 floats per particle stored in RGBA fields of 2 consecutive pixels.\n//    slot 1 ( even pixels ) => Pos: x, y   ; 0, phi\n//\t  slot 2 ( odd pixels )  => Dir: dx, dy ; 0, f\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int      idx = coord2index( ivec2(fragCoord), resx ),\n      field_size = nb_Kernel * 2 *grid_size*grid_size,\n            gidx = (idx) / 2 / nb_Kernel;\n\tivec2    gij = index2coord( gidx , grid_size  );\n    \n    if (idx > field_size) discard;\n    \n    fragColor =vec4(0);\n    if( iFrame == 1 ) { // --------------- initialization ---------\n        int s = morton( morton(gij.x,gij.y), idx );\n\t\tseed(s);\n        if( idx%2 == 0)  // --- particle slot1: position and phi\n           \tfragColor = vec4(uni_0_1(), uni_0_1(),0,0);\n        else {           // --- particle slot2: direction and frequency\n            //We compute the position of the kernel on direction field \n           \tvec2   xy = ( vec2( uni_0_1(), uni_0_1() ) + vec2(gij) ) / float(grid_size) * iResolution.y;\n           \tfloat dir = texelFetch(iChannel1, ivec2(xy),0).x * TAU;\n            \n           \tfragColor = vec4(CosSin(dir), 0 ,2);\n        }\n        return;      \n    }\n    \n    fragColor = texelFetch(iChannel0,ivec2(fragCoord) ,0); // restore previous state\n\n    if(iFrame < 50) { // ---------- alignement process -----\n        \n        if( idx % 2 == 0 ) {       // --- particle slot1\n            //fetch the kernel k\n            vec4 k_part1 = texelFetch(iChannel0, ivec2(fragCoord) \t\t\t  ,0), // slot 1\n                 k_part2 = texelFetch(iChannel0, ivec2(fragCoord) +ivec2(1,0) ,0); // slot 2\n            vec2 phi = vec2(0);\n            // --- loop on the neighbor grid cells to optimize the phase of the kernel k \n            // --- with all the kernels n that interract with it\n            for (int i = -1; i <=1; i ++)\n                for (int j = -1; j <=1; j ++) {\n                    //computation of the index of the cell\n                    gidx = coord2index( gij+ivec2(i,j) , grid_size );\n                    //loop on the kernels in this cell\n                    if(gij.x >=0 && gij.x < grid_size && gij.y >=0 && gij.y  < grid_size)\n                        for(int l = 0; l< nb_Kernel; l ++) {\n                            ////computation of the id of the kernel n\n                            int kid = gidx * nb_Kernel * 2 + l * 2; \n                            //compute the current kernel coordinate \n                            ivec2 c1 = index2coord( kid , resx ),\n                                  c2 = index2coord(kid+1, resx );\n\n                            //fetch the kernel n\n                            vec4 nvalue1 = texelFetch(iChannel0,c1,0),\n                                 nvalue2 = texelFetch(iChannel0,c2,0);\n                            //We want to compute the relative phase shift between the kernel k and n\n                           \n                            //We first compute position of the kernel n relative to the cell of the kernel k\n                            vec2 npos = vec2(i,j)  + nvalue1.xy;\n                            float osc = TAU *  nvalue2.w * dot( k_part1.xy - npos, nvalue2.xy) + nvalue1.w;\n                            \n                            //we use the dot product of the direction of the two kernel to weight this phase shift\n                            //because we want to prioritize the phase alignment of kernel with same direction\n                            float w = dot(k_part2.xy, nvalue2.xy);\n                            phi += w * CosSin(osc) / 2.;\n                        } \n                }  \n\n            //update of the phase value\n            if(phi.x!=0.0){\n                fragColor.w =  atan( phi.y, phi.x );\n            }\n        } \n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// ===============================================\n// Main constants and utility functions\n\n#define nb_Kernel    8\n#define grid_size   32\n#define      resx  128              // [$$ KEZAKO ? ]\n#define M_PI         3.14159265358979323846\n#define TAU      ( 2.*M_PI )\n\n#define index2coord(id,size)   ivec2( (id)%(size), (id)/(size) )\n#define coord2index(P,size)   ( (P).x + (P).y * (size) )\n#define CosSin(a)              vec2( cos(a), sin(a) )\n\n///////////////////////////////////////////////\n//prng\n///////////////////////////////////////////////\n\nint N = 15487469;\nint x_;\nvoid seed(int s)            { x_ = s;                            }\nint next()                  { x_ *= 3039177861; return x_ %=  N; }\nfloat uni_0_1()             { return  float(next()) / float(N);  }\nfloat uni(float m, float M) { return mix( m, M, uni_0_1() );     }\n\n\nint morton(int x, int y)\n{\n  int z = 0;\n  for (int i = 0 ; i < 32* 4 ; i++)\n    z |= ( ( x & (1 << i) ) <<  i      ) \n      |  ( ( y & (1 << i) ) << (i + 1) );\n \n  return z;\n}\n","name":"Common","description":"","type":"common"}]}