{"ver":"0.1","info":{"id":"csBSDw","date":"1670357773","viewed":105,"name":"Ray Casting Attempt 1: Sphere","username":"tjweldon","description":"A first attempt at a raycasted sphere where the sphere surface colour is indicative of the normal to the surface at that point. Then I got carried away! The code is a mess bc it's a WIP. Any advice/feedback welcome.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raycasting","interactive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define PI 3.14159265359 \n\nstruct Camera {\n    vec3 location;\n    vec3 orientation;\n    // the distance from the camera to the projection plane\n    float imgPlaneDist;\n    // field of view expressed as the vector of angles \n    vec2 fov;\n};\n\n// represents a ray from the camera\nstruct Ray {\n    vec3 direction;\n    vec3 start;\n};\n\n// returns the Ray that goes from the camera location via the point on\n// the projection surface. For uv = (0, 0), \n// the ray goes from the camera parallel to its orientation.\nRay pixelRay(Camera c, vec2 uv, vec2 topRight) {\n    vec2 imageSpan = c.imgPlaneDist * c.fov;\n    vec2 imgCoord = uv*imageSpan/topRight;\n    vec3 surfaceOrigin = c.location + normalize(c.orientation)*c.imgPlaneDist;\n    \n    // create orthonormal basis (i,j,k) where:\n    //\n    //     c.orientation = |c.orientation|*k\n    //\n    // The i basis vector is chosen so that\n    //     \n    //     dot(i, z) = 0\n    //\n    // the k vector:\n    vec3 viewZ = normalize(c.orientation);\n    // the i vector, perpendicular to z and k\n    vec3 viewX = normalize(\n        cross(\n            viewZ-dot(viewZ, vec3(0.,0.,1.))*viewZ, \n            vec3(0.,0.,1.)\n        )\n    );\n    // the j vector is fixed by i and k\n    vec3 viewY = normalize(cross(viewX, viewZ));\n    \n    // construct the ray direction in terms of the coords (i,j,k)\n    //\n    //     then ray_direction = (imgCoord.x, imgCoord.y, c.imgPlaneDist)\n    //\n    //     where (a, b, c) denotes a*i + b*j + c*k;\n    \n    vec3 rayIntersect = imgCoord.x*viewX + imgCoord.y*viewY;\n    vec3 direction = viewZ*c.imgPlaneDist + rayIntersect;\n    \n    return Ray(normalize(direction), c.location);\n}\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\n// the vector of closest approach from the ray to the sphere\nvec3 closestApproach(Sphere s, Ray ray) {\n    vec3 start_displacement = s.center - ray.start;\n    vec3 project_normal = normalize(ray.direction) * dot(\n        start_displacement, \n        normalize(ray.direction)\n    );\n    vec3 closest_approach = start_displacement - project_normal;\n    \n    return closest_approach;\n}\n\nvoid mainImage( out vec4 colour, in vec2 fragCoord )\n{\n    // The normalised fragment size\n    vec2 topRight = iResolution.xy/iResolution.y;\n    // Normalized pixel coordinates (from -1 to 1 in y axis)\n    vec2 uv = 2.*fragCoord/iResolution.y - topRight;\n    vec2 uvMouse = 2.*iMouse.xy/iResolution.y - topRight;\n    \n    \n    Sphere s = Sphere(vec3(0.), 2.);\n    \n    // topRight is the pair of opposite side lengths\n    vec2 fov = topRight*tan(PI/8.); // 45 degree in y direction\n    vec3 camStart = 1.3*vec3(5., 5., 2.);\n    vec3 camPos = camStart;\n    if (iMouse.z > 0.)\n        camPos += vec3(2.5*(mat2(1.,-1.,1.,1.)*uvMouse.xy), 0.);\n    Camera c = Camera(\n        camPos, \n        normalize(vec3(0.) - camStart), \n        1., \n        fov\n    );\n    \n    // the sampling ray\n    Ray r = pixelRay(c, uv, topRight);\n    \n    // closest approach of the ray to the center\n    vec3 ca = -closestApproach(s, r);\n    \n    vec3 col = vec3(0.);\n    \n    // everything but the sphere\n    float occlusion = 0.;\n    float ascent = r.direction.z;\n    float tImpact = 0.;\n    if (ascent < 0. && r.start.z > 0.) {\n        tImpact = -r.start.z/ascent;\n        \n        // x-y plane\n        vec3 intersect = r.start + tImpact * r.direction;\n        float decay = exp(.75*(s.radius-length(intersect.xy)));\n        decay = pow(decay, 0.35);\n        if (ca.z < 0. && length(intersect.xy) >= s.radius) {\n            occlusion += decay;\n        }\n        \n        // grid lines\n        // usage of smoothstep to improve some of the jagged pixelation thx to elenzil\n        float green = decay*(smoothstep(-0.02, -0.005, fract(intersect.r+0.5)-0.5) * (1.-smoothstep(0.005,0.02, fract(intersect.r+0.5)-0.5)));\n        float red = decay*(smoothstep(-0.02, -0.005, fract(intersect.g+0.5)-0.5) * (1.-smoothstep(0.005, 0.02, fract(intersect.g+0.5)-0.5)));\n        col += vec3(2.)/(1. + distance(r.start, intersect)) + vec3(red, green, 0.);\n    }\n    \n    \n    float approach = length(ca);\n    \n    \n    // sphere\n    if (approach <= s.radius) {\n        vec3 tex = ca - dot(ca, c.orientation)*normalize(c.orientation);\n        tex = mix(tex, vec3(1.), 0.2);\n        \n        col = mix(col, tex, 1.-occlusion);\n    }\n    \n    // gamma correction (thx to spalmer for the suggestion)\n    col = sRGB(col);\n    \n\n    // Output to screen\n    colour = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// element-wise, piecewise gamma correction function\nfloat y( float x )\n{\n    return x <= 0.0031308\n       ? x * 12.92\n       : pow(x, 1.0/2.4) * 1.055 - 0.055;\n}\n\n// RGB to sRGB (A.K.A gamma correction). Code adapted from:\n// https://unlimited3d.wordpress.com/2020/01/08/srgb-color-space-in-opengl/\nvec3 sRGB( vec3 RGB )\n{\n    return vec3(\n        y(RGB.r),\n        y(RGB.g),\n        y(RGB.b)\n    );\n}","name":"Common","description":"","type":"common"}]}