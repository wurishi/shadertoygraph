{"ver":"0.1","info":{"id":"ws3cRX","date":"1601380467","viewed":255,"name":"SDF logo","username":"Artleet","description":"adopted for OpenGL ES 2, quite unreadable","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["sdf","fonts"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//OpenGL ES 2 adopted\n\n//unpacking\n//if a is ivec4, b is ivec2(1234,5678) and c is 100\n//a will be ivec4(12,34,56,78) -> 1234//100,1234%100,5678//100,5678%100\n#define U(a,b,c) a.yw = b - (a.xz = b / c) * c;\n\n//primitive drawing\n//the coordinates of the primives has to be unpacked to the variable c\n//if first coordinate is not null - call sdf function F\n//and unite the result with the previous sdf stored in f\n#define P(F) f = c.x > 0 ? min(F(o,c), f) : f;\n\n//unpack and draw pair or primitives\n//unpack q to g\n//unpack g.xy to c\n//call drawing function F\n//unpack g.zw to c\n//call drawing function F\n#define D(g,q,F) U(g,q,100) U(c,g.xy,10) P(F) U(c,g.zw,10) P(F)\n\n//calculating position of the letter and unpack and draw up to 4 lines and up to 2 arcs for the letter\n//unpack l[j].xy (lines coordinates) to a\n//call D for further decoding and drawing\n#define C(j) o = vec2(p.x - float(i++) * .1, p.y) * 10.; U(a,l[j].xy,10000) D(b,a.xy,I) D(b,a.zw,I) D(a,l[j].zw,O)\n\n//31337 fx\n//drawing the Leet alternatives of the letters with some cycle F02 7H3 C001 H4CK32 FX\n#define X(a,b) if(sin(float(i)+iTime)>0.){C(a)}else{C(b)}     \n\n//line SDF ivec4(x1,y1,x2,y2)\nfloat I(vec2 p, ivec4 a){\n    vec4 c = vec4(a) / 6.;\n    return length((p -= c.xy) - (c.zw -= c.xy) * clamp(dot(p, c.zw) / dot(c.zw, c.zw), 0., 1.));\n}\n\n//arc SDF ivec4(x,y,radius,mask)\n//first bit of the mask is the masking axis, 2 next bits the direction \nfloat O(vec2 p, ivec4 a){\n    vec4 b = vec4(a) / 6.;\n    int m = a.w - a.w / 2 * 2; \n    return clamp(dot(sign(p -= b.xy), vec2(m, m < 1) * vec2(a.w / 2 - 1)), 0., 1.) + abs(length(p) - b.z);\n}\n\nfloat R(vec2 p){\n    //Letters design is stored in the following format - ivec4(line1-2,line3-4,arc1,arc2)\n    //each digit is a coordinate\n\t//Im deviding the digits by 6. to have coordinate in the 0.-1. range\n    ivec4 l[11];\n    l[0]=ivec4(11353551, 0, 0, 0);//a\n    l[1]=ivec4(11411343, 1545, 4211, 4411);//b\n    l[2]=ivec4(11151333, 51333355, 0, 0);//k\n    l[3]=ivec4(13155355, 0, 3324, 0);//u\n    l[4]=ivec4(11151531, 31555551, 0, 0);//m\n    l[5]=ivec4(15313155, 0, 0, 0);//v\n    l[6]=ivec4(0, 0, 3322, 0);//o\n    l[7]=ivec4(1155, 0, 3322, 0);//0\n    l[8]=ivec4(51555313, 1335, 0, 0);//4\n    l[9]=ivec4(3351, 0, 3322, 0);//q\n    l[10]=ivec4(11411343, 15555533, 4211, 0);//3\n\t\t\n    float f=1.;\n    ivec4 a,b,c;\n    vec2 o;\n    int i=0;\n  \n    //C(0)C(1)C(1)C(0)C(2)C(3)C(4)C(6)C(5)C(0)\n    X(0,8)X(1,10)X(1,10)X(0,8)X(2,9)X(3,3)X(4,4)X(6,7)X(5,5)X(0,8)\n   \n    return f;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    uv.y -= .5;\n    uv.x -= iResolution.x * .5/ iResolution.y - .5;\n    \n    float f = R(uv), g = .02 / f * (sin(iTime * 100.) * .1 + .9);\n    fragColor = vec4(g, g * .5, 0, 1) + .004 / f;\n}","name":"Image","description":"","type":"image"}]}