{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"/*\nBasic Transformation Test-Grid -- Svenofnine / Erfurt 2024\nhttps://www.shadertoy.com/view/lXcyWH\n*/\n\n#define rotate2d(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define TAU float(6.28318530718)\n#define ar float(iResolution.x/iResolution.y)            // aspect ratio\n#define unit float(ar/iResolution.x)\n#define range(a,b,x) float(smoothstep(a-0.5,a,x)-smoothstep(b,b+0.5,x))\n\n// GRID FUNCTIONS\n\n// draws a rectangular antialiased grid \n// uv = coordinates of the 2d space\n// stepsize  = every this distance a line will be drawn. it's vec2() so you can define different stepsizes for x and y\n// linewidth = width of the line in units of uv\n// returns brightness from 0. .. 1.\nfloat grid( vec2 uv, vec2 stepsize, float linewidth ) {\n    vec2 v = mod(uv, stepsize);\n    return max( \n        1. - smoothstep(0., 0.5*linewidth, v.x) + smoothstep( stepsize.x-0.5*linewidth, stepsize.x, v.x), \n        1. - smoothstep(0., 0.5*linewidth, v.y) + smoothstep( stepsize.y-0.5*linewidth, stepsize.y, v.y) \n    );\n}\n\n// returns colours for the world axis\n// uv = coordinates of the 2d space\n// linewidth = width of the line in units of uv\n// returns a color: x-axis = red, y-axis = green (like Rhinoceros 3D), other = white\nvec3 axis_color( vec2 uv, float linewidth) {\n    return \n    ( (uv.x > 0.) && (abs(uv.y) <= 0.5*linewidth) ) \n    ? vec3(1.,0.,0.) \n    : ( ( (uv.y > 0.) && (abs(uv.x) <= 0.5*linewidth) )\n      ? vec3(0.,1.,0.) \n      : vec3(1.) );\n}\n\nfloat mouse_arrow(vec2 d) {\n    return \n    range(0., -d.y, d.x) * range(-30.,0.,d.y) \n    + max(\n        range(0., (43.+d.y), d.x) * range(-42.,-30.,d.y),\n        range(0., 10., d.x + d.y/3.+3.) * range(-44.,-30.,d.y) \n      );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = vec2(0.5);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    vec2 uv_bak = uv;\n\n\n    /*********************************************************/\n    // play with grid transformations\n    // (un)comment several or multiple lines and see what happens:\n    \n    uv = (uv - center) * vec2(ar, 1.);                      // 1) adding aspect ratio correction and center 0/0\n\n    // uv = uv / vec2(0.5);                                 // 2) zooming by a value\n\n    // uv = uv * rotate2d( iTime*.5 );                      // 3) rotation of the grid\n    \n     uv = uv * rotate2d( uv.x * sin(iTime*TAU) );         // 4) bending like wings :)\n    \n    // uv = uv * rotate2d( uv.y * sin(iTime*TAU) );         // 5) wiggling\n    \n    // uv = uv * rotate2d( (uv.y * uv.x)* sin(iTime*TAU) ); // 6) squishing\n    \n    // uv = vec2( distance(vec2(0.),uv), atan(uv.x/uv.y) ); // 7) polar coordinates\n    \n    // ... what also could we do with uv?\n    \n    /*********************************************************/\n    \n    // draw the grid\n    vec3 grid_color = vec3( clamp( \n        1.0 * grid(uv, vec2(1.), 0.01)         // full brightness grid with stepsize 0.5 and linewidth of 0.01 uv units\n        + 0.5 * grid(uv, vec2(0.5), 0.01)         // full brightness grid with stepsize 0.5 and linewidth of 0.01 uv units\n        + 0.3 * grid(uv, vec2(0.1), 0.005)     // half brightness grid with 1/10 from the first\n        + 0.15 * grid(uv, vec2(0.01), 0.001)   // 1/4 brightness grid with 1/10 from the second\n        , 0., 1.                               // max brightness set to 1.\n    ) ) * axis_color(uv, 0.01);\n\n    // draw a mouse arrow\n    grid_color = max( grid_color, mouse_arrow((uv - mouse)/unit) );\n\n    uv = uv_bak;\n    grid_color = max( grid_color, 0.25*mouse_arrow((uv - mouse)/unit) );\n\n    // Output to screen\n    fragColor = vec4( grid_color ,1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lXcyWH","date":"1735001971","viewed":102,"name":"Basic Transformation Test-Grid","username":"Svenofnine","description":"I made two functions for drawing a 2D grid on the uv plane with markers for the axis. It shows how specific transformations on the uv vector affects the grid. Its for teaching and testing. Mouse has coordinates 0,0 to 1,1 for reference.\nEnjoy!","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["test","grid","transformation","measure"],"hasliked":0,"parentid":"","parentname":""}}