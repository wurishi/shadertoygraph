{"ver":"0.1","info":{"id":"X3lfRM","date":"1728754807","viewed":80,"name":"AAA_cluster","username":"kosalos","description":"Interesting, but very slow image.\nUsing partial drawing method to speed up rendering when making parameter changes (press arrow keys, <Spc> or mouse to refresh image)","likes":1,"published":3,"flags":48,"usePreview":0,"tags":["raymarching","3dfractal"],"hasliked":0,"parentid":"l3jyzV","parentname":"Sphere_Cluster"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Key Commands:\n<Up,Dn Arrows> : select widget focus. PgUp,PgDn hop by 5 entries.\n<Lt,Rt Arrows> : alter value of focused widget\n<0>   : focused value -> 0.0\n<E>   : animate just focused value (A,Z affect amount)\n<Spc> : reset\n\nNote: toggles off by default\n\nNote: hold down <Shift> then drag mouse to affect camera.xy regardless of focus.\nNote: hold down <Alt><Shift> then drag mouse to affect aim.xy regardless of focus.\n\nDrag mouse on X axis to alter focused widget value.\nNote: mouse X affects focused value, mouse Y affects next entry\n\nAccelerated changes while holding down arrow keys or moving the mouse:\nHold down <A> for change Amount * 0.1\nHold down <Z> for change Amount * 10.\nHold down both <A><Z> for change Amount * 50.\n\nSpotLight\nSpotV     : strength\nSpotX,Y   : position\nSpotE     : exponent\nSpotR,G,B : color\n\nbased on: https://www.shadertoy.com/view/lstyR4\n*/\n\n// --------------------------------------------------------\n\nfloat DE(vec3 p) {\n\tvec3 po;\n\tfloat excess = 1.3; // adds a skin width\n\tfloat t;\n\tfloat scale = 1.0;\n\tfloat pmmm = qd.minrb * qpackRatio;\n\tbool recurse = true;\n\tfloat z1 = qzero1;\n\tfloat z2 = qzero2;\n    \n\tfor (int n = 0; n < 100; ++n)\t{\n\t\tif(n >= qmaxsteps) break;\n\n        if (recurse) {\n\t\t\tif (length(p) > excess) {\n\t\t\t\treturn (length(p) - 1.0) * scale;\n\t\t\t}\n\t\t\tfloat sc = qscaleFactor * qd.minrb / dot(p,p);\n\t\t\tp *= sc;\n\t\t\tscale /= sc;\n\t\t\trecurse = false;\n\t\t}\n\n\t\tp += qscaleFactor4;\n\t\tt = dot(p, qd.nb0); if (t < 0.0)\tp -= z1 * qd.nb0 * t * qscaleFactor2;\n\t\tt = dot(p, qd.nb1); if (t < 0.0)\tp -= z1 * qd.nb1 * t * qscaleFactor2;\n\t\tt = dot(p, qd.nb2); if (t < 0.0)\tp -= z1 * qd.nb2 * t * qscaleFactor2;\n\t\tt = dot(p, qd.nb3); if (t < 0.0)\tp -= z1 * qd.nb3 * t * qscaleFactor2;\n\t\tt = dot(p, qd.nb4); if (t < 0.0)\tp -= z1 * qd.nb4 * t * qscaleFactor2;\n\n\t\tp = p - qscaleFactor4 + qscaleFactor5;\n\t\tt = dot(p, qd.nb0); if (t > 0.0)\tp -= z2 * qd.nb0 * t * qscaleFactor3;\n\t\tt = dot(p, qd.nb1); if (t > 0.0)\tp -= z2 * qd.nb1 * t * qscaleFactor3;\n\t\tt = dot(p, qd.nb2); if (t > 0.0)\tp -= z2 * qd.nb2 * t * qscaleFactor3;\n\t\tt = dot(p, qd.nb3); if (t > 0.0)\tp -= z2 * qd.nb3 * t * qscaleFactor3;\n\t\tt = dot(p, qd.nb4); if (t > 0.0)\tp -= z2 * qd.nb4 * t * qscaleFactor3;\n\t\tp -= qscaleFactor5;\n\t\t\n\t\tz1 += qdzero1;\n\t\tz2 += qdzero2;\n\n\t\tif (length(p - qd.mmm) < qd.rb || n == qmaxsteps - 1) {\n\t\t\tp -= qd.mmm;\n\t\t\tfloat sc = qd.rb * qd.rb / dot(p, p);\n\t\t\tp *= sc;\n\t\t\tscale /= sc;\n\t\t\tp += qd.mmm;\n\n\t\t\tif (length(p) < qd.minrb) {\n\t\t\t\tp /= pmmm;\n\t\t\t\tscale *= pmmm;\n\t\t\t\trecurse = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(n > 3) {\n\t\t\tpo = p - qOcenter;\n\t\t\tqd.orbitTrap = min(qd.orbitTrap, vec4(po, dot(po,po)));\n\t\t}\n\t}\n\n\treturn (length(p) - pmmm) * scale;\n}\n\n// --------------------------------------------------------\n\nvec3 generateColor(float weight,float x) {\n    if(weight == 0.0) return vec3(0.0);\n\n    x = cos(x);\n    //x=abs(sin(x)); // limits colors\n\n    // bezier, you can rearange the functions for different color combos but this one is best\n    float r = (1.0-x)*(1.0-x);\n    float g = x*x;\n    float b = 2.0*(1.0-x)*x;\n    return vec3(r,g,b);\n}\n\nvec3 orbitTrapCycle(float cycle,vec3 c, float s) {\n    float ss = s * cycle;\n    return vec3(0.5) + 0.5 * vec3( cos(ss + c.x), cos(ss + c.y), cos(ss + c.z));\n}\n\nvec3 getOrbitColor() {\n    vec3 orbitColor;\n    \n    if (qOcycle > 0.0) {\n        orbitColor =\n        orbitTrapCycle(qOcycle,generateColor(qOXwt,qOXcr), qd.orbitTrap.x) * qOXwt * qd.orbitTrap.x +\n        orbitTrapCycle(qOcycle,generateColor(qOYwt,qOYcr), qd.orbitTrap.y) * qOYwt * qd.orbitTrap.y +\n        orbitTrapCycle(qOcycle,generateColor(qOZwt,qOZcr), qd.orbitTrap.z) * qOZwt * qd.orbitTrap.z +\n        orbitTrapCycle(qOcycle,generateColor(qOWwt,qOWcr), qd.orbitTrap.w) * qOWwt * qd.orbitTrap.w;\n    } else {\n        orbitColor =\n            generateColor(qOXwt,qOXcr) * qOXwt * qd.orbitTrap.x +\n            generateColor(qOYwt,qOYcr) * qOYwt * qd.orbitTrap.y +\n            generateColor(qOZwt,qOZcr) * qOZwt * qd.orbitTrap.z +\n            generateColor(qOWwt,qOWcr) * qOWwt * qd.orbitTrap.w;\n    }\n    \n    return orbitColor;\n}\n\nvec3 spotLighting() {\n    const float PI = 3.141592654;\n    float a1 = qspotLightData.x * PI;\n    float a2 = qspotLightData.y * PI * 0.5;\n    float s1 = sin(a1);\n    vec3 spotDir = vec3(s1 * cos(a2), s1 * sin(a2), cos(a1));\n    spotDir = normalize(spotDir);\n    vec3 halfVector = normalize(spotDir - qd.direction);\n\n    float nDotL = max(0., dot(qd.normal, spotDir));\n    float hDotN = max(0., dot(qd.normal, halfVector));\n\n    float exp = qspotLightData.z;\n    return qspotLight * qspotLightColor * ((exp + 2.) / 2.) * pow(hDotN, exp)\n        * (exp + (1. - exp) * pow(1. - hDotN, 5.)) * nDotL * qspotLight;\n}\n\nvec3 phongLighting() {\n    vec3 L = normalize(qphongPosition - qd.position);\n    float dotLN = dot(L, qd.normal);\n    if (dotLN < 0.0)\n        return vec3(0.);\n        \n    float t1 = qphongParam.x * dotLN;\n\n    vec3 V = normalize(qcamera - qd.position);\n    vec3 R = normalize(reflect(-L, qd.normal));\n    float dotRV = dot(R, V);\n\n    if (dotRV < 0.0)\n        return vec3(qphongColor * t1);\n\n    float t2 = qphongParam.y * pow(abs(dotRV), qphongParam.z);\n    return qphongColor * (t1 + t2);\n}\n\nvoid applyColoring() {\n   qd.color = vec3(qd.ambient) + vec3(5.0 - (qd.normal * qd.vibrant + sqrt(float(qd.iter) * qd.dim)));\n    qd.color = vec3(0.5) + (qd.color - vec3(0.5)) * qd.contrast;\n    \n    if(length(qphongColor) > 0.0)\n        qd.color += phongLighting() * 02.01;\n    if(qspotLight > 0.)\n       qd.color += spotLighting() * 0.02;\n        \n    if(qOstrength > 0.0) {\n        vec3 oColor = getOrbitColor();\n        qd.color = mix(qd.color, oColor, qOstrength);\n    }\n}\n\n// --------------------------------------------------------\n// https://iquilezles.org/articles/normalsSDF\n\nvoid calcNormal() {\n    float d0 = DE(qd.position);\n    vec2 epsilon = vec2(qd.epsilon,0.);\n    vec3 d1 = vec3(\n        DE(qd.position-epsilon.xyy),\n        DE(qd.position-epsilon.yxy),\n        DE(qd.position-epsilon.yyx));\n    qd.normal = normalize(d0 - d1);\n}\n\n// --------------------------------------------------------\n// viewVectors already calculated in Buffer A\n\nvoid setDirection(vec2 U) {\n    vec2 vPos = (U - iResolution.xy * 0.5)/iResolution.y;\n    qd.direction = normalize(qd.viewVector + vPos.x * qd.sideVector + vPos.y * qd.topVector);\n}\n\n// --------------------------------------------------------\nconst float MIN_DIST = 0.01;\nconst float MAX_DIST = 12.0;\nconst float EP = 0.00001;\n\nvoid rayMarch() {\n    vec3 position = qcamera;\n    float distance;\n    qd.iter = 0;\n    qd.depth = MIN_DIST;\n     \n    for(int i = 0;i < 250;++i) {\n        distance = DE(position);\n        if(abs(distance) < EP || qd.depth > MAX_DIST) break;\n        qd.iter += 1;\n        \n        qd.depth += distance;\n        position += qd.direction * distance;\n  }\n}\n\n// --------------------------------------------------------\n\nvoid displayData(inout vec4 O, in vec2 U) {\n    vec2 R = iResolution.xy;\n    if(U.x > R.x * 0.75) return; // no printing in that region\n    if(U.y < R.y * 0.6) return;\n\n    Font f;\n    setFont(f,R.xy / vec2(16, 16),R.xy);\n\n    TextCursor t;\n    float fSize = 10. + R.x / 80.;  // 16 character string -> ~1/3 width of screen\n    vec2 charScale = vec2(fSize,fSize);\n    t.startPos = vec2(0, R.y);\n    t.coord = ivec2(0.);\n    t.font = f;\n    t.color = vec4(1.);\n    t.charSize = charScale;\n    t.charSpace = vec2(0.8,0.9) * charScale;\n    t.pageWidth = int(R.x / t.charSize.x);\n    t.fragCoord = U;\n\n    declString(gap, 1, (cSp));\n\n    String str;\n    float value = 0.;\n\n    switch(qd.focus) {\n        case  0 : setString(str,8,(cm,ca,cx,cs,ct,ce,cp,cs)); value = float(qmaxsteps); break;\n        case  1 : setString(str,9,(cp,ca,cc,ck,cr,ca,ct,ci,co)); value = qpackRatio; break;\n        case  2 : setString(str,3,(cp,ch,ci)); value = qphi; break;\n        case  3 : setString(str,4,(cp,ch,ci,c2)); value = qphi2; break;\n        case  4 : setString(str,5,(cz,ce,cr,co,c1)); value = qzero1; break;\n        case  5 : setString(str,5,(cz,ce,cr,co,c2)); value = qzero2; break;\n        case  6 : setString(str,6,(cd,cz,ce,cr,co,c1)); value = qdzero1; break;\n        case  7 : setString(str,6,(cd,cz,ce,cr,co,c2)); value = qdzero2; break;\n        case  8 : setString(str,11,(cs,cc,ca,cl,ce,cf,ca,cc,ct,co,cr)); value = qscaleFactor; break;\n        case  9 : setString(str,12,(cs,cc,ca,cl,ce,cf,ca,cc,ct,co,cr,c2)); value = qscaleFactor2; break;\n        case 10 : setString(str,12,(cs,cc,ca,cl,ce,cf,ca,cc,ct,co,cr,c3)); value = qscaleFactor3; break;\n        case 11 : setString(str,12,(cs,cc,ca,cl,ce,cf,ca,cc,ct,co,cr,c3)); value = qscaleFactor4; break;\n        case 12 : setString(str,12,(cs,cc,ca,cl,ce,cf,ca,cc,ct,co,cr,c4)); value = qscaleFactor5; break;\n        case 16 : setString(str,7,(cC,ca,cm,ce,cr,ca,cX)); value = qcamera.x; break;\n        case 17 : setString(str,7,(cC,ca,cm,ce,cr,ca,cY)); value = qcamera.y; break;\n        case 18 : setString(str,7,(cC,ca,cm,ce,cr,ca,cZ)); value = qcamera.z; break;\n        case 20 : setString(str,4,(cA,ci,cm,cX)); value = qaim.x; break;\n        case 21 : setString(str,4,(cA,ci,cm,cY)); value = qaim.y; break;\n        case 22 : setString(str,4,(cA,ci,cm,cZ)); value = qaim.z; break;\n        case 23 : setString(str,7,(cP,ch,co,cC,co,cl,cR)); value = qphongColor.x; break;\n        case 24 : setString(str,7,(cP,ch,co,cC,co,cl,cG)); value = qphongColor.y; break;\n        case 25 : setString(str,7,(cP,ch,co,cC,co,cl,cB)); value = qphongColor.z; break;\n        case 26 : setString(str,7,(cP,ch,co,cP,co,cs,cX)); value = qphongPosition.x; break;\n        case 27 : setString(str,7,(cP,ch,co,cP,co,cs,cY)); value = qphongPosition.y; break;\n        case 28 : setString(str,7,(cP,ch,co,cP,co,cs,cZ)); value = qphongPosition.z; break;\n        case 29 : setString(str,7,(cP,ch,co,cD,ci,cf,cf)); value = qphongParam.x; break;\n        case 30 : setString(str,7,(cP,ch,co,cS,cp,ce,cc)); value = qphongParam.y; break;\n        case 31 : setString(str,6,(cP,ch,co,cA,cm,cb)); value = qphongParam.z; break;\n        case 32 : setString(str,5,(cS,cp,co,ct,cV)); value = qspotLight; break;\n        case 33 : setString(str,5,(cS,cp,co,ct,cX)); value = qspotLightData.x; break;\n        case 34 : setString(str,5,(cS,cp,co,ct,cY)); value = qspotLightData.y; break;\n        case 35 : setString(str,5,(cS,cp,co,ct,cE)); value = qspotLightData.z; break;\n        case 36 : setString(str,5,(cS,cp,co,ct,cR)); value = qspotLightColor.x; break;\n        case 37 : setString(str,5,(cS,cp,co,ct,cG)); value = qspotLightColor.y; break;\n        case 38 : setString(str,5,(cS,cp,co,ct,cB)); value = qspotLightColor.z; break;\n        case 39 : setString(str,6,(cO,cr,cb,ci,ct,cS)); value = qOstrength; break;\n        case 40 : setString(str,6,(cO,cr,cb,ci,ct,cC)); value = qOcycle; break;\n        case 41 : setString(str,5,(cO,cw,ch,ct,cX)); value = qOXwt; break;\n        case 42 : setString(str,5,(cO,cc,co,cl,cX)); value = qOXcr; break;\n        case 43 : setString(str,5,(cO,cw,ch,ct,cY)); value = qOYwt; break;\n        case 44 : setString(str,5,(cO,cc,co,cl,cY)); value = qOYcr; break;\n        case 45 : setString(str,5,(cO,cw,ch,ct,cZ)); value = qOZwt; break;\n        case 46 : setString(str,5,(cO,cc,co,cl,cZ)); value = qOZcr; break;\n        case 47 : setString(str,5,(cO,cw,ch,ct,cW)); value = qOWwt; break;\n        case 48 : setString(str,5,(cO,cc,co,cl,cW)); value = qOWcr; break;\n        case 49 : setString(str,5,(cO,cc,cn,ct,cX)); value = qOcenter.x; break;\n        case 50 : setString(str,5,(cO,cc,cn,ct,cY)); value = qOcenter.y; break;\n        case 51 : setString(str,5,(cO,cc,cn,ct,cZ)); value = qOcenter.z; break;\n    }\n\n    printInt(qd.focus+1,t);\n    printString(gap,t);\n    printString(str,t);\n    printString(gap,t);\n    printFloat(value, t);\n    drawText(t, iChannel3, O);\n}\n\n\nvoid initializedNonStoredData() {\n    qd.orbitTrap = vec4(10000.);\n    qd.epsilon = 0.00001; // deviation when calculating normal\n\n    vec3 tb0 = vec3(1.0 / qphi, 0.0, qphi2);\n    vec3 tb1 = vec3(1.,-1.,1.);\n    vec3 tb2 = vec3(qphi, -1.0 / qphi2, 0.0);\n    vec3 tb3 = vec3(qphi, 1.0 / qphi2, 0.0);\n    vec3 tb4 = vec3(1.0, 1.0, 1.0);\n    \n#define qqq(v1,v2,v3) normalize(cross(v1, v2-v3))\n    qd.nb0 = qqq(tb0,tb1,tb0);\n    qd.nb1 = qqq(tb1,tb2,tb1);\n    qd.nb2 = qqq(tb2,tb3,tb2);\n    qd.nb3 = qqq(tb3,tb4,tb3);\n    qd.nb4 = qqq(tb4,tb0,tb4);\n\n    vec3 dirb = normalize(tb0 + tb1 + tb2 + tb3 + tb4);\n    qd.mid_to_edgeb = atan(dirb.z / dirb.x);\n    qd.xxb = 1.0 / sin(qd.mid_to_edgeb);\n    qd.rb = sqrt(2.)/ sqrt(-2.0 + qd.xxb * qd.xxb);\n    qd.rb = sqrt(2.)/ sqrt(-2.0 + qd.xxb * qd.xxb);\n    qd.lb = sqrt(1. + qd.rb * qd.rb);\n    qd.minrb = qd.lb - qd.rb;\n    qd.mmm = dirb * qd.lb;\n \n    // -----------------------------------------------\n    qd.ambient = 0.0;\n    qd.contrast = 0.16;\n    qd.vibrant = 2.;//01;\n    qd.dim = 1.7;\n    qd.color = vec3(0,0,0);\n\n    qd.fogDistance = 0.; //  -1.25;  // set to 0. to disable fog\n    qd.fogAmount = 0.721;\n    qd.fogColor = 0.52;\n}\n\n// --------------------------------------------------------\n\n\nbool getKeyState(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,0), 0).x != 0.);\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    O = vec4(0.);\n    readStoredData(iChannel0);\n    \n    //-----------------------------------\n    // qd.displayCount >  1   :: display text and small rendition of image while using arrow keys and mouse\n    // qd.displayCount == 1   :: display full screen image\n    // qd.displayCount == 0   :: idle\n    //-----------------------------------\n    if(qd.displayCount > 1) {\n        displayData(O,U);\n        \n        if(getKeyState(KEY_UP) || getKeyState(KEY_DOWN) || getKeyState(KEY_PGUP) || getKeyState(KEY_PGDN)) return;\n        \n        vec2 r = vec2(U/iResolution.xy);\n        if(r.x < 0.3 || r.x > 0.7 || r.y < 0.3 || r.y > 0.7) return;\n    }\n    if(qd.displayCount == 0) {\n        discard;\n        return;\n    }\n    \n    initializedNonStoredData();\n    setDirection(U);\n    rayMarch();\n    \n    if(qd.depth < MAX_DIST) {\n        qd.position = qcamera + qd.direction * qd.depth;\n        calcNormal();\n        applyColoring();\n\n        if(qd.fogDistance != 0.0) {\n            float f = qd.depth - qd.fogDistance;\n            if(f > 0.0) {\n                f = min(1.0,f * qd.fogAmount);\n                qd.color = mix(qd.color, vec3(0.2 + f * qd.fogColor),f);\n            }\n        }\n\n        O = vec4(qd.color,1.0);\n    }\n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct Dataset {\n    vec3 nb0,nb1,nb2,nb3,nb4, mmm;\n    float mid_to_edgeb,xxb,rb,lb,minrb;\n    vec3 nbsf20,nbsf21,nbsf22,nbsf23,nbsf24;\n    vec3 nbsf30,nbsf31,nbsf32,nbsf33,nbsf34;\n\n    float epsilon;\n    float ambient,contrast,vibrant,dim;\n    float fogDistance,fogAmount,fogColor; // distance = 0.0 -> disable effect\n    \n    vec3 direction;\n    vec3 normal;\n    vec3 position;\n    vec3 color;\n    float depth;\n    int iter;\n    vec4 orbitTrap;\n    \n    int focus,row,displayCount;\n    vec3 viewVector,sideVector,topVector;\n};\n\nDataset qd;\n\n#define qmaxsteps int(q[0].x)\n#define qpackRatio q[0].y\n#define qphi q[0].z\n#define qphi2 q[0].w\n#define qzero1 q[1].x\n#define qzero2 q[1].y\n#define qdzero1 q[1].z\n#define qdzero2 q[1].w\n#define qscaleFactor q[2].x\n#define qscaleFactor2 q[2].y\n#define qscaleFactor3 q[2].z\n#define qscaleFactor4 q[2].w\n#define qscaleFactor5 q[3].x\n#define qcamera q[4].xyz\n#define qaim q[5].xyz\n#define qphongColor vec3(q[5].w,q[6].xy)\n#define qphongPosition vec3(q[6].zw,q[7].x)\n#define qphongParam q[7].yzw\n#define qspotLight q[8].x\n#define qspotLightData q[8].yzw\n#define qspotLightColor q[9].xyz\n#define qOstrength q[9].w\n#define qOcycle q[10].x\n#define qOXwt q[10].y\n#define qOXcr q[10].z\n#define qOYwt q[10].w\n#define qOYcr q[11].x\n#define qOZwt q[11].y\n#define qOZcr q[11].z\n#define qOWwt q[11].w\n#define qOWcr q[12].x\n#define qOcenter q[12].yzw\n\n// -----------------------------------------------------------------\n\n#define UNUSED  999.\n#define UNUSEDP ParamData(UNUSED,UNUSED,UNUSED,UNUSED)\n\nstruct ParamData {\n    float start,vmin,vmax,delta;\n};\n\nconst float pDelta = 0.001;\n\nconst ParamData[] pData = ParamData[]( \n    //  0 p0 ---------------\n    ParamData(15.,5.,40.,1.),  // maxsteps \n    ParamData(1.168,-5.,5., pDelta), // packRatio\n    ParamData(-0.9131, -5.0, 5.0, pDelta), // phi\n    ParamData(-1.8796, -5.0, 5.0, pDelta), // phi2\n    //  4 p1 ---------------\n    ParamData(2.1517, -5.0, 5.0, pDelta), // zero1\n    ParamData(0.0338, -5.0, 5.0, pDelta), // zero2\n    ParamData(0.0210, -5.0, 5.0, pDelta), // dzero1\n    ParamData(0.0009, -5.0, 5.0, pDelta), // dzero2\n    //  8 p2 ---------------\n    ParamData(0.8859, -5.0, 5.0, pDelta), // scaleFactor\n    ParamData(1.0000, -5.0, 5.0, pDelta), // scaleFactor2\n    ParamData(1.0000, -5.0, 5.0, pDelta), // scaleFactor3\n    ParamData(0.0000, -5.0, 5.0, pDelta), // scaleFactor4\n    // 12 p3 ---------------\n    ParamData(0.0000, -5.0, 5.0, pDelta), // scaleFactor5\n    UNUSEDP,\n    UNUSEDP,\n    UNUSEDP,\n    // 16 p4 ---------------\n    ParamData(0.7123, -20., 20., 0.01), // camera\n    ParamData(-0.0019, -20., 20., 0.01),\n    ParamData(0.3298, -20., 20., 0.01),\n    UNUSEDP,\n    // 20 p5 ---------------    \n    ParamData(0.3153, -20., 20., 0.01), // aim\n    ParamData(0.4238, -20., 20., 0.01),\n    ParamData(0.8490, -20., 20., 0.01),\n    ParamData(0.0900, 0.,3., 0.01),\n    // 24 p6 ---------------\n    ParamData(0.0500, 0.,3., 0.01),\n    ParamData(0.0000, 0.,3., 0.01),\n    ParamData(7.0000, -20.,20., 0.01),\n    ParamData(6.0000, -20.,20., 0.01),\n    // 28 p7 ---------------\n    ParamData(-10.0000, -20.,20., 0.01),\n    ParamData(8.17, 0.,5., 0.01),\n    ParamData(6.16, 0.,5., 0.01),\n    ParamData(1.85, 0.,10., 0.01),\n    // 32 p8 ---------------    \n    ParamData(0.0, 0., 3., 0.01),\n    ParamData(-6.0, -6., 6., 0.01),\n    ParamData(6.0, -6., 6., 0.01),\n    ParamData(2.0, -2., 2., 0.01),\n    // 36 p9 ---------------    \n    ParamData(1.0, 0., 1., 0.01),\n    ParamData(0.06, 0., 1., 0.01),\n    ParamData(0.0, 0., 1., 0.01),\n    ParamData(0.1599, 0., 5., 0.01),\n    // 40 p10 ---------------    \n    ParamData(0.0, 0., 5., 0.01),\n    ParamData(1.34, -5., 5., 0.01),\n    ParamData(-1.75, -5., 5., 0.01),\n    ParamData(-5.0, -5., 5., 0.01),\n    // 44 p11 ---------------    \n    ParamData(-0.75, -5., 5., 0.01),\n    ParamData(-1.02, -5., 5., 0.01),\n    ParamData(-1.91, -5., 5., 0.01),\n    ParamData(0.32, -5., 5., 0.01),\n    // 48 p12 ---------------    \n    ParamData(0.0, -5., 5., 0.01),\n    ParamData(-2.25, -5., 5., 0.01),\n    ParamData(-0.44, -5., 5., 0.01),\n    ParamData(-0.48, -5., 5., 0.01)\n); \n\nconst int indexCamera = 16;\nconst int indexAim = 20;\nconst int indexPhong = 23;\nconst int indexSpot = 32;\nconst int indexOrbit = 39;\n\nconst int PDATA_SIZE = 51;\n\nconst ivec2 FOCUS_ADDR=ivec2( 0, 0);\nconst ivec2 P0_ADDR =  ivec2( 1, 0);\nconst ivec2 P1_ADDR =  ivec2( 2, 0);\nconst ivec2 P2_ADDR =  ivec2( 3, 0);\nconst ivec2 P3_ADDR =  ivec2( 4, 0);\nconst ivec2 P4_ADDR =  ivec2( 5, 0);\nconst ivec2 P5_ADDR =  ivec2( 6, 0); \nconst ivec2 P6_ADDR =  ivec2( 7, 0); \nconst ivec2 P7_ADDR =  ivec2( 8, 0); \nconst ivec2 P8_ADDR =  ivec2( 9, 0); \nconst ivec2 P9_ADDR =  ivec2(10, 0); \nconst ivec2 P10_ADDR = ivec2(11, 0); \nconst ivec2 P11_ADDR = ivec2(12, 0); \nconst ivec2 P12_ADDR = ivec2(13, 0); \nconst int PDATA_ADDR_COUNT = 14;\n\nconst ivec2 VV_1     = ivec2(14, 0);   // view vectors\nconst ivec2 VV_2     = ivec2(15, 0);\nconst ivec2 VV_3     = ivec2(16, 0);\n\nconst ivec2[] storeAddr = ivec2[](\n    P0_ADDR,P1_ADDR,P2_ADDR,P3_ADDR,P4_ADDR,P5_ADDR,P6_ADDR,P7_ADDR,P8_ADDR,P9_ADDR,\n    P10_ADDR,P11_ADDR,P12_ADDR);\n    \nvec4 q[PDATA_ADDR_COUNT];\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeDataAddr(buf_pos, addr) ivec2(buf_pos) == addr\n#define storeData(buf_pos, addr,data) if(ivec2(buf_pos) == addr) fragColor = data\n\n// --------------------------------------------------------\n \nvoid downloadData(sampler2D channel,ivec2 address,inout float v1,inout float v2,inout float v3,inout float v4) {\n    vec4 d = fetchData(channel, address);\n    v1 = d.x; v2 = d.y; v3 = d.z; v4 = d.w;\n}    \n\nvoid readStoredData(sampler2D channel) {\n    vec4 d,sd = texelFetch(channel, FOCUS_ADDR,0);\n    qd.focus = int(sd.x);\n    qd.displayCount = int(sd.y);\n    qd.viewVector = texelFetch(channel, VV_1,0).xyz;\n    qd.sideVector = texelFetch(channel, VV_2,0).xyz;\n    qd.topVector  = texelFetch(channel, VV_3,0).xyz;\n    \n   for(int i=0;i< PDATA_ADDR_COUNT;++i)\n       q[i] = texelFetch(channel,storeAddr[i],0);\n}\n\n// ========================================================================\n// visit: https://www.shadertoy.com/view/mdsSD7\n\nconst int maxStringLength = 32;\nconst ivec2 cNl    = ivec2(-1, -1);\nconst ivec2 cSp    = ivec2( 0, 13);\nconst ivec2 cPlus  = ivec2(11, 13);\nconst ivec2 cMinus = ivec2(13, 13);\nconst ivec2 cDot   = ivec2(14, 13);\n\nconst ivec2[10] Digits = ivec2[10]\n(\n    ivec2(0, 12), ivec2(1, 12), ivec2(2, 12), ivec2(3, 12), ivec2(4, 12), \n    ivec2(5, 12), ivec2(6, 12), ivec2(7, 12), ivec2(8, 12), ivec2(9, 12) \n);\n#define chd(name, index) const ivec2 name = Digits[index];\nchd(c0,  0) chd(c1,  1) chd(c2,  2) chd(c3,  3) chd(c4,  4)\nchd(c5,  5) chd(c6,  6) chd(c7,  7) chd(c8,  8) chd(c9,  9)\n\nconst ivec2[26] Uppercase = ivec2[26]\n(\n    ivec2( 1, 11), ivec2( 2, 11), ivec2( 3, 11), ivec2( 4, 11), ivec2( 5, 11), \n    ivec2( 6, 11), ivec2( 7, 11), ivec2( 8, 11), ivec2( 9, 11), ivec2(10, 11), \n    ivec2(11, 11), ivec2(12, 11), ivec2(13, 11), ivec2(14, 11), ivec2(15, 11), \n    ivec2( 0, 10), ivec2( 1, 10), ivec2( 2, 10), ivec2( 3, 10), ivec2( 4, 10), \n    ivec2( 5, 10), ivec2( 6, 10), ivec2( 7, 10), ivec2( 8, 10), ivec2( 9, 10),\n    ivec2(10, 10) \n);\n#define chu(name, index) const ivec2 name = Uppercase[index];\nchu(cA,  0) chu(cB,  1) chu(cC,  2) chu(cD,  3) chu(cE,  4)\nchu(cF,  5) chu(cG,  6) chu(cH,  7) chu(cI,  8) chu(cJ,  9)\nchu(cK, 10) chu(cL, 11) chu(cM, 12) chu(cN, 13) chu(cO, 14)\nchu(cP, 15) chu(cQ, 16) chu(cR, 17) chu(cS, 18) chu(cT, 19)\nchu(cU, 20) chu(cV, 21) chu(cW, 22) chu(cX, 23) chu(cY, 24)\nchu(cZ, 25)\n\nconst ivec2[26] Lowercase = ivec2[26]\n(\n    ivec2( 1,  9), ivec2( 2,  9), ivec2( 3,  9), ivec2( 4,  9), ivec2( 5,  9), \n    ivec2( 6,  9), ivec2( 7,  9), ivec2( 8,  9), ivec2( 9,  9), ivec2(10,  9), \n    ivec2(11,  9), ivec2(12,  9), ivec2(13,  9), ivec2(14,  9), ivec2(15,  9), \n    ivec2( 0,  8), ivec2( 1,  8), ivec2( 2,  8), ivec2( 3,  8), ivec2( 4,  8), \n    ivec2( 5,  8), ivec2( 6,  8), ivec2( 7,  8), ivec2( 8,  8), ivec2( 9,  8),\n    ivec2(10,  8) \n);\n#define chl(name, index) const ivec2 name = Lowercase[index];\nchl(ca,  0) chl(cb,  1) chl(cc,  2) chl(cd,  3) chl(ce,  4)\nchl(cf,  5) chl(cg,  6) chl(ch,  7) chl(ci,  8) chl(cj,  9)\nchl(ck, 10) chl(cl, 11) chl(cm, 12) chl(cn, 13) chl(co, 14)\nchl(cp, 15) chl(cq, 16) chl(cr, 17) chl(cs, 18) chl(ct, 19)\nchl(cu, 20) chl(cv, 21) chl(cw, 22) chl(cx, 23) chl(cy, 24)\nchl(cz, 25)\n\nstruct String {\n    ivec2[maxStringLength] chars;\n    int count;\n};\n\n#define setString(string, n, contents) {\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n#define declString(string, n, contents)\\\nString string;\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n\nstruct Font {\n    vec2 texSize;\n    vec2 charSize;\n    vec2 ct;\n};\n\n#define setFont(ff,c,t) ff.charSize = c; ff.texSize = t; ff.ct = c/t;\n\nstruct TextCursor {\n    vec2 startPos;\n    ivec2 coord;\n    Font font;\n    vec4 color;\n    vec2 charSize;\n    vec2 charSpace;\n    int pageWidth;\n    vec2 fragCoord;\n    vec2 outUV;\n    vec4 outColor;\n};\n\nvec4 getFontCharRect(in Font f, ivec2 char) {\n    return vec4(char, char+ivec2(1)) * f.ct.xyxy;\n}\n\nvec4 getCharScreenRect(in TextCursor t) {\n    vec2 leftTop = t.startPos + t.charSpace * vec2(t.coord.x, -t.coord.y);\n    vec2 rightBottom = leftTop + t.charSize * vec2(1, -1);    \n    return vec4(leftTop.x, rightBottom.y, rightBottom.x, leftTop.y);\n}\n\nvoid updateOutUV(ivec2 char, inout TextCursor t) {\n    vec4 fontRect = getFontCharRect(t.font, char);\n    vec4 screenRect = getCharScreenRect(t);\n    vec2 screenRectUV = (t.fragCoord - screenRect.xy) / (screenRect.zw - screenRect.xy);\n    \n    if(clamp(screenRectUV, vec2(0), vec2(1)) != screenRectUV) return;    \n    t.outUV = screenRectUV * (fontRect.zw - fontRect.xy) + fontRect.xy;\n    t.outColor = t.color;\n}\n\nvoid incrementCursor(inout TextCursor t){\n    t.coord.x += 1;\n    if(t.coord.x >= t.pageWidth) {\n        t.coord.x = 0;\n        t.coord.y += 1;\n    }\n}\n\nvoid newlineCursor(inout TextCursor t) {\n    t.coord.x = 0;\n    t.coord.y += 1;\n}\n\nvoid printChar(ivec2 char, inout TextCursor t) {\n    if(char == cNl) {\n        newlineCursor(t);\n        return;\n    }\n    \n    updateOutUV(char, t);\n    incrementCursor(t);\n}\n\nvoid printString(String s, inout TextCursor t) {\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n        printChar(s.chars[i], t);\n}\n\nvoid printInt(int val, inout TextCursor t) {\n    if(val < 0) {\n        printChar(cMinus, t);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    for(;;) {\n        digits[count++] = val % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        val /= 10;\n        \n        if(val == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n        printChar(Digits[digits[i]], t);\n}\n\nvoid printFloat(float val, inout TextCursor t) {\n    if(val < 0.0) {\n        printChar(cMinus, t);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    int iVal = int(val);\n    val -= float(iVal);\n    \n    for(;;) {\n        digits[count++] = iVal % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        iVal /= 10;\n        \n        if(iVal == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n        printChar(Digits[digits[i]], t);\n    printChar(cDot, t);\n        \n    const int maxDecimalCount = 4;\n    for(int i = 0; i < maxDecimalCount; i++) {\n        val *= 10.0;\n        \n        int digit = int(val);\n        val -= float(digit);\n        \n        printChar(Digits[digit], t);\n        \n        if(val <= 0.0)\n            break;\n    }\n}\n\nvoid drawText(TextCursor t, sampler2D fontTexture, inout vec4 fragColor) {\n    if(length(t.outColor) > 0.) {\n        if(texture(fontTexture, t.outUV).r < 0.2)\n            fragColor = vec4(0.);  // background\n        else\n            fragColor = t.outColor;\n    }\n        \n}\n\n// --------------------------------------------------------\n// keyboard: https://www.shadertoy.com/view/lsXGzf\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_ALT   = 18;\nconst int KEY_PGUP  = 33;\nconst int KEY_PGDN  = 34;\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid initializeStorage(inout vec4 O,vec2 U) {\n    if (storeDataAddr(U, FOCUS_ADDR)) {\n        O = vec4(0.,20.,0.,0);   // displayCount init\n        return;\n    }\n    \n    int pIndex = 0;\n    for(int i=0;i<PDATA_ADDR_COUNT;++i) {\n        if(storeDataAddr(U, storeAddr[i])) {\n            O = vec4(0.);\n            if(pIndex+0 < PDATA_SIZE) O.x = pData[pIndex+0].start;\n            if(pIndex+1 < PDATA_SIZE) O.y = pData[pIndex+1].start;\n            if(pIndex+2 < PDATA_SIZE) O.z = pData[pIndex+2].start;\n            if(pIndex+3 < PDATA_SIZE) O.w = pData[pIndex+3].start;\n        }\n        \n        pIndex += 4;\n    }\n}\n\n// --------------------------------------------------------\n// determine these values as seldom as possible to save work for image shader\n\nvoid updateViewVectors(inout vec4 O,vec2 U) {\n    if (storeDataAddr(U,VV_1) || storeDataAddr(U,VV_2) || storeDataAddr(U,VV_3)) {\n        vec3 viewVector = normalize(fetchData(iChannel0, P5_ADDR).xyz);  // aim\n        vec3 sideVector = vec3(0.0, 1.0, 0.0);\n        sideVector = cross(sideVector,viewVector);\n        sideVector = normalize(sideVector);\n        vec3 topVector = viewVector;\n        topVector = cross(topVector,sideVector);\n        \n        if(storeDataAddr(U,VV_1)) O = vec4(viewVector,1.);\n        if(storeDataAddr(U,VV_2)) O = vec4(sideVector,1.);\n        if(storeDataAddr(U,VV_3)) O = vec4(topVector,1.);\n    }\n}\n\n// --------------------------------------------------------\n// keyboard: https://www.shadertoy.com/view/lsXGzf\n\nbool keyClick(int ascii) {\n\treturn (texture(iChannel1,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,0), 0).x != 0.);\n}\n\nbool getKeyClick(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,1), 0).x != 0.);\n}\n\nvoid acceleratedValue(inout float value) {\n    bool aKey = getKeyState(65);\n    bool zKey = getKeyState(90);\n    \n    if(aKey && zKey) value *= 50.; else\n    if(aKey) value *= 0.1; else\n    if(zKey) value *= 10.0;    \n}\n\n// --------------------------------------------------------\n\nvec4[PDATA_ADDR_COUNT] memory;\n \nbool alterFocusedVariable(int focus,int axis) {\n    if(focus > PDATA_SIZE-1) return false;\n    float changeAmount = 0.;\n    int focusIndex = focus / 4;  // memory index\n    int focusField = focus % 4;  // x,y,z,w field within\n\n    if(getKeyClick(48)) {  // '0' sets value to 0.\n        memory[focusIndex][focusField] = 0.;\n        changeAmount = 1.;   // so function returns true\n    }\n    else {\n        if(getKeyState(69)) { // 'E'\n            changeAmount = sin(iTime) * 0.001;\n        }\n        else {\n            if(axis == 0) { // arrow keys affect only focused variable \n                if(getKeyState(KEY_LEFT))  changeAmount = -pData[focus].delta; else\n                if(getKeyState(KEY_RIGHT)) changeAmount = +pData[focus].delta;\n            }\n\n            // mouse affects focused variable and also next one --------------\n            if(iMouse.z > 0.0) { // left mouse button down\n                vec2 delta = (iMouse.xy - abs(iMouse.zw)) * 0.01 * pData[focus].delta;\n                if(axis == 0) changeAmount = delta.x;\n                if(axis == 1) changeAmount = -delta.y; // flip Y axis\n             }\n        }\n\n        if(changeAmount != 0.) {\n            acceleratedValue(changeAmount);\n            memory[focusIndex][focusField] += changeAmount;\n            memory[focusIndex][focusField] = clamp(memory[focusIndex][focusField],pData[focus].vmin,pData[focus].vmax);\n        }\n    }\n           \n    return changeAmount != 0.;\n}\n\n// --------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.); \n    if(fragCoord.x > 20.0 || fragCoord.y > 1.0) return; // skip unused storage locations\n    \n    if(iFrame < 10 || keyClick(32)) {  // reset settings on coldstart or <Spc> keypress\n        initializeStorage(fragColor, fragCoord);\n        return; \n    }\n           \n    updateViewVectors(fragColor, fragCoord);\n    \n    // ==========================================================       \n    // keyboard & mouse alter focused data (mouse also affects next entry) ---------\n           \n    // fetch current values\n    for(int i=0;i<PDATA_ADDR_COUNT;++i)\n        if (storeDataAddr(fragCoord, storeAddr[i])) \n            memory[i] = fetchData(iChannel0, storeAddr[i]);\n\n    bool resetDisplayCount = false; \n    int focus = int(fetchData(iChannel0, FOCUS_ADDR).x);\n\n    //-------------\n    // if <Alt><Shift> alter target position.xy regardless of focus    \n    if(getKeyState(KEY_SHIFT) && getKeyState(KEY_ALT)) \n        focus = 21;\n    else\n    \n    // if <Shift> alter camera position.xy regardless of focus\n    if(getKeyState(KEY_SHIFT)) \n        focus = 18;\n    //-------------\n    \n    if(alterFocusedVariable(focus,  0)) resetDisplayCount = true;\n    if(alterFocusedVariable(focus+1,1)) resetDisplayCount = true;\n    \n    // output possibly altered values0-----------\n    for(int i=0;i<PDATA_ADDR_COUNT;++i)\n        if (storeDataAddr(fragCoord, storeAddr[i])) \n            fragColor = memory[i];\n            \n    // ==========================================================       \n\n    // alter focus.  update displayCount. toggle animationEnable --------\n    if (storeDataAddr(fragCoord, FOCUS_ADDR)) {\n        fragColor = fetchData(iChannel0, FOCUS_ADDR);\n        float focusChange = 0.;\n        if(getKeyClick(KEY_UP))   focusChange = -1.;\n        if(getKeyClick(KEY_DOWN)) focusChange = +1.;\n        if(getKeyClick(KEY_PGUP)) focusChange = -5.;\n        if(getKeyClick(KEY_PGDN)) focusChange = +5.;\n\n        if(focusChange == 0. && (iFrame % 12 == 0)) { // slow down auto repeat of up/dn arrows\n            if(getKeyState(KEY_UP))   focusChange = -1.;\n            if(getKeyState(KEY_DOWN)) focusChange = +1.;\n        }\n\n        if(focusChange != 0.) {        \n            //skip past UNUSED rows\n            while(true) {\n                fragColor.x += focusChange;\n                if(fragColor.x < 0.0) fragColor.x = float(PDATA_SIZE-1);\n                if(fragColor.x >= float(PDATA_SIZE)) fragColor.x = 0.0;\n                \n                if(pData[int(fragColor.x)].start != UNUSED) break;\n            }\n            \n            resetDisplayCount = true; \n        }\n        \n        // q.displayCount. so widget display times out \n        if(resetDisplayCount) fragColor.y = iFrameRate * 0.5; else\n        if(--fragColor.y < 0.0) fragColor.y = 0.0;  \n    }   \n}\n","name":"Buffer A","description":"","type":"buffer"}]}