{"ver":"0.1","info":{"id":"fdVfW1","date":"1658111557","viewed":221,"name":"MarbleEgg_853d","username":"harry7557558","description":"A quick shader inspired by the [url=https://www.google.com/search?q=perlin+noise+vase&tbm=isch]Perlin noise vase[/url]. Combine two of my previous physically based path tracing shaders.","likes":13,"published":1,"flags":32,"usePreview":1,"tags":["sss","scattering","marble","emission","cooktorrance","skull","egg","ggx","henyeygreenstein","glassball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Combine two of my previous path tracing shaders to render a marble egg.\n\n// I was inspired by the Perlin noise vase.\n\n// A cheap sine-based noise produces an unintentional skull-like pattern,\n// which I didn't notice after playing with it for a while.\n\n\n// Stuff in Buffer A\n\nvoid mainImage(out vec4 c, in vec2 g) {\n    c = texelFetch(iChannel0, ivec2(g), 0);\n}\n\n\n// (Without this comment, you may or may not notice that\n//  the marble and the floor is emissive.\n\n// The marble's reflection has a blue-green tint.)\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Fork of \"isp-glassball-11-mix\" by harry7557558. https://shadertoy.com/view/NscXRj\n// 2022-07-18 00:12:26\n\n\n#define PI 3.1415926\n#define ZERO min(iTime, 0.)\n\n\n// random number generator\nuint rand_seed = 0u;\nuint randu() { return rand_seed = rand_seed * 1664525u + 1013904223u; }\nfloat randf() { return float(randu()) * (1./4294967296.); }\n\n\n// intersection function\nbool intersectEllipsoid(vec3 r, vec3 ro, vec3 rd, inout float t, inout vec3 n) {\n\tfloat a = dot(rd/r,rd/r);\n\tfloat b = -dot(rd/r,ro/r);\n\tfloat c = dot(ro/r,ro/r)-1.0;\n\tfloat delta = b*b-a*c;\n\tif (delta < 0.0) return false;\n\tdelta = sqrt(delta);\n\tfloat t1 = (b-delta)/a, t2 = (b+delta)/a;\n\tif (t1>t2) { float t=t1; t1=t2; t2=t;}\n\tif (t1>t || t2<0.) return false;\n\tt = t1>0. ? t1 : t2;\n\tn = normalize((ro+rd*t)/(r*r));\n\treturn true;\n}\n\n\n// scattering / importance sampling functions\n\n// Lambert\nvec3 sampleCosWeighted(vec3 n) {\n    vec3 u = normalize(cross(n, vec3(1.2345, 2.3456, -3.4561)));\n    vec3 v = cross(u, n);\n    float rn = randf();\n    float an = 2.0*PI*randf();\n    vec2 rh = sqrt(rn) * vec2(cos(an), sin(an));\n    float rz = sqrt(1. - rn);\n    return rh.x * u + rh.y * v + rz * n;\n}\n\n// refractive\nvec3 sampleFresnelDielectric(vec3 rd, vec3 n, float n1, float n2) {\n    float eta = n1 / n2;\n    float ci = -dot(n, rd);\n    if (ci < 0.0) ci = -ci, n = -n;\n    float ct = 1.0 - eta * eta * (1.0 - ci * ci);\n    if (ct < 0.0) return rd + 2.0*ci*n;\n    ct = sqrt(ct);\n    float Rs = (n1 * ci - n2 * ct) / (n1 * ci + n2 * ct);\n    float Rp = (n1 * ct - n2 * ci) / (n1 * ct + n2 * ci);\n    float R = 0.5 * (Rs * Rs + Rp * Rp);\n    return randf() > R ?\n        rd * eta + n * (eta * ci - ct)  // refraction\n        : rd + 2.0*ci*n;  // reflection\n}\n\n// phase functions\nvec3 sampleUniformSphere() {\n    float u = 2.0*PI*randf();\n    float v = 2.0*randf()-1.0;\n    return vec3(vec2(cos(u), sin(u))*sqrt(1.0-v*v), v);\n}\nvec3 sampleHenyeyGreenstein(vec3 wi, float g) {\n    if (g == 0.0) return sampleUniformSphere();\n    if (g >= 1.0) return wi;\n    if (g <= -1.0) return -wi;\n    float us = randf();\n    float vs = 2.0*PI*randf();\n    float z = (1.0+g*g-pow((1.0-g*g)/(2.0*g*(us+(1.0-g)/(2.0*g))),2.0))/(2.0*g);\n    vec2 xy = vec2(cos(vs), sin(vs)) * sqrt(1.0-z*z);\n    vec3 u = normalize(cross(wi, vec3(1.2345, 2.3456, -3.4561)));\n    vec3 v = cross(u, wi);\n    vec3 wo = normalize(xy.x*u + xy.y*v + z*wi);\n    return wo;\n}\n\n\n// Cook-Torrance BRDF - https://www.shadertoy.com/view/sddXWj\n\nfloat sampleGgxImportance(in vec3 wi, in float alpha, out vec3 wo) {\n    float su = 2.0*PI*randf();\n    float sv = randf();\n    //sv = acos(sqrt((1.0-sv)/((alpha*alpha-1.)*sv+1.)));\n    sv = atan(alpha*sqrt(sv/(1.0-sv)));\n    vec3 h = vec3(sin(sv)*vec2(cos(su),sin(su)), cos(sv));\n    wo = -(wi-2.0*dot(wi,h)*h);\n    return wo.z<0. ? 0. : 4.0*dot(wi, h);\n}\n\nvec3 sampleCookTorrance(\n    vec3 wi, vec3 n,\n    float alpha,  // roughness\n    float f0,  // ratio of reflection along the normal\n    float lambertian,  // ratio of lambertian coefficient\n    vec3 albedo,\n    inout vec3 m_col\n    ) {\n\n    if (randf() < lambertian) {\n        vec3 wo = sampleCosWeighted(n);\n        m_col *= albedo;\n        return wo;\n    }\n\n    vec3 u = normalize(cross(n, vec3(1.2345, 2.3456, -3.4561)));\n    vec3 v = cross(u, n);\n    wi = vec3(dot(wi, u), dot(wi, v), dot(wi, n));\n    vec3 wo, m;  // out and half vector\n\n    // GGX divided by PDF\n    float D = sampleGgxImportance(wi, alpha, wo);\n    m = normalize(wi+wo);\n\n    // Geometry\n    float tan2_theta_i = (1.0-wi.z*wi.z)/(wi.z*wi.z);\n    float tan2_theta_o = (1.0-wo.z*wo.z)/(wo.z*wo.z);\n    float lambda_i = 0.5*(sqrt(1.0+alpha*alpha*tan2_theta_i)-1.0);\n    float lambda_o = 0.5*(sqrt(1.0+alpha*alpha*tan2_theta_o)-1.0);\n    float G = 1.0/(1.0+lambda_i+lambda_o);\n\n    // Fresnel\n    float F = f0 + (1.0-f0)*pow(1.0-dot(wi, m), 5.0);\n\n    // Put all together\n    float Fr = D*G*F / (4.0*wi.z*wo.z+1e-4);\n    float Fr_cos = Fr * wo.z;  // wo is the direction of light in path tracing\n    m_col *= Fr_cos * albedo;\n    return wo.x * u + wo.y * v + wo.z * n;\n}\n\n\n// define materials\nconst int mat_none = -1;\nconst int mat_background = 0;\nconst int mat_ground = 1;\nconst int mat_refractive = 2;\n\n\n// subsurface scattering - https://shadertoy.com/view/NscXRj\n\nvec4 mapMarbleTexture(vec3 p) {\n    p -= vec3(0, 0, 1);\n    for (float i=-2.; i<=6.; i++) {\n        if (i==1.||i==2.) continue;\n        float k = exp2(i);\n        p += 0.5*cos(k*p.zxy-i)/k;\n    }\n    float k = 1.0-0.9*pow(0.5+0.5*sin(2.*dot(p,vec3(10,10,8))),40.0);\n    return vec4(k,k,k,1);\n}\nvoid calcAbsorb(in vec3 p, out vec3 emi, out vec3 tabs, out vec3 sabs, out float k, out float g) {\n    // green-blue emission\n    emi = 0.15*mix(vec3(0.0,1.0,0.2), vec3(0.0,0.2,1.0), 1.0/(1.0+exp(-p.y)));\n    // volume absorption, zero\n    tabs = vec3(0.0);\n    // scattering absorption, black/white\n    sabs = mapMarbleTexture(p).xyz;\n    // scattering opacity\n    k = 40.0;\n    // backward scattering 0.5\n    g = -0.5;\n}\n\nvoid calcScatter(in vec3 ro, inout vec3 rd,\n        inout float mt, inout vec3 m_col, out vec3 m_emi, out int material, inout vec3 min_n) {\n    float p = 1.0, hit_p = randf();\n    float dt = 0.01;\n    m_emi = vec3(0.0);\n    for (float t = 1e-4; t < mt-dt; t += dt) {\n        vec3 emi, tabs, sabs; float k, g;\n        calcAbsorb(ro + rd * (t+0.5*dt), emi, tabs, sabs, k, g);\n        float dp = exp(-k*dt);\n        if (p * dp < hit_p) {\n            dt *= log(p/hit_p)/k;\n            mt = t + dt;\n            rd = sampleHenyeyGreenstein(rd, g);\n            m_col *= sabs * exp(-tabs*dt);\n            material = mat_none;\n            min_n = vec3(0.0);\n            return;\n        }\n        p *= dp;\n        m_col *= exp(-tabs*dt);\n        m_emi += m_col * emi * dt;\n    }\n    material = mat_refractive;\n}\n\n\n// path tracing\n\nvec3 mainRender(vec3 ro, vec3 rd) {\n\n    vec3 m_col = vec3(1.0), t_col = vec3(0.0), col;\n    bool is_inside = false;\n\n    for (int iter = int(ZERO); iter < 128; iter++) {\n        ro += 1e-4f*rd;\n\n        vec3 n, min_n;\n        float t, min_t = 1e12;\n        vec3 min_ro = ro, min_rd = rd;\n        vec3 min_emi = vec3(0.0);\n        int material = mat_background;\n\n        // plane\n        t = -ro.z / rd.z;\n        if (t > 0.0) {\n            min_t = t, min_n = vec3(0, 0, 1);\n            min_ro = ro + rd * t, min_rd = rd;\n            col = 0.5*vec3(0.9, 0.95, 0.98) / (0.1*dot(min_ro.xy,min_ro.xy)+1.0);\n            material = mat_ground;\n        }\n\n        // marble\n        t = min_t;\n        if (intersectEllipsoid(vec3(0.8,1.1,0.8), ro-vec3(0,0,0.8), rd, t, n)) {\n            min_t = t, min_n = n;\n            if (is_inside) {\n                col = vec3(1.0);\n                min_rd = rd;\n                calcScatter(ro, min_rd, min_t, col, min_emi, material, min_n);\n                min_ro = ro + rd * min_t;\n            }\n            else {\n                min_ro = ro + rd * t, min_rd = rd;\n                col = vec3(1.0);\n                material = mat_refractive;\n            }\n        }\n\n        // update ray\n        if (material == mat_background) {\n            if (iter==0) return vec3(0.0);\n            col = 2.0 * texture(iChannel1, rd.yzx).xyz;\n            return m_col * col + t_col;\n        }\n        ro = min_ro, rd = min_rd;\n        min_n = dot(rd, min_n) < 0. ? min_n : -min_n;  // ray hits into the surface\n        if (material == mat_ground) {  // cook-torrance\n            rd = sampleCookTorrance(-rd, min_n, 0.05, 0.8, 0.1, 2.0*col, col);\n            t_col += m_col * vec3(0.2)*col*max(dot(rd,min_n),0.0);  // make it glow a little\n        }\n        else if (material == mat_refractive) {  // steel ball\n            vec2 eta = is_inside ? vec2(1.5, 1.0) : vec2(1.0, 1.5);\n            rd = sampleFresnelDielectric(rd, min_n, eta.x, eta.y);\n        }\n        m_col = m_col * col;\n        t_col += min_emi;\n        if (dot(rd, min_n) < 0.0) {\n            is_inside = !is_inside;\n        }\n    }\n    return m_col + t_col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // set random seed\n    vec3 p3 = fract(fragCoord.xyx*1.1031);\n    p3 += dot(p3, p3.zxy + 31.32);\n    float h = fract((p3.x + p3.y) * p3.z);\n    rand_seed = uint(1048576.*h)+uint(iFrame);\n\n    // camera\n    float rx = iMouse.z==0.?0.25:1.8*(iMouse.y/iResolution.y)-0.1;\n    float rz = iMouse.z==0.?0.5:-iMouse.x/iResolution.x*4.0*3.14;\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n    vec3 ro = 10.0*w + vec3(0, 0, 0.7);\n    vec2 uv = 2.0*(fragCoord.xy+vec2(randf(),randf())-0.5)/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 3.0*length(iResolution.xy));\n    rd = normalize(rd);\n\n    // accumulate pixel color\n    vec3 col = mainRender(ro, rd);\n    vec4 rgbn = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (iMouse.z>0.) rgbn.w = 0.0;\n    fragColor = vec4((rgbn.xyz*rgbn.w + col)/(rgbn.w+1.0), rgbn.w+1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}