{"ver":"0.1","info":{"id":"4d2cWd","date":"1495084406","viewed":16584,"name":"Splitting DNA","username":"BigWIngs","description":"DNA. See comments for details. Hope you like!","likes":158,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","dna","molecule"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Mlf3WB","filepath":"https://soundcloud.com/free-tracks-downloads/gus-gus-selfoss-deepfunks","previewfilepath":"https://soundcloud.com/free-tracks-downloads/gus-gus-selfoss-deepfunks","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Splitting DNA by Martijn Steinrucken aka BigWings - 2017\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Its still a little slow. I tried a bunch of things to optimize:\n// Using raytracing, instead of marching:  works, is significantly faster but I couldn't get rid of artifacts. \n// Using bounding volumes: makes it a little bit faster, though not nearly as much as I had hoped.\n// Only calculating the color once in the end: should save a ton of mix-es, not noticably faster\n// Skipping to the next strand when marching away from current one: works, makes it a little faster\n// Mirroring the backbone: doesn't have any noticable effect\n//\n// Took me a loong time to figure out the atomic structure of the bases, its not easy to figure \n// out from 2d pictures, I might very well have made a mistake.\n//\n// Use the mouse to look around a little bit.\n//\n// Anyways, worked on this for too long already, gotta ship it. Hope you like!\n\n\n#define INVERTMOUSE -1.\n\n// comment out to see one basepair by itself\n#define STRANDS\n\n#define MAX_INT_STEPS 100\n\n#define MIN_DISTANCE 0.1\n#define MAX_DISTANCE 1000.\n#define RAY_PRECISION .1\n\n#define OPTIMIZED\n#define USE_BOUNDING_VOLUMES\n// set to -1 to see bounding spheres\n#define SHOW_BOUNDING_VOLUMES 1.  \n\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,w) S(x-z, x+z, w)*S(y+z, y-z, w)\n#define sat(x) clamp(x,0.,1.)\n#define SIN(x) sin(x)*.5+.5\n\nfloat smth = .6;\nfloat hr = 1.;\t\t\t\t\t// radii of atoms\nfloat nr = 2.264;\nfloat cr = 2.674;\nfloat or = 2.102;\nfloat pr = 3.453;\n\nvec3 hc = vec3(1.);\t\t\t\t// colors of atoms\nvec3 nc = vec3(.1, .1, 1.);\nvec3 cc = vec3(.1);\nvec3 oc = vec3(1., .1, .1);\nvec3 pc = vec3(1., .75, .3);\n\nconst vec3 lf=vec3(1., 0., 0.);\nconst vec3 up=vec3(0., 1., 0.);\nconst vec3 fw=vec3(0., 0., 1.);\n\nconst float halfpi = 1.570796326794896619;\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\n\nvec3 bg = vec3(.1, .5, 1.); // global background color\n\nfloat L2(vec3 p) {return dot(p, p);}\nfloat L2(vec2 p) {return dot(p, p);}\n\nfloat N1( float x ) { return fract(sin(x)*5346.1764); }\nfloat N2(float x, float y) { return N1(x + y*23414.324); }\n\nfloat N3(vec3 p) {\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nvec3 N31(float p) {\n    //  3 out, 1 in... DAVE HOSKINS\n   vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct camera {\n    vec3 p;\t\t\t// the position of the camera\n    vec3 forward;\t// the camera forward vector\n    vec3 left;\t\t// the camera left vector\n    vec3 up;\t\t// the camera up vector\n\t\n    vec3 center;\t// the center of the screen, in world coords\n    vec3 i;\t\t\t// where the current ray intersects the screen, in world coords\n    ray ray;\t\t// the current ray: from cam pos, through current uv projected on screen\n    vec3 lookAt;\t// the lookat point\n    float zoom;\t\t// the zoom factor\n};\n\nstruct de {\n    // data type used to pass the various bits of information used to shade a de object\n\tfloat d;\t// distance to the object\n    float m; \t// material\n    vec3 col;\n    \n    vec3 id;\n    float spread;\n    // shading parameters\n    vec3 pos;\t\t// the world-space coordinate of the fragment\n    vec3 nor;\t\t// the world-space normal of the fragment\n    vec3 rd;\n    float fresnel;\t\n};\n    \nstruct rc {\n    // data type used to handle a repeated coordinate\n\tvec3 id;\t// holds the floor'ed coordinate of each cell. Used to identify the cell.\n    vec3 h;\t\t// half of the size of the cell\n    vec3 p;\t\t// the repeated coordinate\n    vec3 c;\t\t// the center of the cell, world coordinates\n};\n    \nrc Repeat(vec3 pos, vec3 size) {\n\trc o;\n    o.h = size*.5;\t\t\t\t\t\n    o.id = floor(pos/size);\t\t\t// used to give a unique id to each cell\n    o.p = mod(pos, size)-o.h;\n    o.c = o.id*size+o.h;\n    \n    return o;\n}\n    \ncamera cam;\n\n\nvoid CameraSetup(vec2 uv, vec3 position, vec3 lookAt, float zoom) {\n\t\n    cam.p = position;\n    cam.lookAt = lookAt;\n    cam.forward = normalize(cam.lookAt-cam.p);\n    cam.left = cross(up, cam.forward);\n    cam.up = cross(cam.forward, cam.left);\n    cam.zoom = zoom;\n    \n    cam.center = cam.p+cam.forward*cam.zoom;\n    cam.i = cam.center+cam.left*uv.x+cam.up*uv.y;\n    \n    cam.ray.o = cam.p;\t\t\t\t\t\t// ray origin = camera position\n    cam.ray.d = normalize(cam.i-cam.p);\t// ray direction is the vector from the cam pos through the point on the imaginary screen\n}\n\nfloat remap01(float a, float b, float t) { return (t-a)/(b-a); }\n\n\n// DE functions from IQ\n// https://www.shadertoy.com/view/Xds3zN\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 smin2( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return vec2(mix( b, a, h ) - k*h*(1.0-h), h);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, vec3 pos, float s ) { return (length(p-pos)-s)*.9; }\n\n\nvec3 background(vec3 r) {\n\tfloat y = pi*0.5-acos(r.y);  \t\t// from -1/2pi to 1/2pi\t\t\n    \n    return bg*(1.+y);\n}\n\nvec4 Adenine(vec3 p, float getColor) {\n   #ifdef USE_BOUNDING_VOLUMES\n    float b = sdSphere(p, vec3(29.52, 6.64, 3.04), 11.019);\n    \n    if(b>0.)\n        return vec4(bg, b+SHOW_BOUNDING_VOLUMES);\n    else {\n #endif\n    \n    float h =  sdSphere(p, vec3(22.44, 13.63, 3.04), hr);\n    h = min(h, sdSphere(p, vec3(21.93, 0.28, 3.04), hr));\n    h = min(h, sdSphere(p, vec3(26.08, -1.19, 3.04), hr));\n    h = min(h, sdSphere(p, vec3(39.04, 3.98, 3.04), hr));\n    \n    float n =  sdSphere(p, vec3(23.18, 7.49, 3.04), nr);\n    n = min(n, sdSphere(p, vec3(28.39, 11.95, 3.04), nr));\n    n = min(n, sdSphere(p, vec3(24.43, 0.75, 3.04), nr));\n    n = min(n, sdSphere(p, vec3(32.79, 2.79, 3.04), nr));\n    n = min(n, sdSphere(p, vec3(34.93, 8.83, 3.04), nr));\n    \n    float c =  sdSphere(p, vec3(24.50, 11.22, 3.04), cr);\n    c = min(c, sdSphere(p, vec3(25.75, 4.47, 3.04), cr));\n    c = min(c, sdSphere(p, vec3(29.65, 5.2, 3.04), cr));\n    c = min(c, sdSphere(p, vec3(30.97, 8.93, 3.04), cr));\n    c = min(c, sdSphere(p, vec3(36.06, 5.03, 3.04), cr));\n    \n    \n        vec3 col = vec3(0.);\n        float d;\n\n        if(getColor!=0.) {\n            vec2 i = smin2(h, n, smth);\n            col = mix(nc, hc, i.y);        \n\n            i = smin2(i.x, c, smth);\n            col = mix(cc, col, i.y);\n\n            d = i.x;\n        } else\n            d = smin(c, smin(h, n, smth), smth);\n\n        return vec4(col, d);\n    #ifdef USE_BOUNDING_VOLUMES\n    }\n    #endif\n}\n\nvec4 Thymine(vec3 p, float getColor) {\n\n #ifdef USE_BOUNDING_VOLUMES\n    float b = sdSphere(p, vec3(12.96, 5.55, 3.04), 10.466);\n    \n    if(b>0.)\n        return vec4(bg, b+SHOW_BOUNDING_VOLUMES);\n    else {\n #endif\n    float o =  sdSphere(p, vec3(18.171, -.019, 3.04), or);\n    o = min(o, sdSphere(p, vec3(15.369, 13.419, 3.04), or));\n    \n    float h =  sdSphere(p, vec3(19.253, 7.218, 3.04), hr);\n    h = min(h, sdSphere(p, vec3(12.54, -3.449, 4.534), hr));\n    h = min(h, sdSphere(p, vec3(7.625, -1.831, 4.533), hr));\n    h = min(h, sdSphere(p, vec3(10.083, -2.64, 0.052), hr));\n    \n    float n =  sdSphere(p, vec3(16.77, 6.7, 3.04), nr);\n    n = min(n, sdSphere(p, vec3(10.251, 8.846, 3.04), nr));\n    \n    float c =  sdSphere(p, vec3(10.541, -1.636, 3.04), cr);\n    c = min(c, sdSphere(p, vec3(11.652, 2.127, 3.04), cr));\n    c = min(c, sdSphere(p, vec3(15.531, 2.936, 3.04), cr));\n    c = min(c, sdSphere(p, vec3(9.012, 5.082, 3.04), cr));\n    c = min(c, sdSphere(p, vec3(14.13, 9.655, 3.04), cr));\n    \n\n        vec3 col = vec3(0.);\n        float d;\n\n        if(getColor!=0.) {\n            vec2 i = smin2(h, n, smth);\n            col = mix(nc, hc, i.y);        \n\n            i = smin2(i.x, c, smth);\n            col = mix(cc, col, i.y);\n\n            i = smin2(i.x, o, smth);\n            col = mix(oc, col, i.y);\n\n            d = i.x;\n        } else\n            d = smin(o, smin(c, smin(h, n, smth), smth), smth);\n\n        return vec4(col, d);\n    #ifdef USE_BOUNDING_VOLUMES\n    }\n    #endif\n}\n\n\n\n\nvec4 Cytosine(vec3 p, float getColor) {\n\n #ifdef USE_BOUNDING_VOLUMES\n    float b = sdSphere(p, vec3(14.556, 5.484, 3.227), 10.060);\n    if(b>0.)\n        return vec4(bg, b+SHOW_BOUNDING_VOLUMES);\n    else {\n #endif\n        \n        float c = sdSphere(p, vec3(11.689, 1.946, 3.067), cr);\n        c = min(c, sdSphere(p, vec3(15.577, 2.755, 3.067), cr));\n        c = min(c, sdSphere(p, vec3(14.176, 9.474, 3.067), cr));\n        c = min(c, sdSphere(p, vec3(9.058, 4.9, 3.067), cr));\n\n        float n = sdSphere(p, vec3(18.412, 0.342, 3.067), nr);\n        n = min(n, sdSphere(p, vec3(16.816, 6.519, 3.067), nr));\n        n = min(n, sdSphere(p, vec3(10.297, 8.665, 3.067), nr));\n\n        float h = sdSphere(p, vec3(6.526, 3.015, 3.067), hr);\n        h = min(h, sdSphere(p, vec3(10.61, -1.045, 3.067), hr));\n        h = min(h, sdSphere(p, vec3(18.805, -2.297, 3.067), hr));\n        h = min(h, sdSphere(p, vec3(20.95, 0.584, 3.067), hr));\n\n\n        float o = sdSphere(p, vec3(15.415, 13.237, 3.067), or);\n\n        vec3 col = vec3(1.);\n\n        float d;\n        \n        if(getColor!=0.) {\n            vec2 i = smin2(c, n, smth);\n            col = mix(nc, cc, i.y);        \n\n            i = smin2(i.x, h, smth);\n            col = mix(hc, col, i.y);\n\n            i = smin2(i.x, o, smth);\n            col = mix(oc, col, i.y);\n            \n            d = i.x;\n        } else\n            d = smin(o, smin(h, smin(c, n, smth), smth), smth);\n        \n        return vec4(col, d);\n    #ifdef USE_BOUNDING_VOLUMES\n    }\n    #endif\n}\n\nvec4 Guanine(vec3 p, float getColor) {\n\n #ifdef USE_BOUNDING_VOLUMES\n    float b = sdSphere(p, vec3(29.389, 8.944, 3.227), 12.067);\n    \n    if(b>0.)\n        return vec4(bg, b+SHOW_BOUNDING_VOLUMES);\n    else {\n #endif\n        \n        float c = sdSphere(p, vec3(24.642, 11.602, 3.067), cr);\n        c = min(c, sdSphere(p, vec3(31.111, 9.311, 3.067), cr));\n        c = min(c, sdSphere(p, vec3(29.79, 5.576, 3.067), cr));\n        c = min(c, sdSphere(p, vec3(25.893, 4.854, 3.067), cr));\n        c = min(c, sdSphere(p, vec3(36.19, 5.409, 3.067), cr));\n\n        float n = sdSphere(p, vec3(22.56, 14.31, 3.067), nr);\n        n = min(n, sdSphere(p, vec3(23.32, 7.867, 3.067), nr));\n        n = min(n, sdSphere(p, vec3(28.538, 12.325, 3.067), nr));\n        n = min(n, sdSphere(p, vec3(32.934, 3.164, 3.067), nr));\n        n = min(n, sdSphere(p, vec3(35.07, 9.209, 3.067), nr));\n\n        float h = sdSphere(p, vec3(20.044, 14.723, 3.04), hr);\n        h = min(h, sdSphere(p, vec3(22.852, 16.965, 3.04), hr));\n        h = min(h, sdSphere(p, vec3(20.856, 7.404, 3.067), hr));\n        h = min(h, sdSphere(p, vec3(39.187, 4.352, 3.067), hr));\n\n\n        float o = sdSphere(p, vec3(24.7, 1.893, 3.067), or);\n\n        vec3 col = vec3(1.);\n        \n        float d;\n        \n        if(getColor!=0.) {\n            vec2 i = smin2(c, n, smth);\n            col = mix(nc, cc, i.y);        \n\n            i = smin2(i.x, h, smth);\n            col = mix(hc, col, i.y);\n\n            i = smin2(i.x, o, smth);\n            col = mix(oc, col, i.y);\n            \n            d = i.x;\n        } else\n            d = smin(o, smin(h, smin(c, n, smth), smth), smth);\n        \n        return vec4(col, d);\n    #ifdef USE_BOUNDING_VOLUMES\n    }\n    #endif\n}\n\n\nvec4 Backbone(vec3 p, float getColor) {\n\n #ifdef USE_BOUNDING_VOLUMES\n    float b = sdSphere(p, vec3(0., 7.03, 0.), 10.572);   \n    if(b>0.)\n        return vec4(bg, b+SHOW_BOUNDING_VOLUMES);\n    else {\n #endif       \n        float c = sdSphere(p, vec3(1.391, 8.476, -0.708), cr);\n        c = min(c, sdSphere(p, vec3(5.173, 9.661, -0.708), cr));\n        c = min(c, sdSphere(p, vec3(6.342, 10.028, 3.061), cr));\n        c = min(c, sdSphere(p, vec3(0.222, 8.109, 3.061), cr));\n        c = min(c, sdSphere(p, vec3(0.658, 4.4, 4.8871), cr));\n\n        float h = sdSphere(p, vec3(-5.853, 0., 2.213), hr);\n        h = min(h, sdSphere(p, vec3(5.4512, 12.437, -2.216), hr));\n        h = min(h, sdSphere(p, vec3(6.986, 7.541, -2.216), hr));\n        h = min(h, sdSphere(p, vec3(-1.726, 10.517, 4.39), hr));\n        h = min(h, sdSphere(p, vec3(3.203, 2.519, 4.691), hr));\n        h = min(h, sdSphere(p, vec3(-1.619, 3.162, 3.063), hr));\n\n        float o = sdSphere(p, vec3(-4.918, 1.599, 0.344), or);\n        o = min(o, sdSphere(p, vec3(-1.471, 0.995, -5.1), or));\n        o = min(o, sdSphere(p, vec3(-0.836, 6.288, -1.438), or));\n        o = min(o, sdSphere(p, vec3(3.282, 9.068, 5.391), or));\n        o = min(o, sdSphere(p, vec3(-6.286, 5.299, -4.775), or));\n        \n        float ph = sdSphere(p, vec3(-3.377, 3.544, -2.742), pr);\n\t\t\n        #ifdef STRANDS\n        o = min(o, sdSphere(p, vec3(-6.286, 5.299, 6.558), or));\n        ph = min(ph, sdSphere(p, vec3(-3.377, 3.544, 8.592), pr)); // extra so it tiles better\n        #endif\n        \n        vec3 col = vec3(1.);\n\t\tfloat d;\n        \n        if(getColor!=0.) {\n            vec2 i = smin2(c, h, smth);\n            col = mix(hc, cc, i.y);        \n\n            i = smin2(i.x, o, smth);\n            col = mix(oc, col, i.y);\n\n            i = smin2(i.x, ph, smth);\n            col = mix(pc, col, i.y);\n            \n            d = i.x;\n        } else\n            d = smin(ph, smin(o, smin(c, h, smth), smth), smth);\n        \n        return vec4(col, d);\n  #ifdef USE_BOUNDING_VOLUMES      \n    }\n  #endif  \n}\n\n\n\n\nvec4 map( vec3 p, vec3 id, float spread, float getColor ) {\n    \n    p.z += 2.4;// offset so it tiles better\n    vec4 col;\n    \n    vec3 bp = p;    \n    bp.x = 22.5-bp.x;\n    float side = sign(bp.x);\n    bp.x = 22.5-abs(bp.x)+spread;\n    bp.z = bp.z*side - min(0., side)*5.;\n    vec4 b = Backbone(bp, getColor);\n    \n    vec4 c = vec4(1000.);\n    vec4 g = vec4(1000.);\n    vec3 cp = p;\n    vec3 gp = p;\n    \n    float n = N3(id);\n    \n    if(n<.5) {\n    \tcp.xz = -cp.xz + vec2(46., 6.);\n    \tgp.xz = -gp.xz + vec2(46., 6.);\n    }\n    cp.x += spread;\n    gp.x -= spread;\n    \n    if(mod(floor(n*4.), 2.)==0.) {\n    \tc = Cytosine(cp, getColor);\n    \tg = Guanine(gp, getColor);\n    } else {    \n    \tg = Adenine(gp, getColor);\n    \tc = Thymine(cp, getColor);\n    }\n  \n    col.a = min(b.a, min(c.a, g.a));\n  \n    if(getColor!=0.) {\n        if(col.a==b.a)\n            col.rgb = b.rgb;\t\n        else if(col.a==c.a)\n            col.rgb = c.rgb;\n        else\n            col.rgb = g.rgb;\n    }\n    \n    return col;\n}\n\n\nde castRay( ray r ) {\n    float t = iTime*.3;\n    \n    de o;\n    o.m = -1.0;\n    vec2 cbd = vec2(MIN_DISTANCE, MAX_DISTANCE);\n    vec2 bbd = cbd;\n    \n    vec4 col_pos;\n    \n    vec3 p = vec3(0.);\n    \n    float d = MIN_DISTANCE;\n    rc q;\n    vec3 center = vec3(19.12, 7.09, 3.09);\n    float spread;\n    \n    vec3 grid = vec3(180., 180., 11.331);\n    \n    #ifdef STRANDS\n    for( int i=0; i<MAX_INT_STEPS; i++ ) {\n        p = r.o+r.d*d;\n        float oz = p.z;\n        \n        q = Repeat(p, grid);\n        float sd = length((q.c.xy-center.xy));\n            \n        p.z += t*200.*S(800., 100., sd);\n        float n = N2(q.id.x, q.id.y);\n        \n        p.y += sin(n*twopi + p.z*.003+t)*50.*S(300., 500., sd);\n        \n        q = Repeat(p, grid);\n\t\t\n       \n        float z = oz*.05;\n        float z2 = smax(0., abs(oz*.03)-6., 2.);\n        float s = sin(z2);\n        float c = cos(z2);\n        \n        oz *= .012;\n        spread = max(0., 6.-oz*oz);\n        spread *= spread;\n        spread *= S(250., 1., length(q.id.xy*grid.xy+q.h.xy-r.o.xy));\n            \n        vec3 rC = ((2.*step(0., r.d)-1.)*q.h-q.p)/r.d;\t// ray to cell boundary\n        float dC = min(min(rC.x, rC.y), rC.z)+.01;\t\t// distance to cell just past boundary\n        \n       \n        \n        float dS = MAX_DISTANCE;\n        \n        #ifdef OPTIMIZED\n        vec2 bla = q.p.xy-center.xy;\n        if(dot(bla, r.d.xy)>0. && length(bla)>50.)\t// if we are stepping away from the strand and we are already far enough\n        \tdC = min(rC.x, rC.y)+1.;\t\t\t\t// then we won't hit this strand anymore and we can skip to the next one\n        else {\n            #endif \n             q.p-=center;\n        mat2 m = mat2(c, -s, s, c);\n        q.p.xy *= m;\n        q.p+=center;\n            \n        \tdC = rC.z +.01;\n            dS = map( q.p, q.id, spread, 0. ).a;\n        #ifdef OPTIMIZED\n        } \n        #endif\n        \n            \n        if( dS<RAY_PRECISION || d>MAX_DISTANCE ) break;      \n        \n        d+=min(dS, dC);\t// move to distance to next cell or surface, whichever is closest\n    }\n    \n    #else\n\tq.id = vec3(0.);\n    spread = 0.;\n     for( int i=0; i<MAX_INT_STEPS; i++ ) {\n        p = r.o+r.d*d;\n         \n        col_pos = map( p, vec3(0.), 0., 0. );\n        float dS = col_pos.a;\n        if( dS<RAY_PRECISION || d>MAX_DISTANCE ) break;      \n       \n        d+=dS;\n    }\n    #endif\n    \n    if(d<MAX_DISTANCE) { \n        o.m=1.;\n        o.d = d;\n        o.id = q.id;\n        o.spread = spread;\n        #ifdef STRANDS\n        o.pos = q.p;\n        #else\n        o.pos = p;\n        #endif\n        \n        o.d = d;\n    }\n    return o;\n}\n\nvec4 nmap( de o, vec3 offs ) {\n   \n    return map(o.pos+offs, o.id, o.spread, 0.);\n}\n\nde GetSurfaceProps( de o )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 p = o.pos-eps.yyx;\n    vec4 c = map(p, o.id, o.spread, 1.);\n    o.col = c.rgb;\n    \n    vec3 nor = vec3(\n\t    nmap(o, eps.xyy).a - nmap(o, -eps.xyy).a,\n\t    nmap(o, eps.yxy).a - nmap(o, -eps.yxy).a,\n\t    nmap(o, eps.yyx).a - c.a );\n\to.nor = normalize(nor);\n    \n    return o;\n}\n\nvec3 AtomMat(de o, vec3 rd) {\n    o = GetSurfaceProps( o );\n    \n    vec3 R = reflect(cam.ray.d, o.nor);\n    vec3 ref = background(R);\n    \n    float dif = dot(up, o.nor)*.5+.5;\n    dif = mix(.3, 1., dif);\n    \n\tvec3 col = o.col*dif;\n    \n    float t = iTime*50.+length(o.col)*10.;\n\n    float fresnel = 1.-sat(dot(o.nor, -rd));\n    fresnel = pow(fresnel, .5);\n          \n    \n    \n    #ifdef STRANDS\n    float up = dot(rd, vec3(0., 1., 0.));\n    col = mix(col, ref, fresnel*.5*S(.8, .0, up));\n    col *= S(.9, .2, up);\n    #else  \n    col = mix(col, ref, fresnel*.5);\n    #endif\n    \n    col = mix(col, bg, S(0., 1000., o.d));\n\n    return col;\n}\n\nvec3 render( vec2 uv, ray camRay, float depth ) {\n    // outputs a color\n    \n    bg = background(cam.ray.d);\n    \n    vec3 col = bg;\n    de o = castRay(camRay);\n   \n    if(o.m>0.) {\n        col = AtomMat(o, cam.ray.d);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    uv -= .5;\n    uv.y *= iResolution.y/iResolution.x;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n\tfloat t = iTime;\n    \n   if(m.x==0.&&m.y==0.) m = vec2(.5, .5);\n    \n    \n    #ifdef STRANDS\n    float camDist = -4.;\n    \n    t = t * .2;\n    \n    float y = t*.5;;\n    float x = t;\n    vec3 camPos = vec3(-60.+sin(t)*180., -80.+sin(y)*250., 0.);\n    \n    m -= .5;\n    vec3 pos = vec3(-(cos(x)+m.x)*3., -(cos(y)+m.y)*3., camDist);//*rotX;\n    #else\n    \n    float turn = (.1-m.x)*twopi+t*.0;\n    float s = sin(turn);\n    float c = cos(turn);\n    mat3 rotX = mat3(c,  0., s, 0., 1., 0., s,  0., -c);\n    \n    float camDist = -100.;\n    vec3 camPos = vec3(19., 0., 0.);\n    \n    vec3 pos = vec3(0., INVERTMOUSE*camDist*cos((m.y)*pi), camDist)*rotX;\n    #endif\n    \t\n    CameraSetup(uv, camPos+pos, camPos, 1.);\n    \n    vec3 col = render(uv, cam.ray, 0.);\n   \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}