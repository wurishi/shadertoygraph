{"ver":"0.1","info":{"id":"MsycRV","date":"1522608701","viewed":379,"name":"Electric Hexagons","username":"blackle","description":"hexagons are hard\n\n\nprogrammed during revision 2018","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["glsl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat gradient(vec2 point, vec2 origin, vec2 dir) {\n    return clamp(dot(point - origin, dir) + 0.5, 0.0, 1.0);\n}\n\nfloat plasma(vec2 p, float offset) {\n    vec2 point = p * 2.0;\n    float plsm = 1.0;\n    for(float i = 0.0; i < 30.0; i++) {\n        vec4 rnd = texture(iChannel0, vec2(i*2.0));\n        float t1 = iTime * 0.04 + offset;\n        float t2 = iTime * 0.08 + offset;\n        vec2 origin = vec2(cos(i+t1), sin(i+t1));\n        vec2 dir = vec2(cos(i*3.0 + t2), sin(i*2.0 + t2));\n        plsm = abs(plsm - gradient(point, origin, dir));\n    }\n    return plsm;\n}\n\nvec2 rotate(vec2 point, float angle) {\n    return vec2(  point.x * cos(angle) + point.y * sin(angle),\n                - point.x * sin(angle) + point.y * cos(angle) );\n}\n\nfloat smin( float a, float b, float k )\n{\n    // if (k == 0.0) return min(a,b);\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat hexpart(vec2 p) {\n    vec2 point = p + vec2(0.5, 0.0);\n    float x = point.x - floor(point.x);\n    float fac = 0.289;\n    float yy = point.y*fac + mod(floor(point.x), 2.0)*0.5;\n    float y = yy - floor(yy);\n    return max(abs(x - 0.5) - 0.08, abs(y-0.5)/fac - 0.6);\n}\n\nfloat hexagons(vec2 point) {\n    return smin(smin(\n        hexpart(point),\n        hexpart(rotate(point, 3.141*1.0/3.0)), 0.1),\n        hexpart(rotate(point, 3.141*2.0/3.0)), 0.1\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 framecoords = (fragCoord-iResolution.xy/2.0)/iResolution.yy;\n    vec2 mouse = (iMouse.xy-iResolution.xy/2.0)/iResolution.yy;\n    \n    \n    vec2 uv = rotate(framecoords, cos(iTime*0.054)*5.0+cos(iTime*0.013)*10.0)*(1.0+cos(iTime*0.67)*0.5);\n    uv += vec2(cos(iTime*0.05*2.0), sin(iTime*0.05*3.0))*0.5;\n    \n    float hexmult = 20.0;\n    float hex = hexagons(uv*hexmult);\n    \n    if ( hex < 0.0) {\n        uv += vec2(-0.005,0.005);\n    }\n\t\n    float pls = plasma(uv, 0.0);\n    float plshighlight = pow(pls, 2.0);\n    for (float i = 0.0; i < 2.0; i++) {\n        for (float j = 0.0; j < 2.0; j++) {\n            vec2 coord = vec2(i,j)*2.0 - 1.0;\n            plshighlight += pow(plasma(uv + coord*0.005, 0.0), 2.0);\n        }\n    }\n    plshighlight = 1.0 - pls/sqrt(plshighlight)*2.0;\n\n\n    // Time varying pixel color\n    float col = (1.0-pls)*0.8;\n    col += max(0.0,plshighlight)*0.5;\n    \n    if ( hex < 0.0) {\n        hex += hexagons((uv + vec2(-0.005,0.005))*hexmult);\n        col *= mix(1.0, -hex*5.0, 0.5);\n    }\n    // Output to screen\n    fragColor = vec4(col, 0.04,0.11,0.0);\n}","name":"Image","description":"","type":"image"}]}