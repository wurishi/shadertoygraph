{"ver":"0.1","info":{"id":"4sKyRK","date":"1522609795","viewed":565,"name":"Cenotaph for Soda","username":"blackle","description":"here is cenotaph for soda as a shadertoy shader, since very few people have a linux machine with a decent nvidia card it seems","likes":16,"published":1,"flags":32,"usePreview":1,"tags":["glsl","revision","4kgfx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//NOTE: increase this value to 18 to see how it looked during the party\n//gamma is a bit wonky so it won't be 1:1 to the party version unfortunately\n#define MAXDEPTH 8\n\nstruct Ray\n{\n  vec3 m_origin;\n  vec3 m_direction;\n  vec3 m_point;\n  bool m_intersected;\n  int m_mat;\n  vec3 m_color;\n  vec3 m_attenuation;\n};\n    \nstruct Mat\n{\n    vec3 m_diffuse;\n    vec3 m_reflectance;\n    vec3 m_transparency;\n};\n\nMat mats[2] = Mat[2](\n    Mat(vec3(0.8, 0.2, 0.1), vec3(0.2), vec3(0.1)), //label / cap\n    Mat(vec3(1.0), vec3(0.8), vec3(0.7)) //bottle / grave\n);\n\n//choose good positions...\nvec3 lightdirs[3] = vec3[3](\n    vec3(0.0, 0.5, -1.0),\n    vec3(1.0, -0.5, -1.0),\n    vec3(-1.0, -0.25, -1.0)\n);\n\nvec3 lightcols[3] = vec3[3](\n    vec3(1.0, 1.0, 0.1),\n    vec3(1.0, 0.1, 1.0),\n    vec3(0.1, 1.0, 1.0)\n);\n\nfloat smin( float a, float b, float k )\n{\n    // if (k == 0.0) return min(a,b);\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat distanceToBottleCurve(vec2 point) {\n    return point.y-0.1*sin(point.x*2.5 + 0.6) + 0.05*sin(5.0*point.x) + 0.04*sin(7.5*point.x);\n}\n\nfloat tombstone(vec3 point, float w, float l, float h, float s, float s2) {\n    vec3 ptabs = abs(point);\n    return -smin(smin(w - ptabs.x, h - ptabs.z, s2), l - ptabs.y, s);\n}\n\nfloat cylinder(vec3 point, float r, float h, float s) {\n    return -smin(-(length(point.xy) - r), -(abs(point.z) - h), s);\n}\n\nvec2 smatUnion(vec2 a, vec2 b, float k) {\n    return vec2(smin(a.x, b.x, k), (a.x < b.x) ? a.y : b.y);\n}\n\nvec2 bottle(vec3 point) {\n\n    //blackle were you raised in a barn? fix this shit!\n    float dist = length(point.xy);\n\n    float curve = distanceToBottleCurve(vec2(point.z, dist - 0.29)) + min(sin(atan(point.y,point.x)*16.0), 0.0)*0.001;\n    \n    float shell = -smin(0.95-abs(point.z-0.05), -curve, 0.2);\n    \n    for (int i = 0; i < 3; i++) {\n        vec2 angle = vec2(cos(3.14/3.0*float(i)), sin(3.14/3.0*float(i)));\n        //note, make this a call to cylinder\n        float cut = length(vec2(dot(point.xy, angle), point.z) - vec2(dot(vec2(0.0), angle), 0.95)) - 0.06;\n        shell = -smin(-shell, cut, 0.1);\n    }\n\n    shell = min(cylinder(point+vec3(0.0,0.0,0.73), 0.15, 0.01, 0.01), shell);\n\n    return smatUnion(smatUnion(\n        vec2(shell, 1.0),\n        vec2(cylinder(point*3.1 + vec3(0.0,0.0,-0.75), 1.05, 1.0, 0.1) / 2.9, 0.0), 0.02),\n        vec2(min(cylinder(point+vec3(0.0,0.0,0.89), 0.14, 0.10, 0.02) + abs(sin(atan(point.y,point.x)*32.0))*0.0005 * (1.0 - clamp(abs(dist - 0.14)*32.0, 0.0, 1.0)), cylinder(point+vec3(0.0,0.0,0.77), 0.14, 0.02, 0.02)), 0.0), 0.02);\n    // return uni;\n}\n\nvec2 scene(vec3 point) {\n\n    // return bottle(p4b);\n    vec3 offset = point.x > 1.0\n        ? vec3(2.0, 0.0, 0.0)\n        : (point.x < -1.0\n            ? vec3(-2.0, 0.0, 0.0)\n            : vec3(0.0));\n\n\n    vec3 p = point - offset;\n    vec3 p4b = (p - vec3(0.0, 0.0, -0.25)).zxy;\n\n    // return bottle(p4b);\n    return smatUnion(vec2(cos(point.z)*cos(point.y*5.0)*cos(point.x*5.0)*0.01 + smin(tombstone(p + vec3(0.0, 1.5, 0.0), 0.5 - p.z*0.01, 0.12 - p.z*0.01, 1.2, 0.1, 0.5), -smin(-p.z, tombstone(p, 0.6 + p.z*0.2, 1.2 + p.z*0.2, 0.75, 0.1, 0.1), 0.1), 0.1), 1.0), bottle(p4b), 0.0);\n}\n\nvec3 sceneGrad(vec3 point) {\n    float t = scene(point).x;\n    return normalize(vec3(\n        t - scene(point + vec3(0.001,0.0,0.0)).x,\n        t - scene(point + vec3(0.0,0.001,0.0)).x,\n        t - scene(point + vec3(0.0,0.0,0.001)).x));\n}\n\nRay newRay(vec3 origin, vec3 direction, vec3 attenuation) {\n    // Create a default ray\n    return Ray(origin, direction, origin, false, -1, vec3(0.0), attenuation);\n}\n\nvoid castRay(inout Ray ray) {\n    // Cast ray from origin into scene\n    float sgn = sign(scene(ray.m_origin).x);\n    for (int i = 0; i < 100; i++) {\n        float dist = length(ray.m_point - ray.m_origin);\n        if (dist > 20.0) {\n            break;\n        }\n\n        vec2 smpl = scene(ray.m_point);\n        \n        if (abs(smpl.x) < 0.0001) {\n            ray.m_intersected = true;\n            ray.m_mat = int(smpl.y);\n            break;\n        }\n        \n        ray.m_point += smpl.x * ray.m_direction * sgn;\n    }\n}\n\nvoid texturee(vec3 point, vec3 normal, inout Mat mat) {\n    float angle = atan(normal.x, normal.z);\n    if (abs(point.y) < 0.5 ) {\n        vec2 uv = vec2(angle, point.y)*vec2(2.5,7.0)+vec2(0.0,-1.5);\n        float ang = atan(uv.y, uv.x);\n        float len = floor(length(uv)*10.0);\n        bool val = len == 2. || len == 6. || len == 9.;\n        if (len == 3. || len == 4. || len == 5. || len == 8. || len == 10.) {\n            val = distanceToBottleCurve(vec2(ang+len,0.0))*7.99 > cos(len*7.99);\n        }\n        if(val) {\n            mat = mats[1];\n        }\n    }\n}\n\nvoid phongShadeRay(inout Ray ray) {\n\n    if (ray.m_intersected) {\n        for (int i = 0; i < 3; i++) {\n            vec3 lightDirection = normalize(lightdirs[i]);\n            Mat mat = mats[ray.m_mat];\n\n            vec3 normal = -sceneGrad(ray.m_point);\n\n            vec3 reflected = reflect(lightDirection, normal);\n            float diffuse = abs(dot(lightDirection, normal));\n            float specular = pow(abs(dot(ray.m_direction, reflected)), 20.0);\n\n            if (ray.m_mat == 0) {\n                if (ray.m_point.x > 1.0) {\n                    mat.m_diffuse = mat.m_diffuse.zyx;\n                } else if (ray.m_point.x < -1.0) {\n                    mat.m_diffuse = mat.m_diffuse.yxz*0.7;\n                }\n            }\n            texturee(ray.m_point, normal, mat);\n      \n            //oh god blackle clean this up\n            ray.m_color += (mat.m_diffuse * diffuse * (- mat.m_transparency + 1.0) + specular)*lightcols[i];\n        }\n    } else {\n        ray.m_color += 1.0-ray.m_direction*ray.m_direction;//vec3(pow(abs(dot(lightDirection, ray.m_direction)), 25.0))*lightcols[i];\n    }\n}\n\nRay reflectionForRay(Ray ray) {\n    Mat mat = mats[ray.m_mat];\n    float sgn = sign(scene(ray.m_origin).x);\n    vec3 normal = -sceneGrad(ray.m_point);\n    texturee(ray.m_point, normal, mat);\n    float frensel = abs(dot(ray.m_direction, normal));\n    vec3 atten = ray.m_attenuation * mat.m_reflectance * (1.0 - frensel*0.98);\n    vec3 reflected = reflect(ray.m_direction, normal);\n\n    return newRay(ray.m_point + normal*0.0001*4.0*sgn, reflected, atten);\n}\n\nRay transmissionForRay(Ray ray) {\n    Mat mat = mats[ray.m_mat];\n    float sgn = sign(scene(ray.m_origin).x);\n    vec3 normal = -sceneGrad(ray.m_point);\n    texturee(ray.m_point, normal, mat);\n    // float frensel = sqrt(abs(dot(ray.m_direction, normal)));\n    vec3 atten = ray.m_attenuation * mat.m_transparency;// * frensel;\n\n    return newRay(ray.m_point - normal*0.0001*4.0*sgn, ray.m_direction, atten);\n}\n\nRay rayQueue[MAXDEPTH];\nint raynum = 1;\nvoid addToQueue(Ray ray) {\n    if (raynum >= MAXDEPTH) return;\n    rayQueue[raynum] = ray;\n    raynum++;\n}\n\nvoid recursivelyRender(inout Ray ray) {\n    rayQueue[0] = ray;\n\n    for (int i = 0; i < MAXDEPTH; i++) {\n        if (i >= raynum) break;\n\n        castRay(rayQueue[i]);\n        phongShadeRay(rayQueue[i]);\n        if (rayQueue[i].m_intersected) {\n            addToQueue(reflectionForRay(rayQueue[i]));\n            addToQueue(transmissionForRay(rayQueue[i]));\n        }\n    }\n    for (int i = 0; i < raynum; i++) {\n        ray.m_color += rayQueue[i].m_color * rayQueue[i].m_attenuation;\n    }\n    // if (raynum == 1) {\n    //     ray.m_color = vec3(2.0);\n    // }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (iFrame != 0) {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)*2.0 - vec2(1.0,1.0);\n    uv.y *= iResolution.y/iResolution.x;\n    \n\n    vec3 cameraOrigin = vec3(5.0);\n    vec3 cameraDirection = vec3(-1.41,-1.41,-1.41);\n    vec3 platePoint = (vec3(-0.71,0.71,0.0) * uv.x + vec3(0.41, 0.41, -0.82) * -uv.y);\n\n    Ray ray = newRay(cameraOrigin, normalize(platePoint + cameraDirection), vec3(1.0));\n    recursivelyRender(ray);\n\n    ray.m_color *= 1.0 - pow(length(uv)*0.85, 3.0);\n    \n    fragColor = vec4(pow(log(ray.m_color+1.0)*0.9, vec3(1.3)), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}