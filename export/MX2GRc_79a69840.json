{"ver":"0.1","info":{"id":"MX2GRc","date":"1708859566","viewed":26,"name":"TP1_Jouet","username":"leticia","description":"La fonction object définit la géométrie d'un jouet représentant une voiture. Elle comprend un corps de forme cubique pour la carrosserie et quatre roues, chacune composée d'un torus pour la jante et d'une sphère pour le pneu. La fonction retourne l'union ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":[],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modeling - 2023.02.06\n// Eric Galin\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(vec2 m,vec2 p,out vec3 ro,out vec3 rd)\n{\n  float a=3.*3.14*m.x;\n  float le=3.5;\n  \n  // Origin\n  ro=vec3(37.,0.,15.);\n  ro*=Rz(a);\n  \n  // Target point\n  vec3 ta=vec3(0.,0.,1.);\n  \n  // Orthonormal frame\n  vec3 w=normalize(ta-ro);\n  vec3 u=normalize(cross(w,vec3(0.,0.,1.)));\n  vec3 v=normalize(cross(u,w));\n  rd=normalize(p.x*u+p.y*v+le*w);\n}\n\n// Primitives\n\n// Sphere\n// p : point\n// c : center of skeleton\n// r : radius\nfloat Sphere(vec3 p,vec3 c,float r)\n{\n  return length(p-c)-r;\n}\n// Box\n// p : point\n// c : center of box\n// b : half size of box in each dimension (x, y, z)\nfloat Box(vec3 p, vec3 c, vec3 b) {\n    vec3 d = abs(p - c) - b;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n// Torus\n// p : point\n// c : center of torus\n// R : major radius\n// r : minor radius\nfloat Torus(vec3 p, vec3 c, float R, float r) {\n    vec2 q = vec2(length(p.xz - c.xz) - R, p.y);\n    return length(q) - r;\n}\n// Cylinder\n// p : point\n// c : center of cylinder\n// h : height\n// r : radius\nfloat Cylinder(vec3 p, float h, float r) {\n    return max(length(p.xz) - r, abs(p.y) - h * 0.5);\n}\n// Plane\n// p : point\n// n : normal of the plane\n// c : center point of the plane\nfloat Plane(vec3 p, vec3 n, vec3 c) {\n    return dot(p - c, n);\n}\n// Capsule\n// p : point\n// a : one end point of the capsule\n// b : another end point of the capsule\n// r : radius\nfloat Capsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n// Operators\n\n// Union\n// a,b : field function of left and right sub-trees\nfloat Union(float a,float b)\n{\n  return min(a,b);\n}\n// Intersection\n// a, b : valeurs de champ de la sous-arbre gauche et droit\nfloat Intersection(float a, float b) {\n    return max(a, b);\n}\n// Différence\n// a, b : valeurs de champ de la sous-arbre gauche et droit\nfloat Difference(float a, float b) {\n    return max(a, -b);\n}\n// Soft Union\n// a, b : valeurs de champ de la sous-arbre gauche et droit\nfloat SoftUnion(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n// Translation\n// p : point à déplacer\n// t : vecteur de translation\nvec3 Translate(vec3 p, vec3 t) {\n    return p - t;\n}\n// Rotation autour de l'axe Y\n// p : point à faire pivoter\n// angle : angle de rotation en radians\nvec3 RotateY(vec3 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);\n}\n\n// Rotation autour de l'axe Z\n// p : point à faire pivoter\n// angle : angle de rotation en radians\nvec3 RotateZ(vec3 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(p.x * c - p.y * s, p.x * s + p.y * c, p.z);\n}// Homothétie\n// p : point à mettre à l'échelle\n// s : facteur d'échelle\nvec3 Scale(vec3 p, float s) {\n    return p * s;\n}\n\n// Potential field of the object\n// p : point\n\nfloat object(vec3 p) {\n    // Corps de la voiture (box)\n    float body = Box(p, vec3(0.0, 0.0, 0.0), vec3(4.0, 1.0, 1.0));\n\n    // Roues de la voiture (tore)\n    float wheel1 = Torus(p + vec3(-2.5, -1.0, -1.0), vec3(0.0, 0.0, 0.0), 0.8, 0.3);\n    float wheel2 = Torus(p + vec3(2.5, -1.0, -1.0), vec3(0.0, 0.0, 0.0), 0.8, 0.3);\n    float wheel3 = Torus(p + vec3(-2.5, -1.0, 1.0), vec3(0.0, 0.0, 0.0), 0.8, 0.3);\n    float wheel4 = Torus(p + vec3(2.5, -1.0, 1.0), vec3(0.0, 0.0, 0.0), 0.8, 0.3);\n\n    // Pneus (sphères)\n    float tire1 = Sphere(p + vec3(-2.5, -1.0, -1.0), vec3(0.0), 0.35);\n    float tire2 = Sphere(p + vec3(2.5, -1.0, -1.0), vec3(0.0), 0.35);\n    float tire3 = Sphere(p + vec3(-2.5, -1.0, 1.0), vec3(0.0), 0.35);\n    float tire4 = Sphere(p + vec3(2.5, -1.0, 1.0), vec3(0.0), 0.35);\n\n    // Combinaison des différentes parties de la voiture\n    return Union(body, Union(Union(Union(wheel1, wheel2), Union(wheel3, wheel4)), Union(Union(tire1, tire2), Union(tire3, tire4))));\n}// Analysis of the scalar field\n\nconst int Steps=200;// Number of steps\nconst float Epsilon=.01;// Marching epsilon\n\n// Object normal\n// p : point\nvec3 ObjectNormal(vec3 p)\n{\n  const float eps=.001;\n  vec3 n;\n  float v=object(p);\n  n.x=object(vec3(p.x+eps,p.y,p.z))-v;\n  n.y=object(vec3(p.x,p.y+eps,p.z))-v;\n  n.z=object(vec3(p.x,p.y,p.z+eps))-v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o,vec3 u,float e,out bool h,out int s)\n{\n  h=false;\n  \n  // Start at the origin\n  float t=0.;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=o+t*u;\n    float v=object(p);\n    // Hit object\n    if(v<0.)\n    {\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=max(Epsilon,v);\n    // Escape marched too far away\n    if(t>e)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Lighting\n\n// Background color\n// d : Ray direction\nvec3 background(vec3 d)\n{\n  return mix(vec3(.45,.55,.99),vec3(.65,.69,.99),d.z*.5+.5);\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n  bool h;\n  int s;\n  float t=SphereTrace(p+Epsilon*n,l,100.,h,s);\n  if(!h)\n  {\n    return 1.;\n  }\n  return 0.;\n}\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// e : Eye direction\nvec3 Shade(vec3 p,vec3 n,vec3 e)\n{\n  // Point light\n  const vec3 lp=vec3(5.,10.,25.);\n  \n  // Light direction to point light\n  vec3 l=normalize(lp-p);\n  \n  // Ambient color\n  vec3 ambient=.25+.25*background(n);\n  \n  // Shadow computation\n  float shadow=Shadow(p,n,l);\n  \n  // Phong diffuse\n  vec3 diffuse=.35*clamp(dot(n,l),0.,1.)*vec3(1.,1.,1.);\n  \n  // Specular\n  vec3 r=reflect(e,n);\n  vec3 specular=.15*pow(clamp(dot(r,l),0.,1.),35.)*vec3(1.,1.,1.);\n  vec3 c=ambient+shadow*(diffuse+specular);\n  return c;\n}\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n  float t=float(n)/(float(Steps-1));\n  return.5+mix(vec3(.05,.05,.5),vec3(.65,.39,.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel,out bool pip)\n{\n  // Pixel coordinates\n  vec2 p=(-iResolution.xy+2.*pixel)/iResolution.y;\n  if(pip==true)\n  {\n    const float fraction=1./4.;\n    // Recompute pixel coordinates in sub-picture\n    if((pixel.x<iResolution.x*fraction)&&(pixel.y<iResolution.y*fraction))\n    {\n      p=(-iResolution.xy*fraction+2.*pixel)/(iResolution.y*fraction);\n      pip=true;\n    }\n    else\n    {\n      pip=false;\n    }\n  }\n  return p;\n}\n\n// Image\nvoid mainImage(out vec4 color,in vec2 pxy)\n{\n  // Picture in picture on\n  bool pip=true;\n  \n  // Pixel\n  vec2 pixel=Pip(pxy,pip);\n  \n  // Mouse\n  vec2 m=iMouse.xy/iResolution.xy;\n  \n  // Camera\n  vec3 ro,rd;\n  Ray(m,pixel,ro,rd);\n  \n  // Trace ray\n  \n  // Hit and number of steps\n  bool hit;\n  int s;\n  \n  float t=SphereTrace(ro,rd,100.,hit,s);\n  \n  // Shade background\n  vec3 rgb=background(rd);\n  \n  if(hit)\n  {\n    // Position\n    vec3 p=ro+t*rd;\n    \n    // Compute normal\n    vec3 n=ObjectNormal(p);\n    \n    // Shade object with light\n    rgb=Shade(p,n,rd);\n  }\n  \n  // Uncomment this line to shade image with false colors representing the number of steps\n  if(pip==true)\n  {\n    rgb=ShadeSteps(s);\n  }\n  \n  color=vec4(rgb,1.);\n}","name":"Image","description":"","type":"image"}]}