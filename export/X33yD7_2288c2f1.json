{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"\n// SDF by our lord and saviour iq\nfloat sdTriangle( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat boid_scene(in vec2 p)\n{\n    float min_boid = 999.; // it has to be big, otherwise it will always be smaller\n    for (int i = 1; i < boids_number; i++)\n    {\n        vec2 bp = texelFetch(iChannel0, ivec2(i, 0), 0).xy;\n        vec2 forward = texelFetch(iChannel0, ivec2(0, i), 0).xy;\n        float angle = texelFetch(iChannel0, ivec2(i, 0), 0).z;\n        vec2 boid_pos = p;\n        boid_pos -= bp;\n        boid_pos *= r2d(-angle);\n       \n        float boid = sdTriangle(boid_pos, boid_size);\n        \n        min_boid = min(boid, min_boid);\n    }\n    return min_boid;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.0f * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 col = vec3(1.);\n    vec4 boid_color = vec4(vec3(0.55,0.84,0.31), 0.);\n    \n    float boids = boid_scene(uv);\n    \n    // Output to screen\n    if(boids <= 0.)\n    {\n        fragColor = boid_color;\n    }\n    else\n    {\n        fragColor = vec4(col,1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define epsilon 0.000000000000001\nfloat anglev(in vec2 a, in vec2 b)\n{\n    float theta = acos(dot(a / length(a), b / length(b)));\n    return -mod(theta * sign(cross(vec3(a, 0.), vec3(b, 0.)).z), 2. * pi);\n}\n\nvoid save_at_ivec(in ivec2 desired_pos, in vec4 data, inout vec4 fragColor, in ivec2 current_pos)\n{\n    fragColor = (desired_pos.x==current_pos.x && desired_pos.y==current_pos.y ) ? data : fragColor;\n}\n\nvec2 get_away_dir(in vec2 pos, in vec2 allpos[boids_number])\n{\n    vec2 away;\n    for (int g = 1; g < boids_number; ++g)\n    {\n         vec2 aw = pos - allpos[g];\n         away += aw *  (1. - length(aw));\n    }    \n    return normalize(away);\n}\n\nvec2 match_average_forward(in vec2 pos, in vec2 forward, in vec2 allpos[boids_number], in vec2 allfow[boids_number])\n{\n    vec2 final;\n    for (int i = 1; i < boids_number; i++)\n    {\n        if (distance(allpos[i], pos) <= av_fov)\n        {\n            final += allfow[i];\n        }\n    }\n    final = final / float(boids_number);\n    return normalize(final);\n}\n\nvec2 target_average_center(in vec2 pos, in vec2 allpos[boids_number])\n{\n    vec2 towards;\n    for (int g = 1; g < boids_number; ++g)\n    {     \n        if (distance(allpos[g], pos) <= boid_fov)\n        {\n            towards += allpos[g];\n        }\n        \n    }\n    towards /= float(boids_number);\n    return towards;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 forwards[boids_number];\n    vec2 poss[boids_number];\n    float angles[boids_number];\n    \n    if (iFrame == 0)\n    {\n        for (int i = 1; i < boids_number; i++)\n        {\n            vec2 bp = vec2( 0.2* float(i), 0.);\n            poss[i] = bp;\n            angles[i] = float(i);\n            forwards[i] = normalize(vec2(0., 1.) * r2d(angles[i]));\n        }  \n    }\n    else\n    {\n        for (int a = 1; a < boids_number; a++)\n        {\n            forwards[a] = texelFetch(iChannel0, ivec2(0, a), 0).xy;\n            poss[a] = texelFetch(iChannel0, ivec2(a, 0), 0).xy;\n            \n        }\n        for (int a = 1; a < boids_number; a++)\n        {\n            vec2 bp = poss[a];\n            vec2 forward = forwards[a];\n            \n           \n            vec2 average_forward = match_average_forward(bp, forward, poss, forwards);\n            vec2 towards_center = target_average_center(bp, poss);\n            vec2 away_dir = get_away_dir(bp, poss);\n            \n            forward += average_forward * 0.3 * iTimeDelta; // alignment\n            forward += away_dir * steer_value * iTimeDelta; // ceparation\n            forward = mix(forward, towards_center, 6.5 * iTimeDelta); // cohesion \n            \n            forward = normalize(forward);\n            \n            angles[a] = anglev(forward, vec2(0., 1.));\n            bp += forward * speed * iTimeDelta;\n          \n          \n            if(bp.x > 2.)\n            {\n                bp.x = -1.8;\n                bp.y *= -1.;\n            }\n            else if(bp.x < -2.)\n            {\n                bp.x = 1.8;\n                bp.y *= -1.;\n            }\n            if(bp.y > 1.2)\n            {\n                bp.y = -1.1;\n                bp.x *= -1.;\n            }\n            else if(bp.y < -1.2)\n            {\n                bp.y = 1.1;\n                bp.x *= -1.;\n            }\n            \n            poss[a] = bp;\n            forwards[a] = forward;\n        }\n    \n    } \n\n \n    ivec2 int_fc = ivec2(fragCoord);    \n    for (int i = 1; i < boids_number; i++)\n    {\n        save_at_ivec(ivec2(i, 0), vec4(poss[i], angles[i], 0.), fragColor, int_fc);\n        save_at_ivec(ivec2(0, i), vec4(forwards[i], 0., 0.), fragColor, int_fc);\n        \n    }      \n}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"\n#define pi 3.1415926535\nconst int boids_number =  50;\nconst float boid_fov = 0.39;\nconst float av_fov = 0.29;\nconst float speed = 0.7;\nvec2 boid_size = vec2(.024, -.07);\nconst float steer_value = 1.8;\n\n\nmat2 r2d(float t)\n{\n    float sn = sin(t);\n    float cs = cos(t);\n    return mat2(cs, -sn, sn, cs);\n}\n\nvec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"X33yD7","date":"1735158863","viewed":36,"name":"ultimately silly boids","username":"donerfornothing","description":"i like boids. the boids hate me","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["boids"],"hasliked":0,"parentid":"","parentname":""}}