{"ver":"0.1","info":{"id":"dddyWH","date":"1695295421","viewed":87,"name":"Path_Tracing_Bg","username":"vince5287","description":"WIP","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ----------------------Section1: Utils ---------------------------------------\n// Lin alg\nvec2 rotate(vec2 pos, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c, s, -s, c) * pos; \n}\n\n// rand\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Fractal Brownian Motion\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\n//------------ Section 2: SDFs - For derivation, Inigo Quilez ---------------\n\n// Octahedron - Not Exact\nfloat sdOctahedron( vec3 pos, float size)\n{\n  pos = abs(pos);\n  return (pos.x+pos.y+pos.z-size)*0.57735027;\n}\n\n// 2 - Plane\nfloat plane(vec3 pos)\n{\n    return pos.y;\n}\n\n// 3 - Sphere\nfloat sphere(vec3 pos, float r)\n{\n    return length(pos) - r;\n}\n\n// 4 - Boxes\nfloat box(vec3 pos, vec3 size)\n{\n    return length(max(abs(pos) - size, 0.0));\n}\n\nfloat roundedBox(vec3 pos, vec3 size, float radius)\n{\n    return length(max(abs(pos) - size, 0.0)) - radius;\n}\n\n\n//--------------Section 3: Ray Marching Mapping (min union, max intersect)---------------\n\nvec2 repeat(inout vec2 pos, vec2 period)\n{\n    vec2 off = pos + period * 0.5;\n    vec2 idx = floor(off / period);\n    pos = mod(off, period) - period * 0.5;\n    \n    return idx;\n}\n\n// Use max for intersection instead\nfloat map(vec3 pos)\n{\n    \n    float p = plane(pos);\n    vec2 idx = repeat(pos.xz, vec2(20.0));\n    float i = (idx.x + idx.y * 7.0) * 5.0;\n    \n    //return p;\n    \n    vec3 octOffset = vec3(sin(iTime) * 5.0, 4.0, 0.0);\n    float shapes = sdOctahedron(pos - octOffset, 4.0);\n    return min(p, shapes);\n}\n\n\n//-----------------Section 4: Normals and Lighting-----------------------------\n// Normals\nvec3 computeNormal(vec3 pos)\n{\n    // Trick to build epsilon cube\n    vec2 e = vec2(0.01, 0.0);\n    vec3 right = e.xyy;\n    vec3 left = -e.xyy;\n    vec3 top = e.yxy;\n    vec3 bottom = -e.yxy;\n    vec3 front = e.yyx;\n    vec3 back = -e.yyx;\n    \n    return normalize(vec3(\n        map(pos + right) - map(pos + left),\n        map(pos + top) - map(pos + bottom),\n        map(pos + front) - map(pos + back)\n    ));\n    \n}\n\n\n// Use noise to simulate Cloud/Fog reflections\nvec3 albedo(vec3 pos, vec2 uv)\n{\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    \n    pos *= 0.5;\n    float f = smoothstep(0.12, 0.14, fract(pos.x - sin(pos.z) * 0.5));\n    return f * vec3(1.0) * clamp(fbm(st*3.0 + ((sin(iTime*0.05)*4.0))), 0.5, 1.0);\n}\n\nvec3 lightDir = normalize(vec3(3.0, 3.0, 1.0));\n\nfloat diffuse(vec3 normal)\n{\n    //return max(dot(normal, lightDir), 0.0);\n    \n    // Wrap lighting\n    return dot(normal, lightDir) * 0.5 + 0.5;\n}\n\nfloat specular(vec3 normal, vec3 dir)\n{\n    vec3 h = normalize(normal - dir);\n    return pow(max(dot(h, normal), 0.0), 100.0);\n}\n\nfloat occlusion(vec3 pos, vec3 normal)\n{\n    const float OCCLUSION_DISTANCE = 0.3;\n    float occ = 1.0;\n    for (int i = 0; i < 4; i++)\n    {\n        pos += normal * OCCLUSION_DISTANCE;\n        occ = clamp(min(occ, map(pos) / OCCLUSION_DISTANCE), 0.2, 1.0);\n    }\n    \n    return occ;\n}\n\n\n// ----------------- Section5: Render ----------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( gl_FragCoord.xy * 2.0 - vec2(iResolution.x, iResolution.y) ) / iResolution.y;\n    \n    // Camera Position\n    //vec3 pos = vec3(sin(iTime*0.4)*3.0, sin(iTime*0.3)*2.0 + 4.0, -8.0);\n    vec3 pos = vec3(sin(iTime * 0.2) * 4.0, 5.0 + sin(iTime * 0.05) * 3.0, -10.0);\n    // z Coordinate gives FOV\n    vec3 dir = normalize(vec3(uv, 1.0));\n    \n    // Create sun and sky from lightDir\n    float sun = pow(dot(dir, lightDir), 4.0);\n    vec3 sky = mix(vec3(0.8, 0.9, 0.95), vec3(1.0, 1.0, 0.8), sun);\n    \n    vec3 color = vec3(0.0);\n    \n    for (int i = 0; i < 128; i++)\n    {\n        float d = map(pos);\n        if (d < 0.01)\n        {\n            float lightDistance = sphere(pos, 1.0);\n            vec3 norm = computeNormal(pos);\n            float diff = diffuse(norm);\n            float spec = specular(norm, dir);\n            //color = (diff + spec) * 10.0 / (lightDistance * lightDistance) * vec3(0.9, 0.7, 0.2) * albedo(pos);\n            color = (diff + spec) * vec3(0.9, 0.7, 0.2) * albedo(pos, uv);\n            color *= occlusion(pos, norm) * 0.8 + 0.2;\n            break;\n        }\n        pos += d * dir;\n    }\n    \n    float fogFactor = exp(-pos.z * 0.04);\n    //color = mix(vec3(0.8, 0.9, 1.0), color, fogFactor);\n    color = mix(sky, color, fogFactor);\n        \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}