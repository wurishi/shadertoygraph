{"ver":"0.1","info":{"id":"ftKfDh","date":"1664975935","viewed":77,"name":"AnotherVoroniShader","username":"hjd3481","description":"experimenting with voroni. Tesselating Tiles split into Cells. Increase the wrapping by increasing the \"TileZoom\" parameter. With ALLOW_TESSELATION_BREAK 0 Would be suitable for rendering a single tile into a render-target and using as a wrapping texture.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sun","cellular","voroni"],"hasliked":0,"parentid":"flVfWz","parentname":"CellularBase"},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////\n/*\n\nA Sun-surface or roiling-fire shader ( disable SUNSPOT_ENABLE ).\nEasily modifiable to be a toxic-goo shader etc.\n\nTodo: Figure out and fix the cell-boundary aliasing\n\n*/\n/////////////////////////////\n//Debugging\n\n#define TEST_CELL_UVS      0\n#define TEST_TILE_UVS      0\n#define TEST_WARP          0\n#define TEST_NOISE         0\n#define OVERLAY_CELL_NOISE 0\n#define TEST_VORONI_DIST   0\n#define TEST_DIRECTION     0\n#define TEST_NEAREST       0\n#define TEST_FLOW_BLEND    0\n\n#define OUTLINE_CELL -1  //-1 for off\n\n/////////////////////////////\n//Consts\n\n#define PI 3.14159f\n#define TWOPI 6.283185f\n\n#define noiseSampler iChannel0\n#define flameSampler iChannel1\n\n#define CELL_BL 0\n#define CELL_B  1\n#define CELL_BR 2\n#define CELL_L  3\n#define CELL_C  4 //'our' cell\n#define CELL_R  5\n#define CELL_TL 6\n#define CELL_T  7\n#define CELL_TR 8\n\n/////////////////////////////\n//Effect parameters \n\n//features / debugging\n#define WARP_ENABLE      1\n#define TEXTURE_OVERLAY  1\n#define SUNSPOT_ENABLE   1\n\n//time will loop after this period in seconds\n#define TIME_STEPS  4\n#define TIME_LOOP   float(TIME_STEPS)\n\n//These features warp the whoel iamge and break square tesselation as displayed on screen, for added aesthetics\n#define ALLOW_TESSELATION_BREAK 1  //enable disable all tesselation-breaking features\n#define SKEW_ENABLE      1\n#define AUTO_ZOOM_ENABLE 1\n\n///////////////////////////////////////\n\n//the overall time 'speed'\nconst float TimeScale = 0.11234f;\n\n//the number of tiles vertically in the preview\nconst float TileZoom = 1.0f;\n\n//The cells per tesselation-tile (e.g the texture) in both axes\nconst int cellsPerTile = 7;\n\nconst float GridVariation = 1.0f; //1.5f;\n\nconst float WarpSpeed = 0.035;\nconst float WarpMagnitude = 0.793133;\n\nconst float FlameFlowScale = 0.3;\nconst float FlameFlowSpeed = 5.1f; //must be a positive whole number to loop properly\n\n\n//////////////////////////////////////////\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//////////////////////////////////////////\nvec4 GetCellNoise( in ivec2 cellCoord, in int cellsPerTile, in vec2 noisePixelUV )\n{\n\n     \n    int cellIndex = cellCoord.x + (cellCoord.y * cellsPerTile);\n    \n    \n    //offset the unit-transition between noise values in time so each cell lerps out of sync\n    vec3 cellRandom = hash32(vec2(cellCoord)); //a static per cell random value\n    float fTX = mod( (iTime * TimeScale) + cellRandom.x, TIME_LOOP );\n        \n    float timeBlend  = fract( fTX );\n    float textureRow = floor( fTX );\n    \n    //debugging: snap the change over at the half way point\n    //timeBlend = smoothstep( 0.5,0.51, fTX );\n        \n    //cells in U, time in V\n\n    vec2 pixelCentre = vec2(0.5);  \n    \n    //TODO fix for time loop ( wrap the offset to looped value correctly )\n    \n    //get pixel centre for non-blended value\n    vec2 noiseTexcoordA = ( vec2( cellIndex, textureRow ) + pixelCentre) * noisePixelUV;\n    //sample future value, wreap if need be\n    vec2 noiseTexcoordB = ( vec2( cellIndex, mod( textureRow + 1.0, TIME_LOOP) ) + pixelCentre) * noisePixelUV;\n    \n    vec4 cellNoiseA = texture(noiseSampler, noiseTexcoordA );\n    vec4 cellNoiseB = texture(noiseSampler, noiseTexcoordB );\n   \n    //vec4 cellBlendNoise = mix( cellNoiseA, cellNoiseB, timeBlend );\n    \n    //add some more smoothing and randomness to the noise blend to give the movement of the cells are more natural motion\n    //timeBlend = pow( timeBlend, mix(0.5, 1.4, cellNoiseA.x) );    \n    //timeBlend = mix( timeBlend,  smoothstep(0.0,1.0, timeBlend), 0.5 );\n    vec4 cellBlendNoise = mix( cellNoiseA, cellNoiseB, smoothstep( 0.0, 1.0, timeBlend) ); //smooth off the noise-transition\n   \n   //TODO fix time looping\n    \n    return cellBlendNoise;\n\n}\n\nvec2 sincos( in vec2 rad )\n{\n    return vec2( sin(rad.x), cos(rad.y) );\n}\n\nvec2 sincos( in float radX, in float radY )\n{\n    return vec2( sin(radX), cos(radY) );\n}\n\nvec2 sincos( in float rad )\n{\n    return vec2( sin(rad), cos(rad) );\n}\n\n#define GetDistanceNoise( cellIndex )\\\n   mix( -0.742, 0.237, allCellNoise[cellIndex].w ) //Randomly scale the voroni influences to get more organic shapes\n   \n///////////////////////////////////////////\n\nconst ivec2 offsets[9] = ivec2[9](\nivec2(-1,-1),//CELL_BL\nivec2(0,-1), //CELL_B    \nivec2(1,-1), //CELL_BR\n\nivec2(-1,0), //CELL_L\nivec2(0,0),  //CELL_C\nivec2(1,0),  //CELL_R\n\nivec2(-1,1), ///CELL_TL\nivec2(0,1),  //CELL_T\nivec2(1,1) //CELL_TR\n);\n\nfloat GetLoopingTimeScale( in float timeScale )\n{\n\n    const float recipTimeScale = 1.0f / TIME_LOOP; //minimum timeScale\n\n    float c = 1.0 / timeScale; //loopTime\n    \n    float e = TIME_LOOP / c;\n    \n    float f = floor(e);\n    \n    float nearestLoopingTimeScale = f * recipTimeScale;\n        \n    return nearestLoopingTimeScale;\n}\n\n#define DebugEarlyOut( col ) fragColor = vec4(col,1.0); return;\n\n//////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y; //dividing only by Y gets us 0:1 in Y and aspect-correct pixels in X. divide by x to get 0:1 in width and crop top.\n    vec3 col = vec3(0);\n    \n    float aspect = float(iResolution.y) / float(iResolution.x);\n    \n    \n    float fT = mod( iTime * TimeScale, TIME_LOOP );\n\n\n#if (SKEW_ENABLE && ALLOW_TESSELATION_BREAK)\n    //skew for some more distraction from the grid / help show boundary errors\n    //! affects on-screen tesselation\n    const float SkewSpeed = TimeScale* 0.30731;\n    uv = ( (uv + 0.5) + (uv.yx * sincos(iTime*SkewSpeed) + uv.xy * sincos(TWOPI-iTime*SkewSpeed) )*0.13125) - 0.5;\n    \n    //DebugEarlyOut( vec3(fract(uv),0.0) );\n    \n#endif //SKEW_ENABLE\n\n#if (AUTO_ZOOM_ENABLE && ALLOW_TESSELATION_BREAK) \n    //! affects on-screen tesselation\n    const float AutoZoomSpeed = 0.089;\n    uv = ((uv * 2.0 - 1.0) + (1.0 + sincos( iTime * AutoZoomSpeed ) * aspect * 0.3125)) * 0.5 + 0.5;\n#endif //AUTO_ZOOM_ENABLE\n\n    //tesselation test and aspect\n    vec2 tileuv = (uv * TileZoom );\n    \n\n    ///////////////////////////////////\n    //warp tileUVs\n#if (WARP_ENABLE)\n    vec2 warpSpeedA = vec2( WarpSpeed * 0.81,    WarpSpeed * 0.7113 );\n    vec2 warpSpeedB = vec2( WarpSpeed * 0.77113, WarpSpeed * 0.8671 );   \n\n    float warpMagA = WarpMagnitude * 0.035;\n    float warpMagB = WarpMagnitude * 0.025;\n    //warp inside the unit-tile so the warping always tesselates\n    \n    float warpTime =  GetLoopingTimeScale( WarpSpeed ) * iTime * TimeScale;\n    \n    vec2 tuvwa = sincos( warpTime * TWOPI + tileuv.xy * TWOPI  ) * warpMagA;\n    vec2 tuvwb = sincos( warpTime * TWOPI + tileuv.yx * TWOPI  ) * warpMagB;\n    tileuv += tuvwa + tuvwb;\n    \n#endif //WARP_ENABLE\n\n    tileuv = fract(tileuv);\n       \n    ///////////////////////////////////\n    vec2 celluv = fract( tileuv * vec2(cellsPerTile) );    \n    \n    ivec2 cellCoord = ivec2(tileuv * vec2(cellsPerTile));    \n    int cellIndex = cellCoord.x + cellCoord.y * cellsPerTile;\n    \n    //we add an offset so the warping or offsets dont go below zero\n    cellCoord += cellsPerTile;\n    \n     \n    ///////////////////////////////////\n    //Get a smooth noise value over time use a texture for wrapping/cycling\n     \n    ivec2 noiseSize = textureSize(noiseSampler, 0);\n    vec2 noisePixelUV = vec2(1.0,1.0) / vec2(noiseSize);\n            \n    ivec2 allCellCoord[9];\n    for(int iCell =0; iCell < 9; ++iCell)\n    {\n        //add and mod becasue modding negative numbers creates an 'abs()' that we dont want\n        allCellCoord[iCell] = (cellCoord + offsets[iCell]) % cellsPerTile;\n    }\n        \n    ///////////////////////////////////\n    \n    vec4 allCellNoise[9];\n    for(int iCell =0; iCell < 9; ++iCell)\n    {\n       allCellNoise[iCell]  = GetCellNoise( allCellCoord[iCell], cellsPerTile, noisePixelUV );\n    }\n    \n    ///////////////////////////////////   \n    //convert from unit values to -1:+1\n    vec2 cellSignedCoords = celluv * 2.0 - 1.0;\n       \n    //Get the roaming cell-centres    \n\n    vec2 voroniCentre[9];\n    for(int iCell =0; iCell < 9; ++iCell)\n    {   \n        //vec2 centreOffsetRand = (sincos( (allCellNoise[iCell].xz + allCellNoise[iCell].wy) * PI)*0.5);\n        //voroniCentre[iCell] = (vec2(offsets[iCell])*2.0) + clamp( vec2(-0.5), vec2(0.5), (centreOffsetRand * GridVariation) );\n        \n        \n        \n        voroniCentre[iCell] = (vec2(offsets[iCell])*2.0);\n        \n        vec2 centreOffsetRand = (sincos( (allCellNoise[iCell].xz + allCellNoise[iCell].wy) * PI)*0.5);\n        voroniCentre[iCell] +=  sincos( allCellNoise[iCell].x + (TWOPI * allCellNoise[iCell].y), allCellNoise[iCell].z + (TWOPI * allCellNoise[iCell].w) ) * GridVariation;\n        \n    }\n    \n    \n    ///////////////////////////////\n    // Get Voroni Distance value and flow-direction\n    float voroniDist = -1.0;\n    int iCellNearest = -1;\n\n    vec2 weightedDirectionAll = vec2(0);\n    {\n        float d = 10000.0f;\n        for(int iCell =0; iCell < 9; ++iCell)\n        {\n            vec2 toCell = (voroniCentre[iCell] - cellSignedCoords);\n            float cd = length(toCell) + GetDistanceNoise( iCell );\n            \n            if(cd < d)\n            {\n                iCellNearest = iCell;            \n            }\n\n            d = min(d, cd);\n                        \n            weightedDirectionAll += toCell * smoothstep( 1.75, 0.0, cd );     \n        }\n        voroniDist = d;\n    }\n\n    \n    /////////////////////////////////////\n    //Colour and texture\n    \n    float voroniDistMul = 2.8;\n    \n    const vec3 colA = vec3(0.1,0.0,-0.50);\n    const vec3 colB = vec3(1.3,1.0,0.5) * 1.0;\n    col = mix( colA, colB, smoothstep( voroniDistMul, 0.0, voroniDist ));\n    \n#if (TEXTURE_OVERLAY)    \n    vec2 flameWarp = vec2(0);// (weightedDirectionAll*0.125);\n    \n    float flameTime = fT * FlameFlowSpeed;\n    float flameLoop = fract(flameTime);\n    \n    vec2 flameScrollA = weightedDirectionAll* mix(0.0,FlameFlowScale,flameLoop);\n    vec2 flameScrollB = weightedDirectionAll* mix(-FlameFlowScale,0.0,flameLoop);\n    \n    \n    vec4 vorFlameTexA = texture(flameSampler, celluv + flameWarp + flameScrollA );\n    vec4 vorFlameTexB = texture(flameSampler, celluv + flameWarp + flameScrollB );\n    //vec4 vorFlameTex = texture(flameSampler, tileuv + flameScroll );\n       \n    vec3 flameFlowBlend = mix( vorFlameTexA.xyz, vorFlameTexB.xyz, flameLoop );//smoothstep(0.0,1.0,fract(flameTime)));\n    \n    col =  col-0.5 + flameFlowBlend;\n    \n    #if (SUNSPOT_ENABLE)\n    //float v = 0.98;\n    //col = mix( col, vec3(0), smoothstep( v, v+0.1, spotDist + flameFlowBlend.r  ));\n    \n    const float spotclip = 0.022;    //larger = larger, rougher spots\n    const float spotSizeInv = 0.63778; //smaller = more, larger spots\n    const float vfalloff = 3.7;   //smaller = rougher spots, more flow included, higher = smoother spots.\n    col *= vec3( smoothstep(spotclip, spotclip+0.01, (flameFlowBlend.r*flameFlowBlend.g*flameFlowBlend.b* ((voroniDist+spotSizeInv)*vfalloff) )));  \n    #endif //SUNSPOT_ENABLE\n\n#endif //TEXTURE_OVERLAY\n\n\n    \n    ///////////////////////////////////\n    //Debugging options\n    \n\n    /////////////////////\n    #if (TEST_DIRECTION)\n    {\n        vec2 wd = (weightedDirectionAll.xy);\n        //wd = normalize(weightedDirectionAll.xy)*1.0;    \n        col = vec3( (wd.xy) *0.5 +0.5, 1.0);\n    }\n    #endif //TEST_DIRECTION\n\n    /////////////////////\n    #if (TEST_NEAREST)\n        if(iCellNearest >= 0)\n        {\n            col = allCellNoise[iCellNearest].xyz;\n        }\n        else\n        {\n            col = mix( vec3(0), vec3(1,0,1) , step( 0.5, fract(iTime)*2.0 ) );\n        }\n    #endif //TEST_NEAREST\n    \n    /////////////////////\n    #if (TEST_CELL_UVS)\n \n     col.xy = celluv;\n     col.z = 0.0;\n     \n    #endif //TEST_CELL_UVS\n    \n    /////////////////////\n    #if (TEST_TILE_UVS)\n         vec2 tileCoords = fract( uv * TileZoom );\n         col.z = (col.x+col.y+col.z)*0.33;\n         col.xy = vec2( tileCoords );\n    #endif //TEST_TILE_UVS\n    \n    #if (TEST_WARP)\n     col = normalize(vec3(tuvwa + tuvwb, 0.0))*0.5+0.5;\n    #endif //TEST_WARP\n    \n    /////////////////////\n    #if (TEST_NOISE)\n        col.rgb = allCellNoise[CELL_C].rgb;\n\n        const float thkL = 0.125;\n        const float thkH = 1.0-thkL;\n\n        const float lenL = 0.25;\n        const float lenH = 1.0-lenL;\n\n        if( celluv.x >= thkH && celluv.y >= lenL && celluv.y <= lenH )\n        {\n            col.rgb = allCellNoise[CELL_R].rgb;\n        }\n        else if( celluv.x < thkL && celluv.y >= lenL && celluv.y <= lenH )\n        {\n            col.rgb = allCellNoise[CELL_L].rgb;\n        }\n        else if(celluv.y >= thkH && celluv.x >= lenL && celluv.x <= lenH )\n        {\n            col.rgb = allCellNoise[CELL_T].rgb;\n        }\n        else if(celluv.y < thkL && celluv.x >= lenL && celluv.x <= lenH )\n        {\n            col.rgb = allCellNoise[CELL_B].rgb;\n        }\n        else if(celluv.x < thkL && celluv.y < thkL )\n        {\n            col.rgb = allCellNoise[CELL_BL].rgb;\n        }\n        else if( celluv.x < thkL && celluv.y > thkH )\n        {\n            col.rgb = allCellNoise[CELL_TL].rgb;\n        }\n        else if(celluv.x > thkH && celluv.y > thkH )\n        {\n            col.rgb = allCellNoise[CELL_TR].rgb;\n        }\n        else if(celluv.x > thkH && celluv.y < thkL )\n        {\n            col.rgb = allCellNoise[CELL_BR].rgb;\n        }\n    #endif //TEST_NOISE\n\n    /////////////////////\n    #if (OUTLINE_CELL > -1)\n        if( cellIndex == OUTLINE_CELL )\n        {\n            vec2 toCen = (celluv - 0.5)*2.0;\n            //float mask = smoothstep( 0.9, 0.8, abs(dot(toCen,toCen)) );\n            float mask = smoothstep( 0.9, 0.85, abs(toCen.x)) * smoothstep( 0.9, 0.85, abs(toCen.y));\n            vec3 maskCol = vec3(int(floor(iTime))%2);\n            col = mix( maskCol, col, mask );\n        }\n    #endif //(OUTLINE_CELL)\n    \n    /////////////////////\n    #if (OVERLAY_CELL_NOISE)\n        col.rgb *= allCellNoise[CELL_C].rgb;\n    #endif //OVERLAY_CELL_NOISE\n\n    /////////////////////\n    #if (TEST_VORONI_DIST)\n         col = mix( col, vec3(1), smoothstep( 0.11, 0.1, voroniDist ));\n    #endif //TEST_VORONI_DIST\n\n    /////////////////////////\n    \n    #if (TEXTURE_OVERLAY && TEST_FLOW_BLEND)\n        vec2 screen_uv = fragCoord/iResolution.xy;\n        col.r = vorFlameTexA.x * float(screen_uv.y < 0.5);\n        col.g = vorFlameTexB.x * float(screen_uv.y > 0.5);\n        col.b = 0.0;\n\n        if(screen_uv.x > 0.5)\n        {\n          col.rg = mix( vorFlameTexA.xx, vorFlameTexB.xx, smoothstep(0.0,1.0,flameLoop));\n        }\n    #endif //TEST_FLOW_BLEND\n    \n    \n    ///////////////////////////////////////////////////////////////\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}