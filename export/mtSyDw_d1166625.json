{"ver":"0.1","info":{"id":"mtSyDw","date":"1692301200","viewed":73,"name":"Dreadful place to be stranded","username":"Langwedocjusz","description":"Nothing is physically based, it was just supposed to be a picture of a gloomy lighthouse that renders reasonably fast.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//=====CLOUDS=============================================\n\nfloat CloudsDensity(vec3 p)\n{\n    const int octaves = 2;\n    const float scale = 3.0;\n    \n    //Coordinate transform to make it look more interesting\n    vec2 q = vec2(1.0, 0.25) * p.xz;\n    \n    q.x += 200.0*(1.0 - 1.0/(1.0+p.z*p.z));\n    \n    //Potential wind animation\n    q.y -= 2.0*iTime;\n\n    //Just usual 2d fbm\n    return sat(fbm(scale*q, octaves));\n}\n\nvec3 DrawClouds(vec3 org, vec3 dir, float tmin, float tmax)\n{\n    //Material properties\n    const float absorbance = 0.14;\n    const vec3 albedo = vec3(1.0);\n\n    //Sampling parameters\n    const int num_samples = 12;\n    float dt = (tmax-tmin)/float(num_samples);\n    \n    float visibility = 1.0;\n    vec3 volume_col = vec3(0.0);\n    \n    //Main raymarching loop\n    for (float t = tmin; t < tmax; t += dt)\n    {\n        vec3 p = org + t*dir;\n        \n        float density = CloudsDensity(p);\n        \n        float prev_visiblity = visibility;\n        //Beer-Lambert law:\n        visibility *= exp(-dt*density*absorbance);\n        \n        float absorption = prev_visiblity - visibility;\n        \n        //Self-shadowing:\n        //float light_vis = 1.0;\n        //\n        //for (float lt = 0.0 lt <  )\n        \n        volume_col += absorption * albedo;\n        \n    }\n\n    //Ad-hoc, non physical transformation\n    //Just to make it look more 'dramatic'\n    //Using something fast to compute\n\n    volume_col *= volume_col;\n\n    //Random coloration\n    const vec3 dark   = vec3(0.0, 0.0, 0.03);\n    const vec3 bright = 0.5*vec3(0.97, 1.0, 1.0);\n\n    return (1.0-volume_col)*dark + volume_col*bright;\n}\n\n//=====WATER==============================================\n\n#define WAVE_HEIGHT 0.1\n\n//Based on 'Seascape':\n//https://www.shadertoy.com/view/Ms2SD1\nfloat Wave(vec2 p) \n{\n    p += noise(p);\n\n    vec2 s = 1.0 - abs(sin(p));\n    vec2 c = abs(cos(p));\n\n    vec2 wv = mix(s,c,s);\n\n    return 1.0 - wv.x * wv.y;\n}\n\nfloat WavesHeight(vec2 p)\n{\n    p *= 2.0;\n\n    const int octaves = 5;\n    \n    float h = 0.0;\n    float A = 1.0, a = 1.0;\n    mat2 M = mat2(1.0, 0.0, 0.0, 1.0);\n    \n    vec2 offset = vec2(0.0);\n    \n    for (int i=0; i<octaves; i++)\n    {\n        offset = 2.0*iTime*M*vec2(-0.6,-0.8);\n    \n        h += A * Wave(a*M*p + offset);\n        \n        A *= 0.5;\n        a *= 2.0;\n        M *= mat2(0.8, -0.6, 0.6, 0.8);\n    }\n    \n    //Normalization\n    h *= float(octaves)/float(2*octaves-1);\n    \n    return WAVE_HEIGHT*h;\n}\n\n//Essentially raymarching a heightfield as in\n//https://iquilezles.org/articles/terrainmarching/\nbool RaymarchWater(vec3 org, vec3 dir, inout float dist)\n{\n    const int steps = 32;\n    const float maxt = 200.0;\n    \n    const vec4 bounding_plane = vec4(vec3(0,1,0), WAVE_HEIGHT);\n    \n    float mint = IntersectPlane(org, dir, bounding_plane);\n    \n    if (mint<0.0) return false;\n    \n    float dt = (maxt-mint)/float(steps);\n    \n    if (dt < 0.0) return false;\n\n    dist = 0.0;\n    \n    for(float t=mint; t<maxt; t += dt)\n    {\n        vec3 p = org + t*dir;\n        dist = t;\n        \n        if (p.y < WavesHeight(p.xz))\n        {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nvec3 GetWaterNorm(vec3 p)\n{\n    const vec2 h = vec2(0.0, 0.0001);\n\n    float H = WavesHeight(p.xz);\n\n    return normalize(vec3(\n        WavesHeight(p.xz + h.yx) - H,\n        h.y,\n        WavesHeight(p.xz + h.xy) - H\n    ));\n}\n\nvec3 DrawWater(vec3 org, vec3 dir, inout float depth)\n{\n    vec3 norm = vec3(0,1,0);\n    \n    float dist = 0.0;\n    \n    if (RaymarchWater(org, dir, dist))\n    {\n        vec3 p = org + dist*dir;\n        \n        norm = GetWaterNorm(p);\n        \n        depth = dist;\n    }\n    \n    const vec3 ldir = normalize(vec3(1,1,-1));\n    \n    float dif = sdot(ldir, norm);\n    \n    float fres = sat(1.0 - dot(norm, -dir));\n    fres *= fres*fres;\n    \n    const vec3 ref_col = vec3(0.5);\n    const vec3 base_col = vec3(0.02, 0.1, 0.15);\n    \n    vec3 col = mix(base_col, ref_col, fres);\n    \n    //Completely ad-hoc\n    return 0.8*(col - 0.2);\n}\n\n//=====LIGHTHOUSE=========================================\n\n#define MAT_BRICK 0\n#define MAT_ROCK 1\n#define MAT_METAL 2\n\nfloat Map(vec3 p, inout int mat_id)\n{\n    //Offset entire reference frame\n    p -= vec3(-1.3, 0.0, 2.0);\n\n    //Base cylinder\n    const float cyl_rad = 0.4;\n    \n    float cyl_sd = length(p.xz) - cyl_rad;\n    //Top cutoff\n    cyl_sd = max(cyl_sd, p.y - 2.5);\n    \n    //Bricklike pattern\n    float phi = atan(p.x, -p.z);\n    \n    vec2 uv = vec2(2.0*phi/PI, p.y);\n    \n    const vec2 scale = 2.0*vec2(1.0, 3.0);\n    \n    vec2 ts = fract(scale*uv);\n    \n    if (int(3.0*scale*uv.y) % 2 == 0)\n        ts.x = fract(ts.x + 0.5);\n    \n    const float eps = 0.1;\n    \n    float bx = smoothstep(0.0, eps, ts.x)\n             * smoothstep(0.0, eps, 1.0-ts.x);\n    float by = smoothstep(0.0, eps, ts.y)\n             * smoothstep(0.0, eps, 1.0-ts.y);\n\n    float br = bx*by;\n    \n    cyl_sd -= 0.01*br;\n    \n    //Some additional noise detail\n    cyl_sd -= 0.01*fbm(100.0*uv, 4);\n    \n    float sd = cyl_sd;\n    mat_id = MAT_BRICK;\n    \n    //Rock at the base\n    const float rock_rad = 0.5;\n    const vec3 r_offset = vec3(-0.1, -0.3, 0.0);\n    \n    float r_sd = length(p-r_offset) - rock_rad;\n    \n    float theta = acos(normalize(p).y);\n    \n    vec2 we = vec2(phi, theta);\n    \n    r_sd -= 0.5*fbm(10.0*we, 7);\n    \n    if (r_sd < sd)\n    {\n        sd = r_sd;\n        mat_id = MAT_ROCK;\n    }\n    \n    //The top\n    vec3 toffset = vec3(0.0, 2.51, 0.0);\n    \n    float t_sd = sdCappedCylinder(p-toffset, 0.05, cyl_rad);\n    t_sd -= 0.01;\n    \n    for (int i=0; i<5; i++)\n    {\n        float ang = float(i)*0.3333*PI;\n        \n        vec3 col_offset = (cyl_rad - 0.03)\n                        * vec3(cos(ang), 0.0, sin(ang));\n                        \n        float col = length((p-col_offset).xz) - 0.03;\n        \n        t_sd = min(t_sd, col);\n    }\n    \n    t_sd = max(t_sd, p.y - 3.0);\n    \n    float cap_rad = cyl_rad + 0.02;\n    vec3 cap_offset = vec3(0.0, 3.0+cap_rad, 0.0);\n    \n    t_sd = min(t_sd, sdCone(p-cap_offset, vec2(1,1), cap_rad));\n    \n    \n    if (t_sd < sd)\n    {\n        sd = t_sd;\n        mat_id = MAT_METAL;\n    }\n   \n    return sd;\n}\n\nvec3 Norm(vec3 p)\n{\n    const vec2 h = vec2(0.0, 0.01);\n\n    //Dummy variable\n    int i;\n\n    return normalize(vec3(\n        Map(p + h.yxx, i) - Map(p - h.yxx, i),\n        Map(p + h.xyx, i) - Map(p - h.xyx, i),\n        Map(p + h.xxy, i) - Map(p - h.xxy, i)\n    ));\n}\n\nbool RaymarchLighthouse(vec3 org, vec3 dir, inout float dist,\n                                            inout int mat_id)\n{\n    const int max_steps = 64;\n    const float min_dist = 0.001, max_dist = 7.0;\n\n    dist = 0.0;\n    \n    for (int i=0; i<max_steps; i++)\n    {\n        vec3 p = org + dist*dir;\n        float sd = Map(p, mat_id);\n        \n        if (abs(sd) < min_dist)\n            return true;\n            \n        dist += sd;\n        \n        if (dist > max_dist)\n            break;\n    }\n    \n    return false;\n}\n\nvec4 GetMaterial(vec3 p, int mat_id)\n{\n    switch(mat_id)\n    {\n        case MAT_BRICK:\n        {\n            float f = sin(6.0*p.y);\n            f = sat(f);\n            f = sqrt(f);\n            \n            return vec4(vec3(0.45 + 0.55*f), 4.0);\n        }\n        case MAT_ROCK:\n        {\n            return vec4(vec3(0.02), 64.0);\n        }\n        case MAT_METAL:\n        {\n            return vec4(vec3(0.01), 8.0);\n        }\n    }\n    \n    return vec4(0.0);\n}\n\n//=====MAIN================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Coords normalized to [-1;1] vertically\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n\n    //Camera setup\n    const float cam_fov_deg = 45.0;\n    const float cam_dist = 1.0/tan(0.5*PI*cam_fov_deg/180.0);\n\n    vec3 org = vec3(0.0, 1.5, -3.5);\n    \n    float otime = 0.5*iTime;\n    org += 0.01 * cos(5.0*otime) * vec3(cos(otime), 0.0, sin(otime));\n    \n    vec3 dir = normalize(vec3(uv, cam_dist));\n    \n    const float tilt = 0.1;\n    float s = sin(tilt), c = cos(tilt);\n    \n    dir.xy *= mat2(c, -s, s, c);\n    \n    //Initial color\n    vec3 col = vec3(0.0);\n    \n    //For blending in lighthouse geometry later\n    float current_depth = 1e9;\n    \n    //====CLOUDS=========================================\n    const float clouds_height = 4.5;\n    const vec4 clouds_plane = vec4(vec3(0,-1,0), clouds_height);\n    \n    float clouds_min = IntersectPlane(org, dir, clouds_plane);\n\n    if (clouds_min > 0.0)\n    {\n        const float clouds_thickness = 0.66;\n        const float clouds_top = clouds_height + clouds_thickness;\n        const vec4 clouds_plane_top = vec4(vec3(0,-1,0), clouds_top);\n        \n        float clouds_max = IntersectPlane(org, dir, clouds_plane_top);\n    \n        col = DrawClouds(org, dir, clouds_min, clouds_max);\n        \n        current_depth = clouds_min;\n    }\n    \n    //====OCEAN===================================\n    else\n    {\n        col = DrawWater(org, dir, current_depth);\n    }\n    \n    //====LIGHTHOUSE================================\n    float dist = 0.0;\n    int mat_id = 0;\n    \n    const vec3 lpos = vec3(-1.3, 2.6, 2.0);\n    const vec3 lcol = 4.0*vec3(0.9, 1.0, 0.5);\n    \n    if (RaymarchLighthouse(org, dir, dist, mat_id))\n    {\n        if (dist < current_depth)\n        {\n            current_depth = dist;\n        \n            vec3 p = org + dist*dir;\n            vec3 norm = Norm(p);\n            \n            vec4 material = GetMaterial(p, mat_id);\n            \n            float fres = sat(1.0 - dot(norm, -dir));\n            fres *= fres*fres;\n            \n            const float spec_fac = 0.6;\n            \n            //Direct light\n            vec3 dlcol = 0.4* vec3(0.9,1.0,1.0);\n            vec3 ldir = normalize(vec3(1,1,-1));\n            \n            float dif = sdot(ldir, norm);\n            float spec = pow(max( dot( reflect(-ldir, norm), -dir ), 0.0 ), material.w);\n            \n            col = dif * material.xyz * dlcol;\n            col += spec_fac * spec * dlcol;\n            \n            //Point light\n            vec3 diff = lpos-p;\n            \n            float ldist = length(diff);\n            float pdif = sdot(normalize(diff), norm);\n            float pspec = pow(max( dot( reflect(-normalize(diff), norm), -dir ), 0.0 ), material.w);\n            \n            //Cheap fake self-shadowing\n            if (p.y < 2.51)\n            {\n                pdif = 0.0;\n                pspec = 0.0;\n            }\n            \n            col += 50.0 * lcol * pdif * material.xyz;\n            col += 50.0 * spec_fac * lcol * pspec;\n            \n            float fres_str = 0.05;\n            \n            switch(mat_id)\n            {\n                case MAT_ROCK:\n                {\n                    fres_str = 0.1;\n                    break;\n                }\n                case MAT_METAL:\n                {\n                    fres_str = 0.4;\n                    break;\n                }\n            }\n            \n            col += fres_str*fres;\n        }\n        \n    }\n    \n    //Fog\n    float vis = 1.0;\n    \n    const int fog_samples = 10;\n    float fog_dt = current_depth/float(fog_samples);\n    \n    float fog_t = 0.0;\n    \n    const float fog_height = 2.5;\n    \n    for (int i=0; i<fog_samples; i++)\n    {\n        vec3 p = org + fog_t * dir;\n        float density = sat(fog_height-p.y);\n        \n        vis *= exp(-0.1*fog_dt*density);\n        \n        fog_t += fog_dt;\n    }\n    \n    col = mix(col, 0.7*vec3(0.17,0.18,0.25), 1.0-vis);\n    \n    \n    //Rain - stolen from 'Rainy London':\n    //https://www.shadertoy.com/view/XdSGDc\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tfloat dis = 0.1;\n\tfor (int i = 0; i < 12; i++)\n\t{\n\t\tvec3 plane = org + dir * dis;\n\t\tif (dis < current_depth)\n\t\t{\n\t\t\tfloat f = pow(dis, .45) + 0.25;\n\n            float time = 0.5*iTime;\n\n\t\t\tvec2 st =  f * (q * vec2(1.5, .05)+vec2(-time*.1+q.y*.5, time*.12));\n\t\t\tf = (texture(iChannel0, st * 2.0).x + texture(iChannel0, st*1.1).y);\n\t\t\tf = clamp(pow(abs(f)*.5, 29.0) * 140.0, 0.00, q.y*.4+.05);\n\n\t\t\tvec3 bri = vec3(.25);\n\t\t\t\n\t\t\tvec3 v3 = lpos - plane.xyz;\n\t\t\tfloat l = dot(v3, v3);\n\t\t\tl = max(2.0-(l*l * 0.125), 0.0);\n\t\t\tbri += l * lcol;\n            \n\t\t\tcol += 0.5*bri*f;\n\t\t}\n\t\tdis += 1.2;\n\t}\n\n    //Lens flare\n    \n    float flare_cos = sdot(normalize(lpos-org), dir);\n    float soft_flare = pow(flare_cos, 24.0);\n    \n    col += 0.1*soft_flare * lcol;\n    \n    vec3 flare_diff = ((lpos.z-org.z)/dir.z)*dir - (lpos + vec3(0.0, 0.2, 0.0) -org);\n    flare_diff *= vec3(0.25, 16.0, 1.0);\n    float we = length(flare_diff);\n    float hard_flare = sat(1.0 - 0.5*we);\n    hard_flare *= sat(1.0 - abs(flare_diff.x));\n    \n    col += 0.1*hard_flare * lcol;\n\n    //Color correction\n    col = pow(col, vec3(1.0/2.2));\n\n    //Vignette \n    float fac = 0.8*length(fragCoord/iResolution.xy - 0.5);\n    \n    col = mix(col, vec3(0.0), fac);\n\n    //Output\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535\n\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sdot(x, y) sat(dot(x,y))\n\n//https://iquilezles.org/articles/intersectors/\nfloat IntersectPlane(in vec3 org, in vec3 dir, in vec4 plane)\n{\n    return -(dot(org,plane.xyz)+plane.w)/dot(dir,plane.xyz);\n}\n\n//Hash functions from 'Hash without Sine':\n//https://www.shadertoy.com/view/4djSRW\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//2d value noise:\nfloat noise(vec2 p) {\n    vec2 id = floor(p);\n    vec2 u = fract(p);\n    \n    float a = hash12(id + vec2(0,0));\n    float b = hash12(id + vec2(1,0));\n    float c = hash12(id + vec2(0,1));\n    float d = hash12(id + vec2(1,1));\n    \n    u = u*u*u*(u*(6.0*u-15.0)+10.0);\n    \n    float k0 = a;\n    float k1 = b-a;\n    float k2 = c-a;\n    float k3 = a-b-c+d;\n    \n    return 0.5 + 0.5*(k0 + k1*u.x + k2*u.y + k3*u.x*u.y);     \n}\n\n//Fbm:\n//https://iquilezles.org/articles/fbm/\nfloat fbm(vec2 p, int octaves) {\n    const float scale_y = 1.0;\n    const float scale_xz = 0.25;\n    const mat2 rot = mat2(0.8, 0.6, -0.6, 0.8);\n    \n    p *= scale_xz;\n\n    float res = 0.0;\n    mat2 M = mat2(1.0);\n    \n    float A = 1.0, a = 1.0;\n    \n    for (int i=1; i<=octaves; i++) {\n        res += A*noise(a*M*p);\n        \n        a *= 2.0;\n        A *= 0.5;\n        M *= rot;\n    }\n    \n    float inv_norm = float(octaves)/float(2*octaves-1);\n    \n    return inv_norm*scale_y*res;\n}\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}","name":"Common","description":"","type":"common"}]}