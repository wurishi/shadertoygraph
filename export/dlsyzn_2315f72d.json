{"ver":"0.1","info":{"id":"dlsyzn","date":"1690363334","viewed":41,"name":"Newton-Raphson-Bisection Poly","username":"Envy24","description":"Function to find one or zero roots of polynomial in desired range.\nShould work better if you isolate roots.\nAlso can be used for transcendential functions.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["approximation","solver","cubic","quadratic","quartic","newton","quintic","bisection","polynomials","raphson","numeric","sextic","dekker"],"hasliked":0,"parentid":"dllyzn","parentname":"Newton-Raphson-Bisection Cubic"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  6.0 / R.y  )\n#define SM(x)                     ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n\nfloat x_axis(vec2 NDC) { return SM(abs(NDC.x)); }\nfloat y_axis(vec2 NDC) { return SM(abs(NDC.y)); }\nfloat draw_func(vec2 NDC, float f, float dfdx)\n{\n    float df   = NDC.y - f;\n    return SM(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\n/* Polynomials (from sextic to linear) */\n#define func(x)  ( (((((  a*x +    b)*x +    c)*x +    d)*x +    e)*x + f)*x + g )\n#define deriv(x) ( ((((6.*a*x + 5.*b)*x + 4.*c)*x + 3.*d)*x + 2.*e)*x + f )\n\n//#define func(x)  ( ((((  a*x +    b)*x +    c)*x +    d)*x + e)*x + f )\n//#define deriv(x) ( (((5.*a*x + 4.*b)*x + 3.*c)*x + 2.*d)*x + e )\n\n//#define func(x)  ( (((  a*x +    b)*x +    c)*x + d)*x + e )\n//#define deriv(x) ( ((4.*a*x + 3.*b)*x + 2.*c)*x + d )\n\n//#define func(x)  ( ((  a*x +     b)*x + c)*x + d )\n//#define deriv(x) ( (3.*a*x + 2.0*b)*x + c )\n\n//#define func(x)  ( (   a*x + b)*x + c )\n//#define deriv(x) (  2.*a*x + b )\n\n//#define func(x)  ( a*x + b )\n//#define deriv(x) ( a )\n\n#define T ( iTime*0.3 )\n//#define T ( iMouse.x/iResolution.x*20. )\nfloat f(float x)\n{\n    float a = sinOSC(-1.25, 1.25, T * 0.15), b = sinOSC( -2.0,  2.0, T * 0.6), \n          c = sinOSC( -1.0,  1.0, T * 0.45), d = sinOSC( -1.0,  1.0, T * 0.25),\n          e = sinOSC( -1.0,  1.0, T * 0.17), f = sinOSC( -1.0,  1.0, T * 0.07),\n          g = sinOSC( -1.0,  1.0, T * -0.17);\n\n    return func(x);\n}\nfloat dfdx(float x)\n{\n    float a = sinOSC(-1.25, 1.25, T * 0.15), b = sinOSC( -2.0,  2.0, T * 0.6), \n          c = sinOSC( -1.0,  1.0, T * 0.45), d = sinOSC( -1.0,  1.0, T * 0.25),\n          e = sinOSC( -1.0,  1.0, T * 0.17), f = sinOSC( -1.0,  1.0, T * 0.07),\n          g = sinOSC( -1.0,  1.0, T * -0.17);\n          \n    return deriv(x);\n}\n\nfloat gs(float x) { return x >= 0. ? 1. : -1.; } // get_sign\n// If (gs(y0) == gs(y1)) then maxy not converge.\n// Also if range is lange, then may not converge to.\nfloat findRootNRB(\n    float min,\n    float max)\n{\n    /* If you have troubles try to decrease tolerance */\n    const float tolerance = 1e-5; /* Desired precision. */\n    const float EPSILON = 1e-9;  /* Treshold for infinitly small values. */\n    \n    // Data to track.\n    float x = min,\n          prev_x = x,\n          y0 = f(min),\n          y1 = f(x),\n          y2 = f(max),\n          deriv = dfdx(x),\n          y = 9e5;\n\n    const int max_num_of_steps = 32;\n    for (int i = 0; i < max_num_of_steps; i++)\n    {            \n        y = f(x);\n             \n        if ((abs(y) <= tolerance) || // Close enough?\n            (abs(deriv) <= EPSILON)) { break; }\n\n        // Make Newton-Raphson step.\n        x -= y / deriv;  \n        \n        // Failed Newton-Raphson step?\n        if (x < min || x > max || // x step otside search range?\n            gs(y1) != gs(y) ||    // x now from other side of curve?\n            prev_x > x)           // step back?\n        {\n            // Make bisection step.\n            x = min + (max - min) * 0.5;\n            y = f(x);\n            \n            // Update bounds\n            if (sign(y0) == sign(y)) { min = x; }\n            else { max = x; }      \n        }  \n        deriv = dfdx(x);\n        prev_x = x;\n    }\n    \n    // Not neccerealy needed (and can cause problems).\n    x = x >= min && x <= max ? x : 9e5;\n    x = abs(y) < tolerance ? x : 9e5;\n    \n    return x;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = 2.5*TO_CENTERED_NDC(SC);\n\n    float x_min = -1. + sin(iTime);\n    float x_max = 1. + sin(iTime);\n\n    vec3 color = (NDC.x <= x_max && NDC.x >= x_min) ? vec3(.9,.9,.9) : vec3(1.);\n         color -= draw_func(NDC, f(NDC.x), dfdx(NDC.x));\n         color -= x_axis(NDC); color -= y_axis(NDC);\n\n    float x = findRootNRB(x_min, x_max);\n    \n    vec3 colors[3] = vec3[3](\n        vec3(1,0,0),\n        vec3(0,1,0),\n        vec3(0,0,1)\n    );\n\n    /* Root */\n    color = mix(color, vec3(1, 0, 0), SM(diskSDF_L2(NDC, vec2(x, 0.0), 0.05)));\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0));\n}","name":"Common","description":"","type":"common"}]}