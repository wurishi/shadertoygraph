{"ver":"0.1","info":{"id":"tttXWn","date":"1581879893","viewed":103,"name":"Luna Land R","username":"spalmer","description":"my take at a minimal lunar lander clone.\nWASD+arrows+spacebar. Watch your fuel gauge!\nJust try to land anywhere softly enough, for now.\nESC to reset and try again.\n","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["simple","game","retro"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float dLand(vec2 q, float seed)\n{\n    float a = h(q.x + seed);\n    return (q.y-a) * 4.;\n}\n\nfloat dShip(vec2 q)\n{\n    q.x = abs(q.x);\n    return max(\n          dot(q, vec2(.866, .5))-.08\n        , dot(q, vec2(-.05, -.9))-.008);\n}\n\nfloat dFlame(vec2 q, bool on)\n{\n    return on ? length(q)-mix(.02,.04,sin(iTime*24.)) : 9e9; // HACK disc for now\n}\n\n#if 0\n// FIXME doesn't even work!\nfloat dStarsA(vec2 q)\n{ // WIP, pretty lame so far\n\tq *= 5.; //    q = mod(q * 5., 5.);   \n    vec2 i = floor(q);\n    q = fract(q) - .5;\n    return max(0., length(q)//+.27//-.3*rand(dot(i,vec2(.13,.14)))\n       // - .03*(sin(atan(q.y,q.x)*6.28+5.*iTime)*.5+.5)\n        );\n}\n#endif\n\n#if 1\n// fine, I'm stealing this guy's so I don't have to find my \n// jittered grid stuff and heck, cleaning up code is part of the fun.\n// original from https://shadertoy.com/view/WttXW7\n\nfloat hashB(vec2 p)  \n{\n    p = 50.*fract(p*.3183099 + vec2(.71,.113));\n    return fract(p.x*p.y*(p.x+p.y));\n}\n\nfloat dStarsB(vec2 p)\n{\n    float s = 2.;\n    p *= s;    \n    float r = 3.4e38; // any huge number\n    for (int x = -1; x <= 1; ++x)\n    for (int y = -1; y <= 1; ++y) {\n        const float jit = .5;\n        vec2 t = p+vec2(x,y)\n        , c = fract(t)\n        , i = floor(t)\n        , j = vec2(hashB(i), hashB(i+vec2(7.,13.))) * 2. - 1.\n        , k = i+.5+j*jit        \n        , q = p - k;\n        float z = s/176. * (.5+hashB(i))\n        , d = length(q) - z;\n        if (d < r)\n            r = d;\n    }\n    return r / s;\n}\n\n#endif\n\n#if 1\n// try #3, based on the kerned FCC voxel stuff at https://shadertoy.com/view/WlK3Wm\nfloat dStarOn(vec2 q)\n{\n    // the actual object in this cell, wiggled if necessary\n\treturn length(q) - .01; // ball at lattice points\n}\n// FCC tiling keeps the two largest components (of two, in this 2D case)\nfloat dStarOff(vec2 q)\n{\n    vec2 a = abs(q)\n    , d = step(0., q) * 2. - 1.;\n    q -= d; // snap to closest neighbor cell\n    return dStarOn(q) - 1e-3;\n}\n\nfloat dStarsPlaneC(vec2 q)\n{\n    ivec2 i = ivec2(round(q));\n    if (((i.x^i.y)&1) != 0) {\n        vec2 d = q - vec2(i)\n        , a = abs(d);\n        if (a.x > a.y) i.x += int(sign(d.x));\n        else           i.y += int(sign(d.y));\n    }\n    q -= vec2(i);\n    return fract(hash(vec2(i))) > .7 ? //isVoxel(i) ?\n          dStarOn(q)\n        : dStarOff(q)\n        ;\n}\n// multiple planes of it, different scales & rotations\n// decent, but FIXME has antialiasing problems!\nfloat dStarsC(vec2 q, float scale)\n{\n    float s = .5, d = 3.4e38, phi = (sqrt(5.)+1.)*.5;\n    for (int i = 5; i-- > 0; ) {\n        s *= phi; vec2 e = sin(vec2(.5*pi, 0)+s);\n        mat2 r = s * mat2(e.x, -e.y, e.y, e.x);\n        vec2 fw = fwidth(q); float w = 1. + fw.y; //max(fw.x, fw.y); //max(1e-3, );\n        float ds = dStarsPlaneC(r * q) / s; // / scale; // * w * 2. * iResolution.y;\n        ds += exp2(1.*s*scale/iResolution.y) - 1.; // fade out with scale\n            //- 2. / s / iResolution.y; // * 2.; //* w;\n        if (ds < d) d = ds;\n    }\n    return d;\n}\n#endif\n\n#define D(i0, d0) if (d0 < d) { d = d0; i = i0; }\n\n#define dStars dStarsC\n//#define dStars dStarsB\n//#define dStars dStarsA\n\nvoid show(inout vec3 c, vec2 p, vec2 r)\n{\n    mat4 s; st(iChannel0, s);\n    vec2 pq = (p+p-r)/r.y;\n    vec2 q = pq;\n    float ch = h(s[0].x);\n    float scale = clamp(s[0].y + .5 - ch, .75, 3.);\n    q *= scale;\n    q.x += s[0].x;\n    q.y += max(s[0].y,  0.) - .25;\n    float seed = s[0].z;\n    float d = 9e9; int i = 0;\n    vec2 sp = s[0].xy, sr = q - sp;\n    // honestly, I think the way the main fn here handles all the\n    // antialiasing uniformly just isn't working out; \n    // prevents tuning the falloff on the stars, for instance.\n    D(3, dStars(q - sp * .5, scale)); //(sr+q)*.5)); //\n    D(1, dLand(q, seed));\n    D(2, dShip(sr)); //q - sp));\n    D(4, dFlame(sr + vec2( .1,-.01), s[2].x>0.));\n    D(4, dFlame(sr + vec2(-.1,-.01), s[2].x<0.));\n    D(4, dFlame((sr + vec2(0,.02))/1.5, s[2].y>0.));\n    D(4, dFlame(sr/5., s[3].z<=0.));\n    if (s[3].z <= 0.) {\n    \tfloat texp = iTime - s[1].z; // time since death, for animating explosions\n    \t//texp = mod(texp, 5.); // HACK cycle for debugging or just explode again once in a while\n    \tD(4, dFlame(sr/25. / exp2(-2.1*texp), true));\n    \tfor (int i = 0; i < 3; ++i)\n\t    \tD(4, dFlame(sr/2. + sin(float(i)*1.+3.5+vec2(pi/2.,0)) * .7 * texp - vec2(0,1.-exp(.4*texp)), true));\n    }\n    float dc = clamp(d,-2.5,2.5);\n    float g = clamp(.5-.5*r.y*d,0.,1.);\n    c = vec3(g);\n    switch (i) {\n        case 0: break;\n        case 1: c.rb *= .9; break;\n        case 2: c.r *= .5; break;\n        case 3: c.rg *= 5.; c.b *= .9; break;\n        case 4: c.b *= .2; break;\n    }\n//    vec2 n = normalize(vec3(dFdx(dc),dFdy(dc),.1)).xy;\n//    c *= max(0., mix(dot(n,vec2(1,1)*.7), 1., .25)); // fake lighting\n    if (d > 0.) {\n        float blink = max(0.,sin(15.*iTime));\n        if (s[3].z <= 0.) // if destroyed\n    \t\tc = vec3(.5*blink,0,0);\n        // TODO I want a little flag to raise, \n        // but blinking bg green will have to do for now\n        // in fact this whole logic should really be in BufferA\n        // since it's game state related.  HAX!\n\t    else if (s[0].y <= ch+.0155 && length(s[1].xy)<3e-3)\n        \tc = vec3(0,.5*blink,0);\n    }\n//    c.xy=n*.5+.5;\n    // ground color should be based on score of that zone\n//    q -= s[0].xy;\n    if (pq.y < -.98 && abs(pq.x)<=1.)\n        c = pq.x*.5+.5 < s[3].y/10. ? vec3(0,.7,0) : vec3(.7,.5,0);\n    // can show various data for debugging also\n    c = sqrt(c); // good 'nuff\n}\n\nB(show)\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//const int sP=0,sV=1; // slots\n\nconst float pi = acos(-1.); //3.1415927;\n\n// read game state from buffer A\nvoid st(sampler2D A, out mat4 s)\n{\n    for (int j=0; j<2; ++j)\n        for (int i=0; i<2; ++i)\n            s[j*2+i] = texelFetch(A, ivec2(i,j), 0);\n}\n// signed\nfloat rand(float x)\n{\n    return sin(43658.7*fract(x*6.3));\n}\n// signed\nfloat hash(vec2 q)\n{\n    return rand(dot(q, vec2(11., 7.)));\n}\n\nfloat fbm(float x)\n{\n    //const vec3 o=vec3(1,2,4);\n    //const vec4 o=vec4(1,2,4,8);\n    return 1./(1.+.5+.25) * ( // 1./dot(1.,o)\n          rand(x) \n        + rand(x*2.) * .5\n        + rand(x*4.) * .25\n       );\n}\n\n\nfloat rh(float x)\n{\n    return fbm(x * 4e-6);\n    const vec4 o=vec4(1,2,4,8);\n    return dot(abs(sin(o*6.3*7.*x)),1./o) * 1.-1.;\n    return pow(fract(rand(x*.1)),4.) * 2.-1.;\n}\n\n// idk that this is any good yet.  No, I definitely know \n// that it's not yet any good.  It's passable at best.\nfloat h(float x)\n{\n//    x *= 3e-6;\n//    return rh(x);\n//    x += sin(x*5.) * .25; // the idea is to warp the field index so that cells are different sizes\n    float n = floor(x);\n    float k = abs(rand(n));\n    x -= n;\n    \n    float m = x;\n    //m = mix(x, .5, 1.-abs(x - .5)*2.); // semi-flattens the midpoints of all cells, which makes some interesting hills.  A bit spiky and oddly curved and flat though.\n    // really only want to do that on some of the larger ones though\n    //m = mix(x, .5, (1.-abs(x - .5)*2.)*.95*pow(k,8.)); // flatten midpoints some cells randomly to provide some good landing spots\n    //m = mix(x, .5, pow(1.-abs(x - .5)*2., .25)*.95*pow(k,8.)); // really extra flatten midpoints some cells randomly to provide some good landing spots - looks weirdly artificially curved though\n    //m = mix(x, .5, .95*pow(k,8.)); // HACK rotate toward flat some cells randomly\n    //m = .5; // HACK just totally flatten\n    return mix(rh(n), rh(n+1.), m);\n}\n\n#define B(f) void mainImage(out vec4 c, vec2 p) { f(c.rgb, p, iResolution.xy); c.a = 1.; }\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define KEY(i) (texelFetch(iChannel1,ivec2(i,0),0).x>.5)\n\nvoid state(inout vec3 c, vec2 p, vec2 r)\n{\n    if (!all(lessThan(p, vec2(2)))) return;\n    mat4 s; st(iChannel0, s); //vec4 m = iMouse;\n    bool init = iFrame==0; bool reset = init;\n    if (KEY(27)) // ESC?\n        init = true; // reset/restart game\n    c = reset ? vec3(0) : texelFetch(iChannel0, ivec2(p), 0).rgb;\n    int dat = int(p.x)+2*int(p.y);\n    float dt = iTimeDelta;\n    \n    bool gas = s[3].y > 0. && s[3].z > 0.; // fueled and alive? can thrust\n    bool kU = gas && (KEY(87)||KEY(38)||KEY(83)||KEY(40)||KEY(32) // QWERTY\n                      ||KEY(90)||KEY(188)||KEY(79)); // AZERTY/DVORAK\n    bool kL = gas && (KEY(65)||KEY(37)||KEY(81));\n    bool kR = gas && (KEY(68)||KEY(39)||KEY(69));\n    float seed = s[0].z;\n    float g = h(s[0].x + seed);\n    float geps = .01;\n    float g2 = h(s[0].x + seed + geps);\n    float deriv = (g2 - g) / geps;\n    bool aground = s[0].y <= g+.015;\n    if (init) switch (dat) {\n        case 0:\n        \tc.x = rand(iDate.w*3e-8)*43.;\n        \tc.y = 1.19;\n        \tc.z = mod(iDate.w, 128.); // random seed for terrain\n        \tbreak;\n        case 1:\n        \tc.x = rand(iDate.w*1e-8)*.5;\n        \tc.y = .01;\n\t        break;\n        case 2:\n\t        break;\n        case 3:\n        \tc = vec3(0.,10.,100.);\n\t        break;\n    } else switch (dat) {\n    \tcase 0: {\n        \tc.xy += s[1].xy * dt;\n            if (aground) {\n        \t\tc.y = max(c.y, g-.025);\n            }\n            //c = vec3(pos.x,pos.y,0);\n\t        break;\n        }\n        case 1:\n\t        if (kU) { // thrusting?\n                c.y += dt*.25;\n        \t}\n        \tc.x += dt*123.5*((kR?1.:0.)-(kL?1.:0.))/r.x;\n        \tif (aground) {\n        \t\tc.y = max(c.y, 0.);\n                c.x *= exp2(-1.2*dt); // friction\n            } else\n            \tc.y -= dt * .03; // gravity\n        \t//c = vec3(vel.x,vel.y,0);\n\t\t\tif (s[3].z <= 0. && c.z == 0.) c.z = iTime; // record timestamp of death, for explosion chunk animation\n\t        break;\n        case 2:\n        // TODO store thrust so Image shader can draw flames\n        \tc = vec3(int(kR)-int(kL), kU, s[0].y - g);\n        // TODO if we stored altitude, image shader wouldn't have to compute it\n\t        break;\n        case 3:\n        \t//c = vec3(score,fuel,health);\n            c.y = max(c.y - dt * (1.5*float(kU)+.5*(float(kL)+float(kR))), 0.); // use fuel\n    \t\tif (aground)\n                c.z -= 7500.*dt*length(s[1].xy); // damage\n        // TODO explosions!  chunks\n\t        break;\n    }\n}\n\nB(state)\n\n","name":"Buffer A","description":"","type":"buffer"}]}