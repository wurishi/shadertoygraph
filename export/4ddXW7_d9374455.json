{"ver":"0.1","info":{"id":"4ddXW7","date":"1460420796","viewed":196,"name":"Functional Animation","username":"akohdr","description":"Playing with time dependent macros and simple 2D animation overlays.\nClick to move Green point, last quadrant clicked selects underlying texture.\nIncludes Barycentric coordinate triangle test function.\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","animation","barycentric","functional"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Barycentric 2D triangle test (order of a,b,c irrelevant)\n#define TRIABC(p,a,b,c) triBarycentricSwizzle2(vec4(p,a),vec4(b,c))\n//#define TRIABC triBarycentricSwizzle\n//#define TRIABC triBarycentric\n\n// outline width 5.0\n//#define TRIABC(p,a,b,c) abs(sdTriangle(a,b,c,p))<5.0\n\n// filled when facing\n//#define TRIABC(p,a,b,c) sdTriangle(a,b,c,p)<0.\n\n// hollow mask when facing\n//#define TRIABC(p,a,b,c) sdTriangle(a,b,c,p)>0.\n\n// box test\n//#define TRIABC(p,a,b,c) (BOXAB(p,MIN3(a,b,c),MAX3(a,b,c))&&length(a+b+c)<5.)\n\n#define Q(q) if(q) return true;\n#define QF(q) if(q) return false;\n#define QOR(a,b,c) {Q(a); Q(b); Q(c);}\n#define QORF(a,b,c) {QF(a); QF(b); QF(c);}\n\n// Barycentric method for filled 2D triangle\nbool triBarycentricSwizzle2(const in vec4 a, const in vec4 b) \n{\n    vec4 p = vec4(a.z,b.wxy) - vec4(b.xyz,a.w),\n         q = vec4(a.wz, b.yx) * b,\n         r = vec4(q.zx - q.wy, a.zw * b.wz),\n         s = a.yxyx * p;\n    vec2 t = (r.xy + s.yw + s.zx)/(r.x + r.y + r.z - r.w);\n    return !(t.x<0.||t.y<0.||(t.x + t.y)>1.);\n}\n\n// Barycentric method for filled 2D triangle\nbool triBarycentricSwizzle(const in vec2 p, const in vec2 a, const in vec2 b, const in vec2 c) \n{\n    vec4 q = vec4(b.yx, a.yx)*vec4(a,c),\n         r = vec4(q.zx - q.wy, b*c.yx),\n         s = p.xyxy*(vec4(c.y,a,b.x) - vec4(a.y,c.x,b.y,a.x));\n    vec2 t = (r.xy + s.xz + s.yw)/(r.x + r.y + r.z - r.w);\n    return !(t.x<0.||t.y<0.||(t.x + t.y)>1.);\n}\n\n// Barycentric method for filled 2D triangle\nbool triBarycentric(const in vec2 p, const in vec2 a, const in vec2 b, const in vec2 c) \n{\n    // could likely vectorize/swizzle further\n    vec2 pac = a.yx*c.xy,\n         pab = a.xy*b.yx;\n    \n    float ax=a.x, ay=a.y, bx=b.x, by=b.y, cx=c.x, cy=c.y, px=p.x, py=p.y,\n\n// the method:\n//          f = ay*(cx - bx) + ax*(by - cy) + bx*cy - by*cx,\n//          s = (ay*cx - ax*cy + (cy - ay)*px + (ax - cx)*py)/f,\n//          t = (ax*by - ay*bx + (ay - by)*px + (bx - ax)*py)/f;\n\n          // some partials\n//          aycx = ay*cx, \n//          axby = ax*by, \n//          axcy = ax*cy, \n//          aybx = ay*bx,\n//          aycx_axcy = aycx - axcy, \n//          axby_aybx = axby - aybx,\n          aycx_axcy = pac.x - pac.y, \n          axby_aybx = pab.x - pab.y,\n        \n          // compute f,s,t\n          f = aycx_axcy + axby_aybx + bx*cy - by*cx,\n          s = (aycx_axcy + (cy - ay)*px + (ax - cx)*py)/f,\n          t = (axby_aybx + (ay - by)*px + (bx - ax)*py)/f;\n\n    // boolean test s>0 & t>0 & s+t<1 to see if we're in triangle a,b,c\n\n// really need disassembly to see what compiler generates.\n//    return s>0. && t>0. && s+t<1.;\n//    return !(s<0. || t<0. || s+t>1.);\n    QORF(s<0., t<0., (s+t)>1.)\n    return true;\n}\n\n// Range test (use logical equivalences to eng. early return for particular use case)\n#define RNGT(a,l,v,u,b,c) a l v c v u b\n\n// Normal form decorator ensures a<b before applying ternary op F\n#define NF(F,a,c,b) ((a<b) ? F(a,c,b) : F(b,c,a))\n\n// Deal with non-commutative ops explicitly\n#define AOPB(a,c,b) (a c b)\n#define BOPA(a,c,b) (b c a)\n\n// abs difference between two terms\n#define DIF(a,b) NF(BOPA,a,-,b)\n// shorthand\n#define DIFy(a,b) DIFc(a.y,b,y)\n#define DIFx(a,b) DIFc(a.x,b,x)\n\n// call-less ABS eesentially expands to ternary assignment (compiler should do this)\n// (watch the LISPy-ness use of brackets a is src term not value)\n#define ABS(a) DIF((a),0.)\n#define ABSI(a) DIF((a),0)\n\n#define IN_AND(a,v,b) RNGT(a,<=,v,<=,b,&&)\n#define IN_OR(a,v,b) !(RNGT(a,>,v,>,b,||))\n#define IN IN_OR\n\n#define OUT_AND(a,v,b) !RNGT(a,<=,v,<=,b,&&)\n#define OUT_OR(a,v,b) RNGT(a,>,v,>,b,||)\n#define OUT OUT_OR\n\n#define MID(a,b,f) ((a<b) ? a+(f-a)*(a/b) : b+(f-b)*(b/a))\n#define MIDF(a,b,f) vec2(MID(a.x,b.x,f.x),MID(a.y,b.y,f.y))\n\n#define MIN3(a,b,c) min(a,min(b,c))\n#define MAX3(a,b,c) max(a,max(b,c))\n\n#define BOXAB_IN(p,a,b) NF(IN,a.x,p.x,b.x)&&NF(IN,a.y,p.y,b.y)\n#define BOXAB_OUT(p,a,b) !(NF(OUT,a.x,p.x,b.x)||NF(OUT,a.y,p.y,b.y))\n#define BOXAB BOXAB_OUT\n\n#define DISK(p,c,r) length(p-c)<r\n//#define HLINE(p,c,r) abs(p.y-c.y)<r\n#define HLINE(p,c,r) DIFy(p,c)<r\n\n//#define VLINE(p,c,r) abs(p.x-c.x)<r\n#define VLINE(p,c,r) DIFx(p,c)<r\n\n// variations on theme\n#define TRI1a(p,c,r,h,v) ABS(p.x-c.x)<r-ABS(p.y-c.y) && p.y v c.y && p.x h c.x\n#define TRI1b(p,c,r,h,v) abs(p.y-c.y)<r-abs(c-p).x && p.y v c.y && p.x h c.x\n#define TRI1c(p,c,r,h,v) DIF(p.x,c.x)<r-DIF(p.y,c.y) && p.y v c.y && p.x h c.x\n#define TRI2a(p,c,r,h,v) abs(p.x-c.y)<r-abs(c-p).y && p.y v c.y && p.x h c.x\n#define TRI2b(p,c,r,h,v) abs(p.x-c.y)<r-abs(c-p).y && p.y v c.y && p.x h c.x\n\n#define TRI3(p,c,r,h,v) abs(p.x-c.y)<r+abs(c-p).y && p.x v c.x && p.y h c.y\n#define TRI4(p,c,r,h,v) abs(p.x-c.x)<r+abs(c-p).y && p.y v c.y && p.x h c.x\n#define TRI5(p,c,r,h,v) abs(p.y-c.x)<r+abs(c-p).x && p.y v c.y && p.x h c.x\n#define TRI6(p,c,r,h,v) abs(p.y-c.y)<r+abs(c-p).x && p.y v c.y && p.x h c.x\n\n#define QUAD(p,c,r,h,v) abs(p.x-c.x)<r+abs(c-p).x && p.y v c.y && p.x h c.x\n#define DIA1(p,c,r) abs(p.x-c.y)<r-abs(c-p).y && p.x < c.x && p.x < c.x\n\n#define TRI_112(p,c,r,h,v) abs(p.x-c.x)<r-abs(c-p).y && p.y v c.y && p.x h c.x\n\n#define TRI TRI1c\n\n#define QC(C,p) if(p) {fc=C;return;}\n#define WHT vec4(1.,1.,1.,1.)\n#define RED vec4(1.,.0,.0,1.)\n#define GRN vec4(.0,1.,.0,1.)\n#define BLU vec4(.0,.0,1.,1.)\n#define YEL vec4(1.,1.,.0,1.)\n#define ORG vec4(1.,.5,.0,1.)\n#define PNK vec4(1.,.0,.5,1.)\n#define SLM vec4(1.,.5,.5,1.)\n#define MAG vec4(1.,.0,1.,1.)\n#define CYN vec4(0.,1.,1.,1.)\n#define PRP vec4(.5,.0,.5,1.)\n#define vO vec2(0,0)\n\n#define iM iMouse\n#define iR iResolution\n#define iT iTime\n\n#define sT(a,f) a*sin(f*iT)\n#define asT(a,f) abs(a*sin(f*iT))\n#define cT(a,f) a*cos(f*iT)\n#define acT(a,f) abs(a*cos(f*iT))\n\n#define linT(a,st,dt,t) a*smoothstep(st,st+dt,t)\n\n// Returns background based on last quadrant clicked\nvec4 quadrantChannel(const in vec2 P) {\n\n    vec2 irxy = iR.xy, \n         ctr = irxy/2., \n         uv = P/irxy;\n\n    return iM.x<ctr.x ? \n        \tiM.y>ctr.y ? texture(iChannel0, uv) : texture(iChannel3, uv) :\n        \tiM.y>ctr.y ? texture(iChannel1, uv) : texture(iChannel2, uv);\n}\n\n// Distance func just seems like bit of overkill....\n\n// signed distance to a 2D triangle (iq)\nfloat sdTriangle( in vec2 a, in vec2 b, in vec2 c, in vec2 p )\n{\n\tvec2 e0 = b - a, e1 = c - b, e2 = a - c, v0 = p - a, v1 = p - b, v2 = p - c,\n\n\t     pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 ),\n\t     pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 ),\n\t     pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 ),\n    \n         d = min( min( vec2( dot( pq0, pq0 ), v0.x*e0.y-v0.y*e0.x ),\n                       vec2( dot( pq1, pq1 ), v1.x*e1.y-v1.y*e1.x )),\n                       vec2( dot( pq2, pq2 ), v2.x*e2.y-v2.y*e2.x ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvoid mainImage( out vec4 fc, in vec2 P ) {\n    \n\tvec2 ctr = iR.xy/2.,\n         uv = P/iR.xy;\n\n    // Lissajous path\n    float r = min(ctr.x,ctr.y)-iR.x/40.;\n    vec2 orb = vec2(sT(r,3.),cT(r,2.)),\n         lp = ctr + orb;\n    \n\t// cyan triangle\n    vec2 a = ctr + orb,\n         b = ctr - orb,\n         c = iM.xy;\n    \n    vec2 co = normalize(P.xy);\n    QC((CYN+vec4(co.xy,co.xy))/1.6, TRIABC(P,a,b,c))\n    QC(quadrantChannel(P), BOXAB(P,a,b))\n\n    float sz = 10.+abs(cT(20.,.5));\n        \n    QC(RED, TRI(P, lp, sz, <, >))\n    QC(GRN, TRI(P, lp, sz, >, >))\n    QC(BLU, TRI(P, lp, sz, <, <))\n    QC(YEL, TRI(P, lp, sz, >, <))\n\n    QC(YEL, DISK(P, ctr.xy + orb.xy, sz))\n    QC(GRN, DISK(P, iM.xy, sz))\n\n    float l = asT(100.,3.);\n    QC(ORG,NF(IN,l, P.x, l+sT(iR.x/3.,2.)))\n    QC(PRP,IN(l, P.y, l+asT(iR.y/2.,2.)))\n        \n    QC(vec4(2.*P.xy,1.,1.)/iR.x*asT(1.,2.), DISK(P, P, sz))\n    \n    fc = quadrantChannel(P);\n}\n\n","name":"Image","description":"","type":"image"}]}