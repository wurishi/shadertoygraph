{"ver":"0.1","info":{"id":"Xt33Dj","date":"1471485498","viewed":255,"name":"Simple 2D Terrain Lighting","username":"Incin","description":"Maybe to be used with a 2D platformer where you don't want the player to see all the way down, but you still want them to be able to see a little bit. You can use the mouse to move the light.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["2d","terrain","lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 bgc = vec3(0.5, 0.7, 0.9);\nconst int stepA = 5;\nconst int steps = 256;\n\nvec2 lightPos = vec2(0, 0);\n\nfloat sqLength(vec3 vec) {\n    return (vec.x * vec.x + vec.y * vec.y + vec.z * vec.z);\n}\n\nfloat sqDist2(vec2 vect1, vec2 vect2) {\n    return (vect1.x * vect1.x - vect2.x * vect2.x) + (vect1.y * vect1.y - vect2.y * vect2.y);\n}\n\nfloat march(vec2 pos) {\n    float time = 0.0;\n    vec2 mPos = pos;\n    vec2 stepVec = normalize(lightPos - pos) * float(stepA);\n    float dist = distance(pos, lightPos);\n    \n    for (int i = 0; i < steps; i++) {\n        if (distance(pos, mPos) >= dist) {\n            break;\n        }\n        if (sqLength(texture(iChannel0, mPos.xy / iResolution.xy).xyz) == 0.0) {\n            time = time + 0.2;\n            // Should be lit less as it travels further through the air, but not as\n            // much as going through the ground\n        } else {\n            time = time + 1.0;\n        }\n        mPos = mPos + stepVec;\n    }\n    return time;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iMouse.x <= 1.0 && iMouse.y <= 1.0) {\n        lightPos = vec2((sin(iTime) + 1.2) * iResolution.x / 3.0, (2.95 * iResolution.y) / 4.0);\n    } else {\n        lightPos = iMouse.xy;\n    }\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 terrain = texture(iChannel0, uv);\n    fragColor = vec4(bgc, 1);\n    if (sqLength(terrain.xyz) > 0.) {\n        fragColor = terrain;\n    }\n        fragColor -= march(fragCoord.xy) / 100.;\n    //} else {\n    //    fragColor = vec4(bgc, 1);\n    //}\n    \n    if (distance(fragCoord.xy, lightPos) < 10.0) {\n        fragColor += vec4(1.0 - distance(fragCoord.xy, lightPos) / 10.);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    if (uv.y < 0.65 + sin(uv.x * 15.0) * 0.03) {\n    \tfragColor = texture(iChannel0, uv);\n    } else {\n        fragColor = vec4(0);\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}