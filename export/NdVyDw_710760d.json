{"ver":"0.1","info":{"id":"NdVyDw","date":"1654978292","viewed":217,"name":"Swirly Things (updated)","username":"snolot","description":"Adding new shape\nAdding mouse","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","domain"],"hasliked":0,"parentid":"7dVyz1","parentname":"Swirly Things"},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// PLENTO\n\n\n\n\n#define FAR 80.0\n#define DISTANCE_BIAS 0.26\n#define HASHSCALE1 .1031\n#define EPSILON 0.001\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return max(q.x, max(q.y, q.z));\n}\n\nfloat box(vec2 p, vec2 b) {\n    vec2 q = abs(p) - b;\n    return max(q.x, q.y);\n}\n\nvec2 shape(vec3 p) {\n    float a = box(p, vec3(0.1, 0.1, 2.0)); // plastic box.\n   \n    p = -abs(p) + vec3(.1); // mirror space to save on distance evaluations\n    float ce = 0.02;\n\t// edges.\n    float b = box(p - vec3(.1, 0, 0), vec3(.1 + ce, ce, ce));\n    float c = box(p - vec3(0, 0, .1), vec3(ce, ce, .1 + ce));\n    float d = box(p - vec3(0, .1, 0), vec3(ce, .1 + ce, ce));\n    \n    vec2 s = vec2(a, 2.0); // 2.0 == material id for white plastic.\n    vec2 t = vec2(min(min(b, c), d), 1.0); // 1.0 == material id for metal.\n    \n    return s.x < t.x ? s : t;\n}\n\n\nvec2 map(vec3 rp){\n    float t = iTime * .3;\n \n    vec3 pos = rp; - vec3(1.0, -.5, 2.0);\n\n    pos = abs(pos.xyz + 1.0) - 1.0;\n    pos=pos*2./clamp(dot(pos.xyz,pos.xyz),.3,1.)-vec3(0.5,1.5,0.5);\n    vec3 b = vec3(1., 1.0, .1);\n   \n    //pos.xy *= rot(pos.z*0.2);\n    \n    pos.y += sin(pos.z + iTime + pos.x*1.0)*0.6;\n    pos.x += cos(pos.y - pos.z * 1.0 + iTime)*0.3;\n    pos = mod(pos, b)-0.5*b;\n\n     \n    vec2 res = shape(pos);// sdBox(pos, vec3(0.1, 0.1, 2.0));\n   \n  \n    return res;\n}\n\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0.0035, -0.0035); \n    return normalize(\n        e.xyy * map(p + e.xyy).x + \n        e.yyx * map(p + e.yyx).x + \n        e.yxy * map(p + e.yxy).x + \n        e.xxx * map(p + e.xxx).x);\n}\n\n// swirly color thing\nvec3 oc(vec3 p, float id)\n{\n    p.xy *= rot(p.z*0.64);\n    vec3 c = (id > 1.) ? vec3(1.,.7,0.) : vec3(1.3,.1,.1);\n    \n    vec3 col = c;// mix(vec3(1.0, 0.7, 0.) *c, vec3(1., .2, 0.0) *c,  smoothstep(1.0, 0., abs(p.z)-.3));\n    return col;\n}\n\nvec3 color(vec3 ro, vec3 rd, vec3 norm, vec3 lp, vec2 t)\n{\n    \n    // Lighting\n    vec3 ld = lp-ro;\n    float lDist = max(length(ld), 0.001); // Light to surface distance.\n    float atten = 1.0 / (1.0 + lDist*0.2 + lDist*lDist*0.1); // light attenuation \n    \n    ld /= lDist;\n    \n    // Diffuse\n    float diff = max(dot(norm, ld), 0.0);\n    \n    // specular\n    float spec = pow(max( dot( reflect(-ld, norm), -rd ), 0.0 ), 12.0);\n    \n    //Colors\n    vec3 objCol = oc(ro, t.y);\n    \n   \n   // objCol = oc(ro);\n    \n    vec3 sceneCol = (objCol*(diff + 0.15) + vec3(1.0, 1.0, 1.0)*spec*1.2) * atten;\n   \n    // Get final color\n    return sceneCol;\n    \n}\n\nvec2 trace(vec3 ro, vec3 rd)\n{\n    vec2 t = vec2(0.0,1.0);\n    vec2 d = vec2(0.0,1.0); \n   \n    for (int i = 0; i < 100; i++) \n    {\n        d = map(ro + rd*t.x);\n       \n        if(abs(d.x)<EPSILON || t.x > FAR) break;\n         \n        \n        t.x += d.x * DISTANCE_BIAS;\n        t.y = d.y;\n    }\n    return t;\n}\n\nvec2 traceRef(vec3 ro, vec3 rd){\n    \n    vec2 t = vec2(0.0,1.0);\n    vec2 d = vec2(0.0,1.0); \n    \n    for (int i = 0; i < 200; i++)\n    {\n        d = map(ro + rd*t.x);\n      \n        if(abs(d.x)<.0025 || t.x>FAR) break;\n        \n        t.x += d.x;\n        \n        t.y = d.y;\n    }\n    \n    return t;\n}\n\n\n// Triplaniar blending of 2d materials to 3d surfaces.\n// Got this from Shane (THE GOAT).\nvec3 tex3D(vec3 p, vec3 n, sampler2D s) {\n    vec3 m = pow(abs(n), vec3(10.0));\n    m /= dot(m, vec3(1));\n    \n    vec3 x = texture(s, p.yz).rgb;\n    vec3 y = texture(s, p.xz).rgb;\n    vec3 z = texture(s, p.xy).rgb;\n    \n    return m.x*x*x + m.y*y*y + m.z*z*z;\n}\n\n// Normal bumping based on material. Also got this from Shane.\nvec3 bump(vec3 p, vec3 n, float bf, float f) {\n    p *= f;\n    vec2 h = vec2(0.001, 0.0);\n    vec3 g = mat3(\n        tex3D(p + h.xyy, n, iChannel1) - tex3D(p - h.xyy, n, iChannel1),\n        tex3D(p + h.yxy, n, iChannel1) - tex3D(p - h.yxy, n, iChannel1),\n        tex3D(p + h.yyx, n, iChannel1) - tex3D(p - h.yyx, n, iChannel1))\n        *vec3(0.299, 0.584, 0.114); // grey scale.\n    \n    g -= n*dot(n, g);\n    \n    return normalize(n + bf*g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; \n    vec2 mo = (3.0*iMouse.xy - 1.5*iResolution.xy)/iResolution.y;\n    if(iMouse.z <= 0.0) mo = vec2(0);\n \n \n    vec3 ro = vec3(0.0, 0.0, 10.0); \n    ro.y += sin(ro.z + iTime + ro.x*1.0)*0.6;\n    ro.xy += mo;\n    vec3 rd = normalize(vec3(uv,2.0));\n    //ro.z -= iTime * 0.7;\n   \n    // fish eye\n     rd = normalize(vec3(uv, 1.0 - dot(uv, uv) * 0.75));\n    \n    // light position\n    vec3 lp = ro + vec3(0.0, 1.0, -0.5);\n    \n    \n    // Scene\n    vec2 t = trace(ro, rd);\n \n    ro += rd * t.x;\n    vec3 rr = ro;\n    vec3 norm = getNormal(ro); \n    \n    vec3 col = color(ro, rd, norm, lp, t);\n    \n    float fog = t.x;\n    \n   \n    // Reflection  \n    rd = reflect(rd, norm);\n    \n    t = traceRef(ro +  rd*.01, rd);\n    \n    ro += rd*t.x;\n    \n    norm = getNormal(ro);\n   \n    col += color(ro, rd, norm, lp, t) * 0.25;\n  \n    vec3 p = ro +  rd * t.x;\n    \n    fog = smoothstep(0.0, 0.15, fog / 30.);\n    col = mix(col, vec3(0), fog);\n   \n   // col *= smoothstep(2.0, 0.29, length(uv));\n    \n    fragColor = vec4(sqrt(clamp(col, 0.0, 1.0)), 1.0);\n \n}","name":"Image","description":"","type":"image"}]}