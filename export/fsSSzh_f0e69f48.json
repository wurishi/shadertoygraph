{"ver":"0.1","info":{"id":"fsSSzh","date":"1625233303","viewed":175,"name":"Haru86_RaymarchHole","username":"Haru86_","description":"Haru86_RaymarchHole","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","previewfilepath":"/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n float rand(vec2 st)\n{\n    return fract(sin(dot(st, vec2(12.9898, 78.233))) * 43758.5453);\n}\n              \n\nvec2 pmod(vec2 p, float n)\n{\nfloat a = atan(p.x, p.y) + PI / n;\nfloat th = 2.0 * PI / n;\na = floor(a / th) * th;\nreturn rot(a)* p;\n}\n\nfloat Cube(vec3 p, float s)\n{\np = abs(p);\nreturn length(max(p - vec3(s, s, s), 0.0));\n}\n\nfloat sdCross(vec3 p, float scale)\n{\np = abs(p);\nfloat dxy = max(p.x, p.y);\nfloat dyz = max(p.y, p.z);\nfloat dzx = max(p.z, p.x);\nreturn min(dxy, min(dyz, dzx)) - scale;\n}\n\n\nfloat menger(vec3 p)\n{\n    float k = 1.;\n    p.z = mod(p.z, k) - 0.5 * k;\n\n    //\n    float s = .8;\n    p = abs(p);\n    float d = Cube(p, s);\n    //\n    float scale = 4.;\n    //\n    float h = 1.5;\n    for (int i = 0; i < 4; i++)\n    {\n\n        p = mod(p, h) - h * 0.5;\n        s *= scale;\n        p = 1.0 - scale * abs(p);\n        //\n        d = max(d, sdCross(p, .75) / s);\n\n    }\n\n    return d;\n}\n\nfloat sdHexPrism(vec3 p, vec2 h)\n{\nconst vec3 k = vec3(-0.8660254, 0.5, 0.57735);\np = abs(p);\np.xy -= 2.0 * min(dot(k.xy, p.xy), 0.0) * k.xy;\nvec2 d = vec2(\n    length(p.xy - vec2(clamp(p.x, -k.z * h.x, k.z * h.x), h.x)) * sign(p.y - h.x),\n    p.z - h.y);\nreturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n#define rootT 1.73205080757\n\n\nfloat hex(vec3 p,float height) {\n    p.yz *=rot(PI / 2.0); \n    p.xy *=rot(PI / 2.0); \n\n    float r = .015;\n    float l = .015;\n    p.z -= height;\n    p.xy = abs(p.xy);\n    float offset = 0.025;\n\n    vec3 pos1 = p;\n    vec3 pos2 = p;\n    vec2 off1 = vec2(2.0, 2.0 * rootT) * r + vec2(offset, offset);\n\n\n\n\n    pos1.x = mod(pos1.x, off1.x) - off1.x * 0.5;\n\n\n    pos2.x= mod(pos2.x + 0.5 * off1.x, off1.x) - off1.x * 0.5;\n    pos2.y -= off1.y * 0.5;\n\n\n    float d1 = sdHexPrism(pos1, vec2(r, l));\n    float d2 = sdHexPrism(pos2, vec2(r, l));\n\n\n\n\n    d1 = min(d1, d2);\n\n    return d1;\n}\n\nfloat AirPlane(vec3 p){\n\n    return 1.0;\n\n}\n\nfloat map(vec3 p,inout float flash)\n{\n     vec3 pos2=p;\n     p.z -= iTime * 0.5;\n    \n    \n    /////////////////////////\n    vec3 pos = p;\n    pos=abs(pos)-0.5;\n    pos.z-=0.5;\n    pos.z-=0.2;\n    pos.z-=0.5;\n    pos.z-=0.1;\n    \n    pos.xy = pmod(pos.xy, 10.0);\n    float k=1.2;\n    pos=mod(pos,k)-k*0.5;\n    float d2 = menger(pos);\n  \n    if (d2 < 0.001) {\n        flash =1.0- abs(sin(p.z+iTime*4.0));\n        flash += .15;\n        flash = clamp(flash,0.0, 1.0);\n    }\n    \n    ////////////////////////\n    //pos2\n    float d3=AirPlane(pos2);\n    \n    \n    ////////////////////////\n    \n\n    return d2;\n\n\n\n}\n\n\nvec3 gn(vec3 p) {\n    vec2 e = vec2(0.0001, 0.0);\n    float flash = 0.0;\n    return normalize(vec3(\n        map(p + e.xyy, flash) - map(p - e.xyy, flash),\n        map(p + e.yxy, flash) - map(p - e.yxy, flash),\n        map(p + e.yyx, flash) - map(p - e.yyx, flash)\n        ));\n}\n\nvec3 hsv2rgb2(vec3 c, float k) {\n    return smoothstep(0. + k, 1. - k,\n        .5 + .5 * cos((vec3(c.x, c.x, c.x) + vec3(3., 2., 1.) / 3.) * radians(360.)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n   vec2 st=(fragCoord.xy*2.-iResolution.xy)/min(iResolution.x,iResolution.y);\n//st*=rot(iTime);\n float radius=.25;\n   float phi=iTime*0.2;\n   \n   vec3 ro=vec3(0.0,-0.05,1.0);\n  // vec3 ro=vec3(radius*cos(phi),0.0,radius*sin(phi));\n   //vec3 rd=normalize(vec3(uv.xy,-3.0));\n   vec3 ta=vec3(0.0,0.0,0.0);\n   \n   vec3 cDir=normalize(ta-ro);\n   vec3 side=cross(cDir,vec3(0.0,1.0,0.0));\n   vec3 up=cross(cDir,side);\n   float fov=0.6;\n   \n   vec3 rd=normalize(vec3(st.x*side+st.y*up+cDir*fov));\n    \n      vec3 col = vec3(0., 0., 0.);\n\n    float d, t, acc, flash = 0.0;\n    float adjD = .75;\n\n    for (int i = 0; i < 80; i++)\n    {\n        d = map(ro + rd * t, flash);\n        if (d < 0.001 || t>1000.0)break;\n        t += d * adjD;\n        acc += exp(-1.0 * d);\n\n\n    }\n\n    vec3 refRo = ro + rd * t;\n    vec3 n = gn(refRo);\n    //rd = refract(rd, n,.25);\n    rd = reflect(rd, n);\n    ro = refRo;\n    t = 0.1;\n    float acc2, flash2 = 0.0;\n    for (int i = 0; i < 20;i++){\n        d = map(ro + rd * t, flash2);\n        if (d < 0.0001 || t>1000.0)break;\n        t += d * adjD;\n        acc2 += exp(-1.0 * d);\n    }\n    float H = mod(iTime*0.1, 1.0);\n    col = acc * hsv2rgb2(vec3(H,1.0,1.0),2.2) * 0.08 * flash;\n    //col += acc2 *vec3(1.,1.,1.) * 0.01 * flash2 ;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}