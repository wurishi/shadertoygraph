{"ver":"0.1","info":{"id":"NsjGRt","date":"1617819345","viewed":561,"name":"Soul - 22 (interactive)","username":"AmarnathMurugan","description":"An interactive real-time sdf portrait of the character 22 from the pixar movie Soul. \n\nControls : \nMouse Drag: Eyes\nZ/X - Zoom\nArrow Keys: Orbit","likes":23,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","sdf","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//============ References ==========\n// sdfs & ops : https://iquilezles.org/articles/distfunctions\n// volumetric raytracing : https://blog.uhawkvr.com/rendering/rendering-volumetric-clouds-using-signed-distance-fields/\n//==================================\n\n#define MAX_STEPS 50\n#define threshold 0.1\n#define MAX_DIST 2.0\n#define step_size 0.01\n\nstruct sdfRes\n{\n    float d,a,isVol;\n    vec3 col;\n};\n\nvec2 mo;\nvec3 baseCol = vec3(.753,1.,.721);\nvec3 lightPos = vec3(1.,1.0,1.0);\n\nfloat invMix(float a,float b,float t)\n{\n    return (t-a)/(b-a);\n}\n\nfloat smin(float a,float b,float t)\n{\n    float h = clamp(0.5+0.5*(b-a)/t,0.0,1.0);\n    return mix(b,a,h) - h*(1.0 - h)*t;\n}\n\nvec3 smin(vec3 a,vec3 b,float t)\n{\n    vec3 h = clamp(0.5+0.5*(b-a)/t,0.0,1.0);\n    return mix(b,a,h) - h*(1.0 - h)*t;\n}\n\nsdfRes smin(sdfRes x,sdfRes y,float t)\n{\n    sdfRes res;\n    res.d = smin(x.d,y.d,t);\n    res.isVol = smin(x.isVol,y.isVol,t);\n    res.col = smin(x.col,y.col,t);    \n    return res;\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\n\nsdfRes opSmoothSubtraction(sdfRes x,sdfRes y, float k)\n{\n    float d1=x.d;\n    float d2=y.d;\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    y.d = mix( d2, -d1, h ) + k*h*(1.0-h); \n    return y;\n}\n\n\n//sphData - (CenterPosition,Radius)\nsdfRes SphereSDF(vec4 sphData, const vec3 pt, float vol, vec3 col )\n{\n    return sdfRes(length(pt-sphData.xyz)-sphData.w,1.-vol,vol,col);    \n}\n\nsdfRes sdEllipsoid( vec3 p, vec3 r, float vol, vec3 col )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return sdfRes(k0*(k0-1.0)/k1,1.-vol,vol,col);\n}\n\nfloat sdParabola( in vec2 pos, in float wi, in float he )\n{\n    pos.x = abs(pos.x);\n    float ik = wi*wi/he;\n    float p = ik*(he-pos.y-0.5*ik)/3.0;\n    float q = pos.x*ik*ik*0.25;\n    float h = q*q - p*p*p;\n    float r = sqrt(abs(h));\n    float x = (h>0.0) ? \n        pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n        2.0*cos(atan(r/q)/3.0)*sqrt(p);\n    x = min(x,wi);\n    return length(pos-vec2(x,he-x*x/ik)) * \n           sign(ik*(pos.y-he)+pos.x*pos.x);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nsdfRes sdBox( vec3 p, vec3 b, float vol,vec3 col )\n{\n  return sdfRes(sdBox(p,b),0.,vol,col);\n}\n\n\nfloat sdTriPrism( vec3 p, vec2 h,float h1)\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5*h1,-p.y)-h.x*0.5);\n}\n\nsdfRes sdTriPrism( vec3 p, vec2 h, float h1,float vol,vec3 col )\n{\n  return sdfRes(sdTriPrism(p,h,h1),0.,vol,col);\n}\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\nsdfRes sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb, float vol, vec3 col)\n{\n    return sdfRes(sdCone(p, a, b, ra,rb),0.0, vol, col);\n}\n\n\nsdfRes resMin(sdfRes x,sdfRes y)\n{\n    if(x.d<y.d)\n        return x;\n    else\n        return y;\n}\n\nsdfRes resMax(sdfRes x,sdfRes y)\n{\n    if(x.d>y.d)\n        return x;\n    else\n        return y;\n}\n\nsdfRes subtract(sdfRes x,sdfRes y) \n{\n    x.d *=-1.;\n    return resMax(x,y);\n}\n\n\nvec3 MirrorPt(const vec3 pt)\n{\n    vec3 mirPt = pt;\n    mirPt.x = abs(mirPt.x);\n    return mirPt;\n}\n\n\nsdfRes GetEye(const vec3 pt,const vec3 pos, const vec3 r)\n{\n    sdfRes res = sdEllipsoid(pt-pos, r,0.,vec3(1.,0.,0.));\n    vec2 center = pt.xy-pos.xy-mo*0.05;\n    float len = length(center)*1.6;\n    res.col = vec3(smoothstep(.1,0.14,len));\n    res.col = mix(vec3(0.,0.6,.9),res.col,smoothstep(.05,0.15,len));\n    res.col = mix(vec3(0.),res.col,smoothstep(.04,0.06,len));\n    res.col = mix(vec3(1.),res.col,smoothstep(.01,0.03,length(center+vec2(-0.022,-0.01))*2.));\n    res.col *= mix(vec3(2.),vec3(1.),smoothstep(.001,0.09,length(center+vec2(0.02,0.025))*2.));    \n    res.a = 0.;\n    return res;\n}\n \n\nsdfRes GetTeeth(vec3 pt,float scale)\n{        \n    vec3 mirPt = MirrorPt(pt);\n    sdfRes teeth = sdBox(pt/scale-vec3(0.,-0.27+abs(pt.x*0.0),1.1),vec3(0.2,0.03,0.001),0.,vec3(1.));\n    teeth.d = opSmoothSubtraction(sdTriPrism((mirPt/scale-vec3(0.22,-0.27,1.1)),vec2(.1),.8,0.,vec3(1.,0.,0.)).d,teeth.d,0.12);\n  \n    teeth.d = opSmoothSubtraction(sdBox((pt/scale)-vec3(0.,-0.2,1.05),vec3(0.01,0.5,0.1),0.,vec3(1.,0.,0.)).d,teeth.d,0.03);\n    teeth.d -= 0.035;\n    teeth.d*=scale;\n    \n    return teeth;\n}\n\n\nsdfRes GetModelSurf(const vec3 pt)\n{\n    //Mirrored point for symmetry\n    vec3 mirPt = MirrorPt(pt);\n    \n    //Timed Spikes\n    float t = min(1.,mod(iTime,4.1));\n    float t2 = min(1.,mod(iTime,9.1));\n    t = smoothstep(0.,0.1,t)-smoothstep(0.18,0.4,t);\n    t2 = smoothstep(0.,0.1,t2)-smoothstep(0.18,0.4,t2);\n    t = max(t,t2)+cos(iTime)*0.03;\n    \n    //Head\n    sdfRes sdf1 = sdEllipsoid( pt, vec3(0.92,0.9,1.),1.,vec3(0.));         \n    sdf1.d = smin(sdf1.d ,SphereSDF(vec4(0.36,-0.18,0.75,0.25),pt,1.,vec3(0)).d,0.52);\n    sdf1.d = smin(sdf1.d ,SphereSDF(vec4(-0.36,-0.18,0.75,0.25),pt,1.,vec3(0)).d,0.52);\n    \n    //Body\n    sdfRes body = sdCone(pt, vec3(0.,-0.1,0.3), vec3(0.,-0.4,0.3),0.001, 0.01,0.,vec3(1.));\n    body.d-=0.2;    \n    sdf1.d = smin(body.d,sdf1.d,0.6);\n    sdf1.d = smin(sdf1.d,sdEllipsoid( pt-vec3(0.,-.9,0.4), vec3(0.38,0.6,0.35),0.,vec3(1.)).d,0.2);\n    sdf1.d = smin(sdf1.d,SphereSDF(vec4(0.0,-1.3,0.35,0.42),pt,0.,vec3(1.)).d,.25);\n    \n    //Hands\n    sdfRes hand = sdEllipsoid(mirPt-vec3(.5,-.7-mirPt.x*mirPt.x*1.3,0.33), vec3(0.4,0.2+mirPt.y*mirPt.y*0.06,0.2),1.,vec3(1.));\n    hand.d = smin(hand.d,sdEllipsoid(mirPt-vec3(0.74,-1.6,0.33), vec3(0.19,0.22,0.22),1.,vec3(0.)).d,0.3);    \n    sdf1.d = smin(hand.d,sdf1.d,0.22);       \n    \n    //hair??\n    sdf1.d = smin(sdf1.d ,SphereSDF(vec4(-0.9,0.8,-0.0,0.001),pt,1.,vec3(0)).d,0.79);\n    \n    //Eye socket    \n    sdf1 = opSmoothSubtraction(SphereSDF(vec4(0.23,0.01,1.05,0.1), mirPt,1.,vec3(0.)),sdf1,0.05);\n   \n    //Top eyelids\n    float eyeClose = mix(-0.13,-0.3,t);    \n    sdfRes eyelids = opSmoothSubtraction(       \n    sdBox(mirPt-vec3(0.23,eyeClose,0.95),vec3(0.16,0.15,0.3),0.,vec3(0.,1.,0.)),\n    sdEllipsoid(mirPt-vec3(0.23,0.0,0.99), vec3(0.18,0.18,0.1),.0,vec3(1.,0.,0.)),0.1);\n    \n    sdf1.d = smin(sdf1.d,eyelids.d,0.02); \n    \n    //Bottom eyelids\n    sdfRes eyelids2 = opSmoothSubtraction(       \n    sdEllipsoid(mirPt-vec3(0.23,0.09,.99), vec3(0.3,0.16,0.25),0.,vec3(1.,0.,0.)),\n    sdEllipsoid(mirPt-vec3(0.23,0.0,.99), vec3(0.15,0.15,0.1),0.,vec3(1.,0.,0.))\n    ,0.25); \n    \n    sdf1.d = smin(sdf1.d,eyelids2.d,0.06);    \n    \n    //Eyes\n    sdf1 = resMin(sdf1,GetEye(pt,vec3(0.23,0.02,1.01),vec3(0.145,0.15,0.038)));\n    sdf1 = resMin(sdf1,GetEye(pt,vec3(-0.23,0.02,1.01),vec3(0.145,0.15,0.038)));\n    \n    //Mouth indent\n    float scale = .7;\n    sdfRes sdf2 = sdBox(pt/scale-vec3(0.,-0.36,1.5),vec3(0.26,0.00,0.01),0.,vec3(1.));\n    sdf2.d -= 0.000;\n    sdf2.d *= scale;\n    sdf1.d = opSmoothSubtraction(sdf2.d,sdf1.d,0.12);\n    \n    //Upper lip\n    scale=0.3;\n    sdfRes ul = sdCone(pt/scale,vec3(0.,-0.8,2.4+t*0.009),vec3(0.,0.,2.4),1.35,0.5,0.,vec3(1.));\n    ul.d-=0.01;\n    ul.d*=scale;\n    sdf1.d = smin(sdf1.d,ul.d,0.1);\n    \n    //Teeth\n    sdfRes teeth = GetTeeth(pt-vec3(0.,-0.045,0.09-pt.x*pt.x*0.5),.9);\n    sdf1 = resMin(sdf1,teeth);  \n    \n    //Shading\n    if(sdf1.isVol!=0.)\n    {    \n        //Blush\n        float c =clamp (0.,1.,length(vec3(0.55,-0.2,.99)-mirPt)*4.5);\n        sdf1.col = mix(vec3(250.,180.,90.)/255.,vec3(1.),smoothstep(0.9,1.,c));    \n        sdf1.isVol = clamp(0.,1., c);\n        \n        //Eyelid color\n        c =clamp (0.,1.,length(vec3(0.22,0.02,.99)-mirPt)*4.9);\n        sdf1.col = mix(vec3(171.,183.,236.)*0.8/255.,sdf1.col,smoothstep(0.99,1.,c));    \n        sdf1.isVol = min(sdf1.isVol, c);      \n        vec2 cen = vec2(0.0,-1.05);\n        float rad = 0.04;\n        float ang = -90.;\n        vec2 curPos;\n        for(float i=0.;i<6.;i++)\n        {\n            curPos = cen+step(0.1,i)*rad*2.5*vec2(cos(radians(ang)),sin(radians(ang)));\n            c =clamp (0.,1.,length(curPos-pt.xy));\n            if(c<rad)\n            {\n               sdf1.col = vec3(1.);    \n               sdf1.isVol = 0.;       \n            }\n            ang-=60.*step(0.1,i);\n        }\n        \n        \n        //Right Eyebrow\n        float x = sdParabola(pt.xy-vec2(0.27,0.3-t*0.006),0.14,-0.04);\n        float lim = mix(0.001,0.03,smoothstep(.5,.20,pt.x));\n        if(abs(x)<lim)\n        {\n            c = smoothstep(0.5,1.,clamp(0.,1.,invMix(-lim,lim,x)));\n            sdf1.isVol = 0.2;\n            sdf1.col = vec3(171.,183.,236.)*mix(1.,0.9,c)/255.;\n        }\n        \n        //Left eyebrow\n        x = sdParabola(pt.xy-vec2(-0.22,0.35-t*0.004),0.14,0.04);\n        lim = mix(0.001,0.03,smoothstep(.5,.10,-pt.x));\n        if(abs(x)<lim)\n        {\n            c = smoothstep(0.1,1., invMix(-lim,lim,x));\n            sdf1.isVol = 0.2;\n            sdf1.col = vec3(171.,183.,236.)*mix(1.,0.9,1.-c)/255.;\n        } \n        \n        \n    }\n  \n    return sdf1; \n}\n\nvec3 GetNormal(const vec3 pt)\n{\n    float d = GetModelSurf(pt).d;\n    vec2 eps = vec2(0.001,0.0);\n    vec3 n = vec3(d-GetModelSurf(pt-eps.xyy).d,\n                       d-GetModelSurf(pt-eps.yxy).d,\n                       d-GetModelSurf(pt-eps.yyx).d);\n    return normalize(n);\n}\n\nsdfRes Raymarch(const vec3 ro, const vec3 rd)\n{\n   float d = 0.0;\n    vec3 pt;\n    float t=1.,dist=999.;\n    sdfRes sdf,final;\n    vec3 col;\n    for(int i=0;i<MAX_STEPS;i++)\n    {\n        pt = ro + d * rd;\n        sdf = GetModelSurf(pt);\n        if(sdf.d<0.)        \n        {\n            float extinction = max(-sdf.d*30.,0.0);\n            float transmittance = exp(-extinction * step_size);\n            t *= transmittance;\n            \n            if(dist==999.) // Register surface details\n            { \n                dist = d; \n                final = sdf;\n            }\n        }       \n        d += sdf.d <0. ? step_size : max(sdf.d,step_size);\n    }\n    final.d = dist;\n    final.a = 1.-t;\n    return final;\n}\n\nmat3 RotateY(float theta)\n{\n    float Cos = cos(theta);\n    float Sin = sin(theta);\n\treturn mat3(Cos,0.0,Sin,\n                0.0,1.0,0.0,\n                -Sin,0.0,Cos);\n}\n\nmat3 RotateX(float theta)\n{\n    float Cos = cos(theta);\n    float Sin = sin(theta);\n\treturn mat3(1.0,0.0,0.0,\n                0.0,Cos,-Sin,\n                0.0,Sin,Cos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    uv.x *= iResolution.x/iResolution.y; \n    \n    mo = iMouse.xy/iResolution.xy-0.5;\n    mo.x *= iResolution.x/iResolution.y;\n    \n    vec3 bg = mix(vec3(0.,0.1,.4),vec3(0.),uv.y+1.);\n    vec3  ldir =normalize(lightPos);    \n    \n    //Get data from buffer\n    vec4 transform = texelFetch(iChannel0,ivec2(0,0),0);     \n    //Calculate the origin with transform data, here the z value is used to set the distance\n    vec3 ro = RotateY(transform.x) * RotateX(-transform.y) * vec3(0.0,0.0,transform.z);\n    //usual look at calculation\n \tvec3 lp = vec3(0.0,-0.05,0.0);\n    vec3 forward = normalize(lp-ro);\n    vec3 GlobalUp = vec3(0.0,1.0,0.0);\n    vec3 right = normalize(cross(forward,GlobalUp));\n    vec3 localUp = cross(right,forward);    \n    vec3 rd = (ro+forward) + uv.x * right + uv.y * localUp - ro;           \n    \n    sdfRes res = Raymarch(ro,rd);\n    \n    vec3 normal = GetNormal(ro+res.d*rd);    \n    vec3 n01 = normal*0.5+0.5;     \n    vec3 col;\n    \n    if(res.isVol==0. && res.d != 999.) //set alpha for non-volumes\n    res.a=1.;\n    \n    col = mix(normal,baseCol,mix(0.0,1.,res.a));    \n    col = mix(res.col,col,res.isVol);\n    \n    res.a = smoothstep(0.05,0.7,res.a);\n    \n    col = col* mix(0.6,1.,dot(normal,ldir));\n    col = mix(bg,col,res.a);\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_Z  = 90;\nconst int KEY_X  = 88;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nvec3 offset = vec3(0.0);\n//Used to set the initial offset\nvec3 initOffset = vec3(0.0,.05,4.0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    offset = texelFetch(iChannel0,ivec2(0,0),0).xyz; \n    //sets the offset value to initial offset when the program starts\n    if(iTime<0.1) offset = initOffset;    \n    offset.x+= (texelFetch(iChannel1,ivec2(KEY_RIGHT,0),0).x - texelFetch(iChannel1,ivec2(KEY_LEFT,0),0).x)*0.02 ;\n    offset.y+= (texelFetch(iChannel1,ivec2(KEY_UP,0),0).x - texelFetch(iChannel1,ivec2(KEY_DOWN,0),0).x)*0.02 ;     \n    \n    //the added value is multiplied by the z value to make it faster over time\n    offset.z+= (texelFetch(iChannel1,ivec2(KEY_X,0),0).x - texelFetch(iChannel1,ivec2(KEY_Z,0),0).x)*0.02 * offset.z; \n    \n    //Change this value to determine x rotation clamping\n    float limit = radians(20.);// PI/4.0;\n    offset.y = clamp(offset.y,-limit,limit);\n    offset.x = clamp(offset.x,-limit,limit);\n    //Change this value to fix minimum and maximum distance form lookat point\n    offset.z = clamp(offset.z,3.0,6.0);\n    fragColor = vec4(offset,iMouse.x);\n} ","name":"Buffer A","description":"","type":"buffer"}]}