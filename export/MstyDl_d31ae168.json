{"ver":"0.1","info":{"id":"MstyDl","date":"1520656366","viewed":2327,"name":"Vector Field Pixel Sorting","username":"Wunkolo","description":"GLSL based vector field pixel sorting\n\nCrude attempt at implementing PixSort( https://wunkolo.itch.io/pixsort ) as a GLSL shader.","likes":18,"published":1,"flags":0,"usePreview":1,"tags":["sort"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A basic port of Adobe After Effects plugin PixSort: https://wunkolo.itch.io/pixsort\n// Created by Wunkolo/2018\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Public License\n\n// Unless you got a beefy as hell GPU\n// dont make MAXSPAN any higher than it needs to.\n// Each pixel is potentially O( MAXSPAN ^ 2 )\n// Overall this is very nasty and has no business being a glsl shader\n#define MAXSPAN 100\n#define MINSPAN 16\n\nvec4 Span[MAXSPAN];\n\n// Samples a single texel\nvec4 Texel( ivec2 Coord )\n{\n    ivec2 CurSize = ivec2( iChannelResolution[0].xy );\n    ivec2 CurCoord = Coord % CurSize;\n    return texelFetch( iChannel0, CurCoord, 0 );    \n}\n\n// Converts any color into a single ordinal float\n// This is what it sorts by\nfloat Bias( vec4 Color )\n{\n    return dot( Color.rgb, vec3( 0.3f, 0.59f, 0.11f ) );\n}\n\n// Mask for sorting\n// Areas of \"false\" are where sortings occur\n// Areas of \"true\" are where they dont\nbool Threshold( vec4 Color )\n{\n    // True when \"Bright\"\n    // False when \"Dark\"\n    return dot( Color.rgb, vec3( 0.3f, 0.59f, 0.11f ) ) > 0.5f;\n}\n\n// Vector field which gives a direction vector given a spacial coordinate\n// Determines the \"Flow\" of the pixel sorting spans\nvec2 Flow( vec2 Coord )\n{\n    Coord /= iChannelResolution[0].xy;\n    Coord -= vec2(0.5f);\n    return normalize(vec2(\n        sin( Coord.x/Coord.y + iTime),\n        Coord.y\n    ));\n}\n\n// Gets the index of the current span following flow until we hit a \"wall\" pixel\nint GetSpanIndex( ivec2 Coord )\n{\n    int CurIndex = 0;\n    vec2 CurVector = vec2(Coord);\n    for( ; CurIndex < MAXSPAN; ++CurIndex )\n    {\n        vec4 CurTexel = Texel(ivec2(CurVector));\n        // Integrate backwards until we hit an \"edge\"\n        if( Threshold(CurTexel) == true )\n        {\n            // Hit a border\n            // This pixel doesnt count\n            CurIndex--;\n            break;\n        }\n        Span[CurIndex] = CurTexel;\n        // get previous pixel\n        CurVector += -Flow(CurVector);\n    }\n    return CurIndex;\n}\n\n// Gets the upper index of the current span following flow until we hit a \"wall\" pixel\n// This tells us how large the current span is\nint GetUpperSpanIndex( ivec2 Coord, int CurIndex )\n{\n    vec2 CurVector = vec2(Coord);\n    for( ; CurIndex < MAXSPAN; ++CurIndex )\n    {\n        vec4 CurTexel = Texel(ivec2(CurVector));\n        // Integrate forward until we hit an \"edge\"\n        if( Threshold(CurTexel) == true )\n        {\n            // Hit a border\n            // This pixel doesnt count\n            CurIndex--;\n            break;\n        }\n        Span[CurIndex] = CurTexel;\n        // get next pixel\n        CurVector += Flow(CurVector);\n    }\n    return CurIndex;\n}\n\n// Fallback/debug\nvec4 Fallback( ivec2 Coord )\n{\n    vec4 Final = Texel(Coord);\n    if( Coord.x < int(iMouse.x) )\n    {\n        vec2 Direction = Flow(vec2(Coord)).xy * 0.5f + 0.5f;\n        Final = Threshold(Final) ? vec4(Direction,1.0f,1.0f): vec4(Direction,0.0f,1.0f);\n    }\n    return Final;\n}\n\n// Bubblesort\n// This is going to be disgustingly slow\n// like O(n^2)-per-sorted-pixel slow\nvoid SortSpan( int CurSize )\n{\n    for( int i = 0; i < MAXSPAN; ++i )\n    {\n        if( i >= CurSize )\n        {\n            break;\n        }\n        for( int j = 0; j < MAXSPAN; ++j )\n        {\n        \tif( j >= CurSize )\n        \t{\n\t            break;\n    \t    }\n            if( Bias(Span[j]) < Bias(Span[i]) )\n            {\n                vec4 Temp = Span[j];\n                Span[j] = Span[i];\n                Span[i] = Temp;\n            }\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ThisCoord = ivec2(gl_FragCoord.xy);\n    vec4 CurColor = Texel(ThisCoord);\n    \n    // Find out what index we're currently at\n    int CurIndex = GetSpanIndex(ThisCoord);\n    // No interval here\n    if( CurIndex == MAXSPAN )\n    {\n        // return faded pixel\n        fragColor = Fallback(ThisCoord);\n        return;\n    }\n    \n    // Get the rest of the \"upper\" pixels\n    int UpperIndex = GetUpperSpanIndex(ThisCoord, CurIndex);\n    // Interval too short\n    if( UpperIndex < MINSPAN )\n    {\n        // return faded pixel\n        fragColor = Fallback(ThisCoord);\n        return;\n    }\n    \n    // Select the \"CurIndex\"-th sorted pixel within\n    // an array of \"UpperIndex+1\" pixels\n    SortSpan(UpperIndex+1);\n    vec4 FinalColor = Span[CurIndex];\n    \n    // Output to screen\n    fragColor = vec4(\n        //vec3( float(CurIndex) / float(UpperIndex) ),\n        FinalColor.rgb,\n        1.0f\n    );\n}","name":"Image","description":"","type":"image"}]}