{"ver":"0.1","info":{"id":"XtjXRm","date":"1442511309","viewed":260,"name":"Raymarching Subtraction","username":"JamesHagerman","description":"This is mostly a copy of https://www.shadertoy.com/view/XtsXRB but with a different object being generated using some of the info on this page: http://iquilezles.org/articles/distfunctions/distfunctions.htm\n\nI've also added some useful notes...","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarchsensatron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//Raymarching Visualizer\n//By Alain Galvan - Based of a presentation by iq.\n\n// **************************************************************************\n// CONSTANTS\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define PI_OVER_TWO 1.570796\n#define ONE_OVER_PI 0.318310\n#define GR   1.61803398\n\n#define SMALL_FLOAT 0.0001\n#define BIG_FLOAT 1000000.\n\n// **************************************************************************\n// GLOBALS\n\nvec3  g_camPointAt   = vec3(0.);\nvec3  g_camOrigin    = vec3(0.);\nfloat g_time         = 0.;\nvec3  g_ldir         = vec3(.8, 1., 0.8);\n\n// **************************************************************************\n// UTILITIES\n\n// Rotate the input point around the y-axis by the angle given as a\n// cos(angle) and sin(angle) argument.  There are many times where  I want to\n// reuse the same angle on different points, so why do the heavy trig twice.\n// Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\n\nvec3 rotateAroundYAxis( vec3 point, float cosangle, float sinangle )\n{\n    return vec3(point.x * cosangle  + point.z * sinangle,\n        point.y,\n        point.x * -sinangle + point.z * cosangle);\n}\n\n// Rotate the input point around the x-axis by the angle given as a\n// cos(angle) and sin(angle) argument.  There are many times where  I want to\n// reuse the same angle on different points, so why do the  heavy trig twice.\n// Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\n\nvec3 rotateAroundXAxis( vec3 point, float cosangle, float sinangle )\n{\n    return vec3(point.x,\n        point.y * cosangle - point.z * sinangle,\n        point.y * sinangle + point.z * cosangle);\n}\n\n// convert a 3d point to two polar coordinates.\n// First coordinate is elevation angle (angle from the plane going through x+z)\n// Second coordinate is azimuth (rotation around the y axis)\n// Range of outputs - ([PI/2, -PI/2], [-PI, PI])\nvec2 cartesianToPolar( vec3 p ) \n{    \n    return vec2(PI/2. - acos(p.y / length(p)), atan(p.z, p.x));\n}\n\n// **************************************************************************\n// DISTANCE FIELDS\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  float boxval = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    \n  float sphereval = length(p)-b.x-0.5;\n    \n  return max(-sphereval,boxval); // this is a subtraction operation.\n}\n\n// **************************************************************************\n// SCENE MARCHING\n\n\nvec2 scenedf( vec3 p )\n{\n    vec2 obj =  vec2(sdBox(p, vec3(1.) ), 1.);\n    return obj;\n}\n\n#define DISTMARCH_STEPS 64\n#define DISTMARCH_MAXDIST 30.\n\n\n// ro = ray origin\n// rd = ray direction\n// maxd = max ray marching distance/depth\nvec2 distmarch( vec3 ro, vec3 rd, float maxd )\n{\n\n    float epsilon = 0.001;\n    float dist = 10. * epsilon;\n    float t = 0.;\n    float material = 0.;\n    float iterations = 0.;\n    \n    for (int i=0; i < DISTMARCH_STEPS; i++) \n    {\n        iterations = float(i);\n        if ( abs(dist) < epsilon || t > maxd || (float(i) > mod(8. * (iTime+15.), 30.))) break;\n        // advance the distance of the last lookup\n        t += dist;\n        vec2 dfresult = scenedf( ro + t * rd );\n        dist = dfresult.x;\n    }\n\n    if( t > maxd ) iterations = -1.0; \n    return vec2( t, iterations );\n}\n\n\n\n// **************************************************************************\n// CAMERA & GLOBALS\n\nstruct CameraData\n{\n    vec3 origin; // ray origin (basically where our camera is located)\n    vec3 dir;    // ray direction (basically ends up being a pixel in world space (I think?))\n    vec2 st;     // shifted fragment coordinate (I think?)\n};\n\nCameraData setupCamera( in vec2 fragCoord )\n{\n\n    // aspect ratio\n    float invar = iResolution.y / iResolution.x;\n    vec2 st = fragCoord.xy / iResolution.xy - .5; // shift the fragment coordinate to the middle of the scene\n    st.y *= invar;\n\n    // calculate the ray origin and ray direction that represents\n    // mapping the image plane towards the scene\n    vec3 iu = vec3(0., 1., 0.);\n\n    // g_camPointAt and g_camOrigin are globals and are both set inside animateGlobals() before we get to this point\n    vec3 iz = normalize( g_camPointAt - g_camOrigin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    // I'd love to have an explination as to what exactly this is doing.\n    // As far as I can tell, it's taking the camera postion and relating it to the specific fragment coordinate in the scene\n    // That would give us the ray direction for that fragment pointing into the scene.\n    // Any comments?\n    vec3 dir = normalize( st.x*ix + st.y*iy + .7 * iz ); \n\n    return CameraData(g_camOrigin, dir, st);\n\n}\n\nvoid animateGlobals()\n{\n    // remap the mouse click ([-1, 1], [-1/ar, 1/ar])\n    vec2 click = iMouse.xy / iResolution.xx;    \n    click = 2.0 * click - 1.0;  \n    \n    g_time = .8 * iTime - 10.;\n\n    // camera position\n    g_camOrigin = vec3(4.5, 0.0, 4.5);\n    \n    float rotx    = -1. * PI * (.5 * click.y + .45) + .05 * g_time;\n    float cosrotx = cos(rotx);\n    float sinrotx = sin(rotx);\n    \n    float roty    = TWO_PI * click.x + .05 * g_time;\n    float cosroty = cos(roty);\n    float sinroty = sin(roty);\n\n    // Rotate the camera around the origin\n    g_camOrigin = rotateAroundXAxis(g_camOrigin, cosrotx, sinrotx);\n    g_camOrigin = rotateAroundYAxis(g_camOrigin, cosroty, sinroty);\n\n    g_camPointAt   = vec3(0., 0., 0.);\n    \n    float lroty    = .9 * g_time;\n    float coslroty = cos(lroty);\n    float sinlroty = sin(lroty);\n\n    // Rotate the light around the origin\n    g_ldir = rotateAroundYAxis(g_ldir, coslroty, sinlroty);\n\n}\n\n// **************************************************************************\n// Visualize Functions (Mind the mess!)\n\n/*\n * Returns a component based on luminocity p, saturation q, and hue h.\n */\nfloat hueToRgb(float p, float q, float h)\n{\n    if ((h * 6.) < 1.)\n        return p + (q - p) * h * 6.;\n    else if ((h * 2.) < 1.)\n        return q;\n    else if ((h * 3.) < 2.)\n        return p + (q - p) * ((2. / 3.) - h) * 6.;\n    else\n        return p;\n}\n/*\n * Returns a vec4 with components r,g,b,a, based off vec4 col with components h,s,l,a.\n */\nvec3 hslToRgb(vec3 col)\n{\n    vec3 outColor = vec3(0.);\n    float p, q, tr, tg, tb;\n    \n    if (col.b <= .5)\n        q = col.b * (1. + col.g);\n    else\n        q = col.b + col.g - (col.b * col.g);\n\n    p = 2. * col.b - q;\n    tr = col.r + (1. / 3.);\n    tg = col.r;\n    tb = col.r - (1. / 3.);\n\n    outColor.r = hueToRgb(p, q, tr);\n    outColor.g = hueToRgb(p, q, tg);\n    outColor.b = hueToRgb(p, q, tb);\n\n    return outColor;\n}\n\n// **************************************************************************\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Animate globals\n    animateGlobals();\n\n    // Setup Camera\n    CameraData cam = setupCamera( fragCoord );\n\n    // Scene Marching\n    vec2 scenemarch = distmarch( cam.origin, cam.dir, DISTMARCH_MAXDIST );\n    \n    // Visualizer\n    vec3 scenecol = vec3(0.);\n    \n    if (scenemarch.y > SMALL_FLOAT)\n        scenecol = hslToRgb(vec3(scenemarch.y / 30., .9, .6));\n\n    fragColor.rgb = scenecol;\n    fragColor.a = 1.;\n}\n","name":"","description":"","type":"image"}]}