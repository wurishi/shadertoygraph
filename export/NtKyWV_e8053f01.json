{"ver":"0.1","info":{"id":"NtKyWV","date":"1662236080","viewed":132,"name":"Uniform points on sphere (fast)","username":"Shiv2k3","description":"a simple shader show casing angle partitioning on a sphere to create equidistant points","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sphere","points","unifrom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\n    precision highp float;\n#endif\n \n#define eps 0.0001\n#define pi 3.141592\nconst float hpi = pi / 2.0; \n\nstruct Ray\n{\n  vec3 origin;\n  vec3 position;\n  vec3 direction;\n};\nmat3 ry(in float angle)\n{\n  float s = sin(angle);\n  float c = cos(angle);\n \n  return mat3\n  (\n    c, 0.0, -s,\n    0.0, 1.0, 0.0,\n    s, 0.0, c\n  );\n}\nmat3 rx(in float angle)\n{\n  float s = sin(angle);\n  float c = cos(angle);\n \n  return mat3\n  (\n    1.0, 0.0, 0.0,\n    0.0, c, s,\n    0.0, -s, c\n  );\n}\n\nconst float partitions = 30.; \nvec2 getPartition(vec3 p)\n{\n  // Angles: phi-inclination, theta-radial\n   vec3 np = normalize(p);\n   float phi = acos(np.y)/pi;\n   float theta = atan(np.z, np.x)/hpi;\n   \n   // partition - still need to find a way to fix less points appearing at the poles, i needs to be slightly bigger around the poles than it is now\n   phi = round(phi * partitions) / partitions;\n   float inclination = (0.5 - abs(phi - 0.5)); // can be multiplied by a multiple of 2 for different patterns\n   if(inclination != 0.0) // stop divide by zero error\n   theta = round(theta * partitions * inclination) / (partitions * inclination);\n   \n   return vec2(theta, phi);\n}\nconst float r = 3.0; // radius of big sphere\nvec3 getCart(vec2 s)\n{\n   // Point\n   float sp = r*sin(s.y*pi);\n   float x = cos(s.x*hpi) * sp;\n   float y = sin(s.x*hpi) * sp;\n   float z = r*cos(s.y*pi);\n   return vec3(x,z,y);\n}\nvec4 scene(vec3 p)\n{\n   // Points\n   vec2 angles = getPartition(p);\n   vec3 point = getCart(angles);\n   \n   // Colors\n   float sphereD =length(p) - r;\n   float pointD = length(p-point) - 0.01*r;\n   bool is = sphereD < pointD;\n   float d = is ? sphereD : pointD;\n   vec3 sphereC = abs(normalize(point)/2.0);\n   vec3 color = is ? sphereC : vec3(1);\n   return vec4(color, d);\n}\nvec4 shootRay(in Ray ray)\n{\n  float raystep = 0.0;\n  vec4 d;\n  for (int i=0; i<32; i++)\n  {\n    ray.position = ray.origin + ray.direction * raystep;\n    vec2 m = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n    ray.position = ry(2.0*pi*m.x)*rx(2.0*pi*-m.y) * ray.position;\n    d = scene(ray.position);\n    raystep += d.w;\n    if(d.w <= eps)\n      break;    \n  }\n  \n  return d;\n}\n \nfloat camz = -5.0;\nRay setupRay()\n{\n  Ray ray;\n  vec2 uv = (gl_FragCoord.xy / iResolution.xy-0.5)*2.0;\n  uv.x *= iResolution.x / iResolution.y;\n \n  ray.direction =  normalize(vec3(uv,1.0));\n  ray.origin = vec3(0,0,camz);\n \n  return ray;\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    Ray ray = setupRay();\n    vec4 s = shootRay(ray);\n    fragColor.xyz = s.xyz;\n    fragColor.xyz *= 1.0 - s.w;\n}","name":"Image","description":"","type":"image"}]}