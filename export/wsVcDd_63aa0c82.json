{"ver":"0.1","info":{"id":"wsVcDd","date":"1604108192","viewed":291,"name":"Pretty Pumpkin'","username":"Dombass","description":"A raymarched pumpkin for halloween, hacked together like a frankenstein monster.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["halloween"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat boxSDF(vec3 a, vec3 b, float r) {\n    return length(max(abs(a)-b, 0.)) - r;\n}\n\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat noise(vec3 p) //Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat sphere(vec3 p, vec4 spr)\n{\n\treturn length(spr.xyz-p) - spr.w;\n}\n\nfloat flame(vec3 p, vec3 cone)\n{\n\tfloat d = sphere(p*cone, vec4(.0,-1.,.0,1.));\n\tfloat fl = abs(d + (noise(p+vec3(1.,iTime*.75,1.0)) + noise(p*3.)*.5)*.25*(p.y)) ;\n    return min(20.-d , fl );\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nconst float MAX = 200.;\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat scene(in vec3 pos) {\n\tfloat box = boxSDF(pos,vec3(3.5,0.25,3.5), .2);\n    \n    mat4 r = rotationX(3.14/2.0);\n    vec4 rotated = vec4(pos, 1.0)*r;\n    float limit = 3.14;\n    const float step = 0.04;\n    float thicc = .65;\n    float final = torus(rotated.xyz, vec2(1.2, thicc));\n    for(float i = step; i < .63; i += step)\n    {\n        vec4 new = rotated*rotationZ(3.14/i);\n    \t//final = opSmoothUnion(final, torus(new.xyz, vec2(1.2f, thicc)), 0.07);\n        final = min(final, torus(new.xyz, vec2(1.2, thicc)) );\n    }\n    \n    {\n    \tvec3 toTheLeft = pos;\n    \ttoTheLeft.x -= .8;\n    \ttoTheLeft.z -= 2.;\n    \tfloat sphere = sphereSDF(toTheLeft, .4);\n    \tfinal = opSmoothSubtraction(sphere, final, 0.01);\n    }\n    \n    {\n    \tvec3 toTheLeft = pos;\n    \ttoTheLeft.x += .85;\n    \ttoTheLeft.z -= 2.0;\n    \tfloat sphere = sphereSDF(toTheLeft, .4);\n    \tfinal = opSmoothSubtraction(sphere, final, 0.01);\n    }\n    \n     {\n    \tvec3 toTheLeft = (vec4(pos, 1.)*rotationZ(3.14)).xyz;\n    \ttoTheLeft.y += .1;\n    \ttoTheLeft.z -= 1.7;\n    \tfloat sphere = sdCappedTorus(toTheLeft, vec2(0.2, 0.1),1., .2);\n    \tfinal = opSmoothSubtraction(sphere, final, 0.01);\n    }\n\n    {\n        vec3 toTheLeft = (vec4(pos, 1.)*rotationZ(3.14)).xyz;\n        final = opSmoothUnion(final, flame(toTheLeft, vec3(1., .4, 1.)), .07);\n    }\n    {\n        vec3 toTheLeft = (vec4(pos, 1.)*rotationZ(3.14)).xyz;\n        final = opSmoothUnion(final, flame(toTheLeft, vec3(1.75, .4, 1.75)), .07);\n    }\n    \n    \n    return final;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*scene( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*scene( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*scene( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*scene( pos + e.xxx ) );\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 0.0, glow = 0.0, eps = 0.01;\n\tvec3  p = org;\n\tbool glowed = false;\n\t\n\tfor(int i=0; i<64; i++)\n\t{\n\t\td = scene(p) + eps;\n\t\tp += d * dir;\n\t\tif( d>eps )\n\t\t{\n\t\t\tif(scene(p) < 0.)\n\t\t\t\tglowed=true;\n\t\t\tif(glowed)\n       \t\t\tglow = float(i)/64.;\n\t\t}\n\t}\n\treturn vec4(p,glow);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 eye = (vec4(0, 2.1, 10., 1)).xyz;//*rotationZ(iTime)).xyz;\n    vec3 rayDir = rayDirection(90., iResolution.xy, fragCoord);\n    vec4 p = raymarch(eye, rayDir);\n\tfloat glow = p.w;\n\t\n    vec3  lig = normalize( vec3(-0.0, -5., 0.) );\n    vec3  lig2 = normalize( vec3(-0.0, 5., 4.) );\n    vec3 hal = lig - rayDir;\n    \n    vec3 normal = calcNormal(p.xyz);\n    \n    float dif = clamp( dot( normal, lig ), 0.0, 1. );\n    float dif2 = clamp( dot( normal, lig2 ), 0.0, 1. );\n    vec3 mate = vec3(0.3);\n    vec3 col = mate*dif*4.*vec3(.9,0.4,0.1);\n    vec3 col2 = mate*dif2*4.*vec3(.9,0.1,0.1);\n    \n    vec4 blah =  vec4(1.,.5,.1, 1.);//mix(vec3(0.), vec3(0.7,0.0,0.0), p.y*.04);\n    fragColor = mix(vec4(col, 1.), blah, pow(glow*2.,4.));\n    fragColor = mix(fragColor, vec4(col2, 1.), 0.5);\n}","name":"Image","description":"","type":"image"}]}