{"ver":"0.1","info":{"id":"fdffDS","date":"1645277100","viewed":437,"name":"Fast Gaussian-blurred polygon","username":"Michel_Rouzic","description":"A real breakthrough in polygon rendering, this directly calculates the Gaussian-blurred pixels of polygons (both concave and convex) in one single pass. This works by approximating the Gaussian-weighted area of the polygon around the pixel.","likes":22,"published":3,"flags":0,"usePreview":0,"tags":["triangle","blur","antialiasing","gaussianblur","polygon","loopless"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nI, Michel Rouzic, have been researching this problem for years and at last I have just (in February 2022) solved it.\nThis directly calculates, in one pass, a visually fully accurate approximation of a Gaussian-blurred polygon,\nin this case a polygon with 4 (easy to modify) sides which can be concave or convex.\nThis works by calculating the Gaussian-weighted area of the polygon around the coordinate of the pixel being rendered.\nEach side of the polygon forms a subtriangle with the pixel, and each subtriangle is split into two right triangles.\nTheir weights are calculated mainly according to the approximation of an integral, and depending on the angle at the\npixel some other operations have to be done. Then all the weights are added together and multiplied by the colour.\n\nThe Gaussian blurring gets no smaller than 0.8 pixels wide because that's what I consider the best Gaussian blurring\nfor a sharp antialiasing. I made this so that I could render perfectly antialiased polygons (even on the CPU)\nefficiently without any multisampling. I think this method is a pretty big deal due to how efficient and practically\nperfect it is.\n\nBonuses include a fast approximation of the error function (erf) which you can reuse whenever you need erf() and \na way to convert linear pixel values to sRGB without using pow() (although I'm not sure this is more efficient).\n*/\n\nfloat sq(float x)\n{\n    return x * x;\n}\n\nfloat erf_fast(float x)\n{\n\tfloat y, xa = abs(x);\n\n\t// erf(x) ~= 1 - exp(<polynomial>) for x >= 0, max error 1/4249\n\t// 2 mad, 1 mul, 1 +-, 1 copysign, 1 exp = ~9 FR\n\ty = ((-0.06388*xa - 0.66186)*xa - 1.123613)*xa;\n\ty = 1. - exp(y);\n\ty *= sign(x);\n\n\treturn y;\n}\n\nfloat erf_right_triangle_acute_integral(float x, float y)\n{\n\tfloat x2 = x*x, y2 = y*y;\n\tfloat v = (((((-1.6663128e-05*y2 + 5.104393e-06)*x2 +\n\t\t\t0.0005496131*y2 - 5.30433e-05)*x2 +\n\t\t\t(0.0001584783*y2 - 0.00741157237)*y2 - 0.0018265954)*x2 +\n\t\t\t(-0.003881739*y2 + 0.0523013844)*y2 + 0.04582956)*x2 +\n\t\t\t((-0.00368418*y2 + 0.03692744)*y2 - 0.1996548)*y2 - 0.50360028)*x2 +\n\t\t\t((-0.0012717*y2 - 0.0101518)*y2 + 0.0109084)*y2 - 1.836892;\n\treturn exp(v) * x2 * y;\t// 25 FR\n}\n\nfloat calc_right_triangle_pixel_weight(vec2 rp)\n{\n\tvec2 rpa;\n\tbool use_obtuse;\n\tfloat slope, acute, obtuse;\n\n\trpa = abs(rp);\n\n\t// Pick method\n\tuse_obtuse = rpa.y > rpa.x;\n\tif (use_obtuse)\t\t\t// if we use the obtuse method\n\t{\n\t\t// Swap axes\n\t\tfloat t = rp.x;\n\t\trp.x = rp.y;\n\t\trp.y = t;\n\t}\n\n\t// Prepare the arguments (slope and clamped x)\n\tslope = abs(rp.x) < 1e-5 ? 0. : rp.y / rp.x;\n\tslope = clamp(slope, -1., 1.);\n\trp.x = clamp(rp.x, -3., 3.);\n\n\tacute = erf_right_triangle_acute_integral(rp.x, slope);\n\tobtuse = 0.25 * erf_fast(rp.y) * erf_fast(rp.x) - acute;\n\tacute = abs(acute) * sign(slope);\n\tobtuse = abs(obtuse) * sign(slope);\n\n\treturn use_obtuse ? obtuse : acute;\n}\n\nfloat calc_subtriangle_pixel_weight(vec2 p0, vec2 p1)\n{\n\tvec2 rot, r0, r1, np;\n\tfloat weight;\n\n\t// Rotate points\n\trot = normalize(p1 - p0);\n\tr0.x = rot.x*p0.y - rot.y*p0.x;\n\tr0.y = rot.x*p0.x + rot.y*p0.y;\n\tr1.x = r0.x;\n\tr1.y = rot.x*p1.x + rot.y*p1.y;\n\n\t// Calc weights\n\tweight = calc_right_triangle_pixel_weight(r1);\n\tweight -= calc_right_triangle_pixel_weight(r0);\n\n\treturn weight;\n}\n\nvec3 draw_tetragon(vec2 p[4], vec3 col, float rad, vec3 pv, vec2 pf)\n{\n\tfloat weight;\n    \n\t// Transform polygon coordinates\n\tp[0] = (p[0] - pf) * rad;\n\tp[1] = (p[1] - pf) * rad;\n\tp[2] = (p[2] - pf) * rad;\n\tp[3] = (p[3] - pf) * rad;\n\n\t// Calculate weight for each subtriangle\n\tweight = calc_subtriangle_pixel_weight(p[0], p[1]);\n\tweight += calc_subtriangle_pixel_weight(p[1], p[2]);\n\tweight += calc_subtriangle_pixel_weight(p[2], p[3]);\n\tweight += calc_subtriangle_pixel_weight(p[3], p[0]);\n\n\t// Apply weight to colour\n\tpv += weight * col;\n\n\treturn pv;\n}\n\nfloat lsrgb(float l)\t// converts a [0.0, 1.0] linear value into a [0.0, 1.0] sRGB value\n{\n\tfloat x, line, curve;\n\n\t// 13 FR every time + 2 FR once\n\tline = l * 12.92;\t// 1 FR\n\tx = sqrt(l);\t// 4 FR\n\tcurve = ((((0.455*x - 1.48)*x + 1.92137)*x - 1.373254)*x + 1.51733216)*x - 0.0404733783;\t// 5 FR + 2 FR once, error 0.145 sRGB units\n\n\treturn l <= 0.0031308 ? line : curve;\t// 3 FR\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 rp, p[4] = vec2[] ( vec2(0., 3.), vec2(1.8, -2.), vec2(0., 0.), vec2(-1.8, -2.) );\n    \n    // Pixel to world coordinates\n    float scrscale = 18. / iResolution.y;\n    vec2 uv = (fragCoord-iResolution.xy*0.5) * scrscale;\n    \n    // Tetragon rotation\n    float th = iTime * 6.2831853 / 40.;\n    float costh = cos(th);\n    float sinth = sin(-th);\n    \n    for (int i=0; i < 4; i++)\n    {\n        rp.x = p[i].x * costh - p[i].y * sinth;\n        rp.y = p[i].x * sinth + p[i].y * costh;\n        p[i] = rp;\n    }\n    \n    // Varying blurriness\n    float rad = sq(1.-abs(cos(iTime * 6.2831853 / 16.))) * 6.;\n    float min_rad = 0.8*scrscale;\n    rad = length(vec2(rad, min_rad));\n\n    // Time varying pixel color\n    vec3 pv = vec3(0.);\n    pv = draw_tetragon(p, vec3(1.), 1./rad, pv, uv);\n\n    // Output to screen\n    fragColor = vec4(lsrgb(pv.r), lsrgb(pv.g), lsrgb(pv.b), 1.);\n}","name":"Image","description":"","type":"image"}]}