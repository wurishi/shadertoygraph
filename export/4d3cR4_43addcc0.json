{"ver":"0.1","info":{"id":"4d3cR4","date":"1517975275","viewed":147,"name":"Chocolate-Loving Shark 3","username":"BobMowzie","description":"For CIS 566: Procedural Computer Graphics\nResources used:\nhttp://iquilezles.org/www/index.htm\nhttp://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nTechniques used:\nRaymarching\nCustom math functions\nLots of trial and error","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","homework"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n/**\n * Signed distance function for a cube centered at the origin\n * with dimensions specified by size.\n */\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius r.\n */\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.yz)-t.x,p.x);\n  return length(q)-t.y;\n}\n\n/**\n * Signed distance function for an XY aligned cylinder centered at the origin with\n * height h and radius r.\n */\nfloat cylinderSDF(vec3 p, float h, float r) {\n    // How far inside or outside the cylinder the point is, radially\n    float inOutRadius = length(p.xy) - r;\n    \n    // How far inside or outside the cylinder is, axially aligned with the cylinder\n    float inOutHeight = abs(p.z) - h/2.0;\n    \n    // Assuming p is inside the cylinder, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    // Assuming p is outside the cylinder, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat floorSDF(vec3 samplePoint) {    \n    return boxSDF(samplePoint - vec3(0., -1.1, 0.), vec3(100., 1., 100.));\n}\n\nfloat crateSDF(vec3 samplePoint) {\n    float crate = udRoundBox(samplePoint, vec3(1., 0.01, 1.5), 0.05);\n    for (int i = 0; i < 3; i++) {\n    \tcrate = smin(crate, sphereSDF(samplePoint * vec3(1., 0.7, 1.) + vec3(0.5, 0., -1. + 1. * float(i)), 0.45) / length(vec3(1., 0.7, 1.)), 0.2);\n    \tcrate = smin(crate, sphereSDF(samplePoint * vec3(1., 0.7, 1.) + vec3(-0.5, 0., -1. + 1. * float(i)), 0.45) / length(vec3(1., 0.7, 1.)), 0.2);\n    }\n    float sub = udRoundBox(samplePoint - vec3(0., 1.11, 0.), vec3(1.2, 1., 1.7), 0.05);\n    for (int i = 0; i < 3; i++) {\n    \tsub = smin(sub, sphereSDF(samplePoint * vec3(1., 0.7, 1.) + vec3(0.5, 0., -1. + 1. * float(i)), 0.4) / length(vec3(1., 0.7, 1.)), 0.3);\n    \tsub = smin(sub, sphereSDF(samplePoint * vec3(1., 0.7, 1.) + vec3(-0.5, 0., -1. + 1. * float(i)), 0.4) / length(vec3(1., 0.7, 1.)), 0.3);\n    }\n    crate = differenceSDF(crate, sub);\n    crate = smin(crate, sphereSDF(samplePoint * vec3(1., 0.6, 1.) - vec3(0., -0.2, -0.5), 0.2) / 0.7, 0.3);\n    crate = smin(crate, sphereSDF(samplePoint * vec3(1., 0.6, 1.) - vec3(0., -0.2, 0.5), 0.2) / 0.7, 0.3);\n    return crate;\n}\n\nfloat eggSDF(vec3 samplePoint) {\n\tfloat eggs = MAX_DIST;\n    for (int i = 0; i < 3; i++) {\n        float myTime = 0.5 * (mod(float(iTime), 2.) + 0.15 * float(i));\n        float t = 1./(1. + pow(2., -40. * myTime + 8.)) - 1./(1. + pow(2., -40. * (myTime - 0.8)));\n        float myTime2 = 0.25 * (mod(float(iTime), 2.) + 0.15 * float(i)-0.1);\n        float t2 = 1./(1. + pow(2., -40. * myTime2 + 8.)) - 1./(1. + pow(2., -40. * (myTime2 - 1.2)));\n        float egg = sphereSDF(samplePoint * vec3(1., 0.7, 1.) - vec3(0.5 - t2, -0.05 + t*0.3, 1. - 1. * float(i)), 0.4) / length(vec3(1., 0.7, 1.));\n        for (int j = 0; j < 7; j++) {\n        \tegg = differenceSDF(egg, sdTorus((samplePoint * vec3(1., 0.7, 1.) - vec3(0.5 - t2, -0.05 + t*0.3, 1. - 1. * float(i))) * rotateY(radians(-360. * 1. * t2)) - vec3(0.11 * (float(j) - 3.), 0., 0.), vec2(0.4 - abs(0.02 * (float(j) - 3.) * (float(j) - 3.)), 0.025)));\n        }\n        eggs = unionSDF(eggs, egg);\n    }\n    return eggs;\n}\n\nfloat sharkSDF(vec3 samplePoint) {\n\tfloat shark = MAX_DIST;\n    float angle = radians(90. - 180. * mod(iTime * 0.5, 1.));\n    float r = 3. * 1./pow(pow(sin(angle), 4.) + pow(cos(angle), 4.), -1./4.);\n    float x = r * 0.7 * sin(angle + radians(45.));\n    float z = r * cos(angle + radians(45.));\n    float dx = r * 0.8 * cos(angle + radians(45.));\n    float dz = r * -sin(angle + radians(45.));\n    float myTime = mod(0.5 * (float(iTime)), 1.);\n    float t = 1./(1. + pow(2., -60. * (myTime - 0.))) + 1./(1. + pow(2., -60. * (myTime - 0.5))) + 1./(1. + pow(2., -60. * (myTime - 1.)));\n    float yaw = radians(-90. + 90. * t);\n    float wiggle = 0.1 * sin(iTime*18. + 1.5);\n    shark = udTriangle(((samplePoint - vec3(x, 0., z)) * rotateY(yaw) - vec3(wiggle, 0., 0.)) * rotateY(0.15 * sin(iTime*18.)), vec3(0., -0.8, 0.5), vec3(0., -0.8, -0.5), vec3(0., 0.3, -0.5));\n    return shark;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end, int whichSurface) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = 0.;\n        if (whichSurface == 0) dist = floorSDF(eye + depth * marchingDirection);\n        else if (whichSurface == 1) dist = crateSDF(eye + depth * marchingDirection);\n        else if (whichSurface == 2) dist = eggSDF(eye + depth * marchingDirection);\n        else if (whichSurface == 3) dist = sharkSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p, int whichSurface) {\n    if (whichSurface == 0)\n    return normalize(vec3(\n        floorSDF(vec3(p.x + EPSILON, p.y, p.z)) - floorSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        floorSDF(vec3(p.x, p.y + EPSILON, p.z)) - floorSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        floorSDF(vec3(p.x, p.y, p.z  + EPSILON)) - floorSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n    else if (whichSurface == 1)\n    return normalize(vec3(\n        crateSDF(vec3(p.x + EPSILON, p.y, p.z)) - crateSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        crateSDF(vec3(p.x, p.y + EPSILON, p.z)) - crateSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        crateSDF(vec3(p.x, p.y, p.z  + EPSILON)) - crateSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n    else if (whichSurface == 2)\n    return normalize(vec3(\n        eggSDF(vec3(p.x + EPSILON, p.y, p.z)) - eggSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        eggSDF(vec3(p.x, p.y + EPSILON, p.z)) - eggSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        eggSDF(vec3(p.x, p.y, p.z  + EPSILON)) - eggSDF(vec3(p.x, p.y, p.z - EPSILON))\n    )); \n    else if (whichSurface == 3)\n    return normalize(vec3(\n        sharkSDF(vec3(p.x + EPSILON, p.y, p.z)) - sharkSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sharkSDF(vec3(p.x, p.y + EPSILON, p.z)) - sharkSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sharkSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sharkSDF(vec3(p.x, p.y, p.z - EPSILON))\n    )); \n}\n\nfloat shadow(vec3 ro, vec3 rd, float mint, float maxt, float k, int whichSurface)\n{\n    float res = 1.0;\n    for( float t=mint; t < maxt; )\n    {\n        float h = 0.;\n        if (whichSurface == 0) h = floorSDF(ro + rd*t);\n        else if (whichSurface == 1) h = crateSDF(ro + rd*t);\n        else if (whichSurface == 2) h = eggSDF(ro + rd*t);\n        else if (whichSurface == 3) h = sharkSDF(ro + rd*t);\n        if( h<0.001 )\n            return 0.02;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity, int whichSurface) {\n    vec3 N = estimateNormal(p, whichSurface);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, int whichSurface) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(0.0,\n                          6.0,\n                          0.0);\n    vec3 light1Intensity = vec3(0.5, 0.5, 0.5);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity, whichSurface)\n         \t\t\t\t\t\t* shadow(p, normalize(light1Pos - p), 0.1, 10., 8., 1)\n        \t\t\t\t\t\t* shadow(p, normalize(light1Pos - p), 0.1, 10., 8., 2)\n        \t\t\t\t\t\t* shadow(p, normalize(light1Pos - p), 0.1, 10., 8., 3);  \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float myTime = 1.-(mod(0.25 * (float(iTime)), 0.5) + 0.25);\n    float t = 1./(1. + pow(2., -60. * (myTime - 0.25))) + 1./(1. + pow(2., -60. * (myTime - 0.75)));\n    vec3 eye = vec3(7.0, 5.0, 7.0) * rotateY(radians(180. + 180. * t));\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float distFloor = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST, 0);\n    float distCrate = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST, 1);\n    float distEggs = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST, 2);\n    float distShark = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST, 3);\n    \n    if (distFloor > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 color;\n    float closestDist = min(min(min(distFloor, distEggs), distCrate), distShark);\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    if (closestDist == distFloor) {\n    \tvec3 p = eye + closestDist * worldDir;\n    \n    \tvec3 K_a = vec3(244./255., 226./255., 66./255.);\n    \tvec3 K_d = vec3(244./255., 226./255., 66./255.);\n    \tvec3 K_s = vec3(255./255., 255./255., 200./255.);\n    \tfloat shininess = 3.0;\n    \n    \tcolor = phongIllumination(K_a, K_d, K_s, shininess, p, eye, 0);\n    }\n    else if (closestDist == distCrate) {\n        vec3 p = eye + closestDist * worldDir;\n    \n    \tvec3 K_a = vec3(225./255., 225./255., 225./255.);\n    \tvec3 K_d = vec3(249./255., 247./255., 255./255.);\n    \tvec3 K_s = vec3(0./255., 0./255., 0./255.);\n    \tfloat shininess = 1.0;\n    \n    \tcolor = phongIllumination(K_a, K_d, K_s, shininess, p, eye, 1);\n    }\n    else if (closestDist == distEggs) {\n        vec3 p = eye + closestDist * worldDir;\n    \n    \tvec3 K_a = vec3(162./255., 53./255., 17./255.);\n    \tvec3 K_d = vec3(181./255., 82./255., 33./255.);\n    \tvec3 K_s = vec3(206./255., 107./255., 57./255.);\n    \tfloat shininess = 1.;\n    \n    \tcolor = phongIllumination(K_a, K_d, K_s, shininess, p, eye, 2);\n    }\n    else if (closestDist == distShark) {\n        vec3 p = eye + closestDist * worldDir;\n    \n    \tvec3 K_a = vec3(225./255., 178./255., 156./255.);\n    \tvec3 K_d = vec3(225./255., 245./255., 245./255.);\n    \tvec3 K_s = vec3(0./255., 0./255., 0./255.);\n    \tfloat shininess = 1.;\n    \n    \tcolor = phongIllumination(K_a, K_d, K_s, shininess, p, eye, 2);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}