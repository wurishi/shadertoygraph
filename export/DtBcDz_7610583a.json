{"ver":"0.1","info":{"id":"DtBcDz","date":"1691638526","viewed":56,"name":"Metaball MetaBox 2","username":"rarora7777","description":"Trying some metaball generalization","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","metaballs"],"hasliked":0,"parentid":"DtlcWS","parentname":"Metaballs Metaboxes"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2.\n\nstruct MetaBall{\n\tfloat r;\n    vec2 pos;\n    vec3 col;\n};\n\nstruct MetaBox {\n    float ax;\n    float ay;\n    vec2 pos;\n    vec3 col;\n};\n\nconst float sqrt2inv = 1./sqrt(2.);\nconst vec3 fillColor1 = vec3(.467, .867, .467);\nconst vec3 fillColor2 = vec3(.467, .467, .867);\nconst vec3 strokeColor = vec3(1.);\nconst vec3 backColor = vec3(0.2);\nconst float potential = 1.;\n    \nfloat falloff(float d, float p)\n{\n    // using the falloff from [Extended Field Functions for Soft Objects. Blanc and Schlick. 1995]\n    float d2 = d * d;\n    return d2 < 1. ? d2 < .25 ? 1. - (9.*d2*d2 / (p + (4.5-4.*p)*d2)) : (1. - d2)*(1. - d2) / (.75 - p + (1.5 + 4.*p)*d2) : 0.;\n}\n\nvec4 BallSDF(MetaBall ball, vec2 uv){\n    float dst = .5 * length(uv - ball.pos)/ball.r;\n    return vec4(ball.col, falloff(dst, potential*.25));\n}\n\nvec4 BoxSDF(MetaBox box, vec2 uv){\n    float delx = (uv.x - box.pos.x) / box.ax;\n    float dely = (uv.y - box.pos.y) / box.ay;\n    float rx = sqrt2inv*(delx + dely);\n    float ry = sqrt2inv*(delx - dely);\n    float dst = .5 * (2.*abs(rx) + 2.*abs(ry));\n    return vec4(box.col, falloff(dst, potential));\n}\n\n\nvec3 renderMetaBall(vec2 uv){\n\tMetaBall mbr;\n    MetaBox mbb;\n    \n    // ***Click and drag with your mouse to move the small ball***\n    vec2 mousePos = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    if (mousePos.x < -.99 && mousePos.y < -.99)\n        mousePos = vec2(0.);\n    mbr.pos = mousePos; mbr.r = 0.15; mbr.col = fillColor2;\n    mbb.pos = vec2(-.5, 0.); mbb.ax = 1.0; mbb.ay = .75; mbb.col = fillColor1;\n\t\n    vec4 ball = BallSDF(mbr, uv);\n    vec4 box = BoxSDF(mbb, uv);\n    \n    float sum = ball.a + box.a;\n    //float total = sum;\n    float sqrSum = ball.a*ball.a + box.a*box.a;\n    float n = 1.;\n    float total = (sum  + sqrt(sqrSum)) * pow(sqrSum, .5*n);\n    float boxThreshold = .15;\n    float alpha = clamp((box.a-boxThreshold)/(.5-boxThreshold), 0., 1.);\n    \n    alpha = smoothstep(0., 1., alpha);\n    \n    vec3 fillColorMix = mix(fillColor2, fillColor1, alpha);\n    vec3 fillColor = box.a >= .5 ? fillColor1 : box.a <= boxThreshold ? fillColor2 : fillColorMix;\n    vec3 color = total >= .5 ? fillColor : total >= .4 ? strokeColor : backColor;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n#ifdef AA \n    // Antialiasing via supersampling\n    float uvs = 1. / max(iResolution.x, iResolution.y);\n   \n    for(float i = -AA; i < AA; ++i){\n        for(float j = -AA; j < AA; ++j){\n        \tcol += renderMetaBall(uv + vec2(i, j) * (uvs / AA)) / (4.* AA * AA);\n        }\n    }\n#else       \n    col = renderMetaBall(uv);\n#endif /* AA */\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}