{"ver":"0.1","info":{"id":"XlXBzX","date":"1512603130","viewed":100,"name":"Solar_System","username":"kalkas","description":"Homework, 2nd","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["homework","nothingspecial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 currentCoords;\n\nstruct circle3d\n{\n    vec3 m_Center;\n    float m_Radius;\n    vec4 m_Color;\n};\n\ncircle3d theSun;\ncircle3d theSunOverlay;\ncircle3d mercury;\ncircle3d venus;\ncircle3d earth;\ncircle3d moon;\ncircle3d mars;\ncircle3d jupiter;\ncircle3d saturn;\ncircle3d uranus;\ncircle3d neptune;\n\nbool IsInside( circle3d _circle )\n{\n    float _magnitude = length( currentCoords.xy - _circle.m_Center.xy );\n    return _magnitude <= _circle.m_Radius;\n}\n\nvec3 RotateX( vec3 _vec, float _angle )\n{\n    return mat3( 1.0, 0.0, 0.0, 0.0, cos( _angle ), -sin( _angle ), 0.0, cos( _angle ), sin( _angle ) ) * _vec;\n}\n\nvec3 RotateY( vec3 _vec, float _angle )\n{\n    return mat3( cos( _angle ), 0.0, sin( _angle ), 0.0, 1.0, 0.0, -sin( _angle ), 0.0, cos( _angle ) ) * _vec;\n}\n\nvec3 RotateZ( vec3 _vec, float _angle )\n{\n    return mat3( cos( _angle ), -sin( _angle ), 0.0, sin( _angle ), cos( _angle ), 0.0, 0.0, 0.0, 1.0 ) * _vec;\n}\n\nvoid PositionPlanets()\n{\n    mercury.m_Center = RotateY( mercury.m_Center, iTime * 3.0 );\n    mercury.m_Center = RotateX( mercury.m_Center, 1.4 );\n\n    venus.m_Center = RotateY( venus.m_Center, iTime * 1.8 );\n    venus.m_Center = RotateX( venus.m_Center, 1.4 );\n\n    earth.m_Center = RotateY( earth.m_Center, iTime );\n    earth.m_Center = RotateX( earth.m_Center, 1.4 );\n\n    moon.m_Center = RotateY( moon.m_Center, iTime * 6.0 );\n    moon.m_Center = RotateZ( moon.m_Center, -0.5 );\n    moon.m_Center += earth.m_Center;\n\n    jupiter.m_Center = RotateY( jupiter.m_Center, iTime * 0.2 );\n    jupiter.m_Center = RotateX( jupiter.m_Center, 1.4 );\n\n    saturn.m_Center = RotateY( saturn.m_Center, iTime * 0.1 );\n    saturn.m_Center = RotateX( saturn.m_Center, 1.4 );\n}\n\nvec4 CalculateColor( vec2 _originalCoords )\n{\n    float _z = 100000.0;\n    vec4 _color = vec4( 0.0, 0.0, 0.0, 1.0 );\n    float _sunAlpha = 0.0;\n    float _sunOverlayAlpha = 0.0;\n\n    if( IsInside( mercury ) )\n    {\n        _color = mercury.m_Color;\n        _z = mercury.m_Center.z;\n    }\n    if( IsInside( venus ) && venus.m_Center.z < _z )\n    {\n        _color = venus.m_Color;\n        _z = venus.m_Center.z;\n    }\n    if( IsInside( earth ) && earth.m_Center.z < _z )\n    {\n        _color = earth.m_Color;\n        _z = earth.m_Center.z;\n    }\n    if( IsInside( moon ) && moon.m_Center.z < _z )\n    {\n        _color = moon.m_Color;\n        _z = moon.m_Center.z;\n    }\n    if( IsInside( jupiter ) && jupiter.m_Center.z < _z )\n    {\n        _color = jupiter.m_Color;\n        _z = jupiter.m_Center.z;\n    }\n    if( IsInside( saturn ) && saturn.m_Center.z < _z )\n    {\n        _color = saturn.m_Color;\n        _z = saturn.m_Center.z;\n    }\n    if( IsInside( theSunOverlay ) && theSun.m_Center.z < _z )\n    {\n        _sunAlpha = 1.0 - smoothstep( 0.7, 1.0, length( currentCoords ) / theSun.m_Radius );\n        _sunOverlayAlpha = 1.0 - smoothstep( 0.0, 1.0, length( currentCoords ) / theSunOverlay.m_Radius );\n        \n        _color =\n            ( theSunOverlay.m_Color * _sunOverlayAlpha + _color * ( 1.0 - _sunOverlayAlpha ) ) /\n            ( _sunOverlayAlpha + ( 1.0 - _sunOverlayAlpha ) );\n        \n        _color =\n            ( theSun.m_Color * _sunAlpha + _color * ( 1.0 - _sunAlpha ) ) /\n            ( _sunAlpha + ( 1.0 - _sunAlpha ) );\n        \n        _z = theSun.m_Center.z;\n    }\n\n    return _color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    currentCoords = fragCoord * 2.0 - iResolution.xy;\n    vec2 nResolution = iResolution.xy * 2.0;\n    float earthRadius = 0.1 * nResolution.y / 2.0;\n\n    theSun = circle3d( vec3( 0.0, 0.0, 0.0 ), 0.3 * nResolution.y / 2.0, vec4( 1.0, 0.4, 0.1, 1.0 ) );\n    theSunOverlay = circle3d( vec3( 0.0, 0.0, 0.0 ), 0.5 * nResolution.y / 2.0, vec4( 1.0, 0.7, 0.1, 1.0 ) );\n    mercury = circle3d( vec3( theSun.m_Radius * 1.5, 0.0, 0.0 ), earthRadius * 0.3, vec4( 1.0, 1.0, 1.0, 1.0 ) );\n    venus = circle3d( vec3( theSun.m_Radius * 2.0, 0.0, 0.0 ), earthRadius * 0.8, vec4( 1.0, 0.5, 0.0, 1.0 ) );\n    earth = circle3d( vec3( theSun.m_Radius * 2.8, 0.0, 0.0 ), earthRadius, vec4( 0.1, 0.4, 1.0, 1.0 ) );\n    moon = circle3d( vec3( earthRadius * 1.4, 0.0, 0.0 ), earthRadius * 0.25, vec4( 0.3, 0.3, 0.3, 1.0 ) );\n    jupiter = circle3d( vec3( theSun.m_Radius * 4.1, 0.0, 0.0 ), earthRadius * 2.0, vec4( 0.0, 0.9, 0.3, 1.0 ) );\n    saturn = circle3d( vec3( theSun.m_Radius * 5.3, 0.0, 0.0 ), earthRadius * 1.2, vec4( 1.0, 0.0, 0.8, 1.0 ) );\n\n    PositionPlanets();\n\n    fragColor = CalculateColor( fragCoord );\n\n}","name":"Image","description":"","type":"image"}]}