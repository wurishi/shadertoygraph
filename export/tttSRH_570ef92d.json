{"ver":"0.1","info":{"id":"tttSRH","date":"1580425863","viewed":168,"name":"Fitting Arc using Bézier 2","username":"harry7557558","description":"Cubic version see there: [url]https://www.shadertoy.com/view/wly3WG[/url]\nThese fitting functions are used to convert ellipse arcs in an SVG path into uniform bezier curve, because I don't want to write hundreds of lines of code specifically for ellipses.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["bezier","circle","arc","fitting","leastsquare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tFitting an unit arc using a quadratic bezier curve\n\tCubic version: https://www.shadertoy.com/view/wly3WG\n\n\tAs one can see, cubic fitting is much better than quadratic fitting.\n\n    Since rendering quadratic is much faster than cubic, fitting the arc/ellipse\n    using multiple quadratic bezier curves is still better. It's not easy to notice \n    the C0 continuety.\n\n*/\n\n#define PI 3.1415926\n#define _13 0.333333333\n#define cbrt(x) ((x)>0.?pow(x,_13):-pow(-(x),_13))\n\nstruct Bezier2{\n    vec2 A, B, C;\n};\n\n\n// ========================= Fitting Code =========================\n\n\n#if 0\n\n// along the tangent\nvoid fitArc(in float theta, out Bezier2 R) {\n    float c = cos(theta), s = sin(theta);\n    float k = theta==0.0 ? 0.0 : (1.0 - c) / s;\n    R.A = vec2(1.0, 0.0), R.B = vec2(1.0, k), R.C = vec2(c, s);\n}\n\n#else\n\n// least square, let the control point be k*(cos(θ/2),sin(θ/2))\nvoid fitArc(in float theta, out Bezier2 R) {\n    // derivative of error: error'=ax³+bx²+cx+d\n    // thanks https://www.integral-calculator.com/ for helping me integrate that disgusting function!\n    float alpha = 0.5 * theta;\n\tfloat s1 = sin(alpha), s2 = s1 * s1, s4 = s2 * s2, s6 = s4 * s2,\n\t\tc1 = cos(alpha), c2 = c1 * c1, c3 = c2 * c1, c4 = c3 * c1, c5 = c4 * c1, c6 = c4 * c2, c7 = c5 * c2;\n    float a = 32.*s4+64.*c2*s2+32.*c4,\n        b = (60.*c1*s4+(120.*c3+60.*c1)*s2+60.*c5+60.*c3) / a,\n        c = (20.*s6+(100.*c2-16.)*s4+(140.*c4+32.*c2-148.)*s2+60.*c6+48.*c4-108.*c2) / a,\n        d = (35.*c1*s6+(105.*c3-5.*c1)*s4+(105.*c5+10.*c3-131.*c1)*s2+35.*c7+15.*c5-111.*c3-91.*c1) / a;\n    // calculate the minima (zero derivative), solve a the cubic function\n\tfloat p = (c - b * b * _13) * _13, q = -0.5 * ((b*b / 13.5 - c * _13) * b + d);\n\ta = q * q + p * p * p;\n\tfloat k = a > 0.0 ? cbrt(q + sqrt(a)) + cbrt(q - sqrt(a)) - b * _13\n\t\t: 2.0 * pow(q*q - a, 0.5 * _13) * cos(atan(sqrt(-a), q) * _13) - b * _13;\n    // apply the solution of the equation to the control points\n    R.A = vec2(1.0, 0.0), R.B = k * vec2(c1, s1), R.C = vec2(c1*c1-s1*s1, 2.0*c1*s1);\n}\n\n#endif\n\n\n\n// ========================= Rendering Code =========================\n\n\n// quadratic bezier distance approximation by tayholliday: https://www.shadertoy.com/view/XsX3zf\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\nvec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n  float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1);\n  float f=b*d-a*a;\n  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n  vec2 gf=2.0*(b*d21+d*d10+a*d20);\n  gf=vec2(gf.y,-gf.x);\n  vec2 pp=-f*gf/dot(gf,gf);\n  vec2 d0p=b0-pp;\n  float ap=det(d0p,d20), bp=2.0*det(d10,d0p);\n  float t=clamp((ap+bp)/(2.0*a+b+d), 0.0 ,1.0);\n  return mix(mix(b0,b1,t),mix(b1,b2,t),t);\n}\nfloat sdBezier2(in Bezier2 R, in vec2 p) {\n  return length(get_distance_vector(R.A-p, R.B-p, R.C-p));\n}\n\nvoid mainImage(out vec4 col, in vec2 P) {\n    vec2 res = iResolution.xy;\n    vec2 p = 6.0*(P-0.5*res)/length(res);\n    float h = 0.2*length(res); \t// hardness of anti-aliasing\n\n    float ang = atan(p.y,p.x);\n    if (ang<0.0) ang += 2.0*PI;\n    float a = sin(0.6*iTime); a=1.8*PI*a*a;\n    int n = int(abs(a)/1.5) + 1;\n    float da = a / float(n);\n    if (iMouse.z>0.0){\n        vec2 d = iMouse.xy-0.5*iResolution.xy;\n        a = atan(d.y,d.x);\n    \tif (a<0.0) a += 2.0*PI;\n        n=1, da=a;\n    }\n\n    // axis\n    vec2 axis = clamp(h*(abs(p)-0.02),0.0,1.0);\n    float bk = min(axis.x,axis.y);\n    vec3 bkg = mix(vec3(0,0,1),vec3(1),bk);\n\n    // circle\n    float circ = clamp(h*(abs(length(p)-1.0)-0.02),0.0,1.0);\n    vec3 c = (ang<a)?vec3(1,0,0):vec3(0.7);\n    c = mix(c,bkg,circ);\n\n    // bezier curve\n    Bezier2 R;\n    fitArc(da, R);\n    if (ang<a){\n        float t = mod(ang,da);\n        vec2 q = length(p)*vec2(cos(t),sin(t));\n    \tfloat d = sdBezier2(R,q);\n    \tc = mix(vec3(0),c,clamp(h*(d-0.01),0.0,1.0));\n    }\n\n    // control points\n    float d = length(p-R.B)-0.04;\n    c = mix(vec3(1),c,clamp(h*d,0.0,1.0));\n    c = mix(vec3(0),c,clamp(h*(abs(d)-0.002),0.0,1.0));\n    d = min(length(p-R.A),length(p-R.C))-0.05;\n    c = mix(vec3(1),c,clamp(h*d,0.0,1.0));\n    c = mix(vec3(0),c,clamp(h*(abs(d)-0.005),0.0,1.0));\n\n    col = vec4(c, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}