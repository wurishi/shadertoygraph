{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"struct Ray\n{\n\tvec3 org;\n\tvec3 dir;\n};\n\n// reference: https://iquilezles.org/articles/distfunctions\nfloat sdPlane( vec3 p, vec4 n )\n{\n\t// n must be normalized\n\treturn dot( p, n.xyz ) + n.w;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat opU( float d1, float d2 )\n{\n\treturn min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nvec3 translate( vec3 v, vec3 t )\n{\n\treturn v - t;\n}\n\nfloat scene( vec3 pos )\n{\n\tvec4 plane = vec4( 0.0, 1.0, 0.0, 0.0 ); // xyz, d\n\tvec4 sphere = vec4(  0.0, 0.5, 0.0, 1.5 ); // xyz, r\n\tvec4 rboxDim = vec4( 2.0, 2.0, 0.5, 0.25 );\n\tvec4 rboxPos = vec4( 0.0, 0.5, 0.0, 1.0 );\n\t\n\t\n\tfloat dPlane = sdPlane( pos, plane );\n\t\n\t//d = opU( d, sdSphere( translate( pos, sphere1.xyz ), sphere1.w ) );\n\t//d = opU( d, sdSphere( translate( pos, sphere2.xyz ), sphere2.w ) );\n\t//float dSphere = sdSphere( translate( pos, sphere.xyz ), sphere.w );\n\t//float dRbox = udRoundBox( translate( pos, rboxPos.xyz ), rboxDim.xyz, rboxDim.w );\n\t\n\t//return opU( dPlane, opS( dSphere, dRbox ) );\n    \n    float dPrism = sdTriPrism(pos, vec2(1.0, 2.));\n    return opU(dPrism,  dPlane);\n}\n\n// calculate scene normal using forward differencing\nvec3 sceneNormal( vec3 pos, float d )\n{\n    float eps = 0.0001;\n    vec3 n;\n\t\n    n.x = scene( vec3( pos.x + eps, pos.y, pos.z ) ) - d;\n    n.y = scene( vec3( pos.x, pos.y + eps, pos.z ) ) - d;\n    n.z = scene( vec3( pos.x, pos.y, pos.z + eps ) ) - d;\n\t\n    return normalize(n);\n}\n\nbool raymarch( Ray ray, out vec3 hitPos, out vec3 hitNrm )\n{\n\tconst int maxSteps = 128;\n\tconst float hitThreshold = 0.0001;\n\n\tbool hit = false;\n\thitPos = ray.org;\n\n\tvec3 pos = ray.org;\n\n\tfor ( int i = 0; i < maxSteps; i++ )\n\t{\n\t\tfloat d = scene( pos );\n\n\t\tif ( d < hitThreshold )\n\t\t{\n\t\t\thit = true;\n\t\t\thitPos = pos;\n\t\t\thitNrm = sceneNormal( pos, d );\n\t\t\tbreak;\n\t\t}\n\t\tpos += d * ray.dir;\n\t}\n\treturn hit;\n}\n\n// reference https://iquilezles.org/articles/rmshadows\nfloat shadow( vec3 ro, vec3 rd, float mint, float maxt )\n{\n\tfloat t = mint;\n    for ( int i = 0; i < 128; ++i )\n    {\n        float h = scene( ro + rd * t );\n        if ( h < 0.001 )\n            return 0.0;\n        t += h;\n\t\t\n\t\tif ( t > maxt )\n\t\t\tbreak;\n    }\n    return 1.0;\n}\n\nfloat shadowSoft( vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n\tfloat t = mint;\n\tfloat res = 1.0;\n    for ( int i = 0; i < 128; ++i )\n    {\n        float h = scene( ro + rd * t );\n        if ( h < 0.001 )\n            return 0.0;\n\t\t\n\t\tres = min( res, k * h / t );\n        t += h;\n\t\t\n\t\tif ( t > maxt )\n\t\t\tbreak;\n    }\n    return res;\n}\n\nvec3 shade( vec3 pos, vec3 nrm, vec4 light )\n{\n\tvec3 toLight = light.xyz - pos;\n\t\n\tfloat toLightLen = length( toLight );\n\ttoLight = normalize( toLight );\n\t\n\tfloat comb = 0.1;\n\t//float vis = shadow( pos, toLight, 0.01, toLightLen );\n\tfloat vis = shadowSoft( pos, toLight, 0.0625, toLightLen, 8.0 );\n\t\n\tif ( vis > 0.0 )\n\t{\n\t\tfloat diff = 2.0 * max( 0.0, dot( nrm, toLight ) );\n\t\tfloat attn = 1.0 - pow( min( 1.0, toLightLen / light.w ), 2.0 );\n\t\tcomb += diff * attn * vis;\n\t}\n\t\n\treturn vec3( comb, comb, comb );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// fragCoord: location (0.5, 0.5) is returned \n\t// for the lower-left-most pixel in a window\n\t\n\t// XY of the normalized device coordinate\n\t// ranged from [-1, 1]\n\tvec2 ndcXY = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\t\n\t// aspect ratio\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\t\n\t// scaled XY which fits the aspect ratio\n\tvec2 scaledXY = ndcXY * vec2( aspectRatio, 1.0 );\n\t\n\t// camera XYZ in world space\n\tvec3 camWsXYZ = vec3( 0.0, 2.0, 0.0 );\n\tcamWsXYZ.z += 5.0;\n\t\n\t// construct the ray in world space\n\tRay ray;\n\tray.org = camWsXYZ;\n\tray.dir = vec3( scaledXY, -1.0 ); // OpenGL is right handed\n\t\n\t// define the point light in world space (XYZ, range)\n\tvec4 light1 = vec4( 0.0, 5.0, 0.0, 10.0 );\n\tlight1.x = cos( iTime * 0.5 ) * 3.0;\n\tlight1.z = sin( iTime * 0.5 ) * 3.0;\n\t\n\tvec4 light2 = vec4( 0.0, 5.0, 0.0, 10.0 );\n\tlight2.x = -cos( iTime * 0.5 ) * 3.0;\n\tlight2.z = -sin( iTime * 0.5 ) * 3.0;\n\t\n\tvec3 sceneWsPos;\n\tvec3 sceneWsNrm;\n\t\n\tif ( raymarch( ray, sceneWsPos, sceneWsNrm ) )\n\t{\n\t\t// our ray hit the scene, so shade it with 2 point lights\n\t\tvec3 shade1 = shade( sceneWsPos, sceneWsNrm, light1 );\n\t\tvec3 shade2 = shade( sceneWsPos, sceneWsNrm, light2 );\n\t\t\n\t\tvec3 shadeAll = \n\t\t\t  shade1 * vec3( 1.0, 0.5, 0.5 )\n\t\t\t+ shade2 * vec3( 0.5, 0.5, 1.0 );\n\t\t\n\t\tfragColor = vec4( shadeAll, 1.0 );\n\t}\n\telse\n\t{\n\t\tfragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t}\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsfGz8","date":"1362238889","viewed":1825,"name":"Ray marching soft-shadows","username":"ming","description":"Ray marching a simple scene and shade it two point lights with real time penumbra shadows support","likes":38,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","example","tutorial","shadow"],"hasliked":0,"parentid":"","parentname":""}}