{"ver":"0.1","info":{"id":"Xd3cWN","date":"1518820561","viewed":304,"name":"LQ Heightmap based shadows","username":"zproxy","description":"https://www.shadertoy.com/view/ls3cWH","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["textureless"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 getTexture(vec2 uv){\n    if (float(gl_FragCoord.x)<iResolution.x/2.)\n    {\n        // why do we need manual repeat?\n        \n                if (uv.y < -1.0)\n           // return vec3(0);\n        return texture(iChannel2, vec2(uv.x, uv.y+ 2.0) ).rgb;\n\n        \n        if (uv.y < -0.0)\n           // return vec3(0);\n        return texture(iChannel2, vec2(uv.x, uv.y+ 1.0) ).rgb;\n        \n        // clamp only? wont repeat?\n\treturn texture(iChannel2, uv).rgb;\n    }\n    \n        return texture(iChannel0, uv).rgb;\n}\n\nfloat getHeightmap(vec2 uv){\n    const float inv3 = 1.0 / 3.0;\n    \n\treturn dot(getTexture(uv), vec3(inv3));\n}\n\nvec3 getNormal(vec2 uv){\n    const float epsilon    = 0.004;\n    const float invEpsilon = 1.0 / epsilon;\n    \n\tfloat centerHeight = getHeightmap(uv);\n    float horizontal   = getHeightmap(uv + vec2(epsilon, 0.0));\n    float vertical     = getHeightmap(uv + vec2(0.0, epsilon));\n    \n    float dh = (centerHeight - horizontal) * invEpsilon;\n    float dv = (centerHeight - vertical)   * invEpsilon;\n    \n    return normalize(vec3(dh, dv, 1.0));\n}\n\nfloat getShadow(vec2 uv, vec3 lp){\n    const int steps = 64;\n    const float invSteps = 1.0 / float(steps);\n    \n\tvec3 inc = lp * invSteps;\n    float heightmap = getHeightmap(uv);\n    vec3 position = vec3(uv, heightmap);\n    \n    float shadow = 1.0;\n    \n    for (int i = 0; i < steps && position.z < 1.0; i++){\n        position += inc;\n        float offsetHightmap = getHeightmap(position.xy);\n        \n        if (offsetHightmap > position.z)\n        {\n            return 0.0;\n        }\n\n    }\n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv /= uv.y - 1.0;\n    \n    vec2 uvlp = iMouse.xy/iResolution.xy * 2.0 - 1.0;\n    uvlp /= uvlp.y - 1.0;\n    \n    vec3 lightPos = normalize(vec3(uvlp, 1.0));\n    vec3 normal = getNormal(uv);\n    vec3 albedo = vec3(1.0);\n    \n    float diffuse = clamp(dot(lightPos, normal), 0.0, 1.0);\n    float shadows = getShadow(uv, lightPos);\n    \n    vec3 skylight = vec3(0.3, 0.5, 0.8);\n    vec3 sunlight = vec3(0.8, 0.6, 0.5) * 4.0;\n\n    vec3 color = vec3(albedo * (diffuse * shadows * sunlight + skylight));\n\n    fragColor = vec4(color / (color + 1.0),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":" \nvec3 rgb(float r, float g, float b) {\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\n/**\n * Draw a circle at vec2 `pos` with radius `rad` and\n * color `color`.\n */\nvec4 circle0(vec2 uv, vec2 pos, float rad, vec3 color) {\n\tfloat d = length(pos - uv) - rad;\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(color * \n                \n                //max(\n                //    (1.-length(pos - uv)/rad)\n                //sin(3.14 * (1.-length(pos - uv)/rad))\n                //cos(3.14 * (length(pos - uv)/rad))\n                //cos(3.14 * 1.)\n                cos( 3.14 * (length(pos - uv)/(rad * 2.0)))\n                \n                *\n\n                (1.0 - t)\n                //1.\n                //)\n                \n                , 1.0 - t);\n}\n\nvec4 circle2x(vec2 uv, vec2 pos, float rad, float a) {\n    vec4 c = vec4(0);\n    \n    // tile warp\n    c += circle0(uv, vec2(pos.x - iResolution.x, pos.y), rad, rgb(a, a, a));\n    c += circle0(uv, vec2(pos.x , pos.y), rad, rgb(a, a, a));\n    c += circle0(uv, vec2(pos.x + iResolution.x, pos.y), rad, rgb(a, a, a));\n\n  \n    return c;\n}\n\nvec4 circle(vec2 uv, vec2 pos, float rad, float a) {\n    vec4 c = vec4(0);\n    \n    // tile warp\n    c += circle2x(uv, vec2(pos.x, pos.y  - iResolution.y), rad, a);\n    c += circle2x(uv, vec2(pos.x, pos.y  ), rad, a);\n    c += circle2x(uv, vec2(pos.x, pos.y  + iResolution.y), rad, a);\n \n    \n    return c;\n}\n\n#define cc(cx, cy, cs, ca) c = max(c, circle(uv, vec2(xy.x * cx, xy.y * cy), cs * xy.y, ca ))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n\t\n    \n    \n    vec4 c = vec4(0.2);\n    \n//\tc += circle(uv, iResolution.xy * 0.5, 0.10 * iResolution.y, rgb(255.0, 255.0, 255.0));\n\n    vec2 xy = iResolution.xy;\n    \n    c += circle(uv, vec2(xy.x * 0.01, xy.y * 0.01), 0.30 * xy.y, 205. );\n\n    c = max(c, circle(uv, vec2(xy.x * 0.13, xy.y * 0.21), 0.20 * xy.y, 225. ));\n    c = max(c, circle(uv, vec2(xy.x * 0.53, xy.y * 0.61), 0.40 * xy.y, 125. ));\n    c = max(c, circle(uv, vec2(xy.x * 0.83, xy.y * 0.11), 0.40 * xy.y, 125. ));\n\n    cc(0.3, 0.3, 0.2, 205.);\n    cc(0.3, 0.9, 0.1, 205.);\n    cc(0.8, 0.1, 0.1, 205.);\n    cc(0.1, 0.6, 0.2, 205.);\n    cc(0.3, 0.6, 0.2, 205.);\n    cc(0.8, 0.8, 0.2, 205.);\n    cc(0.4, 0.0, 0.2, 205.);\n    cc(0.6, 0.0, 0.2, 205.);\n    cc(0.9, 0.5, 0.2, 205.);\n    cc(0.9, 0.5, 0.2, 205.);\n     \n\tfragColor = c;\n\n}","name":"Buf A","description":"","type":"buffer"}]}