{"ver":"0.1","info":{"id":"4XsGWf","date":"1707996100","viewed":555,"name":"Hyperjump Gates","username":"_pwd_","description":"Preparing to jump into hyperspace...","likes":25,"published":1,"flags":96,"usePreview":0,"tags":["raymarching","noise","glitch","bloom","stargate","gate","dashed","gates","hyperjump"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4ddGWB","filepath":"https://soundcloud.com/daniel-deluxe/air-cybervoid","previewfilepath":"https://soundcloud.com/daniel-deluxe/air-cybervoid","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n//\n//\n// Hyperjump gates\n//\n// I wanted to create this little sketch for quite a while now:\n// More or less dashed rings forming sort of a (hyper?)-gate.\n// Fits in very well to the great sound from `Daniel Deluxe`\n// https://soundcloud.com/daniel-deluxe/air-cybervoid\n// \n//\n// This shader shall exist in its/this form on shadertoy.com only \n// You shall not use this shader in any commercial or non-commercial product, website or project. \n// This shader is not for sale nor can´t be minted (ecofriendly or not) as NFT\n//\n//\n//\n//\n//\n//\n//\n// Related examples\n//\n// IQ´s article for sure\n// https://iquilezles.org/articles/distfunctions/\n//\n// Postpro: Moving displacements \n// https://www.shadertoy.com/view/WlXyzN\n//\n//\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // time varying pixel colour\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n   \n    \n    // displacement\n    vec4 disp = texture(iChannel0, uv + vec2(iTime * 0.1, iTime * 0.2));\n    \n    float resx = iResolution.x;\n    float resy = iResolution.y;\n    \n    vec2 center = (vec2(sin(iTime) * resx * 0.75 * 0.5, cos(iTime) * resy * 0.6 * 0.5) + \n                   vec2(sin(2.0*iTime) * resx * 0.25 * 0.5, cos(2.0*iTime) * resy * 0.4 * 0.5) +\n                   vec2(resx * 0.5, resy * 0.5));\n    float dist = length(fragCoord - center);\n    float mag = exp(-dist * (0.01 + 0.005 * sin(iTime)));\n    \n    disp = (disp * mag) * 0.65;\n    \n    \n    // tv-lines\n    vec4 col2 = texture(iChannel1, uv + disp.rg * 0.2);\n    col2.rgb *= 1.+.1*sin(6.283185*fragCoord.y*.5*.618+iTime);\n    col2.rgb *= mix( 1., 1.2, smoothstep(.0,.3,cos(iTime/7.)) );\n    col2.rgb = max(vec3(0),col2.rgb-.02);\n    \n    // vary pixel-colour\n    col2.rgb = mix(col2.rgb, col, 0.25);\n    \n    // noise\n    vec2 rnd1  = vec2(12.9898,78.233);\n    float rnd2 = 43758.5453;\n    float c = fract(sin(dot(uv.xy ,rnd1)) * rnd2+(iTime*0.5));\n    col2.rgb = (col2.rgb*0.85)+(col2.rgb*0.201*vec3(c));      \n    fragColor = col2; \n    \n    // vignette\n    fragColor.rgb *= clamp(pow(64. * uv.x*uv.y*(1.-uv.x)*(1.-uv.y), .12), 0., 1.);      \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Bloom\n#define BLOOM_SIZE (1.15)\n#define BLOOM_THRESHOLD (0.01)\n#define BLOOM_RANGE (0.5)\n#define BLOOM_FRAME_BLEND (0.2)\n\n#define PI 3.1415927\n#define lofi(x,d) (floor((x)/(d))*(d))\n#define time iTime\n#define BEAT (time*170.0/90.0)","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_RECURSION 8 // max ray bounces\n#define REFRACTION_IDX 1.5 // index of refraction\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n// materials idx\n#define MAT_WOOD 0.\n#define MAT_BACKGROUND 1.\n#define MAT_GLASS 2.\n#define MAT_METAL 3.\n#define MAT_ENVREFL 4.\n#define MAT_GOLD 5.\n#define WHITE 6.\n#define BLUE 7.\n\n#define HALFPI 1.570796325\n\nvec2 uvs = vec2(0.);\nfloat prtcl = 0.005;\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// utility functions\n//////////////////////////////////////////////////////////////////////////////////////\n\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(float n) {\n    return fract(sin(n * 12.9898) * 43758.5453);\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// sdf blend & displace functions\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat displace(vec3 p) {\n    return ((cos(14. *p.z)*sin(14. * cos(iTime) * 0.5 *p.y)*sin(14.*p.z))*cos(130.1))*sin(iTime);\n}\n\nfloat opIntersection( float d1, float d2 ) { \n    return max(d1,d2); \n}\n\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\n// union of two objects\nvec2 opU(vec2 a, vec2 b) {\n    return a.x<b.x ? a : b;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// basic sdf shapes\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// Beware -> this is a sphere now :)\nfloat sdSphere1( vec3 p, float s ) {\n    return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// main sdf\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec2 map(vec3 p) {\n\n    vec2 d = vec2(10000.);\n\n    p.xz *= rot(-0.9);\n    p.zy *= rot(0.9);\n    \n    vec3 q = p - vec3( 0.2,-0.2,-0.2);\n    R(q.xy, PI+iTime*.3);\n\n\n    //q.yz *= rot(-0.7 /*iTime*/) ; --> you might add this to rotate rings around themselves\n    d = opU(d, vec2( sdTorus( q.xzy, vec2(0.4, 0.007) ), WHITE));\n    \n    \n    \n    // add dashed tori\n    q = p - vec3( 0.12,-0.2,-0.12);\n    R(q.xy, PI-iTime*.3);\n\n    float dashedTori1 = opIntersection( sdTorus( q.xzy, vec2(0.6, 0.007 * cos(iTime * 0.5) + 0.009) ), sdBox(q, vec3(0.4, 0.8, 0.2)));\n    R(q.xy, 2.15);\n    float dashedTori2 = opIntersection( sdTorus( q.xzy, vec2(0.6, 0.007 * sin(iTime * 0.25) + 0.015) ), sdBox(q, vec3(0.1, 0.9, 0.2)));\n    R(q.xy, 1.9);\n    float dashedTori3 = opIntersection( sdTorus( q.xzy, vec2(0.6, 0.007 * cos(iTime * 0.75) + 0.009) ), sdBox(q, vec3(0.5, 0.4, 0.2)));\n    R(q.xy, -1.3);\n    float dashedTori4 = opIntersection( sdTorus( q.xzy, vec2(0.6, 0.007 * sin(iTime * 0.5) + 0.01) ), sdBox(q, vec3(0.9, 0.2, 0.2)));\n    \n    d = opU(d, vec2(opUnion(dashedTori4,opUnion(dashedTori3,opUnion(dashedTori2,dashedTori1))), WHITE));\n    \n\n\n    // add dashed tori\n    q = p - vec3( 0.25,-0.15,0.25);\n    R(q.xy, PI-iTime * 0.8);\n\n    float dashedTori5 = opIntersection( sdTorus( q.xzy, vec2(0.3, 0.007 * sin(iTime* 0.5) + 0.009 ) ), sdBox(q, vec3(0.4, 0.8, 0.2) * 0.5));\n    R(q.xy, 2.15);\n    float dashedTori6 = opIntersection( sdTorus( q.xzy, vec2(0.3, 0.007) ), sdBox(q, vec3(0.1, 0.9, 0.2) * 0.5));\n    R(q.xy, 1.9);\n    float dashedTori7 = opIntersection( sdTorus( q.xzy, vec2(0.3, 0.007) ), sdBox(q, vec3(0.5, 0.4, 0.2) * 0.5));\n    R(q.xy, -1.3);\n    float dashedTori8 = opIntersection( sdTorus( q.xzy, vec2(0.3, 0.007) ), sdBox(q, vec3(0.9, 0.2, 0.2) * 0.5));\n    \n    d = opU(d, vec2(opUnion(dashedTori8,opUnion(dashedTori7,opUnion(dashedTori6,dashedTori5))), WHITE));\n\n\n    // add dashed tori\n    q = p;\n    q.z -= 1.15;\n    R(q.xy, PI-iTime*.3);\n\n    float dashedTori9 = opIntersection( sdTorus( q.xzy, vec2(0.9, 0.007 * cos(iTime * 0.5) + 0.009) ), sdBox(q, vec3(0.4, 0.8, 0.2) ));\n    R(q.xy, 2.15);\n    float dashedTori10 = opIntersection( sdTorus( q.xzy, vec2(0.9, 0.007 * sin(iTime * 0.25) + 0.015) ), sdBox(q, vec3(0.1, 0.9, 0.2)));\n    R(q.xy, 1.9);\n    float dashedTori11 = opIntersection( sdTorus( q.xzy, vec2(0.9, 0.007 * cos(iTime * 0.75) + 0.009) ), sdBox(q, vec3(0.5, 0.4, 0.2)));\n    R(q.xy, -1.3);\n    float dashedTori12 = opIntersection( sdTorus( q.xzy, vec2(0.9, 0.007 * sin(iTime * 0.5) + 0.01) ), sdBox(q, vec3(0.9, 0.2, 0.2)));\n    \n    d = opU(d, vec2(opUnion(dashedTori12,opUnion(dashedTori11,opUnion(dashedTori10,dashedTori9))), WHITE));\n    \n\n    // add dashed tori\n    q = p;\n    q.z -= 1.25;\n    R(q.xy, PI-iTime*.13);\n\n    float dashedTori13 = opIntersection( sdTorus( q.xzy, vec2(0.99, 0.0002 * cos(iTime * 0.5) + 0.009) ), sdBox(q, vec3(0.2, 1.8, 0.2) * 0.8 ));\n    R(q.xy, 2.15);\n    float dashedTori14 = opIntersection( sdTorus( q.xzy, vec2(0.99, 0.0002 * sin(iTime * 0.25) + 0.015) ), sdBox(q, vec3(0.05, 1.9, 0.2)* 0.8));\n    R(q.xy, 1.9);\n    float dashedTori15 = opIntersection( sdTorus( q.xzy, vec2(0.99, 0.0002 * cos(iTime * 0.75) + 0.009) ), sdBox(q, vec3(0.2, 1.4, 0.2)* 0.8));\n    R(q.xy, -1.3);\n    float dashedTori16 = opIntersection( sdTorus( q.xzy, vec2(0.99, 0.0002 * sin(iTime * 0.5) + 0.01) ), sdBox(q, vec3(0.6, 1.2, 0.2)* 0.89));\n    \n    float union4 = opUnion(dashedTori16,opUnion(dashedTori15,opUnion(dashedTori14,dashedTori13)));\n    d = opU(d, vec2(union4, WHITE));\n    \n\n    \n\n\n\n    vec3 cp = p - vec3(0.2,-0.25,0.0);\n    R(cp.yz, -HALFPI - 0.1);\n    d = opU(d, vec2(sdCylinder(cp, 2.5, 0.004), WHITE));\n\n    \n    \n    \n    q = p;\n    float d2, d3;\n    d2 = 10000.0;\n    vec3 tempPos = q + vec3(0.0, -0.1, -0.15);\n    R(tempPos.yz, -1.5);\n    R(tempPos.xz, -2.5);\n    for(int i = 0; i < 40; i++) {\n        vec3 pos1;\n        float ltime = iTime*0.09 + float(i)*20.134;\n\n        float r = rand(float(i)*1.33);\n        float y = -1.08+mod(ltime*(r + 1.5), 1.7);\n\n        pos1 = vec3(0.5*mod(float(i), 3.0) - 0.2, y, 0.410*floor(float(i)/12.0) - 0.48 + rand(float(i)) * 0.5);\n        d3 = sdSphere1(tempPos - pos1, prtcl );\n        if (d3 < d2) {\n            d2 = d3;\n\n        }         \n    }    \n \n    d2 += sin(30.*p.x)*sin(30.*p.y)*sin(30.*p.z) * 0.01;  \n    d = opU(d, vec2(d2, WHITE));\n\n\n\n\n\n\n\n\n\n    vec3 q1 = p;\n    float d4, d5;\n    d4 = 10000.0;\n    vec3 tempPos1 = q1 + vec3(0.0, -0.1, -0.15);\n    R(tempPos1.yz, -1.5);\n    R(tempPos1.xz, -2.5);\n    for(int ii = 0; ii < 40; ii++) {\n        vec3 pos2;\n        float ltime1 = iTime*0.1 + float(ii)*10.134;\n\n        float r1 = rand(float(ii)*2.33);\n        float y1 = -1.08+mod(ltime1*(r1 + 1.5), 2.5);\n\n        pos2 = vec3(1.5*mod(float(ii), 3.0) - 1.8, y1, 0.410*floor(float(ii)/12.0) - 0.48 + rand(float(ii)) * 0.5);\n        d5 = sdSphere1(tempPos1 - pos2, prtcl + 0.02 );\n        if (d5 < d4) {\n            d4 = d5;\n\n        }         \n    }\n    \n    d = opU(d, vec2(d4, BLUE));\n\n    \n    \n    return d;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// raymarching loop\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec2 intersect(vec3 ro, vec3 rd) {\n    float t = 0.;\n    float s = sign(map(ro).x); // inside and outside the surface\n    \n    for (int i=0; i<256 && t<16.; i++) {\n        vec3 p = ro + rd*t;\n        vec2 h = map(p);\n        h.x *= s;\n        if (abs(h.x)<.0001*t) return vec2(t,h.y);\n        t += h.x;\n    }\n    return vec2(t,-1);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// calculate normals https://iquilezles.org/articles/normalsSDF\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 calcNormal(vec3 p) {\n    float h = map(p).x;\n    const vec2 e = vec2(.0001,0); // epsilon\n    \n    return normalize(h - vec3(map(p-e.xyy).x,\n                              map(p-e.yxy).x,\n                              map(p-e.yyx).x));\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// raymarching softshadows (https://iquilezles.org/articles/rmshadows)\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat shadow(vec3 ro, vec3 rd, float tmax, float k) {\n    float res = 1.;\n    for (float t=.01; t<tmax;) {\n        vec3 p = ro + rd*t;\n        float h = map(p).x*2.;\n        if (h<.001) return 0.;\n        res = min(res, k*h/t);\n        t += h;\n    }\n    return res*res*(3.-2.*res);\n}\n\n\nvec3 repeatTime(vec3 s)\n{\n    return fract(iTime*s)*3.14159265359*2.0;\n}\n\nvec3 noise(vec3 pos, vec3 k, vec3 p, vec3 s)\n{\n    vec3 t = repeatTime(s);\n    float X1 = cos(dot(pos.yz,k.yz) + p.x - t.x);\n    float Y1 = cos(dot(pos.zx,k.zx) + p.y - t.y);\n    float Z1 = cos(dot(pos.xy,k.xy) + p.z - t.z);\n\n    float X2 = cos(dot(vec2(Y1, Z1),k.yz) + p.x + t.x);\n    float Y2 = cos(dot(vec2(Z1, X1),k.zx) + p.y + t.y);\n    float Z2 = cos(dot(vec2(X1, Y1),k.xy) + p.z + t.z);\n \treturn vec3(X2, Y2, Z2); \n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// set: sky-texture\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat fbm( vec2 p )\n{\n    return 0.5000*texture( iChannel0, p*1.00 ).x + \n           0.2500*texture( iChannel0, p*2.02 ).x + \n           0.1250*texture( iChannel0, p*4.02 ).x + \n           0.0675*texture( iChannel0, p*8.02 ).x;\n}\n\nvec4 hash(vec4 h) {\n    return fract(sin(h) * 43758.5);\n}\n\n// IQ\nfloat noise(vec3 p) {\n\tvec3 ip = floor(p);\n    p -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n    p *= p * (3.-2.*p); \n    h = mix(hash(h), hash(h + s.x), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\n\n\nvec3 skyTex(vec3 rd) {\n    vec3 sky = noise(rd * 2. + rd.yxz * 1.4 + iTime * .2) * .19 * vec3(0, .2, 1);\n    \n    vec3 clouds1 = noise(rd, vec3(4.0, 6.0, 3.5),  vec3(0.0, 1.0, 2.0), vec3(0.1, 0.0, 0.0));\n    vec3 clouds2 = noise(rd + clouds1*0.2, vec3(2.0, 3.0, 2.5),  vec3(0.0, 1.0, 2.0), vec3(-0.1, 0.05, 0.0))*0.5+0.5;\n    float c = (clouds2.x+clouds2.y+clouds2.z)*0.08;\n    \n    float d = length(uvs-vec2(0.58,0.5));\n    vec3 moon = vec3(0.0,0.47,1.9);\n    sky = sky + mix(sky + mix( sky, clouds2 *0.08, 0.5) , moon*exp(-3.*d), 0.6);\n    \n    return sky + c * 0.09;\n}\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// rendering function\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = skyTex(rd);\n    \n    vec2 tmat = intersect(ro, rd);\n    float t = tmat.x;\n    float mat = tmat.y;\n    vec3 l;\n    if (t<16.) {\n        vec3 p = ro + rd*t;\n        l -= p;\n        vec3 n = calcNormal(p);\n        vec3 r = reflect(rd, n); // reflected ray\n        \n        // plain-white\n         if (mat==WHITE){\n            col = vec3(1.0);\n        // dark-blue \n        } else if (mat==BLUE){\n            col = vec3(0.03, 0.06, 0.18);           \n        }\n    }\n    \n    return col;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// glitched uvs\n//////////////////////////////////////////////////////////////////////////////////////\n\nfloat fractsin(float v){\n  return fract(sin(v*121.445)*34.59);\n}\n\n// -> https://www.shadertoy.com/view/wsVcDW\nvec2 glitch(vec2 v){\n    \n  vec2 vt=v;\n  for(int i=0;i<6;i++)\n  {\n    float fac=4.0*pow(2.2,-float(i));\n    float s=fractsin(lofi(vt.x,1.6*fac));\n    s+=fractsin(lofi(vt.y,0.4*fac));\n    s+=fractsin(iTime);\n    float proc=fractsin(s);\n    vt+=0.2*step(proc,0.4*exp(-3.0*mod(BEAT,8.0))-0.01)*(vec2(\n      fractsin(s+22.56),\n      fractsin(s+17.56)\n    )-0.5);\n  }\n  return vt;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// camera matrix\n//////////////////////////////////////////////////////////////////////////////////////\n\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - .5*iResolution.xy) / iResolution.y;\n    p = glitch(p);    \n    vec2 m = (iMouse.xy - .5*iResolution.xy) / iResolution.y;\n    vec2 uv = 1.0 * vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; \n    uvs = uv;\n    \n    if( iResolution.x > 1200.0 ) prtcl = 0.003;\n  \n    vec3 ro = vec3(0,-0.2,-3.5); // ray origin\n    //R(ro.xz, iMouse.x*.008*PI+iTime*.3);\n    ro.xz *= rot(-2.1 *iTime * 0.1 + 3.141592*m.x-2.1);//rot(0.2/*iTime*/ * 0.5+3.141592*m.x-1.8);\n    //ro.xy *= rot(.75);// ray origin rotation\n    vec3 ta = vec3(0,-.2,0); // target\n    mat3 ca = setCamera(ro, ta); // camera matrix\n    \n    vec3 rd = ca * normalize(vec3(p,1.6)); // ray direction\n\n    vec3 col = render(ro, rd);\n\n    fragColor = vec4(col ,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n//////////////////////////////////////////////////////////////////////////////////////\n// pyramid bloom (https://www.shadertoy.com/view/lsBfRc)\n//////////////////////////////////////////////////////////////////////////////////////\n\nvec3 makeBloom(float lod, vec2 offset, vec2 bCoord, vec2 aPixelSize)\n{\n    offset += aPixelSize;\n\n    float lodFactor = exp2(lod);\n\n    vec3 bloom = vec3(0.0);\n    vec2 scale = lodFactor * aPixelSize;\n\n    vec2 coord = (bCoord.xy-offset)*lodFactor;\n    float totalWeight = 0.0;\n\n    if (any(greaterThanEqual(abs(coord - 0.5), scale + 0.5)))\n        return vec3(0.0);\n\n    for (int i = -3; i < 3; i++) \n    {\n        for (int j = -3; j < 3; j++) \n        {\n            float wg = pow(1.0-length(vec2(i,j)) * 0.125, 6.0); //* 0.125, 6.0\n            vec3 lTextureColor = textureLod(iChannel1, vec2(i,j) * scale + lodFactor * aPixelSize + coord, lod).rgb;\n            lTextureColor = (any(greaterThan(lTextureColor, vec3(BLOOM_THRESHOLD)))) ? lTextureColor * BLOOM_SIZE : vec3(0.0);\n            lTextureColor = pow(lTextureColor, vec3(2.2)) * wg;\n            bloom = lTextureColor + bloom;\n\n            totalWeight += wg;\n            \n        }\n    }\n\n    bloom /= totalWeight;\n\n    return bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    vec4 lInputColor0 = texture(iChannel0, uv);\n\n    vec3 lBlur  = makeBloom(2., vec2(0.0, 0.0), uv, pixelSize);\n         lBlur += makeBloom(3., vec2(0.3, 0.0), uv, pixelSize);\n         lBlur += makeBloom(4., vec2(0.0, 0.3), uv, pixelSize);\n         lBlur += makeBloom(5., vec2(0.1, 0.3), uv, pixelSize);\n         lBlur += makeBloom(6., vec2(0.2, 0.3), uv, pixelSize);\n\n        vec4 lOutputColor = vec4(clamp(pow(lBlur, vec3(1.0 / 2.2)), vec3(0), vec3(100)), 1.0);\n        fragColor = mix(lInputColor0, lOutputColor, BLOOM_FRAME_BLEND); \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n\nfloat noise(float x)\n{\n    return 2.*textureLod(iChannel0, vec2(x+0.5,0)/256., 0.).r-1.;\n}\n\nfloat fbm1D(float x)\n{\n    return noise(x)*0.5 + noise(2.*x)*0.25 + noise(4.*x)*0.125;\n}\n\n\n\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nvec3 bloomTile(float lod, vec2 offset, vec2 uv)\n{\n    return textureLod(iChannel1, uv * exp2(-lod) + offset, 0.0).rgb;\n}\n\nvec3 getBloom(vec2 uv)\n{\n    vec3 blur = vec3(0.0);\n    vec2 lOffsetFix = vec2(0.00025, 0.0005);\n    blur = pow(bloomTile(2., vec2(0.0, 0.0) + lOffsetFix, uv),vec3(2.2))       \t   \t+ blur;\n    blur = pow(bloomTile(3., vec2(0.3, 0.0) + lOffsetFix, uv),vec3(2.2)) * 1.3        + blur;\n    blur = pow(bloomTile(4., vec2(0.0, 0.3) + lOffsetFix, uv),vec3(2.2)) * 1.6        + blur;\n    blur = pow(bloomTile(5., vec2(0.1, 0.3) + lOffsetFix, uv),vec3(2.2)) * 1.9 \t   \t+ blur;\n    blur = pow(bloomTile(6., vec2(0.2, 0.3) + lOffsetFix, uv),vec3(2.2)) * 2.2 \t   \t+ blur;\n\n    return blur * BLOOM_RANGE;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\t\n    vec2 p = (fragCoord*1.5-iResolution.xy)/iResolution.y;\n    p.y -= 0.35;\n    p.x -= 0.45;\n    float camTime = iTime;\n    float time = iTime;\n    vec2 q = p + vec2(fbm1D(camTime+50.), fbm1D(camTime+20.))*0.1 - vec2(0.7,0.1);\n    \n    vec4 col = texture(iChannel0, uv);\n    col.rgb += pow(getBloom(uv), vec3(1.2));\n    //col.rgb += getBloom(uv);\n    col.rgb = aces_tonemap(col.rgb);\n   \n\n    \n    fragColor = vec4(col.rgb, 1.0);\n    fragColor.rgb *= clamp(pow(164. * q.x*q.y*(1.-q.x)*(1.-q.y), 1.12), 0., 1.);\n}","name":"Buffer C","description":"","type":"buffer"}]}