{"ver":"0.1","info":{"id":"wlG3Wy","date":"1579745708","viewed":441,"name":"HexTorus","username":"NivBehar","description":"HexTorus\nPlay with the mouse to change the torus's mood ;)","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","torus","spiral","hexagons"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define time iTime\n# define PI 3.141592654\n# define MaxSteps 200. // max steps for ray marching\n\nvec3 RotX (vec3 p, float speed)\n{\n    return vec3(p.x, p.y*cos(speed) + p.z*-sin(speed),  p.y*sin(speed) + p.z*cos(speed));\n}\nvec3 RotY (vec3 p, float speed)\n{\n    return vec3(p.x*cos(speed) + p.z*sin(speed), p.y, p.x*-sin(speed) + p.z*cos(speed));\n}\nvec3 RotZ (vec3 p, float speed)\n{\n    return vec3(p.x*cos(speed)  + p.y*-sin(speed), p.x*sin(speed) + p.y*cos(speed), p.z);\n}\n\nvec3 torus1Pos() {return vec3(0.,0.,0.);}\nvec2 torus1Size() {return vec2(45.3,17.5);} //45.3 17.5\n\nfloat torusRotSpeed() {return time;}\nfloat inOut = -1.; // -1 inside torus, 1 outside torus\n\nvec2 hexCoordsMul = vec2(6.,3.03);\nfloat hexCoordsAdd = 1000.;\n\nvec3 spherePos() {return vec3(0, 2.5, 40.) \n                         + 12.*vec3(0., sin(pow(cos(0.75*time),2.)*cos(1.125*time)), 0.)\n                         + 0.*2.*vec3(sin(time*0.4), 0., cos(time*0.4));}\nfloat sphereRad() {return 6.;}\nvec3 spherePosNew(vec3 p, vec3 spherePos)\n{\n    vec3 spherePosNew = RotZ(spherePos, time); // rotate around the torus\n    spherePosNew = RotY(spherePosNew, time);\n    // rotate around itself\n    spherePosNew = RotZ(p - spherePosNew, time);\n    spherePosNew = RotY(spherePosNew, time);\n    return spherePosNew;\n}\n\nvec3 camerapos() {return vec3(0., 2.5, 60.);}\nvec3 cameralookat() {return vec3(15.*cos(time*0.582),35.*sin(time*0.298),0.);}\nvec3 LightPos()\n//{   \n//    float a = 40.;   \n//    return vec3(sin(time)*a,2.5,cos(time)*a);\n//}\n{return camerapos()+vec3(0.,0.,5.);} //vec3(35*sin(time), 15, 35*cos(time)); //vec3(0,1.7 + 1.3*sin(0.3*q26),0); //vec3(sin(q26*4 + time*0.5)*8, 10 + 4*sin(time),cos(q26*2.5 + time*0.3)*8); //camerapos + 0*vec3(sin(time)*5,4,cos(time)*5) + 0*vec3(0,4.5 + 0*2.4*sin(time*0.3),0);\n\nvec3 lum(vec3 col)\n{\n    float gray = 0.2989 * col.x + 0.5870 * col.y + 0.1140 * col.z;\n    return vec3(gray);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1.-h);\n}\n// Hexagon Dist by BigWings\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    \n    float c = dot(p, normalize(vec2(1.,1.73)));\n    c = max(c, p.x);\n    \n    return c;\n}\n// Hash function by BigWings\nvec2 N22(vec2 p)\n{\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n// Hexagon Coords by BigWings\nvec4 HexCoords(vec2 UV) \n{\n    \tvec2 r = vec2(1., 1.73);\n    vec2 h = r*.5;\n    \n    vec2 a = mod(UV, r)-h;\n    vec2 b = mod(UV-h, r)-h;\n    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    \n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = UV - gv;\n    return vec4(x, y, id.x,id.y);\n}\nvec3 Hive(vec2 UV, float a)\n{\n    vec3 col = vec3(0);\n    vec4 hc = HexCoords(UV);\n    float c = smoothstep(0.08, 0.11, hc.y); // inside each hexagon (without the edges)\n    \n    // waves based on hexagon's ID\n    float b1 = 0.5 + 0.43*sin(hc.z*5. + hc.w*3. + 4.*time);\n    // Spirals on each hexagon\n    float b2 = 0.5 + 0.5*cos(hc.x*10. + hc.y*45. + 8.*time);\n    \n    //vec4 ehc = HexCoords((hc.xz+0.1*vec2(0., time))*3.*vec2(2.0693,2.5) + 100. + vec2(4.,0.));\n    //float hexagons = smoothstep(0.,0.01, ehc.y)*mod(ehc.z,2.)*mod(ehc.w,2.);\n    //float b3 = b1*(1.-hexagons);\n\n    float everyOtherTile = mod(floor(hc.z),2.);\n\n    float edges = 1.-c;\n    float eSquares = cos(hc.y*20. + time)*sin(hc.x*20. + time); // edges squares\n    eSquares = smoothstep(0.,0.01,eSquares);\n    float b4 = edges * eSquares; \n\n    // bottom color\n    vec3 col1 = b2*(1.-b1)*c*vec3(0.4274,0.847,0.8941) // azur color for the inverse of the waves\n          + b1*c*vec3(0.4078,0.1725,0.0705)  // brown color for the waves\n          + vec3(b1,0,(1.-b1))*c*0.2          // add some rg colors to the waves and to the inverse of them\n          + b4*vec3(0.8431,0.7607,0.5019);   // brown-ish color for the edges of each hexagon\n    // top color\n    vec3 col2 = b2*(1.-b1)*c*vec3(0.4745,0.3705,0.9039) //  purple color for the inverse of the waves\n          + b1*c*vec3(0.8431,0.7607,0.5019)  // brown color for the waves\n          + vec3(b1,0,(1.-b1))*c*0.08          // add some rg colors to the waves and to the inverse of them\n          + b4*1.3;   // white color for the edges of each hexagon\n    \n    col = mix(col1,col2, a);\n    \n    //vec3 test = vec3(hc.zw*0.005,0.);//everyOtherTile;\n    \n    vec3 woodTex = texture(iChannel0, UV*0.2).xyz;\n    return (woodTex*col+0.7*col);\n}\nvec2 GetTorusUV(vec3 p, vec2 torusSize)\n{\n    float x = atan(p.x, p.z);\n    float y = atan(length(p.xz)-torusSize.x, p.y);\n    return vec2(x,y);    \n}\nfloat sdTorus1(vec3 p, vec2 r, float a) {\n    float torusDist = length( vec2(length(p.xz) - r.x, p.y) ) - r.y; \n    \n    vec2 tUV = GetTorusUV(p, torus1Size());   \n    vec4 h = HexCoords(tUV*hexCoordsMul + hexCoordsAdd + torusRotSpeed());\n    float hive = 0.25*smoothstep(0.,0.1,h.y) - 0.4*smoothstep(0.1,0.2,h.y);\n    float hexTorus = torusDist + hive;\n\n    float holesTorus = max(-hexTorus,torusDist);\n    float hiveTorus = inOut*hexTorus;\n    \n    float toreturn;\n    if(a == 1.)\n        toreturn = holesTorus;\n    else \n        toreturn = hiveTorus;\n    return toreturn;\n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\nvec2 GetSphereUV(vec3 p, float r)\n{\n    vec3 n = normalize(p);\n    float x = atan(n.x, n.z)/(2.*PI) + 0.5;\n    float y = 0.5 + 0.5*n.y;\n    return vec2(x,y);\n}\nfloat sdSphere( vec3 p, float r, float a)\n{\n    vec2 sUV = GetSphereUV(p, r);\n    vec4 h = HexCoords(sUV*vec2(6.,3.3) + 100.);\n    float sphereDist = length(p)-r;\n    float hive = -0.25*smoothstep(0.,0.1,h.y) + 0.4*smoothstep(0.1,0.2,h.y);\n    float HexSphere = sphereDist + hive; // + 0.3*h.y*sin(h.y*15. + time) - h.y\n    return a==1. ?  HexSphere : max(-sphereDist,HexSphere);\n}\nvec2 GetDist(vec3 p, float a)\n{\n    vec2 distToReturn; \n\n    // torus\n    vec3 torusPosNew = RotY(p - torus1Pos(), time);\n    float torusDist = sdTorus1(p - torus1Pos(), torus1Size(), a);\n    float torusID = 1.;\n\n    // a big black sphere around the scene\n    float worldDist = -sdSphere(p, 200., 0.); // I did this because I dont want to discard\n    float worldID = 2.;                   // the pixels that doesnt intersect with the torus, \n                                          // unless - the line in the middle will look odd    \n    // a sphere inside the torus\n    vec3 spherePosNew = spherePosNew(p, spherePos());\n    float sphereDist = sdSphere(spherePosNew, sphereRad(), a);\n    float sphereID = 3.;\n\n    float dist = min(torusDist, sphereDist);\n    dist = min(dist,-worldDist);\n\n    if(dist == torusDist)\n        distToReturn = vec2(dist, torusID);   \n    if(dist == worldDist)\n        distToReturn = vec2(dist, worldID); \n    if(dist == sphereDist)\n        distToReturn = vec2(dist, sphereID);\n    return distToReturn;\n}\nvec3 RayMarch(vec3 ro, vec3 rd, float steps, float a) \n{\n    vec2 dS;\n    float dO;\n    vec3 p;\n    for(float i = 0.; i<steps; i++)\n    {\n        p = ro + rd * dO;\n        dS = GetDist(p, a);\n        if(dS.x < 0.0001) {break;}\n        dO += dS.x*0.8;\n    }     \n    return vec3(dO,dS);\n}\nvec3 GetNormal(vec3 p, float a)\n{\n    float d = GetDist(p, a).x;\n    vec2 e = vec2(.01, 0);\n \n    vec3 n = d-vec3(GetDist(p-e.xyy, a).x, \n                        GetDist(p-e.yxy, a).x, \n                        GetDist(p-e.yyx, a).x);\n    return normalize(n);\n}\nfloat GetLight(vec3 p, vec3 lightpos, float lightpower, float shadowstrength, float steps, float a)\n{\n    //vec3 lightpos = LightPos;\n    //lightpos = camerapos;\n    vec3 l = normalize(lightpos - p);\n    vec3 n = GetNormal(p, a);\n    float dif = clamp(dot(n, l*lightpower), 0., 1.);\n    //dif = dot(n,l);\n    if(steps > 0.) // shadows\n    {\n        float d = RayMarch(p + n*0.2, l, steps, a).x;\n        if(d < length(lightpos-p))\n            dif *= shadowstrength;\n    }\n    return dif;\n}\nfloat specularReflection(vec3 p, vec3 rd, vec3 lightPos, float a, float intensity, float shininessVal)\n{\n    vec3 N = GetNormal(p, a);\n    vec3 L = normalize(lightPos - p);\n    float lambertian = max(dot(L, N), 0.0);\n    float specular = 0.;\n  \tif(lambertian > 0.0) {\n        vec3 R = reflect(-L, N);      // Reflected light vector\n        vec3 V = normalize(-rd); // Vector to viewer\n        // Compute the specular term\n        float specAngle = max(dot(R, V), 0.0);\n        specular = pow(specAngle, shininessVal);\n  \t}\n    return specular * intensity;\n}\nvec3 GetCol(vec3 ro, vec3 rd, vec3 p, vec3 d, vec2 a) \n{\n    vec3 ret;\n\tfloat dif = GetLight(p, LightPos(), 1., 0.7,  0., a.x); //***\n    float spRef = specularReflection(p, rd, LightPos(), a.x, 0.8, 10.);\n    //float dif = 1.;\n\n    if(d.z == 1.) //torus painting\n    {        \n        vec3 col;\n        vec2 tUV = GetTorusUV(p - torus1Pos(), torus1Size());\n        col = Hive(tUV*hexCoordsMul+hexCoordsAdd+torusRotSpeed(), a.y);\n        ret = vec3(dif);\n        ret = dif*col;\n    }\n    if(d.z == 2.) // world painting - black\n    {\n        ret = vec3(0.);\n    }\n    if(d.z == 3.) // sphere painting\n    {\n        vec3 col;\n        vec3 spherePosNew = spherePosNew(p, spherePos());\n        vec2 sUV = GetSphereUV(spherePosNew, sphereRad());\n        col = Hive(sUV*vec2(6.,3.3) + 100., 1.-a.y);\n        ret = col*dif;//vec3(dif)*vec3(0.5,0.7,0.9);\n    }\n    ret *= ret*1.5;\n\tret += spRef;\n    \n    return ret;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ret = vec3(0);\n    \n    vec2 uv_temp = uv;\n    \n    uv = RotZ(vec3(uv,0.), 0.4*sin(time*0.368)).xy;\n    \n    vec3 col = vec3(0);\n \n    vec3 lookat = cameralookat();\n\n    float zoom = 0.3;//0.5 + 0.3*sin(time*0.326);\n    vec3 ro = camerapos();\n\n    vec3 F = normalize(lookat-ro); // Forward\n    vec3 R = normalize(cross(vec3(0., 1., 0.), F)); //Right\n    vec3 U = cross(F, R); //Up\n\n    vec3 C = ro + F*zoom;\n    vec3 I = C + uv.x*R + uv.y*U;\n    vec3 rd = normalize(I-ro);\n\n    // a.x will determine if the pixel will get the torus with the holes\n    // a.y will determine the color \n    vec2 a = vec2(0.,0.);\n    vec2 b = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    if(uv_temp.x > b.x) {a.x = 1.;}\n    if(uv_temp.y > b.y) {a.y = 1.;}\n    \n    vec3 d = RayMarch(ro,rd, MaxSteps, a.x);\n    vec3 p = ro + rd*d.x;\n    \n    ret = GetCol(ro, rd, p, d, a);\n    \n    //ret = dif;\n    //ret = Hive(uv*5.+10.);\n    \n    float mouseClicked = iMouse.w > 0. ? 0.12 : 0.;\n    vec3 vline = exp(-80.*length(uv_temp.x-b.x))*vec3(1.,1.,1.); // vertical line\n    vec3 hline = exp(-80.*length(uv_temp.y-b.y))*vec3(1.,1.,1.); // horizontal line\n    vec3 lineCol = texture(iChannel1,uv_temp*0.05\n                           + mouseClicked*vec2(time*0.5,time)\n                           + vec2(time*0.01, time*0.02)).xyz;\n    lineCol = (lineCol)*3.*vec3(0.8,1.,0.4);\n    ret *= 1.-vline;\n    ret += vline*lineCol;\n    ret *= 1.-hline;\n    ret += hline*lineCol;\n    \n    \n    //ret = line;\n    //ret = lineCol;\n\n    fragColor = vec4(ret,1.0);\n}","name":"Image","description":"","type":"image"}]}