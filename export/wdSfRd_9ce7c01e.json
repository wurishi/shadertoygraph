{"ver":"0.1","info":{"id":"wdSfRd","date":"1590603363","viewed":557,"name":"texture interpolation behavior","username":"ttg","description":"See Description","likes":1,"published":3,"flags":32,"usePreview":0,"tags":["texture","filter","linear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nBe careful when interpolating sRGB textures:\n OpenGL doesn't know the encoding, and interpolates linearly.\n\nHW filtering: OpenGL texture(...) behavior\nSW filtering: GLSL code for interpolating fetched values (see Common)\nConversion: sRGB to linear\n\nTop to bottom:\n- Conversion after HW filtering\n- Conversion after SW filtering\n- Conversion before SW filtering\n- HW filtering of linear buffer\n- SW filtering of linear buffer\n\n*/\n\nvoid mainImage( out vec4 fv, in vec2 fc )\n{\n  vec3 v;\n  vec2 u = fc/iResolution.xy;\n\n  vec2 m = (iMouse.x==0.)?vec2(0):iMouse.xy/iResolution.xy-.5;\n  vec2 uv = vec2(u.x/32.,0.)+vec2(.24,.136)+.1*m;\n\n  if      (u.y>.8) v = srgb_to_linear(texture(iChannel1, uv).rgb);\n  else if (u.y>.6) v = srgb_to_linear(textureLinear(iChannel1, uv).rgb);\n  else if (u.y>.4) v = textureLinearConv(iChannel1, srgb_to_linear, uv).rgb;\n  else if (u.y>.2) v = texture(iChannel0, uv*512./iResolution.xy).rgb;\n  else             v = textureLinear(iChannel0, uv*512./iResolution.xy).rgb;\n\n  fv.a=1.; fv.rgb = srgb_from_linear(v);\n  if(length(mod(u,.2))<.005) fv = vec4(0,1,0,0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// BEGIN Linear Filtering Shim https://www.shadertoy.com/view/tssXWf\nconst struct SAMPLERINDEX_T {\n  int iChannel0, iChannel1, iChannel2, iChannel3;\n} SAMPLERINDEX = SAMPLERINDEX_T(0,1,2,3);\n\nvec4 textureLinearPix (sampler2D sampler, vec2 U) {\n  return mix(mix(\n      texelFetch(sampler,ivec2(U)+ivec2(0,0),0),\n      texelFetch(sampler,ivec2(U)+ivec2(1,0),0),\n    fract((U).x)),mix(\n      texelFetch(sampler,ivec2(U)+ivec2(0,1),0),\n      texelFetch(sampler,ivec2(U)+ivec2(1,1),0),\n    fract((U).x)),fract((U).y));\n}\n\n#define textureLinear(sampler,P) textureLinearPix(sampler, \\\n    (P)*iChannelResolution[SAMPLERINDEX.sampler].xy-vec2(.5))\n// END Linear Filtering Shim\n\n#define textureLinearPixConv(sampler, conv, U) (         \\\n  mix(mix(                                               \\\n      (conv(texelFetch(sampler,ivec2(U)+ivec2(0,0),0))), \\\n      (conv(texelFetch(sampler,ivec2(U)+ivec2(1,0),0))), \\\n    fract((U).x)),mix(                                   \\\n      (conv(texelFetch(sampler,ivec2(U)+ivec2(0,1),0))), \\\n      (conv(texelFetch(sampler,ivec2(U)+ivec2(1,1),0))), \\\n    fract((U).x)),fract((U).y))                          \\\n  )\n\n#define textureLinearConv(sampler,conv,P) \\\n  textureLinearPixConv(sampler,conv, \\\n    (P)*iChannelResolution[SAMPLERINDEX.sampler].xy-vec2(.5))\n\n// BEGIN sRGB/linear conversion\n// Adapted from\n// https://www.shadertoy.com/view/4tXcWr\n// By https://www.shadertoy.com/user/Tynach\nvec3 srgb_from_linear(vec3 linearRGB)\n{\n\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n\tvec3 higher = vec3(1.055)*pow(linearRGB, vec3(1.0/2.4)) - vec3(0.055);\n\tvec3 lower = linearRGB * vec3(12.92);\n\treturn mix(higher, lower, cutoff);\n}\n\nvec3 srgb_to_linear(vec3 sRGB)\n{\n\tbvec3 cutoff = lessThan(sRGB, vec3(0.04045));\n\tvec3 higher = pow((sRGB + vec3(0.055))/vec3(1.055), vec3(2.4));\n\tvec3 lower = sRGB/vec3(12.92);\n\n\treturn mix(higher, lower, cutoff);\n}\n\nvec4 srgb_to_linear(vec4 sRGBA)\n{\n    return vec4(srgb_to_linear(sRGBA.rgb), sRGBA.a);\n}\n// END sRGB/linear conversion\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fv, in vec2 fc )\n{\n    ivec2 fi = ivec2(fc);\n    fv=srgb_to_linear(texelFetch(iChannel1, fi, 0));\n}\n","name":"Buffer A","description":"","type":"buffer"}]}