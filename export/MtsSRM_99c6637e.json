{"ver":"0.1","info":{"id":"MtsSRM","date":"1435454740","viewed":178,"name":"Julia, oh Julia","username":"Marv","description":"yay","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define N 256.0\n#define R 4.0\n#define STEP 3.0 //3.0 looks pretty smooth for accurate display, higher values (100ish) are neat too\n\n#define TIME_SCALE 0.5\n\n#define X -0.85\n#define Y 0.27015\n\n\n#define SPHERICAL\n\nvec2 o = vec2(0.0, 0.0);\n\nfloat getC(float f, float o) {return sin(f + o) * 0.5 + 0.5;}\n\nfloat iterate(float x, float y) {\n    vec2 c = vec2(X+cos(iTime*TIME_SCALE)*0.1,Y);\n    \n    for (float k = 0.0; k < N; k++) {\n    \tfloat xN = (x * x) - (y * y) + c.x;\n        y = (2.0 * x * y) + c.y;\n        x = xN;\n        if (x * x + y * y >= R) {\n        \treturn (k - (log(log(x * x + y * y) / log(4.0)) / log(2.0)))*0.25 - 1.9;\n        }\n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 5.0 - 2.5; \n    uv.y *= iResolution.y / iResolution.x;\n    //uv = uv * max(1.0 * pow(0.9, iTime), 10E-7) + o; //Zoom\n    \n\tfloat stepsize = STEP/iResolution.x;\n    \n#ifdef RECTANGULAR\n    //Rectangular smoothing\n    float col = 0.0;\n    for (float i = -1.0; i <= 1.0; i++) {\n        for (float j = -1.0; j <= 1.0; j++) {\n        \tcol += (iterate(uv.x+stepsize*i, uv.y+stepsize*j)/9.0);\n        }\n    }\n#else\n    float col = iterate(uv.x, uv.y) / 9.0;\n#endif\n#ifdef SPHERICAL\n    //Spherical smoothing\n    for (float i = 0.0; i < 8.0; i++) {\n    \tcol += iterate(uv.x+stepsize*sin(i), uv.y+stepsize*cos(i))/9.0;\n    }\n#endif\n    \n\tfragColor = vec4(vec3(2.0*getC(col, 0.0), getC(col, 2.0), 0.5*getC(col, 4.0)) - vec3(length(uv*0.15)), 1.0);\n}","name":"Image","description":"","type":"image"}]}