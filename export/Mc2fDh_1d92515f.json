{"ver":"0.1","info":{"id":"Mc2fDh","date":"1731324624","viewed":116,"name":"Spheroid - game renderer.","username":"Cotterzz","description":"This is the final version of the game's main shader.\nObject on object shadows removed - too expensive and hardly noticeable.\nSome other additions and the game is now called spheroid.\n","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["game","lighting","spheres","shadows","ball","25d","orthographic","spheroid","spheroid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright (c) 2024 John Cotterell johnmdcotterell@gmail.com\n// You may view and edit this code (with this message intact) only on Shadertoy.\n// Anything else requires my permission.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord/iResolution.y;\n    ar = iResolution.x/iResolution.y;\n    float height = 0.0;\n    pixel = 1./iResolution.y;\n    float mTime = mod(iTime, 6.2832);\n    bool ZoneRob = false;\n    bool ZoneGround = false;\n    bool ZoneWall = false;\n    bool ZoneGoalWall = false;\n    bool ZoneInsideWall = false;\n    border = 0.05;\n    bar = 1.0;\n    vec4 courtyard = vec4( border*bar, border, ar-(border*bar), 1.0-border);\n    courtprox = vec4( courtyard.x - uv.x, courtyard.y - uv.y, uv.x - courtyard.z, uv.y - courtyard.w);\n    float goalwidth = 0.2;\n    float goaltop = 0.5 + (goalwidth/2.0);  \n    float goalbottom = 0.5 - (goalwidth/2.0);\n    float goalprox = max((uv.y-goaltop), (goalbottom-uv.y));\n    float wallheightfactor = 1.0;\n\n    Rob Robs[numrobs];\n    float dist = ar;\n    int rindex = -1;\n    vec2 centre = vec2(ar/2.0, 0.5);\n    float radius = 0.0;\n    float cradius = 0.34;\n    vec2 centreL = vec2((ar/2.0)-(cradius),0.5);\n    vec2 centreR = vec2((ar/2.0)+(cradius),0.5);\n    float segment = 1.256637;\n    float rightAng = 1.5708;\n    float dradius = 0.048;\n    float bradius = 0.02;\n    vec2 distv; \n    vec3 normal = vec3(0.0,0.0,1.0);\n    vec3 bgnormal = vec3(0.0,0.0,1.0); \n    bool flatTop = false;\n    float theight = 0.0;\n    float angle = 0.0;\n    \n    int activerobs = 11;\n    \n    for(int i=1;i<numrobs;i++){\n    Robs[i].ison = false;\n      if(i<activerobs){\n        Robs[i].ison = true;\n        Robs[i].radius = dradius;\n        angle = float(i) * segment;\n        vec2 rcentre = centreL;\n        if(i>5){\n            Robs[i].colourA = pgreen;\n            Robs[i].colourB = pblack;\n            angle += mTime;\n            Robs[i].rotation = angle + rightAng;\n            rcentre = centreR;} else {\n                Robs[i].colourA = pink;\n                Robs[i].colourB = white;\n                angle -= mTime;\n                Robs[i].rotation = angle - rightAng;\n            }\n        Robs[i].position = vec3( rcentre.x + (cradius * cos(angle)), rcentre.y + (cradius * sin(angle)), 0.0);\n        } \n    }\n    \n    int player = 1;\n    \n    int hasball = 1;\n    int tracter = hasball;\n    int tractee = 0;\n    bool tracting = false;\n    if(tracter>0){tracting = true;}\n    \n    float sinw = sin(mTime*50.0);\n    \n    if(tractee==0 &&tracting){\n        float balldist = dradius+bradius*3.;\n        balldist += sinw/200.0;\n        Robs[0].position = vec3( Robs[hasball].position.x + (balldist * cos(Robs[hasball].rotation)), Robs[hasball].position.y + (balldist * sin(Robs[hasball].rotation)), bradius);\n    } else {\n        Robs[0].position = vec3(ar/4., 0.2, 0.);\n    }\n    Robs[0].radius = bradius;\n    Robs[0].ison = true;\n    Robs[0].colourA = vec3(1.2);\n    Robs[player].colourA = pred;\n    vec3 bgcol;\n    vec3 fgcol; \n    vec3 col = white;  \n    vec2 robambient = vec2(1.0, 1.0);\n    \n    light lights[numlights];\n    lights[0] = light(vec3(1.0,1.0,1.0),vec3(ar*.5, .5 ,.6),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.1, true, true);\n    lights[1] = light(vec3(1.0,0.3,0.3),vec3(ar*-0.04, 0.5 ,0.05),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.03, true, true);\n    lights[3] = light(vec3(0.3,1.0,0.3),vec3(ar*1.04, 0.5 ,0.05),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.025, true, false);\n    \n    lights[2] = light(vec3(0.2,0.2,0.9),vec3(0.0),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.0015, false, false);\n    \n    lights[2].position = Robs[tractee].position;\n    lights[2].position.z = 0.001;\n    lights[2].ison = tracting;\n    if(uv.x>=ar/2.0){\n        lights[1] =  lights[3]; lights[1].ison = true;\n    }\n        vec3 tcol = vec3(0.2,0.2,0.6);\n    if(tracter<6){tcol = vec3(0.5,0.2,0.2);}else{tcol = vec3(0.2,0.5,0.2);}\n    lights[2].colour = tcol;\n\n    if(courtprox.w>0.0 && courtprox.w*bar>courtprox.z && courtprox.w*bar>courtprox.x){\n        bgcol = pgrey;\n        bgnormal = vec3(0.0,-1.0,0.0);\n        ZoneWall = true;\n        height = courtprox.w * wallheightfactor;\n    } else if(courtprox.y>0.0 && courtprox.y*bar>courtprox.z && courtprox.y*bar>courtprox.x){\n        bgcol = pgrey;\n        bgnormal = vec3(0.0,1.0,0.0);\n        ZoneWall = true;\n        height = courtprox.y *  wallheightfactor;\n    } else if(goalprox>0.0 && courtprox.x>0.0 || courtprox.x>(border*bar)/2.0){\n        bgcol = pgrey;\n        bgnormal = vec3(1.0,0.0,0.0);\n        ZoneWall = true; ZoneGoalWall = true;\n        float cph = courtprox.x/2.2;\n        if(goalprox<cph && courtprox.x<(border*bar)/2.0 ){\n            ZoneInsideWall = true;\n            height = goalprox * wallheightfactor;\n            if(uv.y<0.5){bgnormal = vec3(0.0,1.0,0.0);}else{bgnormal = vec3(0.0,-1.0,0.0);} \n        } else {\n            height = courtprox.x * wallheightfactor;      \n        }\n    } else if(goalprox>0.0 && courtprox.z>0.0 || courtprox.z>(border*bar)/2.0){\n        bgcol = pgrey;\n        bgnormal = vec3(-1.0,0.0,0.0);\n        ZoneWall = true; ZoneGoalWall = true;\n        if(goalprox<courtprox.z/2.2 && courtprox.z<(border*bar)/2.0 ){\n            ZoneInsideWall = true;\n            height = goalprox * wallheightfactor;\n            if(uv.y<0.5){bgnormal = vec3(0.0,1.0,0.0);}else{bgnormal = vec3(0.0,-1.0,0.0);}\n        } else {\n            height = courtprox.z * wallheightfactor;\n          \n        }\n    } else {\n        ZoneGround = true;\n        bgcol = getGroundColour();\n        bgnormal = vec3(0.0,0.0,1.0);\n    }\n    \n    float limA = courtyard.x;\n    float limB = courtprox.x;\n    \n    if(uv.x>ar/2.0){ limA = courtyard.z; limB = courtprox.z; }\n    \n    float lightATG = (goaltop-lights[1].position.y)/(lights[1].position.x-limA);\n    float lightATGdist = ( (lights[1].position.x - uv.x) * lightATG) -  (uv.y-lights[1].position.y);\n    float lightABG = (goalbottom-lights[1].position.y)/(lights[1].position.x-limA);\n    float lightABGdist =    (uv.y-lights[1].position.y)-( (lights[1].position.x - uv.x) * lightABG);\n    float lightAdist = lightABGdist*lightATGdist;\n    \n    lights[1].shadow.x = 1.0;\n    \n    if(goalprox<0.0||ZoneInsideWall){lights[1].shadow.x = 0.0;} else if(lightAdist>0.0){\n        lights[1].shadow.x = 0.0;\n        f = smoothstep(0.0, 0.2*-limB, lightAdist);\n        lights[1].shadow.x = mix(1.0, 0.0, f);\n    }\n    \n    lights[1].shadow.y = lights[1].shadow.x;\n    \n    for(int i=0;i<numrobs;i++){\n        if(Robs[i].ison){\n        float bdist = distance(uv, Robs[i].position.xy);\n        if(bdist<dist){dist=bdist;}\n        float edgedist = distance(uv, Robs[i].position.xy) + (Robs[i].position.z);\n        if(bdist<Robs[i].radius){\n            dist=bdist;\n            radius = Robs[i].radius;\n            height = sqrt((radius*radius)-(dist*dist));\n            ZoneRob = true;\n            rindex = i;\n            if(i>5){flatTop=true;}\n            if(bdist<Robs[i].radius-pixel){ZoneGround = false;}\n            robambient.y *= 1.0 - (0.5 * pow(0.8/(edgedist/Robs[i].radius),3.0));\n        } else {\n            robambient *= 1.0 - (0.5 * pow(0.8/(edgedist/Robs[i].radius),3.0));\n        }\n      }\n    }\n    \n    if(ZoneRob){\n        fgcol = Robs[rindex].colourA;\n        centre = vec2(Robs[rindex].position.x, Robs[rindex].position.y);\n        distv = uv - centre;\n        normal = vec3(distv.x, distv.y, height)/radius;\n        height+=Robs[rindex].position.z;\n        \n        if(flatTop){\n            float tradius = radius/2.5;\n            theight = sqrt((radius*radius)-(tradius*tradius));\n            if(height>theight){\n                height=theight;\n                normal = vec3(0.0, 1.0, 0.0);\n            }\n            f = smoothstep(theight-0.01, theight, height);\n            normal = mix(normal,vec3(0.0, 0.0, 1.0),  f);\n            height = mix(height,theight,  f);\n        }\n        \n        robambient.x *= (0.6 + normal.z/3.0);\n        float rotation = Robs[rindex].rotation;\n        if(rindex>0){\n            float SpFoffset = radius*2.0;\n            float SpBoffset = radius/1.0;\n            float SpFheight = radius*-1.0;\n            float SpBheight = radius*1.4;\n            float SpWidth = radius/1.4;\n            float SpLength = SpFoffset+SpBoffset;\n            float SpHeight = SpBheight-SpFheight;\n            vec3 SpFc = vec3(centre.x + SpFoffset * cos(rotation),  centre.y + SpFoffset * sin(rotation), 0.0);\n            vec3 SpFl = SpFc; SpFl.x += (SpWidth * sin(rotation)); SpFl.y -= (SpWidth * cos(rotation));\n            vec3 SpFr = SpFc; SpFr.x -= (SpWidth * sin(rotation)); SpFr.y += (SpWidth * cos(rotation));\n            vec3 SpBc = vec3(centre.x - SpBoffset * cos(rotation), centre.y - SpBoffset * sin(rotation), 0.0);\n            vec3 SpBl = SpBc; SpBl.x += (SpWidth * sin(rotation)); SpBl.y -= (SpWidth * cos(rotation));\n            vec3 SpBr = SpBc; SpBr.x -= (SpWidth * sin(rotation)); SpBr.y += (SpWidth * cos(rotation));\n            float SpFD = linePointLength( vec3(uv.x, uv.y, 0.0), vec3(SpFl.x, SpFl.y, 0.0), vec3(SpFr.x, SpFr.y, 0.0) );\n            float SpH = SpFheight + (SpHeight*(SpFD/SpLength));\n            float inTri = sdTriangle(uv, SpFc.xy, SpBr.xy, SpBl.xy);\n            \n            float lineDist = linePointLength( vec3(uv.x, uv.y, 0.0) , vec3(SpBc.x, SpBc.y, 0.0)  , vec3(SpFc.x, SpFc.y, 0.0)  );\n            \n            float linewid =  radius*0.05;\n            float linemid = abs((radius*0.45)-lineDist);\n            if(linemid<linewid){fgcol=Robs[rindex].colourB;}\n            if(linemid<linewid+pixel){\n                f = smoothstep(linewid,linewid+pixel, linemid);\n                fgcol = mix(Robs[rindex].colourB, fgcol, f);\n            }\n            if(rindex>5){\n                if(SpFD<radius*2.0){\n                    float linewid =  radius*0.05;\n                    float linemid = abs((radius*+0.45)-dist);\n                    if(linemid<linewid){fgcol=Robs[rindex].colourB;} else if(dist>(radius*+0.45)) {fgcol=Robs[rindex].colourA;}\n                    if(linemid<linewid+pixel){\n                        f = smoothstep(linewid,linewid+pixel, linemid);\n                        fgcol = mix(Robs[rindex].colourB, fgcol, f);\n                    }\n                }\n            } else {\n                if(SpFD>radius*2.5&&lineDist<(radius*0.5)+pixel){\n                    float linewid =  radius*0.05;\n                    float linemid = abs((radius*+0.75)-dist);\n                    if(linemid<linewid){fgcol=Robs[rindex].colourB;} else if(dist>(radius*+0.75)) {fgcol=Robs[rindex].colourA;}\n                    if(linemid<linewid+pixel){\n                        f = smoothstep(linewid,linewid+pixel, linemid);\n                        fgcol = mix(Robs[rindex].colourB, fgcol, f);\n                    }\n                }\n            }\n            \n            if(SpH>height){\n                float face = 0.7; \n                if(inTri<0.0&&dist<radius*0.9){\n                    if(dist<radius*0.7){\n                        f = smoothstep(0.0, pixel*5.0, SpH-height);\n                        height=mix(height, SpH,  f);\n                        normal=mix(normal,vec3( face * cos(rotation) , face * sin(rotation), 0.7), f);\n                    } else {\n                        f = smoothstep(radius*0.75, radius*0.95, dist);\n                        height=mix( SpH, height, f);\n                        normal=mix(vec3( face * cos(rotation) , face * sin(rotation), 0.7),normal, f);\n                    }\n                } \n            }\n            \n        }\n        normal = normal/length(normal);\n        /*    // ----  Objects casting shadows on other objects\n        for(int i=0;i<numrobs;i++){\n            if(i!=rindex&&Robs[i].ison){\n                for(int j=0;j<numlights;j++){\n                   if(lights[j].casts&&lights[j].ison){\n                     if(distance(Robs[i].position, lights[j].position) < distance(Robs[rindex].position, lights[j].position)){\n                        vec3 tempBall = Robs[i].position;\n                        tempBall.z*=1.2;\n                        float beam = linePointLength(tempBall, lights[j].position, vec3(uv.x, uv.y, height)); \n                        float cradius = Robs[i].radius*1.2; // cheating and making the ball bigger so shadow seen more easily\n                        float blur = distance(Robs[i].position, vec3(uv.x, uv.y, height))/5.0;\n                        float shadow = 0.0;\n                        if (beam<=(cradius-blur)){shadow = 1.0;} else {\n                            f = smoothstep(cradius-blur, cradius, beam);\n                            shadow = mix(1.0,0.0, f);\n                        }\n                            lights[j].shadow.y = max(shadow, lights[j].shadow.y);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // ----  Lots of GPU for small improvement, Uncomment to use\n        */ \n    }\n    \n    if(ZoneGround||ZoneWall){\n        float shadowheight = 0.0;\n        if(ZoneWall){shadowheight = height;};\n        for(int i=0;i<numrobs;i++){\n            if(Robs[i].ison){\n            for(int j=0;j<numlights;j++){\n            if(lights[j].casts&&lights[j].ison){\n                float beam = linePointLength(Robs[i].position, lights[j].position, vec3(uv.x, uv.y, shadowheight)); \n                float cradius = Robs[i].radius;\n                float blur = 0.;\n                blur=distance(Robs[i].position, vec3(uv.x, uv.y, shadowheight))/8.0;\n                float shadow = 0.0;\n                if (beam<=(cradius-blur)){shadow = 1.0;} else {\n                    f = smoothstep(cradius-blur, cradius, beam);\n                    shadow = mix(1.0,0.0, f);\n                }\n                lights[j].shadow.x = max(shadow, lights[j].shadow.x);\n            }\n            }\n            }\n        }\n    }\n\n    vec2 ambientmulti = vec2((min(0.5+(height*3.0), 1.0)),0.5);\n    float ambiA = 1.0;float ambiB = 1.0; float ambiC = 0.5;\n    ambientmulti *= sqrt((min(ambiC-(courtprox.w*ambiA), ambiB))*(min(ambiC-courtprox.z*ambiA, ambiB))*(min(ambiC-courtprox.y*ambiA, ambiB))*(min(ambiC-courtprox.x*ambiA, ambiB)));\n   \n    vec3 position = vec3(uv, height);\n    vec3 bgtot = vec3(0.0);\n    vec3 fgtot = vec3(0.0);\n    vec3 sptot = vec3(0.0);\n    for(int j=0;j<numlights;j++){\n   if(lights[j].ison){\n        lights[j].difference = lights[j].position - position;\n        lights[j].dist = length(lights[j].difference);\n        lights[j].difference = lights[j].difference/lights[j].dist;\n        lights[j].amount.x = max(0.0, dot(lights[j].difference, normal));\n        lights[j].amount.x = lights[j].amount.x/(lights[j].dist*lights[j].dist);\n        lights[j].amount.y = max(0.0, dot(lights[j].difference, bgnormal));\n        lights[j].amount.y = lights[j].amount.y/(lights[j].dist*lights[j].dist);\n        lights[j].amount.y *= lights[j].intensity * (1.0-lights[j].shadow.x);\n        lights[j].amount.x *= lights[j].intensity * (1.0-lights[j].shadow.y);\n        bgtot += lights[j].colour*lights[j].amount.y;\n        fgtot += lights[j].colour*lights[j].amount.x;\n        }\n    }\n\n    bgcol*=(robambient.y*ambientmulti.y)+bgtot;\n    if(ZoneRob){\n        vec3 incident = vec3(0.0, 0.0, -1.0);\n        vec3 reflection = reflect(incident, normal);\n        for(int j=0;j<numlights;j++){\n        if(lights[j].ison){\n            lights[j].amount.z = pow(max(0.0, dot(lights[j].difference, reflection)),32.0);\n            lights[j].amount.z = lights[j].amount.z/(lights[j].dist*lights[j].dist);\n            lights[j].amount.z *= lights[j].intensity * (1.0-lights[j].shadow.y);\n            sptot += lights[j].colour*lights[j].amount.z;\n            }\n        }\n\n        fgcol *= (robambient.x*ambientmulti.x)+fgtot;\n        fgcol += sptot;\n        \n        if(ZoneGround){\n            f = smoothstep(radius-pixel, radius, dist);\n            col = mix(fgcol,bgcol, f);\n        } else {\n            col = fgcol;\n        }\n    } else {\n       col = bgcol;\n    }\n    \n    if(tracting){\n        float tdist = dradius*0.5;\n        float tdistf = distance(Robs[tracter].position.xy, Robs[tractee].position.xy)/2.0;\n        float cosr = cos(Robs[tracter].rotation);\n        float sinr = sin(Robs[tracter].rotation);\n        vec2 tpA = vec2(Robs[tracter].position.x + (tdist * cosr), Robs[tracter].position.y + (tdist * sinr));\n        vec2 tpB = vec2(Robs[tracter].position.x + (tdistf * cosr), Robs[tracter].position.y + (tdistf * sinr));\n        float tpdist = distance(uv, Robs[tractee].position.xy);\n        float tqdist = distance(uv, tpA);\n        float tractor = sdBezier(uv, tpA, tpB, Robs[tractee].position.xy);\n        float lv = 0.01*tqdist;\n        float lw = (0.6*tqdist)+sin((mTime*80.0)+(tqdist*200.0))/80.0;\n        vec3 lcol = tcol/2.;\n        if(tractor<lw){f = smoothstep(lv, lw, tractor);col = mix(col+lcol,col, f);}\n    \n        if(rindex==tractee){\n            float llw = 0.4;\n            vec3 lnorm = vec3(sin(mTime*3.),cos(mTime*11.),cos(mTime*7.));\n            float ncola = sin(dot(normal, lnorm));\n            float ncolb = sin(dot(normal, lnorm.yzx));\n            float ncolc = sin(dot(normal, lnorm.zxy));\n            if(ncolc>sin(ncolc*5.) && ncolc<sin(ncolc*5.)+llw){col += tcol;}\n        }\n    }\n    \n    col = contrast(col, 1.2);\n    col = gammaCorrection(col, .95);\n    if(outputMode){col = outputColour;}\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define numrobs 11\n#define numlights 4\n\n#define white vec3(1.)\n#define pink vec3(.95,.75,.75)\n#define pgreen vec3(.7,.9,.7)\n#define pblack vec3(.6,.6,.6)\n#define black vec3(.0)\n#define pgrey vec3(0.85)\n#define pred vec3(1., .5, .5)\n\nfloat pixel = 0.0;\nvec4 courtprox = vec4(0.0);\nvec2 uv = vec2(0.0);\nfloat ar = 0.0;\nfloat f = 0.0; \nfloat border = 0.05;\nfloat bar = 1.0;\n\nstruct light\n{\n    vec3 colour;\n    vec3 position;\n    vec3 difference;\n    vec3 amount;\n    vec2 shadow;\n    float dist;\n    float intensity;\n    bool casts;\n    bool ison;\n};\n\nstruct Rob\n{\n    vec3 position;\n    vec3 colourA;\n    vec3 colourB;\n    float rotation;\n    float radius;\n    bool ison;\n};\n\nvec3 getGroundColour(){\n    float linewidth = 0.01;\n    float hlinewidth = linewidth/2.0;\n    float rhlinewidth = hlinewidth + pixel/2.0;\n    vec3 rcol = pgrey;\n    if(courtprox.x>-linewidth&&courtprox.x<=0.0||abs(courtprox.y)<linewidth||courtprox.z>-linewidth&&courtprox.z<=0.0||abs(courtprox.w)<linewidth){\n        rcol = white;\n    }\n    float crad = 0.2;\n    float dfc = distance(uv, vec2(ar/2.0, 0.5));\n    float crdiff = dfc-crad;\n    if(crdiff<rhlinewidth ){\n        f = smoothstep(rhlinewidth-pixel,rhlinewidth , abs(crdiff));\n        rcol = mix(white, pgrey, f);\n    }\n\n    if(crdiff>=hlinewidth-pixel&&abs(uv.x - (ar/2.0))<=hlinewidth){\n        rcol = white;\n    }\n    dfc = distance(uv, vec2(border*bar, 0.5));\n    crdiff = dfc-crad;\n    if(crdiff<rhlinewidth ){\n        f = smoothstep(rhlinewidth-pixel,rhlinewidth , abs(crdiff));\n        rcol = mix(white, rcol, f);\n    }\n    dfc = distance(uv, vec2(ar-(border*bar), 0.5));\n    crdiff = dfc-crad;\n    if(abs(crdiff)<rhlinewidth ){\n        f = smoothstep(rhlinewidth-pixel,rhlinewidth , abs(crdiff));\n        rcol = mix(white, rcol, f);\n    }\n    return rcol;\n}\n\nbool outputMode = false; vec3 outputColour;\nvoid outputValue (in float value){\n    outputMode = true;\n    if ( value >= 0.0 && value <= 1.0 )\n        { outputColour = vec3(value, value, value); }\n        else if ( value < 0.0 && value > -1.0 )\n        { outputColour = vec3(0.0, 0.0, -value ); }\n        else if ( value > 1.0 )\n        { outputColour = vec3(1.0-(1.0/value), 1.0, 0.0); }\n        else if ( value < -1.0 )\n        { outputColour = vec3(1.0-(1.0/-value), 0.0, 1.0); }\n} \nvoid outputValue (in vec3 value){outputMode = true;outputColour = value;}\n\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\n\nvec3 gammaCorrection (vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\n\nfloat linePointLength( in vec3 P, in vec3 A, in vec3 B ){\n    vec3 AB = B-A;\n    float lenAB = length(AB);\n    vec3 D = AB/lenAB;\n    vec3 AP = P-A;\n    float d = dot(D, AP);\n    vec3 X = A + D * dot(P-A, D);\n    if(X.z<0.0){return 10.0;} else {return length(X-P);}\n}\n\nvec3 linePoint( in vec3 P, in vec3 A, in vec3 B ){\n    vec3 AB = B-A;\n    float lenAB = length(AB);\n    vec3 D = AB/lenAB;\n    vec3 AP = P-A;\n    float d = dot(D, AP);\n    vec3 X = A + D * dot(P-A, D);\n    return X;\n}\n\n// SD Functions from https://iquilezles.org/articles/distfunctions2d/\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 ){\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\nfloat dot2( vec2 v ) { return dot(v,v); }\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n    }\n    return sqrt( res );\n}\n","name":"Common","description":"","type":"common"}]}