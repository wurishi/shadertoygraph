{"ver":"0.1","info":{"id":"ft3XRH","date":"1638677632","viewed":141,"name":"solid angle reflection","username":"do","description":"na","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["solidanglereflect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t iTime\n\n//solid angle reflection\n//2021\n//do\n\n#define AA 2\n#define EPS 0.001\n\nfloat h11(float p) {\n    return fract(sin(p)*float(43758.5453));\n}\n\nfloat checkerboard(vec3 p,float h) {\n    vec3 q = floor(p*h);\n    return mod(q.x+q.z,2.);\n}\n\nfloat expStep(float x,float k) {\n    return exp((x*k)-k);\n}\n\nvec2 opu(vec2 d1,vec2 d2) {\n    return (d1.x < d2.x) ? d1 : d2;\n} \n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    \n    return mat2(c,-s,s,c);\n}\n\nvec3 rayCamDir(vec2 uv,vec3 ro,vec3 ta,float fov) {\n\n     vec3 f = normalize(ta - ro);\n     vec3 r = normalize(cross(vec3(0.0,1.0,0.0),f));\n     vec3 u = normalize(cross(f,r));\n\n     vec3 d = normalize(uv.x * r\n     + uv.y * u + f * fov);  \n\n     return d;\n}\n\nfloat easeOut3(float t) {\n    return (t = t - 1.0) * t * t + 1.0;\n}\n\nfloat sphere(vec3 p,float r) { \n    return length(p) - r;\n}\n\nfloat capsule(vec3 p,vec3 a,vec3 b,float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return length(pa - ba * h) - r;\n} \n\nfloat prism(vec3 p,vec2 h) {\n    vec3 q = abs(p);\n    return max(q.z - h.y,  \n    max(q.x * 0.866025 + p.y * 0.5,-p.y) - h.x * 0.5); \n}\n\nfloat torus(vec3 p,vec2 t) {\n    vec2 q = vec2(length(vec2(p.x,p.z)) - t.x,p.y);\n    return length(q) - t.y; \n}\n\nfloat cylinder(vec3 p,float h,float r) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\nfloat tetrahedron(vec3 p,float h) {\n     vec3 q = abs(p);\n     float y = p.y;\n     float d1 = q.z-max(y,0.);\n     float d2 = max(q.x*.5+y*.5,0.)-min(h,h+y);\n     return length(max(vec2(d1,d2),.005)) + min(max(d1,d2),0.);\n}\n\nfloat octahedron(vec3 p,float s) {\n    p = abs(p);\n\n    float m = p.x + p.y + p.z - s;\n    vec3 q;\n\n    if(3.0 * p.x < m) {\n       q = vec3(p.x,p.y,p.z);  \n    } else if(3.0 * p.y < m) {\n       q = vec3(p.y,p.z,p.x); \n    } else if(3.0 * p.z < m) { \n       q = vec3(p.z,p.x,p.y);\n    } else { \n       return m * 0.57735027;\n    }\n\n    float k = clamp(0.5 *(q.z-q.y+s),0.0,s);\n    return length(vec3(q.x,q.y-s+k,q.z - k)); \n}\n\nfloat box(vec3 p,vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sa(vec3 p,vec2 c,float ra) {\n    vec2 q = vec2(length(p.xy),p.z);\n    float l = length(q) - ra;\n    float m = length(q - c * clamp(dot(q,c),0.,ra));\n    return max(l,m * sign(q.x * c.y - q.y * c.x));\n}\n\nvec2 scene(vec3 p) { \n\nvec2 res = vec2(1.0,0.0);\nvec3 q = p;\n\nfloat b;\nb = box(q-vec3(3.,1.,-6.),vec3(1.));\nres = opu(res,vec2(b,2.));\n\nres = opu(res,vec2(sphere(q-vec3(-6.,2.,3.),2.),39.453));\n\nres = opu(res,vec2(\ncapsule(q-vec3(-7.,.5,.9)\n,vec3(-2.,3.,-1.),vec3(0.),.5),225.9));\n\nres = opu(res,vec2(torus(q.yzx-vec3(1.5,-3.5,-5.5),vec2(1.,.5)),12.6));\nres = opu(res,vec2(tetrahedron(q-vec3(-3.,.1,-5.),.75),75.67));\nres = opu(res,vec2(octahedron(q-vec3(-.75,1.,-5.1),1.),100.1));\nres = opu(res,vec2(cylinder(q-vec3(-5.,1.,-1.),.5,.25),64.364));\nres = opu(res,vec2(prism(q-vec3(-5.5,1.,-2.),vec2(1.,.25)),124.5));\n\np.xz *= rot(-.5+easeOut3(sin(.5*t)*.25)+1.25);\nvec3 n = p;\nn.zy *= rot(-2.5);\n\nfloat sc = sa(n,vec2(.6,.8),1.);\nres = opu(res,vec2(sc,5.));\n\nres = opu(res,vec2(p.y,1.));\n\nreturn res;\n\n\n}\n\nvec2 trace(vec3 ro,vec3 rd) {\n    \n    float d = -1.0;\n    float s = 0.;\n    float e = 16.;  \n\n    for(int i = 0; i < 75; i++) {\n\n        vec3 p = ro + s * rd;\n        vec2 dist = scene(p);\n   \n        if(dist.x < EPS || e <  dist.x ) { break; }\n        s += dist.x;\n        d = dist.y;\n\n        }\n \n        if(e < s) { d = -1.0; }\n        return vec2(s,d);\n\n}\n\nfloat shadow(vec3 ro,vec3 rd ) {\n\n    float res = 1.0;\n    float t = 0.005;\n    float ph = 1e10;\n    \n    for(int i = 0; i < 125; i++ ) {\n        \n        float h = scene(ro + rd * t  ).x;\n\n        float y = h * h / (2. * ph);\n        float d = sqrt(h*h-y*y);         \n        res = min(res,100. * d/max(0.,t-y));\n        ph = h;\n        t += h;\n    \n        if(res < .01 || t > 10.) { break; }\n\n        }\n\n        return clamp(res,0.0,1.0);\n\n}\n\nvec3 calcNormal(vec3 p) {\n\n    vec2 e = vec2(1.0,-1.0) * EPS;\n\n    return normalize(vec3(\n    vec3(e.x,e.y,e.y) * scene(p + vec3(e.x,e.y,e.y)).x +\n    vec3(e.y,e.x,e.y) * scene(p + vec3(e.y,e.x,e.y)).x +\n    vec3(e.y,e.y,e.x) * scene(p + vec3(e.y,e.y,e.x)).x + \n    vec3(e.x,e.x,e.x) * scene(p + vec3(e.x,e.x,e.x)).x\n\n    ));\n    \n}\n\nvec3 render(inout vec3 ro,inout vec3 rd,inout vec3 ref) {\n\n    vec2 d = trace(ro, rd);\n    vec3 p = ro + rd * d.x;\n    vec3 n = calcNormal(p);\n    vec3 linear = vec3(0.);\n    vec3 r = reflect(rd,n); \n    float amb = sqrt(clamp(.5+.5*n.x,0.,1.));\n    float fre = pow(clamp(1.+dot(n,rd),0.,1.),2.);\n    vec3 bcol = vec3(1.3);\n    vec3 col = bcol * max(1.,rd.y);\n\n    vec3 l = normalize(vec3(25.,3.,-35.));\n\n    float rad = dot(rd,l);\n    col += col * vec3(.5,.7,.5) * expStep(rad,100.);\n    col += col * vec3(.5,.1,.15) * expStep(rad,125.);\n    col += col * vec3(.1,.5,.05) * expStep(rad,25.);\n    col += col * vec3(.15) * expStep(rad,35.);\n\n    vec3 h = normalize(l - rd);  \n    float dif = clamp(dot(n,l),0.0,1.0);\n    float spe = pow(clamp(dot(n,h),0.0,1.0),16.)\n    * dif * (.04 + 0.9 * pow(clamp(1. + dot(h,rd),0.,1.),5.));\n\n    if(d.y >= 0.) {\n        \n        col = .5+.5*sin(2.*d.y+vec3(6.*h11(5.),2.,3.));\n\n        dif *= shadow(p,l);\n\n        linear += dif * vec3(1.9);\n        linear += amb * vec3(0.5);\n        linear += fre * vec3(.25,.1,.03);\n        linear += spe * vec3(0.04,0.05,.05);\n\n        if(d.y == 5.) {\n            col = vec3(.5);\n            ref = vec3(.5);\n            //rd = r;                 \n        }\n\n        if(d.y == 1.) {\n            col = vec3(checkerboard(p,1.))*vec3(1.,.5,.25);\n            ref = vec3(.5);\n        }\n\n        rd = r;\n\n        col = col * linear;\n        col = mix(col,bcol,1.-exp(-.001*d.x*d.x*d.x));\n\n}\n\nreturn col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) { \nvec3 color = vec3(0.);\n\nvec3 ta = vec3(0.);\nvec3 ro = vec3(-2.,2.,-1.3);\n\nfor(int k = 0; k < AA; k++ ) {\n   for(int l = 0; l < AA; l++) {\n   \n       vec2 o = vec2(float(k),float(l)) / float(AA) * .5;\n       vec2 uv = (2.* (fragCoord.xy+o) - \n       iResolution.xy)/iResolution.y;\n\n       vec3 rd = rayCamDir(uv,ro,ta,2.); \n       vec3 ref = vec3(0.);\n       vec3 col = render(ro,rd,ref);       \n       vec3 c = vec3(.5);\n       col += c * render(ro,rd,ref);\n       col = pow(col,vec3(.4545));\n       color += col;\n   }\n}\n   \n   color /= float(AA*AA);\n   fragColor = vec4(color,1.0);\n \n\n}\n","name":"Image","description":"","type":"image"}]}