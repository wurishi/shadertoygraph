{"ver":"0.1","info":{"id":"WdlSRX","date":"1551796362","viewed":403,"name":"Checkerboard 1","username":"OliverSchaff","description":"Irregular checkerboard pattern with circles.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["2d","grid","warping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This shader by vug is very similar and served as inspiration: \n// https://www.shadertoy.com/view/Xs2GDd\n\n#define PI 3.14159265\n\n// number of tiles in y direction\nconst float numOfTilesY = 5.0;\n    \n// palette by Inigo Quilez\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 color(float c) {\n// 0.0 < c < 1.0 covers the full palette\n    return pal( c, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat vnoise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // aa is used in smoothstep for antialiasing. It scales with the number of tiles\n    // and with iResolution.\n    float aa = 3.0/min(iResolution.x, iResolution.y)*numOfTilesY;\n\n    // distort the uv plane with a shift per pixel\n    // the noise has to be scaled by the number of tiles\n    float noise = 2.0*PI*vnoise(.5*numOfTilesY*uv+0.2*iTime);\n    vec2 shift = .1/(numOfTilesY) * vec2(cos(noise), sin(noise));\n    uv += shift;\n\n    // tile the image\n    uv *= numOfTilesY;\n    vec2 fuv = fract(uv); // fractional part within tile, runs from 0-1\n    vec2 iuv = floor(uv); // integer-part index vector of tile\n    \n    // distance function to the edges of the tiles, based on the fractional part\n    // later it will be used as a basis for drawing different sized disks\n    vec2 dist = 1.0-2.0*abs(fuv);\n    \n    // background color\n    vec3 col = vec3(0.);\n    \n    // parameters for moving two layers of disks around, using the integer part of the tiles for randomness\n    float phase1 = 10.0*random(iuv);\n\tvec2 shapeShift1 = 0.2*vec2(cos(iTime+phase1),sin(iTime+phase1));\n    float phase2 = -4.3*random(iuv);\n\tvec2 shapeShift2 = 0.3*vec2(cos(2.*iTime+phase2),sin(iTime+phase2));\n    \n    // first layer of disks, fixed in the local uv coordinate system of the tile\n    // colors are controlled by the integer index of the tiles.\n    col = mix (color(iuv.y/numOfTilesY+0.1).xyz, col , 1.0-smoothstep(0.1, 0.1+aa, 1.0-length(dist)));\n    // second layer of disks, moving around by shapeShift1\n    col = mix (color(0.4*iuv.x/numOfTilesY+0.1).xyz, col , 1.0-smoothstep(0.4, 0.4+aa, 1.0-length(dist+shapeShift1)));\n    // third layer of disks, moving around with shapeshift2\n    col = mix (color(0.5*(iuv.x+iuv.y)/numOfTilesY+0.2).xyz, col , 1.0-smoothstep(0.6, 0.6+aa, 1.0-length(dist+shapeShift2)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}