{"ver":"0.1","info":{"id":"sssXWH","date":"1618604374","viewed":212,"name":"Basic : Simple Atmosphere","username":"Gijs","description":"The most simple-but-still-physical not-hard-coded atmosphere I could come up with. Try changing the scattering coefficients :).","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["atmosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float SKY_HEIGHT = 0.1;\nvec3  SUN_COLOR = vec3(1,1,1);\nvec3  SKY_SCATTERING = vec3(0.1, 0.3, 0.7);\nvec3  SUN_VECTOR;\nfloat SUN_ANGULAR_DIAMETER = 0.08;\n\n#define PI 3.1415926535\n\nfloat atmosphereDepth(vec3 dir)\n{\n    return SKY_HEIGHT/ max(dir.y, 0.0);\n}\n\nvec3 transmittance(vec3 dir)\n{\n    return exp(-atmosphereDepth(dir) * SKY_SCATTERING);\n}\n\nvec3 simple_sun(vec3 dir)\n{\n    float a = acos(dot(dir, SUN_VECTOR));\n    float t = 0.005;\n    float e = smoothstep(SUN_ANGULAR_DIAMETER*0.5 + t, SUN_ANGULAR_DIAMETER*0.5, a);\n    return SUN_COLOR * e;\n}\n\nvec3 simple_sky(vec3 d)\n{\n    vec3 result = mix(\n        simple_sun(SUN_VECTOR) * transmittance(SUN_VECTOR), \n        simple_sun(d),\n        transmittance(d)\n    );\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    SUN_VECTOR = normalize(vec3(0, sin(iTime*.5)*.5 + .5, 1));  \n    \n  \tvec3 cameraForward  = texelFetch(iChannel0,ivec2(1,0),0).rgb;\n    vec3 cameraRight    = texelFetch(iChannel0,ivec2(2,0),0).rgb;\n    vec3 cameraUpward   = texelFetch(iChannel0,ivec2(3,0),0).rgb;\n    \n    float minResolution = min(iResolution.x,iResolution.y);\n\n    vec2 p = fragCoord;\n    vec2 sp  = (p*2.-iResolution.xy)/minResolution*0.5;\n     \n\tvec3 dir = normalize(sp.x*cameraRight + sp.y*cameraUpward + cameraForward);\n\n    fragColor = vec4(simple_sky(dir), 1.0);\n    fragColor = pow(fragColor, vec4(1.0/2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//This buffer handles the Camera\n//if ANY movement is done fragColor.w becomes 1 for ALL pixels\n\nconst float CAMERA_SENSITIVITY      = 0.003;\nconst float CAMERA_ROLL_SENSITIVITY = 1.;\n\n//makes sure that three 3 dimensional vectors are orthonormal\nvoid GramSchmidt33(inout vec3 a, inout vec3 b, inout vec3 c){\n    a = normalize(a);\n    b = b - dot(b,a)*a;\n    b = normalize(b);\n    c = c - dot(c,a)*a - dot(c,b)*b;\n    c = normalize(c);\n}\n\nvoid rot(inout vec3 a, inout vec3 b, float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    vec3 na =  c*a + s*b;\n    vec3 nb = -s*a + c*b;\n    a = na;\n    b = nb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    ivec2 p = ivec2(fragCoord);\n    \n    if(p.x>4 || p.y > 0) return;\n    \n  \tvec3 cameraForward  = texelFetch(iChannel0,ivec2(1,0),0).rgb;\n    vec3 cameraRight    = texelFetch(iChannel0,ivec2(2,0),0).rgb;\n    vec3 cameraUpward   = texelFetch(iChannel0,ivec2(3,0),0).rgb;\n    vec3 mouseOld       = texelFetch(iChannel0,ivec2(4,0),0).rgb;\n    \n    if(iFrame==0){\n        cameraForward   = normalize(vec3(0,0.4,1));\n        cameraRight     = normalize(cross(vec3( 0, 1, 0),cameraForward));\n        cameraUpward    = normalize(cross(cameraForward,cameraRight));\n        mouseOld        = vec3(iMouse.xy, 0);\n    } \t\t\n    \n    bool rollleft    = texelFetch(iChannel1,ivec2(81,0),0).x > 0.;\n    bool rollright   = texelFetch(iChannel1,ivec2(69,0),0).x > 0.;\n    bool mouseLeft   = iMouse.z>0.;\n    bool interaction = rollleft||rollright||mouseLeft;\n    \n    //Roll\n    float r = (float(rollleft)-float(rollright))*iTimeDelta*CAMERA_ROLL_SENSITIVITY;\n    rot(cameraRight, cameraUpward , r);\n    \n    //Pitch & Yaw\n    if(mouseLeft){\n        if(mouseOld.z==0.){\n            mouseOld.xy = iMouse.zw;\n            mouseOld.z = 1.;\n        }\n\t\tvec2 s = iMouse.xy-mouseOld.xy;\n        rot(cameraForward, cameraUpward, s.y*CAMERA_SENSITIVITY);\n        rot(cameraForward, cameraRight , s.x*CAMERA_SENSITIVITY);\n    }else{\n    \tmouseOld.z = 0.;   \n    }\n    \n    //Make sure this triple is orthonormal\n    GramSchmidt33(cameraForward, cameraUpward, cameraRight);\n    \n    if(p.x==1){\n        fragColor.rgb = cameraForward;\n    }else if(p.x==2){\n        fragColor.rgb = cameraRight;\n    }else if(p.x==3){\n        fragColor.rgb = cameraUpward;\n    }else if(p.x==4){\n        fragColor.rgb = vec3(iMouse.xy, mouseOld.z);\n    }\n    \n    fragColor.w = float(interaction);\n}","name":"Buffer A","description":"","type":"buffer"}]}