{"ver":"0.1","info":{"id":"wlsfRj","date":"1597315222","viewed":159,"name":"Noise Island","username":"greenstonedt","description":"Got inspried by this post https://www.reddit.com/r/proceduralgeneration/comments/i756qa/how_to_procedurally_generate_maps_using_layered/, I translated the code into Shadertoy for further reference.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* https://www.shadertoy.com/view/XsX3zB\n *\n * The MIT License\n * Copyright Â© 2013 Nikita Miropolskiy\n * \n * ( license has been changed from CCA-NC-SA 3.0 to MIT\n *\n *   but thanks for attributing your source code when deriving from this sample \n *   with a following link: https://www.shadertoy.com/view/XsX3zB )\n *\n * ~\n * ~ if you're looking for procedural noise implementation examples you might \n * ~ also want to look at the following shaders:\n * ~ \n * ~ Noise Lab shader by candycat: https://www.shadertoy.com/view/4sc3z2\n * ~\n * ~ Noise shaders by iq:\n * ~     Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n * ~     Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n * ~     Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n * ~     Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n * ~     Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n * ~     Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n * ~     Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n * ~     Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n * ~     Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n * ~     Voronoise: https://www.shadertoy.com/view/Xd23Dh\n * ~ \n *\n */\nvec2 hash( vec2 p ) {  \t\t\t\t\t\t// rand in [-1,1]\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn -1. + 2.*fract(sin(p+20.)*53758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor(p), f = fract(p);\n\tvec2 u = f*f*(3.-2.*f);\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\n}\n\n#define HASHSCALE 0.1031\nfloat hash1D(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat fade(float t) { return t*t*t*(t*(6.*t-15.)+10.); }\n\nfloat grad(float hash, float p)\n{\n    int i = int(1e4*hash);\n\treturn (i & 1) == 0 ? p : -p;\n}\n\nfloat perlinNoise1D(float p)\n{\n\tfloat pi = floor(p), pf = p - pi, w = fade(pf);\n    return mix(grad(hash1D(pi), pf), grad(hash1D(pi + 1.0), pf - 1.0), w) * 2.0;\n}\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n//////////////////////////////////////////////\nfloat map( float value, float low, float high, float destLow, float destHigh ) {\n    return destLow + (value - low) * (destHigh - destLow) / (high - low);\n}\n//////////////////////////////////////////////\n// TODO:\n// Add biodome\n\n\n#define ZOOM_VALUE_1 0.05\n#define SEED 10313.8125\n#define NOISE_MAP_COUNT 5\n#define OFFSET vec2(35.0, 32.0)\n\nfloat FREQUENCIES [NOISE_MAP_COUNT] \t= float [NOISE_MAP_COUNT](0.14,\t\t0.72,\t\t2.15,\t\t6.0,\t\t0.1);\nfloat AMPLITUDE [NOISE_MAP_COUNT] \t\t= float [NOISE_MAP_COUNT](1.1,\t\t-0.35,\t\t0.18,\t\t0.05,\t\t-0.67);\nfloat OFFSETX [NOISE_MAP_COUNT] \t\t= float [NOISE_MAP_COUNT](0.0,\t\t1054.0,\t\t-2525.0,\t5656.0,\t\t-852.0);\nfloat OFFSETY [NOISE_MAP_COUNT] \t\t= float [NOISE_MAP_COUNT](0.0,\t\t655.0,\t\t-781.0,\t\t4324.0,\t\t989.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy * ZOOM_VALUE_1 + iMouse.xy + SEED + OFFSET;\n    \n    float h = 0.0;\n    for (int i =0; i < NOISE_MAP_COUNT; i++) {\n        h += noise( vec2(pos.x * FREQUENCIES[i] + OFFSETX[i], pos.y * FREQUENCIES[i] + OFFSETY[i])) * AMPLITUDE[i];\n    }\n    float checkingH = h;\n    vec2 offsetCoord = pos + fragCoord.xy + vec2(1.3, 0.8) * iTime + SEED + iMouse.xy;\n    if (checkingH < 0.244) {\n        float hMap1 = simplex3d(vec3(offsetCoord * 0.001 * 4.0, iTime * 0.1)) * -0.7;\n        float hMap2 = simplex3d(vec3(offsetCoord * 0.04 * 4.0, iTime / 1000.0 * 0.0));\n        h = (hMap1 + hMap2) * 0.41;\n    } else if (checkingH < 0.339) {\n        float hMap = simplex3d(vec3(offsetCoord * 0.002 * 2.0, iTime * 0.3)) * 0.1;\n        h = checkingH + hMap;\n    }\n    if (h < 0.41 && h > 0.339 && checkingH >= 0.224) {\n        float hMap = simplex3d(vec3(offsetCoord * 0.00001 * 2.0, iTime * 0.19)) * 0.02;\n        h = checkingH + hMap * 0.71;\n    }\n    \n    vec4 color = vec4(1.0);\n    if (h < 0.244) color = vec4(0.24, 0.27, 0.49, 1.0);\n    else if (h < 0.339) color = vec4(0.31, 0.46, 0.72, 1.0);\n    else if (h < 0.41) color = vec4(0.56, 0.87, 0.98, 1.0);\n    else if (h < 0.45) color = vec4(0.98, 0.87, 0.72, 1.0);\n    else if (h < 0.474) color = vec4(0.83, 0.67, 0.58, 1.0);\n    else if (h < 0.81) color = vec4(0.37, 0.50, 0.41, 1.0);\n    else if (h < 0.885) color = vec4(0.82, 0.82, 0.82, 1.0);\n        \n    vec2 cloudOffsetCoord = pos + fragCoord.xy + vec2(5.0, -3.14) * iTime + SEED + iMouse.xy;\n    float cloudMap1 = simplex3d(vec3(cloudOffsetCoord * 0.01 * 0.5, iTime * 0.02)) * 1.0;\n    float cloudMap2 = simplex3d(vec3(cloudOffsetCoord * -0.1 * 0.5, iTime * 0.1)) * -0.1;\n    float cloudMap = clamp(cloudMap1 + cloudMap2, 0.0, 1.0);\n        \n   \tvec4 cloudColor = vec4(0.3, 0.3, 0.3, 0.43);\n    if (cloudMap < 0.31) cloudColor = vec4(1.0, 1.0, 1.0, 0.0);\n    else if (cloudMap < 0.48) cloudColor = vec4(1.00, 1.00, 1.00, 0.12);\n    else if (cloudMap < 0.75) cloudColor = vec4(0.57, 0.57, 0.57, 0.25);\n        \n    vec3 finalColor = cloudColor.xyz * cloudColor.w + color.xyz * (1.0 - cloudColor.w);\n        \n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}