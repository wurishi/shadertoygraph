{"ver":"0.1","info":{"id":"Ntf3WS","date":"1622683124","viewed":129,"name":"Worley Noise 3D __","username":"Envy24","description":"noise, random, worley, cellular","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","random","worley","cellular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* playlist: https://www.shadertoy.com/playlist/sXfSDS */\n\n/*\n    Returns hash in range [0.0; 1.0].\n*/\nfloat sample3DHashUI32(uint x, uint y, uint z)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint enthropy0 = 1200u;\n    const uint enthropy1 = 4500u;\n    const uint enthropy2 = 6700u;\n    const uint enthropy3 = 8900u;\n\n    // Use linear offset method to mix coordinates.\n    uint value = \n        z * enthropy3 * enthropy2 +\n        y * enthropy2 +\n        x;\n\n    // Calculate hash.\n\tvalue += enthropy1;\n\tvalue *= 445593459u;\n\tvalue ^= enthropy0;\n\n    // 1.0f / 4294967295.0f = 2.32830644e-10\n\n    return float(value * value * value) * 2.32830644e-10;\n}\n\nfloat WorleyNoise3D(float u, float v, float w)\n{\n    // Fractial part.\n    float fractU = u - floor(u);\n    float fractV = v - floor(v);\n    float fractW = w - floor(w);\n\n    // Integer part.\n    u = floor(u);\n    v = floor(v);\n    w = floor(w);\n\n    float minDistance = 3.40282347e+37f; // FL_MAX = 3.40282347e+38f\n\n    for (float z = -1.0f; z < 2.0f; z += 1.0f)\n    {\n        for (float y = -1.0f; y < 2.0f; y += 1.0f)\n        {\n            for (float x = -1.0f; x < 2.0f; x += 1.0f)\n            {\n                // Pseudorandom sample coordinates in corresponding cell.\n                float xSample = x + sample3DHashUI32(uint(u + x), uint(v + y), uint(w + z));\n                float ySample = y + sample3DHashUI32(uint(u + x), uint(v + y), uint(w + z));\n                float zSample = z + sample3DHashUI32(uint(u + x), uint(v + y), uint(w + z));\n\n                // Distance from pixel to pseudorandom sample.\n                //float distance = \n                    //sqrt(\n                        //(fractU - xSample) * (fractU - xSample) +\n                        //(fractV - ySample) * (fractV - ySample) +\n                        //(fractW - zSample) * (fractW - zSample));\n                        \n                float distance = \n                        (fractU - xSample) * (fractU - xSample) +\n                        (fractV - ySample) * (fractV - ySample) +\n                        (fractW - zSample) * (fractW - zSample);\n\n                // Mistance from pixel to pseudorandom sample.\n                minDistance = min(minDistance, distance);\n            }\n        }\n    }\n\n    return minDistance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv;\n    \n    if (fragCoord.x < iResolution.x * 0.5) { uv = fragCoord/iResolution.xy * 6.0f; }\n    else { uv = fragCoord/iResolution.xy * 18.0f; }\n\n    float _u = uv.x + iMouse.x * 0.1f;\n    float _v = uv.y + iMouse.y * 0.1f;\n    float _w = uv.x + iMouse.y * 0.1f + iTime * 0.2f;\n\n    float gray = WorleyNoise3D(_u, _v, _w) * 0.5f;\n    gray += WorleyNoise3D(_u * 2.054f, _v * 2.210f,  _w * 2.210f) * 0.055f;\n    gray += WorleyNoise3D(_u * 4.554f, _v * 4.710f,  _w * 2.210f) * 0.0325f;\n\n    // Output to screen\n    fragColor = vec4(vec3(gray),1.0);\n}","name":"Image","description":"","type":"image"}]}