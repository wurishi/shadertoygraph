{"ver":"0.1","info":{"id":"NtKfWV","date":"1668643722","viewed":76,"name":"GPT-3 A slightly better sphere","username":"sferrando","description":"prompt:\n\nwrite a shadertoy code that renders a white point light and a specular sphere that reflects some of the light.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["gpt3"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//calculate the closest point of intersection between the ray and the sphere\nvec3 intersectSphere(vec3 rayOrigin, vec3 rayDirection, vec3 spherePosition, float sphereRadius)\n{\n    vec3 m = rayOrigin - spherePosition;\n    float b = dot(m, rayDirection);\n    float c = dot(m, m) - sphereRadius*sphereRadius;\n    \n    //if there is no intersection, return a vec3 of 0's\n    if (c > 0.0 && b > 0.0)\n        return vec3(0.0, 0.0, 0.0);\n    \n    float discriminant = b*b - c;\n    \n    //if the discriminant is negative, there is no real root\n    //and therefore no intersection\n    if (discriminant < 0.0)\n        return vec3(0.0, 0.0, 0.0);\n    \n    //calculate the two roots of the quadratic equation\n    float t1 = -b - sqrt(discriminant);\n    float t2 = -b + sqrt(discriminant);\n    \n    //if t1 is less than 0, the intersection point is at t2\n    if (t1 < 0.0)\n        return rayOrigin + t2*rayDirection;\n    \n    //if t2 is less than 0, the intersection point is at t1\n    if (t2 < 0.0)\n        return rayOrigin + t1*rayDirection;\n    \n    //if both t1 and t2 are positive, the intersection point is at the smaller value of t1 and t2\n    return rayOrigin + min(t1, t2)*rayDirection;\n}\n\n//calculate the normal at the point of intersection\nvec3 getSphereNormal(vec3 point, vec3 spherePosition, float sphereRadius)\n{\n    //the normal is simply the normalized vector from the sphere's center to the point of intersection\n    return normalize(point - spherePosition);\n}\n\n//calculate the diffuse color at the point of intersection\nvec3 getDiffuse(vec3 normal, vec3 lightPosition, vec3 rayOrigin, vec3 point)\n{\n    //the diffuse color is simply the diffuse reflection coefficient times the light's color\n    float diffuseReflectionCoefficient = max(0.0, dot(normal, lightPosition - point));\n    return diffuseReflectionCoefficient*vec3(1.0, 1.0, 1.0);\n}\n\n//calculate the specular color at the point of intersection\nvec3 getSpecular(vec3 normal, vec3 lightPosition, vec3 rayOrigin, vec3 point)\n{\n    //the specular color is simply the specular reflection coefficient times the light's color\n    vec3 viewDirection = normalize(rayOrigin - point);\n    vec3 halfVector = normalize(lightPosition - point + viewDirection);\n    float specularReflectionCoefficient = pow(max(0.0, dot(normal, halfVector)), 50.0);\n    return specularReflectionCoefficient*vec3(1.0, 1.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //normalized device coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //the camera is at (0,0,0) looking in the -z direction\n    vec3 rayOrigin = vec3(0.0,0.0,0.0);\n    //the camera is a pinhole camera, so the ray direction is simply the normalized device coordinates\n    vec3 rayDirection = vec3(uv, -1.0);\n    rayDirection = normalize(rayDirection);\n    \n    //the light is a point light at (1.0, 1.0, 1.0)\n    vec3 lightPosition = vec3(3.0, 3.0, 1.0);\n    \n    //the sphere is at (0.0, 0.0, -2.0) with a radius of 0.5\n    vec3 spherePosition = vec3(0.5, 0.5, -2.0);\n    float sphereRadius = 0.5;\n    \n    //calculate the closest point of intersection between the ray and the sphere\n    vec3 closestPoint = intersectSphere(rayOrigin, rayDirection, spherePosition, sphereRadius);\n    \n    //if there is no intersection, simply draw the background color\n    if(closestPoint == vec3(0.0, 0.0, 0.0))\n    {\n        fragColor = vec4(0.0, 0.0, 0.2, 1.0);\n        return;\n    }\n    \n    //calculate the normal at the point of intersection\n    vec3 normal = getSphereNormal(closestPoint, spherePosition, sphereRadius);\n    \n    //calculate the diffuse color at the point of intersection\n    vec3 diffuse = 0.175*getDiffuse(normal, lightPosition, rayOrigin, closestPoint);\n    \n    //calculate the specular color at the point of intersection\n    vec3 specular = getSpecular(normal, lightPosition, rayOrigin, closestPoint);\n    \n    //add ambient light (by me)\n    vec3 ambient = vec3(0.2,0.2,0.2);\n    \n    //draw the pixel as a combination of diffuse and specular color\n    fragColor = vec4(ambient + diffuse + specular, 1.0);\n}","name":"Image","description":"","type":"image"}]}