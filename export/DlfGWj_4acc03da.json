{"ver":"0.1","info":{"id":"DlfGWj","date":"1672727330","viewed":104,"name":"tetrahedron (incomplete)","username":"DjinnKahn","description":"Trying to make a tetrahedron fractal with infinite zooming. Maybe I'll try ray-plane intersections instead of SDFs?\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["fractal","tetrahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FAST_COMPILE 1 // avoid ~2-minute compile time\n\n#if FAST_COMPILE\n#define UNROLL_POLICY min(0,iFrame)\n#else\n#define UNROLL_POLICY 0\n#endif\n\nconst float SCALE_PER_ITERATION = .3;\n\n//vec3 foldTetrahedron( vec3 p )\n//{\n//    //p.xy *= sign( p.x + p.y );\n//    //p.yz *= sign( p.y + p.z );\n//    //p.zx *= sign( p.z + p.x );    \n//    vec3 sgn = vec3( 1., 1., sign( p.x * p.y * p.z ) );\n//    vec3 q = abs(p);\n//    if ( q.x >= q.y ) //xyz xzy zxy\n//    {\n//        if ( q.y >= q.z ) return q.xyz * sgn;\n//        if ( q.x >= q.z ) return q.xzy * sgn;\n//                          return q.zxy * sgn;\n//    } else {          //yxz yzx zyx\n//        if ( q.x >= q.z ) return q.yxz * sgn;\n//        if ( q.y >= q.z ) return q.yzx * sgn;\n//                          return q.zyx * sgn;\n//    }\n//}\n\nmat3 rotation( vec3 u, float angle )\n{\n    float cs = cos( angle );\n    float sn = sin( angle );\n    float k = 1. - cs;\n    return mat3( u.x*u.x*k + cs    , u.y*u.x*k + u.z*sn, u.z*u.x*k - u.y*sn, \n                 u.x*u.y*k - u.z*sn, u.y*u.y*k + cs    , u.z*u.y*k + u.x*sn, \n                 u.x*u.z*k + u.y*sn, u.y*u.z*k - u.x*sn, u.z*u.z*k + cs    );\n}\n\nvec3 foldDoubleTetrahedron( vec3 p )\n{  \n    vec3 q = abs(p);\n    // just sort xyz\n    if ( q.x >= q.y )\n    {\n        if ( q.y >= q.z ) return q.xyz;\n        if ( q.x >= q.z ) return q.xzy;\n                          return q.zxy;\n    } else {\n        if ( q.x >= q.z ) return q.yxz;\n        if ( q.y >= q.z ) return q.yzx;\n                          return q.zyx;\n    }\n}\n\n//// for tetrahedron with vertices (-1,-1,-1),(1,1,-1),(1,-1,1),(-1,1,1)\n//\n//// fold space tetrahedrally -- e.g. (5,6,-3) returns (6,-3,5)\n//vec3 foldTetrahedron( vec3 p )\n//{   \n//    vec3 sgn = vec3( 1., 1., sign( p.x * p.y * p.z ) );\n//    vec3 q = abs(p);\n//    return (q.x >= q.y ? q.y >= q.z ? q.xyz : q.zxy : q.y >= q.z ? q.yzx : q.zxy ) * sgn;\n//}\n\n\n    \n// `p` must be folded (see foldTetrahedron)\n\nfloat sdTetrahedron( vec3 p )\n{\n    float s2 = 1./sqrt(2.);\n    float s3 = 1./sqrt(3.);\n    float s6 = 1./sqrt(6.);  \n    mat4x3 m = mat4x3( vec3(s6*2.,0,s3), vec3(-s6,s2,s3), vec3(s6,s2,-s3), vec3(s6*-2.,0,-s3) );    \n    p = m * vec4( p, 1. );\n        \n    if ( p.x <= 0. ) return p.z;\n    if ( abs(p.y) <= sqrt(2.) ) return length( p.xz );\n    p = abs( p );\n    return length( vec3( p.x, max(p.y-sqrt(2.),0.), p.z ) );\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdFractal( vec3 p )\n{\n    float d = 99999.;\n    //d = min( d, sdSphere( p - vec3(-1,1,-1)/3., .2/.3 ) );    \n    //d = min( d, sdSphere( p - vec3(-2,-1,-2)/3., .2 ) );\n\n\n    //float scale = SCALE_PER_ITERATION;\n    //float scale = 1.;\n    //\n    //for ( int i = 0; i < 5; i++ ) // fractal iterations\n    //{     \n    //    p = foldDoubleTetrahedron( p );\n    //    d = min( d, sdTetrahedron( p ) );\n    //    p = p - (vec3(-1,-1,1)*SCALE_PER_ITERATION + vec3(2,2,1))/3.;\n    //    scale *= SCALE_PER_ITERATION;\n    //}\n\n    float scale = 1.;\n    p = foldDoubleTetrahedron( p );    \n    d = min( d, sdTetrahedron( p ) );    \n    \n    for ( int i = 0; i < 6; i++ ) // fractal iterations\n    {\n        p = p - (vec3(-1,-1,1)*SCALE_PER_ITERATION + vec3(2,2,1))/3.; \n        p /= SCALE_PER_ITERATION;\n        p = foldDoubleTetrahedron( p );\n        scale *= SCALE_PER_ITERATION;\n        d = min( d, sdTetrahedron( p )*scale );\n    }\n\n    return d;\n}\n\nvec3 f( vec3 p )\n{\n    float t = iTime * .4;\n    t -= max( 0., floor( t ) - 1. );\n    \n    ////vec3 center = vec3(-0.80952380952380965,-0.61904761904761907,-0.80952380952380965);\n    //vec3 center = vec3(-0.79719081877355025,-0.67249057896540088,-0.76841384035628779);\n    vec3 center = vec3(0.71702637889682419,0.21822541966445166,-0.50119904076730204);\n    \n    vec3 axis = normalize(vec3(1,-1,-1));\n    \n    p -= center;\n    float scale = pow( SCALE_PER_ITERATION, t );\n    p *= scale;\n    p = rotation( axis, t * 3.141592*2./3. ) * p;\n    p += center;   \n    return p;\n}\n\n\nfloat sdScene( vec3 p )\n{\n    //bool b = fract( iTime ) < .5;\n    //float scale = b ? 1. : SCALE_PER_ITERATION;\n    //vec3 offset0 = b ? vec3( 0. ) : vec3(-1,1,-1)/3.;\n    //vec3 offset1 = b ? vec3( 0. ) : vec3(-2,-1,-2)/3.;\n    //\n    //p = (p-offset0)*scale + offset1;\n    //p = (p-offset0)*scale + offset1;\n    //p = (p-offset0)*scale + offset1;\n    //float d = sdFractal( p ) / scale / scale / scale;\n    //\n    ////d = min( d, sdSphere( p - vec3(-1.,-1.,-1.), .2 ) );\n    ////d = min( d, sdSphere( p - vec3(1.,1.,-1), .2 ) );\n    ////d = min( d, sdSphere( p - vec3(-1,1,1), .2 ) );\n    \n    //p = f( p );\n    \n    \n    //  Matrix4x4 m = Matrix4x4::translation( XYZ( -2, -1, -2 ) / 3. )\n    //     * Matrix4x4::scale( .3 )\n    //     * Matrix4x4::translation( -XYZ( -1, 1, -1 ) / 3. )\n    //     * Matrix4x4::rotation( XYZ(1,1,1), PI*2/3 );\n         \n    //p = rotation( axis, t * 3.141592*2./3. ) * p;\n    \n    //if ( t < .5 )\n    //{\n    //return sdFractal( p );\n    //}\n    //\n    //p += -vec3( -1, 1, -1 ) / 3.;\n    //p *= .3;\n    //p += vec3( -2, -1, -2 ) / 3.;    \n    \n    float d = sdFractal( p );// / scale;\n    \n    return d;\n}\n\n// from iq\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    int objectId = -1;\n    vec3 texturePos;\n    return normalize( k.xyy*sdScene( p + k.xyy*h ) + \n                      k.yyx*sdScene( p + k.yyx*h ) + \n                      k.yxy*sdScene( p + k.yxy*h ) + \n                      k.xxx*sdScene( p + k.xxx*h ) );\n}\n\nmat2 rot( float a )\n{\n    return mat2( cos(a), sin(a), -sin(a), cos(a) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2. - iResolution.xy)/iResolution.y;\n\n    \n    \n    vec3 pos = vec3(0.0001,0.0002,-5.5);\n    vec3 ray = normalize(vec3(uv.x,uv.y,3.));\n    \n    pos = f( pos );\n    ray = f( ray ) - f( vec3(0.) );\n    pos += ray*4.;\n    \n    //float t = iTime*0.;\n    //pos.xz = rot( t ) * pos.xz;\n    //ray.xz = rot( t ) * ray.xz;\n    //pos.yz = rot( sin( t*.15 )*.5 ) * pos.yz;\n    //ray.yz = rot( sin( t*.15 )*.5 ) * ray.yz;\n    \n    vec3 light0 = normalize(vec3( 1., .2, 1. ));\n    light0 = normalize( f( light0 ) - f( vec3(0.) ) );\n    \n    fragColor = vec4(vec3(.3),1.0);\n    \n    for ( int i = 0; i < 500 + UNROLL_POLICY; i++ )\n    {\n        float d = sdScene( pos );\n        pos += ray * d;\n        if ( length( pos ) > 10. ) break;\n        if ( d < 0.00001 )\n        {\n            vec3 n = calcNormal( pos );\n            //float col = max( dot( light0, -n ), 0. );\n            float col = dot( light0, -n ) * .5 + .5;\n            fragColor = vec4( vec3( col ), 1. );\n            fragColor.r += pos.z*.1;\n            break;\n        }\n    }\n       \n\n}\n\n","name":"Image","description":"","type":"image"}]}