{"ver":"0.1","info":{"id":"lXscR2","date":"1726462942","viewed":38,"name":"Raymarched Solids","username":"andydevs","description":"Platonic Solids but raymarched.\n\nInspired by kishimisu.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589\n\nfloat cameraVelocity = 1.25;\nint maxSteps = 200;\nfloat minDistance = 0.00001;\nfloat farClippingPlane = 100.0;\nfloat shapeRadius = 0.25;\nfloat focalLength = 5.0;\n\n\nmat2 rot2D(float a) {\n    return mat2(cos(a), -sin(a), \n                sin(a), cos(a));\n}\n\nfloat sdCube(vec3 p, float r) {\n    vec3 faces[] = vec3[](\n        vec3(1.,0.,0.),\n        vec3(0.,1.,0.),    \n        vec3(0.,0.,1.),\n        vec3(-1.,0.,0.),\n        vec3(0.,-1.,0.),    \n        vec3(0.,0.,-1.)\n    );\n    float d = dot(p, faces[0]);\n    for(int i=1;i<faces.length();++i){\n        d = max(d, dot(p, faces[i]));\n    }\n    return d - r/2.;\n}\n\n\nfloat sdPyramid(vec3 p, float r) {\n    float r3 = sqrt(3.);\n    vec3 faces[] = vec3[](\n        vec3( 0., -1.,  0.),\n        vec3( 0., .5,  .5*r3),\n        vec3( 0., .5, -.5*r3),\n        vec3( .5*r3, .5,   0.),\n        vec3(-.5*r3, .5,   0.)\n    );\n    float d = dot(p, faces[0]);\n    for(int i=1;i<faces.length();++i){\n        d = max(d, dot(p, faces[i]));\n    }\n    return d - r/r3/2.;\n}\n\nfloat sdTetrahedron(vec3 p, float r) {\n    float ir3 = sqrt(3.)/3.;\n    vec3 faces[] = vec3[](\n        vec3(  ir3,  ir3,  ir3),\n        vec3(  ir3, -ir3, -ir3),\n        vec3( -ir3,  ir3, -ir3),\n        vec3( -ir3, -ir3,  ir3)\n    );\n    float d = dot(p, faces[0]);\n    for(int i=1;i<faces.length();++i){\n        d = max(d, dot(p, faces[i]));\n    }\n    return d - r*ir3/2.;\n}\n\nfloat sdOctahedron( vec3 p, float s )\n{\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sd(vec3 p) {\n    // Tiling box\n    vec3 box = vec3(2., 2., 1.);\n    box += vec3(.1*sin(iTime/5.), .2*sin(iTime/7.), 0.0);\n    \n    // Get relative point within box\n    vec3 q = mod(p, box) - box / 2.;\n    q.xy = rot2D(iTime/2.0)*q.xy;\n    q.yz = rot2D(iTime/3.0)*q.yz;\n    \n    // Not Sphere\n    switch ( int(p.z / box.z) % 4 ) {\n        case 3:\n            return sdOctahedron(q, shapeRadius);\n        case 2:\n            return sdCube(q, shapeRadius);\n        case 1:\n            return sdPyramid(q, shapeRadius);\n        default:\n            return sdTetrahedron(q, shapeRadius);\n    }\n}\n\nvec3 mapToColor(float t) {\n    vec3 freqs = vec3(0.75, 1.15, -0.75);\n    vec3 phases = vec3(0, 1.2, 4.0);\n    return 0.5*(1.0 + cos(2. * PI * freqs * t + phases));\n}\n\nvec3 mapToColorD(float t) {    \n    return vec3(1.,1.,1.)*t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float glowStrength = 0.05*sin(iTime/11.0) + 0.1;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    float scale = min(iResolution.x, iResolution.y);\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / scale;\n    \n    vec3 cameraOrigin = vec3(0.0, 0.0, iTime * cameraVelocity - 1.0);\n    \n    int steps;\n    bool collision = false;\n    vec3 rayDir = normalize(vec3(uv.xy, focalLength));\n    vec3 p = cameraOrigin;\n    float t = 0.0;\n    float d;\n    float md = 1e12;\n    \n    for (steps = 0; steps < maxSteps; ++steps) {\n        // Transform p\n        p.y += sin(t * sin(iTime/11.0)) * .134;\n        p.x += sin(t * sin(iTime/13.0)) * .112;\n        p.xy *= rot2D(t * sin(iTime / 17.0) * .125);\n        \n        // Update\n        d = sd(p);\n        md = min(md, d);\n        t += d;\n        p = t*rayDir + cameraOrigin;\n        \n        // Exit\n        if (d <= minDistance) {\n            collision = true;\n            break;\n        }\n        if ((p - cameraOrigin).z >= farClippingPlane) {\n            break;\n        }\n    }\n\n    // Calculate pixel color\n    float zRatio = (p - cameraOrigin).z/farClippingPlane;\n    float xyRatio = length((p - cameraOrigin).xy)/farClippingPlane;\n    float distRatio = length(p - cameraOrigin)/farClippingPlane;\n    \n    float param = 3.*zRatio - 1.*xyRatio - (1./43.)*iTime;\n    vec3 color;\n    if (collision) {\n        float e = 0.0001;\n        vec3 normal = normalize(vec3(\n            sd(p + vec3(e , 0., 0.)) - sd(p),\n            sd(p + vec3(0., e , 0.)) - sd(p),\n            sd(p + vec3(0., 0., e )) - sd(p)\n        ));\n        color = mapToColor(param);\n        color *= (1. - 0.2 * dot(normal, -rayDir));\n        color *= exp(-0.8*distRatio);\n    }\n    else {\n        color = vec3(0.) + 0.02*mapToColor(-param) / md;\n    }\n\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}