{"ver":"0.1","info":{"id":"wtKfDW","date":"1639367038","viewed":61,"name":"d - RayMarching::Other shapes","username":"francislarge","description":"Raymarching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"WtVfDW","parentname":"c - Raymarching::Materials"},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct FHitResult\n{\n    bool bWasAHit;\n    float Distance;\n    int ClosestObject_ID;\n    vec3 HitLocation;\n    vec3 HitNormal;\n    vec3 RayDirection;\n};\n\nconst int SPHERE = 1, \n          PLANE  = 2, \n          GROUND_PLANE = 3, \n          CUBE = 5, \n          CAPSULE = 6, \n          TORUS = 7, \n          NONE = 0;\n\nconst int POINT_LIGHT = 100, DIRECTIONAL_LIGHT = 200, AMBIENT_LIGHT = 300;\nstruct Light\n{\n    int   Type;\n    vec3  Position;   //for point light\n    vec3  Direction; //for directional light\n    float Intensity;\n    float ConeOpening; //for spot light\n    float Blend; //for spot light\n};\n\nconst int   MAX_STEPS = 100;\nconst float MAX_DISTANCE = 100.0;\nconst float SURFACE_DISTANCE = 0.01;\nconst int   TOTAL_SCENE_OBJECTS = 6;\nconst int   TOTAL_SCENE_LIGHTS  = 5;\n\n\nvoid  AddObjectToScene(out Object SceneObjects[TOTAL_SCENE_OBJECTS], Object ObjectToAdd, out int ObjectsCount);\nvec3  CalculateNormal(vec3 HitPosition,  out Object SceneObjects[TOTAL_SCENE_OBJECTS], int ObjectsCount);\nfloat CapsuleSDF(out Object Capsule, vec3 RayPosition);\nfloat SceneSDF(vec3 RayCurrentPosition,  out Object SceneObjects[TOTAL_SCENE_OBJECTS], int ObjectsCount, out int ClosestObject_ID);\nFHitResult RayMarch(vec3 RO, vec3 RD,    out Object SceneObjects[TOTAL_SCENE_OBJECTS], int ObjectsCount);\n\nvec3 CalculateLighting(Light SceneLights[TOTAL_SCENE_LIGHTS], int LightCount, out Object SceneObjects[TOTAL_SCENE_OBJECTS], out FHitResult HitResult );\nvoid AddLightToScene(out Light SceneLights[TOTAL_SCENE_LIGHTS], Light LightToAdd, out int LightsCount);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 RayDirection = vec3( uv*2.0 - vec2(1), -1);\n    RayDirection.x *= iResolution.x/iResolution.y;\n    RayDirection = normalize(RayDirection);\n    \n    //Objects definition\n    Object Ground = DefaultObjectParameter;\n    Ground.Type   = GROUND_PLANE;\n    Ground.Position = vec3(0);\n    \n    Object Sphere = DefaultObjectParameter;\n    Sphere.Type = SPHERE;\n    Sphere.Position = vec3(0, 2, -15);\n    Sphere.Material.Color = vec3(1,1,0);\n    Sphere.Material.Specularity = 1.0;\n    Sphere.Material.Shineness = 200.0;\n    Sphere.Material.Diffuseness = 0.5;\n    \n    Object Capsule = DefaultObjectParameter;\n    Capsule.Type = CAPSULE;\n    Capsule.Position = vec3(-6, 5, -13);\n    Capsule.SpheresOffset = 2.0;\n    Capsule.Radius = 2.0;\n    Capsule.UpVector = vec3(0,1,0);\n    Capsule.Material.Color = vec3(0.9,0.4,0.2);\n    Capsule.Material.Specularity = 1.0;\n    Capsule.Material.Shineness = 50.0;\n    Capsule.Material.Diffuseness = 0.8;\n    \n    Object Torus = DefaultObjectParameter;\n    Torus.Type = TORUS;\n    Torus.Position = vec3(0, 1, -6);\n    Torus.Radius = 2.0;\n    Torus.RingRadius = 0.5;\n    Torus.UpVector = normalize( vec3(0, 1, 0) );\n    \n    Object Cube = DefaultObjectParameter;\n    Cube.Type = CUBE;\n    Cube.Position = vec3(4, 4, -6);\n    Cube.CubeSize = vec3(1.3);\n\n\n    //Array of objects/ add object to scene\n    Object SceneObjects[TOTAL_SCENE_OBJECTS]; int ObjectsCount = 0;\n    AddObjectToScene(SceneObjects, Sphere, ObjectsCount);\n    AddObjectToScene(SceneObjects, Ground, ObjectsCount);\n    AddObjectToScene(SceneObjects, Capsule, ObjectsCount);\n    AddObjectToScene(SceneObjects, Torus, ObjectsCount);\n    AddObjectToScene(SceneObjects, Cube, ObjectsCount);\n\n    //Lights \n    Light PointLight1, DirectionalLight1, AmbientLight;\n    \n    PointLight1.Type      = POINT_LIGHT;\n    PointLight1.Intensity = 0.5;\n    PointLight1.Position  = vec3(-5, 6, -15); // Torus.Position + vec3(0, 2.0 * sin(iTime), 0);\n    \n    DirectionalLight1.Type      = DIRECTIONAL_LIGHT;\n    DirectionalLight1.Intensity = 0.2;\n    DirectionalLight1.Direction = vec3(1, 0, 0);\n    \n    AmbientLight.Type = AMBIENT_LIGHT;\n    AmbientLight.Intensity = 0.08;\n    \n    //Array of lights /  add lights to scene\n    Light SceneLights[TOTAL_SCENE_LIGHTS]; int LightsCount = 0;\n    AddLightToScene(SceneLights, PointLight1,       LightsCount);\n    AddLightToScene(SceneLights, DirectionalLight1, LightsCount);\n    AddLightToScene(SceneLights, AmbientLight,      LightsCount);\n\n    \n    vec3 RayOrigin = vec3(0, 8, 0);\n\n    vec3 TargetToLookAt = Sphere.Position;\n    vec3 ZBasis = -vec3( normalize(TargetToLookAt - RayOrigin));\n    vec3 XBasis = cross(vec3(0, 1, 0), ZBasis);\n    \n    mat3 CameraMatrix = mat3( XBasis, cross(ZBasis, XBasis),  ZBasis); \n    RayDirection = CameraMatrix * RayDirection;\n         \n    //Ray March scene\n    FHitResult HitResult = RayMarch(RayOrigin, RayDirection, SceneObjects, ObjectsCount);\n\n    vec3 FinalColor; \n    if(HitResult.bWasAHit)\n    {\n        HitResult.HitLocation = RayOrigin + RayDirection * HitResult.Distance;\n        \n        //Ground texture\n        if(SceneObjects[HitResult.ClosestObject_ID].Type == GROUND_PLANE)\n        {\n           vec3 p  = vec3(HitResult.HitLocation.x, 0, -HitResult.HitLocation.z);\n           \n          \n           const float BoundaryLength = 5.0; //on x and z\n           const float LowerBounds    = -BoundaryLength/2.0;\n           vec2 UV = vec2( \n               (p.x - LowerBounds)/BoundaryLength, //u              \n               (p.z - LowerBounds)/BoundaryLength  //v\n           );\n           SceneObjects[HitResult.ClosestObject_ID].Material.Color = texture(iChannel0, UV).rgb;\n        }\n      \n        \n        HitResult.HitNormal   = SceneObjects[HitResult.ClosestObject_ID].Type == GROUND_PLANE \n            ? vec3(0,1,0) : CalculateNormal(HitResult.HitLocation, SceneObjects, ObjectsCount);\n        \n        FinalColor = CalculateLighting(\n            SceneLights,\n            LightsCount,\n            SceneObjects,\n            HitResult\n        );  \n    }\n    else\n    {\n          \n        FinalColor = vec3(0.1);\n    }\n        \n    //Output to screen\n    fragColor = vec4(FinalColor,1.0);\n}\nvec3 CalculateLighting(Light SceneLights[TOTAL_SCENE_LIGHTS], int LightCount, out Object SceneObjects[TOTAL_SCENE_OBJECTS], out FHitResult HitResult )\n{\n    FMaterial SurfaceMaterial = SceneObjects[HitResult.ClosestObject_ID].Material;\n    vec3 FinalColor   = vec3(0); \n    \n    float AmbientLightIntensity = 0.0;\n\n    for(int i = 0; i < LightCount; i++)\n    {\n        Light CurrentLight = SceneLights[i];\n        vec3 ToLightSource;\n        vec3 ToEyeRay = -HitResult.RayDirection;\n        \n        float SpotLightMask = 1.0; //light mask of 1.0 (a.k.a identity mask) for other light types\n\n        if( CurrentLight.Type == POINT_LIGHT)\n        {\n            ToLightSource = normalize( CurrentLight.Position - HitResult.HitLocation );\n             \n        }\n        else if(CurrentLight.Type == DIRECTIONAL_LIGHT)\n        {\n            ToLightSource = normalize(-CurrentLight.Direction);\n        }\n        else if(CurrentLight.Type == AMBIENT_LIGHT)\n        {\n            AmbientLightIntensity = CurrentLight.Intensity;\n            continue;\n        }\n        \n        \n        //Diffuse lighting\n        float N_Dot_D                    = dot(HitResult.HitNormal, ToLightSource);\n        float LightDistributionOnSurface = (max(N_Dot_D, 0.0) * CurrentLight.Intensity);\n        \n        FinalColor += SurfaceMaterial.Color * (SurfaceMaterial.Diffuseness * LightDistributionOnSurface);\n        \n        //Specular lighting\n        if(SurfaceMaterial.Specularity > 0.0){\n            vec3  ReflectedLightRay = reflect(-ToLightSource, HitResult.HitNormal);\n            float Reflected_Dot_Eye = dot(ToEyeRay, ReflectedLightRay);\n            \n            float SpecularDistributionOnSurface = (pow( max(Reflected_Dot_Eye, 0.0), SurfaceMaterial.Shineness) * CurrentLight.Intensity);\n            \n            FinalColor += SurfaceMaterial.Color * (SurfaceMaterial.Specularity * SpecularDistributionOnSurface);\n        }        \n        \n        //Debug\n        //return SurfaceMaterial.Color * (SurfaceMaterial.Specularity * SpecularDistributionOnSurface);\n    }\n    \n    FinalColor += SurfaceMaterial.Color * AmbientLightIntensity;\n    \n    return FinalColor; \n}\n\nvec3 CalculateNormal(vec3 HitPosition, out Object SceneObjects[TOTAL_SCENE_OBJECTS], int ObjectsCount)\n{\n    \n    int WillNotBeUsed;\n    \n    float DistanceFromSurface = SceneSDF(\n                HitPosition, \n                SceneObjects, \n                ObjectsCount, \n                WillNotBeUsed\n        ); \n    \n    vec2 Epsilon = vec2(0.01, 0);\n \n    vec3 Normal = vec3(DistanceFromSurface) - vec3(\n       SceneSDF(HitPosition - Epsilon.xyy, SceneObjects, ObjectsCount, WillNotBeUsed),\n       SceneSDF(HitPosition - Epsilon.yxy, SceneObjects, ObjectsCount, WillNotBeUsed),\n       SceneSDF(HitPosition - Epsilon.yyx, SceneObjects, ObjectsCount, WillNotBeUsed)\n    );\n    \n    return normalize(Normal);\n}\n\nfloat SceneSDF(vec3 RayCurrentPosition, out Object SceneObjects[TOTAL_SCENE_OBJECTS], int ObjectsCount, out int ClosestObject_ID)\n{\n    float ClosestDistance = 3000000.0;\n    for(int i = 0; i < ObjectsCount; i++)\n    {\n        float CurrenDistance = 0.0;\n        if(SceneObjects[i].Type == SPHERE)\n        {\n            CurrenDistance = distance(SceneObjects[i].Position, RayCurrentPosition) - SceneObjects[i].Radius; \n        }\n        else if(SceneObjects[i].Type == GROUND_PLANE)\n        {\n          \n            vec3 LocationOnGroundPlane = SceneObjects[i].Position + vec3(RayCurrentPosition.x, 0, RayCurrentPosition.z);\n            CurrenDistance = distance(LocationOnGroundPlane, RayCurrentPosition); \n        } \n        else if(SceneObjects[i].Type == CAPSULE)\n        {\n            CurrenDistance = CapsuleSDF(SceneObjects[i], RayCurrentPosition);\n        }\n        else if(SceneObjects[i].Type == TORUS)\n        {\n            CurrenDistance = TorusSDF(SceneObjects[i], RayCurrentPosition);\n        }\n        else if(SceneObjects[i].Type == CUBE)\n        {\n            CurrenDistance = CubeSDF(SceneObjects[i], RayCurrentPosition);\n        }\n        else continue; //no other object type yet\n       \n        //Distance check\n        if(CurrenDistance < ClosestDistance)\n        { \n            ClosestDistance  = CurrenDistance;\n            ClosestObject_ID = i;\n        }\n    }\n    \n    return ClosestDistance;\n}\n\nFHitResult RayMarch(vec3 RO, vec3 RD, out Object SceneObjects[TOTAL_SCENE_OBJECTS], int ObjectsCount)\n{    \n    float MarchDistance = 0.0;\n    \n    FHitResult HitResult;\n    HitResult.bWasAHit = false;\n    HitResult.Distance = MarchDistance;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        float DistanceToScene = SceneSDF(\n                RO + RD * MarchDistance, \n                SceneObjects, \n                ObjectsCount, \n                HitResult.ClosestObject_ID\n        );\n\n        if(DistanceToScene < SURFACE_DISTANCE) \n        {\n            HitResult.bWasAHit = true;\n            break;\n        }\n        \n        MarchDistance += DistanceToScene;\n\n        if(MarchDistance >= MAX_DISTANCE) \n        {\n            HitResult.bWasAHit = false;\n            break;\n        }        \n    }\n    \n    HitResult.Distance = MarchDistance;\n    HitResult.RayDirection = RD;\n    return HitResult;\n}\n\nvoid AddObjectToScene(out Object SceneObjects[TOTAL_SCENE_OBJECTS], Object ObjectToAdd, out int ObjectsCount)\n{\n    if(ObjectsCount < TOTAL_SCENE_OBJECTS)\n    {\n        SceneObjects[ObjectsCount] = ObjectToAdd;\n        ++ObjectsCount;\n    }\n}\n\nvoid AddLightToScene(out Light SceneLights[TOTAL_SCENE_LIGHTS], Light LightToAdd, out int LightsCount)\n{\n    if(LightsCount < TOTAL_SCENE_LIGHTS)\n    {\n        SceneLights[LightsCount] = LightToAdd;\n        ++LightsCount;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct FMaterial\n{\n    vec3  Color;\n    float Diffuseness;\n    float Specularity;\n    float Shineness;\n};\nconst FMaterial DefaultMaterial = FMaterial(vec3(1), 1.0, 0.5, 10.0);\n\nstruct Object\n{\n    int   Type;\n    vec3  Position;\n    float Radius;    \n    vec3  UpVector;\n    vec3  ForwardVector;\n    vec3  RightVector;\n\n    FMaterial Material;\n    \n    //Capsule\n    float SpheresOffset;\n    \n    //Torus\n    float RingRadius;\n    \n    //Box\n    vec3 CubeSize;\n};\n\nconst Object DefaultObjectParameter = Object(0, vec3(0, 2, -10), 2.0, vec3(0,1,0), vec3(0,0,-1), vec3(1,0,0), DefaultMaterial, 1.0, 1.0, vec3(1));\n\nfloat CapsuleSDF(out Object Capsule, vec3 RayPosition)\n{\n    vec3 TopSpherePosition = Capsule.Position + (Capsule.UpVector * Capsule.SpheresOffset);\n    vec3 BottomSpherePosition = Capsule.Position + (Capsule.UpVector * -Capsule.SpheresOffset);\n    \n    vec3 LineStart = BottomSpherePosition;\n    vec3 LineEnd   = TopSpherePosition;\n    \n    vec3 Line = LineEnd - LineStart;\n    \n    float c = dot(RayPosition - LineStart, Line)/dot(Line, Line);\n    //clamp within line range i.e within top and bottom spheres positions\n    c = clamp(c, 0.0, 1.0); \n    \n    //So when a ray is hovering around the sphere(outer) corners, we're getting it's sphere distance\n    //from the sphere center's\n    \n    return distance(RayPosition, (LineStart + Line * c)) - Capsule.Radius;\n}\n\nfloat TorusSDF(out Object Torus, vec3 RayPosition)\n{\n    vec3 TorusPositionToRayPosition = (RayPosition - Torus.Position);\n    \n    //Dot product will have a direction as well\n    float RayHeightFromTorusXZPlane_Y = dot(TorusPositionToRayPosition, Torus.UpVector);\n    \n    float RayDistanceFromTorusPosition_X = distance(TorusPositionToRayPosition, Torus.UpVector * RayHeightFromTorusXZPlane_Y);\n    \n    float DistanceFrom_TorusRingPosition_To_RayPosition = length( \n        vec2(RayDistanceFromTorusPosition_X - Torus.Radius, RayHeightFromTorusXZPlane_Y ) \n    ); //Though 'RayHeightFromTorusXZPlane_Y' is signed, the distance computed by length is always positive\n    \n    return DistanceFrom_TorusRingPosition_To_RayPosition - Torus.RingRadius;\n    \n}\n\nfloat CubeSDF(out Object Cube, vec3 RayPosition)\n{\n    vec3 CubePositionToRayPosition = abs(RayPosition - Cube.Position);\n    \n    /*\n        //Optional: to orient the cube based on some defined basis vectors\n        CubePositionToRayPosition = vec3(\n            abs(dot(CubePositionToRayPosition, Cube.RightVector)),\n            abs(dot(CubePositionToRayPosition, Cube.UpVector)),\n            abs(dot(CubePositionToRayPosition, Cube.ForwardVector))\n        );\n    */\n    \n    float x = CubePositionToRayPosition.x - Cube.CubeSize.x;\n    float y = CubePositionToRayPosition.y - Cube.CubeSize.y;\n    float z = CubePositionToRayPosition.z - Cube.CubeSize.z;\n    \n    \n    x = max(x, 0.0);  // clamp(x, 0.0, abs(x));\n    y = max(y, 0.0);  // clamp(y, 0.0, abs(y));\n    z = max(z, 0.0);  // clamp(z, 0.0, abs(z));\n    \n    return length(vec3(x, y, z)); \n}","name":"Common","description":"","type":"common"}]}