{"ver":"0.1","info":{"id":"3l3yDH","date":"1610018997","viewed":142,"name":"Chess piece - Knight","username":"Atchafalaya","description":"Another chess piece modeled with SDFs. It's supposed to be a knight. He's pretty ugly but I have an idea on how to make it better in a future shader.\nStill working on lighting and post-processing.\nFeel free to comment if you have any advice :)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","chess"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define FOCAL 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - R.xy) / R.y;\n\n    vec2 angle = vec2(2.*iMouse.xy/R.xy - 1.) * vec2(3., -0.7);\n    angle.x += iTime;\n    mat3 rotCam = rot(angle);\n    vec3 ro = rotCam * vec3(0., 0., 4.5);\n    ro += vec3(-1., 0.4, -1.);\n    vec3 rd = rotCam * normalize(vec3(uv, -FOCAL));\n    \n    vec3 mainLight = normalize(vec3(1.));\n    \n    float t;\n    RMResult s = raymarch(ro, rd, t);\n    vec3 p = ro + t * rd;\n    vec3 normal = gradient(p);    \n\n    vec3 sky = texture(iChannel0, rd).xyz;\n    vec3 col;\n    if (s.id < 0.)\n    {\n        // skybox\n        col = sky;\n    }\n    else if (s.id < 1.)\n    {\n        // board\n        if (abs(p.x) > 8. || abs(p.z) > 8.)\n        {\n            vec3 n = abs(normal);\n            vec2 fetch;\n            fetch = n.x > n.y && n.x > n.z ? vec2(0.5 * p.z, p.y) :\n            \t    n.y > n.z ? \t\t\t vec2(p.x, p.z) * 0.5:\n            \t\t\t\t\t\t\t   \t vec2(0.5 * p.x, p.y);\n            col = texture(iChannel1, fetch).xyz;\n        }\n        else\n        {\n            vec2 ss = sin(0.5 * PI * p.xz);\n            col = sign(ss.x) * sign(ss.y) < 0. ? vec3(0.05) : vec3(0.9);\n            col *= max(0.2, dot(normal, mainLight));\n        }\n    }\n    else if (s.id < 2.)\n    {\n        // chess piece\n        col = vec3(0.95, 0.95, 0.85) * max(0.2, dot(normal, mainLight));\n        col += 0.1 * max(0.0, dot(normal, -mainLight));\n        col += 0.1 * vec3(0.7, 0.43, 0.3) * max(0., dot(normal, vec3(0., 1., 0.)));\n    }\n\n    col = pow(col, vec3(0.5));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define I_MAX 1024\n#define FAR 1000.\n#define EPS 0.01\n#define PI 3.141592653589793\n\n// ~~~~~~~~ CAMERA ~~~~~~~~\nmat3 rot(vec2 angle)\n{\n    vec2 cc = cos(angle);\n    vec2 ss = sin(angle);\n    return mat3(vec3(cc.x      , 0.  , ss.x      ),\n\t\t\t\tvec3(ss.x*ss.y , cc.y, -ss.y*cc.x),\n                vec3(-cc.y*ss.x, ss.y, cc.x*cc.y ));\n}\n\n// ~~~~~~~~ SDFs and operations ~~~~~~~~\n// SDFs from iq's website https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 o, float r, vec3 p)\n{\n    return length(p - o) - r;\n}\n\nfloat sdBox(vec3 b, vec3 p)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundedBox(vec3 b, float r, vec3 p)\n{\n\treturn sdBox(b, p) - r;\n}\n\nfloat sdHPlane(float h, vec3 p)\n{\n    return p.y - h;\n}\n\nfloat sdCappedCylinder(float h, float r, vec3 p)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid(vec3 r, vec3 p)\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus(vec2 t, vec3 p)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdRoundCone(vec3 a, vec3 b, float r1, float r2, vec3 p)\n{\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    vec3 x =  pa*l2 - ba*y;\n    float x2 = dot(x, x);\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdCone(vec2 c, float h, vec3 p)\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nfloat det( vec3 a, vec3 b, in vec3 v ) { return dot(v,cross(a,b)); }\n\nfloat sdBezier( vec3 p, vec3 b0, vec3 b1, vec3 b2 )\n{\n    b0 -= p;\n    b1 -= p;\n    b2 -= p;\n    \n    vec3  d21 = b2-b1;\n    vec3  d10 = b1-b0;\n    vec3  d20 = (b2-b0)*0.5;\n\n    vec3  n = normalize(cross(d10,d21));\n\n    float a = det(b0,b2,n);\n    float b = det(b1,b0,n);\n    float d = det(b2,b1,n);\n    vec3  g = b*d21 + d*d10 + a*d20;\n\tfloat f = a*a*0.25-b*d;\n\n    vec3  z = cross(b0,n) + f*g/dot(g,g);\n    float t = clamp( dot(z,d10-d20)/(a+b+d), 0.0 ,1.0 );\n    vec3 q = mix(mix(b0,b1,t), mix(b1,b2,t),t);\n    \n    float k = dot(q,n);\n    return length(q);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat smax(float a, float b, float k)\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\n// ~~~~~~~~ Ray-marching algorithm ~~~~~~~~\nstruct RMResult{\n  \tfloat dist;\n    float id;\n};\n\nRMResult map(vec3 p)\n{\n    float d = FAR;\n    float id = -1.;\n    \n    {// board\n        float d0 = sdRoundedBox(vec3(8.2, 0.35, 8.2), 0.1, p - vec3(0., -1.5, 0.));\n        if (d0 < d)\n        {\n            d = d0;\n            id = 0.5;\n        }\n    }\n    {// knight\n\t\tp += vec3(1., 0., 1.);\n        p.x = abs(p.x);\n        // body\n        vec3 p0 = rot(vec2(0., -0.32)) * (p - vec3(0., 0.25, 0.)) + vec3(0., 0., 0.15);\n        float rx = 0.4 + 0.3 * smoothstep(0.4, -1., p0.y);\n        float rz = 0.8 - 0.3 * smoothstep(-1., 1., p0.y);\n        float d0 = sdEllipsoid(vec3(rx, 1.3, rz), p0);\n        vec3 p1 = p - vec3(0., -1., 0.);\n        float d1 = sdTorus(vec2(0.43, 0.5), p1);\n        d1 = max(d1, -sdHPlane(0., p1));\n        d0 = smin(d0, d1, 0.2);\n        vec3 p2 = p - vec3(0., -0.45, 0.);\n        float d2 = sdEllipsoid(vec3(0.66, 0.1, 0.78), p2);\n        d0 = smin(d0, d2, 0.03);\n        // head\n        vec3 p3 = rot(vec2(0., 0.3)) * (p - vec3(0., 1.3, 0.));\n        rx = 0.35 - 0.12 * smoothstep(-0.3, 0.5, p3.y);\n        float d3 = sdEllipsoid(vec3(rx, 0.45, 0.75), p3);\n        // head/chin\n        d3 = smax(d3, -sdCappedCylinder(0.4, 0.25, (p3 - vec3(0., -0.42, 0.33)).yxz), 0.2);\n        // head/mouth\n        d3 = smax(d3, -sdCappedCylinder(0.4, 0.05, (p3 - vec3(0., 0., 0.7)).yxz), 0.1);\n        d0 = smin(d0, d3, 0.15);\n        // head/eyes\n        vec3 p4 = p - vec3(0.23, 1.55, 0.);\n        float d4 = sdEllipsoid(vec3(0.1, 0.05 + 0.04 * smoothstep(0.1, -0.1, p4.z), 0.1), p4);\n        d0 = smax(d0, -d4, 0.08);\n        // head/mane\n        vec3 p5 = p - vec3(0., 0.8, 0.);\n        float freq = 5.7;\n        float notch = atan(p5.y, p5.z);\n        notch = fract(freq * notch);\n        notch = pow(notch, 2.);\n        notch = 4. * notch * (1. - notch);\n        float d5 = sdBezier(p, vec3(0., 1.72 ,  0.2 ),\n                                vec3(0., 2.25 , -1.25),\n                                vec3(0., -0.2, -0.7)) - 0.075 - 0.025 * notch;\n        d0 = smin(d0, d5, 0.04);\n        // head/nostrils\n        vec3 p6 = rot(vec2(0., -0.6)) * (p - vec3(0.11, 1.33, 0.65));\n        float rxz = 0.035 + 0.035 * smoothstep(-0.1, 0.1, p6.y);\n        float d6 = sdEllipsoid(vec3(rxz, 0.07, rxz), p6);\n        d0 = smax(d0, -d6, 0.02);\n        // notches\n        vec3 p7 = rot(vec2(0., -0.25))\n                * rot(vec2(0.8, 0.))\n                * (p - vec3(0.47, 0.2, -0.28));\n        float d7 = sdEllipsoid(vec3(0.05,\n                                    0.3 + 0.4  * smoothstep(-0.1, 0.1, p7.y),\n                                    0.05 - 0.025 * smoothstep(-0.1, 0.8, p7.y)), p7);\n        d0 = smax(d0, -d7, 0.02);\n        vec3 p8 = rot(vec2(0., -0.35))\n                * rot(vec2(0.6, 0.))\n                * (p - vec3(0.485, 0.2, -0.08));\n        float d8 = sdEllipsoid(vec3(0.05,\n                                    0.3 + 0.4  * smoothstep(-0.1, 0.1, p8.y),\n                                    0.05 - 0.025 * smoothstep(-0.1, 0.8, p8.y)), p8);\n        d0 = smax(d0, -d8, 0.02);        \n        if (d0 < d)\n        {\n            d = d0;\n            id = 1.5;\n        }\n    }    \n    return RMResult(d, id);\n}\n\nvec3 gradient( vec3 p )\n{\n    float h = EPS * EPS;\n    vec2 k = vec2(1,-1);\n    return normalize( k.xyy * map(p + k.xyy * h).dist + \n                      k.yyx * map(p + k.yyx * h).dist + \n                      k.yxy * map(p + k.yxy * h).dist + \n                      k.xxx * map(p + k.xxx * h).dist );\n}\n\nRMResult raymarch(vec3 ro, vec3 rd, out float t)\n{\n\tt = 0.;\n    vec3 p = ro + t * rd;\n    RMResult s = map(p);\n    float isInside = sign(s.dist);\n    for(int i = 0; i < I_MAX; i++)\n    {\n        float inc = isInside * s.dist;\n        if (t + inc < FAR && abs(s.dist) > EPS) \n        {\n\t\t\tt += inc;\n\t        p = ro + t * rd;\n            s = map(p);\n        }\n        else\n        {\n            if (t + inc > FAR)\n            {\n               s.id = -1.;\n            }\n            break;\n        }\n    }\n    return s;\n}\n","name":"Common","description":"","type":"common"}]}