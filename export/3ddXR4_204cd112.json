{"ver":"0.1","info":{"id":"3ddXR4","date":"1571749485","viewed":3569,"name":"Alas, poor Yorick!","username":"shau","description":"Loosely inspired by Billelis ","likes":80,"published":1,"flags":32,"usePreview":1,"tags":["3d","skull","billelis"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n/*\n\n    Inspired by Billelis (kind of)\n\n    Another nice skull example on Shadertoy - Lost_Astronaut by Duvengar\n    https://www.shadertoy.com/view/Mlfyz4\n*/\n\nconst float GA =2.399; \n\n// simplified version of Dave Hoskins blur from Virgill\nvec3 dof(sampler2D tex, vec2 uv, float rad) {\n\tvec3 acc = vec3(0);\n    vec2 pixel = vec2(.002*R.y/R.x, .002), angle = vec2(0, rad);;\n    rad = 1.;\n\tfor (int j = 0; j < 80; j++) {  \n        rad += 1. / rad;\n\t    angle *= rot(GA);\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/80.;\n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n    \n    vec2 uv = U / R;\n\tvec3 pc = vec4(dof(iChannel0, uv, texture(iChannel0, uv).w), 1.).xyz;\n    \n    C = vec4(pc, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.141592\n#define EPS .005\n#define FAR 20.\n#define ZERO (min(iFrame,0))\n#define R iResolution.xy\n#define T iTime\n\n#define SKULL 1.0\n#define TEETH 2.0\n#define STONE_I 3.0 \n#define STONE_O 4.0 \n#define GLOW 5.0\n#define BLACK 6.0\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat saturate(float x) {return clamp(x, 0.0, 1.0);}\nvec3 saturate(vec3 x) {return clamp(x, vec3(0.0), vec3(1.0));}\n\n//Shane IQ\nfloat n3D(vec3 p) {    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n//Distance functions - IQ\n//https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 p, float r) {\n    return length(p) -  r;    \n}\n\nfloat sdEllipsoid(vec3 p, vec3 r) {\n    return (length(p / r) - 1.) * min(min(r.x, r.y), r.z);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdTriPrism(vec3 p, vec2 h) {\n    vec3 q = abs(p);\n    return max(q.y-h.y,max(q.x*0.866025+p.z*0.5,-p.z)-h.x*0.5);\n}\n\nfloat sdLink(in vec3 p, in float le, in float r1, in float r2) {\n    vec3 q = vec3( p.y, max(abs(p.x)-le,0.0), p.z );\n    return length(vec2(length(q.yx)-r1,q.z)) - r2;\n}\n\nfloat sdEqTriangle(vec2 p) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0 / k;\n    if (p.x + k * p.y > 0.0) p = vec2(p.x - k * p.y, - k * p.x - p.y) / 2.0;\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sign(p.y);\n}\n\n//mercury\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.0 * PI / repetitions,\n          a = atan(p.y, p.x) + angle / 2.0,\n          r = length(p),\n          c = floor(a / angle);\n    a = mod(a, angle) - angle / 2.0;\n    p = vec2(cos(a), sin(a)) * r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions / 2.0)) c = abs(c);\n    return c;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n\tfloat h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\nfloat pattern(vec2 uv, float size) {\n    \n    for(int i=0; i<5; ++i) {\n\t\tuv *= rot(float(i)+1.7);\n        uv = abs(fract(uv/30. + .5) - .5)*30.; //NuSan\n\t\tuv -= size;\n\t\tsize *= 0.5;\n\t}\n    \n    float t = length(uv+vec2(0.0, -1.5)) - 0.4;\n    t = max(t, -(length(uv+vec2(0.0, -1.5)) - 0.3));\n    t = min(t, length(uv+vec2(0.0, -1.5)) - 0.2);\n    t = min(t, sign(sdEqTriangle((uv+vec2(0.0,-0.5)) * 1.0)) * sign(sdEqTriangle((uv+vec2(0.0,-0.5)) * 1.3)));\n    return step(0.0, t);\n}\n\nvec2 nearest(vec2 a, vec2 b) {\n    float s = step(a.x, b.x);\n    return s*a + (1.0-s)*b;\n}\n\nvec2 dfSkull(vec3 p) {\n    \n    p.yz *= rot(0.2);\n    vec3 q = p;\n  \n    float nz = (n3D(p*2.0) - 0.5) * 0.06;\n    //teeth\n    q.xz *= rot(0.0981);\n    pModPolar(q.xz, 32.0);\n    float teeth = sdEllipsoid(q - vec3(0.7, 0.0, 0.0), vec3(0.04, 0.18, 0.06));\n    teeth = min(smax(teeth, -sdBox(q - vec3(0.0, -1.0, 0.0), vec3(2.0, 1.0, 2.0)), 0.04), \n                smax(teeth, -sdBox(q - vec3(0.0, 1.0, 0.0), vec3(2.0, 1.0, 2.0)), 0.04));\n    teeth = max(teeth, p.z);    \n\n    //symetry\n    p.x = abs(p.x);\n    \n    //skull\n    q = p;\n    float skull = sdCapsule(p, vec3(0.0, 1.5, 0.6), vec3(0.0, 1.5, 1.0), 1.36+nz);\n    skull = smin(skull, sdSphere(p - vec3(0.0, 1.5, 1.0), 1.46), 0.2+nz);\n    //roof of mouth\n    skull = smin(skull, sdEllipsoid(q - vec3(0.0, 0.2, 0.0), vec3(0.72, 0.8, 0.72)), 0.3);\n    skull = max(skull, -sdEllipsoid(q - vec3(0.0, 0.2, 0.0), vec3(0.52, 0.6, 0.52)));\n    skull = smax(skull, -sdBox(q - vec3(0.0, -0.9, 0.0), vec3(2.0, 1.0, 2.0)), 0.02);\n    \n    //jaw socket\n    skull = smax(skull, -sdCappedCylinder(p.yxz - vec3(0.0, 0.0, 0.7), 0.5, 2.0), 0.2);\n    \n    //jaw\n    float jaw = sdEllipsoid(q - vec3(0.0, -0.2, 0.0), vec3(0.72, 0.5, 0.7)+nz);\n    jaw = max(jaw, -sdEllipsoid(q - vec3(0.0, -0.2, 0.0), vec3(0.65, 0.52, 0.65)));\n    jaw = smax(jaw, -sdBox(q - vec3(0.0, 0.9, 0.0), vec3(2.0, 1.0, 2.0)), 0.02);\n    q.yz *= rot(-0.2);\n    jaw = smin(jaw, sdTorus(q - vec3(0.0, -0.38, -0.2), vec2(0.5, 0.08+nz)), 0.14);\n\tq.x = abs(q.x);\n    jaw = smin(jaw, sdEllipsoid(q - vec3(0.58, -0.36, 0.3), vec3(0.3, 0.14, 0.6)+nz), 0.1);\n    jaw = smax(jaw, -sdBox(q - vec3(0.0, 0.0, 1.7), vec3(0.5, 2.0, 2.0)), 0.02);\n    jaw = smax(jaw, -sdBox(q - vec3(0.0, 0.0, 2.5), vec3(2.0, 1.0, 2.0)), 0.08);\n    q = p;\n    q.yz *= rot(-0.2);\n    q.xy *= rot(-0.2);\n    jaw = smin(jaw, sdEllipsoid(q - vec3(0.8, 0.3, 0.36), vec3(0.1, 0.40, 0.14)+nz), 0.2);\n    jaw = smin(jaw, sdCapsule(p, vec3(0.9,0.2,0.3), vec3(1.1,0.5,0.6), 0.08+nz), 0.08);\n    skull = min(skull, jaw);\n    \n    //eyebrow\n    skull = smax(skull, -sdCapsule(p, vec3(0.8,0.8,-0.9), vec3(-0.8,0.8,-0.9), 0.3), 0.16);\n    //eye socket\n    skull = smax(skull, -sdEllipsoid(vec3(abs(p.x),p.y,p.z) - vec3(0.4,0.8,-0.26), vec3(0.4,0.3,0.3)), 0.1);\n\n    //temple\n    q = p;\n    q.xz *= rot(-0.4);\n    q.xy *= rot(-0.3);\n    skull = smax(skull, -sdEllipsoid(q - vec3(0.64,1.2,0.8), vec3(0.1+nz,0.6,0.7)), 0.1);\n    \n    //eye socket\n    nz = n3D(p*5.0) * 0.03;\n    \n    q = p;\n    q += vec3(-0.4, -0.8, 0.50);\n    q.y *= 1.0 - abs(p.x)*0.3;\n    q.z -= abs(q.x*q.x*0.8);\n    q.z += q.y*0.2;\n    float brow = sdLink(q, 0.34, 0.24+nz, 0.08+nz);\n    skull = smin(skull, brow, 0.1);\n    q = p;\n    q += vec3(-1.14, -0.9, -0.44);\n    q.y += q.z*q.z*0.4;\n    q.x += q.z*q.z*0.6;\n    q.yz *= rot(-0.2);\n    skull = smin(skull, sdCapsule(q, vec3(0.0,0.0,-0.66),  vec3(0.0,0.0,0.66), 0.1+nz), 0.1); \n    \n    //nose\n    skull = smin(skull, sdEllipsoid(p - vec3(0.0, 0.5, -0.3), vec3(0.4,0.3,0.44)), 0.1);    \n    float nose = sdCapsule(p, vec3(0.0,0.62,-0.78), vec3(0.0,1.2,-0.5), 0.18 - p.y*0.08 + nz);\n    skull = smin(skull, nose, 0.14);\n    nz = n3D(p*19.0)*0.05;\n    skull = smax(skull, -sdEllipsoid(p - vec3(0.0,0.56,-0.98), vec3(0.34,0.2,0.34)+nz), 0.02);\n    \n    //nostril\n    q = p;\n    q += vec3(-0.08, -0.55, 0.7);\n    q.yz *= rot(1.4);\n    q.xz *= rot(0.523);\n    skull = smax(skull, -sdTriPrism(q, vec2(0.14, 0.3)), 0.03);\n    \n    //cutout teeth\n    skull = smax(skull, -teeth, 0.02);\n    \n    return nearest(vec2(skull, SKULL), vec2(teeth, TEETH));       \n}\n\nvec3 dfHalo(vec3 p) {\n    \n    vec3 q = p.xzy;\n    float stoneO = sdCappedCylinder(q, 50.0, 0.2);\n    stoneO = max(stoneO, -sdCappedCylinder(q, 3.5, 1.0));\n    float stoneI = sdCappedCylinder(q, 3.0, 0.2);\n    stoneI = max(stoneI, -sdCappedCylinder(q, 2.0, 1.0));\n    \n    float glow = sdTorus(p.xzy, vec2(1.9, 0.01));\n    glow = min(glow, sdTorus(p.xzy, vec2(3.3, 0.01)));\n    \n    //ughhh!!!\n    /*\n    q = p;\n    float black = sdCapsule(q, vec3(-3.0,-1.0,-0.5), vec3(3.0,-1.0,-0.5), 0.08);\n    q.xy *= rot(PI*2.0/5.0);\n    black = min(black, sdCapsule(q, vec3(-3.0,-1.0,-0.5), vec3(3.0,-1.0,-0.5), 0.08));\n    q.xy *= rot(PI*2.0/5.0);\n    black = min(black, sdCapsule(q, vec3(-3.0,-1.0,-0.5), vec3(3.0,-1.0,-0.5), 0.08));\n    q.xy *= rot(PI*2.0/5.0);\n    black = min(black, sdCapsule(q, vec3(-3.0,-1.0,-0.5), vec3(3.0,-1.0,-0.5), 0.08));\n    q.xy *= rot(PI*2.0/5.0);\n    black = min(black, sdCapsule(q, vec3(-3.0,-1.0,-0.5), vec3(3.0,-1.0,-0.5), 0.08));\n    //*/\n    \n    vec2 near = nearest(vec2(stoneI, STONE_I), vec2(stoneO, STONE_O));\n    near = nearest(near, vec2(glow, GLOW));\n    //near = nearest(near, vec2(black, BLACK));\n    \n    return vec3(near, glow);\n}\n\nvec3 map(vec3 p) {\n\n    vec2 skull = dfSkull(p);\n    vec3 halo = dfHalo(p + vec3(0.0,-0.9,-0.4));\n    \n    return vec3(nearest(skull, halo.xy), halo.z);\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(EPS, 0);\n    float d1 = map(p + e.xyy).x, d2 = map(p - e.xyy).x;\n    float d3 = map(p + e.yxy).x, d4 = map(p - e.yxy).x;\n    float d5 = map(p + e.yyx).x, d6 = map(p - e.yyx).x;\n    float d = map(p).x * 2.0;\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n//IQ - https://iquilezles.org/articles/raymarchingdf\nfloat AO(vec3 p, vec3 n) {\n    float ra = 0., w = 1., d = 0.;\n    for (float i = 1.; i < 12.; i += 1.){\n        d = i / 5.;\n        ra += w * (d - map(p + n * d).x);\n        w *= .5;\n    }\n    return 1. - clamp(ra, 0., 1.);\n}\n\n//IQ - https://www.shadertoy.com/view/lsKcDD\nfloat shadow(vec3 ro, vec3 rd, float mint, float tmax) {\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10;\n    \n    for (int i = ZERO; i < 32; i++) {\n\t\tfloat h = map(ro + rd * t).x;\n        float y = h * h / (2.0 * ph);\n        float d = sqrt(h * h - y * y);\n        res = min(res, 10.0 * d / max(0.0, t-y));\n        ph = h;        \n        t += h;\n        if (res < 0.0001 || t > tmax) break;\n    }\n    \n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 bump(vec3 p, vec3 n, float ba) {\n    vec2 e = vec2(EPS, 0.0);\n    float nz = n3D(p);\n    vec3 d = vec3(n3D(p + e.xyy) - nz, n3D(p + e.yxy) - nz, n3D(p + e.yyx) - nz) / e.x;\n    n = normalize(n - d * ba / sqrt(0.1));\n    return n;\n}\n   \n//Knarkowicz\n//https://www.shadertoy.com/view/4sSfzK\nvec3 fresnelSchlick(float vdoth, vec3 specularColour) {\n    return specularColour + (1.0 - specularColour) * pow(1.0 - vdoth, 5.0);\n} \n\nfloat distributionTerm(float roughness, float ndoth) {\n\tfloat r2 = roughness * roughness;\n\tfloat d\t = (ndoth * r2 - ndoth) * ndoth + 1.0;\n\treturn r2 / (d * d * PI);\n}\n\nfloat geometrySchlickGGX(float ndot, float roughness) {\n    float r = (roughness + 1.0);\n    float k = (r * r) / 8.0;\n    float nom = ndot;\n    float denom = ndot * (1.0 - k) + k;\n    return nom / denom;\n}\n\nfloat geometrySmith(float roughness, float ndotv, float ndotl) {\n    float ggx2  = geometrySchlickGGX(ndotv, roughness);\n    float ggx1  = geometrySchlickGGX(ndotl, roughness);\n    return ggx1 * ggx2;\n}\n\nvec3 envBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n    const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n    const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n    return specularColor * AB.x + AB.y;  \n}\n\n// St. Peter's Basilica SH\n// https://www.shadertoy.com/view/lt2GRD\nstruct SHCoefficients {\n    vec3 l00, l1m1, l10, l11, l2m2, l2m1, l20, l21, l22;\n};\n\nconst SHCoefficients SH_STPETER = SHCoefficients(\n    vec3( 0.3623915,  0.2624130,  0.2326261 ),\n    vec3( 0.1759131,  0.1436266,  0.1260569 ),\n    vec3(-0.0247311, -0.0101254, -0.0010745 ),\n    vec3( 0.0346500,  0.0223184,  0.0101350 ),\n    vec3( 0.0198140,  0.0144073,  0.0043987 ),\n    vec3(-0.0469596, -0.0254485, -0.0117786 ),\n    vec3(-0.0898667, -0.0760911, -0.0740964 ),\n    vec3( 0.0050194,  0.0038841,  0.0001374 ),\n    vec3(-0.0818750, -0.0321501,  0.0033399 )\n);\n\nvec3 SHIrradiance(vec3 nrm) {\n    const SHCoefficients c = SH_STPETER;\n    const float c1 = 0.429043;\n    const float c2 = 0.511664;\n    const float c3 = 0.743125;\n    const float c4 = 0.886227;\n    const float c5 = 0.247708;\n    return (\n        c1 * c.l22 * ( nrm.x * nrm.x - nrm.y * nrm.y ) +\n        c3 * c.l20 * nrm.z * nrm.z +\n        c4 * c.l00 -\n        c5 * c.l20 +\n        2.0 * c1 * c.l2m2 * nrm.x * nrm.y +\n        2.0 * c1 * c.l21  * nrm.x * nrm.z +\n        2.0 * c1 * c.l2m1 * nrm.y * nrm.z +\n        2.0 * c2 * c.l11  * nrm.x +\n        2.0 * c2 * c.l1m1 * nrm.y +\n        2.0 * c2 * c.l10  * nrm.z\n    );\n}\n\nvec3 envRemap(vec3 c) {\n    return pow(2.0 * c, vec3(2.2));\n}\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 gc) {\n    float t = 0.0, id = 0.0;\n    for (int i=ZERO; i<200; i++) {\n    \tvec3 ns = map(ro + rd*t);\n        if (abs(ns.x)<EPS || t>FAR) {\n            id = ns.y;\n            break;\n        }\n        \n        gc += vec3(0.1,0.0,0.0) / (1.0 + ns.z*ns.z*60.);\n        t += ns.x*0.7;\n    }\n    return vec2(t, id);\n}\n\nvec3 camera(vec2 U, vec3 ro, vec3 la, float fl) {\n    vec2 uv = (U - R*.5) / R.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z, 0., -fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}\n\nvoid mainImage(out vec4 C, in vec2 U) {\n    \n    vec3 pc = vec3(0),\n         gc = vec3(0),\n         ro = vec3(0.0, 1.0 + sin(T*0.04)*0.6, -3.0),\n         la = vec3(0.0, 1.0, 0.0),\n         lp = vec3(3.0, 8.0, -4.0),\n         lc = vec3(0.6, 0.4, 0.1);\n         \n    ro.xz *= rot(sin(T*-0.1)*0.6);\n    /*\n    ro.xz *= rot((iMouse.x/R.x-0.5)*2.0);\n    ro.yz *= rot((iMouse.y/R.y-0.5)*2.0);\n    //*/\n    \n    vec3 rd = camera(U, ro, la, 1.4);\n    \n    float dof = 0.0, mint = FAR;\n    vec2 si = march(ro, rd, gc);\n    if (si.x>0.0 && si.x<mint) {\n        \n        vec3 p = ro +rd*si.x,\n             n = normal(p),\n             sc = vec3(0.0);\n        \n        dof = length(la - p);\n        mint = si.x;\n        \n        float rG = 0.0, //roughness\n              metallic = 0.0; \n        \n        vec3 q = p - vec3(0.0, 0.9, 0.0);\n        \n        if (si.y==SKULL) {\n            \n            n = bump(vec3(p.x*20.0,p.y,p.z*20.0), n, 0.02);\n            n = bump(p*30.0, n, 0.02);\n            \n            if (pattern(q.xy*2.0, 2.0) == 0.0) {\n                sc = vec3(1.0,0.8,0.3)*0.4;\n                rG = 0.7;\n                metallic = 1.0;\n            } else {\n                sc = vec3(1.0,0.9,0.7);\n                rG = 0.9;\n            }\n        } else if (si.y==TEETH) {\n            n = bump(vec3(p.x,p.y*0.1,p.z)*40.0, n, 0.06);\n            sc = vec3(1.0,0.9,0.7);\n            rG = 0.7;\n        } else if (si.y==STONE_O) {\n            q.xy *= rot(T*-0.2);\n            if (pattern(q.xy, 6.0) == 0.0) {\n                sc = vec3(1.0,0.8,0.3)*0.4;\n                rG = 0.7;\n                metallic = 1.0;\n            } else {\n                n = bump(q*20.0, n, 0.08);\n                sc = vec3(0.04);\n                rG = 1.0;\n            }\n        } else if (si.y==STONE_I) {\n            q.xy *= rot(T*0.2);\n            if (pattern(q.xy, 6.0) == 0.0) {\n                sc = vec3(1.0,0.8,0.3)*0.4;\n                rG = 0.7;\n                metallic = 1.0;\n            } else {\n                n = bump(q*20.0, n, 0.08);\n                sc = vec3(0.04);\n                rG = 1.0;\n            }\n        } else if (si.y==BLACK) {\n            sc = vec3(0.0);\n            rG = 0.0;\n            metallic = 1.0;\n        }\n        \n        sc += vec3(0.1,0.0,0.4)*0.8 * max(0.0, n.y);\n        \n        vec3 ld = normalize(lp-p),\n             rrd = reflect(rd, n);\n        float ao = AO(p, n),\n              sh = shadow(p+n*EPS, ld, 0.0, FAR);\n        \n        vec3 h = normalize(-rd + ld);\n        float rL = max(.01, rG*rG), //linear roughness\n              vdoth = clamp(dot(-rd, h), 0., 1.),\n              ndoth\t= clamp(dot(n, h), 0., 1.),\n              ndotv = clamp(dot(n, -rd), 0., 1.),\n              ndotl = clamp(dot(n, ld), 0., 1.);\n        \n        vec3 diffuseColour = metallic == 1.0 ? vec3(0) : sc,\n             specularColour = metallic == 1.0 ? sc : vec3(0.02),\n             diffuse = diffuseColour * envRemap(SHIrradiance(n));\n        diffuse += diffuseColour * saturate(dot(n, ld));\n        diffuse *= ao;\n        \n        vec3 envSpecularColour = envBRDFApprox(specularColour, rG*rG, ndotv),\n             env1 = envRemap(texture(iChannel1, rrd).xyz),\n             env2 = envRemap(texture(iChannel0, rrd).xyz),       \n             env3 = envRemap(SHIrradiance(rrd)),       \n             env  = mix(env1, env2, saturate(rG*rG * 4.));\n        env = mix(env, env3, saturate((rG*rG - 0.25) / 0.75));\n        \n        vec3 specular = envSpecularColour * env;\n        vec3 lightF = fresnelSchlick(vdoth, specularColour);\n        float lightD = distributionTerm(rL, ndoth);\n        float lightV = geometrySmith(rL, ndotv, ndotl);\n        specular += vec3(1.) * lightF * (lightD * lightV * PI * ndotl);\n        specular *= saturate(pow(ndotv + ao, rG*rG) - 1.0 + ao);\n        \n        pc = diffuse + specular;\n        pc *= sh;\n        pc = pow(pc * .4, vec3(1. / 2.4));        \n\n        if (si.y==GLOW) {\n            pc = vec3(1.0,0.0, 0.0);\n        }\n    }\n    \n    pc = mix(pc, vec3(0), mint/FAR);\n    pc += gc;\n    \n    C = vec4(pc, dof/10.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}