{"ver":"0.1","info":{"id":"wtsXRs","date":"1563985080","viewed":363,"name":"swirlyMess001","username":"Taron","description":"experimenting with matrix rotations, bending space a little, more ray marching experiments, but nothing revolutionary, well, uhm, except possibly the revolutions? I'll have to rethink a few things, I believe, because I'm not convinced it has to be RM.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","swirls"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*---------------------------------------------------------------\nI dare not comment anything in this one, yet. But in case someone \nbelieves I know what I'm doing and wants to know it, too, \njust let me know!\n---------------------------------------------------------------*/\nconst float radius = 0.3;\nfloat sRadius;\n\nfloat sphere(vec3 p, float radius)\n{\n  return length(p)-radius;\n}\nfloat box(vec3 p, vec3 c)\n{\n  vec3 q = abs(p)-c;\n  return (min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.)))*0.5;\n}\n\nfloat map(vec3 p)\n{\n    //p = mod(p,2.)-1.;\n    float pz = p.z+iTime;\n    vec3 rotx = vec3(sin(pz), cos(pz),0.);\n    vec3 roty = vec3(-rotx.y, rotx.x,0.);\n    vec3 rotz = normalize(cross(rotx, roty));\n  \tvec3 op = p;\n    p.x = rotx.x*op.x + roty.x*op.y+ rotz.x*op.z;\n    p.y = rotx.y*op.x + roty.y*op.y+ rotz.y*op.z;\n    p.z = rotx.z*op.x + roty.z*op.y+ rotz.z*op.z;\n    p = mod(p,2.)-1.;\n    //return sphere(p,sRadius);\n    return min(max(box(p,vec3(radius)),-sphere(p,sRadius)),sphere(p,sRadius*0.7));\n    //return mix(box(p,vec3(0.25)),sphere(p+vec3(cos(iTime)*.25,0.,sin(iTime)*0.05),.3+.25*sin(iTime*1.5)*0.5),sin(pz*3.33+iTime*.05));\n}\n\nvec3 getNormal(vec3 p)\n{\n  vec2 o = vec2(0.001, 0.);\n  return normalize(vec3(  map(p+o.xyy)-map(p-o.xyy),\n                          map(p+o.yxy)-map(p-o.yxy),\n                          map(p+o.yyx)-map(p-o.yyx)));\n}\n\nvec3 lighting(vec3 n, vec3 light)\n{\n    float lit = dot(n, light);\n    float sub = max(0.,0.5+0.5*lit);\n    vec3 col = vec3(max(0.,lit))+sub*vec3(0.3,0.46,0.5);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tfloat time = iTime;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(sin(time*1.45)*1.,1.*(cos(time*0.25)),5.*time);\n    vec3 p = ro;\n    vec3 rd = vec3(uv.xy*(0.25+0.75*length(uv.xy)),0.5);\n    rd = normalize(rd);\n\n    vec3 light = normalize(vec3(sin(time), cos(time), sin(time*0.25)));\n    vec3 bgColor = mix(vec3(1.7,0.96,0.2),vec3(0.1,0.25,0.4),length(uv));\n\n    bool hit = false;\n    float shading = 0.;\n    vec3 color = bgColor;\n  \n    sRadius = radius*1.3+sin(iTime)*radius*0.25;\n    \n    rd *= 0.5;\n    int i = 0;\n    p+=vec3(uv.xy,1.);\n    float dd;\n    while(i<100)\n    {\n        float d = map(p);\n        if(d<0.01)\n        {\n            hit = true;\n            \n            if(abs(d)<0.0001)\n                break;\n            \n            p-=rd*dd;\n            rd *=0.5;\n        }\n        dd = d;\n        p+=rd*d;\n      \ti++;\n     }\n\n    if(hit)\n    {\n        vec3 norm = getNormal(p);\n        float fog = min(1.0, 0.09*length(p-ro));\n        color = mix(lighting(norm, light),bgColor,fog);\n    }\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}