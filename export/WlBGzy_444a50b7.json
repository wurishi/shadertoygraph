{"ver":"0.1","info":{"id":"WlBGzy","date":"1559921576","viewed":275,"name":"Light interference","username":"Crumbler","description":"An attempt to visualize light interference with raymarching. Dstep should be very small, otherwise graphic artifacts emerge.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float pi = acos(-1.0), dstep = pi / 75.0, camHeight = 3.09;\n\nconst vec2 camGrid = vec2(-2.5,-2.930),\n    \nlight1 = vec2(0.0, 0.0),\nlight2 = vec2(-1.57, 4.0);\n\nconst vec3 camPos = vec3(camGrid.x, camHeight, camGrid.y);\n\nmat3 rotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat f(in vec3 v)\n{\n    return (sin(distance(v.xz, light1) * 2.0 - iTime * 2.0) \n            + sin(distance(v.xz, light2) * 5.87 - iTime * 2.0))\n        \t/ 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = (gl_FragCoord.xy / iResolution.y);\n    st.y = st.y * 2.0 - 1.0;\n    st.x = st.x - 0.5 * iResolution.x / iResolution.y;\n    st.x *= 2.0;\n    \n    // direction of ray for this pixel. Rotated to point down a bit.\n\tvec3 rD = normalize(vec3(0.,0.0,1.0) + vec3(st, 0.0)) * rotationMatrix(vec3(1., 0., 0.), 0.714);\n    float col = 0.0;\n  \tvec3 color = vec3(col);\n    \n    // if rD.y is >= 0 then the ray never hits the function, so we just color the pixel black\n    if (rD.y < 0.0)\n    {\n        // I cast the ray onto a plane with a height of 1, because the value of f() never goes above 1\n        vec3 curPoint = camPos + rD * (camHeight - 1.0) / abs(rD.y);\n    \tfloat curSign, dist = dstep;\n        \n        // curSign means whether curPoint is above or below the function\n    \tcurSign = sign(curPoint.y - f(curPoint));\n        \n    \tfor (int i = 0; i < 1250; ++i)\n    \t{\n    \t    curPoint += rD * dist;\n    \t    curSign = sign(curPoint.y - f(curPoint));\n    \t    if (curSign <= 0.0)\n    \t        break;\n    \t}\n    \t\n        \n   \t \tfor (int i = 0; i < 30; ++i)\n   \t \t{\n    \t\t   dist /= 2.0;\n     \t\t   curPoint += rD * dist * curSign;\n     \t\t   curSign = sign(curPoint.y - f(curPoint));\n     \t}\n\t\n   \t \tcol = f(curPoint) * 0.5 + 0.5;\n    }\n    \n    color = vec3(col);\n    \n  \tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}