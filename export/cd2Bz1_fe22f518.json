{"ver":"0.1","info":{"id":"cd2Bz1","date":"1689436695","viewed":52,"name":"drop line (one rain)","username":"calc","description":"I learned making shape by 2d sdf  following link:\nhttps://iquilezles.org/articles/distfunctions2d/","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSegment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h);\n}\nfloat sdEllipse(vec2 p , vec2 ab){\n    p = abs(p);\n    if (p.x > p.y) {\n        p = p.yx;\n        ab = ab.yx;\n    }\n    float l = ab.y * ab.y - ab.x * ab.x;\n    float m = ab.x *p.x/l;\n    float m2 = m*m;\n    float n = ab.y*p.y/l;\n    float n2 = n*n;\n    float c = (m2+n2-1.0) / 3.0 ;\n    float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n\n    if(d<0.0){\n        float h = acos(q / c3) / 3.0;\n        float s = cos(h);\n        float t = sin(h) * sqrt(3.0);\n        float rx = sqrt(-c*(s + t + 2.0) + m2);\n        float ry = sqrt(-c*(s - t + 2.0) + m2);\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry) - m) /2.0;\n    } else{\n        float h = 2.0 * m*n * sqrt(d);\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c* 4. + 2.0*m2;\n        float ry = (s-u)*sqrt(3.0);\n        float rm = sqrt(rx*rx+ry*ry);\n        co = (ry/sqrt(rm-rx)+2.0*g/rm - m) /2.0;\n    }\n    vec2 r = ab * vec2(co , sqrt(1.-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n\nfloat sdElCircle(vec2 p, vec2 ab , float r  ) { return abs(sdEllipse(p,ab)) - r; }\n\n\n\nfloat e0(float t, float k) {\n  float x = exp(-k * clamp(t, 0.0, 1.0) );\n  float s0 = 1.0;\n  float s1 = exp(-k);\n  return (s0 - x) / (s0 - s1);\n}\nfloat e1(float t, float k) {\n  return 1.0 - e0(1.0 - t, k);\n}\n\nfloat normfit(float x, float a, float b) { // rate between a and b \n  return clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5, 0.5);\n    \n      vec2 a = vec2(0.0, 0.5);\n  vec2 b = vec2(0.0, 0.0); //a to b \n  vec2 initpos = vec2(0.0, -0.5);\n  vec2 finpos = vec2(0.0, 1.5);\n  float progress = fract(iTime );\n  float droptime = progress /0.7;\n\n  float eased = e1(droptime, 6.5);\n  vec2 p = mix( initpos, finpos, eased );\n  \n  float d = sdSegment(uv+p, a, b) ;\n  \n  \n  \n      float progEl = normfit(progress - 0.7, 0.0, 0.3) ;// 0.0~0.3 to 0.0~1.0\n      float easedEl = e0(progEl, 10.);\n  if(eased > 0.9){\n    vec2 size = vec2(0.5, 0.26) ;\n    float dEl = sdElCircle(uv + vec2(.0, 0.3) ,size*easedEl, .003);\n    d = min(d, dEl);\n  }\n\n\n    // Time varying pixel color\n      vec3 blue = vec3(0.2, 0.7 , 1.0 );\n      blue = blue *(1. - progEl); // disappear Ellipse along progress time \n  vec3 col =  blue * smoothstep(0.005, 0.0005, d);\n\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}