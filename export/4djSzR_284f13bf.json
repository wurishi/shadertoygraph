{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define MOTIONBLUR_EMBERS \t0 // Set to 1 to enable sampled motion blur on the embers.\n#define ADD_HEAT_GLOW \t\t0 // Set to 1 to make the rock glow red as the lava covers it.\n\nfloat moveSpeed=0.75;\n\nfloat cubic(float x)\n{\n    return (3.0 * x - 2.0 * x * x) * x;\n}\n\nvec3 rotateX(float angle, vec3 v)\n{\n    return vec3(v.x, cos(angle) * v.y + sin(angle) * v.z, cos(angle) * v.z - sin(angle) * v.y);\n}\n\nvec3 rotateY(float angle, vec3 v)\n{\n    return vec3(cos(angle) * v.x + sin(angle) * v.z, v.y, cos(angle) * v.z - sin(angle) * v.x);\n}\n\nfloat hash(float n)\n{\n    n=mod(n,1024.0);\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise(vec2 p)\n{\n    return hash(p.x + p.y*57.0);\n}\n\nfloat smoothNoise2(vec2 p)\n{\n    vec2 p0 = floor(p + vec2(0.0, 0.0));\n    vec2 p1 = floor(p + vec2(1.0, 0.0));\n    vec2 p2 = floor(p + vec2(0.0, 1.0));\n    vec2 p3 = floor(p + vec2(1.0, 1.0));\n    vec2 pf = fract(p);\n    return mix( mix(noise(p0), noise(p1), pf.x),mix(noise(p2), noise(p3), pf.x), pf.y);\n}\n\nfloat cellnoise(vec2 p)\n{\n    vec2 fp=fract(p);\n    vec2 ip=p-fp;\n    float nd=1e3;\n    vec2 nc=p;\n    for(int i=-1;i<2;i+=1)\n        for(int j=-1;j<2;j+=1)\n        {\n            vec2 c=ip+vec2(i,j)+vec2(noise(ip+vec2(i,j)),noise(ip+vec2(i+10,j)));\n            float d=distance(c,p);\n            if(d<nd)\n            {\n                nd=d;\n                nc=c;\n            }\n        }\n\n    return nd;\n}\n\nfloat heightField(vec2 p)\n{\n    float f=0.0;\n    for(int i=0;i<3;i+=1)\n        f+=smoothNoise2(p*exp2(float(i+2)))/exp2(float(i));\n    return smoothstep(0.0,0.7,1.0-smoothstep(0.0,0.9,cellnoise(p)))*0.4+f*0.04;\n}\n\n\nfloat fbm(vec2 p)\n{\n    float f=0.0;\n    for(int i=0;i<4;i+=1)\n        f+=smoothNoise2(p*exp2(float(i)))/exp2(float(i+1));\n    return f;\n}\n\nfloat bumpHeight(vec2 p)\n{\n    float f=0.0;\n    p*=4.0;\n    for(int i=0;i<5;i+=1)\n        f+=smoothNoise2(p*exp2(float(i)))/exp2(float(i+1));\n    return f*0.15;\n}\n\nvec3 bumpNormal(vec2 p)\n{\n    vec2 eps=vec2(1e-5,0.0);\n    float bumpScale=10.0;\n    float c=bumpHeight(p);\n    float d0=(bumpHeight(p+eps.xy))-c;\n    float d1=(bumpHeight(p+eps.yx))-c;\n    return normalize(cross(vec3(eps.y,d1,eps.x),vec3(eps.x,d0,eps.y)));\n}\n\nvec3 heightFieldNormal(vec2 p)\n{\n    vec2 eps=vec2(1e-1,0.0);\n    float bumpScale=10.0;\n    float c=heightField(p);\n    float d0=(heightField(p+eps.xy))-c;\n    float d1=(heightField(p+eps.yx))-c;\n    vec3 n0 = normalize(cross(vec3(eps.y,d1,eps.x),vec3(eps.x,d0,eps.y)));\n    vec3 bn = bumpNormal(p);\n    return normalize(n0+(bn-n0*dot(n0,bn))*0.2);\n}\n\nvec3 tonemap(vec3 c)\n{\n    return c/(c+vec3(0.6));\n}\n\nfloat evalLavaHeight(vec2 p)\n{\n    return mix(-0.5,0.2,cubic(clamp(1.0-(-p.y-iTime*moveSpeed)+sin(p.x+iTime*0.2),0.0,1.0)));\n}\n\nvec3 samplef(vec2 coord)\n{\n    // Set up ray.\n    vec3 ro=vec3(0.0,3.0,-2.0-iTime*moveSpeed+cos(iTime*1.0)*0.05);\n    vec3 rd=rotateY(3.1415926+sin(iTime*0.1),rotateX(1.0+sin(iTime*0.4)*0.05,normalize(vec3(coord,-1.3))));\n\n    // Intersect the ray with the upper and lower planes of the heightfield.\n    float t0=(0.5-ro.y)/rd.y;\n    float t1=(0.0-ro.y)/rd.y;\n\n    const int n=14;\n\n    float lavaHeight=0.0;\n\n    vec3 prevp=ro+rd*t0,p=prevp;\n    float ph=heightField(prevp.xz);\n\n    // Raymarch through the heightfield with a fixed number of steps.\n    for(int i=1;i<n;i+=1)\n    {\n        float pt=mix(t0,t1,float(i-1)/float(n));\n        float t=mix(t0,t1,float(i)/float(n));\n        p=ro+rd*t;\n        lavaHeight=evalLavaHeight(p.xz);\n        float h=max(lavaHeight,heightField(p.xz));\n        if(h>p.y)\n        {\n            // Refine the intersection point.\n            float lrd=length(rd.xz);\n            vec2 v0=vec2(lrd*pt, prevp.y);\n            vec2 v1=vec2(lrd*t, p.y);\n            vec2 v2=vec2(lrd*pt, ph);\n            vec2 dv=vec2(h-v2.y,v2.x-v1.x);\n            float inter=dot(v2-v0,dv)/dot(v1-v0,dv);\n            p=mix(prevp,p,inter);\n\n            // Re-evaluate the lava height using the refined intersection point.\n            lavaHeight=evalLavaHeight(p.xz);\n            break;\n        }\n        prevp=p;\n        ph=h;\n    }\n\n    vec3 norm=heightFieldNormal(p.xz);\n\n    // Base colour for the rocks.\n    float f0=sqrt(fbm(p.xz*0.5));\n    vec3 diffuse=mix(vec3(0.1,0.2,0.1)*0.5,mix(vec3(0.1),vec3(1.0,0.8,0.6)*0.3,f0),max(0.0,norm.y))*mix(0.7,0.2,p.y)*mix(0.3,1.0,fbm(p.xz*3.0));\n\n    // Cheating by simply adding light from the lava into the diffuse albedo.\n    diffuse+=vec3(1.0,0.35,0.04)*clamp((1.0-norm.y)*0.1+pow(max(0.0,(1.0-abs(lavaHeight-p.y)*4.0)),2.0),0.0,1.0)*0.4;\n    diffuse=mix(1.5*vec3(1.0,0.35,0.04),diffuse,clamp((p.y-lavaHeight)*16.0,0.0,1.0));\n    \n#if ADD_HEAT_GLOW\n    vec3 glow=smoothstep(0.0,3.0,p.z+time*moveSpeed)*max(0.0,1.0-p.y*1.5)*pow(3.0*vec3(0.4,0.21,0.1)*(0.6*fbm(p.xz+vec2(time*0.5,0.0))+0.6*fbm(p.xz+vec2(-time*0.5,0.0))),vec3(3.0));\n#else\n    vec3 glow=vec3(0.0);\n#endif\n    \n    // Some small bright bits for fake embers to suggest fire.\n#if MOTIONBLUR_EMBERS\n    vec3 embers=vec3(0.0);\n    for(int j=0;j<8;j+=1)\n    {\n        float mb_time=time+float(j)*6e-2/8.0;\n\t    embers+=vec3(1.0,0.35,0.04)*smoothstep(0.77+sin(mb_time*20.0)*0.01+sin(mb_time)*0.01,1.0,fbm(coord*10.0+vec2(cos(coord.y*0.8+mb_time*0.7)*10.0,mb_time*4.0)));\n    \tembers+=vec3(1.0,0.35,0.04)*smoothstep(0.77+sin(mb_time*22.0)*0.01+sin(mb_time*1.2)*0.01,1.0,fbm(vec2(100.0)+coord*8.0+vec2(mb_time*8.0+cos(coord.y*0.3+mb_time*0.3)*10.0,mb_time*7.0)));\n    }\n    embers/=8.0*0.5;\n#else\n    vec3 embers=vec3(1.0,0.35,0.04)*smoothstep(0.77+sin(iTime*20.0)*0.01+sin(iTime)*0.01,1.0,fbm(coord*10.0+vec2(cos(coord.y*0.8+iTime*0.7)*10.0,iTime*4.0)));\n    embers+=vec3(1.0,0.35,0.04)*smoothstep(0.77+sin(iTime*22.0)*0.01+sin(iTime*1.2)*0.01,1.0,fbm(vec2(100.0)+coord*8.0+vec2(iTime*8.0+cos(coord.y*0.3+iTime*0.3)*10.0,iTime*7.0)));\n#endif\n    \n    // Wrap lighting is applied here, both to the rock, lava, and glow from lava. This is not correct, but\n    // it gives some substance to the lava and variation/shadow to the glow.\n    return diffuse*(0.5+0.5*norm.x)*2.5+vec3(1.0,0.35,0.04)*0.02+embers+glow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Sample the scene, with a distorted coordinate to simulate heat haze.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv - vec2(0.5)) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    fragColor.rgb=samplef(uv+vec2(cos(smoothNoise2(vec2(-iTime*10.0+uv.y*10.0,uv.x)))*0.01,0.0));\n    fragColor.rgb=tonemap(fragColor.rgb)*1.2;\n}\n\n","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"XsfGRr"}],"inputs":[],"code":"float bubbles(float time, float period, float len, float ff)\n{\n    float c=floor(time/period)*period;\n    float t=(time-c)-(0.5+0.5*sin(c*12.0))*0.8*period;\n    return step(-0.2,cos(c*199.0*len))*sin(ff*(5000.0+cos(c*70.0)*2000.0)*(t+0.1)*t)*(smoothstep(0.0,0.07*len,t)-smoothstep(0.1*len,0.2*len,t));\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    return vec2(bubbles(time, 2.0, 1.2, 1.0)*0.9+0.1*bubbles(time, 0.5, 0.5, 2.0)+0.2*bubbles(time, 0.2, 0.2, 2.0))*0.75;\n}","name":"Sound","description":"","type":"sound"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":true,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4djSzR","date":"1408411404","viewed":2795,"name":"Flowing Lava","username":"fizzer","description":"I implemented heightfield raymarching with intersection refinement and I had the idea to add some flowing lava to it. This is the result. The refinement basically interprets the heightfield along the ray as piecewise linear.","likes":73,"published":1,"flags":8,"usePreview":0,"tags":["procedural","lava","heat","rock","dramatic"],"hasliked":0,"parentid":"","parentname":""}}