{"ver":"0.1","info":{"id":"lc2GRD","date":"1703916734","viewed":86,"name":"High precision octree tracing","username":"GeForceLegend","description":"Ported [url]https://github.com/ch3coohlink/editor[/url] to GLSL.\nCamera code is modified from [url]https://www.shadertoy.com/view/XsXXDB[/url].\nModified to remove dynamic arrays, in order to improve performance.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","voxel","octree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Translated https://github.com/ch3coohlink/editor from wgsl to glsl\n * Camera code from https://www.shadertoy.com/view/XsXXDB\n * Modified to remove dynamic arrays, in order to improve performance\n */\n\nconst int recursion_level = 20;\nconst int step_limit = 100;\nconst float scale = 10.0;\n\nfloat rnd(vec4 v) {\n    return fract(4e4 * sin(dot(v, vec4(13.46, 41.74, -73.36, 14.24)) + 17.34));\n}\n\nuvec3 firstnode(vec3 t0, vec3 tm, vec3 t1) {\n    float c2 = max(max(0.0, t0.x), max(t0.y, t0.z));\n    uvec3 node = uvec3(\n        c2 < tm.x ? 0u : 1u,\n        c2 < tm.y ? 0u : 1u,\n        c2 < tm.z ? 0u : 1u\n    );\n    return node;\n}\n\nfloat rayoctree(vec3 vro, vec3 vrd, inout vec3 clr) {\n    vec3 ro = vro;\n    vec3 rd = vrd;\n    uvec3 mirrormask = uvec3(0u);\n    if (rd.x < 0.0) {\n        ro.x = 1.0 - ro.x;\n        rd.x = -rd.x;\n        mirrormask.x = 1u;\n    }\n    if (rd.y < 0.0) {\n        ro.y = 1.0 - ro.y;\n        rd.y = -rd.y;\n        mirrormask.y = 1u;\n    }\n    if (rd.z < 0.0) {\n        ro.z = 1.0 - ro.z;\n        rd.z = -rd.z;\n        mirrormask.z = 1u;\n    }\n    vec3 intersection = 1.0 / rd;\n    vec3 t0 = (vec3(0.0) - ro) * intersection;\n    vec3 t1 = (vec3(1.0) - ro) * intersection;\n    if (max(max(t0.x, t0.y), max(t0.z, 0.0)) >= min(min(t1.x, t1.y), t1.z)) { return -1.0; }\n\n    int steps = 0;\n    int level = 0;\n    // Moved size outside, so it only need to `*= 2.0` or `*= 0.5` in each loop\n    float size = 0.5;\n    uvec3 stack = uvec3(0u);\n    vec3 pos = vec3(0.0);\n    vec3 tm = 0.5 * (t0 + t1);\n    uvec3 node_cache = firstnode(t0, tm, t1);\n    stack = node_cache;\n    bool exit = false;\n    bool hit = true;\n    while (level < recursion_level) {\n        uvec3 ri = node_cache ^ mirrormask; // real index\n        vec3 rm = vec3(float(ri.x), float(ri.y), float(ri.z));\n        vec3 mask = vec3(float(node_cache.x), float(node_cache.y), float(node_cache.z));\n        vec3 npos = pos + size * rm;\n        float v = rnd(vec4(npos, size));\n        vec3 size_intersection = size * intersection;\n        if (exit || v < 0.3) { // pop and move to next\n            exit = false;\n            steps++;\n            if (steps > step_limit) {\n                hit = false;\n                break;\n            }\n            vec3 next_node_length = tm + mask * size_intersection;\n            float next_length = min(next_node_length.x, min(next_node_length.y, next_node_length.z));\n            node_cache = uvec3(\n                next_node_length.x > next_length ? node_cache.x : (node_cache.x + 1u),\n                next_node_length.y > next_length ? node_cache.y : (node_cache.y + 1u),\n                next_node_length.z > next_length ? node_cache.z : (node_cache.z + 1u)\n            );\n            exit = node_cache.x > 1u || node_cache.y > 1u || node_cache.z > 1u;\n            if (exit) {\n                if (level < 1) {\n                    // Does not hit, but considered as hit to output traced steps.\n                    break;\n                }\n                level--;\n                size *= 2.0;\n                node_cache = (stack & uvec3(1u << level)) >> level;\n                uvec3 ri = node_cache ^ mirrormask;\n                vec3 rm = vec3(float(ri.x), float(ri.y), float(ri.z));\n                vec3 mask = vec3(float(node_cache.x), float(node_cache.y), float(node_cache.z));\n                size_intersection *= 2.0;\n                t0 -= mask * size_intersection;\n                t1 += size_intersection - mask * size_intersection;\n                tm = t0 + size_intersection;\n                pos -= size * rm;\n            } else {\n                stack &= uvec3(~(1u << level));\n                stack |= node_cache << level;\n            }\n        } else { // push\n            t0 += mask * size_intersection;\n            t1 = tm + mask * size_intersection;\n            tm = t0 + 0.5 * size_intersection;\n            pos = npos;\n            level++;\n            size *= 0.5;\n            node_cache = firstnode(t0, tm, t1);\n            stack &= uvec3(~(1u << level));\n            stack |= node_cache << level;\n        }\n    }\n    clr = vec3(1.0, 0.0, 0.0);\n    if (hit) {\n        clr = vec3(float(steps) / float(step_limit));\n    }\n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\t \n\tfloat Time = 10.0*(iTime) / scale + 1.0;\n\t// camera\t\n\tvec3 ro = vec3( 8.0*cos(Time), 6.0, 8.0*sin(Time) );\n//\tvec3 ro = vec3( -8.0, 6.0, 8.0 );\n\tvec3 ta = vec3( 0.5, 0.5, 0.5 );\n\n\tvec2 m = iMouse.xy / iResolution.xy;\n\tif( iMouse.z>0.0 )\n\t{\n\t\tfloat hd = -m.x * 14.0 + 3.14159;\n\t\tfloat elv = m.y * 3.14159 * 0.4 - 3.14159 * 0.25;\n\t\tro = vec3(sin(hd) * cos(elv), sin(elv), cos(hd) * cos(elv));\n\t\tro = ro * 8.0 + vec3(0.0, 6.0, 0.0);\n\t}\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + scale * cw );\n    vec3 col;\n    if (rayoctree(ro, rd, col) < 0.) {\n        col = vec3(0.0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}