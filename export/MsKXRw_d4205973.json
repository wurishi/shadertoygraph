{"ver":"0.1","info":{"id":"MsKXRw","date":"1463918309","viewed":521,"name":"RasterizedPyramid","username":"kuvkar","description":"Rasterized pyramid in a shader. Implements perspective corrected texturing. Simple lighting based on face normals. Mouse to look around.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["rasterization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n Rasterized pyramid in a shader. \n  \n Reference materials:\n http://scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/barycentric-coordinates\n http://scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/visibility-problem-depth-buffer-depth-interpolation \n http://scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/perspective-correct-interpolation-vertex-attributes \t\n Another implementation: https://www.shadertoy.com/view/XdlGzn by iq\n*/\n\n#define BASIS_X \t    vec4(1.0, 0.0, 0.0, 0.0)\n#define BASIS_Y \t    vec4(0.0, 1.0, 0.0, 0.0)\n#define BASIS_Z \t    vec4(0.0, 0.0, 1.0, 0.0)\n#define TRANSLATE_ZERO  vec4(0.0, 0.0, 0.0, 1.0)\n#define PROJ_BASIS_Z    vec4(0.0, 0.0, 1.0, 1.0)\n\n#define UV_BL vec2 (0.0, 0.0)\n#define UV_TL vec2 (0.0, 1.0)\n#define UV_BR vec2 (1.0, 0.0)\n#define UV_TR vec2 (1.0, 1.0)\n#define UV_TC vec2 (0.5, 0.5)\n#define GETNORMAL(p0,p1,p2) normalize(cross(normalize(p1.xyz - p0.xyz), normalize(p1.xyz - p2.xyz)))\n#define VERTICES 5\n#define NORMALS 5\n\nconst float PI = 3.14159265;\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\nmat4 model;\nmat4 view;\nmat4 projection;\n\nvec4 Vertices [VERTICES];\nvec3 Normals[NORMALS];\n\nvec2 g_uv;\n\nstruct Triangle\n{\n    vec4 p1;\n    vec4 p2;\n    vec4 p3;\n    \n    vec2 p1uv;\n    vec2 p2uv;\n    vec2 p3uv;\n    \n    vec3 faceNormal;\n};\n\n    \n// 2d cross product, aka \"wedge product\", returns signed area of a parallellogram defined by the 2 vectors.\nfloat cross2d(in vec2 v1, in vec2 v2)\n{\n\treturn (v1.x*v2.y) - (v1.y*v2.x);\n}\n\nbool drawTriangle(in Triangle t, inout vec4 color, inout float z)\n{\n   vec2 p1 = t.p1.xy;\n   vec2 p2 = t.p2.xy;\n   vec2 p3 = t.p3.xy;\n    \n   float triangleArea = abs(cross2d(p2 - p1, p3 - p1)) * 0.5; \n\n   // Calculate areas of subtriangles that are defined by the current point being rasterized, and the 3 vertices of this triangle.\n   // sizes of those areas are weights of the barycentric coordinates.\n   float w1 = (cross2d(p2 - g_uv, p1 - g_uv) * 0.5) / triangleArea;\n   float w2 = (cross2d(p2 - g_uv, g_uv - p3) * 0.5) / triangleArea;\n   float w3 = (cross2d(p3 - g_uv, g_uv - p1) * 0.5) / triangleArea;\n   \n   // if any value is negative, then the pixel is outside of this triangle.\n   if(w1 < 0.0 || w2 < 0.0 || w3 < 0.0) \n   {\n       return false;\n   }\n    \n    \n   float z1 = 1.0 / t.p1.w;\n   float z2 = 1.0 / t.p2.w;\n   float z3 = 1.0 / t.p3.w;\n   \n   float depth = 1.0 / (w2 * z1 + w3 * z2 + w1 * z3);\n   \n   // Depth test, reject sample if it's z value is larger than smallest sample. \n   if(depth > z) \n   {\n       return false;\n   }\n    \n   z = depth;\n    \n   // Perspective correction for UV coordinates \n   vec2 uv = w2 * (t.p1uv * z1) + w3 * (t.p2uv * z2) + w1 * (t.p3uv * z3);\n   uv *= depth;\n    \n   color = texture(iChannel0, uv);\n   \n   // diffuse lighting \n   float d = dot(t.faceNormal, vec3(0.0, 0.0, -1.0));\n   d = clamp(d, 0.0, 1.0);\n   color *= vec4(d);\n   return true;\n   \n}\n\nvoid applyRotation()\n{\n    mat3 rotation = rotx(sin(-iTime + 0.5) * 1.0) * roty(0.5 + -iTime * 1.5);\n    if(iMouse.z > 0.0)\n    {\n\t    vec2 im = 5.0 * ((iMouse.xy / iResolution.xy) - vec2(0.5));\n        rotation = rotx(-im.y) * roty(im.x);\n    }\n    \n\tfor (int i = 0; i < VERTICES; ++i)\n    {\n        Vertices[i].xyz = rotation * Vertices[i].xyz;\n    }\n    \n    for (int i = 0; i < NORMALS; ++i)\n    {\n        Normals[i] = rotation * Normals[i];\n    }\n}\n\nvoid applyProjection()\n{\n    \n    mat4 MVP = projection * model * view;\n    \n\tfor (int i = 0; i < VERTICES; ++i)\n    {\n        Vertices[i] = MVP * Vertices[i];\n        // Projection. Divides all values by z, expect for w that is used later.\n        // The way projection matrix is set up, w contains value of z before projection.\n        Vertices[i].xyz /= Vertices[i].w;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tfloat size = 1.2;    \n    Vertices[0] = vec4(-0.25, -0.25,  -0.25, 1.0 / size) * size;\n    Vertices[1] = vec4( 0.0,   0.25,   0.0,  1.0 / size) * size;\n    Vertices[2] = vec4( 0.25, -0.25,  -0.25, 1.0 / size) * size;\n    Vertices[3] = vec4( 0.25, -0.25,   0.25, 1.0 / size) * size;\n    Vertices[4] = vec4(-0.25, -0.25,   0.25, 1.0 / size) * size;\n\t\n    // Face normals of triangles\n    Normals[0] = GETNORMAL(Vertices[2], Vertices[1], Vertices[0]);\n    Normals[1] = GETNORMAL(Vertices[3], Vertices[1], Vertices[2]);\n    Normals[2] = GETNORMAL(Vertices[0], Vertices[1], Vertices[4]);\n    Normals[3] = GETNORMAL(Vertices[4], Vertices[1], Vertices[3]);\n    Normals[4] = GETNORMAL(Vertices[0], Vertices[3], Vertices[2]);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    \n    uv.y /= iResolution.x / iResolution.y;\n    g_uv = uv;\n    \n    // Background color\n    fragColor = pow( 1.0 - length(uv), 3.0) * vec4(0.7, 0.5, 0.5, 0.0);\n\n    model = mat4(BASIS_X, BASIS_Y, BASIS_Z, vec4(0.0, 0.1, 2.0, 1.0));\n    view  = mat4(BASIS_X, BASIS_Y, BASIS_Z, TRANSLATE_ZERO);\n    projection = mat4(BASIS_X, BASIS_Y, PROJ_BASIS_Z, vec4(0.0));\n\n    applyRotation();\n    applyProjection();\n    \n    // z \"buffer\"\n    float z = 9999.0;\n    \n    Triangle t1 = Triangle(Vertices[0], Vertices[1], Vertices[2], UV_BL, UV_TC, UV_BR, Normals[0]);\n    Triangle t2 = Triangle(Vertices[1], Vertices[3], Vertices[2], UV_TC, UV_TR, UV_BR, Normals[1]);\n    Triangle t3 = Triangle(Vertices[4], Vertices[1], Vertices[0], UV_BL, UV_TC, UV_BR, Normals[2]);\n    Triangle t4 = Triangle(Vertices[4], Vertices[3], Vertices[1], UV_BL, UV_BR, UV_TC, Normals[3]);\n    Triangle t5 = Triangle(Vertices[3], Vertices[4], Vertices[0], UV_TR, UV_TL, UV_BL, Normals[4]);\n    Triangle t6 = Triangle(Vertices[2], Vertices[3], Vertices[0], UV_BR, UV_TR, UV_BL, Normals[4]);\n    \n    vec4 color = vec4(0.0);\n    bool rasterize = drawTriangle(t1, color, z);\n    rasterize = drawTriangle(t2, color, z) || rasterize;\n    rasterize = drawTriangle(t3, color, z) || rasterize;\n    rasterize = drawTriangle(t4, color, z) || rasterize;\n    rasterize = drawTriangle(t5, color, z) || rasterize;\n    rasterize = drawTriangle(t6, color, z) || rasterize;\n    \n    if(rasterize)\n    {\n    \tfragColor = color;    \n    }\n}","name":"Image","description":"","type":"image"}]}