{"ver":"0.1","info":{"id":"NsKSDm","date":"1647092940","viewed":180,"name":"3body fractal","username":"metabog","description":"Thought it might be interesting to check out the dynamics of a 3 body system by mapping some parameters to UV coords. I think some of the periodic rings are to do with step size... I should use a better form of integration but still interesting.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3body"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//A fractal-like visual based off tracking the position of one body in a 3 body gravitational bound system\n//Mouse position sets the start position of the second body. Pixel position is mapped to the start position of\n//the body we are tracking. Then map the color to be how long it took the tracked body to escape.\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec2 compute_grav_pull(vec2 me, vec2 other, float mass)\n{\n    vec2 vec = other-me;\n    float d = length(vec);\n    vec = normalize(vec);\n    \n    //multiply by 200 to apply some distance scale otherwise all the bodies will be very close by\n    //and explode off of each other's steep gravity wells very quickly\n    //there are no collisions so acceleration approaches infinity near the centres of objects!\n    d=max(0.01,d);//no black holes lol\n    float pull = 1.0f/(d*400.0); \n    vec *= pull * 0.6 * mass;\n    \n    return vec;\n}\n\n//change these to set the starting velocities of the other bodies\nvec2 body1_start_vel = vec2(0.0,0.03);\nvec2 body2_start_vel = vec2(0.0,-0.03);\n\n//the masses of the bodies\nfloat b1mass = 1.2;\nfloat b2mass = 0.5;\nfloat movermass = 0.1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec2 b1pos = vec2(0.25,0.5);\n    vec2 b2pos = vec2(iMouse.x,iMouse.y)/iResolution.xy;\n    \n    vec2 b1vel = body1_start_vel;\n    vec2 b2vel = body2_start_vel;\n    \n    //start at uv coords\n    vec2 moverpos = uv;\n    \n    //set start velocity for the tracked body to rotate slowly\n    vec2 movervel = vec2(cos(iTime*0.1), sin(iTime*0.1))*0.05;\n    \n    int maxiter = 128;\n    \n    int iter_reached = 0;\n    \n    while(iter_reached<maxiter)\n    {\n        //get the new velocities\n        vec2 b1acc  = compute_grav_pull(b1pos, b2pos, b2mass) + compute_grav_pull(b1pos,moverpos, movermass);\n        vec2 b2acc  = compute_grav_pull(b2pos, b1pos, b1mass) + compute_grav_pull(b2pos,moverpos,movermass);\n        vec2 moveracc = compute_grav_pull(moverpos, b1pos,b1mass) + compute_grav_pull(moverpos,b2pos,b2mass);\n\n        b1vel+=b1acc;\n        b2vel+=b2acc;\n        movervel+=moveracc;\n        \n        b1pos+=b1vel;\n        b2pos+=b2vel;\n        moverpos+=movervel;\n        \n        if(length(moverpos-vec2(0.5,0.5))>2.0)\n            break;\n        iter_reached++;\n    }\n    \n    float d = float(iter_reached)/float(maxiter);\n\n    // Output to screen\n    //fragColor = texture(iChannel0, vec2(d,0.5));\n    fragColor = vec4(hsv2rgb(vec3(d*d*1.9,0.6,d)),1.0);\n}","name":"Image","description":"","type":"image"}]}