{"ver":"0.1","info":{"id":"ws3BD2","date":"1606000930","viewed":206,"name":"6D- IQ Biplanar mapping","username":"snolot","description":"Testing IQ Biplanar mapping on animated sdf","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","biplanar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// From IQ's example 'Biplanar mapping' https://www.shadertoy.com/view/ws3Bzf \n#define ROTATE\n#define SLICE\n#define PI 3.14159265\n\n#define R(x) fract(sin(dot(x,vec2(12.9898, 78.233))) * 43758.5453)\n\n// Wyman, Chris, and Morgan McGuire. \"Hashed alpha testing.\" \n// Proceedings of the 21st ACM SIGGRAPH Symposium on Interactive 3D Graphics and Games. ACM, 2017.\nfloat hash(vec2 p) {\n   return fract(1.0e4 * sin(17.0 * p.x + 0.1 * p.y) * (0.1 + abs(sin(13.0 * p.y + p.x))));\n}\n\nfloat hash3D(vec3 p) {\n   return hash(vec2(hash(p.xy), p.z));\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n  vec3 h = max(k-abs(a-b),0.)/k;\n  return min(a,b)-h*h*h*k/6.;\n}\n\nfloat obj(vec3 p) {\n\n    vec3 p1 = p;\n    #ifdef SLICE\n        vec3 p2 = vec3(asin(sin(iTime )),0,0);\n    #else\n        vec3 p2 = vec3(1,0,0);\n    #endif\n\n    #ifdef ROTATE\n    \tmat3 r11 = mat3(-0.33,-0.55,0.29,0.18,-0.055,0.24,-0.11,-0.42,-0.83);\n    \tmat3 r12 = mat3(-0.42,0.13,0.26,0.8,-0.13,0.06,-0.088,0.68,-0.29);\n    \tmat3 r22 = mat3(-0.67,-0.47,0.23,-0.07,-0.54,0.17,0.4,-0.24,0.46);\n    \tmat3 r21 = mat3(0.54,-0.29,0.31,-0.17,0.57,0.73,-0.22,-0.047,0.25);\n    #else    \n        mat3 r11 = mat3(1);\n        mat3 r12 = mat3(0);\n        mat3 r21 = mat3(0);\n        mat3 r22 = mat3(1);\n    #endif\n\n    vec3 l1s = r11*p1 + r12*p2;\n    vec3 l2s = r21*p1 + r22*p2;\n\n    vec3 l1 = smin(1.-sqrt(l1s*l1s+.1),vec3(.5),.2);\n    vec3 l2 = smin(1.-sqrt(l2s*l2s+.1),vec3(.5),.2);\n\n    \n    float cage = sqrt(dot(l1,l1)+dot(l2,l2))-.9;\n    return cage;\n}\n\nfloat scene(vec3 p) {\n    //mix the object with a smaller, space-repeated copy of itself for a more interesting surface texture\n    return mix(obj(p), obj(asin(sin(p*6.)*.8))/6.,.3);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvec4 biplanar( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n    // grab coord derivatives for texturing\n    vec3 dpdx = dFdx(p);\n    vec3 dpdy = dFdy(p);\n    n = abs(n);\n\n    // major axis (in x; yz are following axis)\n    ivec3 ma = (n.x>n.y && n.x>n.z) ? ivec3(0,1,2) :\n               (n.y>n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n    // minor axis (in x; yz are following axis)\n    ivec3 mi = (n.x<n.y && n.x<n.z) ? ivec3(0,1,2) :\n               (n.y<n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n        \n    // median axis (in x;  yz are following axis)\n    ivec3 me = ivec3(3) - mi - ma;\n    \n    // project+fetch\n    vec4 x = textureGrad( sam, vec2(   p[ma.y],   p[ma.z]), \n                               vec2(dpdx[ma.y],dpdx[ma.z]), \n                               vec2(dpdy[ma.y],dpdy[ma.z]) );\n    vec4 y = textureGrad( sam, vec2(   p[me.y],   p[me.z]), \n                               vec2(dpdx[me.y],dpdx[me.z]),\n                               vec2(dpdx[me.y],dpdy[me.z]) );\n    \n    // blend and return\n    vec2 m = pow( vec2(n[ma.x],n[me.x]), vec2(k) );\n\treturn (x*m.x + y*m.y) / (m.x + m.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n     vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n    vec2 mouse = (iMouse.xy/iResolution.xy*2.0-1.0)*2.;\n    mouse.x += iTime/6.;\n    mouse.y += iTime/10.;\n\n    mat3 rot_x = mat3( cos(-mouse.x), sin(-mouse.x), 0.0,\n                      -sin(-mouse.x), cos(-mouse.x), 0.0,\n                                0.0,          0.0, 1.0);\n    \n    mat3 rot_y = mat3( cos(-mouse.y), 0.0, sin(-mouse.y),\n                                0.0, 1.0, 0.0,\n                      -sin(-mouse.y), 0.0, cos(-mouse.y));\n    \n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-11,0,0);\n\n\tinit*=rot_y*rot_x;\n    cam*=rot_y*rot_x;\n\n    vec3 p = init;\n    bool hit = false;\n    \n    for (int i = 0; i < 300; i++) {\n        float dist = scene(p);\n        if (dist*dist < 0.00001) { hit = true; break; }\n        if (distance(p,init)>200.) break;\n        p+=dist*cam;\n    }\n    \n    vec3 n = norm(p);\n   \n    vec3 r = reflect(cam,n);\n    vec3 lightdir = normalize(vec3(1));\n    float ao = smoothstep(-.5,2.,scene(p+n*2.))*.9+.1;\n    float ro = smoothstep(-.5,2.,scene(p+r*2.));\n    float ss = smoothstep(-1.,1.,scene(p+lightdir));\n    float spec = length(sin(r*3.)*0.2+0.8)/sqrt(3.);\n    float diff = length(sin(n*2.)*0.5+0.5)/sqrt(3.);\n    float fres = 1.-abs(dot(n,cam))*.98;\n\n   \tvec3 col = biplanar(iChannel0, p * .25, n, 2.0 ).rgb;\n    col *= col;\n    col *= 2.0;\n    col = ao*mix(ss,diff,.5)* col +pow(spec,20.)*fres*2.*ro;\n   \n    float bg = .8 + length(cam * .5 * .02) / sqrt(.3);\n  \tfragColor =hit ? vec4(sqrt(col), 1.) : vec4(vec3(pow(bg,7.))* vec3(.35, .27, .22), 1.);\n}","name":"Image","description":"","type":"image"}]}