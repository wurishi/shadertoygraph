{"ver":"0.1","info":{"id":"ttc3Dl","date":"1577931627","viewed":471,"name":"3D Cone SDF","username":"aeva","description":"This code is public domain via CC0.  Stick your name on it, sell it to people, don't give me credit - I DON'T CARE!  Print it out and use it to clean your toilet!","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sdf","cone","cc0"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Written in 2019 by Aeva Palecek\n//\n// To the extent possible under law, the author has dedicated all copyright\n// and related and neighboring rights to this software to the public domain\n// worldwide.  This software is distributed without any warranty.\n//\n// See http://creativecommons.org/publicdomain/zero/1.0/ for more information.\n//\n\n//\n// Some notes about this renderer:\n//\n//  - The coordinate system is right handed with Z up, like Blender.\n//  - View space and world space are the same.\n//  - Ray tracing is relative to world space (or view space).\n//\n\n\nconst vec4 MissColor = vec4(0.0, 0.5, 1.0, 1.0);\nconst vec4 OutlineColor = vec4(MissColor.xyz * 0.5, 1.0);\nconst float AlmostZero = 0.001;\n\n\nfloat Cone(vec3 Local, float BaseRadius, float ConeHeight)\n{\n    float Slope = -ConeHeight / BaseRadius;\n\tfloat Ratio = sqrt(1.0/(Slope * Slope + 1.0));\n    vec2 Test = vec2(abs(length(Local.xy)), Local.z);\n    float Vertical = (Slope * Test.x + ConeHeight - Test.y);\n    float Perpendicular = Vertical * Ratio;\n    return -min(Perpendicular, Test.y);\n}\n\n\nfloat Union(float LHS, float RHS)\n{\n    return min(LHS, RHS);\n}\n\n\nfloat SceneSDF(vec3 View)\n{\n    float Shape = Cone(View - vec3(0.0, 10.0, -1.0), 1.0, 2.0);\n    Shape = Union(Shape, Cone(vec3(View.xy, -View.z) - vec3(-2.0, 10.0, -1.0), 1.0, 2.0));\n    Shape = Union(Shape, Cone(vec3(View.xy, -View.z) - vec3(2.0, 10.0, -1.0), 1.0, 2.0));\n    return Shape;\n}\n\n\nvec3 GetRayDir(vec2 FragCoord, vec2 Resolution, float FOV)\n{\n    float Aspect = Resolution.y / Resolution.x;\n    vec2 NDC = FragCoord / iResolution.xy * 2.0 - 1.0;\n    vec2 Angle = NDC * vec2(FOV, FOV * Aspect) * 0.5;\n    vec3 RayDir = vec3(sin(radians(Angle)), 0.0).xzy;\n    RayDir.y = sqrt(1.0 - (RayDir.x * RayDir.x) - (RayDir.z * RayDir.z));\n    return RayDir;\n}\n\n\nbool RayMarch(vec3 RayDir, float TravelStart, float TravelEnd, out vec3 Position)\n{\n    float Traveled = TravelStart;\n    bool bHit = false;\n    for (int i=0; i<100; ++i)\n    {\n    \tPosition = RayDir * Traveled;\n        float Dist = SceneSDF(Position);\n\t\tTraveled += Dist;\n        bHit = Dist < AlmostZero;\n        if (bHit || Traveled >= TravelEnd)\n        {\n            break;\n        }\n    }\n    return bHit;\n}\n\n\nvec3 Gradient(vec3 Position)\n{\n    float Dist = SceneSDF(Position);\n    return normalize(vec3(\n    \tSceneSDF(vec3(Position.x + AlmostZero, Position.y, Position.z)) - Dist,\n        SceneSDF(vec3(Position.x, Position.y + AlmostZero, Position.z)) - Dist,\n    \tSceneSDF(vec3(Position.x, Position.y, Position.z + AlmostZero)) - Dist));\n}\n\n\nvoid mainImage( out vec4 FragColor, in vec2 FragCoord )\n{\n    vec3 RayDir = GetRayDir(FragCoord.xy, iResolution.xy, 45.0);\n    vec3 Position;\n    bool bHit = RayMarch(RayDir, 1.0, 1000.0, Position);\n    bool bOutline = fwidth(float(bHit)) > 0.0;\n    if (bOutline)\n    {\n        FragColor = OutlineColor;\n    }\n   \telse if (bHit)\n    {\n        vec3 Normal = Gradient(Position);\n        FragColor = vec4(Normal * 0.5 + 1.0, 1.0);\n        if (any(lessThan(mod(Position, 0.5), vec3(0.015))))\n        {\n            FragColor.xyz *= 0.5;\n        }\n    }\n    else\n    {\n        FragColor = MissColor;\n    }\n}\n","name":"Image","description":"","type":"image"}]}