{"ver":"0.1","info":{"id":"tlXBRl","date":"1597421761","viewed":1594,"name":"Raymarching - Soft Shadows","username":"athibaul","description":"An experiment of using raymarching to render soft shadows in a scene by marching toward the light.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","illumination","lighting","softshadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Experimenting with soft cast shadows in raymarching\n//\n// After the standard raymarching loop,\n// illumination is computed using a modified raymarching loop,\n// to detect whether there is any obstruction between\n// the point and the light source.\n// By detecting positive and negative values of the\n// distance field close to zero, a relative\n// occlusion value is computed, resulting in soft shadows.\n\n\n//#define SHOW_OBSTRUCTION // Uncomment to show the obstruction detection only\n\n\nvec3 bands(float x)\n{\n    // Debug function for displaying orange/blue bands for positive/negative numbers.\n    float y = x*5.;\n    vec3 cp = vec3(0.7,0.5,0.1);\n    vec3 cm = vec3(0.1,0.5,0.7);\n    if(y>0.){ if(y-floor(y)<0.5) return cp; return 0.8*cp; }\n    if(y-floor(y)<0.5) return cm; return 0.8*cm;\n}\n\nvec3 colorPattern(vec3 p)\n{\n    //vec3 q = p/length(p);\n    //vec3 col = bands(q.x) + bands(q.y) * bands(q.z);\n    vec3 col = vec3(1.);\n    return col;\n}\n\nfloat sphereSDF(vec3 pos)\n{\n    // Repeating pattern of spheres\n    vec2 turned = vec2(pos.x+pos.y, pos.x-pos.y);\n    turned = 6.0*round(turned/6.0);\n    turned = vec2(turned.x+turned.y, turned.x-turned.y)/2.0;\n    /*pos.x -= 3.*round(pos.x/3.);\n    if(pos.y>-1.5)\n        pos.y -= 3.*round(pos.y/3.);\n\t*/\n    pos.xy -= turned.xy;\n    return length(pos-vec3(0.,0.,1.))-1.;\n}\n\nfloat planeSDF(vec3 pos)\n{\n    // Bottom plane\n    return pos.z+0.4;\n}\n\nfloat floorSDF(vec3 pos)\n{\n    // Just a few tiles\n    // Rounded box distance function by iq\n    // https://www.youtube.com/watch?v=62-pRVZuS5c\n    pos.xy -= 3.*round(pos.xy/3.);\n    vec3 c = vec3(0., 0., -0.2);\n    float rounded = 0.1;\n    vec3 r = vec3(0.75, 0.75, 0.2)-rounded;\n    vec3 q = abs(pos - c) - r;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.) - rounded;\n}\n\nfloat cubeSDF(vec3 pos)\n{\n    // One more box..?\n    vec3 c = vec3(0., -2., 0.3);\n    float rounded = 0.1;\n    vec3 r = vec3(0.5, 0.5, 0.3)-rounded;\n    vec3 q = abs(pos - c) - r;\n    //return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.) - rounded;\n    return 1000.; // Nah.\n}\n\nfloat sceneSDF(vec3 pos)\n{\n    return min(min(sphereSDF(pos), cubeSDF(pos)), min(planeSDF(pos), floorSDF(pos)));\n}\n\n\nvec3 calculateNormal(vec3 pos)\n{\n    // Tetrahedral normal calculation method by iq\n    vec2 e = vec2(0.002,-0.002);\n    return normalize(e.xxx * sceneSDF(pos+e.xxx)\n            + e.xyy * sceneSDF(pos+e.xyy)\n            + e.yxy * sceneSDF(pos+e.yxy)\n            + e.yyx * sceneSDF(pos+e.yyx));\n}\n\nvec3 rayDir(vec3 camFwd, float fov, vec2 uv)\n{\n    // In what direction to shoot?\n    vec3 camUp = vec3(0.,0.,1.);\n    camUp = normalize(camUp - camFwd*dot(camFwd, camUp)); // Orthonormalize\n    vec3 camRight = cross(camFwd, camUp);\n    return normalize(camFwd + (uv.x * camRight + uv.y * camUp)*fov);\n}\n\nfloat calculateObstruction(vec3 pos, vec3 lpos, float lrad)\n{\n    // A homemade algorithm to compute obstruction\n    // Raymarch to the light source, and\n    // record the largest obstruction.\n    // We assume that if the ray passes through an object at depth\n    // d (negative distance), then the object obstructs light\n    // proportional to the relative size of d projected on the light\n    // as given by Thales's theorem.\n    vec3 toLight = normalize(lpos-pos);\n    float distToLight = length(lpos-pos);\n    float d, t=lrad*0.1;\n    float obstruction=0.;\n    for(int j=0; j<128; j++)\n    {\n        d = sceneSDF(pos + t*toLight);\n        obstruction = max(0.5+(-d)*distToLight/(2.*lrad*t), obstruction);\n        if(obstruction >= 1.){break;}\n        // If we're stuck, advance by the characteristic \n        // size of an obstructing object\n        t += max(d, lrad*t/distToLight);\n        if(t >= distToLight) break;\n    }\n    return clamp(obstruction, 0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    // uv.y goes between +-1, and uv.x a bit more depending on the display format.\n\n    // Camera ray\n    vec3 ro = vec3(0., -8., 3.0);\n    vec3 ri = rayDir(normalize(vec3(0.,0.,1.)-ro), 0.5, uv);\n\n    // Normal raytracing\n    float d, t=0.;\n    int cause = -1;\n    int j;\n    for(j=0; j<128; j++)\n    {\n        d = sceneSDF(ro + t*ri);\n        if(d<0.001){break;}\n        if(d>1000.){t=1000.; break; }\n        t += d; // Should be a real metric, otherwise put a *.5 or so here\n    }\n    vec3 pos = ro + t*ri;\n    vec3 normal = calculateNormal(pos);\n    \n    // Compute lighting by marching again to detect obstruction\n    vec3 lpos = vec3(4.*cos(iTime*0.5), 4.*sin(iTime*0.5), 4.*(1.-0.5*cos(iTime*2.)));\n    float lightRadius = 0.6;\n    float lightStrength = 20.0;//length(lpos)*length(lpos);\n    float obstruction = calculateObstruction(pos, lpos, lightRadius);\n    vec3 toLight = normalize(lpos-pos);\n    float distToLight = length(lpos-pos);\n    float diffuse = max(dot(normal, toLight), 0.)\n        /(distToLight*distToLight)\n        *lightStrength;\n    \n    float level = diffuse*(1.-obstruction);\n    vec3 col = level * colorPattern(pos);\n    // Tone mapping\n    col = 1.-exp(-2.*col);\n    \n    // Output to screen\n    #ifndef SHOW_OBSTRUCTION\n    fragColor.rgb = vec3(col);\n    #else\n    fragColor.rgb = vec3(1.-obstruction);\n    #endif\n    \n}","name":"Image","description":"","type":"image"}]}