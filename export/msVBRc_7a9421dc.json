{"ver":"0.1","info":{"id":"msVBRc","date":"1698492259","viewed":100,"name":"Carel S' Audio Visualizer","username":"carel_s","description":"This is an Audio Visualizer inspired by the work of kishimisu and IÃ±igo Quilez that reads audio and uses some parameters like energy or frequency to visualize audio!","likes":4,"published":1,"flags":64,"usePreview":0,"tags":["fft","wave","music","sync","animation","trippy","eq","audiovisualizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dc3zj","filepath":"https://soundcloud.com/careless-baby/lofi-fi-demo","previewfilepath":"https://soundcloud.com/careless-baby/lofi-fi-demo","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n Strobing lights effect warning! Discretion is advised.\n This is a (trippy) Audio Visualizer. Reads the audio file from iChannel0, extracts the fft coefficients and use it for the visuals.\n Also, uses the energy for additional effects.\n*/\n\n#define SAMPLERATE iSampleRate\n// These brackets are required because the preprocessor is dumb\n#define MAX_F (0.25*SAMPLERATE)\n// Reference note for the conversions between note/octave and frequency, a good default is C4, aka middle C, 261.63 Hz\n#define REF_NOTE 261.63\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat cubicInOut(float t) {\n    if (t < 0.5) {\n        return 4.0 * t * t * t;\n    } else {\n        float f = ((2.0 * t) - 2.0);\n        return 0.5 * f * f * f + 1.0;\n    }\n}\n\nfloat progress(float t) {\n    return mix(smoothstep(0.0, 1.0, t), cubicInOut(t), t);\n}\n\nvec2 fishEyeLens(vec2 uv, float strength) {\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    // Convert UV to polar coordinates\n    float radius = length(uv);\n    float angle = atan(uv.y, uv.x);\n\n    // Apply fisheye distortion\n    radius = sqrt(1.0 - exp(-radius * strength)) / sqrt(1.0 - exp(-strength));\n    \n    // Convert back to Cartesian coordinates\n    uv.x = radius * cos(angle);\n    uv.y = radius * sin(angle);\n    uv = 0.5 * (uv + 1.0);\n    \n    // Remap the UV coordinates back to the screen space\n    return uv;\n}\n\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdSnowflakeTriangle(in vec2 p, in float r, in float iterations) {\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r / k;\n    if (p.x + k * p.y > 0.0) {\n        p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0;\n    }\n    p.x -= clamp(p.x, -2.0 * r, 0.0);\n    \n    // Apply the snowflake fractal\n    for (float i = 0.; i < iterations; i++) {\n        p = abs(p) - r;\n        p *= 0.5;\n        p = mat2(cos(3.14159 / 3.0), -sin(3.14159 / 3.0), sin(3.14159 / 3.0), cos(3.14159 / 3.0)) * p;\n    }\n    \n    return -length(p) * sign(p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy; // Clip space\n    vec2 uv0 = uv*2.-1.;\n    uv0.x *= iResolution.x/iResolution.y; // Normalized clip space + aspect ratio\n    vec2 uv1 = uv0;\n\n    //Init color variable\n    vec3 finalColor = vec3(1.0);\n    \n    float buff = 512.; // Audio buffer size\n    float bpm = 78.; // Tempo in bpm\n    float f = bpm / 60.; // Tempo in Hz\n    float T = 1./f;\n    float w = 2.*3.14159*f; // Tempo in rad/s\n    \n    //Fetch frequency data from audio in iCh0\n    //Make it radial\n    float rad = pow(length(uv0),2.)*.24;\n    float rad_buff = rad * buff;\n    float fft = texelFetch(iChannel0, ivec2(rad_buff,0), 0 ).x;\n    \n    //fft(freq/MAX_F);\n    \n    //convert freq to color\n    vec3 col = vec3(fft);\n    col = smoothstep(.0,0.7,col);\n    col *= pal(rad,vec3(0.520,0.520,0.520),vec3(0.500,0.500,0.500),vec3(1.000,1.000,1.000),vec3(6.067,6.350,6.683) );\n    //Compute average energy and energy per band\n    float energy = .0, lows= 0., mids = 0., highs = 0.;\n    for (int i = 0; i<int(buff);++i)\n    {\n        energy += texelFetch(iChannel0, ivec2(i,0),0).x;\n        if (i<int(buff/3.))\n            lows += texelFetch(iChannel0, ivec2(i,0),0).x;\n        else if (i<int(2.*buff/3.))\n            mids += texelFetch(iChannel0, ivec2(i,0),0).x;\n        else\n            highs += texelFetch(iChannel0, ivec2(i,0),0).x;\n    }\n    energy /= buff;\n    lows /= buff/3.;\n    mids /= buff/3.;\n    highs /= buff/3.;\n    \n    //energy will have kind of a sigmoidal shape in the range X(0,1) -> Y(0,1)\n    energy = progress(energy);\n    lows = progress(lows);\n    mids = progress(mids);\n    highs = progress(highs);\n    float numIterations = energy * 3.0; //same shape scaled X(0,1) -> Y(0,3)\n    numIterations = smoothstep(0.,1.,numIterations);\n    \n    //spherical contour\n    float r = 0.3;\n    float sph = 1.0;\n    sph = length(uv1* lows);\n    sph -= 6.*r;\n    sph = abs(sph);\n    sph = smoothstep(0.2,1.,sph);\n    \n    finalColor *= sph;\n    finalColor *= col;\n    //for (float i = 0.; i<1.;i++){\n        float tri= 1.0;\n        tri = sdSnowflakeTriangle(uv1,r*energy*T,3.);\n        tri = abs(tri);\n        tri = smoothstep(.0,1.,tri);\n        //tri = smoothstep(0.,1.,tri);\n        //tri = sdEquilateralTriangle(uv1,r*energy*1.5);\n        tri = sin(100.*tri + sin(0.5*T*iTime)*2./T)/100.;\n        tri = abs(tri);\n        tri = energy*0.02/tri;\n        //tri *= 1./numIterations;\n\n        col*=tri;\n    //}\n    finalColor*=col;\n    //HDR\n    finalColor = finalColor / (finalColor + vec3(1.0));\n    finalColor = pow(finalColor, vec3(1.0/2.2));\n    \n    fragColor = vec4(finalColor, 1.);\n    \n    \n}\n","name":"Image","description":"","type":"image"}]}