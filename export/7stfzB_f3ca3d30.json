{"ver":"0.1","info":{"id":"7stfzB","date":"1656746082","viewed":436,"name":"Eye of Phi","username":"ChunderFPV","description":"Math art.  Contains a few grid transforms.  Mouse x to change the exponent.  Mouse y to zoom.\n\nUpdate 11/15/22: Now with anti-aliasing.","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["2d","grid","math","loopless","metallicratios"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 RGBA, in vec2 XY )\n{\n    float t = iTime/PI*2.0;\n    vec4 m = iMouse; m.xy = m.xy*2.0/R-1.0; // ±1x, ±1y\n    if (m.z > 0.0) t += m.y*SCALE; // move time with mouse y\n    float z = (m.z > 0.0) ? pow(1.0-abs(m.y), sign(m.y)): 1.0; // zoom (+)\n    float e = (m.z > 0.0) ? pow(1.0-abs(m.x), -sign(m.x)): 1.0; // screen exponent (+)\n    float se = (m.z > 0.0) ? e*-sign(m.y): 1.0; // spiral exponent\n    vec3 bg = vec3(0); // black background\n    \n    float aa = 3.0; // anti-aliasing\n    for (float j = 0.0; j < aa; j++)\n    for (float k = 0.0; k < aa; k++)\n    {\n        vec3 c = vec3(0);\n        vec2 o = vec2(j, k)/aa;\n        vec2 uv = (XY-0.5*R+o)/R.y*SCALE*z; // apply cartesian, scale and zoom\n        if (m.z > 0.0) uv = exp(log(abs(uv))*e)*sign(uv); // warp screen space with exponent\n\n        float px = length(fwidth(uv)); // pixel width\n        float x = uv.x; // every pixel on x\n        float y = uv.y; // every pixel on y\n        float l = length(uv); // hypot of xy: sqrt(x*x+y*y)\n\n        float mc = (x*x+y*y-1.0)/y; // metallic circle at xy\n        float g = min(abs(mc), 1.0/abs(mc)); // gradient\n        vec3 gold = vec3(1.0, 0.6, 0.0)*g*l;\n        vec3 blue = vec3(0.3, 0.5, 0.9)*(1.0-g);\n        vec3 rgb = max(gold, blue);\n\n        float w = 0.1; // line width\n        float d = 0.4; // shadow depth\n        c = max(c, gm(rgb, mc, -t, w, d, false)); // metallic\n        c = max(c, gm(rgb, abs(y/x)*sign(y), -t, w, d, false)); // tangent\n        c = max(c, gm(rgb, (x*x)/(y*y)*sign(y), -t, w, d, false)); // sqrt cotangent\n        c = max(c, gm(rgb, (x*x)+(y*y), t, w, d, true)); // sqrt circles\n\n        c += rgb*ds(uv, se, t/TAU, px*2.0, 2.0, 0.0); // spiral 1a\n        c += rgb*ds(uv, se, t/TAU, px*2.0, 2.0, PI); // spiral 1b\n        c += rgb*ds(uv, -se, t/TAU, px*2.0, 2.0, 0.0); // spiral 2a\n        c += rgb*ds(uv, -se, t/TAU, px*2.0, 2.0, PI); // spiral 2b\n        c = max(c, 0.0); // clear negative color\n\n        c += pow(max(1.0-l, 0.0), 3.0/z); // center glow\n\n        if (m.z > 0.0) // display grid on click\n        {\n            vec2 xyg = abs(fract(uv+0.5)-0.5)/px; // xy grid\n            c.gb += 0.2*(1.0-min(min(xyg.x, xyg.y), 1.0));\n        }\n        bg += c;\n    }\n    bg /= aa*aa;\n    bg *= sqrt(bg)*1.5;\n    \n    RGBA = vec4(bg, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define SCALE 8.0\n#define R iResolution.xy\n#define PI radians(180.0)\n#define TAU (PI*2.0)\n#define CS(a) vec2(cos(a), sin(a))\n#define PT(u,r) smoothstep(0.0, r, r-length(u))\n\n// gradient map ( color, equation, time, width, shadow, reciprocal )\nvec3 gm(vec3 c, float n, float t, float w, float d, bool i)\n{\n    float g = min(abs(n), 1.0/abs(n));\n    float s = abs(sin(n*PI-t));\n    if (i) s = min(s, abs(sin(PI/n+t)));\n    return (1.0-pow(abs(s), w))*c*pow(g, d)*6.0;\n}\n\n// denominator spiral, use 1/n for numerator\n// ( screen xy, spiral exponent, decimal, line width, hardness, rotation )\nfloat ds(vec2 u, float e, float n, float w, float h, float ro)\n{\n    float ur = length(u); // unit radius\n    float sr = pow(ur, e); // spiral radius\n    float a = round(sr)*n*TAU; // arc\n    vec2 xy = CS(a+ro)*ur; // xy coords\n    float l = PT(u-xy, w); // line\n    float s = mod(sr+0.5, 1.0); // gradient smooth\n    s = min(s, 1.0-s); // darken filter\n    return l*s*h;\n}\n","name":"Common","description":"","type":"common"}]}