{"ver":"0.1","info":{"id":"ddlyRX","date":"1687059309","viewed":85,"name":"Newton Iterations","username":"EthanKim8683","description":"I'm learning multivar over the summer. I figured I'd practice with some newton iterations!","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["newtoniterations"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 ray = normalize(vec3((fragCoord * 2.0 - iResolution.xy) / iResolution.y, 1.0));\n    rotatePitch(ray, CAMERA_PITCH);\n    rotateYaw(ray, CAMERA_YAW);\n    \n    float l = texture(iChannel0, fragCoord.xy / iResolution.xy).x;\n    \n    // Shading\n    vec3 target = CAMERA_POSITION + ray * l;\n    if (abs(f(target)) <= HIT_EPSILON) {\n        vec3 normal = normalize(df(target));\n        vec3 light = normalize(LIGHT_POSITION - CAMERA_POSITION);\n        \n        float a = dot(normal, light), b = a * a;\n        b *= b;\n        b *= b;\n        b *= b;\n        b *= b;\n        b *= b;\n        b *= a;\n        a = max(a, 0.0);\n        b = max(b, 0.0);\n    \n        float shading = 30.0 * (a * 0.5 + b * 0.8 + 0.5) / (target.z + 30.0) / 255.0;\n        ivec3 iTarget = abs(ivec3(target * 50.0));\n        fragColor = vec4(shading * float(60 + ((iTarget.y ^ iTarget.z) & 255)),\n                         shading * float(30 + ((iTarget.x ^ iTarget.z) & 255)),\n                         shading * float(40 + ((iTarget.x ^ iTarget.y) & 255)),\n                         1.0);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"precision highp float;\n\n// Rendering constants\nconst int ITERATIONS = 20;\nconst float HIT_EPSILON = 1e-3;\nconst float DF_EPSILON = 6e-6;\n\n// Scene constants\nconst vec3 CAMERA_POSITION = vec3(0.0, 24.0, -9.0);\nconst vec3 LIGHT_POSITION = vec3(2.0, 30.0, -5);\nconst float CAMERA_PITCH = -0.5;\nconst float CAMERA_YAW = 0.1;\n\n// Function to be drawn\nfloat f(vec3 p) {\n    float c1 = cos(p.y), s1 = sin(p.y);\n    float c2 = cos(p.y * 0.5), s2 = sin(p.y * 0.5);\n    \n    float tx = p.x - c1 + 4.0, tz = p.z - c1 + 4.0;\n    \n    tx = fract(tx / 8.0) * 8.0;\n    tx = min(tx, 8.0 - tx);\n    \n    if (tz > 0.0) {\n        tz = fract(tz / 8.0) * 8.0;\n        tz = min(tz, 8.0 - tz);\n    }\n    \n    float x = tx * c2 - tz * s2;\n    float z = tx * s2 + tz * c2;\n    \n    return x * x * x * x + z * z * z * z - 1.0;\n}\n\n// Gradient function\nvec3 df(vec3 p) {\n    float t = f(p);\n    \n    return (vec3(f(p + vec3(DF_EPSILON, 0, 0)),\n                 f(p + vec3(0, DF_EPSILON, 0)),\n                 f(p + vec3(0, 0, DF_EPSILON))) - t) / DF_EPSILON;\n}\n\n// Rotation functions\nvoid rotatePitch(inout vec3 ray, float pitch) {\n    float s = sin(pitch), c = cos(pitch);\n    ray = vec3(ray.x, ray.z * s + ray.y * c, ray.z * c - ray.y * s);\n}\n\nvoid rotateYaw(inout vec3 ray, float yaw) {\n    float s = sin(yaw), c = cos(yaw);\n    ray = vec3(ray.z * s + ray.x * c, ray.y, ray.z * c - ray.x * s);\n}\n\n// Trace function\nvoid trace(vec3 ray, float nL, inout float pL) {\n    for (int i = 0; i < ITERATIONS; i++) {\n        vec3 target = CAMERA_POSITION + ray * nL;\n        nL -= f(target) / dot(df(target), ray);\n        \n        float pAbsErr = abs(f(CAMERA_POSITION + ray * pL));\n        float nAbsErr = abs(f(CAMERA_POSITION + ray * nL));\n        if (nAbsErr <= HIT_EPSILON ? pAbsErr >= HIT_EPSILON || nL < pL : nAbsErr < pAbsErr) pL = nL;\n    }\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 ray = normalize(vec3((fragCoord * 2.0 - iResolution.xy) / iResolution.y, 1.0));\n    rotatePitch(ray, CAMERA_PITCH);\n    rotateYaw(ray, CAMERA_YAW);\n    \n    // Sample self and neighbors\n    float l = texture(iChannel0, fragCoord.xy / iResolution.xy).x;\n    trace(ray, l, l);\n    trace(ray, texture(iChannel0, (fragCoord.xy + vec2(-1.0,  0.0)) / iResolution.xy).x, l);\n    trace(ray, texture(iChannel0, (fragCoord.xy + vec2( 0.0, -1.0)) / iResolution.xy).x, l);\n    trace(ray, texture(iChannel0, (fragCoord.xy + vec2( 0.0,  1.0)) / iResolution.xy).x, l);\n    trace(ray, texture(iChannel0, (fragCoord.xy + vec2( 1.0,  0.0)) / iResolution.xy).x, l);\n    \n    fragColor = vec4(l);\n}","name":"Buffer A","description":"","type":"buffer"}]}