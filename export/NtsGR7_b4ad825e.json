{"ver":"0.1","info":{"id":"NtsGR7","date":"1621786811","viewed":36,"name":"Raymarching experiment 2","username":"diogotito","description":"Learning from https://www.youtube.com/watch?v=PGtv-dBi2wE (Ray Marching for Dummies!, The Art of Code)\nBut I tried to go on my own somewhere in the middle so some parts are clunky, unoptimized or downright wrong.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"sls3R4","parentname":"Raymarching t46STeWejQmoADECte5i"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 500.0\n#define HIT_DIST .02\n\n// .006 to maximize weird rings in floor\n\n\nstruct RayMarchResult {\n    float marchedDist;\n    vec3 point;\n    vec3 normal;\n    vec3 color;\n};\n\n\n///////////////////////////////////////////////////////////\n//\n//  DISTANCE FUNCTIONS\n//\n///////////////////////////////////////////////////////////\n\nfloat Sphere( vec3 p, vec3 c, float r ) {\n    return distance(p, c) - r;\n}\n\n\nfloat Capsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    return Sphere( p, a + t * ab, r );\n}\n\n\nfloat Torus( vec3 p, vec3 center, float radius, float thickness ) {\n    p -= center;\n    \n    float dx = length(p.xz) - radius;\n    float dy = p.y;\n    \n    return length(vec2(dx, dy)) - thickness;\n}\n\nfloat Box( vec3 p, vec3 center, vec3 size ) {\n    return length(max(abs(p-center) - size, 0.));\n}\n\n\n//\n// Distance from point P to scene\n//\nvec4 CalculateDistance( vec3 p ) {\n    float dancingY = 1.5f + .1f * sin(4.56 * iTime);\n    vec3 wiggly1 = vec3(-.3*cos(3.*iTime), -.4*cos(5.*iTime+943.), .2*sin(10.*iTime+12.));\n    vec3 wiggly2 = vec3(.1*cos(5.*iTime+13.), -.3*cos(3.*iTime+543.), .2*sin(5.*iTime+123.));\n\n    vec4 sceneSphere = vec4(vec3(0, dancingY, 6), /* radius */ 1);\n    \n    float sceneFloor = 0.0f;\n    \n    struct CapsuleData {\n        vec3 A;\n        vec3 B;\n        float r;\n    } sceneCapsule = CapsuleData(\n        vec3(3, 1, 9) + wiggly1,\n        vec3(3, 2, 9) + wiggly2,\n        0.5f\n    );\n    \n    struct TorusData {\n        vec3 center;\n        float radius;\n        float thickness;\n    } sceneTorus = TorusData(\n        vec3(0, 2.2, 6) + 0.2*vec3(cos(10.*iTime), 0, sin(10.*iTime)),\n        1.f,\n        .15f\n    );\n    \n    struct BoxData {\n        vec3 center;\n        vec3 size;\n    } sceneBox = BoxData(\n        vec3(-2.5, 1, 5.5),\n        vec3(0.5, 1, 0.5)\n    );\n    \n    float boxDist = Box( p, sceneBox.center, sceneBox.size );\n    float torusDist = Torus( p, sceneTorus.center, sceneTorus.radius, sceneTorus.thickness );\n    float capsuleDist = Capsule( p, sceneCapsule.A, sceneCapsule.B, sceneCapsule.r );\n    float sphereDist = Sphere( p, sceneSphere.xyz, sceneSphere.w );\n    float floorDist = distance(p.y, sceneFloor);\n    \n    struct ReturnValue {\n        vec3 color;\n        float dist;\n    } r = ReturnValue(\n        vec3(0.4, 0.8, 0.95),  // Sky\n        MAX_DIST\n    );\n\n    if (sphereDist > MAX_DIST) {\n        return vec4(r.color, r.dist);  // Sky\n    }\n    \n    // Naive materials. So naive I needed to make a macro for this\n    \n    #define TEST_DIST(someDist, someColor)  \\\n                                            \\\n                if (someDist < r.dist) {    \\\n                    r.color = someColor;    \\\n                    r.dist = someDist;      \\\n                }\n\n    //        |  someDist:  |         color:         |\n    //--------|-------------|------------------------|\n    TEST_DIST ( sphereDist  , vec3(0.95, 0.70, 0.80) )\n    TEST_DIST ( floorDist   , vec3(0.80, 0.60, 0.50) )\n    TEST_DIST ( capsuleDist , vec3(0.70, 0.80, 0.50) )\n    TEST_DIST ( torusDist   , vec3(0.85, 0.15, 0.05) )\n    TEST_DIST ( boxDist     , vec3(0.95, 0.95, 0.95) )\n    \n    return vec4(r.color, r.dist);\n}\n\n\n\n/*************************************************************************************\n * Raymarching algorithm:\n *------------------------------------------------------------------------------------\n * 1. March!\n * 2. Calculate the distance from the nearest point in the scene from where we stand.\n * 3. We'll walk that distance when we march further\n * 4. Don't march further if we either got close enough or too far for our liking\n * 5. Try to calculate normal like in high school\n *************************************************************************************/\n\nvec3 GetNormal( vec3 p );\n\nRayMarchResult RayMarch( in vec3 camPos, in vec3 rayDir ) {\n    float dO = 0.;\n    float sceneDist;\n    vec3 p;\n    vec4 d;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        // 1.\n        p = camPos + dO * rayDir;\n    \n        // 2. & 3.\n        d = CalculateDistance( p );\n        sceneDist = d.w;\n        dO += sceneDist;\n        \n        // 4.\n        if (sceneDist < HIT_DIST || sceneDist > MAX_DIST) {\n            break;\n        }\n    }\n    \n    return RayMarchResult(dO, p, GetNormal( p ), d.rgb);\n}\n\nvec3 GetNormal( vec3 p ) {\n    float d = CalculateDistance( p ).w;\n    \n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = d - vec3(\n            CalculateDistance( p - e.xyy ).w,\n            CalculateDistance( p - e.yxy ).w,\n            CalculateDistance( p - e.yyx ).w\n    );\n    \n    return normalize(n);\n}\n\nfloat Lighting( RayMarchResult r, vec3 lightPos, float diff, float spec, float phongExp ) {\n    \n    vec3 lightDir = normalize(lightPos - r.point);\n    \n    float light = clamp(dot(r.normal, lightDir), 0., 1.);\n    \n    float ambient  = 0.05;\n    float diffuse  = diff * light;\n    float specular = spec * pow(light, phongExp);\n    \n    light = diffuse + specular;\n    \n    if (RayMarch( r.point + r.normal * HIT_DIST * 3., lightDir ).marchedDist < distance(r.point, lightDir) - HIT_DIST * 2.) {\n        light *= 0.15;\n    }\n    \n    light += ambient;\n    \n    // Try to mix light & depth in an interesting way\n    //return r.marchedDist /12.;\n    //return light * .5 + r.marchedDist * 0.02;\n    return light;\n}\n\n\nvec3 Shading( RayMarchResult r, vec3 rayDir ) {\n    vec3 keyLightPos = vec3(0, 4, 5);\n    keyLightPos.xz += vec2(sin(iTime), cos(iTime)) * 3.;\n    \n    float light = 0.05;\n    light += .9 * Lighting( r, keyLightPos,    0.60, 0.35, 20. );  // \"key\" light?\n    light += .6 * Lighting( r, vec3(-3, 1, 0), 0.90, 0.10, 20. );  // \"fill\" light?\n    light += .5 * Lighting( r, vec3(0, 1, 15), 0.90, 0.05, 10. );  // \"back\" light? \n    \n    float sky = 1.2-length(rayDir.xy*vec2(0.3, 0.6));\n    \n    return (r.marchedDist < MAX_DIST + 10. ? light : sky) * r.color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 camPos = vec3(0, 2.3, 0);\n    vec3 rayDir = normalize(vec3(uv, 0.8));\n    \n    camPos.x = 2. + 2. * sin(iTime);\n    camPos.y = 3. + .5 * cos(iTime);\n    rayDir.x -= .3*(1.+sin(iTime));\n    rayDir.y -= .2*(1.+cos(iTime));\n    rayDir = normalize(rayDir);\n    \n    RayMarchResult r = RayMarch( camPos, rayDir );\n    \n    //vec3 col = vec3(r.marchedDist / 6.);\n    //vec3 col = 0.5 + 0.5 * r.normal;\n    vec3 col = Shading( r, rayDir );\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}