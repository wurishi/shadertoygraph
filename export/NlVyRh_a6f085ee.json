{"ver":"0.1","info":{"id":"NlVyRh","date":"1661058094","viewed":111,"name":"Practical Noise Exercise","username":"H2ongzh","description":" \nReference:\nhttp://www.science-and-fiction.org/rendering/noise.html\nhttps://thebookofshaders.com/12/","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: HongZhang\n// Date: 08/20/2022\n// practices for noise generation\n#define PI 3.141592653\n\n// pseudo-random noise\nfloat Random2D(vec2 uv){\n    return fract(sin(dot(uv, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 Random2V(vec2 uv) {\n    return fract(sin(vec2(dot(uv,vec2(127.1,311.7)),dot(uv,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat Random3D(vec3 uvw){\n    return fract(sin(dot(uvw ,vec3(12.9898,78.233,144.7272))) * 43758.5453);\n}\n\n\n// bilinear interpolation\nfloat linearInterpolate(float a, float b, float t){\n    return a + (b - a) * clamp(t, 0., 1.);\n}\n\n// smooth interpolation\nfloat smoothInterpolate(float a, float b, float t){\n    return a + (b - a) * smoothstep(0., 1., t);\n}\n\n\n// 2D perlin noise\nfloat perlin2D(vec2 uv, float frequence){\n    uv = uv * frequence;\n    vec2 i_uv = uv - fract(uv); // integer\n    vec2 f_uv = fract(uv);  // fraction\n    \n    float s1 = Random2D(i_uv);\n    float s2 = Random2D(vec2(i_uv.x + 1., i_uv.y));\n    float s3 = Random2D(vec2(i_uv.x + 1., i_uv.y + 1.));\n    float s4 = Random2D(vec2(i_uv.x, i_uv.y + 1.));\n    \n    float s12 = smoothInterpolate(s1, s2, f_uv.x);\n    float s34 = smoothInterpolate(s4, s3, f_uv.x);\n    \n    return smoothInterpolate(s12, s34, f_uv.y);   \n}\n\n// linear combinations of multiple octaves of perlin noise\nfloat multipleOctavePerlin(vec2 uv, float frequence, int n_octaves){\n    float sum = 0.;\n    for(int i = 0; i<n_octaves; ++i){\n        sum += perlin2D(uv, frequence * pow(2., float(i)));\n    }\n    return sum/float(n_octaves);\n}\n\n\n// Sparse Dot Noise \nfloat dotNoise2D(vec2 uv, float frequence, float max_dot_size, float density){\n    uv = uv * frequence;\n    vec2 i_uv = uv - fract(uv); // integer\n    vec2 f_uv = fract(uv);  // fraction\n    \n    float s1 = Random2D(i_uv);\n    float s2 = Random2D(vec2(i_uv.x + 1., i_uv.y));\n    float s3 = Random2D(vec2(i_uv.x + 1., i_uv.y + 1.));\n    float s4 = Random2D(vec2(i_uv.x, i_uv.y + 1.));\n    \n    if(s1 > density){\n        return 0.;\n    }\n    \n    float radius = max(0.08, s2) * max_dot_size;\n    float pos_x = 0.5 + (s3 - 0.5) * (1. - 2. * radius);\n    float pos_y = 0.5 + (s4 - 0.5) * (1. - 2. * radius);\n    vec2 pos = vec2(pos_x, pos_y);\n    \n    float dist = length(pos - f_uv); // from the current point to the pos\n    \n    return 1. - smoothstep(0.3 * radius, radius, dist);\n}\n\n// cellular noise (kinda similar to the sparse dot noise)\nfloat cellNoise(vec2 uv, float frequence){\n    uv = uv * frequence;\n    vec2 i_uv = uv - fract(uv); // integer\n    vec2 f_uv = fract(uv);  // fraction\n    float min_dist = 0.;\n    for(int i = -1; i <= 1; ++i){\n        for(int j = -1; j <= 1; ++j){\n            vec2 neighbor = vec2(float(i), float(j));\n            vec2 pos = Random2V(i_uv + neighbor);\n            pos = 0.5 + 0.5 * sin(pos * pos * PI * iTime);\n            float dist = length(neighbor + pos - f_uv); // min() or other operations\n            min_dist += exp2(dist*-25.);\n        }\n    }\n    return -(1./25.) * log2(min_dist);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float noise = Random2D(uv);\n    \n    // noise = Random3D(vec3(uv,1.));\n    // noise = perlin2D(uv, 4.);\n    // float a = multipleOctavePerlin(vec2(0.1*uv.x, 0.9*uv.y), 2.,4);\n    // float b = multipleOctavePerlin(vec2(0.2*uv.x, 0.43*uv.y), 2.,9);\n    // noise = multipleOctavePerlin(uv + vec2(a, b), 2., 6);\n    \n    // float fraction = 0.5;\n    // float transition = 0.1;\n    // noise = smoothstep(fraction - transition, fraction + transition, noise);\n    // noise = dotNoise2D(uv, 10., 0.2, 0.5);  \n     noise = cellNoise(uv, 5.);\n    fragColor = vec4(vec3(uv, exp(-noise)) * noise, 1.);\n\n}","name":"Image","description":"","type":"image"}]}