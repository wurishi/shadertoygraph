{"ver":"0.1","info":{"id":"ftsGRn","date":"1622491429","viewed":231,"name":"Rainbows in Space","username":"ccincotti3","description":"Really wanted to work with curves and ended up making a scene by accident. I have a lot of work to do with learning how to properly light in a scene, but I thought this looked nice enough and decided to just hit publish and walk away from this one.","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["space","curves","rainbow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 100.\n\nfloat rand(vec2 co){return fract(sin(dot(co.xy,vec2(12.9898,78.233)))*43758.5453);}\n\nmat2 Rot(float a){\n    float s=sin(a),c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdfPlanet(vec3 p,float r){\n    return length(p)-r;\n}\n\nfloat map(vec3 p){\n    mat2 rot=Rot(iTime*.08);\n    \n    vec3 bp=p;\n    bp.xz*=rot;\n    \n    float d=sdfPlanet(bp,.4);\n    d+=texture(iChannel2,bp.xy*3.).r*.015;\n    return d;\n}\n\nfloat castRay(vec3 ro,vec3 rd){\n    float dt=0.;\n    for(int i=0;i<100;i++){\n        vec3 p=ro+rd*dt;\n        float dx=map(p);\n        dt+=dx;\n        if(dx<.001||dt>MAX_DIST)break;\n        \n    }\n    \n    return dt;\n}\n\nvec3 CalcNormal(vec3 p){\n    vec2 e=vec2(.01,0);\n    float res=map(p);\n    vec3 n=res-vec3(\n        map(p-e.xyy),\n        map(p-e.yxy),\n        map(p-e.yyx)\n    );\n    return normalize(n);\n}\n\nvec3 rayDir(vec2 uv,vec3 ro,vec3 lookAt,float zoom){\n    vec3 globalUp=vec3(0,1,0);\n    vec3 forward=normalize(lookAt-ro);\n    vec3 right=normalize(cross(globalUp,forward));\n    vec3 up=cross(forward,right);\n    vec3 center=forward*zoom;//center of screen\n    vec3 i=center+uv.x*right+uv.y*up;\n    \n    return normalize(i);\n}\n\nfloat stars(vec2 uv,float time){\n    vec2 fuv=fract(uv*20.);\n    vec2 fluv=floor(uv*40.);\n    float res;\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            vec2 offs=vec2(x,y);\n            float r=rand(fluv+offs);\n            float l=length(fuv-offs-r);\n            float d=(.02*r*r/l);\n            d=smoothstep(.01,1.,d);\n            res+=d*((1.-sin(r*r*time*2.)));\n            res-=max(uv.y-uv.x-.5,0.);\n        }\n    }\n    return clamp(res,.01,1.);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // Setup Cam\n    vec3 ro=vec3(0.,.0,-1.);\n    mat2 rot=Rot(iTime*.08);\n    mat2 crot=Rot(1.5);\n    vec3 lookAt=vec3(-.13,.19,-.5);\n    \n    float zoom=1.;\n    vec3 rd=rayDir(uv,ro,lookAt,zoom);\n    \n    // cast a ray, get the distance.\n    \n    float d=castRay(ro,rd);\n    \n    vec3 p=ro+rd*d;\n    \n    vec3 n=CalcNormal(p);\n    n.xz*=rot;\n    p.xz*=rot;\n    \n    vec3 col=vec3(.4,.1,.1);\n    \n    // color what's been hit.\n    if(d<MAX_DIST){\n        vec3 colXZ=texture(iChannel0,p.xz).rgb;\n        vec3 colYZ=texture(iChannel0,p.yz).rgb;\n        vec3 colXY=texture(iChannel0,p.xy).rgb;\n        vec3 na=abs(n);\n        col=colYZ*na.x+colXZ*na.y+colXY*na.z;\n        float dc=texture(iChannel2,p.xy*3.).r*.015;\n        col*=vec3(.2,.2,.2)*4.;\n        col+=dc*vec3(.5,.3,.3)*40.;\n    }else{\n        col+=stars(uv,iTime)*1.;\n    }\n    \n    // Lighting\n    n.xz*=inverse(rot);\n    \n    vec3 light=vec3(.5);\n    vec3 sun_lig=normalize(vec3(-.5,.45,-.3));\n    float sun_dif=clamp(dot(n,sun_lig),0.,1.);\n    light+=sun_dif*vec3(.6,.6,.6);\n    \n    vec3 sky_lig=normalize(vec3(0.,.5*n.y+.5,0.));\n    float sky_dif=clamp(dot(n,sky_lig),0.,1.);\n    light+=sky_dif*vec3(.3,.05,.01);\n    \n    vec3 planet_lig=normalize(vec3(-.05,.03,.4));\n    float planet_dif=smoothstep(.9,1.,clamp(dot(n,planet_lig),0.,1.))*4.;\n    light+=planet_dif*vec3(.2,1.,1.);//+n*-0.1;\n    \n    col*=light;\n    vec2 pv=fragCoord/iResolution.xy;\n    vec3 curve=texture(iChannel1,pv).rgb;\n    col+=curve;\n    \n    uv-=vec2(-.58,.35);\n    vec2 bfuv=abs(uv*mat2(2.5,0,1.4,1.7))*mat2(2,sin(iTime)*.2-2.,sin(iTime)*.4-.5,1.5);\n    float bright_flare=.1/max(bfuv.x,bfuv.y)*smoothstep(-.7,1.,uv.x);\n    \n    col+=bright_flare*1.*vec3(.8,.9,.6);\n    \n    // Output to screen\n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Rainbow curves that I'm super happy with.\nvec3 TEAL=vec3(.286,.855,.604);\nvec3 L_BLUE=vec3(.204,.733,.902);\nvec3 BLUE=vec3(.263,.333,.856);\nvec3 VIOLET=vec3(.824,.231,.906);\nvec3 RED=vec3(.902,.149,.122);\nvec3 ORANGE=vec3(.922,.456,.196);\nvec3 YELLOW=vec3(.639,.878,.282);\n\nfloat smin(float a,float b,float k){\n    float h=clamp((b-a)/k+.5,0.,1.);\n    return h*a+(1.-h)*b-h*(1.-h)*k*.5;\n}\n\nfloat rainbowCurve(vec2 uv,float r,float a,float s){\n    float S=sign(uv.x);\n    float C=-S*sqrt(pow(r,2.)-pow((uv.x*a)-((1.-r)*-S)-S,2.))-uv.y;\n    float L=8.*(uv.x+0.)-uv.y;\n    float L2=5.*(uv.x+.9)-uv.y;\n    \n    float Cm=smin(L2,C,6.);\n    return smin(Cm,L,-8.);\n}\n\nfloat drawRainbowCurve(vec2 uv,float r){\n    return smoothstep(.06,0.,abs(rainbowCurve(vec2(uv.y,-uv.x)*1.-vec2(.1,-1.4),r,8.,15.)));\n}\n\n// Noise code for the cloud stuff taken from The Art of Code\n// Shader https://www.shadertoy.com/view/3d23z1\n// YouTube https://www.youtube.com/watch?v=zXsWftRdsvU\nfloat N21(vec2 p){\n    return fract(sin(p.x*100.+p.y*6574.)*5647.);\n}\n\nfloat SmoothNoise(vec2 uv){\n    vec2 lv=fract(uv);\n    vec2 id=floor(uv);\n    \n    lv=lv*lv*(3.-2.*lv);\n    \n    float bl=N21(id);\n    float br=N21(id+vec2(1,0));\n    float b=mix(bl,br,lv.x);\n    \n    float tl=N21(id+vec2(0,1));\n    float tr=N21(id+vec2(1,1));\n    float t=mix(tl,tr,lv.x);\n    \n    return mix(b,t,lv.y);\n}\n\nfloat SmoothNoise2(vec2 uv){\n    float c=SmoothNoise(uv*4.);\n    \n    // don't make octaves exactly twice as small\n    // this way the pattern will look more random and repeat less\n    c+=SmoothNoise(uv*8.2)*.5;\n    c+=SmoothNoise(uv*16.7)*.25;\n    c+=SmoothNoise(uv*32.4)*.125;\n    c+=SmoothNoise(uv*64.5)*.0625;\n    \n    c/=2.;\n    \n    return c;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col=vec3(0.);\n    float c=SmoothNoise2(uv);\n    float l=SmoothNoise2(uv+1.);\n    float g=SmoothNoise2(uv+2.*iTime*.01);\n    \n    col+=l*vec3(.2,.1,.3)*.1;\n    col+=c*vec3(.2,.3,.3)*.2;\n    col+=g*vec3(.1,.5,.2)*.7;\n    col*=.8-uv.x*1.5-1.+uv.y;\n    \n    float r=3.;\n    float dr=.09;\n    for(int i=14;i>0;i--){\n        vec3 drawCol;\n        if(i>12){\n            drawCol=TEAL;\n        }else if(i>10){\n            drawCol=L_BLUE;\n        }else if(i>8){\n            drawCol=BLUE;\n        }else if(i>6){\n            drawCol=VIOLET;\n        }else if(i>4){\n            drawCol=RED;\n        }else if(i>2){\n            drawCol=ORANGE;\n        }else{\n            drawCol=YELLOW;\n        }\n        float curve=drawRainbowCurve(uv,r-dr*float((14-i)));\n        float depth=clamp(.35-uv.y,0.,1.);\n        float light=clamp(2.+sin(iTime*3.+float(i)),1.,5.);\n        col+=curve*drawCol*light*depth;\n        \n    }\n    fragColor=vec4(col,1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}