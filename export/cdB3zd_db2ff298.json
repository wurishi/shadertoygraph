{"ver":"0.1","info":{"id":"cdB3zd","date":"1668010982","viewed":77,"name":"SDF_LOGO","username":"bigDreamer","description":"Ningbo University Badge","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","logo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float tmin = 0.01;\nconst float tmax = 80.0;\n\nvec2 fixUV( in vec2 fc)\n{\n    return (2.0 * fc - iResolution.xy) / min(iResolution.x,iResolution.y);\n}\n\nmat3 setCamera(vec3 ro,vec3 t,float theta)\n{\n    vec3 z = normalize(t - ro);\n    vec3 cp = normalize( vec3(sin(theta),cos(theta),0.) );\n    vec3 x = normalize(cross(z , cp));\n    vec3 y = normalize( cross(x,z) );\n    return mat3(x,y,z);\n}\n\n/*\nSDFs\n*/\n\n//图标外框\nfloat sdTorus( vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat plane(vec3 p)\n{\n\n    return p.y;\n}\n\nfloat sdBox( vec3 p,in vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return length( max( d , 0.0) ) + min( max( d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdSphere( vec3 p,float r)\n{\n    return length(p) - r;\n}\n//三棱柱\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n//三角形\nfloat Triangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 vec2Min(vec2 a,vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\n/*\n    None -1 \n    Sphere : 0\n    Plane : 1\n    Box : 2\n    Torus : 3\n    TriPrism : 4\n    Tri : 5\n    Cylinder：6\n*/\n\n//并集操作\nfloat opUnion(float d1,float d2)\n{\n    return min(d1,d2);\n}\n\n//交集操作\nfloat opInter(float d1,float d2)\n{\n    return max(d1,d2);\n}\n\n//减法操作.注意是从d1中减去d2\nfloat opSub(float d1,float d2)\n{\n    return opInter(d1,-d2);\n}\nvec2 map( vec3 p )\n{\n    float floor = plane(p);\n    vec2 plane = vec2(floor,1.);\n\t\n\tvec3 vvv = p - vec3(0.,1.05,0.0);\n\tvvv = vec3(vvv.x,vvv.z,vvv.y);\n    float outer_d = sdCappedCylinder(vvv,0.95,0.03);\n\n    float minus_outer_d = sdCappedCylinder(vvv,0.90,0.1);\n    vec2 outer = vec2(opSub(outer_d,minus_outer_d),3.);\n    float inner_d = sdCappedCylinder(vvv,0.75,0.03);\n\n    float minus_inner_d = sdCappedCylinder(vvv,0.70,0.1);\n    vec2 inner = vec2(opSub(inner_d,minus_inner_d),3.);\n\n\tvvv = p - vec3(0.0,1.15,0.0) ;\n    float building_d = sdBox(vvv,vec3(0.32,0.35,0.01));\n\n\tvvv = vvv+vec3(0.,0.2,0.0);\n    float minus_from_main_d1 = sdBox(vvv,vec3(0.18,0.22,0.05));\n    vec2 main_building = vec2(opSub(building_d,minus_from_main_d1),2.);\n\n\tvvv = p - vec3(0.0,1.15,0.0);\n\tvvv = vvv-vec3(0.,0.1,0.0);\n    float minus_from_main_d2 = sdBox(vvv,vec3(0.08,0.5,0.05));\n    float main_building_d = opSub(opSub(building_d,minus_from_main_d1),minus_from_main_d2);\n    main_building = vec2(main_building_d,2.);\n\n\tvvv = p - vec3(0.0,1.15,0.0);\n    float roof_d = Triangle(vvv - vec3(-0.08,0.35,0.0),vec3(0.,0.,0.),vec3(0.0,0.10,0.0),vec3(-0.25,0.0,0.0));\n    main_building_d = opUnion(main_building_d,roof_d);\n\n    float roof_d2 = Triangle(vvv - vec3(0.08,0.35,0.0),vec3(0.,0.,0.),vec3(0.0,0.10,0.0),vec3(0.25,0.0,0.0));\n    main_building_d = opUnion(main_building_d,roof_d2);\n\n\tvvv = p - vec3(0.0,0.8,0.0);\n    float step_d1 = sdBox(vvv+ vec3(0.0,-0.08,0.0),vec3(0.12,0.01,0.05));\n    main_building_d = opUnion(main_building_d,step_d1);\n    float step_d2 = sdBox(vvv+ vec3(0.0,-0.04,0.0),vec3(0.12,0.01,0.05));\n    main_building_d = opUnion(main_building_d,step_d2);\n    float step_d3 = sdBox(vvv+ vec3(0.0,0.02,0.0),vec3(0.25,0.01,0.05));\n    main_building_d = opUnion(main_building_d,step_d3);\n    float step_d4 = sdBox(vvv + vec3(0.0,0.08,0.0),vec3(0.36,0.01,0.05));\n    main_building_d = opUnion(main_building_d,step_d4);\n    main_building = vec2(main_building_d,4.);\n    \n    return vec2Min(vec2Min(vec2Min(outer,plane),inner),main_building); \n}\n\n// p is a point on the box.\nvec3 calcNormal(in vec3 p)\n{\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return \n        normalize(\n        k.xyy * map(p + k.xyy * h).x + \n        k.yyx * map(p + k.yyx * h).x +\n        k.yxy * map(p + k.yxy * h).x + \n        k.xxx * map(p + k.xxx * h).x\n       );\n}\n\nvec2 rayMarch(in vec3 o,in vec3 d)\n{\n    \n    const float e = 0.001;\n    const int max_iter_cnt = 128;\n    float t = tmin;\n    int i = 0;\n    vec3 pos;\n    float rr;\n    for(;i < max_iter_cnt && t <= tmax;i++)\n    {\n          pos = o + t * d;\n          vec2 obj = map(pos);\n          rr = obj.x;\n          if(rr < e)\n          {\n                return vec2(t,obj.y);\n          }\n          else\n          {\n              t += rr;\n          }\n    }\n    return vec2(t,-1.);\n\n}\n\nvec3 render(in vec2 uv)\n{\n    \n    float offset = 0.;\n    offset = 0.10 * iTime;\n    if(iMouse.z > 0.01)\n    {\n        offset = 2.0 * 3.14159 * iMouse.x / iResolution.x;\n    }\n    vec3 camPos = vec3(2.4 * sin(offset),1.5,2.4 * cos(offset));\n    vec3 target = vec3(0.,0.,0.);\n    vec3 col = vec3(0.15);\n    mat3 camMat = setCamera(camPos,target,0.0);\n    vec3 frag = vec3(uv,1.0);\n    vec3 rd = normalize(camMat * frag);\n    vec2 t = rayMarch(camPos,rd);\n    int marchBlockCnt = 0;\n    if( t.y >= 0.0 )\n    {\n        //计算颜色\n        vec3 p = camPos + t.x * rd;\n        vec3 n = calcNormal(p);\n        vec3 LightPos = vec3(0.8,2.5\n       ,0.5);\n        float LLength = length(LightPos - p);\n        vec3 LightDir = normalize(LightPos - p);\n        float diff = clamp(dot(LightDir,n),0.,1.) / (LLength * LLength);\n       \n        vec3 objcol = vec3(0.);\n        if(abs(t.y) < 0.001)\n        {\n            // Sphere\n            objcol = vec3(1.0,0.,0.);\n        }\n        else if(t.y < 1.1 && t.y > 0.9)\n        {\n            //Plane\n            //棋盘格子\n            vec2 planeUV = floor(p.xz);\n            objcol = vec3(0.2) + 0.2 * mod(planeUV.x + planeUV.y ,2.0);\n        }\n        else if(t.y < 2.1 && t.y > 1.9)\n        {\n            //Box    \n            objcol = vec3(1.,0.,0.);\n        }\n        \n        else if (t.y < 3.1 && t.y > 2.9)\n        {\n            //Torus\n            objcol = vec3(1.,0.,0.0);\n        }\n        else{\n            //other Objects\n            objcol = vec3(1.,0.,0.);\n        \n        }\n        col = (0.5 + 0.5 * dot(n , vec3(0.,1.,0.) ) ) * objcol + diff * vec3(1.0);\n    }\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fixUV(fragCoord);\n    vec3 col = render(uv);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}