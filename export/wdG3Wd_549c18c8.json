{"ver":"0.1","info":{"id":"wdG3Wd","date":"1571584862","viewed":696,"name":"Ball lattice","username":"kabacis","description":"Controls:\nClick on top right corner to reset\nClick and hold mouse on left side for temporary zoom\nClick anywhere else for interacting with balls\n\nLet me know if you find a parameters that produce smaller, longer lasting grain.\n","likes":46,"published":1,"flags":32,"usePreview":0,"tags":["lattice","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvec4 ballD(in vec2 ipos, in vec2 ballp)\n{\n    float d = distance(ipos, ballp)/BALL_SIZE;\n    return vec4(clamp(sign(1.0-d), 0.0, 1.0)*(1.-d) * float(ballp.x > 0.0)) ;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = iMouse.z > 0.0 && iMouse.x < 30.0 ? clamp(SIZE*(iMouse.y/iResolution.y), 0.01, SIZE) : 1.0;\n    ivec2 cellIndex = ivec2(fragCoord / SIZE * scale);\n    vec2 cellp = mod(fragCoord, SIZE * scale)/(SIZE * scale);\n\n    vec4 res = vec4(0.0, 0.0, 0.0, 1.0);\n    vec2 worldPos = fragCoord * scale;\n    float overlaps = 0.0;\n    vec4 normSum = vec4(0.0);\n    for (int x=-1; x<=1; x++) {\n        for (int y=-1; y<=1; y++) {\n            \n            ivec2 tp = max(cellIndex+ivec2(x,y), ivec2(0));\n            \n        \tvec4 ball  = texelFetch( iChannel0, tp, 0 );\n            vec2 p = ball.xy;\n            vec2 vel = ball.zw;\n\n            p *= iResolution.xy;\n            \n            float d = distance(worldPos, p.xy)/BALL_SIZE;\n            normSum += vec4(p.xy-worldPos, 0.0, 0.0)/BALL_SIZE*(d < 1.0 ? 1.0 : 0.0);\n            vec4 shade = vec4(clamp(sign(1.0-d), 0.0, 1.0)*(1.-d) * float(ball.x > 0.0)) ;\n            //vec4 shade = vec4(d < 1.0 ? 1.0 : 0.0) ;\n            //res=max(res, shade*vec4(vel.x,-vel.x-vel.y,vel.y, 1.0));\n            res=max(res, shade);\n            overlaps += d < 1.0 ? 1.0 : 0.0;\n        }\n    }\n    fragColor = res;\n    //fragColor = res * vec4(2.0 - overlaps, 3.0 - 2.0*overlaps, 1.0, 1.0);\n    //fragColor = normSum+vec4(1.0, 1.0, 1.0,1.0)*0.5;\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec4 getV(in vec2 p){\n    if (p.x < 0.001 || p.y < 0.001) return vec4(0);\n\treturn texelFetch( iChannel0, ivec2(p), 0 )* vec4(iResolution.xy, 1.0, 1.0);\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid sim_step( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 middle = SIZE * (fragCoord);\n    bool mouseReset = iMouse.z > 0.0 && iMouse.x >= iResolution.x - 30.0 && iMouse.y >= iResolution.y - 30.0;\n    if (iFrame == 0 || mouseReset) {\n        ivec2 iv = ivec2(fragCoord);\n        if ((iv.x + iv.y) %2 == 0 && iv.y % 2 == 0 && iv.y < H) {\n    \t\tfragColor = vec4((middle+ (rand(fragCoord)-0.5)* SIZE*0.25), 0, 0);\n        } else {\n        \tfragColor = vec4(0); // -2.0*BALL_SIZE\n        }\n    } else {\n        // check if ball needs to transition between cells\n        vec4 v = vec4(0); \n        for (int x=-1; x<=1; x++) {\n            for (int y=-1; y<=1; y++) {\n                \n                vec2 np = fragCoord + vec2(x,y);\n                vec4 p = getV(np);\n                v += float(trunc(middle/SIZE) == trunc(p.xy/SIZE)) * p;\n            }\n        }\n        // movement calculations\n        if (v.x > 0.0){\n            \n            vec2 dr = vec2(0);//vec2(0.0, -0.01);\n            \n            // collision checks\n            float stress = 0.0;\n            for (int x=-2; x<=2; x++) {\n                for (int y=-2; y<=2; y++) {\n\n                    if (x !=0 || y != 0) \n                    {\n                        vec4 p = getV(fragCoord + vec2(x,y));\n                        if (p.x > 0.0) {\n                            vec2 d2 = (v - p).xy;\n                            float l = length(d2);\n                            float f = BALL_D - l;\n                            if (l >= 0.001* BALL_SIZE &&  f > 0.0) {\n                                float f2 = f / (BALL_D);\n                                f2 +=  SQ_K*f2*f2;\n                                f2 *= BALL_D;\n                                vec2 force_part = E_FORCE * normalize(d2)*f2;\n                                stress += abs(force_part.x)+abs(force_part.y);\n                                dr += force_part;\n                            }\n                        }\n\n                    }\n                }\n            }\n            \n            // force from mouse\n            vec2 mouseDir = v.xy - iMouse.xy;\n            float d2 = dot(mouseDir, mouseDir);\n            dr += M * MOUSE_F *\n                max(stress, 1.0) *\n                float(iMouse.x > 30.0)*clamp(iMouse.z, 0.0, 1.0) * // mouse clicked outside zoom region\n                mouseDir * BALL_SIZE / max(d2, 0.01); //  normalize(mouseDir) / (length(mouseDir)/BALL_SIZE)\n\n            // movement calculation\n            vec2 pos = v.xy;\n            float damp_k = length(dr)>0.001? DAMP_K : 1.0; // don't apply damping to freely flying balls\n            dr += G * M; // gravity\n            vec2 vel = damp_k * v.zw + dr / M;\n            vel = clamp(vel, vec2(-1.0), vec2(1.0));\n            \n            vec2 dpos = vel * VEL_LIMIT;\n\n            \n            pos += dpos;\n\n\n            v = vec4(pos, vel);\n\n            v = clamp(v, vec4(vec2(BALL_SIZE *(1.0 + sin(pos.y)*0.1),BALL_SIZE), vec2(-1.0)),\n                      \t vec4(SIZE*iResolution.xy-vec2(BALL_SIZE), vec2(1.0)));\n\n\n            fragColor = v; \n        } else {\n        \tfragColor = v;\n        }\n            \n    }\n\tfragColor /= vec4(iResolution.xy, 1.0, 1.0);//vec4(fragColor.xy/iResolution.xy, f0, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sim_step(fragColor, fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float SIZE = 3.0;\nconst float BALL_SIZE = 0.90 * SIZE; // should be between sqrt(2)/2 and 1\nconst float BALL_D = 2.0 * BALL_SIZE; \nconst int H = 800; // Reduce this if you want to play with surface or reduce pressure at the bottom\nconst float VEL_LIMIT = 0.2 * BALL_SIZE;\nconst vec2 G = vec2(0.0, -0.006); // 0.006\nconst float E_FORCE = 1.9;\nconst float M = 0.6 * BALL_SIZE;\nconst float DAMP_K = 0.98;\nconst float SQ_K = 0.0;\nconst float MOUSE_F = 0.18;","name":"Common","description":"","type":"common"}]}