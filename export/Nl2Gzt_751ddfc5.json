{"ver":"0.1","info":{"id":"Nl2Gzt","date":"1624509238","viewed":55,"name":"my first shader:sphere","username":"yunzhen","description":"Ray Marching a Sphere","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n//到表面的阈值\n#define SURF_DIST .01 \n\n\nfloat GetDist(vec3 p){\n    vec4 sphere = vec4(0, 1, 6, 1);         //球体的数据，xyz是位置，w是半径\n    float sphereDist = length(p-sphere.xyz) - sphere.w;//当前步进位置到球表面的距离\n    float planeDist = p.y;                          //相机到平面的距离\n    return min(sphereDist, planeDist);      //获取最小的距离（也就是最近的物体）\n}\n\nfloat RayMarching(vec3 ro, vec3 rd){\n    float step = 0.;\n    for(int i=0; i <MAX_STEPS; ++i){\n        vec3 p = ro + rd*step;    //当前步进的位置\n        float r = GetDist(p);    //与场景中最近物体的距离\n        step+= r;            //进行步进\n        if(step>MAX_DIST || r < SURF_DIST)break;       \n    }\n    return step;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord -.5*iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.);\n\n    //设置摄像机\n    vec3 ro = vec3(0., 1., 0.);  \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.)); \n    float d = RayMarching(ro, rd);\n    d/=6.;           //由于数值大过 1 的时屏幕显示白色，所以要缩小到0~1之间\n    col = vec3(d);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}