{"ver":"0.1","info":{"id":"4fVyDy","date":"1732329184","viewed":16,"name":"Glitchy(L)","username":"Buchibuchi","description":"Glitchy Heart","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["heartcoraznglitch8bit"],"hasliked":0,"parentid":"4fVyDG","parentname":"Nerearen Pro 4.0 (L)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalizamos las coordenadas de píxel\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0; // Centrar las coordenadas en (0,0)\n    uv.x *= iResolution.x / iResolution.y; // Ajuste de aspecto\n\n    // Añadir movimiento al fondo\n    uv += 0.02 * vec2(sin(iTime * 0.5), cos(iTime * 0.5)); // Desplazamiento ligero en ambas direcciones\n\n    // Efecto holográfico para el fondo, con movimiento añadido\n    vec3 holographicBgColor = vec3(\n        0.5 + 0.5 * cos(uv.x * 5.0 + iTime * 1.0),   // Rojo\n        0.5 + 0.5 * cos(uv.y * 5.0 + iTime * 1.2),   // Verde\n        0.5 + 0.5 * cos((uv.x + uv.y) * 5.0 + iTime * 1.5) // Azul\n    );\n\n    // Inicializar el color base de la escena con el fondo holográfico\n    vec3 color = holographicBgColor;\n\n    // Definir colores neón para los corazones\n    vec3 neonPink = vec3(1.0, 0.1, 0.7);  // Rosa neón brillante\n    vec3 neonGreen = vec3(0.0, 1.0, 0.5); // Verde neón brillante\n\n    // Fragmentar el espacio UV para crear paneles\n    float fragmentSize = 0.25; // Tamaño del fragmento (ajusta para tener más o menos paneles)\n    vec2 fragmentUV = floor(uv / fragmentSize) * fragmentSize; // Fragmentar las coordenadas UV\n\n    // Cantidad de corazones adicionales\n    float numHearts = 10.0;\n\n    // Dibujamos los corazones adicionales con alternancia de colores neón y fragmentación\n    for (float i = numHearts; i > 0.0; i--) {\n        float scale = (0.1 + i * 0.3) * (1.0 + 0.05 * sin(iTime * 0.20));\n        vec2 scaledUV = fragmentUV / scale; // Aplicamos la fragmentación también aquí\n        float thickness = 0.005 + 0.0002 * sin(iTime * 0.0 + i);\n\n        // Cálculo del corazón usando la fórmula tradicional\n        float x = scaledUV.x;\n        float y = scaledUV.y;\n        float echoHeart = pow(pow(x, 2.0) + y * y - (1.0 + thickness), 3.0) - x * x * pow(y, 3.0);\n        float echoEdge = echoHeart <= 0.0 ? 1.0 : 0.0;\n\n        // Alternar colores entre rosa neón y verde neón en cada capa de corazones\n        vec3 heartColor = (mod(i, 2.0) == 0.0) ? neonPink : neonGreen;\n\n        // Limitar los valores de los colores entre 0.0 y 1.0 para evitar desbordamientos\n        heartColor = clamp(heartColor, 0.0, 1.0);\n\n        // Mezclamos los corazones adicionales con el fondo holográfico\n        color = mix(color, heartColor, echoEdge);\n    }\n\n    // Dibujamos el corazón principal con un efecto de textura ondulante\n    float scaleFactor = 1.7 + 6.0 * sin(iTime * 0.7);\n    vec2 scaledUVMain = fragmentUV / scaleFactor; // Aplicamos la fragmentación al corazón principal\n\n    // Añadir una perturbación a las coordenadas UV para un efecto ondulante\n    float amplitudeX = 0.05; // Amplitud de la onda en X\n    float frequencyX = 10.0; // Frecuencia de la onda en X\n    float amplitudeY = 0.05; // Amplitud de la onda en Y\n    float frequencyY = 10.0; // Frecuencia de la onda en Y\n    float waveSpeed = 2.0;   // Velocidad de la animación de la onda\n\n    vec2 waveUV = scaledUVMain;\n    waveUV.x += amplitudeX * sin(waveUV.y * frequencyX + iTime * waveSpeed);\n    waveUV.y += amplitudeY * cos(waveUV.x * frequencyY + iTime * waveSpeed);\n\n    // Cálculo del corazón principal usando la textura ondulante\n    float heart = pow(pow(waveUV.x, 1.0) + waveUV.y * waveUV.y - 1.0, 3.0) - waveUV.x * waveUV.x * pow(waveUV.y, 3.0);\n    float edge = heart <= 0.0 ? 1.0 : 0.0;\n\n    // Añadir un toque holográfico al corazón principal\n    vec3 holographicColor = vec3(\n        0.5 + 0.5 * sin(waveUV.x * 5.0 + iTime * 2.0),   // Rojo\n        0.5 + 0.5 * sin(waveUV.y * 5.0 + iTime * 2.5),   // Verde\n        0.5 + 0.5 * sin((waveUV.x + waveUV.y) * 5.0 + iTime * 3.0) // Azul\n    );\n\n    // Añadir efecto de halo al corazón principal\n    float distanceFromCenter = length(waveUV) * 0.5; // Distancia del centro para simular el halo\n    float halo = 0.3 / (distanceFromCenter * distanceFromCenter + 0.1); // Ajustar la fuerza del halo\n\n    vec3 finalColor = mix(neonPink, holographicColor, 0.5); // Mezcla del rosa neón con holográfico\n    finalColor += halo * vec3(1.0, 0.8, 0.8); // Añadir un resplandor suave alrededor (ajusta el color para cambiar el halo)\n\n    // Limitar los valores de los colores entre 0.0 y 1.0\n    finalColor = clamp(finalColor, 0.0, 1.0);\n\n    // Mezclamos el corazón principal con el fondo y los corazones adicionales\n    color = mix(color, finalColor, edge * 0.9); // Ajusta '0.9' para cambiar la intensidad de la mezcla\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}