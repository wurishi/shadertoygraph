{"ver":"0.1","info":{"id":"slsyDN","date":"1648123176","viewed":188,"name":"Shader - 01","username":"Ghostmoonk","description":"Exam 1","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Remerciements à fractalcineshader pour l'idée et Remy Sohier pour le passage en M2 et Linda Nouri\n\n\n//README : Tu peux changer le MAP_TYPE de 1 à 3, et le nombre de BALLS comme tu veux\n\n#define MAP_TYPE 2\n#define PI 3.14\n#define TOUPI 6.28\n#define PI 3.14\n#define BALLS 5\n\n#define ROWS 3\n\nvec3 palette(float d){\n\treturn mix(vec3(0.8,0.65,0.2),vec3(cos(iTime)-.5,0.,cos(iTime)/2.0 + .5),d);\n}\n\nvec3 opUnion2(vec3 d1, vec3 d2){\n    return(d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 rotate(vec2 p,float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\nfloat map(vec3 pos){\n    \n    pos.xy =rotate(pos.xy,TOUPI + iTime);\n    pos.y -= 2.5 *sin(iTime) / cos(iTime);\n\treturn dot(sign(pos),pos)/5.;\n\n}\n\nfloat map2(vec3 pos){\n\n    pos.xy = rotate(pos.xy, iTime*1.);\n    for(int i = 0; i < 3; i++){\n        pos.xy += vec2(cos(iTime),sin(iTime));\n    }\n    pos.y -=((sin(iTime)/2.0 -.5) * 1.75) +.5;\n    \n    return dot(sign(pos), pos) /(3.0 + (cos(iTime) * .5 + 0.5)*2.0); \n}\n\nfloat map3(vec3 pos){\n    vec3 previousPos = pos;\n    pos.xy = rotate(pos.xy, iTime*1.);\n    previousPos.xy = rotate(pos.xy, iTime - 0.5);\n    for(int i = 0; i < 3; i++){\n        pos.xy += vec2(cos(iTime),sin(iTime));\n        \n    }\n    pos.xy *= previousPos.xz;\n    \n    return dot(sign(pos), pos) /5.; \n}\n\n\nvec4 raymarch(vec3 ro, vec3 rd){\n    float c = 0.;\n    vec3 col = vec3(0.0);\n    float ray;\n    \n    for(float m = 0.; m < 64.; m++)\n    {\n        vec3 p = ro + rd*c;\n#if MAP_TYPE == 1\n        ray =  map(p);\n#endif\n#if MAP_TYPE == 2\n        ray =  map2(p);\n#endif\n\n#if MAP_TYPE == 3\n        ray =  map3(p);\n#endif\n        if(ray < 0.02){\n            break;\n        }\n        if(ray > 100.0){\n            break;\n        }\n        col+=palette(length(p)*.1)/(400.*(ray));\n        c+=ray * 0.15;\n    }\n    return vec4(col,1./(ray*100.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Centering UVs\n    vec2 uv = 2.0 * fragCoord/iResolution.xy -1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 originRay = vec3(0.0,0.0,-10.0);\n    //originRay.xz = rotate(originRay.xz, iTime);\n    vec3 camForward = normalize(-originRay);\n    vec3 camRight = normalize(cross(vec3(0.0, -1.0, 0.0), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n    vec3 viewDir = normalize(uv.x * camRight + uv.y * camUp + 2.0 * camForward);\n    \n    vec3 uuv = originRay+camForward*3. + uv.x*camRight + uv.y*camUp;\n    \n    //Draw each shape\n    vec3 distRay = vec3(uuv - originRay);\n    distRay.xy = rotate(distRay.xy,TOUPI);\n    vec4 col = raymarch(originRay, distRay);\n    \n    #if MAP_TYPE >= 2 && MAP_TYPE <= 3\n    col = vec4(0.0);\n    \n    for(int row = 0; row < ROWS; row++){\n    \n        originRay.x -= 1.0 * float(row);\n        \n        for(int i = 0; i < BALLS; i++){\n            vec3 tempDistRay = distRay;\n            float currentTrigoRotation = 2.0*PI*float(i)/float(BALLS);\n            tempDistRay.xy = rotate(distRay.xy,currentTrigoRotation);\n            col += raymarch(originRay, tempDistRay);\n        }\n    }\n    #endif\n    \n    fragColor = col;\n    \n}","name":"Image","description":"","type":"image"}]}