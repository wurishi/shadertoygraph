{"ver":"0.1","info":{"id":"NdV3Dw","date":"1631658446","viewed":344,"name":"Crystal Ball Rainfall","username":"Hyeve","description":"@Tater suggested I upgrade the lighting on his geometry from https://www.shadertoy.com/view/fsV3WD , and I gladly did so!","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","transparency","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Geometry by Tater\n//-------------------------------------------------------------\n#define pi 3.1415926535\n#define STEPS 500.0\n#define MDIST 200.0\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p,x) (mod(p,x)-0.5*(x))\nfloat h21(vec2 a){\n    return fract(sin(dot(a,vec2(453.2734,255.4363)))*994.3434);\n}\nvec3 rdg;\nfloat box(vec3 p, vec3 b){\n    vec3 d= abs(p)-b;\n    return max(d.x,max(d.y,d.z));\n}\nfloat t; vec3 glw;\n\n\nvec2 mp(vec3 p)\n{  \n  vec3 po = p;\n    vec2 a = vec2(1);\n    vec2 b = vec2(2);\n    float t =iTime;\n    p.x+=t;\n    \n    float m = 2.;\n    \n    vec2 id3 = floor(p.xz/m)+0.5;\n    p.x+=id3.y;\n    vec2 id2 = floor(p.xz/m)+0.5;\n    float hash =h21(mod(id2,100.0));\n    p.y+=(hash-0.5);\n    id2*=rot(-pi/6.0);\n    p.y+=sin(id2.x+t)*0.7;\n    p.y+=sin(id2.x*0.6+t)*0.4;\n    p.y+=sin(id2.x*0.3+t)*0.2;\n    id2*=rot(pi/6.0)*0.3;\n    p.y+=sin(id2.y+t)*0.7;\n    po = p;\n    float dc = 0.;\n    {\n        vec3 p2=p/vec3(m);\n        vec3 id = floor(p2);\n        vec3 dir = sign(rdg)*.5;\n        vec3 q = fract(p2)-.5;\n        vec3 rc = (dir-q)/rdg;\n        rc*=m;\n        dc = min(rc.x,min(rc.y,rc.z))+0.01;\n    }\n    p.xz = pmod(p.xz,m);\n    t+=hash*200.;\n    float spd = .025;\n    t*=spd;\n    float lscl = m;\n    float le = -mod(t * lscl,lscl); \n    float tscl = 650.; \n    float te = tscl - mod(t * tscl,tscl); \n    float scl = 0.; \n    float id = 0.;\n    float npy = 0.;\n    bool mid = false;\n        if(p.y > le && p.y < te){ \n            npy = mod(p.y-le,tscl);\n            scl = mix(tscl,lscl,min(fract(t)*2.0,1.0));\n            mid = true;\n            id = floor(t);\n        }\n        if(p.y<le){ \n            npy = mod(p.y-le,lscl);\n            id = floor((p.y-le)/lscl)+floor(t);\n            scl = lscl;\n        }\n        if(p.y>te){ \n            npy = mod(p.y-te,tscl);           \n            id = floor((p.y-te)/tscl)+floor(t)+1.0; \n            scl = tscl;\n        }\n        npy-=scl*0.5;\n        p.y = npy;\n    \n    a.x = length(p)-m*0.98*0.5;\n    b.x = length(p)-0.15*m;\n    b.x = max(-po.z-16.,b.x);\n    glw+=((0.01/(0.01+b.x*b.x))/35.)*m;\n    \n    a.x = max(-po.z-16.,a.x);\n    a.x = min(a.x,dc);\n    \n    if(mid)a.x = min(a.x,max(-(-po.y+le),0.1));\n    a.y = id+100.;\n    return a;\n}\n\n//Lighting and vfx by me!\n//--------------------------------------------------\nvec2 tr(vec3 ro, vec3 rd, float f)\n{\n  vec2 d = vec2(0);\n  for(int i = 0; i < 128; i++)\n  {\n    vec3 p=ro+rd*d.x;\n    vec2 s=mp(p);s.x*=f;\n    d.x+=s.x;d.y=s.y;\n    if(d.x>64.||s.x<0.001)break;\n  }\n  if(d.x>64.)d.y=0.;return d;\n}\n\nvec3 nm(vec3 p)\n{\n  vec2 e = vec2(0.001,0); return normalize(mp(p).x-vec3(mp(p-e.xyy).x,mp(p-e.yxy).x,mp(p-e.yyx).x));\n}\n\nvec4 px(vec4 h, vec3 rd, vec3 ro, vec3 n,vec4 bg)\n{\n  if(h.a==0.)return bg; \n  h.a=mod(h.a,3.)+1.;\n  vec4 a=h.a==1.?vec4(0.600,0.204,0.996,0.2):h.a==2.?vec4(0.000,0.431,1.000,0.3):vec4(0.761,0.239,1.000,0.4); \n  float d=dot(n,-rd);\n  float dd=max(d,0.); \n  float f=clamp(pow(1.-d,4.),0.,1.);\n  float s=(pow(abs(dot(reflect(rd,n),-rd)),40.)*10.);\n  if(h.a>1.)s*=0.05;\n  vec4 col = vec4(mix(a.rgb*dd+s,bg.rgb,f),a.a); \n  col.rgb = pow(col.rgb,vec3(0.6));;\n  col.rgb = mix(col.rgb,bg.rgb,clamp(length(h.xyz-ro*0.5)/50.,0.,1.));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  t=iTime;\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5; uv /= vec2(iResolution.y / iResolution.x, 1.); \n  float ts=1.,io=1.15;\n  vec3 ro = vec3(1,10,-25);\n  vec3 lk = vec3(1.01,2,0);\n  vec3 f = normalize(lk-ro);\n  vec3 r = normalize(cross(vec3(0,1,0),f));\n  vec3 rd = normalize(f*0.95+uv.x*r+uv.y*cross(f,r));\n  vec4 bg = vec4(mix(vec3(0.102,0.239,0.557),vec3(0.678,0.565,0.996),max(rd.y+0.6,0.)),1.);\n  rdg=rd;vec3 rog=ro;\n  vec3 oro=ro,ord=rd,cp,cn,rc,cc;\n  for(int i=0;i<3;i++)\n  {\n    vec2 fh=tr(oro,ord,1.);\n    cp=oro+ord*fh.x;cn=nm(cp);\n    vec4 c=px(vec4(cp,fh.y),ord,oro,cn,bg);\n    if(fh.y==0.||c.a==1.) {cc=mix(cc,c.rgb,ts); break;}\n    ro=cp-cn*0.01;rd=refract(ord,cn,1./io);\n    vec2 bh=tr(ro,rd,-1.);\n    cp=ro+rd*bh.x;cn=nm(cp);\n    oro=cp+cn*0.01;ord=refract(rd,-cn,io);\n    if(dot(ord,ord)==0.)ord=reflect(rd,-cn);\n    cc=mix(cc,c.rgb,ts);ts-=c.a;\n    if(ts<=0.)break;\n  }\n  cc = mix(cc+glw,bg.rgb,clamp(length(oro-rog*0.5)/60.,0.,1.));\n  fragColor=vec4(cc,1.);\n}\n//-------------------------------------------------------------------------","name":"Image","description":"","type":"image"}]}