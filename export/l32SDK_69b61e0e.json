{"ver":"0.1","info":{"id":"l32SDK","date":"1711116238","viewed":35,"name":"simple raymarching.","username":"TigrePlayz","description":"idk","likes":1,"published":1,"flags":16,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float smoothmin(float a, float b, float intensity)\n{\n    float h = max(intensity - abs(a-b), 0.0);\n    return min(a,b) - h * h * h * intensity*(1.0 / 6.0);\n}\n\nmat2 rot2D(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat2(c,-s,s,c);\n}\n\nfloat box( vec3 rayPos, vec3 scale, vec3 position )\n{\n  return (length(max(abs(rayPos + position)-scale/10.,0.0)));\n}\n\nfloat sphere(vec3 rayPos, float scale, vec3 position)\n{\n    return (length(rayPos + position) - scale);\n}\n\nfloat map(vec3 rayPos, float moveSpeed)\n{   \n    //float moveSpeed = 0.5;\n    \n    float sine = sin(vec2(iTime * 1., 0)).x * moveSpeed;\n    float cosine = cos(vec2(iTime * 1., 0)).x * moveSpeed;\n    \n    //Shapes\n    float ball1 = sphere(rayPos, .1, vec3(cosine / 2.,sine,sine / 2.));\n    float ball2 = sphere(rayPos, .2 * abs(sine), vec3(-.1 - cosine / 1.,-.3 * cosine,-.3 * cosine * 2.));\n    float ball3 = sphere(rayPos, .2, vec3(-sine / 3.));\n    float cube = box(rayPos, vec3(3. * abs(sine)), vec3(sine,cosine / 2.,cosine));\n   \n    float mergeI = 0.85;\n    \n    //Combine shapes using smoothmin functions.\n    return smoothmin(smoothmin(smoothmin(ball1, ball2, mergeI), cube, mergeI), ball3, mergeI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float moveSpeed = .4;\n    float lookSensibility = 2.;\n    int iterations = 64;\n    float viewDistance = 2.5;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 m = (iMouse.xy *2. - iResolution.xy) / iResolution.y;\n    \n    //Camera\n    \n    vec2 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xy;\n    vec3 rayOrigin = vec3(0,0,-1);//Ray Origin\n    vec3 rayDirection = normalize(vec3(uv,1.5));//Ray Direction\n    vec3 rayDistance = vec3(0);\n    \n    rayOrigin.yz *= rot2D(-m.y * lookSensibility);\n    rayDirection.yz *= rot2D(-m.y * lookSensibility);\n    \n    rayOrigin.xz *= rot2D(-m.x * lookSensibility);\n    rayDirection.xz *= rot2D(-m.x * lookSensibility);\n    \n    vec3 col = vec3(0);\n    \n    vec3 rayPos = vec3(0);\n\n    //Raymarch\n    for(int i = 0; i < iterations; i++)\n    {\n        rayPos = rayOrigin+rayDirection*rayDistance;//Current Ray Distance\n        \n        float raymarched = map(rayPos, moveSpeed);\n        \n        if(raymarched < .007) \n        {\n            raymarched = 0.;\n        }\n        if((rayPos.x + rayPos.y + rayPos. z) > 6.)\n        {\n            rayPos = vec3(0);\n            break;\n        }\n        \n        rayDistance += raymarched; \n        \n        float rayDistAverage = (rayPos.x+rayPos.y+rayPos.z)/3.;\n        if(rayDistAverage > viewDistance * 10.){break;}\n                \n        //if(rayDistance > 9.){break;}\n        \n        rayPos = clamp(rayPos, 0., 0.25);\n        \n        float averageRayDist = (rayDistance.x + rayDistance.y + rayDistance.z) / 3.;\n        if(averageRayDist > 8.){break;}\n        \n        \n        \n        col = ((rayDistance / viewDistance) * rayPos * viewDistance * 10.) * (1.0 - raymarched);\n    }\n    \n    col *= vec3(rayDistance / viewDistance);\n    \n    //Coloration\n    vec3 color1 = vec3(1.,1.,1.);\n    vec3 color2 = vec3(.3, .5, 1.);\n    \n    //col = vec3(smoothstep()));\n    // Output to screen\n    fragColor = vec4(col * vec3(0.3,0.9,1.) * 1.5, 0.);\n}","name":"Image","description":"","type":"image"}]}