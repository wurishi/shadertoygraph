{"ver":"0.1","info":{"id":"sddczr","date":"1653005647","viewed":228,"name":"Penrose's unilluminable room","username":"LucasR","description":"Implementation of Roger Penrose's solution to the Illumination problem. You can move the light with the mouse. For better results, you can play with the constants on top of the code, at the cost of performance. Inspired by Steve Mould's latest video","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","illuminationproblem"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants\nconst int rayNum = 9; // number of light rays\nconst int bNum = 1; // number of bounces\nconst float lightR = 0.03; // radius of lightsource (only for displaying)\nconst vec3 lightCol = vec3(1., 1., 0.); // light colour\n//const float pi = 3.14159265359;\nconst float tau = 6.28318530718;\n\nconst float bigA = 1.5; // a of big ellipse\nconst float bigB = 0.7; // b of big ellipse\nconst float bigH = 0.2; // separation of big ellipse segments\nconst float litR = 0.2; // radius of little circles\nconst float litH = 0.01; // cutting of little circles\nconst float litX = 1.33; // x coordinate of little ellipses\nconst float b1 = 0.2; // box width\nconst float b2 = 0.1; // box height\nconst float bX = 1.4; // x coordinate of the side boxes (reflected)\n\nconst float stepFactor = 2.; // bigger values make it more precise around the \"mushrooms\", but it's also slower\nconst int MAX_MARCHING_STEPS = 20;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 3.;\nconst float PRECISION = 0.01;\nconst float EPSILON = 0.0005; // used in calcNormal()\n\nmat2 rot90(){ // 2D rotation matrix -- 90ยบ\n    return mat2(0., -1., 1., 0.);\n}\n\nfloat sdEllipse( vec2 p, vec2 ab ){\n// source: https://www.shadertoy.com/view/4lsXDN\n    // symmetry\n\tp = abs( p );\n\n    // find root with Newton solver\n    vec2 q = ab*(p-ab);\n\tfloat w = (q.x<q.y)? 1.570796327 : 0.0;\n    for( int i=0; i<5; i++ )\n    {\n        vec2 cs = vec2(cos(w),sin(w));\n        vec2 u = ab*vec2( cs.x,cs.y);\n        vec2 v = ab*vec2(-cs.y,cs.x);\n        w = w + dot(p-u,v)/(dot(p-u,u)+dot(v,v));\n    }\n    \n    // compute final point and distance\n    float d = length(p-ab*vec2(cos(w),sin(w)));\n    \n    // return signed distance\n    return (dot(p/ab,p/ab)>1.0) ? d : -d;\n}\n\n\nfloat sdCutDisk( in vec2 p, in float r, in float h ){\n// source: https://www.shadertoy.com/view/ftVXRc\n    float w = sqrt(r*r-h*h); // constant for a given shape\n    \n    p.x = abs(p.x);\n    \n    // select circle or segment\n    float s = max( (h-r)*p.x*p.x+w*w*(h+r-2.0*p.y), h*p.x-w*p.y );\n\n    return (s<0.0) ? length(p)-r :        // circle\n           (p.x<w) ? h - p.y     :        // segment line\n                     length(p-vec2(w,h)); // segment corner\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b ){\n// source: https://iquilezles.org/articles/distfunctions2d/\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r ){\n// source: https://iquilezles.org/articles/distfunctions2d/\n    return length(p) - r;\n}\n\nfloat sdScene(vec2 p){\n    vec2 ab = vec2(bigA, bigB); // a and b of the ellipse\n    float d = sdEllipse(vec2(p.x, abs(p.y)-bigH), ab);\n    d = min(d, sdBox(p, vec2(bigA, bigH))); // add square sides\n    \n    vec2 pr = p*rot90(); // rotated coordinate system\n    d = min(-d, sdCutDisk(vec2(pr.x, litX-abs(pr.y)), litR, litH));\n    d = min(d, sdBox(vec2(abs(p.x)-bX, p.y), vec2(b1, b2)));\n    return d;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ){\n// source: https://www.shadertoy.com/view/3tdSDj\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nvec2 rayMarch(vec2 po, vec2 rd, float start, float end){ // origin and direction, returns contact point\n    float depth = start;\n    vec2 pf;\n    for(int i = 0; i < MAX_MARCHING_STEPS; i++){\n        depth += sdScene(pf)/stepFactor;\n        pf = po + depth*rd;\n        if(abs(depth) < PRECISION || depth > end) break;\n    }\n    \n    return pf;\n}\n\nvec2 calcNormal(vec2 p){\n    vec2 e = vec2(0.0001,0.0);\n    float d = sdScene(p);\n    vec2 normal = normalize(vec2(d-sdScene(p-e.xy), d-sdScene(p-e.yx)));\n    return normal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float LTh = 3./iResolution.y; // line thickness\n    \n    // ***** draw room *****\n    vec2 p = (-iResolution.xy + 2.*(fragCoord))/iResolution.y;    \n    float d = sdScene(p);\n    vec3 col = vec3(smoothstep(1.-LTh, 1., 1.-abs(d))); // room lines\n    // draw elipse foci -- the corners of the semicircles have to lie on the foci\n    float c = sqrt(bigA*bigA - bigB*bigB);\n    col += vec3(1., 0., 0.) * smoothstep(LTh*2., 0., sdCircle(vec2(abs(p.x)-c, abs(p.y)-bigH), 0.005));\n    \n    // ***** end draw room *****\n    \n    // ***** light *****\n    vec2 lightPos = vec2(0.);\n    if(iMouse.z > 0.){ // move light to mouse position if the LMB is being presssed\n        lightPos = (-iResolution.xy + 2.*(iMouse.xy))/iResolution.y;\n    }else{\n        float t = iTime/3.;\n        lightPos = vec2(abs(sin(t))*bigA-.05, abs(cos(t))*bigB/2.+.15); // some random trajectory I liked\n    }\n    float lightMask = sdCircle(p-lightPos, lightR);\n    \n    vec2 rd; // ray direction\n    for(int i = 0; i < rayNum; i++){\n        float theta = float(i)*tau/float(rayNum);\n        rd = vec2(cos(theta), sin(theta));\n        vec2 pf = rayMarch(lightPos, rd, MIN_DIST, MAX_DIST);\n        lightMask = min(lightMask, sdSegment(p, lightPos, pf)-0.001);\n        for(int j = 0; j < bNum; j++){ // bounces\n            vec2 pb = rayMarch(pf, reflect(rd, calcNormal(pf)), MIN_DIST, MAX_DIST);\n            lightMask = min(lightMask, sdSegment(p, pf, pb)-0.001);\n            pf = pb;\n        }\n    }\n    \n    lightMask = smoothstep(LTh, 0., lightMask);\n    // ***** end light *****\n    \n    col += lightMask * lightCol;\n    col *= step(-d, 3./iResolution.y);\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}