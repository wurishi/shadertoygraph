{"ver":"0.1","info":{"id":"ms2XDK","date":"1670942555","viewed":225,"name":"Fractal Ray marching Triplanar","username":"faportero","description":"Experimento de mapeado triplanar usando la t√©cnica de renderizado \"ray marching\", sobre el fractal 3D denominado \"Mandelbub\"","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","triplanar","mandelbub"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926;\nfloat cy = 0.1;\n\nfloat mandelbub(vec3 position)\n{\n            \n    vec3 z = position;\n    float dr = 1.;\n    float r = 0.0;\n    float power = 4.;\n    //float power = iTime*.4;\n    \n    //MATRIZ DE ROTACION\n    float an = .0;\n    //float an = iTime*3.2;\n    mat3 rot = mat3(\n        cos(an),0, sin(an),\n        \t0., 1., 0.,\n        -sin(an),0., cos(an)\n    );\n    \n    vec3 q = position;\n    q.xyz = rot*q.xyz;\n\n    \n    for (int i = 0; i <4; ++i)\n    {\n    r = length(z);\n        if (r > 5.)\n        {\n        break;\n        }\n        \n        //float cPower = 1.;\n        float cPower = iTime / 5.0;\n        float theta = acos(z.z /r) * power * cPower ;\n        float phi = atan(z.y, z.x) * power * cPower;\n        float zr = pow(r, power);\n        \n        dr = pow(r, power - 1.0) * power * dr +  1.0;\n        \n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin (theta), cos(theta));\n        z +=.5*q;       \n    }\n    \n    \n        \n    float d2 = length (vec2(q.y+1.5, length(q.xz) - 0.5)) - 0.2;\n    //return d2;\n\treturn  .5 * log(r) * r / dr;\n       \n}\n\n\n// Calculo del gradiente\nvec3 calcNormal(vec3 position)\n{\n    float rbgx, rgby, rgbz;\n\treturn normalize(vec3(\n    \tmandelbub(position + vec3(-0.001, 0.0, 0.0)) -mandelbub(position - vec3(-0.001, 0.0, 0.0)),\n        mandelbub(position + vec3(0.0, -0.001, 0.0)) - mandelbub(position - vec3(0.0, -0.001, 0.0)),\n        mandelbub(position + vec3(0.0, 0.0, -0.001)) - mandelbub(position - vec3(0.0, 0.0, -0.001))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screen_pos = ((2.0 * fragCoord.xy - iResolution.xy )/ iResolution.y )+ (0.0,0.0,0.0);\n    \n    //float cam_an = 2.*PI;\n    float cam_an = iTime*0.5;\n    float frec = .5;\n    vec3 cam_orig = vec3 (1.*sin(2.5)+cos(.2), 3.*(sin(.3)+cos(2.4)), -4.0);\n\t//vec3 cam_orig = vec3 (1., 1., .5*(sin(cam_an)+cos(-cam_an)));\n\t\n    //vec3 cam_orig = vec3 (.5*sin(frec*cam_an)+cos(frec*cam_an), .5*sin(cam_an)+cos(cam_an), -2.5*sin(cam_an));\n    \n    /*\n    float an = iTime*1.2;\n    mat3 rot = mat3(\n        cos(an),0, sin(an),\n        \t0., 1., 0.,\n        -sin(an),0., cos(an));\n\n*/\n    \n    \n    vec3 cam_target = vec3(-.5, 0.25, 0.0);    \n\n    vec3 q = cam_target;\n  //  q.xyz = rot*q.xyz;\n    \n    vec3 cam_forward = normalize(cam_target - cam_orig);\n    vec3 cam_right = normalize(cross(cam_forward, vec3 (0.0, 1.0, 0.0)));\n    vec3 cam_up = normalize(cross(cam_right, cam_forward));\n    \n    vec3 ro = cam_orig;\n    vec3 rd = normalize(vec3(\n    \tscreen_pos.x * cam_right + \n        screen_pos.y * cam_up + \n        5.0 * cam_forward        \n    ));\n    \n    vec3 col = vec3(0.0);\n    \n    float t = 0.0;\n    \n    for (int step_march = 0; step_march < 200; ++step_march)\n    {\n    \tvec3 p = ro + t * rd;\n        float h = mandelbub(p);\n        if (h < 0.00001)\n        {\n            vec3 contraste = vec3 (.5);\n            vec3 N = pow(abs(calcNormal(p)), contraste);\n            float sN = N.x + N.y + N.z;\n            \n            //triplanar mapping\n            \n            float texSize = .7;\n            vec3 col_z = texture(iChannel0, p.xy/ texSize).xyz;\n            vec3 col_y = texture(iChannel0, p.xz/ texSize).xyz;\n            vec3 col_x = texture(iChannel0, p.yz/ texSize).xyz;\n        \t//col = calcNormal(p);\n            \n            col_z *= N.z/sN; \n            col_x *= N.x/sN;\n            col_y *= N.y/sN;\n            \n            col = col_x + col_y + col_z + calcNormal(p);\n            //col = vec3(0.0,cy,0.0);\n            break;\n        }\n        \n        t +=h;   \n        \n    }\n    \n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}