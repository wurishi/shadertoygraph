{"ver":"0.1","info":{"id":"fdjyR1","date":"1643109696","viewed":313,"name":"Halftone color print on paper","username":"stegu","description":"If you could print video on paper. And if you, for some reason, chose to print a video of Britney Spears.\nZoom with the mouse! There's a *lot* of close-up detail.\n","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["noise","halftone","detail"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// GLSL halftone shader demo for WebGL\n// Stefan Gustavson 2012-02-16\n// Revisited and updated for Shadertoy 2022-01-25\n//\n// Simplex noise \"psrdnoise\" is MIT licensed, as stated\n// in the source under the \"Common\" tab. All other code\n// in this shader is my own original work, and is hereby\n// placed in the public domain.\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 texturesize = vec2(textureSize(iChannel0, 0));\n    vec2 st = (gl_FragCoord.xy - 0.5*max(vec2(0.0), (iResolution.xy-iResolution.yx)))\n    / min(iResolution.x, iResolution.y); // Rescale to 4:3 and center\n    // Hack: if the mouse hasn't been touched, use a default view\n    vec2 mouse = all(equal(vec2(0.0), iMouse.xy)) ? vec2(0.5*iResolution.x,0.0) : iMouse.xy;\n    float zoom = pow(0.5, 8.0*max(0.0, mouse.y-20.0)/iResolution.y);\n    vec2 pan = sqrt(zoom)*vec2(1.0-2.0*(mouse.x/iResolution.x), 0.0);\n    st = zoom*(st-vec2(0.5, 0.7)) + vec2(0.5, 0.7) + pan;\n\n    float freq = 80.0;  // The halftone frequency, in st space\n    float rough = 0.5;  // Roughness of dot edges (0.0 for perfect circles)\n    float fuzz = 0.1;   // Fuzz range for \"optical dot gain\" (0.0 for crisp edges)\n\n    // Use a texture to modulate the size of the dots, and\n    // use explicit bilinear interpolation for better precision.\n    // Extreme magnifications don't work quite right with this\n    // shader if you use the built-in linear filtering.\n    // Also, rescale from 1:1 to 4:3 (original aspect ratio of input)\n    vec3 texcolor = texture2D_bilinear(iChannel0,\n            st*vec2(0.75, 1.0)+vec2(0.125, 0.0)).rgb;\n\n    vec2 p, g, gtemp;\n\tfloat n, s, f, w; // No, this was not a deliberate pun\n\tp = vec2(0.0);\n\ts = 100.0; // Scale for the \"paper fibers\" texture\n\tw = 0.5;\n\n    // \"Paper-like\" fractal noise (more like felted wool, really)\n    for(int i=0; i<6; i++) { // 6 octaves to handle close-ups\n\t  f += w*psrdnoise(s*vec2(2.0,1.0)*st, p, 0.0, gtemp);\n\t  g += w*gtemp;\n\t  w *= 0.55;\n\t  s *= 2.2;\n\t}\n    n = 0.1*f+0.15*length(g);\n\n    float papernoise = 0.5; // Amount of noise to throw on\n    float inknoise = 0.5;  // In the areas of paper/ink\n    vec3 papercolor = vec3(1.0, 1.0, 1.0); // Seriously bright paper\n    vec3 paper = papercolor - papernoise * n; // Paper color + noise\n    float inkamount = 0.9 - inknoise * n; // Ink \"density\" with noise\n \n    // Perform a criminally crude RGB-to-CMYK conversion\n    vec4 cmyk;\n    cmyk.xyz = 1.0 - texcolor; // CMY = 1-RGB, ta-daa! (ugh)\n    // Black generation: K = min(C,M,Y)\n    cmyk.w = min(cmyk.x, min(cmyk.y, cmyk.z));\n    // Grey component replacement: subtract K from CMY\n    cmyk.xyz -= cmyk.w;\n \n    // Distances to nearest point in angled grids of\n    // (frequency x frequency) points over the unit square\n    // K component: 45 degrees screen angle\n    vec2 Kst = freq*mat2(0.707107, -0.707107, 0.707107, 0.707107)*st;\n    vec2 Kuv = 2.0*fract(Kst)-1.0;\n    // This plain sqrt() is not *quite* right for the transfer function\n    float Kr = sqrt(cmyk.w) - length(Kuv) + rough*n;\n    float k = 1.0-(1.0-aasmoothstep(-fuzz, 0.0, Kr)) * (1.0-aastep(0.0, Kr));\n    // C component: 15 degrees screen angle\n    vec2 Cst = freq*mat2(0.965926, -0.258819, 0.258819, 0.965926)*st;\n    vec2 Cuv = 2.0*fract(Cst)-1.0;\n    float Cr = sqrt(cmyk.x) - length(Cuv) + rough*n;\n    float c = 1.0-(1.0-aasmoothstep(-fuzz, 0.0, Cr)) * (1.0-aastep(0.0, Cr));\n    // M component: -15 degrees screen angle\n    vec2 Mst = freq*mat2(0.965926, 0.258819, -0.258819, 0.965926)*st;\n    vec2 Muv = 2.0*fract(Mst)-1.0;\n    float Mr = sqrt(cmyk.y) - length(Muv) + rough*n;\n    float m = 1.0-(1.0-aasmoothstep(-fuzz, 0.0, Mr)) * (1.0-aastep(0.0, Mr));\n    // Y component: 0 degrees screen angle\n    vec2 Yst = freq*st;\n    vec2 Yuv = 2.0*fract(Yst)-1.0;\n    float Yr = sqrt(cmyk.z) - length(Yuv) + rough*n;\n    float y = 1.0-(1.0-aasmoothstep(-fuzz, 0.0, Yr)) * (1.0-aastep(0.0, Yr));\n \n    // CMY screen in RGB (with horribly saturated CMY primaries)\n    vec3 rgbscreen = (1.0-inkamount*vec3(c,m,y));\n    // Blend in K for final color\n    rgbscreen = mix(paper*rgbscreen, vec3(0.0), inkamount*k);\n    // Blend to plain RGB texture under extreme minification\n    // (handles any minification level by regular mipmapping)\n    float afwidth = 2.0 * freq * max(length(dFdx(st)), length(dFdy(st)));\n    float blend = smoothstep(0.7, 1.4, afwidth); \n\n    fragColor = vec4(mix(rgbscreen, texcolor, blend), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float aastep(float threshold, float value) {\n  float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n  return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\n// A smoothstep() that blends to an aastep() under minification\nfloat aasmoothstep(float t1, float t2, float v) {\n\tfloat aw = 0.7 * length(vec2(dFdx(v), dFdy(v)));\n    float t = 0.5*(t1+t2);\n\tfloat sw = max(0.5*(t2-t1), aw);\n\treturn smoothstep(t-sw, t+sw, v);\n}\n\n// Explicit bilinear texture lookup to circumvent bad hardware precision.\nvec4 texture2D_bilinear(sampler2D tex, vec2 st) {\n    vec2 dims = vec2(textureSize(tex, 0)); // Cast to floats for next line\n    vec2 uv = st * dims;\n    //uv = clamp(uv, vec2(0.0), dims-2.0); // Fake \"clamp to edge\"\n    vec2 uv00 = floor(uv + vec2(0.5)); // Lower left corner of lower left texel\n    vec2 uvlerp = uv - uv00 + vec2(0.5); // Texel-local lerp blends [0,1]\n    vec4 tx00, tx01, tx10, tx11;\n    ivec2 ij = ivec2(uv00);\n    tx00 = texelFetch(tex, ij, 0);\n    tx01 = texelFetchOffset(tex, ij, 0, ivec2(0.0, 1.0));\n    tx10 = texelFetchOffset(tex, ij, 0, ivec2(1.0, 0.0));\n    tx11 = texelFetchOffset(tex, ij, 0, ivec2(1.0, 1.0));\n\tvec4 tx0 = mix(tx00, tx01, uvlerp.y); \n\tvec4 tx1 = mix(tx10, tx11, uvlerp.y); \n\treturn mix(tx0, tx1, uvlerp.x);\n}\n\n// psrdnoise (c) Stefan Gustavson and Ian McEwan,\n// ver. 2021-12-02, published under the MIT license:\n// https://github.com/stegu/psrdnoise/\n\nfloat psrdnoise(vec2 x, vec2 period, float alpha, out vec2 gradient)\n{\n\tvec2 uv = vec2(x.x+x.y*0.5, x.y);\n\tvec2 i0 = floor(uv), f0 = fract(uv);\n\tfloat cmp = step(f0.y, f0.x);\n\tvec2 o1 = vec2(cmp, 1.0-cmp);\n\tvec2 i1 = i0 + o1, i2 = i0 + 1.0;\n\tvec2 v0 = vec2(i0.x - i0.y*0.5, i0.y);\n\tvec2 v1 = vec2(v0.x + o1.x - o1.y*0.5, v0.y + o1.y);\n\tvec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\n\tvec2 x0 = x - v0, x1 = x - v1, x2 = x - v2;\n\tvec3 iu, iv, xw, yw;\n\tif(any(greaterThan(period, vec2(0.0)))) {\n\t\txw = vec3(v0.x, v1.x, v2.x);\n\t\tyw = vec3(v0.y, v1.y, v2.y);\n\t\tif(period.x > 0.0)\n\t\t\txw = mod(vec3(v0.x, v1.x, v2.x), period.x);\n\t\tif(period.y > 0.0)\n\t\t\tyw = mod(vec3(v0.y, v1.y, v2.y), period.y);\n\t\tiu = floor(xw + 0.5*yw + 0.5); iv = floor(yw + 0.5);\n\t} else {\n\t\tiu = vec3(i0.x, i1.x, i2.x); iv = vec3(i0.y, i1.y, i2.y);\n\t}\n\tvec3 hash = mod(iu, 289.0);\n\thash = mod((hash*51.0 + 2.0)*hash + iv, 289.0);\n\thash = mod((hash*34.0 + 10.0)*hash, 289.0);\n\tvec3 psi = hash*0.07482 + alpha;\n\tvec3 gx = cos(psi); vec3 gy = sin(psi);\n\tvec2 g0 = vec2(gx.x, gy.x);\n\tvec2 g1 = vec2(gx.y, gy.y);\n\tvec2 g2 = vec2(gx.z, gy.z);\n\tvec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\n\tw = max(w, 0.0); vec3 w2 = w*w; vec3 w4 = w2*w2;\n\tvec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\n\tfloat n = dot(w4, gdotx);\n\tvec3 w3 = w2*w; vec3 dw = -8.0*w3*gdotx;\n\tvec2 dn0 = w4.x*g0 + dw.x*x0;\n\tvec2 dn1 = w4.y*g1 + dw.y*x1;\n\tvec2 dn2 = w4.z*g2 + dw.z*x2;\n\tgradient = 10.9*(dn0 + dn1 + dn2);\n\treturn 10.9*n;\n}\n","name":"Common","description":"","type":"common"}]}