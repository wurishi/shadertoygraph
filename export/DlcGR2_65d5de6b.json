{"ver":"0.1","info":{"id":"DlcGR2","date":"1682674806","viewed":66,"name":"Flower from circles","username":"dtsmio","description":"Rotating circles with uv mirror","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["uv","mirror"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535\n\nvec2 toDec (vec2 pol)\n{\n \treturn vec2(cos(pol.x * PI * 2.), sin(pol.x * PI * 2.)) * pol.y;\n}\n\nvec2 toPolar(vec2 dec) \n{\n    return vec2(atan(dec.y, dec.x) / PI / 2., length(dec)); // x: [-0.5, 0.5]\n}\n\nfloat line (vec2 a, vec2 b, vec2 p)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = min(1., max(0., dot(pa, ba)/dot(ba, ba)));\n    \n    return length(pa - ba * h);\n}\n\nfloat circle (vec2 center, float radius, vec2 uv)\n{\n    float w = 0.002;\n    float l = length(uv - center);\n \n    l = smoothstep(0., radius, l)\n      * smoothstep(radius + w, radius + w / 2., l);\n\n    return l;\n}\n\nvec2 mirror(vec2 polarUV, float segments) {\n    \n    vec2 sg = vec2(sign(sin(polarUV.x * segments * PI)), \n                   sign(sin(polarUV.y * PI)));\n\n    polarUV.x = fract(sg.x * polarUV.x * segments) / segments;\n    \n    return toDec(polarUV);\n}\n\nvec3 gradient(float x, float r)\n{\n    vec3 c1 = vec3(0.05, 0.02, 0.4);\n    vec3 c2 = vec3(0.4, 0.02, 0.1);\n    float a = step(0., sin(r * 40. + 4.));\n \n    vec3 res = mix(c1, c2, x - r) * 2.5;\n    return res * x;\n}\n\nvec3 fill(vec2 uv)\n{\n\n    vec2 p1 = vec2(0.05, 0.05);\n    vec2 p2 = vec2(0.1, 0.1);\n    float l = line(p1, p2, uv);\n    float radius = 0.1;\n    l = smoothstep(0.004, 0.002, l);\n\n    vec2 c = vec2(0.1);\n    float t = iTime * 0.2;\n    c = mix(p1, p2, sin(t) * 0.5 + 0.5);\n    float cir = circle(c, 0.1, uv);\n    vec3 g = gradient(cir, 0.);\n\n    for (float i = 0.; i < 22.; i += 1.)\n    {\n        t *= 1.2;\n        c += vec2(sin(t), cos(t)) * radius;\n        radius *= 0.9;\n        cir = circle(c, radius, uv);\n        g = max(g, gradient(cir, i * 0.04));\n    }\n\n    return g;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec2 av = toPolar(uv);\n    float steps = 6.;\n    av.x = fract(av.x * steps) / steps;\n    uv = toDec(av);\n    vec2 uv2 = toDec(vec2(1. / steps - av.x, av.y));\n\n    vec3 col = vec3(0.);\n    col += max(fill(uv), fill(uv2));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}