{"ver":"0.1","info":{"id":"7l3yRX","date":"1660212478","viewed":166,"name":"Color latex ripples","username":"HaleyHalcyon","description":"a","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["liquidrippleswaterdarkglossy"],"hasliked":0,"parentid":"7sccRr","parentname":"dark Ripples"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU (6.283185307)\n#define HEX(x) (vec3((x >> 16) & 255, (x >> 8) & 255, x & 255) / 255.)\n\nconst int permutation[256] = int[]( \n44,\n157,\n6,\n193,\n149,\n195,\n168,\n24,\n227,\n224,\n12,\n240,\n91,\n50,\n27,\n101,\n86,\n39,\n150,\n58,\n114,\n18,\n203,\n69,\n53,\n245,\n13,\n110,\n16,\n189,\n219,\n134,\n54,\n56,\n35,\n7,\n71,\n76,\n242,\n68,\n237,\n0,\n154,\n236,\n226,\n204,\n14,\n231,\n23,\n67,\n216,\n126,\n100,\n59,\n1,\n38,\n167,\n194,\n243,\n255,\n235,\n22,\n133,\n225,\n117,\n109,\n45,\n173,\n246,\n89,\n205,\n108,\n140,\n186,\n52,\n120,\n49,\n181,\n5,\n9,\n85,\n73,\n153,\n84,\n98,\n143,\n161,\n218,\n66,\n63,\n78,\n28,\n170,\n94,\n184,\n230,\n92,\n221,\n228,\n31,\n131,\n174,\n115,\n87,\n47,\n199,\n223,\n190,\n248,\n175,\n2,\n138,\n142,\n137,\n217,\n166,\n40,\n95,\n151,\n141,\n111,\n80,\n104,\n214,\n252,\n220,\n212,\n75,\n90,\n172,\n197,\n127,\n164,\n232,\n21,\n253,\n17,\n88,\n156,\n207,\n165,\n125,\n102,\n182,\n145,\n147,\n206,\n105,\n26,\n124,\n82,\n229,\n169,\n179,\n196,\n30,\n215,\n99,\n60,\n96,\n191,\n72,\n25,\n213,\n148,\n159,\n160,\n128,\n136,\n208,\n139,\n43,\n83,\n130,\n211,\n249,\n163,\n113,\n70,\n250,\n4,\n183,\n32,\n36,\n178,\n188,\n247,\n77,\n10,\n93,\n20,\n135,\n187,\n238,\n180,\n152,\n65,\n55,\n29,\n62,\n200,\n146,\n144,\n33,\n251,\n48,\n176,\n64,\n107,\n34,\n8,\n201,\n3,\n42,\n119,\n210,\n103,\n41,\n79,\n233,\n106,\n254,\n11,\n222,\n209,\n171,\n46,\n234,\n118,\n81,\n37,\n162,\n61,\n177,\n132,\n202,\n244,\n116,\n123,\n158,\n122,\n192,\n155,\n121,\n51,\n74,\n15,\n57,\n198,\n97,\n239,\n129,\n185,\n112,\n241,\n19);\nint rand(int x) {\n    return permutation[x & 255];\n}\nfloat randxy(vec2 xy, float t) {\n    return float(\n    rand(\n      rand(\n        rand(\n          int(floor(xy.x))\n        ) + int(floor(xy.y))\n      ) + int(floor(t))\n    )\n    ) / 255.0;\n}\n//  0   8   2  10\n// 12   4  14   6\n//  3  11   1   9\n// 15   7  13   5\n\n// 0000 1000 0010 1010\n// 1100 0100 1110 0110\n// 0011 1011 0001 1001\n// 1111 0111 1101 0101\nfloat crosshatch(vec2 xyf) {\n    ivec2 xy = ivec2(xyf) & 3;\n    return float(\n        1 +\n        + ((xy.y >> 1) & 1)\n        + ((xy.x & 2) ^ (xy.y & 2))\n        + ((xy.y & 1) << 2)\n        + ((((xy.x) & 1) ^ (xy.y & 1)) << 3)\n    )/ 16.;\n}\n\nvec3 ease(vec3 t) {\n    t = clamp(t, 0., 1.);\n    return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nvec3 posterize(vec3 col, float thres) {\nconst float steps = 4.;\n    return (floor(\n        col * steps\n    ) + step(\n        vec3(thres), fract(col * steps)\n    )) / steps;\n}\n\nfloat ease(float t) {\n    t = clamp(t, 0., 1.);\n    return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nfloat zigzag(float t) {\n    return 1. - abs(1. - fract(t) * 2.);\n}\n\nfloat ripple(vec2 uv, vec2 lightDir, float scale, float time) {\n    \n    return ease(zigzag(\n        length(uv) * scale - time\n    )) * 0.5 * dot(\n        lightDir,\n        normalize(uv) *\n        ease(length(uv) * scale * 1.25)\n    );\n}\n\nvec2 angleVec(float theta) {\n    return vec2(cos(theta), sin(theta));\n}\n\n// does pseudo overexposure filter\nvec3 deepfry(vec3 rgb, float x) {\n    rgb *= x;\n    return rgb + vec3(\n      max(0., rgb.g - 1.) + max(0., rgb.b - 1.),\n      max(0., rgb.b - 1.) + max(0., rgb.r - 1.),\n      max(0., rgb.r - 1.) + max(0., rgb.g - 1.)\n    );\n}\n\nfloat brightness(vec3 col) {\n    return (col.r * 0.3 + col.g * 0.59 + col.b * 0.11);\n}\n// hue rotation code\n// references a comment in https://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat3 rotAxis(float a) {\n    float s=sin(a);\n    float c=cos(a);\n    float oc=1.0-c;\n    vec3 axis=normalize(vec3(1.0));\n    vec3 as=axis*s;\n    mat3 p=mat3(axis.x*axis,axis.y*axis,axis.z*axis);\n    mat3 q=mat3(c,-as.z,as.y,as.z,c,-as.x,-as.y,as.x,c);\n    return p*oc+q;\n}\n\n// base spiral image\nvec3 base(vec2 uv, float time) {\n    vec2 rt = vec2(\n        1. * log(length(uv) + .1),\n        atan(uv.y, uv.x) / TAU\n    );\n    return ease(vec3(\n    zigzag(\n        rt.x + rt.y * -3. + sin(time * TAU)\n    ), zigzag(\n        rt.x + rt.y * 3. + sin((1. / 3. + time) * TAU)\n    ), zigzag(\n        rt.x + rt.y * 0. + sin((2. / 3. + time) * TAU)\n    )\n    )) * rotAxis(time * TAU);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Make sure this loops\n    float time = fract(iTime / 5.);\n    // Normalized pixel coordinates\n    vec2 uv = ( 2.* fragCoord - iResolution.xy ) / length(iResolution.xy);\n    float lightAngle = 1.7 + 0.45 * sin(2. * uv.x * TAU);\n    const float centerSep = 0.05;\n    const float centerSpeed = -0.;\n    float centerOfs = 2.5;\n    vec2 center0 = centerSep*angleVec(centerOfs + TAU*(centerSpeed*time));\n    vec2 center1 = centerSep*angleVec(centerOfs + TAU*(centerSpeed*time+1./3.));\n    vec2 center2 = centerSep*angleVec(centerOfs + TAU*(centerSpeed*time-1./3.));\n    \n    const float sizeScale = 5.;\n    const float timeScale = 5.;\n    \n    uv += ripple(\n            uv, angleVec(lightAngle),\n            sizeScale, 0. + time * timeScale\n        ) * vec2(0.2, 0.8) * log(1. + length(uv));\n    \n    //uv.x += 0.02 * sin(uv.y * 150.5 + time * 7. * TAU);\n    //uv.y += 0.002 * sin(uv.x * 14.7 + time * 11. * TAU + 0.2);\n   \n    float colorSep = 0.1;\n    vec3 col = vec3(0);\n    col +=\n        ripple(\n            uv - center0, angleVec(lightAngle + colorSep),\n            sizeScale, time * timeScale\n        ) * vec3(0.5,0.5,-1);\n    col +=\n        ripple(\n            uv - center1, angleVec(lightAngle),\n            sizeScale, time * timeScale\n        ) * vec3(-1,0.5,0.5);\n    col +=\n        ripple(\n            uv - center2, angleVec(lightAngle - colorSep),\n            sizeScale, time * timeScale\n        ) * vec3(0.5,-1,0.5);\n    // normalize luminance\n    // col -= vec3(col.r * 0.3 + col.g * 0.59 + col.b * 0.11);\n    \n    // saturation\n    float desat = brightness(col);\n    col = mix(\n        vec3(desat),\n        col,\n        1./4.\n    );\n    \n    // add highlights\n    float desatAA = fwidth(desat) * .75;\n    float highlights = smoothstep(\n        -desatAA,\n        desatAA,\n        desat - .1\n    );\n    \n    col = clamp(col + 0.5, 0., 1.);\n    \n    // color balance\n    // background graphics color\n    vec3 baseCol = base(uv, time);\n    baseCol = mix(vec3(brightness(baseCol)), baseCol, 0.5);\n    baseCol = 0.5 + (baseCol - 0.5) * 0.75;\n    \n    col = 1.0 * pow(\n        col, exp2(2. - 4. * baseCol)\n    );\n    \n    // resaturate\n    col = mix(\n        vec3(brightness(col)),\n        col,\n        1.7\n    );\n    \n    // overexpose\n    col = deepfry(max(vec3(0.), col), 1.2);\n    col *= 0.95;\n    // add highlights\n    col += highlights * vec3(2.);\n    \n    \n    // add b/w ripples\n    /*col +=\n        ripple(\n            uv, angleVec(lightAngle),\n            sizeScale, 0. + time * timeScale\n        ) * vec3(0.5);//*/\n    \n    // dither\n    col = posterize(\n        clamp(col, 0., 1.),\n        crosshatch(fragCoord + mod(iTime * 50., 2.) * vec2(1, 2))\n        //randxy(fragCoord, (60. * iTime))\n    );//*/\n    \n    // Output to screen\n    fragColor = vec4(\n        col, 1.0\n    );\n}","name":"Image","description":"","type":"image"}]}