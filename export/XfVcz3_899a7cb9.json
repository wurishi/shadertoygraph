{"ver":"0.1","info":{"id":"XfVcz3","date":"1732179047","viewed":27,"name":"function visualizer","username":"418cat","description":"small test shader to visualize square sin waves","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["oscilloscope","signal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constant defined later, represents how big\n// a screen pixel is in UV coords\nvec2 DELTA;\n\n/*\n * Centered on the origin\n * from -.5 to .5 for X\n * normalized for Y, from negative to positive too\n */\nvec2 pixToUv(vec2 pix)\n{\n    float x = pix.x / iResolution.x - .5;\n    \n    float y;\n    if(NORMALIZE)\n    {\n        y = (pix.y - iResolution.y / 2.) / iResolution.x;\n    }\n    else\n    {\n        y = pix.y / iResolution.y - 0.5;\n    }\n    \n    x += VIEW_OFFSET.x;\n    y += VIEW_OFFSET.y;\n    \n    x /= ZOOM.x;\n    y /= ZOOM.y;\n    \n    \n    return vec2(x, y);\n}\n\n\n/*\n * returns true if the distance between\n * the uv coord and the point is < to\n * the delta distance\n */\nbool uvIsPoint(vec2 uv, vec2 point)\n{\n    return abs(uv.x - point.x) <= (DELTA.x * DRAW_WIDTH / 2.) &&\n           abs(uv.y - point.y) <= (DELTA.y * DRAW_WIDTH / 2.);\n}\n\nbool uvIsBetween(){return true;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Normalized, zoomed and offset\n    vec2 uv = pixToUv(fragCoord);\n    \n    vec2 topRightPixUV = pixToUv(fragCoord + vec2(1., 1.));\n    DELTA = abs(topRightPixUV - uv);\n    \n    float time_x = VIEW_OFFSET.x / ZOOM.x + (mod(iTime*FUNCTION_SPEED, 1. / ZOOM.x) - (0.5 / ZOOM.x));\n    \n    float r = 0.;\n    float g = 0.;\n    float b = 0.;\n    \n    // draw grid\n    if(uvIsPoint(uv, vec2(uv.x, 0.))) r = 0.7;\n    if(uvIsPoint(uv, vec2(0., uv.y))) r = 0.7;\n    \n    float y = func(uv.x);\n    float yNext = func(uv.x + DELTA.x);\n    \n    if(FUNCTION_STATIC)\n    {\n        if(uvIsPoint(uv, vec2(uv.x, y)))\n        {\n            g = 1.;\n        }\n        \n        if(FUNCTION_FILL && ((uv.y >= y && uv.y <= yNext) || (uv.y <= y && uv.y >= yNext)))\n        {\n            g = 1.;\n        }\n    }\n    \n    if(!FUNCTION_STATIC)\n    {\n    \n        // If X is withing (time_ax +- DELTA.x)\n        if(uv.x < time_x+DELTA.x && uv.x > time_x-DELTA.x)\n        {\n            // If point is on curve\n            if(uvIsPoint(uv, vec2(uv.x, y))) g = 1.;\n            \n            // If point is located between two samples\n            if(FUNCTION_FILL &&\n                (uv.y >= y && uv.y <= yNext ^^\n                 uv.y <= y && uv.y >= yNext)) g = 1.;\n        }\n        \n        if(FUNCTION_TRAIL)\n        {\n            float tmp_time_x = time_x;\n            bool DRAW_X = false;\n            bool DRAW_POINT = false;\n            \n            // If trail wrap and X is ahead\n            DRAW_X = FUNCTION_TRAIL_WRAP && uv.x > time_x+DELTA.x;\n            \n            // set time_x to 1 screen ahead to have it wrap\n            if(DRAW_X) tmp_time_x += DELTA.x * iResolution.x;\n            \n            DRAW_X = DRAW_X || uv.x < tmp_time_x-DELTA.x;\n            \n            // If point is located between two samples\n            DRAW_POINT = FUNCTION_FILL &&\n                (uv.y >= y && uv.y <= yNext ^^\n                 uv.y <= y && uv.y >= yNext) && DRAW_X;\n            \n            DRAW_POINT = DRAW_POINT || (DRAW_X && uvIsPoint(uv, vec2(uv.x, y)));\n            \n            if(DRAW_POINT) g = 1.;\n            \n            // If trail fade enabled\n            if(FUNCTION_TRAIL_FADE)\n            {\n                g *= 1.- FUNCTION_TRAIL_FADE_SPEED*(tmp_time_x - uv.x);\n            }\n        }\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(r, g, b, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592653589793\n\n// View Settings\n#define ZOOM vec2(.1, 0.1)\n#define VIEW_OFFSET vec2(0./50., 0.)\n#define NORMALIZE true\n\n\n//  Graphics settings\n/**/#define DRAW_WIDTH 1.\n\n/**/#define FUNCTION_STATIC false\n/**/#define FUNCTION_FILL true\n\n/*  Only if FUNCTION_STATIC is false          */\n/*  */#define FUNCTION_SPEED 5.\n/*    Trail Settings                            */\n/*    */#define FUNCTION_TRAIL true\n/*    */#define FUNCTION_TRAIL_FADE true\n/*    */#define FUNCTION_TRAIL_FADE_SPEED 0.9\n/*    */#define FUNCTION_TRAIL_WRAP true\n\n\n// Function to be displayed\nfloat func(float x)\n{\n    float ampl =  .5;\n    float per  =  2.;\n    float len  =  1.;\n    \n    float freq = 1. / per;\n    float sum = ampl * len/per;\n    float fact = 2.*ampl  / PI;\n    \n    for(int i = 1; i <= 13; i++)\n    {\n        float f_i = float(i);\n        sum += 1. *\n        (\n            (1. / f_i) *\n            sin(PI * f_i * len / per)  *\n            cos(2.*PI * f_i * freq * x)\n        );\n    }\n    \n    return sum - ampl / 2.;\n}","name":"Common","description":"","type":"common"}]}