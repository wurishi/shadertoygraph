{"ver":"0.1","info":{"id":"Xdlczl","date":"1489478840","viewed":7224,"name":"Another better ocean","username":"afl_ext","description":"This time with more realistic atmosphere and SSS copied from VEngineNative.\nThe code is rather... intense... because it's really copied with just minor modifications from my desktop engine.","likes":97,"published":3,"flags":32,"usePreview":1,"tags":["procedural","waves","ocean","atmosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// afl_ext 2017 \n// This shader is 100% public domain (uses glsl-atmosphere, which is also public domain)\n \n#define time iTime\n#define mouse (iMouse.xy / iResolution.xy)\n#define resolution iResolution.xy\n\n\n#define time iTime\n#define mouse (iMouse.xy / iResolution.xy)\n#define resolution iResolution.xy\n\n// lower this if your GPU cries for mercy (set to 0 to remove clouds!)\n#define CLOUDS_STEPS 16\n#define ENABLE_SSS 1\n\n\n\n#define DRAG_MULT 0.28\n#define ITERATIONS_RAYMARCH 12\n#define ITERATIONS_NORMAL 40\n#define WATER_DEPTH 1.0\n\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\n    float x = dot(direction, position) * frequency + timeshift * speed;\n    float wave = exp(sin(x) - 1.0);\n    float dx = wave * cos(x);\n    return vec2(wave, -dx);\n}\n\nfloat getwaves(vec2 position, int iterations){\n\tfloat iter = 0.0;\n    float frequency = 1.0;\n    float speed = 2.0;\n    float weight = 1.0;\n    float w = 0.0;\n    float ws = 0.0;\n    for(int i=0;i<iterations;i++){\n        vec2 p = vec2(sin(iter), cos(iter));\n        vec2 res = wavedx(position, p, speed, frequency, iTime);\n        position += p * res.y * weight * DRAG_MULT;\n        w += res.x * weight;\n        iter += 1232.399963;\n        ws += weight;\n        weight *= 0.82;\n        frequency *= 1.18;\n        speed *= 1.07;\n    }\n    return (w / ws);\n}\n\nfloat raymarchwater(vec3 camera, vec3 start, vec3 end, float depth){\n    vec3 pos = start;\n    float h = 0.0;\n    float hupper = depth;\n    float hlower = 0.0;\n    vec2 zer = vec2(0.0);\n    vec3 dir = normalize(end - start);\n    for(int i=0;i<64;i++){\n        h = getwaves(pos.xz, ITERATIONS_RAYMARCH) * depth - depth;\n        if(h + 0.01 > pos.y) {\n            return distance(pos, camera);\n        }\n        pos += dir * (pos.y - h);\n    }\n    return distance(start, camera);\n}\n\nvec3 normal(vec2 pos, float e, float depth){\n    vec2 ex = vec2(e, 0);\n    float H = getwaves(pos.xy, ITERATIONS_NORMAL) * depth;\n    vec3 a = vec3(pos.x, H, pos.y);\n    return normalize(\n        cross(\n            (a-vec3(pos.x - e, getwaves(pos.xy - ex.xy, ITERATIONS_NORMAL) * depth, pos.y)), \n            (a-vec3(pos.x, getwaves(pos.xy + ex.yx, ITERATIONS_NORMAL) * depth, pos.y + e))\n        )\n    );\n}\n\nmat3 rotmat(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\t\n\treturn mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\nvec3 getRay(vec2 uv){\n   uv = (uv * 2.0 - 1.0)* vec2(resolution.x / resolution.y, 1.0);\n\tvec3 proj = normalize(vec3(uv.x, uv.y, 1.5));\t\n    if(resolution.y < 400.0) return proj;\n\tvec3 ray = rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (mouse.y * 2.0 - 1.0)) * proj;\n    return ray;\n}\n\nfloat rand2sTime(vec2 co){\n    co *= time;\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal)\n{ \n    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \n}\n#define PI 3.141592\n#define iSteps 16\n#define jSteps 8\n\nvec2 rsi(vec3 r0, vec3 rd, float sr) {\n    // ray-sphere intersection that assumes\n    // the sphere is centered at the origin.\n    // No intersection when result.x > result.y\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(rd, r0);\n    float c = dot(r0, r0) - (sr * sr);\n    float d = (b*b) - 4.0*a*c;\n    if (d < 0.0) return vec2(1e5,-1e5);\n    return vec2(\n        (-b - sqrt(d))/(2.0*a),\n        (-b + sqrt(d))/(2.0*a)\n    );\n}\n\nfloat oct(float p){\n    return fract(4768.1232345456 * sin(p));\n}\nfloat oct(vec2 p){\n    return fract(4768.1232345456 * sin((p.x+p.y*43.0)));\n}\nfloat oct(vec3 p){\n    return fract(4768.1232345456 * sin((p.x+p.y*43.0+p.z*137.0)));\n}\nfloat oct(vec4 p){\n    return fract(4768.1232345456 * sin((p.x+p.y*43.0+p.z*137.0+p.w*2666.0)));\n}\n\nfloat achnoise(float x){\n    float p = floor(x);\n    float fr = fract(x);\n    float L = p;\n    float R = p + 1.0;\n\n    float Lo = oct(L);\n    float Ro = oct(R);\n\n    return mix(Lo, Ro, fr);\n}\n\nfloat achnoise(vec2 x){\n    vec2 p = floor(x);\n    vec2 fr = fract(x);\n    vec2 LB = p;\n    vec2 LT = p + vec2(0.0, 1.0);\n    vec2 RB = p + vec2(1.0, 0.0);\n    vec2 RT = p + vec2(1.0, 1.0);\n\n    float LBo = oct(LB);\n    float RBo = oct(RB);\n    float LTo = oct(LT);\n    float RTo = oct(RT);\n\n    float noise1d1 = mix(LBo, RBo, fr.x);\n    float noise1d2 = mix(LTo, RTo, fr.x);\n\n    float noise2d = mix(noise1d1, noise1d2, fr.y);\n\n    return noise2d;\n}\nfloat achnoise(vec3 x){\n    vec3 p = floor(x);\n    vec3 fr = fract(x);\n    vec3 LBZ = p + vec3(0.0, 0.0, 0.0);\n    vec3 LTZ = p + vec3(0.0, 1.0, 0.0);\n    vec3 RBZ = p + vec3(1.0, 0.0, 0.0);\n    vec3 RTZ = p + vec3(1.0, 1.0, 0.0);\n\n    vec3 LBF = p + vec3(0.0, 0.0, 1.0);\n    vec3 LTF = p + vec3(0.0, 1.0, 1.0);\n    vec3 RBF = p + vec3(1.0, 0.0, 1.0);\n    vec3 RTF = p + vec3(1.0, 1.0, 1.0);\n\n    float l0candidate1 = oct(LBZ);\n    float l0candidate2 = oct(RBZ);\n    float l0candidate3 = oct(LTZ);\n    float l0candidate4 = oct(RTZ);\n\n    float l0candidate5 = oct(LBF);\n    float l0candidate6 = oct(RBF);\n    float l0candidate7 = oct(LTF);\n    float l0candidate8 = oct(RTF);\n\n    float l1candidate1 = mix(l0candidate1, l0candidate2, fr[0]);\n    float l1candidate2 = mix(l0candidate3, l0candidate4, fr[0]);\n    float l1candidate3 = mix(l0candidate5, l0candidate6, fr[0]);\n    float l1candidate4 = mix(l0candidate7, l0candidate8, fr[0]);\n\n\n    float l2candidate1 = mix(l1candidate1, l1candidate2, fr[1]);\n    float l2candidate2 = mix(l1candidate3, l1candidate4, fr[1]);\n\n\n    float l3candidate1 = mix(l2candidate1, l2candidate2, fr[2]);\n\n    return l3candidate1;\n}\n\n\nfloat achnoise(vec4 x){\n    vec4 p = floor(x);\n    vec4 fr = fract(x);\n    vec4 LBZU = p + vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 LTZU = p + vec4(0.0, 1.0, 0.0, 0.0);\n    vec4 RBZU = p + vec4(1.0, 0.0, 0.0, 0.0);\n    vec4 RTZU = p + vec4(1.0, 1.0, 0.0, 0.0);\n\n    vec4 LBFU = p + vec4(0.0, 0.0, 1.0, 0.0);\n    vec4 LTFU = p + vec4(0.0, 1.0, 1.0, 0.0);\n    vec4 RBFU = p + vec4(1.0, 0.0, 1.0, 0.0);\n    vec4 RTFU = p + vec4(1.0, 1.0, 1.0, 0.0);\n\n    vec4 LBZD = p + vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 LTZD = p + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 RBZD = p + vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 RTZD = p + vec4(1.0, 1.0, 0.0, 1.0);\n\n    vec4 LBFD = p + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 LTFD = p + vec4(0.0, 1.0, 1.0, 1.0);\n    vec4 RBFD = p + vec4(1.0, 0.0, 1.0, 1.0);\n    vec4 RTFD = p + vec4(1.0, 1.0, 1.0, 1.0);\n\n    float l0candidate1  = oct(LBZU);\n    float l0candidate2  = oct(RBZU);\n    float l0candidate3  = oct(LTZU);\n    float l0candidate4  = oct(RTZU);\n\n    float l0candidate5  = oct(LBFU);\n    float l0candidate6  = oct(RBFU);\n    float l0candidate7  = oct(LTFU);\n    float l0candidate8  = oct(RTFU);\n\n    float l0candidate9  = oct(LBZD);\n    float l0candidate10 = oct(RBZD);\n    float l0candidate11 = oct(LTZD);\n    float l0candidate12 = oct(RTZD);\n\n    float l0candidate13 = oct(LBFD);\n    float l0candidate14 = oct(RBFD);\n    float l0candidate15 = oct(LTFD);\n    float l0candidate16 = oct(RTFD);\n\n    float l1candidate1 = mix(l0candidate1, l0candidate2, fr[0]);\n    float l1candidate2 = mix(l0candidate3, l0candidate4, fr[0]);\n    float l1candidate3 = mix(l0candidate5, l0candidate6, fr[0]);\n    float l1candidate4 = mix(l0candidate7, l0candidate8, fr[0]);\n    float l1candidate5 = mix(l0candidate9, l0candidate10, fr[0]);\n    float l1candidate6 = mix(l0candidate11, l0candidate12, fr[0]);\n    float l1candidate7 = mix(l0candidate13, l0candidate14, fr[0]);\n    float l1candidate8 = mix(l0candidate15, l0candidate16, fr[0]);\n\n\n    float l2candidate1 = mix(l1candidate1, l1candidate2, fr[1]);\n    float l2candidate2 = mix(l1candidate3, l1candidate4, fr[1]);\n    float l2candidate3 = mix(l1candidate5, l1candidate6, fr[1]);\n    float l2candidate4 = mix(l1candidate7, l1candidate8, fr[1]);\n\n\n    float l3candidate1 = mix(l2candidate1, l2candidate2, fr[2]);\n    float l3candidate2 = mix(l2candidate3, l2candidate4, fr[2]);\n\n    float l4candidate1 = mix(l3candidate1, l3candidate2, fr[3]);\n\n    return l4candidate1;\n}\n\n#define noise1d(a) achnoise(a)\n#define noise2d(a) achnoise(a)\n#define noise3d(a) achnoise(a)\n#define noise4d(a) achnoise(a)\nfloat supernoise3d(vec3 p){\n\n\tfloat a =  noise3d(p);\n\tfloat b =  noise3d(p + 10.5);\n\treturn (a + b) * 0.5;\n}\nfloat supernoise3dX(vec3 p){\n\n\tfloat a =  noise3d(p);\n\tfloat b =  noise3d(p + 10.5);\n\treturn (a * b);\n}\nfloat fbmHI(vec3 p){\n   // p *= 0.1;\n    p *= 0.0000169;\n    p.x *= 0.489;\n\tp += time * 0.02;\n\t//p += getWind(p * 0.2) * 6.0;\n\tfloat a = 0.0;\n    float w = 1.0;\n    float wc = 0.0;\n\tfor(int i=0;i<3;i++){\n        //p += noise(vec3(a));\n\t\ta += clamp(2.0 * abs(0.5 - (noise3d(p))) * w, 0.0, 1.0);\n\t\twc += w;\n        w *= 0.5;\n\t\tp = p * 3.0;\n\t}\n\treturn a / wc;// + noise(p * 100.0) * 11;\n}\n#define MieScattCoeff 4.0\nvec3 wind(vec3 p){\n    return vec3(\n        supernoise3d(p),\n        supernoise3d(p.yzx),\n        supernoise3d(-p.xzy)\n        ) * 2.0 - 1.0;\n}\nstruct Ray { vec3 o; vec3 d; };\nstruct Sphere { vec3 pos; float rad; };\n\nfloat planetradius = 6378000.1;\nfloat minhit = 0.0;\nfloat maxhit = 0.0;\nfloat rsi2(in Ray ray, in Sphere sphere)\n{\n    vec3 oc = ray.o - sphere.pos;\n    float b = 2.0 * dot(ray.d, oc);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float disc = b * b - 4.0 * c;\n    vec2 ex = vec2(-b - sqrt(disc), -b + sqrt(disc))/2.0;\n    minhit = min(ex.x, ex.y);\n    maxhit = max(ex.x, ex.y);\n    return mix(ex.y, ex.x, step(0.0, ex.x));\n}\nvec3 atmosphere(vec3 r, vec3 r0, vec3 pSun, float iSun, float rPlanet, float rAtmos, vec3 kRlh, float kMie, float shRlh, float shMie, float g) {\n    // Normalize the sun and view directions.\n    pSun = normalize(pSun);\n    r = normalize(r);\n\n    // Calculate the step size of the primary ray.\n    vec2 p = rsi(r0, r, rAtmos);\n    if (p.x > p.y) return vec3(0,0,0);\n    p.y = min(p.y, rsi(r0, r, rPlanet).x);\n    float iStepSize = (p.y - p.x) / float(iSteps);\n\tfloat rs = rsi2(Ray(r0, r), Sphere(vec3(0), rAtmos));\n\tvec3 px = r0 + r * rs;\nshMie *= ( (pow(fbmHI(px  ) * (supernoise3dX(px* 0.00000669 + time * 0.001)*0.5 + 0.5) * 1.3, 3.0) * 0.8 + 0.5));\n    \n    // Initialize the primary ray time.\n    float iTime = 0.0;\n\n    // Initialize accumulators for Rayleigh and Mie scattering.\n    vec3 totalRlh = vec3(0,0,0);\n    vec3 totalMie = vec3(0,0,0);\n\n    // Initialize optical depth accumulators for the primary ray.\n    float iOdRlh = 0.0;\n    float iOdMie = 0.0;\n\n    // Calculate the Rayleigh and Mie phases.\n    float mu = dot(r, pSun);\n    float mumu = mu * mu;\n    float gg = g * g;\n    float pRlh = 3.0 / (16.0 * PI) * (1.0 + mumu);\n    float pMie = 3.0 / (8.0 * PI) * ((1.0 - gg) * (mumu + 1.0)) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg));\n\n    // Sample the primary ray.\n    for (int i = 0; i < iSteps; i++) {\n\n        // Calculate the primary ray sample position.\n        vec3 iPos = r0 + r * (iTime + iStepSize * 0.5);\n\n        // Calculate the height of the sample.\n        float iHeight = length(iPos) - rPlanet;\n\n        // Calculate the optical depth of the Rayleigh and Mie scattering for this step.\n        float odStepRlh = exp(-iHeight / shRlh) * iStepSize;\n        float odStepMie = exp(-iHeight / shMie) * iStepSize;\n\n        // Accumulate optical depth.\n        iOdRlh += odStepRlh;\n        iOdMie += odStepMie;\n\n        // Calculate the step size of the secondary ray.\n        float jStepSize = rsi(iPos, pSun, rAtmos).y / float(jSteps);\n\n        // Initialize the secondary ray time.\n        float jTime = 0.0;\n\n        // Initialize optical depth accumulators for the secondary ray.\n        float jOdRlh = 0.0;\n        float jOdMie = 0.0;\n\n        // Sample the secondary ray.\n        for (int j = 0; j < jSteps; j++) {\n\n            // Calculate the secondary ray sample position.\n            vec3 jPos = iPos + pSun * (jTime + jStepSize * 0.5);\n\n            // Calculate the height of the sample.\n            float jHeight = length(jPos) - rPlanet;\n\n            // Accumulate the optical depth.\n            jOdRlh += exp(-jHeight / shRlh) * jStepSize;\n            jOdMie += exp(-jHeight / shMie) * jStepSize;\n\n            // Increment the secondary ray time.\n            jTime += jStepSize;\n        }\n\n        // Calculate attenuation.\n        vec3 attn = exp(-(kMie * (iOdMie + jOdMie) + kRlh * (iOdRlh + jOdRlh)));\n\n        // Accumulate scattering.\n        totalRlh += odStepRlh * attn;\n        totalMie += odStepMie * attn;\n\n        // Increment the primary ray time.\n        iTime += iStepSize;\n\n    }\n\n    // Calculate and return the final color.\n    return iSun * (pRlh * kRlh * totalRlh + pMie * kMie * totalMie);\n}\nvec3 getatm(vec3 ray){\n\tvec3 sd = rotmat(vec3(1.0, 1.0, 0.0), time * 0.25) * normalize(vec3(0.0, 1.0, 0.0)); \n    vec3 color = atmosphere(\n        ray,           // normalized ray direction\n        vec3(0,6372e3,0),               // ray origin\n        sd,                        // position of the sun\n        22.0,                           // intensity of the sun\n        6371e3,                         // radius of the planet in meters\n        6471e3,                         // radius of the atmosphere in meters\n        vec3(5.5e-6, 13.0e-6, 22.4e-6), // Rayleigh scattering coefficient\n        21e-6,                          // Mie scattering coefficient\n        8e3,                            // Rayleigh scale height\n        1.2e3 * MieScattCoeff,                          // Mie scale height\n        0.758                           // Mie preferred scattering direction\n    );\t\t\n \treturn color;\n    \n}\n\nfloat sun(vec3 ray){\n \tvec3 sd = rotmat(vec3(1.0, 1.0, 0.0), time * 0.25) * normalize(vec3(0.0, 1.0, 0.0)); \n\n    return pow(max(0.0, dot(ray, sd)), 1228.0) * 110.0;\n}\nfloat smart_inverse_dot(float dt, float coeff){\n    return 1.0 - (1.0 / (1.0 + dt * coeff));\n}\n#define VECTOR_UP vec3(0.0,1.0,0.0)\nvec3 getSunColorDirectly(float roughness){\n    vec3 sunBase = vec3(15.0);\n\tvec3 sd = rotmat(vec3(1.0, 1.0, 0.0), time * 0.25) * normalize(vec3(0.0, 1.0, 0.0)); \n\n    float dt = max(0.0, (dot(sd, VECTOR_UP)));\n    float dtx = smoothstep(-0.0, 0.1, dt);\n    float dt2 = 0.9 + 0.1 * (1.0 - dt);\n    float st = max(0.0, 1.0 - smart_inverse_dot(dt, 11.0));\n    vec3 supersundir = max(vec3(0.0),   vec3(1.0) - st * 4.0 * pow(vec3(50.0/255.0, 111.0/255.0, 153.0/255.0), vec3(2.4)));\n//    supersundir /= length(supersundir) * 1.0 + 1.0;\n    return supersundir * 4.0 ;\n    //return mix(supersundir * 1.0, sunBase, st);\n    //return  max(vec3(0.3, 0.3, 0.0), (  sunBase - vec3(5.5, 18.0, 20.4) *  pow(1.0 - dt, 8.0)));\n}\n#define xsupernoise3d(a) abs(0.5 - noise3d(a))*2.0\n#define xsupernoise3dx(a) abs(0.5 - supernoise3d(a))*2.0\nfloat fbmHxI(vec3 p){\n   // p *= 0.1;\n    p *= 0.021;\n    float a = 0.0;\n    float w = 0.5;\n    for(int i=0;i<6;i++){\n\tfloat x = xsupernoise3dx(p);\n        a += x * w;\n        p = p * (2.9 + x * w * 0.006 );\n        w *= 0.60;\n    }\n    return a;\n}\n\n\n\nfloat gw5d_hash(float p){\n    return fract(4768.1232345456 * sin(p));\n}\n\nvec2 gw5d_wavedx(vec3 position, vec3 direction, float speed, float frequency, float timeshift) {\n    float x = dot(direction, position) * frequency + timeshift * speed;\n    float wave = exp(sin(x) - 1.0);\n    float dx = wave * cos(x);\n    return vec2(wave, -dx);\n}\n\nfloat gw5d_seedWaves = 70.0;\nvec3 gw5d_randWaves(){\n    float x = gw5d_hash(gw5d_seedWaves);\n    gw5d_seedWaves += 1.0;\n    float y = gw5d_hash(gw5d_seedWaves);\n    gw5d_seedWaves += 1.0;\n    float z = gw5d_hash(gw5d_seedWaves);\n    gw5d_seedWaves += 1.0;\n    return normalize(vec3(x,y,z) * 2.0 - 1.0);\n}\n\nfloat getwaves5d(int iters, vec3 position, float dragmult, float timeshift){\n    float frequency = 1.0;\n    float speed = 2.0;\n    float weight = 1.0;\n    float w = 0.0;\n    float ws = 0.0;\n    for(int i=0;i<iters;i++){\n        vec3 p = gw5d_randWaves();\n        vec2 res = gw5d_wavedx(position, p, speed, frequency, timeshift);\n        position += p * res.y * weight * dragmult;\n        w += res.x * weight;\n        ws += weight;\n        weight = weight * 0.86;\n        frequency *= 1.38;\n        speed *= 1.02;\n    }\n    return w / ws;\n}\n\n\n#define CloudsFloor 1700.0\n#define CloudsCeil 5000.0\n\nfloat getHeightOverSea(vec3 p){\n    vec3 atmpos = vec3(0.0, planetradius, 0.0) + p;\n    return length(atmpos) - planetradius;\n}\nvec2 mirrored(vec2 v) {\n    vec2 m = mod(v, 2.0);\n    return mix(m, 2.0 - m, step(1.0, m));\n}\n\nvec2 cloudsDensity3D(vec3 pos){\n    float h = getHeightOverSea(pos);\n    float innerh = (h - CloudsFloor) / (CloudsCeil - CloudsFloor);\n    \n    float measurement = (CloudsCeil - CloudsFloor) * 0.5;\n    float mediana = (CloudsCeil + CloudsFloor) * 0.5;\n    float mlt = (( 1.0 - (abs( h - mediana ) / measurement )));\n      gw5d_seedWaves = 0.0;\n    \n    float density = fbmHxI(pos * 0.01 + iTime * 0.04)\n    * (getwaves5d(8, pos.yxz * 0.0017, 1.1, iTime * 0.01) * 0.5 + 0.5);\n    \n    return  vec2(density * mlt, innerh) ;\n}\n\n\nvec2 UV = vec2(0.0);\nvec4 internalmarchconservative(vec3 atm, vec3 p1, vec3 p2, float noisestrength){\n    int stepcount = CLOUDS_STEPS;\n    float stepsize = 1.0 / float(stepcount);\n    float rd = fract(rand2sTime(UV)) * stepsize;\n    float c = 0.0;\n    float w = 0.0;\n    float coverageinv = 1.0;\n    vec3 pos = vec3(0);\n    float clouds = 0.0;\n    vec3 color = vec3(0.0);\n\tfloat colorw = 1.01;                      \n    float godr = 0.0;\n    float godw = 0.0;\n    float depw = 0.0;\n    float iter = 0.0;\n    vec3 lastpos = p1;\n    float linear = distance(p1, mix(p1, p2, stepsize));\n    float limit = distance(p1, p2);\n    while(iter < 1.0 && coverageinv > 0.0){\n        pos = mix(p1, p2, iter + rd);\n        vec2 as = cloudsDensity3D(pos);\n        float xasc = smoothstep(0.2, 0.3, as.x);\n\t\tvec3 timev = vec3(time*0.01, time * 0.01, 0.0);\n        clouds = xasc;\n        float W = clouds * max(0.0, coverageinv);\n        color += W * vec3(pow(as.y * 1.0, 2.0));\n        colorw += W;\n\n        coverageinv -= clouds;\n        lastpos = pos;\n      // if ax is 0 then step should be longer\n      // if ax is higher then step shorter\n        iter += stepsize * 0.1 + stepsize * 2.0 * (0.2 - as.x);\n        //rd = fract(rd + iter * 124.345345);\n    }\n    float cv = 1.0 - clamp(coverageinv, 0.0, 1.0);\n    //color *= getSunColorDirectly(0.0) * 4.0;\n\tvec3 sd = rotmat(vec3(1.0, 1.0, 0.0), time * 0.25) * normalize(vec3(0.0, 1.0, 0.0)); \n  \n    vec3 initialC = color / colorw;\n  \n    vec3 scatterDirect = initialC * getSunColorDirectly(0.0) \n      * pow(max(0.0, 0.5 + 0.5 * dot(sd, normalize(p2 - p1))), 4.0) \n      * sqrt(max(0.0, dot(sd, VECTOR_UP)))\n      * 20.0;\n    vec3 scatterIndirect = initialC * getSunColorDirectly(0.0) \n    * sqrt(max(0.0, dot(sd, VECTOR_UP))) * 10.0;\n     \n    //color *= 0.8 + 0.05 * (1.0 / (0.2 + 1.0 * (1.0 - max(0.0, dot(sd, normalize(p2 - p1))))));\n   // return ;//vec4(sqrt(max(0.0, (dot(sd, VECTOR_UP))))\n    // * mix((color / colorw), atm * 0.41, ), cv);\n  return vec4(scatterDirect + scatterIndirect, cv);\n}\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\nfloat flare(vec3 p, vec3 r){\n\treturn supernoise3dX(10.0 * normalize(p - r))  / pow(distance(p, r) * 10.0, 5.0);\t\n}\nfloat cloudsSss(vec3 p, vec3 r){\n\treturn 1.0 / pow(distance(p, r) * 1.0, 2.0);\t\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / resolution.xy;\n \tUV = uv;\n \tvec3 sd = rotmat(vec3(1.0, 1.0, 0.0), time * 0.25) * normalize(vec3(0.0, 1.0, 0.0)); \n\tfloat waterdepth = 1.0;\n\tvec3 wfloor = vec3(0.0, -waterdepth, 0.0);\n\tvec3 wceil = vec3(0.0, 0.0, 0.0);\n\tvec3 orig = vec3(iTime, 1.0, iTime);\n\tvec3 ray = getRay(uv);\n\t\n\tfloat spherehit = rsi2(Ray(orig, ray), Sphere(vec3(-2.0, 3.0, 0.0), 1.0));\n\tfloat fff = 1.0;\n\t\n\t\n\tfloat hihit = intersectPlane(orig, ray, wceil, vec3(0.0, 1.0, 0.0));\n    \n    Sphere sphere1 = Sphere(vec3(0), planetradius + CloudsFloor);\n    Sphere sphere2 = Sphere(vec3(0), planetradius + CloudsCeil);\n    if(ray.y >= 0.0){\n        vec3 rray = vec3(ray.x, abs(ray.y), ray.z);\n        vec3 atm = getatm(rray);\n        vec3 C = atm * 2.0 + sun(rray);\n        \n        vec3 atmorg = vec3(0,planetradius,0);\n        Ray r = Ray(atmorg, rray);\n        float hitfloor = rsi2(r, sphere1);\n        float hitceil = rsi2(r, sphere2);\n        vec4 clouds = internalmarchconservative(atm, rray * hitfloor, rray * hitceil, 1.0);\n        C = mix(C, clouds.xyz, clouds.a);\n\t    C *= fff * 0.5;\n        //tonemapping\n        C = aces_tonemap(C);\n     \tfragColor = vec4( C,1.0);   \n        return;\n    }\n    vec3 fullcolor = vec3(0.0);\n    vec2 pixel = 1.0 / iResolution.xy;\n    ray = getRay(uv);\n\n\n    fff = 1.0;\n\n\n    hihit = intersectPlane(orig, ray, wceil, vec3(0.0, 1.0, 0.0));\n\n    float lohit = intersectPlane(orig, ray, wfloor, vec3(0.0, 1.0, 0.0));\n    vec3 hipos = orig + ray * hihit;\n    vec3 lopos = orig + ray * lohit;\n    float dist = raymarchwater(orig, hipos, lopos, waterdepth);\n    vec3 pos = orig + ray * dist;\n\n    vec3 N = normal(pos.xz, 0.01, waterdepth);\n    N = mix(N, VECTOR_UP, 0.8 * min(1.0, sqrt(dist*0.01) * 1.1));\n    vec2 velocity = N.xz * (1.0 - N.y);\n    vec3 R = normalize(reflect(ray, N));\n    vec3 RF = normalize(refract(ray, N, 0.66)); \n    float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\n\n    R.y = abs(R.y);\n    vec3 atm = getatm(R);\n    vec3 reflection = atm + sun(R);\n  \n    vec3 rray = R;\n    vec3 atmorg = vec3(0,planetradius,0);\n    Ray r = Ray(atmorg + pos, rray);\n    float hitfloor = rsi2(r, sphere1);\n    float hitceil = rsi2(r, sphere2);\n    vec4 clouds = internalmarchconservative(atm, rray * hitfloor, rray * hitceil, 1.0);\n    reflection = mix(reflection, clouds.xyz, clouds.a);\n\n    vec3 C = fresnel * (reflection) * 2.0;\n\n    float superscat = pow(max(0.0, dot(RF, sd)), 16.0) ;\n    #if ENABLE_SSS\n    C += vec3(0.5,0.9,0.8) * superscat * getSunColorDirectly(0.0) * 81.0* (1.0 - 1.0 / (1.0 + 5.0 * max(0.0, dot(sd, VECTOR_UP))));\n    vec3 waterSSScolor =  vec3(0.01, 0.33, 0.55)*  0.171 ;\n    C += waterSSScolor * getSunColorDirectly(0.0) * (0.3 + getwaves(pos.xz, ITERATIONS_RAYMARCH)) * waterdepth * 0.3 * max(0.0, dot(sd, VECTOR_UP));\n    //tonemapping\n    #endif\n    C *= fff * 0.5;\n    C = aces_tonemap(C);\n    fullcolor += C;\n    \n\tfragColor = vec4(fullcolor,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat oct(vec2 p){\n    return fract(4768.1232345456 * sin((p.x+p.y*43.0)));\n}\nfloat noise2d(vec2 x){\n    vec2 p = floor(x);\n    vec2 fr = fract(x);\n    vec2 LB = p;\n    vec2 LT = p + vec2(0.0, 1.0);\n    vec2 RB = p + vec2(1.0, 0.0);\n    vec2 RT = p + vec2(1.0, 1.0);\n\n    float LBo = oct(LB);\n    float RBo = oct(RB);\n    float LTo = oct(LT);\n    float RTo = oct(RT);\n\n    float noise1d1 = mix(LBo, RBo, fr.x);\n    float noise1d2 = mix(LTo, RTo, fr.x);\n\n    float noise2d = mix(noise1d1, noise1d2, fr.y);\n\n    return noise2d;\n}\nfloat fbm(vec2 uv){\n    return noise2d(uv) * 0.5 + \n        noise2d(uv*3.0) * 0.25 + \n        noise2d(uv*6.0) * 0.125 + \n        noise2d(uv*12.0) * 0.064 + \n        noise2d(uv*24.0) * 0.032 + \n        noise2d(uv*48.0) * 0.032; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float n = fbm(uv * 30.0 + fbm(uv * 30.0));\n    float clouds = smoothstep(0.15,1.0, n);\n    fragColor = vec4(clouds);\n}","name":"Buffer A","description":"","type":"buffer"}]}