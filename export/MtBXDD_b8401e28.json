{"ver":"0.1","info":{"id":"MtBXDD","date":"1443819472","viewed":278,"name":"Patch Notes","username":"jameswilddev","description":"Was trying to make a System Shock-style landscape wherein it's two tile heightmaps converging on the horizon.  Found this on the way.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingquadpatch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/* Gets the height of the floor on a specified tile, where:\n\tR: X-, Y-,\n\tG: X+, Y-,\n\tB: X-, Y+,\n\tA: X+, Y+.\n*/\nvec4 tileHeight(vec2 tile) {\n    return vec4(texture(iChannel1, tile / 50.0).r) * 3.0;\n    //return vec4(sin(floor(tile.x)) + sin(floor(tile.y) + iTime));\n}\n\nfloat floorHeight(vec2 xz) {\n    xz *= 0.125;\n    vec4 tile = tileHeight(xz);\n    vec2 local = fract(xz);\n    vec2 between = mix(tile.rb, tile.ga, local.x);\n    return mix(between.x, between.y, local.y);\n}\n\nfloat distanceToWall(float distanceOnAxis, float y, float sampleY) {\n    float yDist = max(0.0, y - sampleY);\n    //return sqrt(distanceOnAxis * distanceOnAxis + yDist * yDist);\n    return length(vec2(distanceOnAxis, yDist));\n}\n\nfloat distanceToCorner(vec2 cornerDiff, float y, float sampleY) {\n    float yDist = min(0.0, y - sampleY);\n    return length(vec3(cornerDiff, yDist));\n}\n\nfloat scene(vec3 xyz) {\n    float distanceToFloor = xyz.y - floorHeight(xyz.xz);\n    vec2 local = fract(xyz.xz);\n    float distanceXN = distanceToWall(local.x, xyz.y, floorHeight(vec2(floor(xyz.x), xyz.z)));\n    float distanceXP = distanceToWall(1.0 - local.x, xyz.y, floorHeight(vec2(ceil(xyz.x), xyz.z)));\n    float distanceYN = distanceToWall(local.y, xyz.y, floorHeight(vec2(xyz.x, floor(xyz.z))));\n    float distanceYP = distanceToWall(1.0 - local.y, xyz.y, floorHeight(vec2(xyz.x, ceil(xyz.z))));\n    //float distanceNN = distanceToCorner(local, xyz.y, floorHeight(vec2(floor(xyz.x), floor(xyz.z))));\n    //float distanceNP = distanceToCorner(local, xyz.y, floorHeight(vec2(floor(xyz.x), floor(xyz.z))));\n    //float distancePN = distanceToCorner(local, xyz.y, floorHeight(vec2(floor(xyz.x), floor(xyz.z))));\n    //float distanceOP = distanceToCorner(local, xyz.y, floorHeight(vec2(floor(xyz.x), floor(xyz.z))));\n    return\n        min(distanceToFloor, \n            min(min(min(distanceXN, distanceXP), distanceYN), distanceYP));\n}\n\n// Returns the location of the current fragment relative to the center of the screen, where 0.5 is the distance to the nearest screen border.\n// This will return values > +-0.5 on the X axis in widescreen, and the Y axis in portrait.\nvec2 pixelCoord(vec2 fragCoord) { \n\treturn ((fragCoord - (iResolution.xy / 2.0)) / min(iResolution.x, iResolution.y)); \n}\n\n// Builds a normal looking down Z+.\nvec3 lens(vec2 pixelCoord, float fieldOfView) {\n\treturn normalize(vec3(pixelCoord, fieldOfView));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 norm = lens(pixelCoord(fragCoord), 0.2);\n    vec3 loc = vec3(5.0, 3.0, iTime);\n    float dis;\n    for(int i = 0; i < 16; i++) {\n        dis = scene(loc);\n        loc += norm * dis;\n    }\n\tfragColor = vec4(0.0, texture(iChannel0, loc.xz).r, 0.0, 0.0) / (dis + 1.0);\n}","name":"","description":"","type":"image"}]}