{"ver":"0.1","info":{"id":"M3jcRh","date":"1726970544","viewed":29,"name":"merlin oilslick","username":"alalalat","description":"give it some time, it goes places","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["blue"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Original code by Inigo Quilez, refactored by Alalalat\n\n// Simplex Noise (2D) implementation\n\nvec2 hash(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)),\n             dot(p, vec2(269.5, 183.3)));\n    return fract(sin(p) * 43758.5453123) * 2.0 - 1.0;\n}\n\nfloat noise(vec2 p) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2\n    const float K2 = 0.211324865; // (3-sqrt(3))/6\n\n    vec2 i = floor(p + (p.x + p.y) * K1);\n    vec2 a = p - i + (i.x + i.y) * K2;\n    float m = step(a.y, a.x);\n    vec2 o = vec2(m, 1.0 - m);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0 * K2;\n\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    h = h * h * h * h;\n\n    vec3 grad = vec3(dot(a, hash(i + vec2(0.0))),\n                     dot(b, hash(i + o)),\n                     dot(c, hash(i + vec2(1.0))));\n    return dot(h, grad) * 70.0;\n}\n\nvec2 rotate(vec2 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c) * p;\n}\n\nfloat noise4(vec2 uv, float time) {\n    float f = 0.5;\n    float frequency = 1.75;\n    float amplitude = 0.5;\n    for(int i = 0; i < 7; i++) {\n        vec2 offset = rotate(vec2(log(time + 3.0), log(time + 3.0) / 9.0), time / 99.0);\n        f += amplitude * noise(frequency * uv - offset);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord / iResolution.xy;\n    vec2 uv = p * vec2(iResolution.x / iResolution.y, 0.8);\n    uv = rotate(uv, log(iTime) / -7.0);\n\n    // Define color intervals\n    const float interval = 10.0;\n    vec3 dblue = interval * vec3(1.8, 2.6, 2.6);\n    vec3 cyan = interval * vec3(0.0, 2.1, 2.0);\n    vec3 magenta = interval * vec3(1.8, 1.0, 1.8);\n\n    vec3 color = vec3(0.75);\n\n    // First noise layer\n    float f = noise4(uv + noise4(uv, iTime) * (log(iTime + 1.0) + iTime / 60.0), iTime);\n    color += f * normalize(dblue);\n\n    // Second noise layer\n    f = noise4(f * rotate(uv, sin(iTime / 11.0)) + f * noise4(f * uv, iTime), iTime);\n    color += f * normalize(cyan);\n\n    // Third noise layer\n    f = noise4(f * rotate(uv, iTime / 7.0) + f * noise4(uv, iTime) * noise4(uv, iTime), iTime);\n    color += f * normalize(magenta);\n\n    // Normalize color\n    color = normalize(color)*normalize(color)*normalize(color);\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}