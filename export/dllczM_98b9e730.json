{"ver":"0.1","info":{"id":"dllczM","date":"1691013822","viewed":44,"name":"Phantasm","username":"bartruefal","description":"“Beware the ball”","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RM_MAX_STEPS 100\n#define RM_MAX_DIST 100.0f\n#define RM_MIN_DIST 0.01f\n\nfloat SphereSDF( vec3 p, vec3 c, float R )\n{\n    return length( p - c ) - R;\n}\n\nfloat OpaqueSceneSDF( vec3 p )\n{\n    vec3 spherePos = vec3(-1.0f, 1.5f, 3.0f) + vec3( sin( iTime ), cos( 0.6f * iTime ), sin( 0.7f * iTime ) ) * 0.8f;\n    float dist = SphereSDF( p, spherePos, 0.4f ) - cos( p.y * 20.0f + p.x * 20.0f ) * 0.01f;\n    dist = min( dist, p.y - cos( p.z * 28.0f + p.x * 38.0f ) * 0.01f );\n    dist = min( dist, p.x + 4.0f - sin( p.y * 18.0f + p.z * 25.0f ) * 0.01f );\n    dist = min( dist, -p.x + 4.0f - cos( p.y * 28.0f + p.z * 18.0f ) * 0.01f );\n    dist = min( dist, -p.z + 9.0f - sin( p.x * 8.0f + p.y * 28.0f ) * 0.01f );\n    return dist;\n}\n\nfloat ReflectiveSceneSDF( vec3 p )\n{\n    vec3 spherePos = vec3(1.0f, 1.5f, 5.0f) + vec3( cos( 0.2f * iTime ), 3.0f * sin( 0.3f * iTime ), cos( 0.1f * iTime ) ) * 0.3f;\n    float dist = SphereSDF( p, spherePos, 1.0f );// - cos( p.y * 20.0f + p.x * 20.0f ) * 0.01f;\n    return dist;\n}\n\nfloat SceneSDF( vec3 p )\n{\n    return min( OpaqueSceneSDF( p ), ReflectiveSceneSDF( p ) );\n}\n\nvec3 SceneNormal( vec3 p )\n{\n    float epsilon = 0.01f;\n    float d = SceneSDF( p );\n    \n    vec3 n;\n    n.x = d - SceneSDF( p - vec3( epsilon, 0.0f, 0.0f ) );\n    n.y = d - SceneSDF( p - vec3( 0.0f, epsilon, 0.0f ) );\n    n.z = d - SceneSDF( p - vec3( 0.0f, 0.0f, epsilon ) );\n    \n    return normalize( n );\n}\n\nstruct RayHit\n{\n    vec3 p;\n    vec3 n;\n    bool hit;\n};\n\nRayHit RayMarchOpaqueScene( vec3 ro, vec3 rd )\n{\n    RayHit res;\n    float dist = 0.0f;\n    int i = 0;\n    for ( ; i < RM_MAX_STEPS; ++i )\n    {\n        res.p = ro + rd * dist;\n        float dS = OpaqueSceneSDF( res.p );\n        dist += dS;\n        \n        if ( dS <= RM_MIN_DIST || dist >= RM_MAX_DIST )\n        {\n            break;\n        }\n    }\n    \n    if ( i == RM_MAX_STEPS || dist >= RM_MAX_DIST )\n    {\n        res.hit = false;\n    }\n    else\n    {\n        res.hit = true;\n        res.n = SceneNormal( res.p );\n    }\n    \n    return res;\n}\n\nRayHit RayMarchReflectiveScene( vec3 ro, vec3 rd )\n{\n    RayHit res;\n    float dist = 0.0f;\n    int i = 0;\n    for ( ; i < RM_MAX_STEPS; ++i )\n    {\n        res.p = ro + rd * dist;\n        float dS = ReflectiveSceneSDF( res.p );\n        dist += dS;\n        \n        if ( dS <= RM_MIN_DIST || dist >= RM_MAX_DIST )\n        {\n            break;\n        }\n    }\n    \n    if ( i == RM_MAX_STEPS || dist >= RM_MAX_DIST )\n    {\n        res.hit = false;\n    }\n    else\n    {\n        res.hit = true;\n        res.n = SceneNormal( res.p );\n    }\n    \n    return res;\n}\n\nfloat RayMarchScene( vec3 ro, vec3 rd )\n{\n    float dist = 0.0f;\n    for ( int i = 0; i < RM_MAX_STEPS; ++i )\n    {\n        vec3 p = ro + rd * dist;\n        float dS = SceneSDF( p );\n        dist += dS;\n        \n        if ( dS <= RM_MIN_DIST || dist >= RM_MAX_DIST )\n        {\n            break;\n        }\n    }\n    \n    return dist;\n}\n\nstruct Luminance\n{\n    float diffuse;\n    float specular;\n};\n\nLuminance CalcLuminance( vec3 p, vec3 n, vec3 lightPos, vec3 camPos )\n{\n    Luminance lum;\n        \n    vec3 toLight = lightPos - p;\n    vec3 toLightNorm = normalize( toLight );\n    \n    float lightFade = min( 5.0f / dot( toLight, toLight ), 1.0f );\n    lum.diffuse = max( dot( n, toLightNorm ), 0.0f ) * lightFade;\n    \n    vec3 toCamNorm = normalize( camPos - p );\n    vec3 H = normalize( toCamNorm + toLightNorm );\n    lum.specular = max( dot( n, H ), 0.0f );\n    lum.specular = pow( lum.specular, 80.0f ) * lightFade;\n    \n    return lum;\n}\n\nfloat CalcShadow( vec3 p, vec3 lightPos )\n{\n    vec3 toLight = lightPos - p;\n    vec3 toLightNorm = normalize( toLight );\n    \n    float shadow = 1.0f;\n    float dist = RayMarchScene( p + toLightNorm * vec3( 0.1f ), toLightNorm );\n    if ( dist < length( toLight ) )\n    {\n        shadow = 0.35f;\n    }\n    \n    return shadow;\n}\n\n//---------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord.xy - 0.5f * iResolution.xy ) / iResolution.y;\n    \n    vec3 camPos = vec3( 0.0f, 1.5f, -2.0f );\n    vec3 ro = camPos;\n    vec3 rd = normalize( vec3(uv.x, uv.y, 1.0f) );\n    \n    RayHit reflHit = RayMarchReflectiveScene( ro, rd );\n    RayHit opaqueHit = RayMarchOpaqueScene( ro, rd );\n    \n    bool opaqueClosest = reflHit.hit && opaqueHit.hit && ( dot( opaqueHit.p - camPos, opaqueHit.p - camPos ) < dot( reflHit.p - camPos, reflHit.p - camPos ) );\n    \n    float reflFactor = 1.0f;\n    if ( reflHit.hit && !opaqueClosest )\n    {\n        reflFactor = 0.8f;\n        ro = reflHit.p;\n        rd = normalize( reflect( normalize( ro - camPos ), reflHit.n ) );\n        opaqueHit = RayMarchOpaqueScene( ro, rd );\n    }\n    \n    vec3 lightPos = vec3( 0.0f, 2.5f, 5.0f );\n    lightPos += vec3( sin( iTime ), 0.5f * cos( 0.7f * iTime ), cos( iTime ) ) * 2.5f;\n    \n    Luminance lum = CalcLuminance( opaqueHit.p, opaqueHit.n, lightPos, camPos );\n    float shadowFactor = CalcShadow( opaqueHit.p, lightPos );\n    \n    vec3 ambColor = vec3( 0.04f, 0.04f, 0.06f );\n    vec3 finalColor = ambColor + vec3( lum.diffuse + lum.specular ) * shadowFactor * reflFactor;\n    \n    // Output to screen\n    fragColor = vec4( finalColor, 1.0f );\n}","name":"Image","description":"","type":"image"}]}