{"ver":"0.1","info":{"id":"XXtSDr","date":"1718885991","viewed":74,"name":"Bresenham 2D lighting","username":"baconbeak1998","description":"A simple (but horribly unoptimized) 2D point-light renderer\n\nMainly just for exploration purposes, lots of optimization would be required to actually use this in any practical sense.","likes":5,"published":3,"flags":32,"usePreview":0,"tags":["2d","raymarch","raycast","lighting","lights"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * A simple 2D raycast lighting approach (horribly unoptimized)\n * Buffer A holds the color information\n * Buffer B holds the lighting information\n * Buffer C holds the bounding box information\n * Image combines all\n *\n**/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord),0).xyz;\n    col += texelFetch(iChannel1, ivec2(fragCoord),0).xyz;\n    //col += texelFetch(iChannel2, ivec2(fragCoord),0).xyz;\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 getTexel(vec2 v) {\n    return texelFetch(iChannel0, ivec2(v.x,v.y),0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    \n    vec2 size = O_SIZE;\n    vec2 position = O_POS - size/2.;\n        \n    vec2 subImg = vec2(mod(floor(iTime * FPS), 6.), 0.);\n\n    if (fragCoord.x > position.x && fragCoord.y > position.y &&\n        fragCoord.x < position.x + size.x && fragCoord.y < position.y + size.y) {\n        vec2 uv = (fragCoord - position) / size;\n        vec2 texel = (uv + subImg) * SPRITE_SIZE;\n        col = mix(col, getTexel(texel).xyzw, getTexel(texel).w);\n    }\n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float getMask(vec2 v) {\n    return texelFetch(iChannel0, ivec2(v.x,v.y),0).w;\n}\n\nfloat getLineMask(vec2 v) {\n    return texelFetch(iChannel1, ivec2(v.x,v.y),0).w;\n}\n\nfloat bresenhamOcclusion(vec2 from, vec2 to) {\n    ivec2 p0 = ivec2(from);\n    ivec2 p1 = ivec2(to);\n\n    int dx = abs(p1.x - p0.x);\n    int dy = -abs(p1.y - p0.y);\n    int sx = p0.x < p1.x ? 1 : -1;\n    int sy = p0.y < p1.y ? 1 : -1;\n    int err = dx + dy;\n    int e2;\n\n    while (true) {\n        if (getMask(vec2(p0)) > 0.0) {\n            return 0.0; // Occlusion detected\n        }\n        if (p0 == p1) break;\n        e2 = 2 * err;\n        if (e2 >= dy) { err += dy; p0.x += sx; }\n        if (e2 <= dx) { err += dx; p0.y += sy; }\n    }\n\n    return 1.0; // No occlusion detected\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float v = 0.;\n    if (getLineMask(fragCoord) == 0.) {\n        v = 1.;\n    } else {\n        v = bresenhamOcclusion(fragCoord, LIGHT_POS);\n    }\n    v *= 1. - distance(fragCoord, LIGHT_POS)/LIGHT_STR;\n    \n    fragColor = vec4(vec3(v),1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define LIGHT_POS iResolution.xy/2.\n#define LIGHT_STR 200.\n#define LIGHT_PRECISION 100.\n\n#define DISTANCE 100.\n#define FPS 10.\n#define SPRITE_SIZE vec2(40.,32.)\n\n#define O_POS vec2(sin(iTime), cos(iTime)) * DISTANCE + LIGHT_POS\n#define O_SIZE vec2(125., 100.)","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"bool intersectAABB(vec2 p0, vec2 p1, vec2 boxMin, vec2 boxMax) {\n    // Check if line segment intersects with AABB\n    vec2 dir = p1 - p0;\n    vec2 invDir = 1.0 / dir;\n\n    vec2 tMin = (boxMin - p0) * invDir;\n    vec2 tMax = (boxMax - p0) * invDir;\n\n    float t1 = max(min(tMin.x, tMax.x), min(tMin.y, tMax.y));\n    float t2 = min(max(tMin.x, tMax.x), max(tMin.y, tMax.y));\n\n    return t2 >= t1 && t2 >= 0.0 && t1 <= 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    \n    vec2 size = O_SIZE;\n    vec2 position = O_POS - size/2.;\n\n    if (distance(fragCoord, LIGHT_POS) < LIGHT_STR && \n        intersectAABB(fragCoord, LIGHT_POS, position, position+size)) {\n        col = vec4(1.);\n    }\n    \n    fragColor = col;\n}","name":"Buffer C","description":"","type":"buffer"}]}