{"ver":"0.1","info":{"id":"wsdyRl","date":"1601560847","viewed":420,"name":"21 - 2D Rain on texture","username":"Krabcode","description":"My favorite water ripple algorithm now with rain and textures\ndrag your mouse to splash around","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["wave","texture","water","rain","ripple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"20 - 2D Water\" by Krabcode. https://shadertoy.com/view/wdccRl\n// 2020-10-01 13:13:02\n\n\nvec3 gammaCorrection(vec3 rgb){\n    float gamma = 2.2;\n    rgb = smoothstep(0., 1., rgb);\n    return pow(max(rgb, 0.), vec3(1.0/gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cv = (fragCoord.xy - .5* iResolution.xy) / iResolution.y;\n    float waveHeight;\n    vec4 buffers = texture(iChannel0, uv);\n    if(swap){\n     \twaveHeight = buffers.r;\n    }else{\n        waveHeight = buffers.g;\n    }\n    vec2 refractOffset = buffers.zw;;\n    vec3 col = texture(iChannel1, uv+waveHeight*refractOffset).rgb;\n    fragColor = vec4(gammaCorrection(col), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define res iResolution\n\n// based on this algorithm: https://web.archive.org/web/20160418004149/http://freespace.virgin.net/hugo.elias/graphics/x_water.htm\n// x and y are the two buffers, z and w are texture displacement\n\nconst float damping = .9975; // change this! good values are between 0.99 and 1.\n\nfloat buffer1(vec2 uv){\n    vec2 tex = texture(iChannel0, uv).xy;\n    if(swap){\n        return tex.x;\n    }\n    return tex.y;\n}\n\nfloat buffer2(vec2 uv){\n    vec2 tex = texture(iChannel0, uv).xy;\n    if(swap){\n        return tex.y;\n    }\n    return tex.x;\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\n// the hash is Hash without Sine by David Hoskins\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat drawOnWater(vec2 fragCoord){\n    vec2 uv = fragCoord.xy / res.xy;\n    vec2 m = (iMouse.xy  - .5 * res.xy) / res.y;\n    if(iMouse.z < .5){\n     \tm = vec2(-2);\n    }\n    vec2 cv = (fragCoord.xy - .5 * res.xy) / res.y;\n    float mouseShape = cubicPulse(.0, .05, distance(m, cv));\n    \n    float timeModulo = floor(float(iFrame) / 2.);\n    vec2 raindropPos = -1.+2.*hash22(vec2(17.2125*timeModulo, 3.725*timeModulo));\n    float raindropSize = .01+.08*hash11(timeModulo);\n    float raindrop = smoothstep(raindropSize, 0., distance(cv,raindropPos));\n    \n    return max(mouseShape, raindrop);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / res.xy;\n    vec2 texel = vec2(1./res.x, 1./res.y);\n    float newBuffer2 = (buffer1(uv+vec2(+texel.x, 0.)) + \n                        buffer1(uv+vec2(-texel.x, 0.)) + \n                        buffer1(uv+vec2(0., +texel.y)) + \n                        buffer1(uv+vec2(0., -texel.y))) / 2. - buffer2(uv);\n    newBuffer2 *= damping;\n\tnewBuffer2 += drawOnWater(fragCoord);\n    newBuffer2 = clamp(newBuffer2, 0., 1.);\n    vec2 buffers;\n    if(swap){\n        buffers = vec2(buffer1(uv), newBuffer2);\n    }else{\n        buffers = vec2(newBuffer2, buffer1(uv));       \n    }\n    \n    float offsetX = buffer1(uv+vec2(-texel.x, 0.)) - buffer1(uv+vec2(+texel.x, 0.));\n\tfloat offsetY = buffer1(uv+vec2(0., -texel.y)) - buffer1(uv+vec2(0., -texel.y));\n    vec2 waveDisplacement = vec2(offsetX, offsetY);\n    \n    fragColor = vec4(buffers, waveDisplacement);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define swap iFrame % 2 == 0","name":"Common","description":"","type":"common"}]}