{"ver":"0.1","info":{"id":"Dds3Dl","date":"1667179798","viewed":47,"name":"GPU Path Tracer","username":"artefox","description":"GPU Path Tracer","likes":0,"published":1,"flags":32,"usePreview":1,"tags":["gpupathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec4 buffer = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 col = buffer.rgb / buffer.a;\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265359\n\nstruct ray\n{\n    vec3 o;\n    vec3 d;\n    vec3 e;\n};\n\nstruct hit\n{\n    vec3 pos;\n    float dist;\n    vec3 n;\n};\n\nvec2 pixel;\nfloat seed = 4.5453;\n\nfloat rand(float seed)\n{\n    float result = fract(sin(seed / 100.0 * dot(pixel, vec2(12.9898, 78.233))) * 43758.5453);\n    return result;\n}\n\nvoid intersectPlane(ray r, out hit bestHit)\n{\n    float t = r.o.y / -r.d.y;\n    if (t > 0.0 && t < bestHit.dist)\n    {\n        bestHit.dist = t;\n        bestHit.pos = r.o + t * r.d;\n        bestHit.n = vec3(0.0, 1.0, 0.0);\n    }\n}\n\nvoid intersectSphere(ray r, out hit bestHit, vec4 s)\n{\n    vec3 d = r.o - s.xyz;\n    \n    float p1 = -dot(r.d, d);\n    float p2sqr = p1 * p1 - dot(d, d) + s.w * s.w;\n    if (p2sqr < 0.0) return;\n    \n    float p2 = sqrt(p2sqr);\n    float t = p1 - p2 > 0.0 ? p1 - p2 : p1 + p2;\n    \n    if (t > 0.0 && t < bestHit.dist)\n    {\n        bestHit.dist = t;\n        bestHit.pos = r.o + t * r.d;\n        bestHit.n = normalize(bestHit.pos - s.xyz);\n    }\n}\n\nhit trace(ray r)\n{\n    hit bestHit = hit(vec3(0.0), 10000.0, vec3(0.0));\n\n    for (int u = 0; u < 8; u++)\n    {\n        for (int s = 0; s < 8; s++)\n        {\n            intersectSphere(r, bestHit, vec4(float(u) / 2.0, 0.2, float(s) / 2.0, 0.2));\n        }\n    }\n        \n    intersectPlane(r, bestHit);\n    return bestHit;\n}\n\nvec4 directional = vec4(0.6, 1.0, 0.4, 0.5);\nvec3 albedo = vec3(0.8);\nvec3 specular = vec3(1.0, 0.78, 0.34);\n\nvec3 shade(out ray r, hit h)\n{\n    if (h.dist < 10000.0)\n    {\n        r.o = h.pos + h.n * 0.001;\n        r.d = reflect(r.d, h.n);\n        r.e *= specular;\n        \n        bool shadow = false;\n        hit shadowHit = trace(ray(r.o, directional.xyz, vec3(0.0)));\n        \n        if (shadowHit.dist != 10000.0)\n        {\n            return vec3(0.0);\n        }\n        return clamp(dot(h.n, directional.xyz), 0.0, 1.0) * directional.w * albedo;\n    }\n    else\n    {\n        r.e = vec3(0.0);\n\n        // get spherical coords\n        float theta = PI - acos(r.d.y); // range [0, pi] = [0deg, 180deg]\n        float phi = atan(-r.d.z, r.d.x); // range [-pi, pi] = [-180deg, 180deg]\n        // bring into range [0.0, 1.0] because that's how the texture stores the data (= texture uv coords)\n        theta /= PI;\n        phi = (phi + PI) / (2.0*PI);\n        // bring in range [w, h] = [512, 512] because the texelFetch() function requires the integer pixel coords.\n        vec2 texDims = vec2(256.0, 256.0); // dimensions of texture - idk if you can automatically fetch it somehow\n        theta *= texDims.x;\n        phi *= texDims.y;\n        return texelFetch(iChannel1, ivec2(phi, theta), 0).xyz * 1.1;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    pixel = fragCoord;\n    \n    vec2 uv;\n    \n    vec3 col;\n    \n    // TO DO: clean up this giant uv mess\n    uv.x = ((fragCoord.x + rand(float(iFrame))) / iResolution.x * 2.0 - 1.0) * (iResolution.x / iResolution.y);\n    uv.y = (fragCoord.y + rand(float(iFrame) + 0.65452)) / iResolution.y * 2.0 - 1.0;\n\n    ray r = ray(vec3(1.5, 0.5, 4.5), normalize(vec3(uv, -1.0)), vec3(1.0));\n    for (int i = 0; i < 16; i++)\n    {\n        hit h = trace(r);\n        col += r.e * shade(r, h);\n        if (r.e == vec3(0.0))\n            break;\n    }\n    \n    vec4 buffer = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if(iFrame == 0) buffer = vec4(0.0);\n    \n    buffer += vec4(col, 1.0);\n    \n    fragColor = vec4(buffer);\n}","name":"Buffer A","description":"","type":"buffer"}]}