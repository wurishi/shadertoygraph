{"ver":"0.1","info":{"id":"4sKGWV","date":"1456495604","viewed":661,"name":"Sphere with displacement","username":"tomkel","description":"An sdf sphere with a displaced plane.<br/><br/>Now with a cube map and displacement map on the cube. Shading is simply reflection * ambient occlusion term which generates some pleasing shadowing effects.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphere( vec3 spherepos, float r, vec3 raypos )\n{\n    float disp = texture( iChannel1, raypos.xy * 0.05 ).r;\n    return distance( spherepos, raypos ) - r - disp*2.0;\n}\n\nfloat cylinder( float r, vec3 raypos )\n{\n    return r - length( raypos ) ;\n}\n\nfloat plane( vec4 plane, vec3 raypos )\n{\n\n    float scale = max( 0.0, 1.0 -  length( raypos.xz) / 40.0 );\n    \n    float d = cos( iTime * 10.0 - distance( vec2( 0,0) , raypos.xz) * 0.5 ) * 2.0 + \n        \t  cos( iTime * 10.0 - distance( vec2( 10.0,5.0) , raypos.xz) * 1.0 )  * 0.8 + \n         \t  cos( iTime * 10.0 - distance( vec2( -10.0,-5.0) , raypos.xz) * 2.0 ) * 0.8;\n    \n    float disp = texture( iChannel1, raypos.xz * 0.01 ).r;\n    \n    return dot( raypos, plane.xyz ) - plane.w - d*scale;\n}\n\n\n\nvec4 getlight( vec3 eye, vec3 normal, vec3 position, vec3 lightpos, vec4 lightcolour  )\n{\n    float d = distance( lightpos, position );\n    vec3 n = normalize( lightpos - position  );\n    \n    vec4 spec = pow( max( dot( normalize( n - eye ), normal ), 0.0 ), 16.0 ) * vec4(1.0,1.0,1.0,1.0);\n   \n    \n    return max( dot( normal, n ), 0.0 ) * lightcolour + spec * 0.1;\n    \n    \n}\n\n\nfloat softmin( float a, float b, float d )\n{\n    if (abs( a-b ) > d )\n    {\n        return min( a, b );\n    }\n   \telse\n    {\n        float lerp = abs( a - b ) / d;\n        return min(a,b) * lerp +  (a+b)/2.0 * ( 1.0 - lerp );\n        \n    }\n}\n\nfloat sdf( vec3 raypos )\n{\n    float e = abs( cos( iTime ) ) * 10.0;\n    return min( sphere( vec3( 0,5.0, 0.0), 10.0, raypos ),\n                 plane( vec4( 0,1.0, 0.0,-10.0), raypos ));\n}\n\n\nvec3 grad( vec3 raypos, float delta )\n{\n    float dx =  sdf( raypos + vec3( delta, 0,0 ) ) - sdf( raypos - vec3( delta,0,0 ) );\n    float dy =  sdf( raypos + vec3( 0, delta,0 ) ) - sdf( raypos - vec3( 0,delta,0 ) );\n    float dz =  sdf( raypos + vec3( 0,0, delta ) ) - sdf( raypos - vec3( 0,0,delta ) );\n    return vec3( dx,dy,dz );\n}\n\nvec4 shadowlight( vec3 eye, vec3 normal, vec3 origin,  vec3 lightpos, vec4 colour, float ep )\n{\n   vec3 ray = normalize( lightpos - origin);\n    \n    vec3 p = origin + ray * 2.0;\n    for ( int i = 0; i < 512; i++ )\n    {\n        float sd = sdf(p);\n        float ld = distance( p, lightpos );\n        float step = min( sd, ld );\n        if ( sd  <  ep )\n        {\n           return vec4(0,0,0,1.0);\n        }\n        else if ( ld < ep )\n        {\n           return getlight( eye, normal, origin, lightpos, colour );\n        }\n        \n        p += ray * step;\n    } \n    \n    \n    return getlight( eye, normal, origin, lightpos, colour );\n}\n\nvec4 contact( vec3 position, vec3 normal, float scale )\n{\n    float s = sdf( position + normal * scale );\n    return  (s/scale) * vec4( 1.0,1.0,1.0,1.0);\n    \n}\n\nvec4 march( vec3 ray, vec3 origin, float ep )\n{\n    vec3 p = origin;\n    vec3 eye = normalize( ray );\n    for ( int i = 0; i < 512; i++ )\n    {\n        float step = sdf(p);\n        if ( step  <  ep )\n        {\n            vec3 normal = normalize( grad( p, 0.1 ) );\n            vec4 cube =  texture( iChannel0, -reflect( eye, normal ) ); //reflect( eye, normal ) );\n //           return //shadowlight( eye, normal, p,  vec3( 100,100,100 ), vec4(0.5,0.5,0,1.0 ), ep) + \n   //                shadowlight( eye, normal, p,  vec3( -100,100,-100 ), vec4(0.0,0.5,0.5,1.0 ), ep) + \n     //         contact( p, normal, 4.0 ) * 0.1;\n            return cube *  contact( p, normal, 4.0 );\n        }\n        else if ( length( p - origin ) > 200.0 )\n        {\n             return texture( iChannel0, -eye ); \n        }\n        \n        p += ray * step;\n    }\n    \n    return vec4(0.0,0,0,1);\n}\n\nvec3 rotatevecY( vec3 vec, float angle )\n{\n    vec3 m0 = vec3( -cos( angle ), 0, sin( angle ));\n    vec3 m1 = vec3( 0            , 1.0,   0      );\n    vec3 m2 = vec3( sin( angle ), 0, cos( angle ) );\n    \n    return vec3(  dot( m0, vec ), dot( m1, vec ), dot( m2, vec )) ;\n} \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspect = iResolution.y / iResolution.x;\n    \n    vec3 origin = vec3(0.0, 2, -60.0 + iMouse.y / iResolution.y * 100.0);\n    vec3 ray = vec3( uv.x - 0.5, (uv.y - 0.5) * aspect, 0.5 );\n    \n\n    \n    ray = rotatevecY( ray, iMouse.x / iResolution.x * 8.0 );\n    origin = rotatevecY( origin,  iMouse.x / iResolution.x * 8.0  );\n\n    \n\tfragColor = march( ray, origin, 0.1);\n}","name":"Image","description":"","type":"image"}]}