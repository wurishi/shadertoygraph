{"ver":"0.1","info":{"id":"clfSDs","date":"1675459873","viewed":163,"name":"Simple hyperbolic tiling","username":"MagmaMcFry","description":"Simple hyperbolic shader, using the hyperboloid model for geometry but the Poincar√© disk model for display. Click and drag right to see the limits of float resolution.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["hyperbolic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 P2H(vec2 p) {\n    float E = dot(p,p);\n    return vec3(2.*p, 1.+E) / (1.-E);\n}\n\nvec2 H2P(vec3 v) {\n    return v.xy / (1. + v.z);\n}\n\n// Minkowski inner product, z is the special coordinate\nfloat doth(vec3 v, vec3 w) {\n    return v.x * w.x + v.y * w.y - v.z * w.z;\n}\n\nvec3 hfold(vec3 v, vec3 n) {\n    return v - 2.0 * max(0.0, doth(n,v)) * n;\n}\nvec3 hreflect(vec3 v, vec3 n) {\n    return v - 2.0 * doth(n,v) * n;\n}\n\nconst float PI = 3.1415926535897932384626;\nconst float T = sqrt(0.5);\nconst float A = -cos(PI/5.); // Try changing the 5 to 6 or 7\nconst float B = sqrt(2.*A*A-1.);\nconst float BRIGHTNESS = 6.; // then decreasing this value\n\n// Well-chosen hyperbolic normals have appropriate values when doth'ing them with each other\nconst vec3 N1 = vec3(1.,0.,0.);\nconst vec3 N2 = vec3(-T,-T,0.);\nconst vec3 N3 = vec3(A,-A,B);\nconst int ITERS = 20;\n\nvec3 transform(vec3 h) {\n    // Interactivity!\n    float dx = 4. * iMouse.x / iResolution.x;\n    h = hreflect(h, vec3(cosh(dx), 0, sinh(dx)));\n    // Folds a point in the hyperboloid model in on itself repeatedly along all faces of the fundamental triangle\n    for (int i = 0; i < ITERS; ++i) {\n        h = hfold(h, N1);\n        h = hfold(h, N2);\n        h = hfold(h, N3);\n    }\n    return h;\n}\n\nvec3 colorFundamentalDomain(vec2 p) {\n    float c = BRIGHTNESS*dot(p,p);\n    return vec3(c,c*c,c*c*c);\n    //return vec3(-5.*p.x, 1.5*p.y+p.x, 1.-5.*p.y);\n}\n\nfloat inBounds(vec2 p) {\n    return float(dot(p,p) < 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p0 = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec2 p1 = H2P(transform(P2H(p0))); // Switches from Poincare disk to hyperboloid for reflection math, back for coloring\n    fragColor = vec4(colorFundamentalDomain(p1), 1.0);\n    fragColor = mix(vec4(0.), fragColor, inBounds(p0));\n}","name":"Image","description":"","type":"image"}]}