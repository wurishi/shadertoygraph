{"ver":"0.1","info":{"id":"M3d3zS","date":"1716698677","viewed":39,"name":"Another Water test","username":"saalty","description":"A test, not meant to be very clean code and/or optimized.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define COLLIDE_THRESHOLD 0.001\n#define MAXTRAVEL 400.0\n\nfloat dist(vec3 pos, vec3 vec, out vec3 normal)\n{\n    vec3 cur = texture(iChannel0, pos.xy / iResolution.xy).xyz;\n    float dist = pos.z / iResolution.x - cur.z * WATERHEIGHT;\n    normal = texture(iChannel1, pos.xy / iResolution.xy).xyz * 2.0 - 1.0;\n    dist *= normal.z;\n    return dist * 20.0;\n}\n\nvec3 raymarch(vec3 pos, vec3 dir)\n{\n    float travel = 0.0;\n    \n    int bounces = 0;\n    \n    bool inWater = false;\n    \n    vec3 curCol = vec3(0.0);\n    vec3 curSpec = vec3(0.0);\n    \n    while (bounces < 2)\n    {\n        vec3 normal = vec3(0.0);\n        float d = dist(pos, dir, normal);\n        if (inWater) d = -d;\n        pos += dir * d;\n        \n        travel += d;\n        \n        if (d < COLLIDE_THRESHOLD)\n        {\n            float NdotI = -dot(dir, normal);\n            if (inWater)\n            {\n                float factor = NdotI;\n                \n                curCol = mix(curCol, vec3(0.0, 0.0, 1.0), factor);\n                \n                dir = normalize(refract(dir, normal, 1.33));\n            }\n            else\n            {\n                float factor = NdotI;\n                \n                curCol = mix(curCol, vec3(0.0, 0.0, 1.0), factor);\n                \n                float spec = pow(max(0.0, dot(reflect(dir, normal), normalize(vec3(0.2, 0.2, 1.0)))), 64.0);\n                curSpec = mix(curSpec, vec3(spec), factor);\n                \n                dir = normalize(refract(dir, normal, 1.0 / 1.33));\n            }\n            \n            inWater = !inWater;\n            \n            pos -= normal * iResolution.x * 0.1;\n            travel = 0.0;\n            bounces++;\n            continue;\n        }\n        \n        if (travel > MAXTRAVEL)\n        {\n            float factor = 0.9;\n            if (bounces == 0) factor = 1.0;\n            return mix(curCol, texture(iChannel2, dir.xzy).xyz, factor) + curSpec;\n        }\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 rayPos = vec3(iResolution.xy / 2.0, 50.0);\n    vec3 rayDir = normalize(vec3(uv.x - 0.5, 1.0, uv.y - 0.5));  \n    \n    fragColor = vec4(raymarch(rayPos, rayDir), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define DETAIL 9\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 normal = vec3(0.0);\n    \n    float mult = 0.0;\n    for (int i = 0;i < DETAIL;i++)\n    {\n        normal += texture(iChannel0, iTime / pow(2.0, float(i)) / 100.0 * float(i + 1) + uv / pow(2.0, float(i))).xyz * pow(2.0, float(i));\n        mult += pow(2.0, float(i));\n    }\n    normal /= mult;\n    float height = length(normal);\n    \n    fragColor = vec4(height);\n    fragColor.w = 1.0;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float stepX = 1.0 / iResolution.x;\n    float stepY = 1.0 / iResolution.y;\n    \n    vec3 s0 = vec3(fragCoord, texture(iChannel0, uv).x * iResolution.x * WATERHEIGHT);\n    vec3 s1 = vec3(fragCoord + vec2(1.0, 0.0), texture(iChannel0, uv + vec2(stepX, 0.0)).x * iResolution.x * WATERHEIGHT);\n    vec3 s2 = vec3(fragCoord - vec2(1.0, 0.0), texture(iChannel0, uv - vec2(stepX, 0.0)).x * iResolution.x * WATERHEIGHT);\n    vec3 s3 = vec3(fragCoord + vec2(0.0, 1.0), texture(iChannel0, uv + vec2(0.0, stepY)).x * iResolution.x * WATERHEIGHT);\n    vec3 s4 = vec3(fragCoord - vec2(0.0, 1.0), texture(iChannel0, uv - vec2(0.0, stepY)).x * iResolution.x * WATERHEIGHT);\n    \n    vec3 norm0 = normalize(cross(s1 - s0, s3 - s0));\n    vec3 norm1 = normalize(cross(s2 - s0, s4 - s0));\n    \n    vec3 normal = normalize((norm0 + norm1) / 2.0);\n    \n    fragColor = vec4(normal / 2.0 + 0.5, 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define WATERHEIGHT (iMouse.x / iResolution.x * 0.100)","name":"Common","description":"","type":"common"}]}