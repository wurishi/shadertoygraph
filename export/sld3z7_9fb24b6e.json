{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/* \n\nBorders are only drawn between hexes (A and B) if they are different colors.\nWhen drawing a border there are 9 different cases, depending on the color of the\nhexes on ends of the border segment (C and D). Each of C and D could be the same\ncolor as A, B, or neither, leading to the 9 different cases.\n\n             \\    A    /\n              \\       /\n          C    =======    D\n              /       \\\n             /    B    \\\n\n*/\n\n#define swap() { vec4 colorSwap = colorB; colorB = colorA; colorA = colorSwap; }\n\n#define BufA(p) texture(iChannel0, (p + canvas.xy + vec2(0.5)) / iResolution.xy)\n\nfloat linstep(float edge0, float edge1, float x) {\n    return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\nvec3 draw(vec2 fragCoord, vec4 canvas) {\n    fragCoord -= 0.5 * iResolution.xy;\n    float s = scale * zoom(canvas.z);\n\n    vec2 pos = fragCoord * mat2(1.0, 0.0, 0.5, 0.866025) / s;\n    \n    vec2 id = floor(pos);\n    id.x = floor((id.x + id.y) / 3.0);\n    pos -= vec2(3.0, 1.0) * id - vec2(id.y, 0.0);\n\n    int i = int(2.0 * floor(pos.x) + step(pos.y, fract(pos.x)));\n    vec2 a = id + idA[i];\n    vec2 b = id + idB[i];\n    vec2 c = id + idC[i];\n    vec2 d = id + idD[i];\n\n    vec3 colorA = BufA(a).rgb;\n    vec3 colorB = BufA(b).rgb;\n    vec3 colorC = BufA(c).rgb;\n    vec3 colorD = BufA(d).rgb;\n\n    vec2 centerA = a * idCenter * s;\n    vec2 centerB = b * idCenter * s;\n    vec2 dir = 0.5 * (centerB - centerA);\n    \n    float index = compareColor(colorA, colorC);\n    index += 2.0 * compareColor(colorB, colorC);\n    index += 3.0 * compareColor(colorA, colorD);\n    index += 6.0 * compareColor(colorB, colorD);\n    index = mix(index, 9.0, compareColor(colorA, colorB));\n    //index = 0.0;\n    \n    i = int(index);\n    vec2 center = centerA + dir * centerMat[i];\n    vec2 norm = dir * dirMat[i] / s;\n    vec3 outside = mix(colorA, colorB, flip[i]);\n    vec3 inside = mix(colorB, colorA, flip[i]);\n            \n    float t = dot(fragCoord - center, norm);\n    fragCoord -= t * norm * step(0.0, t);\n    float x = length(fragCoord - center) - radius[i] * s;\n    return mix(mix(lineColor, outside, linstep(halfWidth, halfWidth + 1.0, x)), inside, linstep(halfWidth, halfWidth + 1.0, -x));\n}\n\nvec3 drawPalette(vec3 color, vec2 fragCoord) {\n    float edge = fragCoord.x - menuWidth;\n    if (edge > 0.0) {\n        return color * (1.0 - 0.2 * exp(-0.05 * edge));\n    }\n    \n    vec2 button = buttonPos(fragCoord, iResolution);\n    vec4 pallete = texture(iChannel0, vec2(1.5, 0.5) / iResolution.xy);\n\n    float selected = compare(button.x, pallete.r);\n    selected = min(selected + compare(button.x, pallete.g) * compare(button.x, pallete.b), 1.0);\n    float buttonWidth = mix(lineWidth, selectedWidth, selected);\n    \n    vec3 buttonColor = colorPalette[int(button.x)];\n    color = mix(menuBackground, lineColor, step(button.y, buttonWidth));\n    color = mix(color, buttonColor, step(button.y, 0.0));\n\n    color = mix(color, menuBackground, step(button.x, -0.5));\n    color = mix(color, menuBackground, step(colorCount, button.x));\n    color = mix(color, lineColor, step(-lineWidth, edge));\n    \n    return color;\n}\n\nvec3 drawScroll(vec3 color, vec2 fragCoord, vec4 canvas) {\n    fragCoord.x = iResolution.x - fragCoord.x;\n    \n    float edge = fragCoord.x - menuWidth;\n    if (edge > 0.0) {\n        return color * (1.0 - 0.2 * exp(-0.05 * edge));\n    }\n\n    float halfHeight = 0.5 * iResolution.y;\n    vec2 pos = abs(fragCoord - vec2(buttonCenter, halfHeight));\n    color = mix(menuBackground, lineColor, step(pos.y, halfHeight - sliderTip) * step(pos.x, halfWidth));\n    \n    float top = step(halfHeight, fragCoord.y);\n    float center = buttonTop + selectedWidth + 0.5 * buttonSize;\n    center = mix(center, iResolution.y - center, top);\n    float radius = mix(0.5 * buttonSize, 0.2 * buttonSize, top);\n    \n    float circle = distance(fragCoord, vec2(buttonCenter, center)) - radius;\n    color = mix(color, lineColor, linstep(lineWidth + 1.0, lineWidth, circle));\n    color = mix(color, menuBackground, linstep(1.0, 0.0, circle));\n\n    float slider = sliderCenter + canvas.z * (iResolution.y - 2.0 * sliderCenter);\n    pos = abs(fragCoord - vec2(buttonCenter, slider));\n    float button = max(pos.x, pos.y) - 0.5 * buttonSize;\n    float buttonWidth = mix(lineWidth, selectedWidth, canvas.w);\n\n    color = mix(color, lineColor, step(button, buttonWidth));\n    color = mix(color, sliderColor, step(button, 0.0));\n\n    color = mix(color, lineColor, step(-lineWidth, edge));\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 canvas = texture(iChannel0, vec2(2.5, 0.5) / iResolution.xy);\n\n    vec3 color = draw(fragCoord, canvas);\n    color = drawPalette(color, fragCoord);\n    color = drawScroll(color, fragCoord, canvas);\n \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\n\nSpecial Buffer A pixels used for control\n========================================\n\n  (0, 0) := Previous mouse state\n\n  (1, 0)    Pallete indices\n      .r := Current draw Color\n      .g := Mouse is currently over this pallete color\n      .b := Mouse was pressed down over this pallete color\n      \n  (2, 0)    Canvas\n      .x := X center\n      .y := y center\n      .z := Zoom scale (0 - 1)\n      .w := Mouse was pressed down on zoom slider\n\n*/\n\n#define BufA(x) texture(iChannel0, vec2(x + 0.5, 0.5) / iResolution.xy)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    fragCoord = floor(fragCoord);\n    vec4 prevMouse = BufA(0.0);\n    vec4 pallete = BufA(1.0);\n    vec4 canvas = BufA(2.0);\n    \n    if (iFrame == 0 || canvas.x < 0.5) {\n        if (fragCoord == vec2(1.0, 0.0))\n            fragColor = vec4(2.0, -1.0, -1.0, 0.0);\n        else if (fragCoord == vec2(2.0, 0.0))\n            fragColor = vec4(floor(0.5 * iResolution.xy), 0.5, 0.0);\n        else {\n            vec2 pos = (fragCoord - floor(0.5 * iResolution.xy) - 0.5) * idCenter;\n            vec4 f = fbm(0.2 * pos);\n            f.x += 0.003 * dot(pos, pos) - 0.1;\n            if (f.y > f.x && f.y > f.z && f.y > f.w)\n                fragColor = vec4(colorPalette[2], 1.0);\n            else if (f.z > f.x && f.z > f.y && f.z > f.w)\n                fragColor = vec4(colorPalette[4], 1.0);\n            else if (f.w > f.x && f.w > f.y && f.w > f.z)\n                fragColor = vec4(colorPalette[7], 1.0);\n            else\n                fragColor = vec4(colorPalette[0], 1.0);\n        }\n    }\n    \n    if (fragCoord == vec2(0.0, 0.0)) {\n        fragColor = iMouse;\n    } else if (fragCoord == vec2(1.0, 0.0)) {\n        vec2 button = buttonPos(iMouse.xy, iResolution);\n        float id = mix(button.x, -1.0, step(selectedWidth, button.y));\n\n        fragColor.g = id;\n        if (iMouse.z > prevMouse.z)\n            fragColor.b = id;\n        if (iMouse.z < prevMouse.z) {\n            if (fragColor.b == id && id > -0.5 && id < colorCount)\n                fragColor.r = id;\n            fragColor.b = -1.0;\n        }\n    } else if (fragCoord == vec2(2.0, 0.0)) {\n        float slider = step(iResolution.x - menuWidth, iMouse.x);\n\n        if (iMouse.z > prevMouse.z)\n            fragColor.w = slider;\n        else if (iMouse.z < prevMouse.z)\n            fragColor.w = 0.0;\n        if (fragColor.w > 0.5)\n            fragColor.z = clamp((iMouse.y - sliderCenter) / (iResolution.y - 2.0 * sliderCenter), 0.0, 1.0);\n    } else if (iMouse.z > 0.5 && iMouse.x > menuWidth && pallete.b < -0.5 &&\n               iMouse.x < iResolution.x - menuWidth && canvas.w < 0.5) {\n        float dt = 1.0 / length(iMouse.xy - prevMouse.xy);\n        dt += 2.0 * step(prevMouse.z, 0.5);\n        for (float t = 0.0; t < 1.0; t += dt) {\n            vec2 pos = (mix(iMouse.xy, prevMouse.xy, t) - 0.5 * iResolution.xy) / (scale * zoom(canvas.z));\n            pos *= mat2(1.0, 0.0, 0.5, 0.866025);\n            vec2 id = floor(pos);\n            id.x = floor((id.x + id.y) / 3.0);\n            pos -= vec2(3.0, 1.0) * id - vec2(id.y, 0.0);\n\n            int i = int(2.0 * floor(pos.x) + step(pos.y, fract(pos.x)));\n            id += idOffset[i];\n\n            if (fragCoord == id + canvas.xy)\n                fragColor = vec4(colorPalette[int(pallete.r)], 1.0);\n        }\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"const float scale = 30.0;\n\nconst float lineWidth = floor(0.2 * scale);\n\nconst float selectedWidth = 2.0 * lineWidth;\nconst float buttonSize = 1.0 * scale;\nconst float buttonLeft = 0.2 * scale;\nconst float buttonRight = 0.2 * scale;\nconst float buttonTop = 0.3 * scale;\nconst float buttonSpacing = 0.1 * scale;\n\nconst vec3 lineColor = vec3(0.0, 0.0, 0.0);\nconst vec3 menuBackground = vec3(1.0, 1.0, 1.0);\nconst vec3 sliderColor = vec3(0.9, 0.9, 0.9);\n\nconst float colorCount = 8.5;\nconst vec3 colorPalette[9] = vec3[9](\n    vec3(1.0, 1.0, 1.0),\n    vec3(0.3, 0.3, 0.3),\n    vec3(1.0, 0.3, 0.3),\n    vec3(1.0, 0.6, 0.0),\n    vec3(0.9, 0.9, 0.0),\n    vec3(0.0, 0.8, 0.0),\n    vec3(0.0, 0.6, 0.9),\n    vec3(0.3, 0.3, 1.0),\n    vec3(0.8, 0.0, 1.0)\n);\n\n\nconst float menuWidth = buttonSize + 2.0 * selectedWidth + buttonLeft + buttonRight + lineWidth;\nconst float buttonTotal = buttonSize + 2.0 * selectedWidth + buttonSpacing;\nconst float buttonCenter = buttonRight + selectedWidth + 0.5 * buttonSize;\nconst float sliderTip = buttonTop + buttonSpacing + 3.0 * selectedWidth + buttonSize;\nconst float sliderCenter = sliderTip + 0.5 * buttonSize;\nconst float halfWidth = 0.5 * lineWidth;\n\nfloat zoom(float slider) {\n    return exp(1.1 - 2.0 * slider);\n}\n\nvec2 buttonPos(vec2 fragCoord, vec3 iResolution) {\n    fragCoord.y = iResolution.y - fragCoord.y;\n    float button = floor((fragCoord.y - buttonTop) / buttonTotal);\n    float pos = fragCoord.y - (buttonTop + (button + 0.5) * buttonTotal);\n    pos = max(abs(pos), abs(fragCoord.x - buttonCenter)) - 0.5 * buttonSize;\n    return vec2(button, pos);\n}\n\nfloat compareColor(vec3 colorA, vec3 colorB) {\n    return step(distance(colorA, colorB), 0.001);\n}\n\nfloat compare(float a, float b) {\n    return step(abs(a - b), 0.001);\n}\n\nconst vec2 idOffset[6] = vec2[6](\n    vec2(0.0, 0.0),\n    vec2(0.0, 0.0),\n    vec2(1.0, 1.0),\n    vec2(1.0, 1.0),\n    vec2(1.0, 1.0),\n    vec2(1.0, 0.0)\n);\n\nconst vec2 idA[6] = vec2[6](\n    vec2(0.0, 0.0),\n    vec2(0.0, 0.0),\n    vec2(0.0, 0.0),\n    vec2(0.0, -1.0),\n    vec2(1.0, 0.0),\n    vec2(1.0, 0.0)\n);\n\nconst vec2 idB[6] = vec2[6](\n    vec2(1.0, 2.0),\n    vec2(1.0, 1.0),\n    vec2(1.0, 1.0),\n    vec2(1.0, 1.0),\n    vec2(1.0, 1.0),\n    vec2(1.0, 1.0)\n);\n\nconst vec2 idC[6] = vec2[6](\n    vec2(0.0, 1.0),\n    vec2(1.0, 2.0),\n    vec2(1.0, 2.0),\n    vec2(0.0, 0.0),\n    vec2(0.0, -1.0),\n    vec2(0.0, -1.0)\n);\n\nconst vec2 idD[6] = vec2[6](\n    vec2(1.0, 1.0),\n    vec2(0.0, -1.0),\n    vec2(0.0, -1.0),\n    vec2(1.0, 0.0),\n    vec2(2.0, 2.0),\n    vec2(2.0, 2.0)\n);\n\nconst mat2 idCenter = mat2(3, -1, -1.73205, 1.73205);\n\nconst mat2 centerMat[10] = mat2[10](\n    mat2(2.0, -2.0, 2.0, 2.0),\n    mat2(2.866025, 0.5, -0.5, 2.866025),\n    mat2(-0.866025, 0.5, -0.5, -0.866025),\n    mat2(2.866025, -0.5, 0.5, 2.866025),\n    mat2(2.0, 0.0, 0.0, 2.0),\n    mat2(2.0, 0.0, 0.0, 2.0),\n    mat2(-0.866025, -0.5, 0.5, -0.866025),\n    mat2(2.0, 0.0, 0.0, 2.0),\n    mat2(0.0, 0.0, 0.0, 0.0),\n    mat2(0.0, 0.0, 0.0, 0.0)\n);\n\nconst mat2 dirMat[10] = mat2[10](\n    mat2(0.0, 1.0, -1.0, 0.0),\n    mat2(0.0, 1.0, -1.0, 0.0),\n    mat2(0.0, 1.0, -1.0, 0.0),\n    mat2(0.0, -1.0, 1.0, 0.0),\n    mat2(1.0, 0.0, 0.0, 1.0),\n    mat2(-0.5, -0.866025, 0.866025, -0.5),\n    mat2(0.0, -1.0, 1.0, 0.0),\n    mat2(-0.5, 0.866025, -0.866025, -0.5),\n    mat2(-1.0, 0.0, 0.0, -1.0),\n    mat2(1.0, 0.0, 0.0, 1.0)\n);\n\nconst float radius[10] = float[10](\n    1.0,\n    1.866025,\n    1.866025,\n    1.866025,\n    0.866025,\n    0.866025,\n    1.866025,\n    0.866025,\n    0.866025,\n    2.0\n);\n\nconst float flip[10] = float[10](\n    0.0,\n    0.0,\n    1.0,\n    0.0,\n    0.0,\n    0.0,\n    1.0,\n    0.0,\n    1.0,\n    0.0\n);\n\n// https://www.shadertoy.com/view/4djSRW\nvec4 hash(vec2 p) {\n    vec4 p4 = fract(vec4(p.xyxy) * vec4(0.1031, 0.1030, 0.0973, 0.1099));\n    p4 += dot(p4, p4.wzxy + 33.33);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash(i + vec2(0.0, 0.0)), \n                   hash(i + vec2(1.0, 0.0)), u.x),\n               mix(hash(i + vec2(0.0, 1.0)), \n                   hash(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nconst mat2 m2 = mat2(1.616, 1.212, -1.212, 1.616);\n\nvec4 fbm(vec2 p) {\n    vec4 f = noise(p); p = m2 * p;\n    f += 0.5 * noise(p); p = m2 * p;\n    f += 0.25 * noise(p);\n    return f / 1.75;\n}\n","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"sld3z7","date":"1638044498","viewed":436,"name":"Hex Draw","username":"mhnewman","description":"Drawing canvas on hexagonal grid\n\nColor palette on the left, zoom slider on the right","likes":39,"published":1,"flags":32,"usePreview":0,"tags":["mouse","interactive","hexagon","draw","hex","canvas"],"hasliked":0,"parentid":"","parentname":""}}