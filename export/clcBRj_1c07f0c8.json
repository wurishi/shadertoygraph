{"ver":"0.1","info":{"id":"clcBRj","date":"1701389008","viewed":63,"name":"Weird Blobby Goo","username":"workingclasshacker","description":"Me trying to learn more about raymarching. ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","learning","effects"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 10.\n#define SURF_DIST 0.0001\n#define TRANSITION_DURATION 20.0 // in seconds\n#define GLOW_SIZE 50\n\nstruct CameraRotation {\n    float phi;\n    float theta;\n    float transitionEndTime;\n};\n\nstruct Camera {\n    vec3 pos;\n    vec3 target;\n    vec3 dir;\n    vec3 up;\n    vec3 right;\n    float fov;\n};\n\nstruct Light {\n    vec3 dir;\n    vec3 color;\n    float intensity;\n};\n\nstruct March {\n    float dist;\n    int steps;\n    float glow;\n};\n\nfloat t;\n\n// Initialize the camera\nCamera initCamera(vec3 pos, vec3 target, vec3 up, float fov) {\n    Camera cam;\n    cam.pos = pos;\n    cam.target = target;\n    cam.dir = normalize(target - pos);\n    cam.up = normalize(cross(cam.dir, up));\n    cam.right = normalize(cross(cam.dir, cam.up));\n    cam.fov = fov;\n    return cam;\n}\n\n// Initialize the light\nLight initLight(vec3 dir, vec3 color, float intensity) {\n    Light light;\n    light.dir = normalize(dir);\n    light.color = color;\n    light.intensity = intensity;\n    return light;\n}\n\n// Compute the ray direction\nvec3 getRay(Camera cam, vec2 uv) {\n    mat3 m = mat3(cam.up, cam.right, cam.dir);\n    return m * normalize(vec3(uv, cam.fov));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Box SDF (Signed Distance Function)\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n\n// From IQ: https://iquilezles.org/articles/distfunctions/\n\nfloat smUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\nfloat sdSphere(vec3 p, vec4 sphere) {\n    return length(p-sphere.xyz)-sphere.w;\n}\n\n\nvec3 repeat(vec3 p, vec3 c) {\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\n// Scene distance estimator\nfloat mapScene(vec3 p) {\n    p.x += (1.-cos(p.z*5.+t)*.2 + 1.-sin(p.y*3.+t)*.3)*.5+.5;\n    p.y += (1.-cos(p.x*5.+t)*.2 + 1.-sin(p.z*3.+t)*.3)*.5-.5;\n    float d = sdSphere(p, vec4(0,0,0,3.0));//sdMengerSponge(p, 5, 2.0);\n    p.x += (1.-cos(p.z*5.+t)*.2 + 1.-sin(p.y*3.+t)*.3)*.5+.5;\n    p.y += (1.-cos(p.x*5.+t)*.2 + 1.-sin(p.z*3.+t)*.3)*.5-.5;\n    float d2 = sdSphere(p, vec4(4.0,1.0,0,2.4));//sdMengerSponge(p, 5, 2.0);\n    p += vec3(-4.0,0,0);\n    //float d3 = sdTorus(p, vec2(3.4, .5));\n    return max(0.,smUnion(smUnion(d, d2, .2), 110.0, .5));\n    //return d3;\n}\n\n// Perform ray marching and calculate glow\nMarch rayMarch(vec3 rayOrigin, vec3 rayDir) {\n    float t = 0.0;\n    float glow = 0.0;\n    int i = 0;\n    for (i = 0; i < MAX_STEPS; i++) {\n        vec3 pos = rayOrigin + t * rayDir;\n        float dist = mapScene(pos);\n\n        if (dist < SURF_DIST || dist > MAX_DIST) {\n            if(dist < SURF_DIST) dist -= SURF_DIST * 0.5;\n            break;\n        }\n        t += dist;\n        // Adjust the glow calculation here. We need to ensure that the glow is noticeable.\n        // You can adjust the multiplier and the exponent based on your scene's scale and aesthetics.\n        glow += exp(-dist * dist * .3); // Increase the multiplier if glow is not visible.\n    }\n    March march;\n    march.dist = t;\n    march.steps = i;\n    // Adjust the normalization of glow factor based on the range of steps where glow is significant.\n    march.glow = glow / float(GLOW_SIZE);\n    return march;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize UV coordinates\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    t = mod(iTime, 6.28);\n    \n    // Update camera rotation based on mouse input and time\n    \n    // Calculate camera position \n    vec3 camPos = vec3(0,0,-5);\n    \n    // Initialize camera and light\n    Camera cam = initCamera(camPos, vec3(0.0, 0.0, 0.0), vec3(0.0, -1.0, 0.0), 0.5);\n    Light light = initLight(vec3(1.0, 1.0, -1.0), vec3(1.0, 1.0, 1.0), 1.0);\n\n    // Construct ray using camera and UV coordinates\n    vec3 rayOrigin = cam.pos;\n    vec3 rayDir = getRay(cam, uv);\n    // Ray marching\n    March m = rayMarch(rayOrigin, rayDir);\n    float t = m.dist;\n    vec3 col = vec3(0.1, 0.2, 0.3);\n    vec3 vigCol = vec3(.0, .5, .4);\n    vec3 vignette = (1. - vigCol * vec3(length(uv)))+.5;\n    col *= vignette;\n\n    // If the ray hits the surface, calculate the color and lighting\n    if (m.dist < MAX_DIST) {\n        vec3 normal = normalize(rayOrigin + m.dist * rayDir); // Approximate normal\n        float diff = max(dot(normal, light.dir), 0.0); // Diffuse lighting\n        col = mix(vec3(0.1, 0.2, 0.3), vec3(1.0, 1.0, 1.0) * light.intensity, diff); // Surface color\n    }\n    \n     // Apply glow effect with smooth interpolation\n    float glowFactor = smoothstep(0.0, 1.0, m.glow);\n    col += vec3(.5, 0.2, 0.7) * glowFactor; // Additive glow\n    float tt = t / 6.28;\n    //col.y = tt/20. - uv.x*sin(t*10.);\n    //col.x *= 2.1-(1.-t/6.28);\n    //col *= 1.-col;\n    col *= 1.2;\n    col.x *= 1.2-(uv.x*.5+.5);\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}