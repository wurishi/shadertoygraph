{"ver":"0.1","info":{"id":"tl33D4","date":"1576418998","viewed":378,"name":"Triangle Grate ","username":"Podis","description":"Got idea from searching Google for 'Hexagon Patterns'.\nThis one came from www.123rf.com - actual url is waaaay too long","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["triangle","shading","pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Learning a little more about mixing colors and patterns.\n// Got this idea from searching Google for Hexagon Patterns.\n// Needs to be cleaned up a bit as you can clearly see...\n\n// Thinking of using this to learn some basic animation.\n// Would be pretty cool if the background had some movement like fire or lava.\n\n// IQ's ndot function for SDF's\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nconst vec2 s = vec2(1, .8660254);\n\n// Shane's n2D function for dust\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; p *= p*(3. - p*2.); // p *= p*p*(p*(p*6. - 15.) + 10.); //\n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\nvec2 rotateDEG(vec2 v, float a) {\n    a = a*(3.1415/180.);\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\n// Shane's getTri\nvec4 getTri(vec2 p, inout float itri){\n    \n    p /= s;\n    float ys = mod(floor(p.y), 2.)*.5;\n    vec4 ipY = vec4(ys, 0, ys + .5, 0);\n    vec4 ip4 = floor(p.xyxy + ipY) - ipY + .5; \n    vec4 p4 = fract(p.xyxy - ipY) - .5;\n    float i = (abs(p4.x)*2. + p4.y<.5)? 1. : -1.;\n    itri = i;\n    float deg = 180.;\n    p4 = i>0.? vec4(p4.xy*s, ip4.xy) : vec4(rotateDEG(p4.zw*s, deg), ip4.zw);  \n    p4.yw += .144;\n    return p4;\n}\n\n// IQ's SDF-Rhombus\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\n// Where all the magic happens\nvec3 pattern(in vec2 p, out float mask){\n    \n    // Triangle Grid\n    p /= s;\n    float ys = mod(floor(p.y), 2.)*.5;\n    vec4 ipY = vec4(ys, 0, ys + .5, 0);\n    vec4 ip4 = floor(p.xyxy + ipY) - ipY + .5; \n    vec4 p4 = fract(p.xyxy - ipY) - .5;\n    float i = (abs(p4.x)*2. + p4.y<.5)? 1. : -1.;\n    float itri = i;\n    float deg = 180.;\n    p4 = i>0.? vec4(p4.xy*s, ip4.xy) : vec4(rotateDEG(p4.zw*s, deg), ip4.zw);  \n    p4.yw += .144;\n\n    \n    // Pattern Vars\n    float offset = .288;\n    deg = 60.;\n    vec2 size = vec2(.5, .275);\n    \n    vec3 col = vec3(0.);\n    vec3 shadow = vec3(.0);\n    \n    // Rhombus 1\n    vec2 p1 = p4.xy;\n    p1.y += offset;\n    float rh1 = sdRhombus(p1, size);\n    float aaf1 = fwidth(rh1)* .5;\n    float aac1 = smoothstep(aaf1, -aaf1, rh1);\n\n    \n    // Rhombus 2\n    vec2 p2 = p4.xy;\n    p2 = rotateDEG(p2, 60.);\n    p2.y -= offset;\n    float rh2 = sdRhombus(p2, size);\n    float aaf2 = fwidth(rh2)* .5;\n    float aac2 = smoothstep(aaf2, -aaf2, rh2);\n\n    \n    // Rhombus 3\n    vec2 p3 = p4.xy;\n    p3 = rotateDEG(p3, -60.);\n    p3.y -= offset;\n    float rh3 = sdRhombus(p3, size);\n    float aaf3 = fwidth(rh3)* .5;\n    float aac3 = smoothstep(aaf3, -aaf3, rh3);\n\n    \n    //mask = rh1 + rh2 + rh3;\n    mask = aac1 + aac2 + aac3;\n    \n    // Mixing\n    if (i > 0.){\n        col = mix(col, shadow + .1, aac1);\t// Bottom\n    \tcol = mix(col, shadow + .05, aac2);\t// Right\n    \tcol = mix(col, shadow + .15, aac3);\t// Left\n    }else{\n        col = mix(col, shadow + .15, aac1);\t// Top\n    \tcol = mix(col, shadow + .1, aac2);\t// Left\n    \tcol = mix(col, shadow + .05, aac3);\t// Right\n    }\n    \n    return vec3(col);\n\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -.5 to .5)\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scaling\n    vec2 s = vec2(1, sqrt(3.)/2.);\t// Equilateral (1, sqrt(3)/2)\n    float gSc = 4.;\n\tvec2 p = (uv*gSc);\n    \n    // Triangle Grid\n    float itri;\n    vec4 d = getTri(p, itri);\n   \n    // Final Result\n    float m;\n    vec3 fin = pattern(p, m);\n    \n    // Shane's Sprinkling of Dust\n    p *= 300./gSc;\n    fin *= ((n2D(p)*.5 + n2D(p*3.)*.25 + n2D(p*9.)*.15 + n2D(p*27.)*.1)*.75 + .5);\n    \n    // Background\n    vec3 col = vec3(1., .34, .01);\n    float c = -1. * (length(d.xy) - .35);\n    c *= 3.;\n   \n    // Mixes\n    col = mix(vec3(0.), col, c);\n    col = mix(col, fin,  m);\n \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}