{"ver":"0.1","info":{"id":"Msy3WG","date":"1456150041","viewed":2183,"name":"Local slope Erosion","username":"Dave_Hoskins","description":"Height map erosion using local slope values, not as good as moving points but much faster. It has a more corrosive effect. Click to move to new area. It can be a lot faster, but I liked the slow transition.","likes":20,"published":3,"flags":32,"usePreview":0,"tags":["terrain","heightmap","erosion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Local slope Erosion\n// by David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// #define LIT\n\n//--------------------------------------------------------------------------\nfloat terrain(vec2 p)\n{\n\n    vec4 r = texture(iChannel0, p / iResolution.xy);\n    return r.x*200.-r.w*200.;\n}\nvec3 getNormal( in vec2 pos)\n{\n    vec2  eps = vec2( 1., 0 );\n    return normalize( vec3( terrain(pos-eps.xy) - terrain(pos+eps.xy),\n                           2.*eps.x,\n                 \t\t   terrain(pos-eps.yx) - terrain(pos+eps.yx) ));\n}\n//--------------------------------------------------------------------------\n// Tiled noise to make it wrap around for flying...\n\n\nvoid mainImage( out vec4 colour, in vec2 coord )\n{\n    vec2 uv = (coord.xy+.5) / iResolution.xy;\n    vec3 ligDir = normalize(vec3(-2., 1., 3.2));\n                           \n    colour = texture(iChannel0, uv);\n     colour.xyz = vec3(colour.x-colour.w);\n#ifdef LIT\n     vec3 nor = getNormal(coord);\n     colour = vec4(1.0) * max(dot(nor, ligDir), 0.0);\n#endif\n }","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Local slope Erosion\n// by David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define HASHSCALE1 .1031\n\n//--------------------------------------------------------------------------\nfloat hash12(in vec2 p, in float scale)\n{\n    p = mod(p, scale);\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//--------------------------------------------------------------------------\n// Tiled noise to make it wrap around for flying...\nconst vec2 add = vec2(1,0);\nfloat noise( in vec2 x, in float scale )\n{\n    x *= scale;\n    x+=iTime+20.;\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(1.5-f)*2.0;\n    \n    float res = mix(mix( hash12(p, scale), hash12(p + add.xy, scale),f.x),\n                    mix( hash12(p + add.yx, scale), hash12(p + add.xx, scale),f.x),f.y);\n    return res;\n}\nfloat terrain(vec2 p)\n{\n    p+=.5;\n    float h = texture(iChannel0, p / iResolution.xy).x;\n    return h;\n}\nfloat fbm(vec2 pos)\n{\n    float a = 0.0;\n    float v = .9;\n    float scale = 4.0;\n    for (int i = 0; i < 12; i++)\n    {\n        a+= pow(noise(pos, scale) * v,1.2);\n        scale *= 2.2;\n        v *= .5;\n    }\n    return a;\n}\n\nvec3 getNormal( in vec2 pos)\n{\n    vec2  eps = vec2( 1., 0 );\n    return normalize( vec3( terrain(pos-eps.xy) - terrain(pos+eps.xy),\n                           2.*eps.x,\n                 \t\t   terrain(pos-eps.yx) - terrain(pos+eps.yx) ));\n}\n\nvoid mainImage( out vec4 colour, in vec2 coord )\n{\n    vec2 uv = coord.xy / iResolution.xy;\n    if (iFrame <= 1 || iMouse.z > 0.5)\n    {\n        float h = fbm(uv);\n        colour.x = h;\n        colour.w = .0 ;\n    }else\n    {\n        vec3 nor = getNormal(coord);\n        nor.xz = (nor.xz)*.1*iResolution.xy;\n        colour = texture(iChannel0, uv);\n        float h = colour.x;\n        float h1 = texture(iChannel0, uv+nor.xz).x;\n        float h2 = texture(iChannel0, uv-nor.xz).x;\n        colour.w += (h1-h)*.005;\n        colour.w += (h2-h)*.005;\n        colour.w = clamp(colour.w*.99, 0., 1.);\n\n    }\n    colour = max(colour,0.0);\n}","name":"Buf A","description":"","type":"buffer"}]}