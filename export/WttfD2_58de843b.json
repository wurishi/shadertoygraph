{"ver":"0.1","info":{"id":"WttfD2","date":"1613583925","viewed":625,"name":"Water Simulation with Raytracing","username":"Clocktown","description":"My previous water simulation, but now 3D rendered: https://www.shadertoy.com/view/WttBWj","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["3d","reflection","simulation","heightfield","refraction","water"],"hasliked":0,"parentid":"WttBWj","parentname":"Trivial Algorithm for Water"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simulation was forked from my previous work: https://www.shadertoy.com/view/WttBWj\n// That was an implementation of \"Trivial Algorithm for Interactive Water Simulation\" from AVR 2018\n// See: https://link.springer.com/chapter/10.1007/978-3-319-95270-3_43\n\n/* The core of this heightfield renderer is based on this work: https://www.shadertoy.com/view/Xss3zr\n *\n * Which was distributed with the following license:\n *\n * Copyright 2020 Simon Green (@simesgreen)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n \n /* I extended the original heightfield renderer with reflection/refraction, supporting a water layer + terrain layer and normals. \n  * I also modified parts of the camera-related code.\n  */\n  \n  \n// Simulation happens in whatever resolution is given, which is usually not square, so one dimension is kinda squashed?\n// => TODO: make box non-square and match aspect!\n\nconst int _Steps = 256;\nconst vec3 lightDir = vec3(0.577, 0.577, 0.577);\n\n// transforms\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = p.x;\n    r.y = ca*p.y - sa*p.z;\n    r.z = sa*p.y + ca*p.z;\n    return r;\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = ca*p.x + sa*p.z;\n    r.y = p.y;\n    r.z = -sa*p.x + ca*p.z;\n    return r;\n}\n\nbool\nintersectBox(vec3 ro, vec3 rd, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar)\n{\n\t// compute intersection of ray with all six bbox planes\n\tvec3 invR = 1.0 / rd;\n\tvec3 tbot = invR * (boxmin - ro);\n\tvec3 ttop = invR * (boxmax - ro);\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max (tmin.xx, tmin.yz);\n\ttnear = max (t0.x, t0.y);\n\tt0 = min (tmax.xx, tmax.yz);\n\ttfar = min (t0.x, t0.y);\n\t// check for hit\n\tbool hit;\n\tif ((tnear > tfar)) \n\t\thit = false;\n\telse\n\t\thit = true;\n\treturn hit;\n}\n\nfloat luminance(sampler2D tex, vec2 uv)\n{\n\tvec3 c = textureLod(tex, uv, 0.0).xyz;\n\treturn dot(c, vec3(0.33, 0.33, 0.33));\n}\n\nvec2 gradient(sampler2D tex, vec2 uv, vec2 texelSize)\n{\n\tfloat h = luminance(tex, uv);\n\tfloat hx = luminance(tex, uv + texelSize*vec2(1.0, 0.0));\t\n\tfloat hy = luminance(tex, uv + texelSize*vec2(0.0, 1.0));\n\treturn vec2(hx - h, hy - h);\n}\n\nvec2 worldToTex(vec3 p)\n{\n\tvec2 uv = p.xz*0.5+0.5;\n\tuv.y = 1.0 - uv.y;\n\treturn uv;\n}\n\nfloat heightField(vec3 p)\n{\n\t//return sin(p.x*4.0)*sin(p.z*4.0);\n\t//return luminance(iChannel0, p.xz*0.5+0.5)*2.0-1.0;\n\treturn 0.5*(terrain_h(worldToTex(p)));\n}\n\nvec2 dualHeightField(vec3 p)\n{\n    vec2 t_p = worldToTex(p);\n    float te = terrain_h(t_p);\n    float wd = texture(iChannel3, t_p).x;\n\treturn 0.5 * vec2(te, te+wd);\n}\n\nvec3 waterNormal(vec3 p) {\n    vec2 t_p = worldToTex(p);\n    vec2 dh = vec2(\n        (texture(iChannel3, t_p + dUV * Right).x + terrain_h(t_p + dUV * Right)) - (texture(iChannel3, t_p + dUV * Left).x + terrain_h(t_p + dUV * Left)),\n        (texture(iChannel3, t_p + dUV * Up).x + terrain_h(t_p + dUV * Up)) - (texture(iChannel3, t_p + dUV * Down).x + terrain_h(t_p + dUV * Down))\n    );\n    dh *= 0.25; // 0.5 * would be normal, but heights are additionally scaled by 0.5 in rendering\n    vec3 n = -cross(normalize(vec3(2.0 * dUV.x, dh.x, 0.0)), normalize(vec3(0.0, dh.y,  2.0 * dUV.y)));\n    return normalize(n) * vec3(1.0, 1.0, -1.0);\n}\n\nvec3 terrainNormal(vec3 p) {\n    vec2 t_p = worldToTex(p);\n    vec2 dh = vec2(\n        terrain_h(t_p + dUV * Right) - terrain_h(t_p + dUV * Left),\n        terrain_h(t_p + dUV * Up) - terrain_h(t_p + dUV * Down)\n    );\n    dh *= 0.25; // 0.5 * would be normal, but heights are additionally scaled by 0.5 in rendering\n    vec3 n = -cross(normalize(vec3(2.0 * dUV.x, dh.x, 0.0)), normalize(vec3(0.0, dh.y,  2.0 * dUV.y)));\n    return normalize(n) * vec3(1.0, 1.0, -1.0);\n}\n\nbool traceDualHeightField(vec3 ro, vec3 rayStep, out vec3 hitPos, out vec2 h, out int steps)\n{\n\tvec3 p = ro;\n\tbool hit = false;\n\tvec2 pH = vec2(0.0);\n\tvec3 pP = p;\n\tfor(int i=0; i<_Steps; i++) {\n        steps = i;\n\t\th = dualHeightField(p);\n  \n\t\tif ((p.y < h.y) && !hit) {\n\t\t\thit = true;\n            hitPos = mix(pP, p, (pH.y - pP.y) / ((p.y - pP.y) - (h.y - pH.y)));\n            return true; // added this\n            \n\t\t}\n\t\tpH = h;\n\t\tpP = p;\n\t\tp += rayStep;\n\t}\n\treturn hit;\n}\n\nbool traceHeightField(vec3 ro, vec3 rayStep, out vec3 hitPos, int i)\n{\n\tvec3 p = ro;\n\tbool hit = false;\n\tfloat pH = 0.0;\n\tvec3 pP = p;\n\tfor(; i<_Steps; i++) {\n\t\tfloat h = heightField(p);\n  \n\t\tif ((p.y < h) && !hit) {\n\t\t\thit = true;\n            hitPos = mix(pP, p, (pH - pP.y) / ((p.y - pP.y) - (h - pH)));\n            return true; // added this\n            \n\t\t}\n\t\tpH = h;\n\t\tpP = p;\n\t\tp += rayStep;\n\t}\n\treturn hit;\n}\n\nvec3 background(vec3 rd)\n{\n     return mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.5, 1.0), abs(rd.y));\n}\n\nMain\n{\n    InitUV;\n    vec2 pixel = (fC.xy / iResolution.xy)*2.0-1.0;\n\n    // compute ray origin and direction\n    float asp = iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -2.0));\n    vec3 ro = vec3(0.0, 0.0, 2.0);\n\t\t\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\n\t// rotate view\n    float ax = -0.7;\n\tif (iMouse.x > 0.0) {\n    \tax = -(1.0 - mouse.y)*2.0 - 1.0 + 0.9;\n\t}\n    rd = rotateX(rd, ax);\n    ro = rotateX(ro, ax);\n\t\t\n\tfloat ay = sin(iTime*0.2);\n    if (iMouse.x > 0.0) {\n    \tay = -(1.0 - mouse.x)*6.28 - 1.0 + 0.0;\n\t}\n    rd = rotateY(rd, ay);\n    ro = rotateY(ro, ay);\n\t\n\t// intersect with bounding box\n    bool hit;\t\n\tconst vec3 boxMin = vec3(-1.0, -0.01, -1.0);\n\tconst vec3 boxMax = vec3(1.0, 0.5, 1.0);\n\tfloat tnear, tfar;\n\thit = intersectBox(ro, rd, boxMin, boxMax, tnear, tfar);\n\n\ttnear -= 0.0001;\n\tvec3 pnear = ro + rd*tnear;\n    vec3 pfar = ro + rd*tfar;\n\t\n    float stepSize = length(pfar - pnear) / float(_Steps);\n\t\n    vec3 rgb = background(rd);\n    if(hit)\n    {\n    \t// intersect with heightfield\n\t\tro = pnear;\n\t\tvec3 hitPos;\n        vec2 h;\n        int steps;\n\n        hit = traceDualHeightField(ro, rd*stepSize, hitPos, h, steps);\n        if (hit) {\n            //rgb = hitPos*0.5+0.5;\n            //vec2 uv = worldToTex(hitPos);\n            bool calc_shadow = false;\n            bool hit_water = h.x < h.y - 0.001;\n            vec3 ld = lightDir;\n            if(hit_water) {\n                vec3 n = waterNormal(hitPos);\n                vec3 oldHitPos = hitPos;\n                float R0 = pow((1.0 - 1.325)/(2.325), 2.0);\n                float fresnel = R0 + (1.0 - R0) * pow(1.0 - dot(n, -rd), 5.0);\n                \n                // Handle Refraction\n                if(traceHeightField(hitPos, refract(rd, n, 1.0/1.325) * stepSize, hitPos, steps)) {\n                    // We pretend that the water is a flat surface and use a refracted light direction based on that to simulate the change in light direction\n                    ld = -refract(-ld, vec3(0.0,1.0,0.0), 1.0/1.325);\n                    float attenuation = min(pow(4.0 * distance(oldHitPos, hitPos), 2.0), 1.0);\n                    rgb = max(dot(ld, terrainNormal(hitPos)), 0.0) * vec3(0.8, 0.95, 0.6);\n                    rgb = mix(rgb, rgb * vec3(0.0, 0.0, 1.0 - 0.5*attenuation), attenuation);\n                    calc_shadow = true;\n                } else {\n                    // refracted ray goes into background, attenuate based on pfar on AABB\n                    float attenuation = min(pow(4.0 * distance(oldHitPos, pfar), 2.0), 1.0);\n                    rgb = mix(rgb, rgb * vec3(0.0, 0.0, 1.0 - 0.9*attenuation), attenuation);\n                }\n                rgb *= 1.0 - fresnel;\n                \n                // Handle Reflection\n                if(traceHeightField(oldHitPos, reflect(rd, n) * stepSize, hitPos, steps)) {\n                    // We hit the terrain, and assume it was out of water\n                    rgb += fresnel * max(dot(lightDir, terrainNormal(hitPos)), 0.0) * vec3(0.8, 0.95, 0.6);\n                } else {\n                    // We hit the BG\n                    rgb += fresnel * background(reflect(rd, n));\n                }\n            } else {\n                rgb = max(dot(ld, terrainNormal(hitPos)), 0.0) * vec3(0.8, 0.95, 0.6);\n                calc_shadow = true;\n            }\n            //texture(iChannel1, uv).xyz;\n            //vec2 g = gradient(iChannel0, uv, vec2(1.0) / iResolution.xy);\n            //vec3 n = normalize(vec3(g.x, 0.01, g.y));\n            //rgb = n*0.5+0.5;\n#if 1\n            // shadows\n            if(calc_shadow) {\n                hitPos += vec3(0.0, 0.001, 0.0);\n                bool shadow = traceHeightField(hitPos, ld*0.01, hitPos, 0);\n                if (shadow) {\n                    rgb *= 0.75;\n                }\n            }\n#endif\t\t\t\n        }\n     }\n\n    result=vec4(rgb, 1.0);\n\t//result = vec4(vec3(tfar - tnear)*0.2, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Config Params\nconst float K = 1.0; // \"Viscosity\" - 1 is no viscosity, lower is higher viscosity (essentially damping). Higher than 1 is possible, will be stable but weird\nconst float P_1 = 0.25; // Speed scale - should probably be 0.25 at most, higher causes bugs (so, unstable)\nconst float P_2 = 0.000001;//0.0000001; // Minimum difference that causes overflow, can be zero and should be close to zero\n\n\n// Lots of weird macros\n#define Main void mainImage( out vec4 result, in vec2 fC )\n#define InitUV UV = fC/iResolution.xy; dUV = vec2(1.0)/(iResolution.xy); px = ivec2(fC); Res = iResolution.xy;\n\n// Macros to grab the individual channels with offset\n#define A(x) texelFetch(iChannel0, px + x, 0)\n#define B(x) texelFetch(iChannel1, px + x, 0)\n#define C(x) texelFetch(iChannel2, px + x, 0)\n#define D(x) texelFetch(iChannel3, px + x, 0)\n\n// Macros for pixel offset vectors\n#define Mid vec2(0.0)\n#define iMid ivec2(0)\n#define Left vec2(-1.0, 0.0)\n#define Right vec2(1.0, 0.0)\n#define Up vec2(0.0, 1.0)\n#define Down vec2(0.0, -1.0)\n#define iLeft ivec2(-1, 0)\n#define iRight ivec2(1, 0)\n#define iUp ivec2(0, 1)\n#define iDown ivec2(0, -1)\n\n// Noise functions from Patricio Gonzalez Vizo: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\n// End of Noise functions\n\nivec2 px; // fragCoord in integer, calculate by macro at beginning\nvec2 UV; // UV, calculate it by macro at beginning\nvec2 dUV; // delta UV, calculate it by macro at beginning\nvec2 Res;\n\n// Terrain at integer offset to current pixel\nfloat terrain(vec2 off) {\n    vec2 p = UV + off * dUV;\n    \n    ivec2 pos_pix = ivec2(p * Res);\n    \n    if(pos_pix.x <= 5 || pos_pix.y <= 5 || pos_pix.x >= int(Res.x - 6.0) || pos_pix.y >= int(Res.y - 6.0)) {\n            return 100.0;\n    }\n    \n    // A Noise with slope\n    return noise(10.0 * p) * (1.0 - p.x);\n    \n}\n\nfloat terrain_h(vec2 p) {\n    ivec2 pos_pix = ivec2(p * Res);\n    \n    if(pos_pix.x <= 5 || pos_pix.y <= 5 || pos_pix.x >= int(Res.x - 6.0) || pos_pix.y >= int(Res.y - 6.0)) {\n            return 0.0;\n    }\n    \n    // A Noise with slope\n    return noise(10.0 * p) * (1.0 - p.x);\n    \n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// RGBA Inertia\n// reads C + D, writes A\n\nMain\n{\n    InitUV;\n    \n    // Todo: store terrain + depth instead of depth to optimize\n    float dx = D(iMid).x;\n    float hx = terrain(Mid) + dx;\n    vec4 ha = vec4(\n        terrain(Left) + D(iLeft).x,\n        terrain(Up) + D(iUp).x,\n        terrain(Right) + D(iRight).x,\n        terrain(Down) + D(iDown).x\n    );\n    \n    vec4 outflow = max(vec4(hx) - ha, vec4(0.0));\n    \n    // Add some forcefield into the mix\n    if(length(UV - vec2(0.5)) < 0.25 && iTime > 10.0) {\n    \n        // Radial pulsing forcefield in the middle of the scene\n        vec2 dir = normalize(UV - vec2(0.5));\n        vec4 force = vec4(0.0);\n        force.zy = clamp(dir, 0.0, 1.0);\n        force.xw = clamp(-dir, 0.0, 1.0);\n        \n        outflow += force * max(0.0025*sin(5.0*iTime), 0.0);//0.001;\n    }\n    \n    vec4 prevS = C(iMid);\n    vec4 S = K * prevS + P_1 * outflow;\n    \n    float Ssum = S.x + S.y + S.z + S.w;//dot(S, vec4(1.0));\n    \n    if(dx < Ssum) {\n        S = (dx * S) / Ssum;\n        Ssum = dx;\n    }\n    \n    // Explicitly fix the boundary, seems to be necessary\n    if(px.x <= 5 || px.y <= 5 || px.x >= int(iResolution.x - 6.0) || px.y >= int(iResolution.y - 6.0)) {\n        S = vec4(0.0);\n    }\n    \n    result = Ssum > P_2 ? S : vec4(0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// water depth\n// reads A and D, writes B\n\nMain\n{\n    InitUV;\n    \n    float dx = D(iMid).x;\n    vec4 S = A(iMid);\n    vec4 adjS = vec4 (\n        A(iLeft).z,\n        A(iUp).w,\n        A(iRight).x,\n        A(iDown).y\n    );\n    \n    float adjSsum = adjS.x + adjS.y + adjS.z + adjS.w; //dot(adjS, vec4(1.0));\n    float Ssum = S.x + S.y + S.z + S.w; //dot(S, vec4(1.0));\n    \n    if(px.x <= 5 || px.y <= 5 || px.x >= int(iResolution.x - 6.0) || px.y >= int(iResolution.y - 6.0)) {\n       result = vec4(0.0);\n    } else {\n        result = vec4(max(dx - Ssum + adjSsum, 0.0), 0.0, 0.0, 0.0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// RGBA Inertia (pong)\n\nMain\n{\n    InitUV;\n    \n    vec4 inertia = A(iMid);\n    \n    // Just to be extra safe, this is probably already the initial state.\n    if(iFrame == 0) {\n        inertia = vec4(0.0);\n    }\n    \n    result = inertia;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// water depth (pong)\n\nMain\n{\n    InitUV;\n    \n    vec4 depth = B(iMid);\n    \n    // Initialize water and ensure that there is none on the border\n    if(iFrame == 0) {\n        depth.x = max(1.0*float(UV.x > 0.75) - terrain(Mid), 0.0);\n        if(px.x <= 5 || px.y <= 5 || px.x >= int(iResolution.x - 6.0) || px.y >= int(iResolution.y - 6.0)) {\n            depth.x = 0.0;\n        }\n    }\n    \n    result = depth;\n}","name":"Buffer D","description":"","type":"buffer"}]}