{"ver":"0.1","info":{"id":"XscSRn","date":"1457242745","viewed":189,"name":"MandelboxTest","username":"gsitcia","description":"A mandelbox fractal<br/><br/>Scale -1.5          Try switching the commented out lines.<br/><br/>Uses raymarching. The distance expression is (obviously) not my own\nThis should no longer be as laggy. At least my chromebook doesn't die running it.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat rpBox( vec3 p, vec3 c ) {\n    vec3 q = mod(p,c)-0.5*c;\n    return udBox( p, vec3(0.5, 0.5, 0.5) );\n}\n\nvoid sphereFold(inout vec3 z, inout float dz) {\n\tfloat r2 = dot(z,z);\n    float minRadius2 = 0.5;\n    float fixedRadius2 = 1.0;\n\tif (r2 < minRadius2) { \n\t\t// linear inner scaling\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz *= temp;\n\t\tdz*= temp;\n\t} else if (r2 < fixedRadius2) { \n\t\t// this is the actual sphere inversion\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz *= temp;\n\t\tdz*= temp;\n\t}\n}\n\nvoid boxFold(inout vec3 z, inout float dz) {\n\tfloat foldingLimit = 1.0;\n    z = clamp(z, -foldingLimit, foldingLimit) * 2.0 - z;\n}\n\nfloat DE(vec3 z)\n{\n\tvec3 offset = z;\n    float Scale = 2.0;\n\tfloat dr = 1.0;\n\tfor (int n = 0; n < 21; n++) {\n\t\tboxFold(z,dr);       // Reflect\n\t\tsphereFold(z,dr);    // Sphere Inversion\n \t\t\n                z=Scale*z + offset;  // Scale & Translate\n                dr = dr*abs(Scale)+1.0;\n\t}\n\tfloat r = length(z);\n\treturn r/abs(dr);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat mindist = min(iResolution.x, iResolution.y);\n    \n    vec3 uv = vec3((gl_FragCoord.xy - iResolution.xy / 2.0) / mindist, 0.0);\n    \n    vec3 eye = vec3((2.0 * (iMouse.xy - iResolution.xy / 2.0) / mindist) + vec2(0.0, 5.0), iTime / 10.0 - 20.0);\n    \n    float fl = 1.0;\n    \n    vec3 fo = normalize(vec3(0.0, -1.0, 3.0));\n    \n    vec3 up = normalize(vec3(0.0, 1.0, 0.0));\n    \n    vec3 si = cross(up, fo);\n    \n    uv = eye + fl * fo + uv.x * si + uv.y * up;\n    \n    vec3 dr = uv - eye;\n    \n    dr = dr / length(dr);\n    \n    float dt = 0.0;\n    \n    for (int i = 0; i < 80; ++i) {\n        dt = DE( uv );\n        if (dt < 0.0001) {\n            dt = float(i);\n            break;\n        }\n        uv = uv + dr * dt;\n    }\n   \n    fragColor = vec4(dt / 70.0, dt / 80.0, dt / 80.0, 0.0);\n}","name":"Image","description":"","type":"image"}]}