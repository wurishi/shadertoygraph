{"ver":"0.1","info":{"id":"ws2Gzt","date":"1549773356","viewed":122,"name":"Arcs 3d","username":"theepicsnail","description":"3d version of https://www.shadertoy.com/view/td2GzR","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["arcs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS .001\n#define STEPS 120\n#define FAR_CLIP 100.0\nvec2 cossin(float f){ return vec2(cos(f), sin(f)); }\nvec2 rotate(vec2 xy, float f) {\n    vec2 cs = cossin(f);\n    return mat2x2(cs.x, -cs.y, cs.y, cs.x) * xy;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\nfloat sdSphere(vec3 p, float r) {\n    return length(p)-r;\n}\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nmat2x2 rotate(float t) { \n    float c = cos(t);\n    float s = sin(t);\n    return mat2(c,-s,s,c);\n}\n\n\nstruct SDF_RESULT {\n    vec4 params;\n    float best_dist;\n    int id;\n} sdf_result;\n\nstruct CAST_RESULT {\n    vec3 ro;\n    vec3 rd;\n    vec3 end;\n    float total_dist;\n    bool hit;\n} cast_result;\n\nbool update(float dist) {\n    if(dist < sdf_result.best_dist) {\n        sdf_result.best_dist = dist;\n        return true;\n    }\n    return false;\n}\n\n\nvec3 mirror(vec3 vin, vec3 pos, vec3 norm) {\n    //  v = i - 2 * n * dot(i n) .\n    float d = dot((vin - pos), norm);\n    return pos + (\n        (vin - pos) - (1.0+sign(d)) * norm * d\n    );\n    return reflect(vin-pos, norm)+pos;\n}\nfloat sdf(vec3 pos) {\n    sdf_result.best_dist = FAR_CLIP;\n    sdf_result.id = -1;\n\t\n    //if(update(length(pos.xy-vec2(1,0))-.1)) {\n//        sdf_result.params.xyz = vec3(1,0,0);\n//    }\n    update(sdSphere(pos, 1.));\n    \n    return sdf_result.best_dist;\n}\n\n\nvec2 eps = vec2(EPS, 0);\nvec3 sdf_normal(vec3 pos) {\n    return normalize(vec3(\n        sdf(pos - eps.xyy)-sdf(pos + eps.xyy),\n        sdf(pos - eps.yxy)-sdf(pos + eps.yxy),\n        sdf(pos - eps.yyx)-sdf(pos + eps.yyx)));\n}\n\n\nfloat min3(vec3 a) { return min(min(a.x,a.y),a.z);}\nfloat max3(vec3 a) { return max(max(a.x,a.y),a.z);}\nvec3 colorize(vec3 dir) {\n    vec3 o = dir;\n    dir-=min(min3(dir),0.);\n    dir/=max(1., max3(dir));\n    \n    return dir;\n}\n\nvec3 color() {\n    return sdf_result.params.xyz;\n}\n\nvec3 lighting() {\n    float f = cast_result.total_dist/FAR_CLIP;\n    vec3 n = sdf_normal(cast_result.end);\n    return vec3(1.0-sqrt(f)) * dot(cast_result.rd, n);\n}\n\nvoid cast_ray(vec3 ro, vec3 rd) {\n    \n    cast_result.ro = ro;\n    cast_result.rd = rd;\n    cast_result.hit = false;\n    \n    vec3 pos = ro;\n    float total_dist = 0.0;\n    for(int i = 0 ; i < STEPS ; i ++) {\n        float dist = sdf(pos);\n        if(dist < eps.x) {\n            cast_result.hit = true;\n        \tbreak;\n        }\n        \n        total_dist += dist;\n        pos += dist * rd;\n        \n        if(total_dist > FAR_CLIP) {\n            total_dist = FAR_CLIP;\n            break;\n        }\n    }   \n    \n    cast_result.total_dist = total_dist;\n    cast_result.end = pos;\n}\n\nvec3 movement(vec3 i) {\n   \n    i.xz = i.xz * rotate(cos(iTime)*.5);\n    i.xy = i.xy * rotate(iTime*.5);\n \treturn i;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    vec3 ro = movement(vec3(-5, 0, 0));\n    \n    vec3 rd = movement(normalize(vec3( 1.8, uv)));\n    \n    cast_ray(ro, rd);\n    \n    \n    fragColor.rgb = colorize(sdf_normal(cast_result.end)); //color() * lighting();\n    \n    \n}","name":"Image","description":"","type":"image"}]}