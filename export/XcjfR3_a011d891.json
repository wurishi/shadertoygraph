{"ver":"0.1","info":{"id":"XcjfR3","date":"1725273203","viewed":18,"name":"sinewave decoratum","username":"akr51","description":"Trying to get better at reflection, using the lighting and \"texture\" of the plane to be reflected on the sphere. It's not really a texture, hence the quotes. Just a trig function is projected on the plane using the smooth_plot. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","trig"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define DST 90.0\n#define ITR 120\n#define SRF 0.01\n\n\nfloat smooth_plot(vec2 uv, float f)\n{\n\n\n    float dl = 0.1;\n    float du = 0.1;\n    \n    return smoothstep(uv.y - dl, uv.y, f) - smoothstep(uv.y, uv.y + du, f);\n\n\n}\n\n\n\nfloat plane(vec3 sp) \n{\n\n\n    return sp.y + 0.5;\n\n\n}\n\n\n\n\nfloat sphere(vec3 sp)\n{\n\n    sp.x -= 5.4;\n    sp.z -= 13.6;\n    sp.y -= 2.6;\n    \n    return length(sp) - 3.1;\n\n}\n\n\n\n\nvec2 map(vec3 sp) \n{\n\n    float id = 0.0;\n    float dst[2];\n    dst[0] = plane(sp);\n    dst[1] = sphere(sp);\n    \n    \n    for (int i = 1; i < 2; i++) \n    {\n    \n        if (dst[i] < dst[0])\n        {\n        \n        \n            dst[0] = dst[i];\n            id = float(i);\n            \n        }\n    \n    }\n\n\n    return vec2(dst[0], id);\n\n}\n\n\n\nvec2 mrch(vec3 ro, vec3 rd)\n{\n    \n\n    float d0 = 0.0;\n    float id = 0.0;\n    for (int i = 0; i < ITR; i++)\n    {\n    \n        vec3 sp = ro + rd * d0;\n        \n        vec2 ds = map(sp);\n        id = ds.y;\n        d0 += ds.x * 0.80;\n        if (d0 > DST || abs(ds.x) < SRF) break;\n    \n    \n    }\n    \n    \n    return vec2(d0, id);\n    \n\n}\n\n\n\nvec3 nml(vec3 p)\n{\n\n\n    vec2 d = vec2(0.001, 0.0);\n    return normalize(map(p).x - vec3(map(p - d.xyy).x, map(p - d.yxy).x, map(p - d.yyx).x));\n    \n\n}\n\n\n\nfloat lighting(vec3 p, vec3 lp)\n{\n\n\n    vec3 l = normalize(lp - p);\n    vec3 n = nml(p);\n    float df = clamp(dot(n, l), 0.0, 1.0);\n    \n    vec2 ds = mrch(p + n * 0.02, l);\n    \n    if (ds.x < length(lp - p))\n    {\n    \n        \n        df *= 0.1;\n    \n    }\n    \n    return df;\n\n\n}\n\n\nvec3 dir(vec2 uv, vec3 ro, vec3 fx)\n{\n\n\n    vec3 w = normalize(fx - ro);\n    vec3 u = normalize(cross(w, vec3(0.0, 1.0, 0.0)));\n    vec3 v = normalize(cross(u, w));\n    return mat3(u, v, w) * normalize(vec3(uv, 2.5));\n    \n\n}\n\n\n\nvoid mainImage(out vec4 c_out, in vec2 u)\n{\n    \n    \n    vec2 rr = iResolution.xy;\n    vec2 uv = (u + u - rr) / rr.y;\n    \n    \n    vec3 ro = vec3(0.0, sin(iTime * 0.11) * 0.5 + 0.5, -5.0);\n    vec3 fx = vec3(0.0, 0.0, 0.0);\n    \n    vec3 rd = dir(uv, ro, fx);\n    \n    vec3 cl = vec3(0.0);\n    \n    vec2 d0 = mrch(ro, rd);\n    \n    float depth_d = d0.x;\n    float depth_f = exp(-depth_d * 0.1);\n    \n    vec3 sp = ro + rd * d0.x;\n    \n    vec3 lp = vec3(sin(sp.z + iTime), 0.000325, sp.z);\n   \n    vec3 mlp = vec3(0.0, 1.0, mod(iTime * 15.0, 128.0) - 64.0);\n    \n    if (d0.x > 0.0) \n    {\n        \n        \n        float lt = lighting(sp, lp);\n           \n           \n        // We'll make the sphere reflective\n        if (d0.y == 1.0) {\n        \n            vec3 n = nml(sp);\n            vec3 refld = reflect(rd, n);\n            \n            vec2 rd0 = mrch(sp + n * 0.01, refld);\n            float rdepth_f = exp(-rd0.x * 0.055);\n            vec3 rsp = sp + refld * rd0.x;\n            \n            vec3 rcl = vec3(1.0, 0.84, 0.0) * 0.01;\n            \n            if (rd0.y == 0.0) \n            {\n                vec3 rlp = vec3(sin(rsp.z + iTime), 0.000325, rsp.z);\n                rcl += mix(vec3(1.0, 0.84, 0.0) * 0.01, vec3(smooth_plot(rsp.zx, sin(rsp.z + iTime))),  rdepth_f) * 0.1;\n                rcl += lighting(rsp, rlp) * (vec3(1.0, 0.84, 0.0) * 0.3);\n                \n            } else {\n                \n                rcl += 0.001;\n            \n            }\n            \n            cl += rcl;\n            \n            \n            \n        } else {\n        \n            cl += lt * vec3(0.05, 0.05, 0.04);\n        \n        }\n        \n       \n        \n        if (d0.y == 0.0) \n        {\n        \n            cl += mix(vec3(0.0, 0.0, 0.0), vec3(smooth_plot(sp.zx, sin(sp.z + iTime))),  depth_f) * 2.25;\n            \n        \n        }\n        \n        cl += lighting(sp, mlp) * vec3(1.0, 1.84, 1.0) * 0.1;\n        \n\n    }\n    \n    c_out = vec4(cl, 1.0);\n    \n    \n}","name":"Image","description":"","type":"image"}]}