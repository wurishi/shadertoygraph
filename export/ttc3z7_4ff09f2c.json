{"ver":"0.1","info":{"id":"ttc3z7","date":"1576525674","viewed":112,"name":"ReflectionsRefractionsFun","username":"bignobody","description":"First Experiments with refraction. Probably a somewhat naive approach, but it's a start!","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","reflect","refract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nFirst attempt at transparent/refractive surfaces based on my earlier raymarching experiments.\nThanks as always to iq, BigWIngs (ArtOfCode), Jamie Wong and others for sharing their knowledge!\nFeedback is always welcome.\n\nUse mouse to change camera rotation.\n*/\n\n\n#define MAX_STEPS 500\n#define MAX_DIST 500.\n#define SURF_DIST .0001\n\nmat2 rotate2(float a) \n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// adapted from sdf functions by iq\nfloat sdfSphere(vec3 p, vec3 t, float r)\n{\n\treturn length(p-t)-r;   \n}\n\nfloat sdfBox( vec3 p, vec3 t, vec3 b )\n{\n  vec3 d = abs(p - t) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdfPlane( vec3 p, vec3 t, vec4 n )\n{\n  return dot(p-t,n.xyz) + n.w;\n}\n\n//From Shane (via shau) to avoid conditionals\nvec2 nearest(vec2 a, vec2 b) \n{    \n    float s = step(a.x, b.x);\n    return s * a + (1. - s) * b;    \n}\n\n////////\n// objects map\nvec2 sceneDistance(vec3 p)\n{\n\tfloat ti = iTime * 1.8;\n    vec2 c = vec2( sdfPlane(p,vec3(0.0,-60.0,0.0), normalize(vec4(0.0,1.0,0.0,1.0))), 0.0);\n   \tvec2 e = vec2( sdfBox(p, vec3(-145.0 * cos(ti) , 0.0, 145.0 * sin(ti)), vec3(10.0)), 2.0);\n    vec2 d = vec2( abs(sdfSphere(p, vec3(0.0, sin(iTime * 0.25)*8.0, 0.0), 20.0))-1.0, 1.0);\n\td =  nearest(d,e);\n    return nearest (d,c);\n}\n\n\nvec3 gridColor(vec2 uv, float s)\n{\n \tvec2 gv = fract(uv * s);\n    vec2 id = floor(uv * s);\n\treturn vec3(0.8) * mod(id.x+id.y,2.0)+0.01;   \n}\n\nfloat mat2Type(float m)\n{\n\tif (m == 1.0)\n    {\n        return -1.0;\n    }\n    return 1.0;\n}\n\nfloat mat2Reflect(float m)\n{\n    if (m == 0.0)\n    {\n    \treturn 0.001;   \n    }\n    \n    if (m < 1.1)\n    {\n     \treturn 0.06;\n    }\n    if (m < 2.1)\n    {\n     \treturn 0.75;\n    }\n    \n    return 0.1;\n\t   \n}\n\nvec3 mat2Col(float m, vec3 p)\n{\n    if (m == 0.0)\n    {\n    \treturn gridColor(p.xz,0.1);   \n    }\n    \n    if (m < 1.1)\n    {\n     \treturn vec3(0.2,0.16,0.05);   \n    }\n    if (m < 2.1)\n    {\n     \treturn vec3(0.05,0.16,0.19);   \n    }\n    \n    return vec3(0.9);\n}\n\nvec3 mat2Spec(float m)\n{\n    if (m == 0.0)\n    {\n    \treturn vec3(0.98);   \n    }\n    \n    if (m < 1.1)\n    {\n     \treturn vec3(0.6,0.46,0.25);   \n    }\n    if (m < 2.1)\n    {\n     \treturn vec3(0.5,0.6,0.9);   \n    }\n    \n    return vec3(0.99);\n}\n\nfloat mat2Shine(float m)\n{\n    if (m == 0.0)\n    {\n    \treturn 0.0001;\n    }\n    \n    if (m < 1.1)\n    {\n     \treturn 0.009;\n    }\n    if (m < 2.1)\n    {\n     \treturn 1.0;\n    }\n    \n    return 40.0;\n   \n}\n\nvec3 getNormal(vec3 p) \n{\n\tvec2 d = sceneDistance(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d.x - vec3(\n        sceneDistance(p-e.xyy).x,\n        sceneDistance(p-e.yxy).x,\n        sceneDistance(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec2 rayMarch(vec3 rayOrigin, vec3 rayDirection) \n{\n\tvec2 dist = vec2(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = rayOrigin + rayDirection * dist.x;\n        vec2 d = sceneDistance(p);\n        dist.x += d.x;\n        dist.y = d.y;\n        if(dist.x > MAX_DIST || abs(d.x) < SURF_DIST) break;\n    }\n    \n    return dist;\n}\n\n\n// soft shadows from iq's tutorial\nfloat shadowMarch( vec3 lightOrigin, vec3 surfacePoint )\n{\n    vec3 direction = normalize(lightOrigin-surfacePoint);\n    float blendFactor = 1024.0;\n  \tfloat res = 1.0;\n    float ph = 1e20;\n    float dist = 0.001;\n\n    float t = 0.01;\n    for( int i=0; i<128; i++ )\n    {\n        vec3 pos = surfacePoint + direction * dist;\n        float h = sceneDistance(pos).x;\n        res = min( res, blendFactor*max(h,0.0)/t );\n        if( res<0.0001 ) break;\n        t += clamp(h,0.01,0.5);\n    }\n\n    return res;\n}\n\n\nvec3 getLightPosition(int l)\n{\n    if (l == 0)\n    {\n        return vec3(30.0 * sin(iTime), 50.0, 40.0 * cos(iTime));\n    }\n    \n    return vec3(1.0,-10.5,1.0);\n}\n\nvec3 getLightIntensity(int l)\n{\n    if (l == 0)\n    {\n        return vec3(0.18);\n    }\n    return vec3(0.18,0.2,0.0);\n}\n\nvec3 lightPoint(vec3 p, vec3 e, float m) \n{\n    vec3 surfaceColour = vec3(0.0);\n\tfloat shadow = 1.0;\n    for (int i =0; i < 2; i ++)\n    {\n\t    vec3 lightPos = getLightPosition(i);\n    \tvec3 l = normalize(lightPos-p);\n    \tvec3 n = getNormal(p);\n    \t\n    \tfloat dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    \tvec3 surfacePoint = p+n*SURF_DIST*2.;\n    \tvec2 d = rayMarch(surfacePoint, l);\n    \n    \tvec3 V = normalize(e - surfacePoint);\n    \tvec3 R = normalize(reflect(-l, n));\n   \n    \tfloat dotLN = dot(l, n);\n    \tfloat dotRV = dot(R, V);\n    \tvec3 intensity = getLightIntensity(i);\n    \tvec3 colour = mat2Col(m,p);\n    \n    \tif (dotLN < 0.0) \n\t\t{\n        \t// Light not visible from this point on the surface\n        \tcolour *= 0.05;\n    \t} \n    \telse if (dotRV < 0.0) \n\t\t{\n       \t// Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n       \t\tcolour = intensity * colour * dotLN;\n        \tshadow = min(shadow, shadowMarch(lightPos, surfacePoint));\n    \t}\n    \telse\n    \t{\n    \t\tcolour = intensity* (colour * dotLN + mat2Spec(d.y) * pow(dotRV, mat2Shine(d.y)));\n        \tshadow = min(shadow, shadowMarch(lightPos, surfacePoint));\n    \t}\n    \n\t\tsurfaceColour += colour*shadow;\n    }\n                             \n    return surfaceColour;\n}\n\nvec3 rayMarchFull(vec3 rayOrigin, vec3 rayDirection, inout vec3 colAccum, vec3 skyCol, float maxBounces) \n{\n\tvec3 dist = vec3(0.0);\n    float refMixVal = 0.35;\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = rayOrigin + rayDirection * dist.x;\n        vec2 d = sceneDistance(p);\n        dist.x += d.x;\n        dist.y = d.y;\n        if(abs(d.x) < SURF_DIST)\n        {\n           \n\t\t\tvec3 litPoint = lightPoint(p, rayOrigin, dist.y);\n\n            dist.z += 1.0;\n            \n            if (mat2Type(dist.y) < 0.0)\n            {\n\t            colAccum = mix(colAccum * 0.98 , litPoint * 0.15, clamp(dist.z*dist.x * 0.6, 0.1,1.0));\n\n\t\t\t\t// single bounce reflect\n\t\t\t\tvec3 bounceDir = normalize(reflect((rayDirection ), getNormal(p)));\n\t\t\t\tvec3 bounceOrig = p + bounceDir * 0.1;\n                d = sceneDistance(bounceOrig);\n                if(abs(d.x) < SURF_DIST)\n        \t\t{\n                \tlitPoint = lightPoint(p, bounceOrig, d.y);\n\n\t            \tcolAccum = mix(colAccum * 0.5 , litPoint * 0.8, clamp(dist.z * 0.6, 0.1,1.0));\n                }\n                else\n                {\n                    colAccum = mix(colAccum * 2.98 , skyCol * 0.85, clamp(dist.z*dist.x * 0.01, 0.1,1.0));\n                }\n\n            \t// refract\n                rayDirection = normalize(refract(normalize(rayDirection),getNormal(p), 1.23));\n\t\t\t\tdist.x += abs(dist.x);\n                rayOrigin = p + rayDirection * dist.x;\n            }\n            else\n            {\n\t            colAccum = mix(colAccum * 0.25 , litPoint * 0.78, clamp(dist.z * 0.6, 0.1,1.0));\n    \n        \t// reflect\n\t\t\t\trayDirection = normalize(reflect((rayDirection ), getNormal(p)));\n            \tdist.x = 0.01;\n\t\t\t\t// move camera origin to reflection location\n\t\t\t\trayOrigin = p + rayDirection * dist.x;\n\t\t\t\t   \n            }\n            \n            if (dist.z >= maxBounces)\n            {\n            \treturn dist;   \n            }\n\n        }\n        if (dist.x > MAX_DIST) break;\n    }\n    \n    return dist;\n}\n\nvec3 rayCast(vec2 uv, vec3 pos, vec3 lookAt, float zoom) \n{\n    vec3 forward = normalize(lookAt-pos),\n    ray = normalize(cross(vec3(0,1,0), forward)),\n    up = cross(forward,ray),\n    center = pos+forward*zoom,\n    intersect = center + uv.x*ray + uv.y*up,\n    r = normalize(intersect-pos);\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\tvec2 mouse = iMouse.xy/iResolution.xy;\n    \n    float ambientLight = 6.0;//4.0 + sin(iTime*10.0);\n\n \tvec3 rayOrigin = vec3(0, 40, -45);\n    rayOrigin.yz *= rotate2(-mouse.y*3.14+1.);\n    rayOrigin.xz *= rotate2(-mouse.x*6.2831);\n    \n    vec3 rayDirection = rayCast(uv, rayOrigin, vec3(0,0.1,0), 1.0);\n\tvec3 colAccum = vec3(0.01);\n    \n\n    vec3 col = vec3(0.01,0.1,0.2) * smoothstep(1.0,0.08,rayDirection.y*1.2);\n\tvec3 dist = rayMarchFull(rayOrigin, rayDirection, colAccum, col, 6.0);\n    float refMixVal = 1.0;\n    \n    if(dist.z > 0.0) \n    {\n    \tcol = colAccum; //mix(col,colAccum, clamp(dist.x*dist.z*0.1,0.001,0.9)); //+(col * dist.z*dist.x * 0.0001);//*p; //mix(col,colAccum, 0.75);\n    }\n    else\n    {\n    \tcol = mix(colAccum,col,0.5);   \n    }\n    \n    col = pow(col * ambientLight,vec3(0.4545));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}