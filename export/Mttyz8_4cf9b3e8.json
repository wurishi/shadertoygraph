{"ver":"0.1","info":{"id":"Mttyz8","date":"1531594639","viewed":194,"name":"Sine function in Raymarch","username":"JohanFlod","description":"Trying to get distortion free sine wave motion in distance field objects. As the repeating grid is created I create an index in x direction. \n\nI colour the spheres based on their x position. The x position of the intersection point.\" projection mapping\"","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FAR 1000.\n#define EPSILON 0.01\n\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\nfloat rounded_cube(vec3 p)\n{\n\treturn length(max(abs(p)-.2,0.0))-.2;\n}\n\n\nfloat map(vec3 p)\n    \n{\n    // cell index in x \n   \tfloat c_x= floor((p.x + 2.0)/4.0);\n   \n    \n    // repeat cell in x and z direction \n    p.xz = mod(p.xz,2.) -1.;\n    vec3 grid;\n    \n    vec3 sphere_pos = vec3(.0, 2., .0); \n    // same sine movement for cells with same x axis index. \n    sphere_pos.y += sin(c_x + iTime) * .25;\n    sphere_pos.y += cos(c_x + iTime)*.25;\n    \n    //repeating coordinate system\n    \n   \n    \n    //sphere_pos.xz = fract(p.xz/2.)*2.-1. ;\n   \n    \n    \n    float distances = sdSphere(sphere_pos-p, 0.5);\n    return distances;\n}\n\n\n\n\nfloat trace(vec3 o, vec3 r)\n{\n    // start with zero distance\n\tfloat t = 0.0;\n    // i is number of samples along the ray\n    for (int i = 0; i < 1024; ++i) {\n        \n        // Current distance to nearest point in the scene\n    \tfloat d = map(o + r * t);\n        \n        /* If the ray comes within .001 units of the surface consider it a hit, and break. Also break if the \n\t\treay overshoots the maximum distance set, FAR\n\t\t*/\n        if ( d<.001 || t>FAR) break;\n        \n        // advance the ray\n        t += d;\n    }\n    \n    // cap distance to the maximum\n    \n    return min(t, FAR);\n\n\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // coordinate system from -1 to +1\n    // correct aspect ratio\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n\n    // ray/camera where third coordinate is Field of View\n   \tvec3 r = normalize(vec3(uv, .9));\n    \n    // rotate the ray/camera\n    \n    //float the = 0.1*iTime;\n    //r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    // camera position\n    vec3 o = vec3(1.0, 4.2, 1.0+iTime);\n    \n    float t = trace(o,r);\n    \n    // things further away gets darker\n    // fog based on camera to surface distance. \n    \n    float fog = 1.0 / (1.0 +  t * t* .02);\n   \t\n    vec3 intersection = o + r * t;\n   \n    float col_var_x =1.- .5*abs(sin(ceil(intersection.x*.5)));\n    //float col_var_y = 1.-.5*sin(floor(intersection.y*.5));\n     \n    \n    vec3 nrml = estimateNormal(intersection);\n    vec3 light_dir = normalize(vec3(1.0, 1.0, 1.0));\n   \tfloat diffuse = dot(light_dir, nrml);\n    diffuse = diffuse * 0.5 + 0.5;\n    diffuse = max(0.0,diffuse);\n    vec3 light_color = vec3(1.4, 1.2, 0.7);\n    vec3 ambient_color = vec3(0.2, 0.45, 0.6);\n    vec3 diffuseLit = vec3(col_var_x,.0,1.-col_var_x) * (diffuse * light_color + ambient_color);\n   \n    //water_line += sin(floor(intersection.x*20.));\n   \n   \n   \t\n    fragColor = vec4(diffuseLit,1.0)*fog;\n    //fragColor = vec4(fc.b*diffuse,.0,.5*(1.0-fc.r)*diffuse,1.0);\n    /*\n    vec3 p = o + r*t;\n    float diff = max(map(p + .5773*.001) - map(p),0.)/.001*.5773;\n    fragColor = (diff + .5)*vec4(fog);\n    \n    fragColor = sqrt(max(fragColor*fragColor2,0.));\n\t*/\n\t\n}","name":"Image","description":"","type":"image"}]}