{"ver":"0.1","info":{"id":"4lXcR2","date":"1505444187","viewed":675,"name":"Image Melting","username":"mplanck","description":"Playing with differential based blurring and signal diffusion, and came up with this simple toy. Eventually, I want to add shock waves, but that will involve velocity fields and a pressure solve.","likes":15,"published":1,"flags":32,"usePreview":1,"tags":["differentials","melt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor.rgb = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    fragColor.a = 1.0f;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float luminosity(vec3 color)\n{\n    return dot(vec3(0.21, 0.71, .07), color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // give some time for the images to load\n    int frame = iFrame - 30;\n    \n    vec2 this_coord = fragCoord/iResolution.xy;\n    vec3 scol = vec3(0.);\n    if (frame >= 0)\n    {\n        if (frame%300 == 0)\n        {        \n            int selector = (frame/300)%3;\n\n            if (selector == 0) \n            {\n            \tscol = textureLod(iChannel1, this_coord, 0.).rgb;\n            } \n            else if (selector == 1)\n            {\n            \tscol = textureLod(iChannel2, this_coord, 0.).rgb;\n            }\n            else if (selector == 2)\n            {\n            \tscol = textureLod(iChannel3, this_coord, 0.).rgb;            \n            }\n            //scol = pow(scol, vec3(2.));\n\n        }\n        else\n        {\n            vec3 this_color = textureLod(iChannel0, this_coord, 0.).rgb;\n            float this_value = luminosity(this_color);\n            vec4 accum = vec4(0.);\n            \n            for (int i = -1; i<=1; i += 1)\n            {\n                for (int j = -1; j<=1; j += 1)\n                {\n                    if (i == 0 && j == 0) {\n                        // really de-value this color's influence, which creates\n                        // interesting diffusion effects\n                        accum.rgb += this_color * this_value * .02;\n                        accum.a += this_value * .02;\n                        continue;\n                    }\n\n\n                    vec2 coord_offset = vec2(i, j);                \n                    vec2 neighbor_coord = vec2(this_coord) + 1. * coord_offset/iResolution.xy;\n                    neighbor_coord;\n\n                    vec3 neighbor_color = vec3(0.);\n                    // simple boundary conditions\n                    if (neighbor_coord.x < 0. || neighbor_coord.x >= 1. || \n                        neighbor_coord.y < 0.)\n                    {\n                        neighbor_color = this_color;\n                    }\n                    else if (neighbor_coord.y >= 1.)\n                    {\n                        neighbor_color = vec3(.01);\n                    }\n                    else\n                    {\n                        neighbor_color = textureLod(iChannel0, neighbor_coord, 0.).rgb;\n                    }\n\n                    float neighbor_value = luminosity(neighbor_color);\n\n                    float l = sqrt(dot(vec2(1.), abs(vec2(coord_offset))));\n                    float d = max(1e-4, abs(this_value - neighbor_value) / l);\n                    // add more influence from the color above this coordinate to\n                    // create the melting effect\n                    if (j == 1)\n                    {\n                        d += .1;\n                    }\n                    accum.rgb += neighbor_color * d;\n                    accum.a += d;\n                }\n            }\n\n            accum.rgb /= accum.a;\n\n            scol = accum.rgb;\n\t    }\n    }\n    \n    fragColor = vec4(scol,1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}