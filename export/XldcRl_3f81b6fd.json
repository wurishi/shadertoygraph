{"ver":"0.1","info":{"id":"XldcRl","date":"1533668304","viewed":275,"name":"Happy glutton Pac","username":"Ignitron","description":"Another pacman shader!","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["pacman"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tFirst of all I want share a thousand thanks to my namesake IÃ±igo Quilez for letting everyone enjoy such a nice tool, \n\twhere one can develop and visualize its own fantasies :)\n\t\n\tWarn: This code is a mix from many geniouses that copied others who copied others(nested forever).\n\tAlso pretends to be didactic in a fairly easy way.\n\t\n\tWould love mentioning the users Nrx & iquilez as my main influences on this shader(functions, ideas, talent, etc...).\n\t\n\tHope someone enjoys it and why not, copy some aspects if they are deserved! :D\n\t\n\tPD: It is highly possible that there are some remains from my own engine, literally unusable here... sorry for it\n\n\tThank you, again, to my love Sara, for ... the other funny point of view!\n*/\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define MOUSE\n#define SHADOW\n#define ARMS\n#define LEGS\n\n#define CAMERA_FOCAL_LENGTH\t2.0\n\n#define RAY_LENGTH_MAX\t\t1000.0\n#define RAY_STEP_MAX\t\t1000.0\n#define DELTA\t\t\t0.2\n#define DELTA_SEARCH\t0.1527\n\n#define NORMAL_DELTA\t\t0.2\n\n#define SHADOW_LENGTH\t\t600.0\n#define SHADOW_POWER\t\t1.0\n#define SHADOW_DELTA\t\t0.12\n\n#define AMBIENT\t\t\t0.1\n\n#define GAMMA\t\t\t1.0\n\n#define BACKGROUND_COLOR vec3(0.3, 0.4, 0.6)\n\n// Math constants\n#define PI\t\t3.14159265359\n#define PI2\t\t6.28318530718\n\n//Config\nvec3 pacmanColor = vec3(0.9,0.65,0.1);\nvec3 pacmanMat = vec3(1.0,0.1,0.0);\nvec3 gloveColor = vec3(1.0,0.545,0.298);\nvec3 gloveMat = vec3(5.0,0.3,0.0);\nvec3 bootColor = vec3(0.55,0.145,0.1);\nvec3 bootMat = vec3(2.0,0.1,0.0);\nvec3 bigBiscuitColor = vec3(1.0,0.75,0.15);\nvec3 bigBiscuitMat = vec3(30.0,0.5,0.0);\nvec3 biscuitColor = vec3(0.9,0.65,0.1);\nvec3 biscuitMat = vec3(10.0,0.5,0.0);\nvec3 groundColor = vec3(0.1,0.898,0.545);\nvec3 groundMat = vec3(3.0,0.0,0.0);\nvec3 tongueColor = vec3(0.9,0.1,0.1);\nvec3 tongueMat = vec3(10.0,5.0,0.0);\nvec3 eyeBallColor = vec3(0.0,0.0,0.0);\nvec3 eyeBallMat = vec3(30.0,1.0,0.0);\nvec3 eyeBall2Color = vec3(0.5,0.5,1.0);\nvec3 eyeBall2Mat = vec3(50.0,3.0,0.0);\n\n//Lighting\nvec3 lightDir = normalize(vec3(0.9,0.8,0.2));\nvec3 light2Dir = normalize(vec3(-0.9,-0.8,-0.2));\nfloat light2Pow = 0.1;\n\n\nmat3 rotX(float c, float s)\n{ \n    return mat3( 1.0, 0.0, 0.0, \n                0.0, c, s, \n                0.0, -s, c);\n}\n\nmat3 rotY(float c, float s)\n{ \n    return mat3( c, 0.0,-s, \n                0.0,1.0,0.0, \n                s, 0.0, c);\n}\n\nmat3 rotZ(float c, float s)\n{ \n    return mat3( c, s, 0.0,\n                -s, c, 0.0, \n                0.0, 0.0, 1.0);\n}\n\nfloat smin( float a, float b, float k, float l )\n{\n\tfloat h = clamp( l + l*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 smin( vec2 a, vec2 b, float k, float l )\n{\n\tfloat h = clamp( l + l*(b.x-a.x)/k, 0.0, 1.0 );\n\treturn vec2( mix( b.x, a.x, h ) - k*h*(1.0-h), mix( b.y, a.y, h ) );\n}\n\nfloat smax( float a, float b, float k, float l )\n{\n\tfloat h = clamp( l + l*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n    return (length( (p-c)/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nvec2 sdSegment( vec3 a, vec3 b, vec3 p )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat reboundValue( float iTime, float limit )\n{\n    float doubleLimit = limit*2.0;\n\tfloat doubleValue = mod(iTime, doubleLimit);\n    if(doubleValue>limit)\n        return doubleLimit-doubleValue;\n    return doubleValue;\n}\n\n\n// Distance to the scene and color of the closest point\nfloat distScene (in vec3 p, out vec3 color, out vec3 material) {\n\tfloat d = 1000.0;\n    float d2 = 1000.0;\n    float d3 = 1000.0;\n    float d4 = 1000.0;\n    \n    float speed = iTime*0.5;\n    \n    float speedPI2 = speed*PI2;\n    \n    vec3 pacmanPos = vec3(0.0,sin((speedPI2)-2.2)*20.0,0.0);\n    \n    //body\n    vec3 pacmanRelPos = p-pacmanPos;\n    float body = length (pacmanRelPos);\n\tbody = max (body - 32.0, 27.5 - body);\n\tfloat mouthAngle = PI * (0.09 + 0.08 * sin (speedPI2));\n    vec3 mouthPos = pacmanRelPos-vec3(0.0,3.0,5.0);\n\tfloat mouthTop = dot (mouthPos, vec3 (0.0, -cos (mouthAngle), sin (mouthAngle))) - 2.0;\n\tmouthAngle *= 1.8;\n\tfloat mouthBottom = dot (mouthPos, vec3 (0.0, cos (mouthAngle), sin (mouthAngle)));\n\tfloat pacManBody = max (body, min (mouthTop, mouthBottom));\n    \n    d = pacManBody;\n    color = pacmanColor;\n    material = pacmanMat;\n    \n    // EYES\n    float eyesAngle = sin(speedPI2)*2.0;\n    vec3 eyesPos = vec3 (abs (pacmanRelPos.x) - 11.5, pacmanRelPos.y - (18.2)-eyesAngle, pacmanRelPos.z - (19.2 - eyesAngle));\n    vec3 q = 1.2*eyesPos;\n\tfloat eyeBall = max (length (q) - (6.0), -p.z);\n    q = 1.0*eyesPos;\n    float eyeBall2 = min(eyeBall,max (length (q) - (6.0), -p.z));\n    eyeBall2 = max(pacManBody-0.1,eyeBall2);\n\tif (eyeBall2 <= d) {\n        d = eyeBall2;\n        if(eyeBall < eyeBall2)\n        {\n            color = eyeBallColor;\n        \tmaterial = eyeBallMat;\n        }\n        else\n        {\n        \tcolor = eyeBall2Color;\n        \tmaterial = eyeBall2Mat;\n        }\n    }\n    \n    //TONGUE\n    float tongueFactor = abs(sin(mod(speed*2.0,PI2)));\n    vec3 tongueAnim = vec3(1.0,1.4,2.5)*tongueFactor;\n    float tongue = sdEllipsoid( vec3(abs(p.x), p.yz), \n                               vec3(3.0,-18.5,-3.0)+pacmanPos, \n                               vec3(14.0,3.2,17.0)+tongueAnim );\n    d2 = smin(pacManBody,tongue,2.06,0.5);\n    if(d2 < d)\n    {\n        d = d2;\n        if(tongue <= d2+0.09)\n        {\n            color = tongueColor;\n    \t\tmaterial = tongueMat;\n        }\n    }\n    \n    float mirrorX = sign(p.x);\n    \n    #ifdef ARMS\n    float armsPeriod = PI*0.55;\n    float armsPeriodiTime = (speedPI2*0.275)-1.15+((mirrorX+1.0)*0.5*armsPeriod);\n    float armRotSegmentA = reboundValue(armsPeriodiTime,armsPeriod)-1.0;\n    float armsSinRotA = sin(armRotSegmentA);\n    float armsCosRotA = cos(armRotSegmentA);\n    mat3 armsSegmentARot = rotX(armsCosRotA, armsSinRotA);\n    \n    float armRotSegmentB0 = reboundValue(armsPeriodiTime,armsPeriod)-0.7;\n    float armsSinRotB0 = sin(armRotSegmentB0);\n    float armsCosRotB0 = cos(armRotSegmentB0);\n    mat3 armsSegmentB0Rot = rotY(armsCosRotB0, armsSinRotB0);\n    \n    float armRotSegmentB1 = reboundValue(armsPeriodiTime,armsPeriod)-1.1;\n    float armsSinRotB1 = sin(armRotSegmentB1);\n    float armsCosRotB1 = cos(armRotSegmentB1);\n    mat3 armsSegmentB1Rot = rotX(armsCosRotB1, armsSinRotB1);\n    \n    float armRotSegmentB2 = reboundValue(armsPeriodiTime,armsPeriod)-0.1;\n    float armsSinRotB2 = sin(armRotSegmentB2);\n    float armsCosRotB2 = cos(armRotSegmentB2);\n    mat3 armsSegmentB2Rot = rotZ(armsCosRotB2, armsSinRotB2);\n    \n    mat3 armsSegmentBRot = armsSegmentB0Rot*armsSegmentB1Rot*armsSegmentB2Rot;\n    \n    vec3 armsSegmentAPos = vec3(28.0,3.0,-2.0)+pacmanPos;\n    vec3 armsSegmentBPos = armsSegmentARot*(vec3(10.0,-10.0,5.0))+armsSegmentAPos;\n    vec3 armsSegmentCPos = armsSegmentBRot*(vec3(1.0,-2.0,15.0))+armsSegmentBPos;\n    \n    vec2 armSegmentA = sdSegment( armsSegmentAPos, armsSegmentBPos, vec3(abs(p.x),p.yz) );\n\td2 = armSegmentA.x - 4.0 + armSegmentA.y*1.0;\n \td2 = smin(pacManBody,d2,1.06,0.5);\n    if (d2 < d) {\n        d = d2;\n\t\tcolor = pacmanColor;\n    \tmaterial = pacmanMat;\n\t}\n    \n    vec2 armSegmentB = sdSegment( armsSegmentBPos, armsSegmentCPos, vec3(abs(p.x),p.yz) );\n\td4 = armSegmentB.x - 3.0 + armSegmentB.y*1.0;\n \td2 = smin(d2,d4,2.06,0.5);\n    if (d2 < d) {\n        d = d2;\n\t\tcolor = pacmanColor;\n    \tmaterial = pacmanMat;\n\t}\n    \n    //Hand\n    vec3 handPos = armsSegmentBRot*vec3(0.0,0.0,1.2)+armsSegmentCPos;\n    \n    vec2 hand = sdSegment( armsSegmentCPos, handPos, vec3(abs(p.x),p.yz) );\n\td3 = hand.x - 3.0 + hand.y*0.1;\n \td2 = smin(d2,d3,2.06,0.5);\n    \n    d2 = smax(-d4,d3,1.06,0.5);\n    if (d2 < d) {\n        d = d2;\n        if(d3 <= d2+0.28)\n        {\n            color = gloveColor;\n            material = gloveMat;\n        }\n\t}\n    \n    //Fingers\n    vec3 fingerPos00 = armsSegmentBRot*vec3(-2.0,2.6,8.2)+armsSegmentCPos;\n    vec3 fingerPos01 = armsSegmentBRot*vec3(-2.0,0.0,9.5)+armsSegmentCPos;\n    vec3 fingerPos02 = armsSegmentBRot*vec3(-2.0,-2.6,8.2)+armsSegmentCPos;\n    \n    vec2 finger00 = sdSegment( armsSegmentCPos, fingerPos00, vec3(abs(p.x),p.yz) );\n\td3 = finger00.x - 1.5 + finger00.y*0.5;\n    d2 = smin(d2,d3,0.01,0.1);\n    \n    vec2 finger01 = sdSegment( armsSegmentCPos, fingerPos01, vec3(abs(p.x),p.yz) );\n\td3 = finger01.x - 1.5 + finger01.y*0.5;\n    d2 = smin(d2,d3,0.01,0.1);\n    \n    vec2 finger02 = sdSegment( armsSegmentCPos, fingerPos02, vec3(abs(p.x),p.yz) );\n\td3 = finger02.x - 1.5 + finger02.y*0.5;\n \td2 = smin(d2,d3,0.01,0.1);\n    \n    if (d2 < d) {\n        d = d2;\n        if(d3 <= d2+0.28)\n        {\n        color = gloveColor;\n        material = gloveMat;\n        }\n\t}\n    #endif\n    \n    #ifdef LEGS\n    float legsPeriod = PI*0.75;\n    float legsPeriodiTime = ((speedPI2*0.375)-1.55)+((-mirrorX+1.0)*0.5*legsPeriod);\n    float legRotSegmentA = reboundValue(legsPeriodiTime,legsPeriod)-1.4;\n    float legsSinRotA = sin(legRotSegmentA);\n    float legsCosRotA = cos(legRotSegmentA);\n    mat3 legsSegmentARot = rotX(legsCosRotA, legsSinRotA);\n    \n    float legRotSegmentB1 = reboundValue(legsPeriodiTime*0.85-1.1,legsPeriod*0.85);\n    float legsSinRotB1 = sin(legRotSegmentB1);\n    float legsCosRotB1 = cos(legRotSegmentB1);\n    mat3 legsSegmentB1Rot = rotX(legsCosRotB1, legsSinRotB1);\n    \n    mat3 legsSegmentBRot = legsSegmentB1Rot*legsSegmentARot;\n    \n    vec3 legsSegmentAPos = vec3(14.0,-27.0,1.0)+pacmanPos;\n    vec3 legsSegmentBPos = legsSegmentARot*(vec3(0.0,-22.0,0.0))+legsSegmentAPos;\n    vec3 legsSegmentCPos = legsSegmentBRot*(vec3(0.0,-20.0,0.0))+legsSegmentBPos;\n    \n    vec2 legsegmentA = sdSegment( legsSegmentAPos, legsSegmentBPos, vec3(abs(p.x),p.yz) );\n\td2 = legsegmentA.x - 4.5 + legsegmentA.y*1.0;\n \td2 = smin(pacManBody,d2,3.06,0.5);\n    if (d2 < d) {\n        d = d2;\n\t\tcolor = pacmanColor;\n    \tmaterial = pacmanMat;\n\t}\n    \n    vec2 legsegmentB = sdSegment( legsSegmentBPos, legsSegmentCPos, vec3(abs(p.x),p.yz) );\n\td4 = legsegmentB.x - 3.5 + legsegmentB.y*1.0;\n \td2 = smin(d2,d4,2.06,0.5);\n    if (d2 < d) {\n        d = d2;\n\t\tcolor = pacmanColor;\n    \tmaterial = pacmanMat;\n\t}\n    \n    //Boot\n    vec3 bootPos = legsSegmentBRot*vec3(0.0,-4.6,14.2)+legsSegmentCPos;\n    \n    vec2 boot = sdSegment( legsSegmentCPos, bootPos, vec3(abs(p.x),p.yz) );\n\td3 = boot.x - 5.5 + boot.y*1.4;\n    d2 = smin(d,d3,2.06,0.5);\n    d2 = smax(-d4,d3,6.06,0.5);\n    if (d2 < d) {\n        d = d2;\n        if(d3 <= d2+0.28)\n        {\n            color = bootColor;\n            material = bootMat;\n        }\n\t}\n    #endif\n    \n    // Biscuits\n    float biscuitPeriod = 200.0;\n    \n    float displacement = floor (speed * biscuitPeriod);\n    \n    float idsPerPeriod = 8.0;\n    \n    float fullPeriod = biscuitPeriod*idsPerPeriod;\n    \n    float modPerPeriod = mod (p.z + displacement, fullPeriod);\n    \n    float unitDist = fullPeriod/idsPerPeriod;\n\n\tfloat idValue = modPerPeriod/unitDist;\n\tidValue = idValue-fract(idValue ); // modf(idValue, idValue);\n    \n    float difSize = floor(idValue/(idsPerPeriod-1.0))*4.0;\n\tq = vec3 (p.xy, mod (p.z + displacement, biscuitPeriod) - biscuitPeriod * 0.5);\n\tfloat biscuit = max (length (q) - (6.0+difSize), -p.z);\n\tif (biscuit < d) {\n\t\td = biscuit;\n        if(idValue==(idsPerPeriod-1.0))\n        {\n            color = bigBiscuitColor;\n        \tmaterial = bigBiscuitMat;\n        }\n        else\n        {\n            color = biscuitColor;\n        \tmaterial = biscuitMat;\n        }\n\t}\n    \n    // Ground\n\tfloat ground = (p.y + 91.50 );\n\tif (ground < d) {\n\t\td = ground;\n\t\tcolor = groundColor;\n        material = groundMat;\n\t}\n    \n    \n\treturn d;\n}\n\n// Distance to the scene\nvec2 dist (inout vec3 p, in vec3 ray, in float rayLengthMax, in float delta, out vec3 color, out vec3 material) {\n    color = vec3(0.0,0.0,0.0);\n    material = vec3(0.0,0.0,0.0);\n\tfloat d = 0.0;\n\tfloat rayLength = 0.0;\n\tfor (float rayStep = 0.0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\td = distScene (p, color, material);\n\t\tif (d < delta) {\n\t\t  break;\n\t\t}\n\t\td = d*DELTA_SEARCH;\n\t\trayLength += d;\n\t\tif (rayLength > rayLengthMax) {\n\t\t\tbreak;\n\t\t}\n\t\tp += d * ray;\n\t}\n\treturn vec2 (d, rayLength);\n}\n\n// Normal at a given point\nvec3 normal (in vec3 p) {\n\tvec2 h = vec2 (NORMAL_DELTA, -NORMAL_DELTA);\n    vec3 dummy0, dummy1;\n\tvec3 n;\n\tn = h.xxx * distScene (p + h.xxx, dummy0, dummy1) +\n\t\t\th.xyy * distScene (p + h.xyy, dummy0, dummy1) +\n\t\t\th.yxy * distScene (p + h.yxy, dummy0, dummy1) +\n\t\t\th.yyx * distScene (p + h.yyx, dummy0, dummy1);\n\treturn normalize (n);\n}\n\n// Main function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\t// Get the fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n\t// Define the ray corresponding to this fragment\n\tvec3 ray = normalize (vec3 (frag, CAMERA_FOCAL_LENGTH));\n\n\t// Compute the orientation of the camera\n\tfloat yawAngle = PI * (1.9) + clamp(reboundValue( iTime, PI2*1.15 ), PI, PI2);\n\tfloat pitchAngle = PI*(0.1);\n    \n\t#ifdef MOUSE\n\t\tyawAngle += 8.0 * PI * iMouse.x;\n\t\tpitchAngle += PI * 8.0 * (1.0 - iMouse.y);\n\t#endif\n\n\tfloat cosYaw = cos (yawAngle);\n\tfloat sinYaw = sin (yawAngle);\n\tfloat cosPitch = cos (pitchAngle);\n\tfloat sinPitch = sin (pitchAngle);\n\n\tmat3 cameraOrientation;\n\tcameraOrientation [0] = vec3 (cosYaw, 0.0, -sinYaw);\n\tcameraOrientation [1] = vec3 (sinYaw * sinPitch, cosPitch, cosYaw * sinPitch);\n\tcameraOrientation [2] = vec3 (sinYaw * cosPitch, -sinPitch, cosYaw * cosPitch);\n\n\tray = cameraOrientation * ray;\n\n\t// Compute the origin of the ray\n\tfloat cameraDist = 250.0;\n\tvec3 origin = (clamp(reboundValue( iTime, PI2*1.5 ), 0.0, PI)*10.0+(vec3 (0.0, -30.0, 0.0)) - cameraOrientation [2] * cameraDist);\n\n\t// Compute the distance to the scene\n    vec3 color;\n    vec3 material;\n\tvec2 d = dist (origin, ray, RAY_LENGTH_MAX, DELTA, color, material);\n\n\t// Set the background color\n\tvec3 finalColor = vec3(0.0,0.0,0.0);\n\tif (d.x < DELTA) {\n        vec3 n = normal (origin);\n        vec3 diffuse = color * max(0.0,dot(n,lightDir));\n        float specular = pow (max (0.0, dot (reflect (ray, n), lightDir)), material.x) * material.y;\n        vec3 ambient = (AMBIENT*color*groundColor);\n        finalColor = (diffuse+specular);\n        \n        diffuse = color * max(0.0,dot(n,light2Dir));\n        specular = pow (max (0.0, dot (reflect (ray, n), light2Dir)), material.x) * material.y;\n        \n        #ifdef SHADOW\n            vec3 shadowOrigin = origin + n * SHADOW_DELTA*0.5;\n            vec2 shadowDist = dist (shadowOrigin, lightDir, SHADOW_LENGTH, SHADOW_DELTA, color, material);\n            if (shadowDist.x < SHADOW_DELTA ) {\n                float shadowAmount = pow (min (1.0, shadowDist.y / SHADOW_LENGTH), SHADOW_POWER);\n                finalColor *= shadowAmount;\n            }\n\t\t#endif\n        \n\n        finalColor += (diffuse+specular)*light2Pow*groundColor;\n        \n        finalColor += ambient;\n    }\n\n    float dist = length(origin)/600.0;\n    //finalColor = vec3(dist,dist,dist);\n    \n    finalColor = mix(finalColor, BACKGROUND_COLOR, min(dist,1.0));\n    \n\t// Set the fragment color\n\tfinalColor = pow (finalColor, vec3 (GAMMA));\n\tfragColor = vec4 (finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}