{"ver":"0.1","info":{"id":"43jSW1","date":"1710527560","viewed":60,"name":"Fork 1D Error D leonliang 275","username":"leonliang","description":"Fork for testing","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["dithering","errordiffusion"],"hasliked":0,"parentid":"4dt3W7","parentname":"1D Error Diffusion"},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\n// number of pixels wide to accumulate error. outside of a frag shader, this would naturally be the width of the image in pixels.\nconst float accWidth = 2250.;\nconst float resMult = 1.;\n//#define COLOR\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 pix = fragCoord;\n    vec4 o = fragColor;\n    pix = floor(pix/resMult)*resMult;\n    vec3 outpColor;\n    vec3 accErr;\n    for(float i = accWidth; i >= 0.; -- i)\n    {\n        // make sure we're always working from specific boundaries, otherwise the\n        // error accumulation effect doesn't behave correctly\n        float leftBoundary = floor(pix.x/accWidth)*accWidth;\n        if(pix.x-i < leftBoundary)\n            continue;\n\n        vec2 uv = vec2(pix.x-i,pix.y)/iResolution.xy;\n        o = texture(iChannel0, uv);\n        vec3 idealColor = o.rgb;//= (o.r+o.g+o.b)/3.;// gray scale.\n        #ifndef COLOR\n        idealColor = vec3(o.r+o.g+o.b)/3.;// gray scale.\n        #endif\n\n        vec3 idealColorWithErrCorr = idealColor + accErr;\n        outpColor = step(0.,idealColorWithErrCorr-.5);\n        accErr = idealColorWithErrCorr - outpColor;\n    }\n    \n    fragColor=vec4(outpColor,1);\n}\n\n\n","name":"Image","description":"","type":"image"}]}