{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float _zoom = zooming; //(iMouse.y / iResolution.y)*100.0;\n\n    vec2 pixPos = vec2(fract(fragCoord/_zoom));\n    ivec2 zoom = ivec2(fragCoord/_zoom);\n    \n    point p0 = getPoint(texelFetch(iChannel0, zoom, 0));\n    point p1 = getPoint(texelFetch(iChannel0, zoom+ivec2(0,1), 0));\n    point p2 = getPoint(texelFetch(iChannel0, zoom+ivec2(1,1), 0)); \n    point p3 = getPoint(texelFetch(iChannel0, zoom+ivec2(1,0), 0)); \n    \n    float slider = iMouse.x/iResolution.x;\n    \n    // Output to screen\n    float height = getHeight(pixPos, p0, p1, p2, p3) / 1.0;\n    //fragColor = vec4(slider*height + (1.0-slider)*getPoint(texelFetch(iChannel0, ivec2(vec2(zoom)+pixPos+0.5), 0)).height);\n    \n    //fragColor = slider*vec4(0.5*getSlope(pixPos, p0, p1, p2, p3) + 0.5, 0.0, 1.0) + (1.0-slider)*vec4(height)*vec4(0.404,0.592,0.659,0.0);\n    \n    fragColor = vec4(height)*vec4(0.404,0.592,0.659,0.0);\n    \n    p0.height -= hash22(vec2(zoom)).x/16.0;\n    \n    // pixel water\n    \n    if (p0.height > 0.7)\n    {\n        fragColor = vec4(0.353,0.510,0.565,0.0);\n    } \n    else if (p0.height > 0.05)\n    {\n        fragColor = vec4(0.404,0.592,0.659,0.0);\n    }\n    else\n    {\n        fragColor = vec4(0.0);\n    }\n    \n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"// from paint streams\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define sizer 256.0\n// set to 256 width\n#define zooming iResolution.x/sizer\n//#define zooming 1.0\n\n// from paint\n#define fluid_rho 0.5\nfloat Pf(float rho)\n{\n    return 0.06*rho*(rho/fluid_rho - 1.0);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\n// Dave's hash function\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// this is contains the graph for the particals\nstruct point\n{\n    float height;\n    vec2 gradient;\n    vec2 velocity;\n};\n\npoint getPoint(vec4 info)\n{\n    point p;\n    p.height = info.r;\n    p.gradient = unpackHalf2x16(floatBitsToUint(info.g));\n    p.velocity = unpackHalf2x16(floatBitsToUint(info.b));\n    \n    return p;\n}\n\nvec4 savePoint(point p)\n{\n    vec4 info;\n    \n    info.r = p.height;\n    info.g = uintBitsToFloat(packHalf2x16(p.gradient));\n    info.b = uintBitsToFloat(packHalf2x16(p.velocity));\n    \n    return info;\n}\n\nvec4 initPoint(vec2 fragCoord)\n{\n    vec4 info;\n    \n    info.r = 0.0; //(hash22(fragCoord + 0.2).x + hash22(fragCoord + 0.2).y) * 0.05;\n    info.g = 0.0; //uintBitsToFloat(packHalf2x16( vec2(0.0) )); //4.0*hash22(fragCoord + 0.4)-2.0));\n    info.b = 0.0; //uintBitsToFloat(packHalf2x16( (2.0*hash22(fragCoord + 0.8)-1.0)/8.0    )); \n    info.a = 0.0;\n    \n    return info;\n}\n\nfloat getHeight(vec2 pos, point p0, point p1, point p2, point p3)\n{\n    // Here I am calculating the coefficents of the Hermite then adding them together\n\n    // 2t^{3} - 3t^{2} + 1\n    vec2 a = 2.0*pos*pos*pos-3.0*pos*pos+1.0;\n    // -2t^{3} + 3t^{2}\n    vec2 b = -2.0*pos*pos*pos+3.0*pos*pos;\n    \n    float height = a.x*a.y*p0.height + a.x*b.y*p1.height + b.x*b.y*p2.height + b.x*a.y*p3.height;\n    \n    // t^{3} - 2t^{2} + t\n    vec2 c = pos*pos*pos-2.0*pos*pos + pos;\n    // t^{3} - t^{2}\n    vec2 d = pos*pos*pos-pos*pos;\n    \n    // the added height with the effect of the slope at each corner\n    float slope = c.x*a.y*p0.gradient.x + c.y*a.x*p0.gradient.y + d.x*a.y*p3.gradient.x + c.y*b.x*p3.gradient.y\n        + d.x*b.y*p2.gradient.x + d.y*b.x*p2.gradient.y + c.x*b.y*p1.gradient.x + d.y*a.x*p1.gradient.y;\n    \n    return height + slope;\n}\n\n// calculate the dervative of the function here\nvec2 getSlope(vec2 pos, point p0, point p1, point p2, point p3)\n{\n    // Here I am calculating the coefficents of the Hermite then adding them together\n\n    // 2t^{3} - 3t^{2} + 1\n    vec2 dxa = 6.0*pos*pos-6.0*pos;\n    // -2t^{3} + 3t^{2}\n    vec2 dxb = -6.0*pos*pos+6.0*pos;\n    \n    // 2t^{3} - 3t^{2} + 1\n    vec2 a = 2.0*pos*pos*pos-3.0*pos*pos+1.0;\n    // -2t^{3} + 3t^{2}\n    vec2 b = -2.0*pos*pos*pos+3.0*pos*pos;\n    \n    // take the parcial derivative\n    vec2 height;\n    height.x = dxa.x*a.y*p0.height + dxa.x*b.y*p1.height + dxb.x*b.y*p2.height + dxb.x*a.y*p3.height;\n    height.y = a.x*dxa.y*p0.height + a.x*dxb.y*p1.height + b.x*dxb.y*p2.height + b.x*dxa.y*p3.height;\n\n    \n    // t^{3} - 2t^{2} + t\n    vec2 dxc = 3.0*pos*pos-4.0*pos + 1.0;\n    // t^{3} - t^{2}\n    vec2 dxd = 3.0*pos*pos-2.0*pos;\n    \n   // t^{3} - 2t^{2} + t\n    vec2 c = pos*pos*pos-2.0*pos*pos + pos;\n    // t^{3} - t^{2}\n    vec2 d = pos*pos*pos-pos*pos;\n    \n    vec2 slope;\n    \n    // the added height with the effect of the slope at each corner\n    slope.x = dxc.x*a.y*p0.gradient.x + c.y*dxa.x*p0.gradient.y + dxd.x*a.y*p3.gradient.x + c.y*dxb.x*p3.gradient.y\n        + dxd.x*b.y*p2.gradient.x + d.y*dxb.x*p2.gradient.y + dxc.x*b.y*p1.gradient.x + d.y*dxa.x*p1.gradient.y;\n    \n    slope.y = c.x*dxa.y*p0.gradient.x + dxc.y*a.x*p0.gradient.y + d.x*dxa.y*p3.gradient.x + dxc.y*b.x*p3.gradient.y\n        + d.x*dxb.y*p2.gradient.x + dxd.y*b.x*p2.gradient.y + c.x*dxb.y*p1.gradient.x + dxd.y*a.x*p1.gradient.y;\n        \n    \n    return height + slope;\n}\n/*\nfloat getHeight(vec2 posOne, vec2 posTwo, point p, float s)\n{\n    // get height contribution with no slope\n    vec2 dif = posTwo - posOne;\n    \n    // make sure that the function does not fall out of bounds\n    vec2 next = min(abs(dif), 1.0);\n    \n    // 2x^{3}-3x^{2}+1\n    vec2 then = 2.0 * next * next * next - 3.0 * next * next + 1.0;\n    \n    float height = then.x*then.y*p.height*1.0;\n    \n    vec2 slopeO = next * next * next - 2.0 * next *next + next;\n    vec2 slopeT = next *next *next - next * next;\n\n    // multiply direction of the sign by slope to get it to positve coordinates \n    \n    // now add the slope height\n    \n    // todo: use dot product here\n    //height += slopeO.x*then.y*p.gradient.x*sign(dif.x) + slopeO.y*then.x*p.gradient.y*sign(dif.y);    \n    height += dot(slopeO*then.yx*p.gradient, sign(dif));\n    \n    // boundries\n    \n    // number of cells affected:\n    float numCells = 9.0;\n    \n    // corner case\n    if (posOne.y == 10.0 && posOne.x == 10.0)\n    {\n        numCells = 4.0;\n    }\n    else if (posOne.y == 10.0 && posOne.x == 256.0 - 10.0)\n    {\n        numCells = 4.0;\n    }\n    \n    // edge case\n    else if (posOne.y == 10.0)\n    {\n        numCells = 6.0;\n    }\n    else if (posOne.y < 10.0)\n    {\n        return 0.0;\n    }\n    else if (posOne.x == 10.0)\n    {\n        numCells = 6.0;\n    }\n    else if (posOne.x < 10.0)\n    {\n        return 0.0;\n    }\n    else if (posOne.x == sizer - 10.0)\n    {\n        numCells = 6.0;\n    }\n    else if (posOne.x > sizer -10.0)\n    {\n        return 0.0;\n    }\n    \n    height -= (slopeO.x*p.gradient.x + slopeT.x*p.gradient.x + slopeO.y*p.gradient.y + slopeT.y*p.gradient.y) / numCells;\n    \n    return height * (1.0 - s) + (p.height / numCells) * s; \n}\n\nvec2 getSlope(vec2 posOne, vec2 posTwo, point p, float s)\n{\n    // get height contribution with no slope\n    vec2 dif = posTwo - posOne;\n    \n    // make sure that the function does not fall out of bounds\n    vec2 next = min(abs(dif), 1.0);\n    \n    // TODO: double check math here\n    \n    // there is a fall off here -- double check this\n    vec2 a = 2.0 * next * next * next - 3.0 * next * next + 1.0;\n    \n    // get height controbution to the slope\n    vec2 dxa = 6.0 * next * next - 6.0 * next;\n    \n    vec2 slope = vec2(dxa.x*a.y*p.height, dxa.y*a.x*p.height)*sign(dif);\n    \n    // now add the slope part to the slope\n    \n    //x^{3}-2x^{2}+x\n    vec2 dxb = 3.0 *next * next - 4.0 * next + 1.0;\n    \n    // TODO: double check this formula\n    slope += vec2(dxb.x*a.y*p.gradient.x, dxb.y*a.x*p.gradient.y);\n    \n    slope = slope * (1.0 - s);\n    \n    return slope;\n}\n*/\n\n/*\nvec3 getNext(vec2 posOne, vec2 posTwo, point p, float s)\n{\n    // get height contribution with no slope\n    vec2 dif = posTwo - posOne;\n    \n    // make sure that the function does not fall out of bounds\n    vec2 n1 = min(abs(dif), 1.0);\n    vec2 n2 = n1 * n1;\n    vec2 n3 = n2 * n1; \n    \n    vec2 then = (2.0 * n1 - 3.0) * n2 + 1.0;\n        \n    // Now calculate slope:\n    vec2 dxa = 6.0 * (n2 - n1);\n    vec2 dxb = (3.0 * n1 - 4.0) * n1 + 1.0;\n    \n    float height = then.x*then.y*p.height;\n    \n    vec2 slopeO = n3 - 2.0 * n2 + n1;\n    vec2 slopeT = n3 - n2;\n    \n    height += dot(slopeO*then.yx*p.gradient, sign(dif));\n    \n    // boundries\n    float numCells = 9.0;\n    \n    // corner case\n    \n    //if (posOne.y == 10.0 && (posOne.x == 10.0 || posOne.x == sizer - 10.0))\n    //    numCells = 4.0;\n    //// edge case\n    //else if (posOne.y == 10.0 || posOne.x == 10.0 || posOne.x == sizer - 10.0)\n    //    numCells = 6.0;\n    //else if (posOne.y < 10.0 || posOne.x < 10.0 || posOne.x > sizer - 10.0)\n    //    return vec3(0.0);\n     \n         // corner case\n    if (posOne.y == 10.0 && posOne.x == 10.0)\n    {\n        numCells = 4.0;\n    }\n    else if (posOne.y == 10.0 && posOne.x == sizer - 10.0)\n    {\n        numCells = 4.0;\n    }\n    \n    // edge case\n    else if (posOne.y == 10.0)\n    {\n        numCells = 6.0;\n    }\n    else if (posOne.y < 10.0)\n    {\n        return vec3(0.0);\n    }\n    else if (posOne.x == 10.0)\n    {\n        numCells = 6.0;\n    }\n    else if (posOne.x < 10.0)\n    {\n        return vec3(0.0);\n    }\n    else if (posOne.x == sizer - 10.0)\n    {\n        numCells = 6.0;\n    }\n    else if (posOne.x > sizer -10.0)\n    {\n        return vec3(0.0);\n    }\n    \n    height -= dot(slopeO + slopeT, p.gradient)/numCells;\n    \n    height = mix(height, p.height / numCells, s);\n\n    vec2 slope = then.yx * (dxa*p.height*sign(dif) + dxb*p.gradient); \n    \n    slope *= (1.0 - s);\n    \n    return vec3(height, slope);\n}\n*/\n\n\nvec3 getNext(vec2 posOne, vec2 posTwo, point p, float s)\n{\n    // get height contribution with no slope\n    vec2 dif = posTwo - posOne;\n    \n    // make sure that the function does not fall out of bounds\n    vec2 next = min(abs(dif), 1.0);\n    \n    // 2x^{3}-3x^{2}+1\n    vec2 then = 2.0 * next * next * next - 3.0 * next * next + 1.0;\n    \n    float height = then.x*then.y*p.height*1.0;\n    \n    vec2 slopeO = next * next * next - 2.0 * next *next + next;\n    vec2 slopeT = next *next *next - next * next;\n\n    // multiply direction of the sign by slope to get it to positve coordinates \n    \n    // now add the slope height\n    \n    // todo: use dot product here\n    //height += slopeO.x*then.y*p.gradient.x*sign(dif.x) + slopeO.y*then.x*p.gradient.y*sign(dif.y);    \n    \n    // boundries\n    \n    // number of cells affected:\n    float numCells = 9.0;\n    \n    // corner case\n    if (posOne.y == 10.0 && posOne.x == 10.0)\n    {\n        numCells = 4.0;\n    }\n    else if (posOne.y == 10.0 && posOne.x == 256.0 - 10.0)\n    {\n        numCells = 4.0;\n    }\n    \n    // edge case\n    else if (posOne.y == 10.0)\n    {\n        numCells = 6.0;\n    }\n    else if (posOne.y < 10.0)\n    {\n        return vec3(0.0);\n    }\n    else if (posOne.x == 10.0)\n    {\n        numCells = 6.0;\n    }\n    else if (posOne.x < 10.0)\n    {\n        return vec3(0.0);\n    }\n    else if (posOne.x == sizer - 10.0)\n    {\n        numCells = 6.0;\n    }\n    else if (posOne.x > sizer -10.0)\n    {\n        return vec3(0.0);\n    }\n    \n    //height -= (slopeO.x*p.gradient.x + slopeT.x*p.gradient.x + slopeO.y*p.gradient.y + slopeT.y*p.gradient.y) / numCells;\n    \n    height = height * (1.0 - s) + (p.height / numCells) * s; \n    \n    // TODO: double check math here\n    \n    // there is a fall off here -- double check this\n    vec2 a = 2.0 * next * next * next - 3.0 * next * next + 1.0;\n    \n    // get height controbution to the slope\n    vec2 dxa = 6.0 * next * next - 6.0 * next;\n    \n    vec2 slope = vec2(dxa.x*a.y*p.height, dxa.y*a.x*p.height)*sign(dif);\n    \n    // now add the slope part to the slope\n    \n    //x^{3}-2x^{2}+x\n    vec2 dxb = 3.0 *next * next - 4.0 * next + 1.0;\n    \n    // TODO: double check this formula\n    slope += vec2(dxb.x*a.y*p.gradient.x, dxb.y*a.x*p.gradient.y);\n    \n    slope = slope * (1.0 - s);\n    \n    return vec3(height, slope);\n}\n","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initilize the buffer with data\n    if (iTime < 0.1)\n    {\n        fragColor = initPoint(fragCoord);\n        \n        return;\n    }\n    \n    ivec2 pos = ivec2(fragCoord.xy);\n    \n    vec3 nextPoint = vec3(0.0);\n    \n    point p;\n    p.height = 0.0;\n    p.gradient = vec2(0.0);\n    p.velocity = vec2(0.0);\n    \n    vec2 Force;\n    \n    float under = 0.0;\n    \n    range(i, -1, 1) range(j, -1, 1)\n    {\n        ivec2 tpos = pos + ivec2(i, j);\n        \n        point p_ = getPoint(texelFetch(iChannel0, tpos, 0));\n        \n        // smoothing amount\n        // subtract by an amount here! Important makes the fluid more particlly   \n        float s = clamp((p_.height-under)/4.0, 0.0, 0.8);\n        \n        // pos one is the new center point pos\n        // pos two is the point that will add to this one\n        nextPoint = getNext(vec2(pos), vec2(tpos) + p_.velocity, p_, s);\n        \n        // multipy new velocity by the mass that each cell contribues\n        p.height += nextPoint.x;\n        p.gradient += nextPoint.yz;\n        p.velocity += p_.velocity * nextPoint.x;\n    }\n    \n    // normalize the velocity baced on mass\n    if (p.height > 0.0)\n    {\n        p.velocity = p.velocity / p.height;\n    }\n    \n    vec2 F = vec2(0.0);\n    vec3 avgV = vec3(0.0);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        ivec2 tpos = pos + ivec2(i, j);\n        \n        point p_ = getPoint(texelFetch(iChannel0, tpos, 0));\n        \n        vec2 dx = vec2(pos) - (vec2(tpos) + p_.velocity); \n        float avgP = 0.5*p_.height*(Pf(p.height) + Pf(p_.height)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += p_.height*G(1.*dx)*vec3(p_.velocity,1.);\n    }\n    avgV.xy /= avgV.z*2.0;\n\n    //viscosity\n    F -= 0.0*p.height*(avgV.xy - p.velocity);\n    \n    // force from mouse\n    if (distance(fragCoord, vec2(iMouse.xy/(zooming))) < 5.0 && iMouse.z > 1.0 || (iMouse.x < 0.1 && distance(fragCoord, vec2(iResolution.xy/2.0/(zooming))) < 5.0))\n    {\n        vec2 newF = (fragCoord - vec2(iMouse.xy/(zooming))) / 6000.0;\n        \n        F.x += -newF.y;\n        F.y += newF.x;\n        //F.y -= 0.0005;\n        \n        p.height += 0.1;\n    }\n    \n    // 1 * (p.height/35.0) this is so the gradient isn't used to calculate fluid in wrong places\n    p.velocity -= (F/p.height) * 4.0 - (p.gradient) * 0.002  + vec2(0.0, 0.005);\n    \n    p.velocity += (hash22(fragCoord + iTime) - 0.5) / 12.0;\n    \n    // make sure that the velocity does not exceed the limit\n    p.velocity = clamp(p.velocity, -1.0, 1.0);  \n    \n    // place circle at center of screen\n    if (distance(fragCoord, vec2(iResolution.xy/(2.0*zooming))) < 0.0)\n    {\n        p.height = 0.5;\n        p.gradient = vec2(0.0);\n        p.velocity = vec2(0.0, 0.4); //vec2(cos(iTime), sin(iTime));\n    }\n    \n    // boundries\n    // soft\n    if (pos.y < 12)\n    {\n        p.velocity.y /= 5.0;\n    }\n    if (pos.x < 12)\n    {\n        p.velocity.x /= 5.0;\n    }\n    if (pos.x >= int(sizer) - 12)\n    {\n        p.velocity.x /= 5.0;\n    }\n    \n    // hard\n    if (pos.y <= 10)\n    {\n        p.velocity.y = 0.0;\n    }\n\n    if (pos.x <= 10)\n    {\n        p.velocity.x = 0.0;\n    }\n    \n    if (pos.x >= int(sizer) - 10)\n    {\n        p.velocity.x = 0.0;\n    }\n    \n    fragColor = savePoint(p);\n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"McVXR1","date":"1734303011","viewed":81,"name":"Fluid Sim Using Cubic Hermite","username":"capslpop","description":"Just an old fluid solver that I had that looks cool!","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["hermite"],"hasliked":0,"parentid":"XfdSDH","parentname":"Hermite Blur w/ Slope"}}