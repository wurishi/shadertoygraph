{"ver":"0.1","info":{"id":"llVBDw","date":"1542979487","viewed":240,"name":"TunnelFlight","username":"Falko","description":"camera follows a space-curve, enveloped by approximating cylinders,  change curve by click&drag","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["procedural","tunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 v;\n\nfloat bLightSource = 0.6;\nfloat ba = 0.4;\nvec4 mouse;\n\n\nfloat getRadius(){\n    if(iMouse.w<0.){\n        return 30.0;\n    }\n    else{\n    \treturn min(90.0, \n                   max(15.0, 30.0+60.0*(mouse.x-mouse.z)));\n    }\n}\n\n\nfloat pi(){\n \treturn radians(180.0);   \n}\n\nvec2 intersectCircle(vec2 cp, vec2 rView){\n            float cp_projected = dot(rView, cp);\n            return vec2(cp_projected, pow(cp_projected, 2.0)-dot(cp, cp));\n    }\n\n\n\nvec3 curvePosition(float theta){\n    \n    float radius = getRadius();\n    float thetaScaled = theta/(radius*sqrt(2.0));\n    return vec3(radius*cos(thetaScaled), radius*sin(thetaScaled), 2.0+theta/sqrt(2.0));\n    \n}\n\nvec3 curveTangent(float theta){\n    float radius = getRadius();\n    float thetaScaled = theta/(radius*sqrt(2.0));\n    return vec3(-sin(thetaScaled)/sqrt(2.0), cos(thetaScaled)/sqrt(2.0), 1.0/sqrt(2.0));\n}\n\nvec3 getLightSource(float theta){\n \treturn  curvePosition(theta)+vec3(0.0, 0.0, 0.97);\n}\n\n\n\n\nfloat diffuse(vec3 p, vec3 normal, float theta){\n    float bd = 0.0;\n    float dist;\n    float spacing = 10.0;\n    vec3 lightSource;\n    vec3 dirLight;\n    float theta0 = theta-mod(theta, spacing)-2.0*spacing;\n    for(int i = 0; i<5; i++){\n     \t   lightSource = getLightSource(theta0+float(i)*spacing);\n           dist = length(p-lightSource);\n           dirLight = normalize(lightSource-p);\n        bd+=bLightSource*max(0.0, dot(normal, dirLight))/pow(dist, 0.9);\n    }\n            \n            return bd;\n    }\n\nfloat getTheta0(vec4 mouse){\n    \n    if(iMouse.w<0.){\n        return 0.0;\n    }\n    else{\n    \treturn 20.0*length(mouse.xy-mouse.zw);\n    }\n}\n\nfloat getTheta(vec4 mouse){\n    return 5.0*iTime;\n}\n\n\nvec3 getCameraPosition(float theta){\n    return curvePosition(theta);\n    \n}\n\nmat3 getCameraCoordinates(float theta){\n\tvec3 vView = curveTangent(theta);\n    vec3 vLeft = normalize(cross(vView, vec3(0.0, 0.0, 1.0)));\n    vec3 vUp = cross(vLeft, vView);\n    return mat3(vView, vLeft, vUp);\n\n}\n\n\nmat3 cylinderCoordinates(float theta){\n \tfloat alpha = 0.1*pi()*sin(iTime);\n    vec3 principalAxis = curveTangent(theta);\n    vec3 minorAxis0 = normalize(cross(principalAxis, vec3(0.0, 0.0, 1.0)));\n    vec3 minorAxis1 = cross(minorAxis0, principalAxis);\n    \n    return mat3(minorAxis0, minorAxis1, principalAxis);\n}\n\nvec3 transform(vec3 argument, vec3 shift, mat3 trans){\n \t   return (argument+shift)*trans;\n}\n\nvec3 backTransform(vec3 argument, vec3 shift, mat3 trans){\n \t   return trans*argument+shift;\n}\n\nvec3 cLines(vec2 pSurface){\n    vec3 cBrick = vec3(0.8, 0.25, 0.33);\n    vec3 cSandStone = vec3(0.76, 0.57, 0.5);\n    vec2 pUnit = normalize(pSurface);\n    float alpha = 2.0*acos(pUnit.x)*sign(pUnit.y);\n    return mix(cBrick, cSandStone, sin(4.0*alpha)); \n}\n\nvec3 cLines(float theta){\n    vec3 cBrick = vec3(0.8, 0.25, 0.33);\n    vec3 cSandStone = vec3(0.76, 0.57, 0.5);\n    return mix(cBrick, cSandStone, sin(4.0*theta));\n}\n\nvec3 cLines(float theta, vec2 p){\n    vec3 cBrick = vec3(0.8, 0.25, 0.33);\n    vec3 cSandStone = vec3(0.76, 0.57, 0.5);\n    float n = 10.0;\n    float thetaHat = theta/(0.5*2.0*pi());\n    float alpha = 3.5*(acos(p.y)*sign(p.x)/pi());\n\treturn textureLod(iChannel0,\n                      vec2(thetaHat, alpha),\n                     0.5).xyz;\n    \n}\n\n\n\nfloat aCylinder(float theta, vec3 p, vec3 rView, float radius){\n    mat3 coordinates = cylinderCoordinates(theta);\n   \tvec3 center = curvePosition(theta);\n    \n    \n    \n    vec3 pHat = transform(p, -center, coordinates);\n    vec3 rHat = transform(rView, vec3(0.0), coordinates);\n    \n    vec2 sol = intersectCircle(-pHat.xy, normalize(rHat.xy));\n    float lxy = length(rHat.xy);\n    \n    \n    \n    return (sol.x+sqrt(sol.y+pow(radius, 2.0)))/lxy;\n    \n}\n\nvec4 cColor(float theta, vec3 p, float radius){\n\tvec3 cBrick = vec3(0.8, 0.25, 0.33);\n    \n    vec3 c = curvePosition(theta);\n    vec3 t = curveTangent(theta);\n    vec3 ax0 = cross(t, vec3(0.0, 0.0, 1.0));\n    vec3 ax1 = cross(ax0, t);\n    \n    \n    vec3 normal = p-c;\n    vec2 cNormal = vec2(dot(ax0, normal),\n                        dot(ax1, normal));\n    \n    normal = -normalize(normal-t*dot(t, normal));\n    float bd = diffuse(p, normal, theta);\n    return vec4((ba+bd)*cLines(theta, cNormal), 1.0);\n\n}\n\nvec4 cylinderApproximation(float theta, vec3 pFrag, vec3 rView, float h, float radius){\n \tfloat thetaStart = theta-mod(theta, h);\n    float theta1 = thetaStart;\n    float theta0;\n    float l = 0.0;\n    int iMax = 50;\n    int i = 1;\n    \n    vec3 c1;\n    vec3 t1;\n    \n    float a0 = 1.0;\n    float a1 = 0.0;\n    while(a0>a1 && i<iMax){\n        theta0 = theta1;\n        theta1 = thetaStart+float(i)*h;\n        \n        a0 = aCylinder(theta0, pFrag, rView, radius);\n        c1 = curvePosition(theta1);\n        t1 = curveTangent(theta1);\n     \ta1 = dot(c1-pFrag, t1)/dot(rView, t1);\n        \n        i = i+1;\n    }\n    \n    \n    if(i<iMax){\n     \tvec3 pSurface = pFrag + a0*rView;\n        float thetaMid = 0.5*(theta0+theta1);\n        float orient=10.0;\n        i = 0;\n        iMax = 40;\n        float tol = 0.005;\n        while(abs(orient)>tol && i<iMax){\n         \tc1 = curvePosition(thetaMid);\n            t1 = curveTangent(thetaMid);\n            \n            orient = dot(t1, pSurface-c1);\n            if(orient>0.0){\n                theta0 = thetaMid;\n            }\n            else{\n                theta1 = thetaMid;\n            }\n            thetaMid = 0.5*(theta0+theta1);\n            i+=1;  \n            \n        }\n        \n        return cColor(thetaMid, pSurface, radius); \n    }\n    return vec4(1.0, 0.0, 0.0, 1.0);\n    \n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n    mouse = iMouse/min(iResolution.x, iResolution.y);\n    \n    // set up camera\n    \n    \n    float theta = getTheta(mouse);\n    v = getCameraPosition(theta);\n    mat3 camCo = getCameraCoordinates(theta);\n    float dScreen = 2.5;\n    \n    //calculate fragment position in space\n    vec3 pFrag = v + camCo * vec3(dScreen, uv);\n    \n    vec3 rView = normalize(pFrag-v);\n    \n    vec4 cCylinder = cylinderApproximation(theta, pFrag, rView, 2.0, 1.0);\n    \n    \n    // Output to screen\n    fragColor = cCylinder;\n}","name":"Image","description":"","type":"image"}]}