{"ver":"0.1","info":{"id":"3tfXRn","date":"1561668707","viewed":534,"name":"Distortion/Glitch DB demo all fx","username":"Mogster","description":"distortion effect","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["distortion","distort","glitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nfloat downsample(float v, float res){\n    if (res == 0.0) return 0.0;\n    return floor(v * res) / res;\n}\n\nfloat interval(float timeInInterval, float percentOfInterval)\n{\n    float n = (percentOfInterval - 0.45) / 0.05; \n    return ((sign(sin(TWO_PI * iTime / timeInInterval) + percentOfInterval\n                 *(2.0 * (n - 1.0) / (n + 9.0)) ) + 1.0) / 2.0) * step(0.4, cos(rand(vec2(iTime))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 renderColor;\n    \n    // PARAMS\n    //------------------------------\n    // Color dispersion params\n    vec3 rgb = vec3(0.0, 0.8, .4); // dispersionRGB\n\n    \n    float randomDispersionEnable = 1.0; // Basically a bool ( 0.0 or 1.0 )\n    \n    float dispersionIntensity = 0.025; // Prev demo: 0.025\n    float dispersionInterval = 10.0;\n    float dispersionFreq = 2.5;\n    \n    // Horizontal Line Distortion Params\n    float randDistortIntensity = 0.5; // Prev demo: 0.5\n    float randDistortInterval = 5.0f;\n    float randDistortFreq = 0.25;\n    \n    float intensity = .0;\t// Prev demo: 0.2\n    float lineResolution = 5.0;\n    float lineSpeed = 5.0;\n    float lineShift = .01;\n\n\n    intensity += randDistortIntensity * interval(randDistortInterval, randDistortFreq / randDistortInterval);\n    \n    // Scan params\n    float activeScanIntensity = .03; // Prev demo: 0.03\n    float activeScanInterval = 7.0;\n    float activeScanFreq = 0.25;\n    \n    float passiveScanIntensity = 0.02; // Prev demo: 0.04\n    \n    // Glitch block params \n    float smallBlockEnable = 1.0; // bool\n    float smallBlockInterval = 3.0;\n    float smallBlockFreq = 0.3;\n    \n    float bigBlockEnable = 1.0; // bool\n    float bigBlockInterval = 11.0;\n    float bigBlockFreq = 1.0;\n    \n    // Noise\n    float noiseIntensity = 0.1; // Prev demo: 0.1\n    \n    //------------------------------------------------\n\n\t/////////////////////////////////////////////\n    \n    \n    // LOGIC\n    //--------------------------------\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Downsamplers\n    float yMod = downsample(uv.y, 50.0 * lineResolution);\n    float xMod = downsample(uv.x, 50.0 * lineResolution);\n    float yMod2 = uv.y * 250.0;\n    float xMod2 = uv.x * 250.0;\n    float yMod3 = downsample(uv.y, 50.0 * sin(iTime));\n    float xMod3 = downsample(uv.x, 50.0 * cos(iTime));\n    \n    float res = lineResolution * 50.0;\n    \n    // Glitch block and random scanning jitter\n    // -----------------------------\n    // Block 1 (small)\n    float blockTop = rand(vec2(floor(iTime * 9.0)));\n    float blockBottom = blockTop - clamp(rand(vec2(blockTop)), 0.01, 0.1);\n    float blockRight = rand(vec2(floor(iTime * 10.0)));\n    float blockLeft = blockRight - clamp(rand(vec2(blockRight)) / 10.0, 0.01, 0.1);\n    \n    float blockShift = step(blockBottom, uv.y) * step(uv.y, blockTop);\n    blockShift *= step(blockLeft, uv.x) * step(uv.x, blockRight) * step(1.0, smallBlockEnable) * interval(smallBlockInterval, smallBlockFreq / smallBlockInterval);\n    \n    uv.x = mix(uv.x, xMod3, step(1.0, blockShift));\n    uv.y = mix(uv.y, yMod3, step(1.0, blockShift));\n    \n\n    \n    // Random Scanning\n    float randomTop = rand(vec2(iTime));\n    float randomBottom = randomTop - 0.1;\n    float randomShift = step(randomBottom, uv.y) * step(uv.y, randomTop);\n    uv.x = mix(uv.x, uv.x + activeScanIntensity*rand(vec2(uv.x, iTime)) * interval(activeScanInterval, activeScanFreq / activeScanInterval) * cos(iTime), \n               step(1.0, randomShift));\n    \n\n\n    \n    // Horizontal line distortion\n    // --------------------------\n    float sineMod = sin((downsample(rand(vec2(yMod)) * TWO_PI , 50.0 * lineResolution) * 80.0 + iTime * rand(vec2(yMod, yMod)) * lineSpeed) );\n    float cosineMod = cos((downsample(rand(vec2(yMod)) * TWO_PI, 25. * lineResolution) * 80. + iTime * rand(vec2(yMod, yMod)) *lineSpeed) );\n    float cosineMod2 = cos((downsample(rand(vec2(xMod, yMod)) * TWO_PI, res) * 80. + iTime * rand(vec2(xMod, yMod)) *lineSpeed * 100.0) );\n\n    uv.x += (sineMod + cosineMod) * lineShift * intensity;\n\n\n \t// Glitch block\n    // ------------------------\n    // Block 2 (large)\n    float blockTop2 = clamp( rand(vec2(floor(iTime * 2.0)))+ 0.3, 0.4, 1.0);\n    float blockBottom2 = clamp(blockTop2 - rand(vec2(blockTop2)) - 0.2, 0.0, 0.6);\n    float blockRight2 = clamp(rand(vec2(floor(iTime * 2.0), iMouse.x)) + 0.2, 0.5, 0.8);\n    float blockLeft2 = clamp(blockRight2 - rand(vec2(blockRight2)) - 0.2, 0.2, 0.5);\n    float blockShift2 = step(blockBottom2, uv.y) * step(uv.y, blockTop2);\n    blockShift2 *= step(blockLeft2, uv.x) * step(uv.x, blockRight2) * step(1.0, bigBlockEnable)* interval(bigBlockInterval, bigBlockFreq / bigBlockInterval);\n    \n    uv.x = mix(uv.x, mix(uv.x, uv.x + 0.02 + (cosineMod2) * lineShift * intensity * 5.0, yMod3) + step(0.7, sin(iTime * TWO_PI / 4.0)) * 0.1, step(1.0, blockShift2));\n    uv.y = mix(uv.y, uv.y + 0.05, step(1.0, blockShift2));\n\n    \n    \n    float colorOffset =  mix(1.0, (rand(vec2(iTime))-0.5) * 2.0 * sin(iTime * TWO_PI), step(1.0, randomDispersionEnable)) * dispersionIntensity * interval(dispersionInterval, dispersionFreq / dispersionInterval);\n  \n    float scan = 1.0 - sin(uv.y * 6000.0 * rand(vec2(iTime))) * passiveScanIntensity;\n    \n    float noiseMod = (0.5 + 0.5 * noise(vec2(rand(vec2(iTime)), rand(vec2(iTime * 10.0))) * 100.0 + vec2(xMod2, yMod2) )) * noiseIntensity;\n        //(2.0 * atan(1.0 * iTime * iTime) / PI);0\n    \n    //float fade = (2.0 * atan(1.0 * iTime * iTime) / PI);\n    \n    ///////////////////////////////////////////////////////////////\n    \n    \n    renderColor = texture(iChannel0, uv);\n    \n\tvec4 red = texture(iChannel0, vec2(uv.x + colorOffset * rgb.x, uv.y)) * vec4(1.0, 0.0, 0.0,1.0);\n\tvec4 green = texture(iChannel0, vec2(uv.x + colorOffset * rgb.y, uv.y))\n\t\t * vec4(0.0, 1.00, 0.0,1.0);\n\tvec4 blue  = texture(iChannel0, vec2(uv.x + colorOffset * rgb.z, uv.y)) * vec4(0.0, 0.0, 1.0,1.0);\n    \n    \n    \n\n    // Output to screen\n    fragColor = ((renderColor + (red + green + blue)) / 2.0) * scan - noiseMod;\n}","name":"Image","description":"","type":"image"}]}