{"ver":"0.1","info":{"id":"fdGcR1","date":"1654365273","viewed":43,"name":"Theodo logo 3D shader","username":"fabriceb","description":"Theodo logo 3D shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["thedoo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define C(c) U.x-=.5; fragColor+= char(U,64+c)\n\n//GLOBAL VARIABLES\nfloat time;\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat map(vec3 p)\n{ \n  return sdPyramid(p, 0.7);\n\n}\n//RAY CAST / TRACE LOOP FUNCTION\nfloat raycast( vec3 ro, vec3 rd )\n{\n  float dist,res=0.;\n  for(int i=0;i<128;i++){ \n    dist=map(ro+rd*res); \n    if(dist<.0001||res>120.) break;\n    res+=dist;\n  }\n  if(res>120.) res=0.;\n  return res;\n}\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //UV.y from -.5 to .5 and UV.x from -.88 to .88 (aspect ratio broooh)\n  time=mod(iTime,62.82); //Modulo time to avoid sin glitch noise due to floating point precision\n  // CAMERA  \n  vec3 rayOrigin=vec3(cos(time*.2)*1.,1.2,sin(time*.2)*1.);\n  vec3 cameraForward=normalize(vec3(0)-rayOrigin);\n  vec3 cameraLeft=normalize(cross(cameraForward,vec3(0,1,0)));\n  vec3 cameraUp=normalize(cross(cameraLeft,cameraForward));\n  vec3 rayDirection=mat3(cameraLeft,cameraUp,cameraForward)*normalize(vec3(uv,.5)); \n  // LIGHT DIRECTION & BACKGROUND SETUP   \n  vec3 lightDirection=normalize(vec3(-.1,.4,-.3));  \n  vec3 backgroundColor=vec3(.1,.1,.1)-length(uv)*.1;\n  vec3 color=backgroundColor;\n  // TRACE AND GET RESULT FOR THIS PIXEL\n  float result=raycast(rayOrigin,rayDirection);\n  // IF WE HIT SOMETHING THEN DO SOME LIGHTING  \n  if(result>0.){ \n    vec3 hitPos=rayOrigin+rayDirection*result; // GET POSITION OF WHERE WE HIT\n    vec2 e=vec2(.00035,-.00035); // e=ESPILON = OFFSET NUMBER FOR NORMALS CALCULATION\n    vec3 normals=normalize(e.xyy*map(hitPos+e.xyy)+e.yyx*map(hitPos+e.yyx)+e.yxy*map(hitPos+e.yxy)+e.xxx*map(hitPos+e.xxx)); //CALCULATE NORMALS FOR WHERE WE HIT\n    vec3 albedo=vec3(.8,.8,.8); // SETUP BASE COLOUR\n    float diffuse=max(0.,dot(normals,lightDirection)); // SIMPLE DIFFUSE LIGHTING\n    float fresnel=pow(1.+dot(normals,rayDirection),4.); // FRESNEL = BACKGROUND REFLECTIONS ADDED TO EDGES OF GEOMETRY TO COMPOSITE IT BETTER IN THE SCENE\n    float specular=pow(max(dot(reflect(-lightDirection,normals),-rayDirection),0.),30.);// SPECULAR LIGHTING = Bright highlights, the shiny white flashy bit especially visible on metallic objects\n    float ao=clamp(map(hitPos+normals*.05)/.05,0.,1.); // AO = AMBIENT OCCLUSION = Small shadows where geometries touch due to ambient lighting\n    float sss=smoothstep(0.,1.,map(hitPos+lightDirection*.4)/.4);// SSS = Sub surface scattering = Light penetrating through edges of a translucent object, especially visible on candle wax or skin. Can be used as backlight too.\n    if(specular<1.) color=mix(specular+albedo*(ao+.2)*(diffuse+sss*.1),backgroundColor,fresnel); // Final lighting result made of all the above and then mixed with fresnel\n    color=mix(backgroundColor,color,exp(-.002*result*result*result)); // Add fog right at the end\n  }\n  \n  \n      fragColor = vec4(0.0);\n    fragCoord /= iResolution.y;\n    //fragCoord +=(40.0,0.0);\n    vec2 position = vec2(.6, 0.45);\n    float FontSize = 8.;\n    vec2 U = ( fragCoord - position)*64.0/FontSize;\n    C(20);C(8);C(5);C(15);C(4);C(15);\n    fragColor = max(\n        vec4(0.0,0.33*fragColor.x,0.66*fragColor.x,0.5),\n        vec4(pow(color,vec3(.4545)),1)\n    );// RETURN FINAL COLOR WITH GAMMA CORRECTION (pow(color,vec3(.4545)))\n}","name":"Image","description":"","type":"image"}]}