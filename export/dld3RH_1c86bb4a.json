{"ver":"0.1","info":{"id":"dld3RH","date":"1682218184","viewed":60,"name":"Shadertoy Raytracer","username":"int_45h","description":"Working on porting my raytracer to GLSL","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["e"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI      3.14159265359f\n#define _PI_180 0.01745329252f\n#define _180_PI 57.2957795131f\n\n#define NONE        0\n#define SPHERE      1\n#define TRIANGLE    2\n#define BOX         3\n\n#define FLOAT_EPSILON 0.00001f\n#define MAX_RAY_LEN 100000000.0f\n#define MAX_RAY_OBJECTS 128\n\n#define SAMPLES_PER_PIXEL 10\n#define MAX_BOUNCES 2\n\nvec3 hash32(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 random_in_unit_hemisphere(vec3 normal)\n{\n    vec3 ret = normalize(vec3(\n        hash32(vec2(iTime))\n    ));\n    return normal * ((dot(normal, ret)<FLOAT_EPSILON)?-1.f:1.f);\n}\n\nvoid swap(inout float a, inout float b)\n{\n    float tmp;\n    tmp = a;\n    a = b;\n    b = tmp;\n}\n\nstruct camera{float FOV, ar;};\nstruct light\n{\n    vec3    position;\n    float   intensity,\n            radius;\n    vec3    color;\n};\nstruct material\n{\n    vec3    diffuse;\n    float   roughness;\n};\nstruct ray_object\n{\n    int type;\n    material m;\n    vec3 position, normal;\n    float radius;\n    \n    vec3 v1, v2, v3;\n    vec3 lb, ub;\n};\nvec3 blinn_phong(vec3 O, vec3 D, float t, light L, inout ray_object obj)\n{\n    //return obj.normal*0.5f+0.5f;\n    vec3    lv = L.position - obj.position;\n    float    d = length(lv)-L.radius,\n            lf = L.intensity / (d*d);\n    vec3    kA = vec3(0.1,0,0),\n            H  = normalize((O+t*D)+lv);\n    float   kD = dot(obj.normal, normalize(lv))*lf,\n            kS = pow(clamp(dot(obj.normal,H),FLOAT_EPSILON,1.f),obj.m.roughness)*lf;\n            \n    return kA + obj.m.diffuse*kD + kS;\n}\nvec3 GOOCH(vec3 O, vec3 D, float t, light L, inout ray_object obj, vec3 warm, vec3 cool)\n{\n    //return obj.normal*0.5f+0.5f;\n    vec3    lv = L.position - obj.position;\n    float    d = length(lv)-L.radius,\n            lf = L.intensity / (d*d);\n    vec3    kA = vec3(0.1,0,0),\n            H  = normalize((O+t*D)+lv);\n    float   kD = dot(obj.normal, normalize(lv))*lf,\n            kS = pow(clamp(dot(obj.normal,H),FLOAT_EPSILON,1.f),obj.m.roughness)*lf;\n            \n    return kA + mix(cool, warm, kD*0.5+0.5) + kS;\n}\nvec3 brdf(vec3 O, vec3 D, float t, light L, inout ray_object obj){return blinn_phong(O,D,t,L,obj);}\nray_object new_empty()\n{\n    ray_object ro;\n    ro.type = NONE;\n    return ro;\n}\nray_object new_sphere(vec3 pos, float rad, material m)\n{\n    ray_object s;\n    \n    s.m = m;\n    s.type = SPHERE;\n    s.position = pos;\n    s.radius = rad;\n    \n    return s;\n}\nray_object new_triangle(vec3 pos, vec3 v1, vec3 v2, vec3 v3, material m)\n{\n    ray_object t;\n    \n    t.m = m;\n    t.type = TRIANGLE;\n    t.position = pos;\n    \n    t.v1 = v1 + pos;\n    t.v2 = v2 + pos;\n    t.v3 = v3 + pos;\n    \n    return t;\n}\nray_object new_box(vec3 pos, vec3 lb, vec3 ub, material m)\n{\n    ray_object b;\n    \n    b.m = m;\n    b.type = BOX;\n    b.lb = lb;\n    b.ub = ub;\n    \n    return b;\n}\n\nbool hit_sphere(vec3 O, vec3 D, inout float t, inout ray_object obj)\n{\n    vec3    O_p  = O - obj.position;\n    float   a    = 1.0f,\n            b    = dot(O_p,   D),\n            c    = dot(O_p, O_p) - obj.radius*obj.radius,\n            disc = b*b-a*c;\n\n    if (disc < FLOAT_EPSILON)\n        return false;\n    \n    float   sq_disc = sqrt(disc),\n            t0 = -b + sq_disc,\n            t1 = -b - sq_disc;\n    \n    if (t0 > FLOAT_EPSILON || t1 > FLOAT_EPSILON)\n    {\n        if (t0 > t1) swap(t0, t1);\n        t = t0;\n        \n        obj.normal  = ((O+t*D)-obj.position)/obj.radius;\n        //obj.normal *= (dot(D,obj.normal)>FLOAT_EPSILON)?1.:-1.;\n        return true;\n    }\n    \n    return false;\n}\nbool hit_triangle(vec3 O, vec3 D, inout float t, inout ray_object obj)\n{\n    vec3    T   = O - obj.v1,\n            E1  = obj.v3 - obj.v1,\n            E2  = obj.v2 - obj.v1,\n            P   = cross(D, E2),\n            Q   = cross(T, E1);\n    float   det = dot(P, E1);\n    \n    if (abs(det) < FLOAT_EPSILON)\n        return false;\n    \n    float   inv_det = 1.f/det,\n            u = dot(P,  T)*inv_det,\n            v = dot(Q,  D)*inv_det;\n    t = dot(Q, E2)*inv_det;\n    \n    if (u < FLOAT_EPSILON || u > 1.f)   return false;\n    if (v < FLOAT_EPSILON || u+v > 1.f) return false;\n    if (t < FLOAT_EPSILON)              return false;\n    \n    obj.normal = normalize(cross(E1, E2));\n    \n    return true;\n}\nbool hit(vec3 O, vec3 D, inout float t, inout ray_object obj)\n{\n    switch (obj.type)\n    {\n        case SPHERE:   return hit_sphere(O, D, t, obj);\n        case TRIANGLE: return hit_triangle(O, D, t, obj);\n    }\n    return false;\n}\n\nstruct scene\n{\n    ray_object objects[MAX_RAY_OBJECTS];\n    int size;\n    light lights[MAX_RAY_OBJECTS];\n    int light_size;\n};\nscene new_scene()\n{\n    scene s;\n    s.size = 0;\n    s.light_size = 0;\n    return s;\n}\nvoid push_back(out scene s, ray_object r) {s.objects[s.size++]=r;}\nvoid push_light_back(out scene s, light l){s.lights[s.light_size++]=l;}\n\nvec3 default_color(vec3 O, vec3 D, float t)\n{\n    t = D.y*0.5f+0.5f;\n    return mix\n    (\n        vec3(1.,1.,1.),\n        vec3(0.6, 0.9, 1.0),\n        t\n    );\n}\n\nscene s; // GLOBAL SCENE\nvec3 trace_ray(vec3 O, vec3 D, float t)\n{\n    ray_object closest_obj = new_empty();\n    float closest_hit = MAX_RAY_LEN;\n    bool hit_thing = false;\n    \n    int  b = 1;\n    vec3 color  = default_color(O, D, t);\n    \n    for (b; b < MAX_BOUNCES+1; b++)\n    {\n        // Get closest object\n        for (int i = 0; i < s.size; i++)\n        {\n            if (!hit(O, D, t, s.objects[i]))\n                continue;\n        \n            if (abs(t) < FLOAT_EPSILON)\n                continue;\n                \n            hit_thing = true;\n        \n            if (t < closest_hit)\n            {\n                closest_hit = t;\n                closest_obj = s.objects[i];\n            }\n        }\n        \n        // Break out early if there're no hits\n        if (!hit_thing)\n            break;\n        \n        // I HAVE NO BETTER WAY I CAN THINK OF TO DO THIS\n        // Aggregate the color from all light sources\n        for (int i = 0; i < s.light_size; i++)\n        {\n            color += brdf(O,D,t,s.lights[i],closest_obj);\n        }\n        // Pick a new direction and roll with it\n        vec3 offset = random_in_unit_hemisphere(closest_obj.normal);\n        \n        O = O+t*D;\n        D = reflect(D, closest_obj.normal);\n        t = MAX_RAY_LEN;\n    }\n    \n    color /= float(b);\n    \n    return color;//(hit_thing) ? brdf(O,D,t,s.lights[0],closest_obj) : default_color(O, D, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    camera c = camera\n    (\n        _PI_180*120.f,\n        iResolution.y/iResolution.x\n    );\n    s = new_scene();\n    material ma = material(\n        vec3(1,0,0),\n        200.f\n    ),\n    mb = material(\n        vec3(0,1,0),\n        200.f\n    ),\n    mc = material(\n        vec3(0,0,1),\n        200.f\n    );\n    \n    push_back(s, new_sphere(vec3( 0,0,4.*cos(iTime)), 1.f, ma));\n    push_back(s, new_sphere(vec3(-3,0,4), 1.f, mb));\n    push_back(s, new_sphere(vec3( 3,0,4), 1.f, mc));\n    \n    push_light_back(s, light(\n        vec3(5,5,-2),\n        10.f,\n        6.f,\n        vec3(1)\n    ));\n    \n    float tan_fov = tan(c.FOV*.5f);\n    \n    vec3 col = vec3(0);\n    int spp = 1;\n    float scatter = 1.f/200.f;\n    \n    for (spp; spp < SAMPLES_PER_PIXEL+1; spp++)\n    {\n        vec2    offset = clamp(hash32(fragCoord+iTime+float(spp)).xy,vec2(-1),vec2(1)),\n                uv = (fragCoord + offset) / iResolution.xy;\n        \n        col += trace_ray\n        (\n            vec3(0.f),\n            normalize(vec3\n            (\n                 (uv.x*2.f - 1.f)*tan_fov,\n                 (uv.y*2.f - 1.f)*tan_fov*c.ar,\n                 1.f\n            )),\n            MAX_RAY_LEN\n        );\n    }\n    col /= float(spp-1);\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}