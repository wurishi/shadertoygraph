{"ver":"0.1","info":{"id":"3sGyWz","date":"1602553784","viewed":705,"name":"Turing Machine Interpreter","username":"mhnewman","description":"Have you ever wanted to program using Shadertoy? Well now you can! With interactive editing!\nSample machine is 4-state Busy Beaver see: wikipedia.org/wiki/Busy_beaver\nPlease do not attempt to implement Shadertoy as a Turing machine within this shader.\n","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["beaver","turing","machine","interpreter","programming","busy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n  Click on the machine to change it!\n\n\nCARD DESCRIPTION\n                           _________\n                          |         |\n  Current state label --> |    B    |\n                          |         |\n  Scanned symbol = 0 ---> | 1  >  C |\n                          |         |\n  Scanned symbol = 1 ---> | 0  <  A |\n                          |_________|\n\n                            ^  ^  ^\n                            |  |  |\n         Print symbol ------'  |  |\n                               |  |\n         Move tape direction --'  |\n                                  |\n         Next state label --------'\n\n\nTAPE DISPLAY\n\n  Current machine state -->       B\n                                  |\n  Position on tape ------->       v\n  Local tape display -----> 0 1 1 0 1 0 0\n\n  Global tape display ---->     || |\n\n\nNOTES\n\n  The Imager shader is used entirely for rendering the display, all logic is in Buf A.\n\n*/\n\nfloat drawLetter(vec2 pos, float letter) {\n    pos += vec2(mod(letter, 16.0), 15.0 - floor(letter / 16.0));\n    pos /= 16.0;\n    return texture(iChannel1, pos).r;\n}\n\nfloat stateLabel(float state) {\n    if (state == 0.0) return halt;\n    return label + state;\n}\n\nvec4 button(vec4 fragColor, float buttonID) {\n    vec4 buttonState = BufA(1.0, 4.0);\n    vec3 color = vec3(0.0, 0.15, 0.3);\n    if (buttonState.r == buttonID) {\n\t    if (buttonState.g == buttonID)\n            color = vec3(0.0, 0.3, 0.6);\n        else\n            color = vec3(0.2, 0.25, 0.4);\n    }\n    return 1.0 - (1.0 - vec4(color, 0.0)) * (1.0 - fragColor);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos = fragCoord - vec2(0.0, 0.5 * iResolution.y);\n\tpos = 35.0 * pos / iResolution.x;\n    pos.y *= letterWidth;\n    vec2 grid = floor(pos);\n    \n    vec4 main = BufA(0.0, 0.0);\n    vec4 curr = BufA(1.0, 0.0);\n    vec4 anim = BufA(0.0, 3.0);\n    float t = 4.0 * anim.a;\n    \n    // Red step indicator highlight\n    vec2 highlight;\n    if (t < 1.0) {\n        vec2 prev = vec2(4.0 * anim.b, 2.0);\n        vec2 next = vec2(4.0 * anim.b - 1.0, 1.0 - anim.r);\n        highlight = mix(prev, next, smoothstep(0.0, 1.0, t));\n    } else if (t < 2.0) {\n        vec2 prev = vec2(4.0 * anim.b - 1.0, 1.0 - anim.r);\n        vec2 next = vec2(4.0 * anim.b, 1.0 - anim.r);\n        highlight = mix(prev, next, smoothstep(1.0, 2.0, t));\n    } else if (t < 3.0 || curr.b < 0.5) {\n        vec2 prev = vec2(4.0 * anim.b, 1.0 - anim.r);\n        vec2 next = vec2(4.0 * anim.b + 1.0, 1.0 - anim.r);\n        highlight = mix(prev, next, smoothstep(2.0, 3.0, t));\n    } else {\n        vec2 prev = vec2(4.0 * anim.b + 1.0, 1.0 - anim.r);\n        vec2 next = vec2(4.0 * curr.b, 2.0);\n        highlight = mix(prev, next, smoothstep(3.0, 4.0, t));\n    }\n    float glow = smoothstep(0.9, 0.2, length(highlight - pos + 0.5));\n    fragColor = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(0.9, 0.0, 0.0, 1.0), glow);\n\n    // White flash in the output display to highlight changes\n    if (t < 1.0) {\n        glow = 0.0;\n    } else if (t < 3.0) {\n        highlight = vec2(17.0, -4.0);\n        glow = smoothstep(2.0, 1.0, t);\n    } else {\n        highlight = vec2(17.0, -2.0);\n        glow = smoothstep(4.0, 3.0, t);\n    }\n    glow *= smoothstep(0.9, 0.2, length(highlight - pos + 0.5));\n    fragColor = mix(fragColor, vec4(1.0), glow);\n\n    pos -= grid;\n    \n    // Global tape display\n    float letter = space;\n    if (grid.y == -5.0) {\n        float x = fragCoord.x - 0.5;\n        vec4 color;\n        if (x == curr.g - anim.g * step(t, 2.0)) {\n            color = vec4(1.0, 0.0, 0.0, 1.0);\n        } else {\n            vec4 tape = BufA(x, 2.0);\n            color = vec4(mix(0.2, 0.8, tape.r));\n        }\n        fragColor = mix(fragColor, color, pow(4.0 * pos.y * (1.0 - pos.y), 0.5));\n        return;\n    }\n    \n    if (grid.y == -4.0) {\n        // Local tape display\n        if (grid.x == 17.0 && t < 1.0) {\n            letter = anim.r > 0.5 ? one : zero;\n        } else {\n            pos += grid - anim.g * vec2(smoothstep(2.5, 1.5, t), 0.0);\n            grid = floor(pos);\n            pos -= grid;\n            vec4 tape = BufA(curr.g + grid.x - 17.0, 2.0);\n            letter = tape.r > 0.5 ? one : zero;\n        }\n    } else if (grid.y == 4.0) {\n        // Top row buttons\n        if (grid.x >= 1.0 && grid.x < 10.0) {\n            letter = addState[int(grid.x - 1.0)];\n            fragColor = button(fragColor, 1.0);\n        } else if (grid.x >= 12.0 && grid.x < 24.0) {\n            letter = deleteState[int(grid.x - 12.0)];\n            fragColor = button(fragColor, 2.0);\n        } else if (grid.x >= 26.0 && grid.x < 33.0) {\n            letter = restart[int(grid.x - 26.0)];\n            fragColor = button(fragColor, 3.0);\n        }\n    } else if (grid.y == -2.0 && grid.x >= 1.0 && grid.x < 16.0) {\n        // Speed indicator\n        if (grid.x < 6.0) {\n            letter = speed[int(grid.x - 1.0)];\n            fragColor = button(fragColor, 4.0);\n        } else if (grid.x < main.g + 7.0) {\n            letter = forward;\n        }\n    } else if (grid.y > -1.0 && grid.x > 2.0) {\n        // State cards\n        float col = grid.x + 1.0;\n        float state = floor(col / 4.0);\n        col -= 4.0 * state;\n        if (state <= main.r) {\n            vec4 card = BufA(state, 1.0);\n            if (grid.y == 2.0 && col == 1.0) {\n                letter = stateLabel(state);\n            } else if (grid.y == 1.0 && col == 0.0) {\n                letter = mod(card.r, 2.0) > 0.5 ? one : zero;\n                fragColor = button(fragColor, 6.0 * state + 0.0);\n            } else if (grid.y == 1.0 && col == 1.0) {\n                letter = mod(card.g, 2.0) > 0.5 ? right : left;\n                fragColor = button(fragColor, 6.0 * state + 1.0);\n            } else if (grid.y == 1.0 && col == 2.0) {\n                letter = stateLabel(card.b);\n                fragColor = button(fragColor, 6.0 * state + 2.0);\n            } else if (grid.y == 0.0 && col == 0.0) {\n                letter = card.r > 1.5 ? one : zero;\n                fragColor = button(fragColor, 6.0 * state + 3.0);\n            } else if (grid.y == 0.0 && col == 1.0) {\n                letter = card.g > 1.5 ? right : left;\n                fragColor = button(fragColor, 6.0 * state + 4.0);\n            } else if (grid.y == 0.0 && col == 2.0) {\n                letter = stateLabel(card.a);\n                fragColor = button(fragColor, 6.0 * state + 5.0);\n            }\n        }\n    } else if (grid.y == -2.0 && grid.x > 27.5 && grid.x < 33.5) {\n        // Step counter\n        float counter = curr.r;\n        for (float x = 33.0; x > 27.5; x -= 1.0) {\n            if (grid.x == x && counter > 0.5)\n                letter = zero + mod(counter, 10.0);\n            counter = floor(counter / 10.0);\n        }\n    } else {\n        // Static displays\n        if (grid == vec2(1.0, 0.0))\n            letter = one;\n        else if (grid == vec2(1.0, 1.0))\n            letter = zero;\n        else if (grid == vec2(17.0, -3.0))\n            letter = head;\n        else if (grid == vec2(17.0, -2.0))\n            letter = stateLabel(mix(anim.b, curr.b, step(3.0, t)));\n    }\n    \n    float mask = smoothstep(1.0, 2.0, pos.x * (1.0 - pos.x) *\n                                      pos.y * (1.0 - pos.y) * iResolution.x * 0.25);\n    pos.x = 0.5 + letterWidth * (pos.x - 0.5);\n    fragColor = mix(fragColor, vec4(1.0), mask * drawLetter(pos, letter));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float letterWidth = 0.6;\n\n// Character codes\nconst float head = 19.0;\nconst float space = 32.0;\nconst float zero = 48.0;\nconst float one = 49.0;\nconst float label = 64.0;\nconst float left = 2.0; //76.0;\nconst float right = 5.0; //82.0;\nconst float halt = 164.0;\nconst float forward = 5.0;\nconst float[] addState = float[](65.0, 100.0, 100.0, 32.0, 115.0, 116.0, 97.0, 116.0, 101.0);\nconst float[] deleteState = float[](68.0, 101.0, 108.0, 101.0, 116.0, 101.0, 32.0, 115.0, 116.0, 97.0, 116.0, 101.0);\nconst float[] restart = float[](82.0, 101.0, 115.0, 116.0, 97.0, 114.0, 116.0);\nconst float[] speed = float[](83.0, 112.0, 101.0, 101.0, 100.0);\n\n#define BufA(x, y) texture(iChannel0, (vec2(x, y) + 0.5) / iResolution.xy)\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\nBUFFER A PIXEL USAGE:\n\n  (0, 0) Main state:\n    .r := Number of states\n    .g := Speed\n\n  (1, 0) Current step state:\n    .r := Current step number\n    .g := Current position\n    .b := Current state\n    .a := Time in this step\n\n\n  (1+, 1) State cards:\n    .r := Output symbol (0-input) + 2 * (1-input)\n    .g := Move direction (0-input) + 2 * (1-input)\n    .b := Transition state (0-input)\n    .a := Transition state (1-input)\n\n  (X, 2) Tape:\n    .r := Value\n\n  (0, 3) Animation:\n    .r := Previous tape value\n    .g := Move direction\n    .b := Previous state\n    .a := Animation timer = main.a / secondsPerStep\n\n  (0, 4) Mouse from last frame\n\n  (1, 4) Button state\n    .r := Button ID for mouse down\n    .g := Button ID for current mouse hover\n\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n\n    vec2 p = fragCoord - 0.5;\n    vec4 main = BufA(0.0, 0.0);\n    vec4 curr = BufA(1.0, 0.0);\n    vec4 mouse = BufA(0.0, 4.0);\n    \n    float secondsPerStep = pow(0.25, main.g - 1.0);\n    \n    if (iFrame == 0) {\n        // Initial setup\n        \n        fragColor = vec4(0.0);\n        mouse = vec4(0.0);\n        \n        /*\n        // 2-state busy beaver\n        main = vec4(2.0, 1.0, 0.0, 0.0);\n        if (p == vec2(1.0, 1.0)) fragColor = vec4(3.0, 1.0, 2.0, 2.0);\n        if (p == vec2(2.0, 1.0)) fragColor = vec4(3.0, 2.0, 1.0, 0.0);\n        \n        // 3-state busy beaver\n        main = vec4(3.0, 1.0, 0.0, 0.0);\n        if (p == vec2(1.0, 1.0)) fragColor = vec4(3.0, 3.0, 2.0, 0.0);\n        if (p == vec2(2.0, 1.0)) fragColor = vec4(2.0, 3.0, 3.0, 2.0);\n        if (p == vec2(3.0, 1.0)) fragColor = vec4(3.0, 0.0, 3.0, 1.0);\n        */\n        \n        // 4-state busy beaver\n        main = vec4(4.0, 1.0, 0.0, 0.0);\n        if (p == vec2(1.0, 1.0)) fragColor = vec4(3.0, 1.0, 2.0, 2.0);\n        if (p == vec2(2.0, 1.0)) fragColor = vec4(1.0, 0.0, 1.0, 3.0);\n        if (p == vec2(3.0, 1.0)) fragColor = vec4(3.0, 1.0, 0.0, 4.0);\n        if (p == vec2(4.0, 1.0)) fragColor = vec4(1.0, 3.0, 4.0, 1.0);\n        \n        if (p == vec2(0.0, 0.0)) fragColor = main;\n        if (p == vec2(1.0, 0.0)) fragColor = vec4(0.0, floor(0.5 * iResolution.x), 1.0, secondsPerStep);;\n        if (p == vec2(0.0, 3.0)) fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n        if (p == vec2(0.0, 4.0)) fragColor = mouse;\n    } else if (p.y < 4.0) {\n        // Increment time\n        curr.a += iTimeDelta;\n        if (curr.a > secondsPerStep && curr.b > 0.5) {            \n            curr.a = mod(curr.a, secondsPerStep);\n            \n/*** Turing machine logic ***/\n            vec4 tape = BufA(curr.g, 2.0);\n            vec4 card = BufA(curr.b, 1.0);\n            \n            float dir = 1.0 - 2.0 * mix(mod(card.g, 2.0), floor(0.5 * card.g), tape.r);\n            \n            if (p == vec2(1.0, 0.0)) {\n                curr.r += 1.0;\n                curr.g += dir;\n                curr.b = mix(card.b, card.a, tape.r);\n                fragColor = curr;\n            } else if (p == vec2(curr.g, 2.0)) {\n                fragColor.r = mix(mod(card.r, 2.0), floor(0.5 * card.r), tape.r);\n/*** That's it! That's the whole interpreter ***/\n\n            } else if (p == vec2(0.0, 3.0)) {\n                // Record state transition for rendering\n                fragColor = vec4(tape.r, dir, curr.b, curr.a / secondsPerStep);\n            }\n\n        // Update animation times\n        } else if (p == vec2(1.0, 0.0)) {\n            fragColor.a = curr.a;\n        } else if (p == vec2(0.0, 3.0)) {\n            fragColor.a = curr.a / secondsPerStep;\n        }\n    }\n    \n    // Get mouse press events\n    bool mouseDown = iMouse.z > mouse.z;\n    bool mouseUp = iMouse.z < mouse.z;\n    if (p == vec2(0.0, 4.0))\n        fragColor = iMouse;\n    \n    vec2 pos = iMouse.xy - vec2(0.0, 0.5 * iResolution.y);\n\tpos = 35.0 * pos / iResolution.x;\n    pos.y *= letterWidth;\n    vec2 grid = floor(pos);\n    \n    // Determine which button the mouse is currently over\n    float buttonID = 0.0;\n    if (grid.y == 4.0) {\n        if (grid.x >= 1.0 && grid.x < 10.0)\n            buttonID = 1.0;\n        else if (grid.x >= 12.0 && grid.x < 24.0)\n            buttonID = 2.0;\n        else if (grid.x >= 26.0 && grid.x < 33.0)\n            buttonID = 3.0;\n    } else if (grid.y == -2.0 && grid.x >= 1.0 && grid.x < 6.0) {\n        buttonID = 4.0;\n    } else {\n        float col = grid.x + 1.0;\n        float state = floor(col / 4.0);\n        col -= 4.0 * state;\n        if (state <= main.r) {\n            if (grid.y == 1.0 && col == 0.0)\n                buttonID = 6.0 * state + 0.0;\n            else if (grid.y == 1.0 && col == 1.0)\n                buttonID = 6.0 * state + 1.0;\n            else if (grid.y == 1.0 && col == 2.0)\n                buttonID = 6.0 * state + 2.0;\n            else if (grid.y == 0.0 && col == 0.0)\n                buttonID = 6.0 * state + 3.0;\n            else if (grid.y == 0.0 && col == 1.0)\n                buttonID = 6.0 * state + 4.0;\n            else if (grid.y == 0.0 && col == 2.0)\n                buttonID = 6.0 * state + 5.0;\n        }\n    }\n    \n    // Execute button actions\n    if (mouseUp && buttonID > 0.0 && (BufA(1.0, 4.0).r == buttonID)) {\n        if (buttonID == 1.0) {\n            // Add state\n            if (p == vec2(0.0, 0.0)) fragColor.r = min(main.r + 1.0, 8.0);\n        } else if (buttonID == 2.0) {\n            // Delete state\n            float stateCount = max(main.r - 1.0, 1.0);\n            if (p == vec2(0.0, 0.0)) {\n            \tfragColor.r = stateCount;\n                fragColor.b = min(fragColor.b, stateCount);\n            }\n            else if (p.y == 1.0 && p.x <= stateCount) {\n                fragColor.a = mod(fragColor.a, stateCount + 1.0);\n                fragColor.b = mod(fragColor.b, stateCount + 1.0);\n            }\n        } else if (buttonID == 3.0) {\n            // Restart\n            if (p == vec2(1.0, 0.0)) fragColor = vec4(0.0, floor(0.5 * iResolution.x), 1.0, secondsPerStep);\n            else if (p == vec2(0.0, 3.0)) fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n            else if (p.y > 1.5) fragColor = vec4(0.0);\n        } else if (buttonID == 4.0) {\n            // Speed\n            if (p == vec2(0.0, 0.0)) fragColor.g = mod(main.g + 1.0, 5.0);\n        } else {\n            float state = floor(buttonID / 6.0);\n            if (p == vec2(state, 1.0)) {\n                // Change state card\n                float id = buttonID - 6.0 * state;\n                if (id == 0.0) {\n                    fragColor.r = mod(1.0 - fragColor.r, 4.0);\n                } else if (id == 1.0) {\n                    fragColor.g = mod(1.0 - fragColor.g, 4.0);\n                } else if (id == 2.0) {\n                    fragColor.b = mod(fragColor.b + 1.0, main.r + 1.0);\n                } else if (id == 3.0) {\n                    fragColor.r = mod(fragColor.r + 2.0, 4.0);\n                } else if (id == 4.0) {\n                    fragColor.g = mod(fragColor.g + 2.0, 4.0);\n                } else if (id == 5.0) {\n                    fragColor.a = mod(fragColor.a + 1.0, main.r + 1.0);\n                }\n            }\n        }\n    }\n    \n    // Record button state for rendering\n    if (p == vec2(1.0, 4.0)) {\n        if (mouseDown)\n            fragColor.r = buttonID;\n        else if (mouseUp)\n            fragColor.r = 0.0;\n        fragColor.g = buttonID;\n    }\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}