{"ver":"0.1","info":{"id":"stVfDw","date":"1664660499","viewed":144,"name":"interlocked cube tori","username":"jt","description":"Tiling space with interlocked loops (gaps filled up with cuboids).\nAnimation shows different parts of the structure:\n1. loops, 2. outer grid, 3. inner grid, 4. combined, 5. offset loops, 6. offset outer grid, 7. offset inner grid, 8. offset combined\nall.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","raycasting","torus","cube","voxel","loop","honeycomb","dda","tiling","tesselation","textured","spacefilling","torii","interlocked","bcc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/stVfDw interlocked cube tori, 2022 by Jakob Thomsen\n// based on https://www.shadertoy.com/view/7dK3D3 Branchless Voxel Raycasting Tex\n// using DDA from https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4\n// (with loop optimization by kzy), based on http://lodev.org/cgtutor/raycasting.html\n// 3d-texture on voxels addon by jt\n\n// Tiling space with interlocked loops (colored), gaps filled up with cuboids (grey).\n// (This structure refines https://www.shadertoy.com/view/styfRG interlocked grids.)\n// Animation shows different parts of the structure:\n//     0. loops\n//     1. outer grid\n//     2. inner grid\n//     3. combined\n//     4. offset loops\n//     5. offset outer grid\n//     6. offset inner grid\n//     7. offset combined\n//     9-11 and 12 to 15 repeats steps for grid and offset grid combined.\n\n// Towards filling space symmetrically (non-chiral) with interlocked bricks.\n\n// tags: 3d, raycasting, voxel, dda, textured, interlocked, loop, torus, torii, cube, honeycomb, tiling, tesselation, space-filling, BCC\n\n#define REPETITIONS 2u\n\n#define BLACK 0u\n#define RED (BLACK + 1u)\n#define GREEN (RED + 1u)\n#define YELLOW (GREEN + 1u)\n#define BLUE (YELLOW + 1u)\n#define MAGENTA (BLUE + 1u)\n#define CYAN (MAGENTA + 1u)\n#define WHITE (CYAN + 1u)\n#define COLORS (WHITE + 1u)\n\nvec3 palette(uint i)\n{\n    return vec3((i >> 0u) & 1u, (i >> 1u) & 1u, (i >> 2u) & 1u);\n}\n\n// two half-patterns fit together to fill one cube exactly in a body-centred cubic (BCC) lattice pattern.\nuint half_pattern(ivec3 i, uint stage)\n{\n    i = abs(i); // global mirror-symmetry (to make sure \"mod\" works for negative numbers)\n    i -= 6*(i / 6); // mod 6\n    i -= 3; // move zero\n    i = abs(i); // local mirror-symmetry\n\n    if(stage == 0u || stage == 3u)\n    {\n        // loops / tori\n        if(i.z == 3 && max(i.y, i.x) == 2) return BLUE;\n        if(i.y == 3 && max(i.x, i.z) == 2) return GREEN;\n        if(i.x == 3 && max(i.z, i.y) == 2) return RED;\n    }\n    \n    if(stage == 1u || stage == 3u)\n    {\n        // outer grid\n        //if(i.x == 3 && i.y == 3 && i.z == 3) return WHITE; // omit small cubes for better visibility (keep cuboids distinct)\n        if(i.x == 3 && i.y == 3 && i.z < 3) return WHITE;\n        if(i.y == 3 && i.z == 3 && i.x < 3) return WHITE;\n        if(i.z == 3 && i.x == 3 && i.y < 3) return WHITE;\n    }\n    \n    if(stage == 2u || stage == 3u)\n    {\n        // inner grid\n        //if(i.x == 2 && i.y == 2 && i.z == 2 ) return WHITE; // omit small cubes for better visibility (keep cuboids distinct)\n        if(i.x == 2 && i.y == 2 && i.z < 2 ) return WHITE;\n        if(i.y == 2 && i.z == 2 && i.x < 2 ) return WHITE;\n        if(i.z == 2 && i.x == 2 && i.y < 2 ) return WHITE;\n    }\n\n    return 0u;\n}\n\n// Fills one unit cell (composed of 6^3 voxels).\nuint pattern(ivec3 i, uint stage)\n{\n    // NOTE: using bit-operators rather than modulo because of % bugs on windows\n\n    stage = stage & 15u;\n\n    if(stage < 4u || stage >= 8u)\n    {\n        uint c = half_pattern(i, stage & 3u);\n        if(c > 0u)\n            return c;\n    }\n\n    if(stage >= 4u || stage >= 8u)\n    {\n        uint c = half_pattern(i-3, stage & 3u);\n        if(c == WHITE) // HACK: keep color to avoid transparency when inverting colors below\n            return c;\n        if(c > 0u)\n            return WHITE - c;\n    }\n\n    return 0u;\n}\n\n#define PI 3.1415926\n\nfloat checker(vec3 p)\n{\n    //return step(0.5, length(1.0 - abs(2.0 * fract(p) - 1.0))); // dots\n    return step(0.0, sin(PI * p.x + PI/2.0)*sin(PI *p.y + PI/2.0)*sin(PI *p.z + PI/2.0));\n    //return step(0.0, sin(p.x)*sin(p.y)*sin(p.z));\n}\n\nmat2 rotate(float t)\n{\n    return mat2(vec2(cos(t), sin(t)), vec2(-sin(t), cos(t)));\n}\n\nfloat sdSphere(vec3 p, float d)\n{ \n    return length(p) - d;\n} \n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nbool getVoxel(ivec3 c, uint stage)\n{\n    if(any(greaterThan(abs(c), ivec3(REPETITIONS * 6u)))) return false;\n    return pattern(c, stage) > 0u;\n}\n\n// \"The raycasting code is somewhat based around a 2D raycasting toutorial found here: \n//  http://lodev.org/cgtutor/raycasting.html\" (fb39ca4)\n\n#define MAX_RAY_STEPS (24u * (1u << REPETITIONS))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint stage = uint(floor(iTime / 5.0));\n\n    vec2 screenPos = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    screenPos.x *= iResolution.x / iResolution.y;\n    vec3 rayDir = vec3(screenPos.x, screenPos.y, 2.0);\n    vec3 rayPos = vec3(0.0, 0.0, -float(REPETITIONS * 16u));\n\n    float mx = 2.0 * PI * float(-iMouse.x) / float(iResolution.x);\n    float my = PI * float(-iMouse.y) / float(iResolution.y);\n    mx = (iMouse.x > 10.0) ? mx : 2.0 * PI * fract(iTime * 0.025);\n    my = (iMouse.y > 10.0) ? my : PI / 2.0;\n\n    mat2 S = mat2(vec2(cos(my), sin(my)), vec2(-sin(my), cos(my)));\n    rayPos.yz = S * rayPos.yz;\n    rayDir.yz = S * rayDir.yz;\n\n    mat2 R = mat2(vec2(cos(mx), sin(mx)), vec2(-sin(mx), cos(mx)));\n    rayPos.xy = R * rayPos.xy;\n    rayDir.xy = R * rayDir.xy;\n    \n    rayDir = normalize(rayDir);\n\n    ivec3 mapPos = ivec3(floor(rayPos + 0.));\n\n    vec3 color = vec3(1.0);\n    vec3 sideDist;\n    bvec3 mask;\n    // core of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4 (somewhat reduced)\n    vec3 deltaDist;\n    {\n        deltaDist = 1.0 / abs(rayDir);\n        ivec3 rayStep = ivec3(sign(rayDir));\n        sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\n        for (uint i = 0u; i < MAX_RAY_STEPS; i++)\n        {\n            if (getVoxel(mapPos, stage)) break; // forked shader used continue here\n\n            //Thanks kzy for the suggestion!\n            mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n            sideDist += vec3(mask) * deltaDist;\n            mapPos += ivec3(vec3(mask)) * rayStep;\n        }\n\n        color *= mask.x ? vec3(0.25) : mask.y ? vec3(0.5) : mask.z ? vec3(0.75) : vec3(0.0);\n    }\n\n    fragColor = vec4(0);\n    \n    if(any(greaterThan(abs(mapPos), ivec3(REPETITIONS * 6u))))\n        return;\n\n    color *= palette(pattern(mapPos, stage));\n\n    // jt's 3d-texture addon recovering distance & subvoxel intersection-position of ray \n    // as described in https://lodev.org/cgtutor/raycasting.html (see \"perpWallDist\" there)\n    //float d = (mask.x ? sideDist.x - deltaDist.x : mask.y ? sideDist.y - deltaDist.y : mask.z ? sideDist.z - deltaDist.z : 0.0) / length(rayDir);\n    //float d = length(vec3(mask) * (sideDist - deltaDist)) / length(rayDir); // rayDir not normalized\n    float d = length(vec3(mask) * (sideDist - deltaDist)); // rayDir normalized\n\n    vec3 dst = rayPos + rayDir * d;    \n\n    //color *= smoothstep(0.6,0.61, distance(dst, vec3(mapPos)+0.5));\n    color += 0.05*(1.0-smoothstep(0.6,0.61, distance(dst, vec3(mapPos)+0.5)));\n\n    vec3 fogcolor = vec3(0.25, 0.4, 0.5); // fog\n    //vec3 fogcolor = vec3(0.75, 0.6, 0.3); // smog\n    color *= mix(fogcolor, color, exp(-d * d / 200.0)); // fog for depth impression & to suppress flickering\n\n    //fragColor = vec4(color, 1.0);\n\tfragColor = vec4(sqrt(color), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}