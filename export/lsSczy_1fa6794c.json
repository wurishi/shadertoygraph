{"ver":"0.1","info":{"id":"lsSczy","date":"1492549865","viewed":259,"name":"Fake postprocessing fun","username":"novalis","description":"Some fake postprocessing fun including black bar cropping, filmic grain and chromatic aberration.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["postprocessing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS 1e-4\n#define PI 3.141592653589793238\n\nvec3 rotateX(vec3 p, float a) { float c = cos(a); float s = sin(a); return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z); }\nvec3 rotateY(vec3 p, float a) { float c = cos(a); float s = sin(a); return vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x); }\nvec3 rotateZ(vec3 p, float a) { float c = cos(a); float s = sin(a); return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z); }\nvec3 rotate(vec3 p, vec3 rot) { return rotateZ(rotateY(rotateX(p, rot.x), rot.y), rot.z); }\n\n// http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand(vec2 uv) {\n    highp float a = 12.9898, b = 78.233, c = 43758.5453;\n    highp float dt = dot(uv.xy, vec2(a,b));\n    return fract(sin(mod(dt,PI)) * c);\n}\n\nfloat displacement(vec3 p) {\n\tfloat d = 0.;\n\tconst int STEPS = 1;\n\tfor (int i=1; i<STEPS+1; i++) {\n\t\td += 1./float(i) * dot(sin(float(i)*p), vec3(1.))/3.;\n\t}\n\treturn d;\n}\n\nfloat sdSphere(vec3 p, float s) {\n\treturn length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat scene(vec3 p) {\n\tvec3 p2 = rotate(p, vec3(.2*iTime,.3*iTime,.5*iTime));\n\tfloat d = sdSphere(p2, 0.3) + 0.03*sin(2.*iTime)*displacement(p2*70.);\n\t\n\tfloat room = -sdBox(p+vec3(0.,-1.5,0.), vec3(2.,2.,2.));\n\treturn min(d, room);\n}\n\t\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(EPS, 0.);\n\tfloat d = scene(p);\n\treturn normalize(vec3(d-scene(p+e.xyy), d-scene(p+e.yxy), d-scene(p+e.yyx)));\n}\n\nvec3 lighting(vec3 p, vec3 lightPos) {\n\tvec3 n = normal(p);\n\tvec3 lightDir = normalize(p-lightPos);\n\tvec3 color = vec3(max(dot(lightDir,n), 0.));\n\treturn color;\n}\n\nbool raytrace(vec3 ro, vec3 rd, out vec3 p) {\n\tfloat f = 0.;\n\t\n\tconst float fMax = 10.;\n\t\n\tfor (int i=0; i<256; i++) {\n\t\tp = ro+f*rd;\n\t\tfloat d = scene(p);\n\t\tif (d <= EPS) return true;\n\t\tif (f > fMax) return false;\n\t\tf += d;\n\t}\n\t\n\treturn false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n\n\tvec3 lightPos = vec3(1.);\n\n\tvec3 ro = vec3(sin(iTime),-.2,cos(iTime));\n\tvec3 rd = normalize(rotate(vec3(2.*uv,-1.), vec3(0.3,sin(iTime),0.0)));\n\t\n\tvec3 color;\n\tif (abs(uv.y) < 0.4) {\n\t\tvec3 p;\n\t\tif (raytrace(ro, rotate(rd, vec3(0.,.004,0.)), p)) {\n\t\t\tcolor.r = lighting(p, lightPos).r;\n\t\t}\n\t\tif (raytrace(ro, rd, p)) {\n\t\t\tcolor.g = lighting(p, lightPos).g;\n\t\t}\n\t\tif (raytrace(ro, rotate(rd, vec3(0.,-.004,0.)), p)) {\n\t\t\tcolor.b = lighting(p, lightPos).b;\n\t\t}\n\t\n\t\tfloat vignette = smoothstep(2.0, 2.0-0.45, length(uv));\n\t\tcolor = mix(color, color*vignette, 0.3);\n\t} else {\n\t\tcolor = vec3(0.);\n\t}\n\t\n\tfragColor = vec4((pow(color, vec3(1./1.3))+0.05*rand(3.*uv)), 1.);\n}","name":"Image","description":"","type":"image"}]}