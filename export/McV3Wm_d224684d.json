{"ver":"0.1","info":{"id":"McV3Wm","date":"1712927269","viewed":45,"name":"Cherry Blossom: [Sakura]","username":"inverse_transpose","description":"Cherry blossom character","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["blur","bloom","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define colorRange 24.0\n\nvec3 jodieReinhardTonemap(vec3 c){\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvec3 bloomTile(float lod, vec2 offset, vec2 uv){\n    return texture(iChannel1, uv * exp2(-lod) + offset).rgb;\n}\n\nvec3 getBloom(vec2 uv){\n\n    vec3 blur = vec3(0.0);\n\n    blur = pow(bloomTile(2., vec2(0.0,0.0), uv),vec3(2.2))       \t   \t+ blur;\n    blur = pow(bloomTile(3., vec2(0.3,0.0), uv),vec3(2.2)) * 1.3        + blur;\n    blur = pow(bloomTile(4., vec2(0.0,0.3), uv),vec3(2.2)) * 1.6        + blur;\n    blur = pow(bloomTile(5., vec2(0.1,0.3), uv),vec3(2.2)) * 1.9 \t   \t+ blur;\n    blur = pow(bloomTile(6., vec2(0.2,0.3), uv),vec3(2.2)) * 2.2 \t   \t+ blur;\n\n    return blur * colorRange;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = pow(texture(iChannel0, uv).rgb * colorRange, vec3(2.2));\n    color = pow(color, vec3(2.2));\n    color += pow(getBloom(uv), vec3(2.2));\n    color = pow(color, vec3(1.0 / 2.2));\n    \n    color = jodieReinhardTonemap(color);\n    \n\tfragColor = vec4(color*1.25,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float dot2( in vec2 v ) { return dot(v,v); }\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n// Signed distance to quadratic Bezier curve, by Inigo Quilez.\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{\n    vec2 a = B - A;\n\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p  = ky - kx*kx;\n    float q  = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float p3 = p*p*p;\n    float q2 = q*q;\n    float h  = q2 + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n\n        #if 0\n        // When p≈0 and p<0, h-q has catastrophic cancelation. So, we do\n        // h=√(q²+4p³)=q·√(1+4p³/q²)=q·√(1+w) instead. Now we approximate\n        // √ by a linear Taylor expansion into h≈q(1+½w) so that the q's\n        // cancel each other in h-q. Expanding and simplifying further we\n        // get x=vec2(p³/q,-p³/q-q). And using a second degree Taylor\n        // expansion instead: x=vec2(k,-k-q) with k=(1-p³/q²)·p³/q\n        if( abs(p)<0.001 )\n        {\n          //  float k = p3/q;              // linear approx\n          float k = (1.0-p3/q2)*p3/q;  // quadratic approx \n            x = vec2(k,-k-q);  \n        }\n        #endif\n\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        vec2  q = d+(c+b*t)*t;\n        res = dot2(q);\n    \tsgn = cro(c+2.0*b*t,q);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx = cro(c+2.0*b*t.x,qx);\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy = cro(c+2.0*b*t.y,qy);\n        if( dx<dy ) { res=dx; sgn=sx; } else {res=dy; sgn=sy; }\n    }\n    \n    return sqrt(res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n    \n    float result = 1000000.0;\n    \n    result = min(result, sdBezier(uv, vec2(-0.500,  0.600), vec2(-0.500,  0.000), vec2(-0.510, -0.575)));\n    result = min(result, sdBezier(uv, vec2(-0.650,  0.250), vec2(-0.500,  0.340), vec2(-0.350,  0.400)));\n    result = min(result, sdBezier(uv, vec2(-0.500,  0.300), vec2(-0.600,  0.000), vec2(-0.720, -0.200)));\n    result = min(result, sdBezier(uv, vec2(-0.500,  0.200), vec2(-0.350,  0.050), vec2(-0.350,  0.050)));\n    result = min(result, sdBezier(uv, vec2(-0.250, -0.050), vec2( 0.200, -0.100), vec2( 0.625, -0.100)));\n    result = min(result, sdBezier(uv, vec2( 0.475,  0.000), vec2( 0.300, -0.450), vec2(-0.250, -0.575)));\n    result = min(result, sdBezier(uv, vec2( 0.100,  0.125), vec2(-0.050, -0.200), vec2(-0.150, -0.300)));\n    result = min(result, sdBezier(uv, vec2(-0.150, -0.300), vec2( 0.123, -0.300), vec2( 0.450, -0.550)));\n    result = min(result, sdBezier(uv, vec2(-0.190,  0.450), vec2(-0.100,  0.350), vec2(-0.075,  0.250)));\n    result = min(result, sdBezier(uv, vec2( 0.080,  0.500), vec2( 0.120,  0.350), vec2( 0.120,  0.330)));\n    result = min(result, sdBezier(uv, vec2( 0.550,  0.450), vec2( 0.335,  0.200), vec2( 0.250,  0.100)));\n    \n    vec3 col = mix(\n        vec3(0.95, 0.4, 0.98),\n        vec3(0.000005, 0.000005, 0.00001),\n        result < 0.02 ? 0.0 : 1.0\n    );\n\n    col = pow(col, vec3(0.225));\n\tfragColor = vec4(col*0.31,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 makeBloom(float lod, vec2 offset, vec2 bCoord){\n    \n    vec2 pixelSize = 1.0 / vec2(iResolution.x, iResolution.y);\n\n    offset += pixelSize;\n\n    float lodFactor = exp2(lod);\n\n    vec3 bloom = vec3(0.0);\n    vec2 scale = lodFactor * pixelSize;\n\n    vec2 coord = (bCoord.xy-offset)*lodFactor;\n    float totalWeight = 0.0;\n\n    if (any(greaterThanEqual(abs(coord - 0.5), scale + 0.5)))\n        return vec3(0.0);\n\n    for (int i = -5; i < 5; i++) {\n        for (int j = -5; j < 5; j++) {\n\n            float wg = pow(1.0-length(vec2(i,j)) * 0.125,6.0);\n\n            bloom = pow(texture(iChannel0,vec2(i,j) * scale + lodFactor * pixelSize + coord, lod).rgb,vec3(2.2))*wg + bloom;\n            totalWeight += wg;\n\n        }\n    }\n\n    bloom /= totalWeight;\n\n    return bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\tvec3 blur  = makeBloom(2.,vec2(0.0,0.0), uv);\n\t\t blur += makeBloom(3.,vec2(0.3,0.0), uv);\n\t\t blur += makeBloom(4.,vec2(0.0,0.3), uv);\n\t\t blur += makeBloom(5.,vec2(0.1,0.3), uv);\n\t\t blur += makeBloom(6.,vec2(0.2,0.3), uv);\n\n    fragColor = vec4(pow(blur, vec3(1.0 / 2.2)),1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}