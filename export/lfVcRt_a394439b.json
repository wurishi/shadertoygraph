{"ver":"0.1","info":{"id":"lfVcRt","date":"1732271614","viewed":200,"name":"Pagoda","username":"dr2","description":"Pagoda at sunset (mouseable)","likes":27,"published":3,"flags":0,"usePreview":0,"tags":["sunset","architecture","pagoda"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Pagoda\" by dr2 - 2024\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  0   // (= 0/1) optional antialiasing\n\nfloat SmoothMin (float v1, float v2, float rc);\nfloat SmoothMax (float v1, float v2, float rc);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float aa);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Noiseff (float p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir;\nfloat tCur, dstFar, cIdV, gSizeV, wlSize, rfWid;\nint nFrame, idObj;\nconst int idFlor = 1, idCol = 2, idRf = 3, idRail = 4, idGlob = 5, idWal = 6, idSym = 7,\n   idRok = 8, idGrnd = 9;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 pr, q;\n  float dMin, d, rf;\n  dMin = dstFar;\n  pr = p;\n  pr.xz = mix (abs (pr.xz), abs (pr.zx), step (abs (pr.z), abs (pr.x)));\n  q = pr;\n  d = SmoothMax (length (max (abs (vec2 (q.x, abs (q.z) - wlSize)) -\n     vec2 (wlSize + 0.1, 0.1), 0.)) - 0.01, abs (q.y - 0.6) - 0.6, 0.02);\n  if (abs (q.x) < wlSize - 0.5) d = SmoothMax (d, min (0.5 - length (vec2 (abs (fract (q.x +\n     0.5) - 0.5) + 0.2, max (q.y - 0.5, 0.))), q.y - 0.05), 0.02);\n  DMIN (idWal);\n  d = SmoothMax (min (length (max (abs (vec2 (q.x, abs (q.y - 2.1) - 0.12)) - vec2 (0.7, 0.05), 0.)),\n     length (max (abs (Rot2D (vec2 (abs (q.x) - 0.35, q.y - 1.8), -0.05 * pi)) - vec2 (0.07, 0.7),\n     0.))) - 0.01, abs (abs (q.z) - wlSize) - 0.04, 0.01);\n  DMIN (idSym);\n  q = pr;\n  q.xz -= 2.4 * rfWid;\n  d = length (q) - 0.6 - 0.06 * Noisefv3 (8. * q.yzx);\n  DMIN (idRok);\n  q = p;\n  d = q.y - 0.01;\n  DMIN (idGrnd);\n  pr.y -= gSizeV * (cIdV + 0.5);\n  q = pr;\n  if (cIdV >= 1.) d = max (mix (abs (q.y - 0.18) - 0.07, abs (q.y - 0.12) - 0.03, step (5.5, cIdV)),\n     q.z - 0.68 * rfWid);\n  else d = max (min (max (abs (q.y - 0.18) - 0.07, q.z - 0.97 * rfWid), max (q.y - 0.17,\n     dot (q.zy, CosSin (0.15 * pi)) - 0.9 * rfWid)), min (0.17 - length (vec2 (q.x,\n     max (0., q.y + 0.17))), q.y + 0.7));\n  d = max (d, mix (d, 0.2 - length (q.xz), step (cIdV, 5.5) * step (0.1, p.y)));\n  DMIN (idFlor);\n  if (abs (p.y - 4. * gSizeV + 0.5) < 3. * gSizeV) {\n    d = min (length (abs (q.xz - 0.45 * rfWid) - 0.08) - 0.04, length (q.xz - 0.15 * rfWid) - 0.08);\n    DMIN (idCol);\n  }\n  if (cIdV >= 1.) {\n    q.y -= 0.7;\n    rf = rfWid * (1.5 - 0.5 * (cIdV - 1.) / 5.);\n    q.yz = Rot2Cs (q.yz, CosSin (-0.12 * pi));\n    d = 0.9 * max (abs (q.y + 0.01 * cos (32. * pi * q.x / rf)) - 0.01,\n       mix (max (0.68 * rfWid - q.z, q.z - rf), q.z - rfWid, step (5.5, cIdV)));\n    DMIN (idRf);\n    q.x = abs (q.x);\n    q.xz -= rf * vec2 (0.93, 1.);\n    d = length (q) - 0.03;\n    DMIN (idGlob);\n  }\n  if (cIdV <= 5.) {\n    q = pr;\n    q.xz -= mix (0.85, 0.63, step (0.5, cIdV)) * rfWid;\n    d = min (length (vec2 (abs (q.y - 0.54) - 0.06, q.z)) - 0.02,\n       max (length (q.xz) - 0.06, abs (q.y - 0.43) - 0.2));\n    DMIN (idRail);\n  }\n  q = p;\n  q.y -= 7. * gSizeV - 0.2;\n  d = length (q) - 0.2;\n  DMIN (idGlob);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  bool cNu;\n  float dHit, d, s, sb, eps, rdyi;\n  if (rd.y == 0.) rd.y = 1e-4;\n  rdyi = 1. / rd.y;\n  eps = 1e-4;\n  cNu = true;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    if (cNu) {\n      cIdV = floor (p.y / gSizeV);\n      sb = (gSizeV * (cIdV + step (0., rd.y)) - ro.y) * rdyi;\n      cNu = false;\n    }\n    d = (cIdV <= 6.) ? ObjDf (p) : dstFar;\n    s = max (dHit, sb);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      cNu = true;\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = 1e-3 * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float sh, d, h;\n  int idObjT;\n  idObjT = idObj;\n  sh = 1.;\n  d = 0.01;\n  for (int j = 0; j < 40; j ++) {\n    p = ro + d * rd;\n    cIdV = floor (p.y / gSizeV);\n    if (cIdV < 0. || cIdV > 6.) break;\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.02 * d, h));\n    d += max (0.01, h);\n    if (sh < 0.05) break;\n  }\n  idObj = idObjT;\n  return 0.6 + 0.4 * sh;\n}\n\nfloat GrndHt (vec2 p)\n{\n  float t1, t2, h;\n  h = 0.;\n  if (length (max (abs (p) - wlSize, 0.)) < 0.01) {\n    t1 = SmoothMin (min (length (p - 1.2 * rfWid), length (p + 1.2 * rfWid)),\n       min (length (p - 2.4 * rfWid), length (p + 2.4  * rfWid)), 0.5);\n    p.x = - p.x;\n    t2 = SmoothMin (min (length (p - 1.2 * rfWid), length (p + 1.2 * rfWid)),\n       min (length (p - 2.4 * rfWid), length (p + 2.4 * rfWid)), 0.5);\n    h = 0.01 * (1. - smoothstep (0.4, 0.5, length (p) / dstFar)) * sin (8. * pi * SmoothMin (t1, t2, 0.5));\n  }\n  return h;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd, vec3 farCol)\n{\n  vec3 col, skyCol, p, cloudDisp;\n  float ds, fd, att, attSum, d, sd, aa;\n  aa = atan (rd.z, - rd.x) / (2. * pi) + 0.5;\n  if (rd.y > -0.02 && rd.y < 0.015 + 0.03 * mix (Fbm1 (128. * (aa + 1.)), Fbm1 (128. * aa), aa)) {\n    col = farCol;\n  } else {\n    cloudDisp = -0.05 * tCur * vec3 (1., 0., 1.);\n    p = ro + rd * (200. - ro.y) / rd.y;\n    ds = 0.1 * sqrt (length (ro - p));\n    fd = 0.001 / (smoothstep (0., 10., ds) + 0.1);\n    p.xz *= fd;\n    p.xz += 0.05 * tCur;\n    p *= 3.;\n    att = Fbm2 (p.xz);\n    attSum = att;\n    fd *= 3.;\n    d = fd;\n    ds *= fd;\n    for (int j = VAR_ZERO; j < 4; j ++) {\n      attSum += Fbm2 (p.xz + d * sunDir.xz);\n      d += ds;\n    }\n    sd = clamp (dot (sunDir, rd), 0., 1.);\n    skyCol = mix (vec3 (0.7, 1., 1.), vec3 (1., 0.4, 0.1), 0.25 + 0.75 * sd);\n    col = mix (vec3 (0.5, 0.75, 1.), skyCol, exp (-2. * (3. - sd) * max (rd.y - 0.1, 0.))) +\n       0.3 * (vec3 (1., 0.4, 0.2) * pow (sd, 256.) + vec3 (1., 0.8, 0.7) * pow (sd, 1024.));\n    attSum = 1. - smoothstep (1., 9., attSum);\n    col = mix (vec3 (0.4, 0., 0.2), mix (col, vec3 (0.2),\n       att * (0.001 + 0.999 * smoothstep (0.001, 0.004, rd.y))), attSum) +\n       vec3 (1., 0.4, 0.) * pow (attSum * att, 4.) * (pow (sd, 8.) + 0.5);\n  }\n  return col;\n}\n\nvec4 GrndCol (vec3 p)\n{\n  return mix (vec4 (0.4, 0.5, 0.3, 0.), vec4 (0.3, 0.4, 0.1, 0.),\n       smoothstep (0.2, 0.8, Fbm2 (0.5 * p.xz)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, farCol;\n  vec2 vf;\n  float dstObj, dstGrnd, nDotL, sh;\n  bool isBg;\n  isBg = true;\n  vf = vec2 (0.);\n  farCol = 0.5 * vec3 (0.3, 0.41, 0.55);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    isBg = false;\n    ro += dstObj * rd;\n    vn = (idObj == idGrnd) ? GrndNf (ro) : ObjNf (ro);\n    if (idObj == idFlor) {\n      col4 = vec4 (0.65, 0.6, 0.6, 0.05);\n      if (cIdV == 0.) col4 *= 1. - 0.3 * smoothstep (0.42, 0.45, abs (fract (12. * ro.y + 0.5) - 0.5));\n      if (ro.y < 0.5 * gSizeV && length (ro.xz) < rfWid) col4 *= 0.6;\n      if (vn.y > 0.99) col4 *= 1. - 0.2 * smoothstep (0.43, 0.46, Maxv2 (abs (fract (8. * ro.xz + 0.5) - 0.5)));\n    } else if (idObj == idCol) {\n      col4 = vec4 (0.6, 0.3, 0.2, 0.05) * (1. - 0.2 * smoothstep (0.43, 0.45,\n         abs (fract (8. * ro.y / gSizeV + 0.5) - 0.5)));\n    } else if (idObj == idRf) {\n      col4 = vec4 (0.2, 0.5, 0.2, 0.2);\n    } else if (idObj == idRail) {\n      col4 = vec4 (0.8, 0.8, 0.85, 0.3);\n    } else if (idObj == idGlob) {\n      col4 = vec4 (1., 1., 0.3, -1.);\n      if (length (ro.xz) < 0.2) col4.rgb *= 1.1 - 0.6 * Noiseff (floor (3. * tCur));\n    } else if (idObj == idWal) {\n      col4 = vec4 (0.65, 0.6, 0.6, 0.);\n      vf = vec2 (16., 0.5);\n    } else if (idObj == idSym) {\n      col4 = vec4 (0.6, 0., 0., -1.);\n    } else if (idObj == idRok) {\n      col4 = mix (vec4 (0.4, 0.45, 0.4, 0.), vec4 (0.6, 0.6, 0.6, 0.1),\n         smoothstep (0.4, 0.6, Noisefv3 (32. * ro.yzx)));\n      vf = vec2 (8., 1.);\n    } else if (idObj == idGrnd) {\n      col4 = (length (max (abs (ro.xz) - wlSize, 0.)) < 0.01) ? vec4 (0.35, 0.4, 0.5, 0.) :\n         GrndCol (ro);\n      vf = vec2 (4., 1.);\n    }\n  } else if (rd.y < 0.) {\n    isBg = false;\n    dstObj = - ro.y / rd.y;\n    ro += dstObj * rd;\n    vn = vec3 (0., 1., 0.);\n    col4 = GrndCol (ro);\n    vf = vec2 (4., 1.);\n  }\n  if (! isBg) {\n    if (col4.a >= 0.) {\n      nDotL = max (dot (vn, sunDir), 0.);\n      if (idObj == idRail) nDotL *= nDotL;\n      if (vf.y > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n      sh = (dstObj < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n      col = col4.rgb * (0.25 + 0.15 * max (- dot (vn, sunDir), 0.) + 0.75 * sh * nDotL) +\n         col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n      if (idObj == idCol || idObj == idRail || idObj == idFlor) col += 0.2 * col4.rgb *\n         (max (abs (vn.y), max (- dot (vn.xz, normalize (ro.xz)), 0.)));\n      if (dstObj >= dstFar) col = mix (col, farCol, pow (1. + rd.y, 16.));\n    } else {\n      col = col4.rgb * (0.8 - 0.2 * dot (rd, vn));\n    }\n  } else {\n    col = SkyBgCol (ro, rd, farCol);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  el = -0.05 * pi;\n  zmFac = 4.;\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    zmFac += 2. * abs (az);\n    el += pi * mPtr.y;\n  } else {\n    az = 0.1 * pi * abs (2. * fract (0.005 * tCur) - 1.);\n  }\n  az += 0.1 * pi;\n  vuMat = StdVuMat (el, az);\n  gSizeV = 1.5;\n  rfWid = 2.;\n  wlSize = 4. * rfWid;\n  ro = vuMat * vec3 (0., 3. * gSizeV, -38.);\n  ro.y = max (ro.y, 0.5);\n  dstFar = 80.;\n  sunDir = normalize (vec3 (1., 0.5, 1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float aa = float (VAR_ZERO); aa < naa; aa ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * aa + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float v1, float v2, float rc)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (v2 - v1) / rc, 0., 1.);\n  return mix (v2 - h * rc, v1, h);\n}\n\nfloat SmoothMax (float v1, float v2, float rc)\n{\n  return - SmoothMin (- v1, - v2, rc);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float aa)\n{\n  vec2 cs;\n  cs = sin (aa + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (mod (p + vec2 (0., 1.), 2. * pi)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (mod (dot (p, cHashVA2) + vec2 (0., cHashVA2.x), 2. * pi)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (mod (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y),\n     2. * pi)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, aa;\n  f = 0.;\n  aa = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += aa * Noiseff (p);\n    aa *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, aa;\n  f = 0.;\n  aa = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += aa * Noisefv2 (p);\n    aa *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float aa;\n  s = vec3 (0.);\n  aa = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += aa * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    aa *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 h;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  }\n  h = v.xyz - v.w;\n  return normalize (n + f * (h - n * dot (n, h)));\n}\n","name":"Image","description":"","type":"image"}]}