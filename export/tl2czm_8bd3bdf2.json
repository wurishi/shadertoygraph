{"ver":"0.1","info":{"id":"tl2czm","date":"1594047147","viewed":158,"name":"2D SDF RenderTexture","username":"PrzemyslawZaworski","description":"In following example, Buffer A is 32-bit float RGBA render texture which stores scene geometry as distance values. It is an exercise which shows how to store custom SDF shapes with ability to apply standard shadow/AO algorithms etc.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["2d","sdf","tutorial","texture","shadows","distance","field","signed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Map(vec2 uv)\n{  \n\treturn texture(iChannel0, uv).a;\n}\n\n// https://www.ronja-tutorials.com/2018/12/01/2d-shadows.html\nfloat Shadow(vec2 position, vec2 light, float hardness)\n{\n    vec2 direction = normalize(light - position);\n    float lightDistance = length(light - position);\n    float rayProgress = 0.0001;\n    float shadow = 9999.;\n    for(int i=0; i<32; i++)\n    {\n        float sceneDist = Map(position + direction * rayProgress);\n        if(sceneDist <= 0.) return 0.1;        \n        if(rayProgress > lightDistance) return clamp(shadow, 0.1, 1.0);\n        shadow = min(shadow, hardness * sceneDist / rayProgress);\n        rayProgress = rayProgress + sceneDist;\n    }\n    return 0.1;\n}\n\nvec3 Lighting(vec2 p)\n{\n\tvec2 lightPos = vec2(sin(iTime) * 0.5 + 0.5, 1.0);\n\tvec3 lightDir = normalize(vec3(lightPos, -1.0));\n\tvec3 normalDir = normalize(vec3(p, -1.0));\n\tfloat s = pow(dot(lightDir,normalDir), 5.0); \n    return vec3(s,s,0) * Shadow(p, lightPos, 50.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    bool IsPointInsideObject = (Map(uv)<0.0);\n    fragColor = IsPointInsideObject ? vec4(0,0,1,1) : vec4(Lighting(uv), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 Hash(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat Circle(vec2 p, vec2 c, float r) \n{\n    return length(p-c)-r;\n}\n\nfloat Map(vec2 p)\n{\n\tvec2 c = Hash(ceil(iTime));\n\tc.y *= 0.85;\n\tfloat sdf = Circle(p,c,0.01);\n\tif (iFrame>0) sdf = min(sdf, texture(iChannel0, p).a);   \n\treturn sdf;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord/iResolution.xy;\n    float sdf = Map(p);\n    fragColor = vec4(sdf, sdf, sdf, sdf);\n}","name":"Buffer A","description":"","type":"buffer"}]}