{"ver":"0.1","info":{"id":"4sdSRs","date":"1460928650","viewed":124,"name":"Color testing","username":"rimina","description":"Prototyping color palette","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["palette"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//The glitch method is modified from three.js post processing examples\n//Original version by alteredq\n//https://github.com/mrdoob/three.js/blob/dev/examples/js/postprocessing/GlitchPass.js\n\n#define PI 3.14159265\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat randf(){\n    float time = iTime;\n    return mod(4.0,sin(time*time)+1.0)*0.75;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    int on = 1;//should we apply the glitch ?\n    float amount = randf()*0.005;\n    float angle = (PI*randf())/(2.0*PI)-PI;\n    float seed = randf();\n    float seed_x = 0.5*randf()-0.5;\n    float seed_y = (0.3*randf()/0.6)-0.3;\n    float distortion_x = randf()*iResolution.x;\n    float distortion_y = randf()*iResolution.y;\n    float col_s = 0.3;\n\n\n    if(on != 0){\n\n        vec2 p = uv;\n        float xs = floor(gl_FragCoord.x / 0.5);\n        float ys = floor(gl_FragCoord.y / 0.5);\n        //based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch\n        vec4 normal = texture(iChannel0, p*seed*seed);\n        if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {\n            if(seed_x >0.0){\n                p.y = 1. - (p.y + distortion_y);\n            }\n            else {\n                p.y = distortion_y;\n            }\n        }\n        if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {\n            if(seed_y>0.){\n                p.x=distortion_x;\n            }\n            else {\n                p.x = 1. - (p.x + distortion_x);\n            }\n        }\n        p.x+=normal.x*seed_x*(seed/5.);\n        p.y+=normal.y*seed_y*(seed/5.);\n        //base from RGB shift shader\n        vec2 offset = amount * vec2( cos(angle), sin(angle));\n        vec4 cr = texture(iChannel0, p + offset);\n        vec4 cga = texture(iChannel0, p);\n        vec4 cb = texture(iChannel0, p - offset);\n        fragColor = vec4(cr.r, cga.g, cb.b, cga.a);\n        //add noise\n        vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);\n        fragColor = fragColor+ snow;\n    }\n    else {\n        fragColor = texture(iChannel0, uv);\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//https://iquilezles.org/articles/palettes\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nfloat bend(vec2 p){\n    return 0.5*(sin(p.x) + cos(p.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float noise = bend(uv+iTime*0.1);\n    \n    vec3 col =  palette((fragCoord.x/iResolution.x*0.5)+noise,\n            vec3(0.2, 0.1, 0.25), vec3(0.5, 0.5, 0.5), vec3(1., 1., 0.), vec3(0.25, 0.5, 0.8));\n    \n    col = smoothstep(0., 1., col); \n    col = pow(col, 1./vec3(1.7));\n\tfragColor = vec4(col, 1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}