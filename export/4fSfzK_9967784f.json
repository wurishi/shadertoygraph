{"ver":"0.1","info":{"id":"4fSfzK","date":"1727723517","viewed":30,"name":"Liquorice","username":"EldritchEli","description":"Definitetly not correct, light is a bit weird. However, it looks cool!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","hash"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RED vec3(0.8,0.1,.6)\n#define BLUE vec3(0.4,0.3,.6)\n#define GREEN vec3(0.2,0.6,.6)\n#define WHITE vec3(1.0,1.0,1.0)\n#define MIN_DIST 0.001\n#define MAXSTEP 100\n#define MAX_DIST 150.0\n#define UTIL vec3(1.0,-1.0,0.0)\n#define I_UTIL vec3(1,-1,0)\n#define LightRot mat3x3(cos(iTime),.0,sin(iTime),.0,1.0,.0,-sin(iTime),0,cos(iTime))\n#define rot mat3x3(0.2,.0,1.2,.0,1.0,.7,1.2,0.9,0.1)\nvec3 lightPos;\n\n\nvec3 camera;\n\nvec4 sphere (vec3 p, vec3 pos, float size, vec3 color){\nreturn vec4(color, length(p - pos) - size);\n\n}\n\nfloat sphere (vec3 p, vec3 pos, float size){\n    return length(p - pos) - size;\n}\n\n\n\nvec3 hash(uvec3 v) {\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    v ^= v >> 16u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    return normalize(vec3(v));\n}\n\n    // cubic polynomial\nvec4 smin( vec4 a, vec4 b, float k )\n{\n    float h = 1.0 - min( abs(a.w-b.w)/(6.0*k), 1.0 );\n    float w = h*h*h;\n    float m = w*0.5;\n    float s = w*k; \n    return (a.w<b.w) ? vec4(vec3(mix(a.xyz,b.xyz,m)),a.w-s) : vec4(vec3(mix(a.xyz,b.xyz,(1.0-m))),b.w-s);\n}\n\n\nfloat sphereGrid(vec3 uv, float scale){\n    uv*=scale;\n    vec3 p = fract(uv);\n    vec3 base = vec3(floor(uv));\n    float m = 1000000.0;\n    vec3 h;\n    for(float i=0.0; i<=1.0; i++){\n     for(float j=0.0; j<=1.0; j++){\n      for(float k=0.0; k<=1.0; k++){\n          h = hash(uvec3(base +vec3(i,j,k)+vec3(20.0)));\n          m = min( m, sphere(p,vec3(i,j,k),h.x*h.z));\n          \n          }}}\n          \n    return m;\n}\n\n\nvec4 map (vec3 p){\n    vec4 m;\n    float sph = sphere(p, vec3(0.0,0.0,60.0), 16.0);\n    if(sph <=40.0f){ \n        float gr = sphereGrid(p,0.1);\n        m = smin(vec4(RED,sph),vec4(BLUE,gr),0.2);\n        m = smin(m, vec4(GREEN,sphereGrid(rot*p+sin(p),0.1)),0.1);\n        return m;\n        }\n    \n    return vec4(BLUE, sph);\n}\n\nvec3 normal(vec3 pos){\n    vec3 u = UTIL*0.01;\n    return normalize(vec3(map(pos+u.xzz).w - map(pos+u.yzz).w, //x\n                map(pos+u.zxz).w - map(pos+u.zyz).w,\n                map(pos+u.zzx).w - map(pos+u.zzy).w));\n    }\n\nvec3 shadeHit(vec3 p, vec3 rd, vec3 col){\n    const float s = 0.5;\n    const float d = .7;\n    //Phong shading!!\n    vec3 n = normal(p);\n   \n    vec3 l = normalize(lightPos-p);\n    vec3 r = reflect(-l,n);\n    vec3 v = normalize(camera - p);\n    vec3 specular = pow(s*max(0.0,dot(r,v)), 2.0)*WHITE;\n    vec3 diffuse = d*max(0.0,dot(l,n))*col;\n    return diffuse + specular;\n    \n    }\n\nvec3 rayMarch(vec3 o, vec3 rd) {\n    vec4 col_dist;\n    float ray_length = 0.0f;\n    for(int s; s < MAXSTEP && ray_length < MAX_DIST; s++){\n        col_dist = map(o +rd*ray_length);\n        ray_length += col_dist.w;\n        if(col_dist.w <= MIN_DIST) { return shadeHit(o+rd*ray_length, rd, col_dist.xyz);}\n        \n        }\n        return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    camera = UTIL.zzy;\n\n    lightPos = LightRot*vec3(50.0,0.0,0.0);\n\n\n\n    // Normalized pixel coordinates (from 0 to 1) + z coordinate 0\n    vec3 uv = vec3(fragCoord/iResolution.xy,0.0f);\n    uv-= UTIL.xxz*0.5;\n   uv.x *= iResolution.x/iResolution.y;\n    //uv.y-0.2;\n\n\n    \n    vec3 col = rayMarch(camera,normalize(uv-camera));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}