{"ver":"0.1","info":{"id":"XftGzH","date":"1712148240","viewed":68,"name":"TP3 : bipboupboup-3","username":"Raphalator","description":"ezfezf","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["ezfezf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modeling - 2024.02.06\n// Eric Galin\n\nfloat PI=3.14;\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);\n}\n\nstruct Ray {\nvec3 ro; // Ray origin\nvec3 rd; // Direction\n};\n\n// Compute a point on the ray\n// ray : Ray\n// t   : depth\nvec3 Point(Ray ray,float t)\n{\n  return ray.ro+t*ray.rd;\n}\n\n// Compute the ray\n//     m : Mouse position\n//     p : Pixel\nRay CreateRay(vec2 m,vec2 p)\n{\n  float a=3.*3.14*m.x; \n  float le=3.5;\n  \n  // Origin\n  vec3 ro=vec3(35.,0.,10.)*Rz(a);\n  \n  // Target point\n  vec3 ta=vec3(0.,0.,3.);\n  \n  // Orthonormal frame\n  vec3 w=normalize(ta-ro);\n  vec3 u=normalize(cross(w,vec3(0.,0.,1.)));\n  vec3 v=normalize(cross(u,w));\n  vec3 rd=normalize(p.x*u+p.y*v+le*w);\n  return Ray(ro,rd);\n}\n\n// Primitives\n\nfloat Union(float a,float b)\n{\n  return min(a,b);\n}\n\nfloat Intersect(float a, float b){\n    return max(a,b);\n}\n\nfloat Difference(float a, float b){\n    return max(a,-b);\n}\n\nfloat Arrondi(float a, float b){\n    return a - b;\n}\n\nfloat Maigrir(float a, float b){\n    return a + b;\n}\n\nvec3 Translation(vec3 p, vec3 translation)\n{\n    return p + translation;\n}\n\nfloat Lissage(float a, float b, float r){\n    float h = max(r - abs(a - b), 0.) / r;\n    return min(a, b) - ((1. / 6.) * r * (h * h * h));\n}\n\n//rotation de l'objet (ça marche :)) mais soucis sur le pivot pour certaine forme )\n//wikipédia https://fr.wikipedia.org/wiki/Matrice_de_rotation#:~:text=En%20math%C3%A9matiques%2C%20et%20plus%20pr%C3%A9cis%C3%A9ment,I%20est%20la%20matrice%20identit%C3%A9.\nvec3 rotateZ(vec3 p, float angle) {\n    float s = sin(radians(angle));\n    float c = cos(radians(angle));\n    \n    mat3 rotationMatrix = mat3( \n        c, s, 0,\n        -s, c, 0,\n        0, 0, 1\n    );\n\n    return rotationMatrix * p;\n}\n\nvec3 rotateY(vec3 p, float angle) {\n    float s = sin(radians(angle));\n    float c = cos(radians(angle));\n    \n    mat3 rotationMatrix = mat3( \n        c, 0, -s,\n        0, 1, 0,\n        s, 0, c\n    );\n\n    return rotationMatrix * p;\n}\n\nvec3 rotateX(vec3 p, float angle) {\n    float s = sin(radians(angle));\n    float c = cos(radians(angle));\n    \n    mat3 rotationMatrix = mat3( \n        1, 0, 0,\n        0, c, -s,\n        0, s, c\n    );\n\n    return rotationMatrix * p;\n}\n\nvec3 rotateXYZ(vec3 p, float angleX, float angleY, float angleZ) {\n    vec3 rotated_p = rotateX(p, angleX);\n    rotated_p = rotateY(rotated_p, angleY);\n    rotated_p = rotateZ(rotated_p, angleZ);\n    return rotated_p;\n}\n\n\n// Primitives\n// Sphere\n// p : point\n// c : center of skeleton\n// r : radius\nfloat Sphere(vec3 p,vec3 c,float r)\n{\n  return length(p-c)-r;\n}\n\n//Plan\n//c : Point du plan\n//p : Position\n//n : Normale au plan\nfloat Plan(vec3 p, vec3 c, vec3 n){\n    return dot(p-c, normalize(n));\n}\n\n\n\n//Cube\n//c : center of skeleton\n//p : Position\n//h : hauteur\n//l : largeur\n//w : profondeur\nfloat Cube(vec3 p, vec3 c, float h, float l, float w){  \n    h = h / 2.0;\n    l = l / 2.0;\n    w = w / 2.0;\n\n    // Plan du cube\n    float p1 = Plan(p, Translation(c, vec3(-h, 0.0, 0.0)), vec3(-1.0, 0.0, 0.0));\n    float p2 = Plan(p, Translation(c, vec3(h, 0.0, 0.0)), vec3(1.0, 0.0, 0.0));\n    float p3 = Plan(p, Translation(c, vec3(0.0, 0.0, w)), vec3(0.0, 0.0, 1.0));\n    float p4 = Plan(p, Translation(c, vec3(0.0, 0.0, -w)), vec3(0.0, 0.0, -1.0));\n    float p5 = Plan(p, Translation(c, vec3(0.0, l, 0.0)), vec3(0.0, 1.0, 0.0));\n    float p6 = Plan(p, Translation(c, vec3(0.0, -l, 0.0)), vec3(0.0, -1.0, 0.0));\n\n    // Intersection des plans pour former le cube\n    return Intersect(Intersect(p1, Intersect(p2, Intersect(p3, p4))), Intersect(p5, p6));\n}\n\n//Pyramid\n//c : center of skeleton\n//p : Position\n//L : Longueur\n//l : largeur\nfloat Pyramid(vec3 p, vec3 c, float l, float L){\n    L ;\n    l ;\n    \n    // Base pyramide\n    float basePlane = Plan(p, Translation(c, vec3(0.0, -L, 0.0)), vec3(0.0, -1.0, 0.0)); // Laisser la hauteur inchangée\n\n    // Côtés pyramide\n    float p1 = Plan(p, Translation(c, vec3(l, 0., l)), normalize(vec3(1.0, 1.0, 0.0)));\n    float p2 = Plan(p, Translation(c, vec3(-l, 0., l)), normalize(vec3(-1.0, 1.0, 0.0)));\n    float p3 = Plan(p, Translation(c, vec3(0.0, -L, -l)), normalize(vec3(0.0, 1.0, -1.0)));\n    float p4 = Plan(p, Translation(c, vec3(0.0, -L, l)), normalize(vec3(0.0, 1.0, 1.0)));\n\n    // Intersection des plans \n    return Intersect(basePlane, Intersect(p1, Intersect(p2, Intersect(p3, p4))));\n}\n\n//Capsule\n//p : Position\n//a : Extrémité 1\n//b : Extremité 2\n//r : rayon\nfloat Capsule(vec3 p, vec3 a, vec3 b, float r){\n    vec3 u = normalize(b-a);\n    if(dot(p-a,u) < 0.){\n        return length(p-a) - r;\n        }\n    else if (dot(p-b,-u) < 0.){\n        return length(p-b) - r;\n        }\n    else {\n        return sqrt( length(p-a) * length(p-a) - dot(p-a, u) * dot(p-a, u)) - r;\n    }\n}\n//Cylinder\n//p : Position\n//a : Centre 1\n//b : Centre 2\n//r : Rayon\nfloat Cylinder (vec3 p, vec3 a, vec3 b, float r){\n    float v = Capsule(p,a,b,r);\n    float p1 = Plan(p,a,a-b);\n    float p2 = Plan(p,b,b-a);\n    return Intersect(p1,(Intersect(p2,v)));\n}\n\nfloat tele(vec3 p){\n      float v1 = Union(\n    Difference(\n    Lissage(\n    Sphere(p,vec3(-2.,0.,5.), 2. ),\n    Sphere(p,vec3(2.,0.,5.), 2. ), 10.),\n    Cube(p, vec3(0.,0.,5.), 5.,1.,12.)),\n    Union(Union(Cylinder(rotateXYZ(p, 0.,-50.,0.), vec3(-11.,0.,4.),vec3(-6.,0.,4.), 0.2),\n    Sphere(p,vec3(-4.,0.,11.), 0.6 )),\n    Union(Cylinder(rotateXYZ(p, 0.,50.,0.), vec3(13.,0.,4.),vec3(6.,0.,4.), 0.2),\n    Sphere(p,vec3(5.,0.,12.), 0.6 ))\n    ));\n    \n    \n    float v3 = Cube(p, vec3(0.,9.9,0.), 18.,10.,30.);\n    float v36 = Cube(p, vec3(0.,10.5,0.), 18.,10.,30.);\n    float v32 = Cube(p, vec3(0.,10.,0.), 18.,10.,30.);\n    float v33 = Cube(p, vec3(0.,-10.,0.), 18.,10.,30.);\n    float v35 = Cube(p, vec3(0.,-11.5,0.), 18.,10.,30.);\n    float v34 = Difference(Lissage(Intersect(\n    Plan(p, vec3(0.,-6.5,0.),vec3(0.0, -1.0, 0.0)),\n    Pyramid(rotateXYZ(p, 0.,0.,180.), vec3(0.,7.,0.), 4.,2.)),\n    Lissage(\n    Cylinder(p,vec3(1.5,-6.5,0.), vec3(1.5,-2.,0.), 2. ),\n    Cylinder(p,vec3(-1.5,-6.5,0.), vec3(-1.5,-2.,0.), 2. ),\n    10.),\n    3.),\n    v35);\n    \n    float v13 = Union(Difference(Lissage(Cube(p, vec3(0.,0.,0.), 15.,10.,12.),\n    Lissage(Capsule(p,vec3(2.5,3.,0.), vec3(2.5,-2.,0.), 6. ),\n    Capsule(p,vec3(-2.5,3.,0.), vec3(-2.5,-2.,0.), 6. ), 3.), 3.), v33),v34);\n\n    \n    \n    float v10 = Union(Union(Union(Union(\n    Cube(p, vec3(-5,7.,0.8), 3.,10.,0.5),\n    Cube(p, vec3(-5,7.,1.8), 3.,10.,0.5)),\n    Cube(p, vec3(-5,7.,4.8), 3.,10.,0.5)),\n    Cube(p, vec3(-5,7.,3.8), 3.,10.,0.5)),\n    Cube(p, vec3(-5,7.,2.8),3.,10.,0.5)\n    );\n    \n   \n    float v4 = Cube(p, vec3(0.,4.4,0.), 14.4,1.,11.4);\n    float v5 = Difference(Difference(Difference(Lissage(Cube(p, vec3(-5.,4.5,0.), 4.,1.,11.4),  \n    Lissage(Cylinder(p,vec3(-4.,5.,1.),vec3(-4.,3.,1.),3. ),\n    Cylinder(p,vec3(-4.,5.,-1.),vec3(-4.,3.,-1.),3. ), 3.)\n    , 2.5), v10), v32),  \n    Cube(p, vec3(-5.,0.5,0.), 4.,1.,11.4));\n    float v6 = Cylinder(rotateXYZ(p, 0.,0.,90.), vec3(0.,-5.,-4.),vec3(-5.5,-5.,-4.), 1.);\n    float v7 = Cylinder(rotateXYZ(p, 0.,0.,90.), vec3(0.,-5.,-1.),vec3(-5.5,-5.,-1.), 1.);\n    float v8 = Union(\n    Cylinder(p, vec3(6.5,-4.,-8.),vec3(6.,-4.,0.), 0.5),\n    Cylinder(p, vec3(-6.5,-4.,-8.),vec3(-6.,-4.,0.), 0.5)\n    );\n    \n    float v9 = Union(\n    Cylinder(p, vec3(6.5,4.,-8.),vec3(6.,4.,0.), 0.5),\n    Cylinder(p, vec3(-6.5,4.,-8.),vec3(-6.,4.,0.), 0.5)\n    );\n    \n    \n    float v11 = Intersect(\n    Plan(p, vec3(1.,9.5,0.),vec3(0.0, -1.0, 0.0)),\n    Pyramid(rotateXYZ(p, 0.,0.,180.), vec3(-1.,-10.,0.), 0.001,0.001));\n    \n    float v12 = Lissage(Cube(p, vec3(2.2,2.5,0.), 8.,5.,9.4),\n    Sphere(p,vec3(2.2,2.,0.), 5. ),3.);\n    \n    float v15 = Lissage(Cube(p, vec3(2.2,3.5,0.), 8.,5.,9.4),\n    Sphere(p,vec3(2.2,3.,0.), 5. ),3.);\n    \n    float v14 = Difference(Difference(Lissage(Cube(p, vec3(2.2,5.,0.), 8.5,4.5,9.9),\n    Capsule(p,vec3(2.2,4.,0.),vec3(2.2,-1.,0.) ,5.5 ),3.),v36),v15);\n    \n    \n  return Union(Union(Union(Union(Union(Union(Union(Union(Union(Union(Difference(v13,v3),v14),v11), v12), v6), v9), v8), v7), v4), v5), v1);\n}\n\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n    \n  float v1 = Plan(p, vec3(0., 0., -8.), vec3(0.0, 0.0, 1.));\n  float v2= tele(Translation(p, vec3(0., 15, 0.)));\n  \n  return Union(v1, v2);\n}\n\n// Analysis of the scalar field\n\nconst int Steps=200;// Number of steps\nconst float Epsilon=.01;// Marching epsilon\n\n// Object normal\n// p : point\nvec3 ObjectNormal(vec3 p)\n{\n  const float eps=.001;\n  vec3 n;\n  float v=object(p);\n  n.x=object(vec3(p.x+eps,p.y,p.z))-v;\n  n.y=object(vec3(p.x,p.y+eps,p.z))-v;\n  n.z=object(vec3(p.x,p.y,p.z+eps))-v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// ray : Ray \n// e : Maximum distance\n// h : hit\n// s : Number of steps\nfloat SphereTrace(Ray ray,float e,out bool h,out int s)\n{\n  h=false;\n  \n  // Start at the origin\n  float t=0.;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=Point(ray,t);\n    float v=object(p);\n    // Hit object\n    if(v<0.)\n    {\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=max(Epsilon,v);\n    // Escape marched too far away\n    if(t>e)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Shadow -----------------------------------------------------------------------------------------------------------\n\n//Fibonacchi spiral\n//r : radius\n//k : index of point\n//n : number of points\nvec3 Fib(float r, int k, int n)\n{\n    float lambdaK,thetaK,phiK;\n    vec3 P;\n    \n    thetaK = (float(k)+1./2.) * PI * (1. + sqrt(5.));\n    phiK = acos(1.-2.*float(k)/float(n));\n    lambdaK = (float(k) + 1./2.)/float(n);\n        \n    return (r * sqrt(lambdaK) * vec3(cos(thetaK)*sin(phiK),sin(thetaK)*sin(phiK),cos(phiK)));\n}\n\n\n//Hard shadow casting light\n//p : p\n//s : source light position\n\n\nfloat HS(vec3 p, vec3 s, vec3 norm)\n{\n    int n; \n    bool hit;\n    \n    float t = SphereTrace(Ray(s + norm, normalize(p - s)), 100.0, hit, n);\n    \n    if(hit && t<length(p-s))\n    {\n        return 0.0;\n    }\n    \n    return 1.0;\n}\n\n//Soft shadow neon\n//p : p\n//a : neon start\n//b : neon end\n//n : nomber of HS lights\n//norm : Normal at point\nfloat SoftNeon(vec3 p, vec3 a, vec3 b, int n, vec3 norm)\n{\n    vec3 si;\n    float l = 0.0;\n    \n    for (int i = 0; i < n; i++)\n    {\n        \n        float t = float(i) / float(n - 1);\n        si = mix(a, b, t);\n        \n       \n        float hs = HS(p, si, norm);\n        \n        \n        l += hs;\n    }\n    \n    \n    return l / float(n);\n}\n\n//Soft shadow sphere\n//p : p\n//a : sphere center\n//b : sphere radius\n//n : nomber of HS lights\n//norm : Normal at point\nfloat SoftSphere(vec3 p, vec3 c, float r, int n, vec3 norm)\n{\n    vec3 si;\n    float l = 0.0;\n\n    for(int i=0;i<n;i++)\n    {\n        si = c + Fib(r,i,n);\n        l += HS(p,si,norm);\n    }\n\n    return l/float(n);\n}\n\n//Ambient occlusion\n//p : p\n//norm : Normal at point\n//r : sphere radius\n//n : nomber of HS lights\nfloat AO(vec3 p, float r, int n, vec3 norm)\n{\n    vec3 si;\n    float l = 0.0;\n\n    for(int i=0;i<n;i++)\n    {\n        si = p + Fib(r,i,n);\n\n        l += HS(p,si,norm);\n    }\n\n    return l/float(n);\n}\n\n// Lighting\n\n// Background color\n// d : Ray direction\nvec3 Background(vec3 d)\n{\n  vec3 color1 = vec3(0.529, 0.808, 0.922);\n    vec3 color2 = vec3(0.529, 0.808, 0.980);\n    float coefficient = d.z * 0.5 + 0.5;\n    vec3 skyBlue = mix(color1, color2, coefficient);\n\n    return skyBlue;\n}\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// e : Eye direction\nvec3 Shade(vec3 p,vec3 n,vec3 e)\n{\n  // Point light\n  vec3 lp = vec3(cos(iTime) * 20., sin(iTime) * 20., 15.);\n  \n  // Light direction to point light\n  vec3 l=normalize(lp-p);\n  \n  // Ambient color\n  vec3 ambient=.25+.25*Background(n);\n  \n  // Shadow computation ---------------------------------------------------------------------------------------------\n  float shadow= SoftNeon(p, lp, vec3(0., 0., 0.), 20, n);\n  //float shadow= HS(p, lp, n);\n  \n  // Phong diffuse\n  vec3 diffuse=.35*clamp(dot(n,l),0.,1.)*vec3(1.,1.,1.);\n  \n  // Specular\n  vec3 r=reflect(e,n);\n  vec3 specular=.15*pow(clamp(dot(r,l),0.,1.),35.)*vec3(1.,1.,1.);\n  vec3 c=ambient+shadow*(diffuse+specular);\n  return c;\n}\n\n// Image\nvoid mainImage(out vec4 color,in vec2 pxy)  \n{\n  // Pixel\n  vec2 pixel=(-iResolution.xy+2.*pxy)/iResolution.y;\n\n  // Mouse\n  vec2 m=iMouse.xy/iResolution.xy;\n  \n  // Camera\n  Ray ray=CreateRay(m,pixel);\n  \n  \n  // Hit and number of steps\n  bool hit;\n  int s;\n  \n   // Trace ray\n float t=SphereTrace(ray,75.,hit,s);\n  \n  // Shade background\n  vec3 rgb=Background(ray.rd);\n  \n  if(hit)\n  {\n    // Position\n    vec3 p=Point(ray,t);\n    \n    // Compute normal\n    vec3 n=ObjectNormal(p);\n    \n    // Shade object with light\n    rgb=Shade(p,n,ray.rd);\n  }\n    \n  color=vec4(rgb,1.);\n}\n","name":"Image","description":"","type":"image"}]}