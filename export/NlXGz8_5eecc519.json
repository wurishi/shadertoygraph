{"ver":"0.1","info":{"id":"NlXGz8","date":"1621477470","viewed":103,"name":"chladni gradient field","username":"aganztracy","description":"chladni simulation test","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["chladnisimulation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define HASHSCALE1 443.8975\n\n#define KALEIDOSCOPE_SPEED_X    4.0\n#define KALEIDOSCOPE_SPEED_Y  -10.0\n#define KALEIDOSCOPE_SPLITS     2.0\n\n#define PI 3.14159265359\n\n//reference：https://www.shadertoy.com/view/XdtBWH\nvec2 kaleidoscope(vec2 uv, vec2 offset, float splits)\n{\n    // XY coord to angle\n    float angle = atan(uv.y, uv.x);\n    // Normalize angle (0 - 1)\n    angle = ((angle / PI) + 1.0) * 0.5;\n    // Rotate by 90°\n    angle = angle + 0.25;\n    // Split angle \n    angle = mod(angle, 1.0 / splits) * splits;\n    \n    // Warp angle\n#ifndef LINEAR\n    float a = (2.0*angle - 1.0);\n    angle = -a*a + 1.0;\n    \n    //angle = -pow(a, 0.4) + 1.0;\n#else\n    angle = -abs(2.0*angle - 1.0) + 1.0;\n#endif\n    \n    angle = angle*0.2;\n    \n    // y is just dist from center\n    float y = length(uv);\n    //y = (y*30.0);\n    \n#ifdef FIX_X\n    //angle = angle * (y*1.0);\n#endif\n    \n    return vec2(angle, y) + offset;\n}\n\nvec2 SymmUV(vec2 uv, float splits){\n    float angle = atan(uv.y, uv.x);\n    //// Normalize angle (0 - 1)\n    angle = ((angle / PI) + 1.0) * 0.5;\n    //split angle\n    angle = mod(angle, 1.0 / splits) * splits;\n    angle = abs((angle -0.5)*2.);\n    angle *= 0.4;\n    \n    float y = length(uv);\n    uv = vec2(cos(angle),sin(angle))*y;\n    return uv;\n}\n//repeat the position in 'pos' every 'q' degree in polar space\nvec2 fan(in vec2 pos, in float q) \n{\n    pos-= vec2(0.5,0.5);\n    pos.x*=iResolution.x/iResolution.y;\n    //q = q / 180. * 3.14159265;\n    //float ang = atan(pos.x, pos.y),\n    //len = length(pos.xy );\n    //ang = mod(ang + q/2., q) - q/2.;\n    //pos.xy = len * vec2(sin(ang), cos(ang));\n    return pos;\n}\n\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lerp(float a, float b, float t)\n{\n\treturn a + t * (b - a);\n}\n\nfloat noise(float p)\n{\n\tfloat i = floor(p);\n    float f = fract(p);\n    \n    float t = f * f * (3.0 - 2.0 * f);\n    \n    return lerp(f * hash11(i), (f - 1.0) * hash11(i + 1.0), t);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;   \n    float signuvx = -sign(uv.x - 0.5);\n    float signuvy = sign(uv.y - 0.5);\n    ////////////////////////////////////////\n    \n\n    uv = fan(uv,45.);\n    vec2 UV = uv;\n    \n    vec2 A = vec2(sin(1.) * 4. * 0.005, \n                  sin(1.) * -10. * 0.005);\n\t//uv = kaleidoscope(uv, A, 8.);//8份对称\n    //uv = abs(uv * 2. - 1.);\n    \n    uv = SymmUV(uv,8.);\n\n    ////mod(angle, 1.0 / splits) * splits = fract(angle * splits);\n    \n    \n    uv.x *= iResolution.x/iResolution.y;\n\n    float m = 3. + sin(iTime*1.2*noise(iTime*0.003))*2.;\n    float n = 4. + sin(iTime*1.3*noise(iTime*0.001))*3.;\n    float L = 1.;\n    float value = cos(PI*n*uv.x/L)*cos(PI*m*uv.y/L)-cos(PI*m*uv.x/L)*cos(PI*n*uv.y/L);\n    value = (value + 1.)*0.5;\n    float finalValue = 10000.;\n    float stepx = 1.0 / iResolution.x;\n    float stepy = 1.0 / iResolution.y;\n    float directionx = 0.;\n    float directiony = 0.;\n    //for (float ny = -1.; ny <= 1.; ny++) {\n    //    for (float nx = -1.; nx <= 1.; nx++) {\n    //        if (nx == 0. && ny == 0.) {\n    //            continue;  // ourselves!\n    //       }\n    //        float tempValue = cos(PI*n*(uv.x+ nx * stepx)/L)*cos(PI*m*(uv.y+ ny * stepy)/L)-cos(PI*m*(uv.x+ nx * stepx)/L)*cos(PI*n*(uv.y+ ny * stepy)/L); \n    //       if (tempValue < finalValue){\n     //           finalValue = tempValue;\n                \n      //          if(abs(nx)>abs(ny)){\n     //               nx = sign(nx)*ny;\n     //               ny = sign(ny)*nx;\n      //          }\n     //           directionx = (nx * signuvx +1.)*0.5 ;\n     //           directiony = (ny * signuvy +1.)*0.5 ;\n      //      }\n      //  }\n    //}\n    \n    //float a = (atan(UV.x, UV.y)+PI)/PI*0.5;\n    float a = atan(UV.x, UV.y);\n    \n    for(float angle = 0.;angle < 2.*PI; angle+=PI*0.125*0.5){//对于所有的方向，计算出当前粒子所在位置对应的运动方向\n        float nx = cos(angle);\n        float ny = sin(angle);\n        \n         float tempValue = cos(PI*n*(uv.x + nx * stepx)/L)*cos(PI*m*(uv.y + ny * stepy)/L)-cos(PI*m*(uv.x+ nx * stepx)/L)*cos(PI*n*(uv.y+ ny * stepy)/L); \n            if (tempValue < finalValue){\n                finalValue = tempValue;\n                \n                if(a>=0.*PI&&a<0.25*PI){\n                    directionx = (nx+1.)*0.5 ;\n                    directiony = (ny+1.)*0.5 ;\n                }\n                else if(a>=0.25*PI&&a<0.5*PI){\n                    directionx = (ny+1.)*0.5 ;\n                    directiony = (nx+1.)*0.5 ;\n                }\n                else if(a>=0.5*PI&&a<0.75*PI){\n                    directionx = (ny+1.)*0.5 ;\n                    directiony = (-nx+1.)*0.5 ;\n                }\n                else if(a>=0.75*PI&&a<1.*PI){\n                    directionx = (nx+1.)*0.5 ;\n                    directiony = (-ny+1.)*0.5 ;\n                }\n                else if(a>=-1.*PI&&a<-0.75*PI){\n                    directionx = (-nx+1.)*0.5 ;\n                    directiony = (-ny+1.)*0.5 ;\n                }else if(a>=-0.75*PI&&a<-0.5*PI){\n                    directionx = (-ny+1.)*0.5 ;\n                    directiony = (-nx+1.)*0.5 ;\n                }else if(a>=-0.5*PI&&a<-0.25*PI){\n                    directionx = (-ny+1.)*0.5 ;\n                    directiony = (nx+1.)*0.5 ;\n                }else if(a>=-0.25*PI&&a<0.*PI){\n                    directionx = (-nx+1.)*0.5 ;\n                   directiony = (ny+1.)*0.5 ;\n                }\n\n            }    \n    }\n    //fragColor = vec4(uv.x*0.6,0.0,0.0, 1.0);\n    //fragColor = vec4(UV.x,UV.y,0.0, 1.0);\n    //fragColor = vec4(directionx,directiony,0.0, 1.0);\n    fragColor = vec4(directionx,directiony,value, 1.0);\n    //fragColor = vec4(value,value,value, 1.0);\n    //fragColor = vec4(uv,0., 1.0);\n\n}","name":"Image","description":"","type":"image"}]}