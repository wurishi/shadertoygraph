{"ver":"0.1","info":{"id":"DsVXRh","date":"1680730734","viewed":32,"name":"Pipe_Generation_v02","username":"Francois_Vrp","description":"Ray marching and occlusion culling test.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["pipegeneration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// name = Pipe_Generator\n// version = 1.2\n// author = FrancoisVrp\n\n\n// Cylinder Form\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// Torus Form\nfloat sdTorus (vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat ncos(float val) \n{\n    return cos(val) * 0.5+0.5;\n}\n\n// Set the color in function of the form.\nvec3 objectColor(float contactObject, int objectType)\n{\n    vec3 col = vec3(0.0);\n    if (objectType == 0)// if objectType is a Torus\n    {\n        col = vec3(1.0-contactObject);\n    }\n    else\n    {\n        //col = vec3(0.0, 0.0, ncos(iTime+3.1415926538*0.5));\n        col = vec3(ncos(iTime), 0.4, 0.4)-contactObject; \n    }\n    return col;\n}\n\n// Set a color if collision detected, or black.\nvec3 objectDetection(float contactObject, int objectType)\n{\n    vec3 col = vec3(0.0);\n    if (contactObject == -1.0)\n    {\n        col = vec3(0.0);\n    }\n    else\n    {\n        col = objectColor(contactObject, objectType);\n    }\n    return col;\n}\n\n// Repeat the space in function of a modulo c.\nvec3 Repeat(vec3 p, vec3 c)\n{\n\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// Set the map of the two objects separatly to allow a camera culling.\nvec2 map(vec3 pos)\n{\n    pos = Repeat(pos, vec3(5.0));\n    \n    // Volume.\n    float vCylinder = 0.0;\n    float vTorus =0.0;\n    \n    vCylinder = sdCappedCylinder(pos, 10.0, 0.5);\n    vTorus = sdTorus (pos, vec2 (1.2, 0.25));\n    return vec2(vCylinder, vTorus);\n}\n\n// \nstruct CastRayResult\n{\n    float contact;\n    int objectType;\n}\n\nCastRay(vec3 ro, vec3 rd) // ro = ray origin, rd = ray direction\n{\n    CastRayResult result;\n    // Contact.\n    float c = 0.0;\n    \n    for(int i=0; i<64; i++)\n    {\n        // Get a ray cast for each object.\n        float rayTorus = map(ro +rd *c)[0];      \n        float rayCylinder = map(ro +rd *c)[1];\n        \n        // A local variable to keep the shortest ray in mind.\n        float ray =0.0;\n        // Assign to ray the shortest ray and set the object which is closest to the camera.\n        if (rayTorus < rayCylinder)\n        {\n            ray = rayTorus;\n            result.objectType = 0;   \n        }\n        else\n        {\n            ray = rayCylinder;\n            result.objectType = 1;\n        }\n        \n        // If the ray is enough short, a value is set to contact, to had a field of view/outline to the object display.\n        if(ray < (0.0001*c))\n        {\n            result.contact = float (i)*0.02;\n            return result;\n        }\n        \n        c += ray;\n    }\n    // If not, give a value which will set this space in black.\n    result.contact = -1.0;\n    return result;\n}\n\n\n// Get the results of the castray, to apply to this position, the wright vec3 color.\nvec3 render(vec3 ro, vec3 rd)\n{\n    CastRayResult result = CastRay(ro, rd);\n    float contact = result.contact;\n    int objectType = result.objectType;\n    \n    \n    vec3 col = objectDetection(contact, objectType);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Centered Screen and Orthographic Environment.\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x*= iResolution.x/iResolution.y;\n    \n    // Camera.\n    float posX = 2.5;\n    float posY = sin(iTime*0.5)*2.;\n    float posZ = -iTime;\n    vec3 cameraPos = vec3(posX, posY, 5.0+posZ);\n    vec3 cameraTarget = vec3(posX, posY, posZ);\n    \n    // Setting direction camera vectors .\n    vec3 forward = normalize(cameraTarget - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    // Setting vector direction towards uv coordinates.\n    vec3 viewDir = normalize(uv.x * right + uv.y * up + forward);\n    \n    vec3 col =  render(cameraPos, viewDir);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}