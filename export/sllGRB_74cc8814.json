{"ver":"0.1","info":{"id":"sllGRB","date":"1622362811","viewed":931,"name":"Vyshyvanka GPU Patterns ","username":"mkngry","description":"Experimented with https://www.shadertoy.com/view/XlGcRh to find some good seeds for ranlim32 generator and accidently found some stuff generating nice-looking periodical patterns quite similar to Ukrainian embroider shirts.","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["integerhashing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"uvec3 hash(vec2 s)\n{\t\n  uvec2 u = uvec2(s);\n  //uint x = fmix(yellow_code(u.x^u.y));\n  uint x = triple32(fmix(u.x^u.y));\n  //uint x = pcg_hash(fmix(u.x^u.y));\n  uint y = avalanche0(yellow_code(u.x^~u.y));\n  uint z = avalanche1(yellow_code(~u.x^u.y));\n  //return uvec3(tw_hash(x),tw_hash(y),tw_hash(z));\n  return uvec3(yellow_code(EncodeMorton2(x,tw_hash(y))),yellow_code(EncodeMorton2(z,esgtsa(x))),yellow_code(EncodeMorton2(y,z)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy;\n  uint bit = uint(8.0 * uv.x) + 8u * uint(4.0 * uv.y);\n  vec2 seed = mod(fragCoord, vec2(iResolution.x/8.0, iResolution.y/4.0));\n  // Animation\n  seed += 100.0 * iTime;\n  \n  uvec3 hash = hash(seed);\n    \n  fragColor = vec4((hash >> bit) & 1u, 1.0);\n  // grid\n  fragColor *= step( 10.0/iResolution.x, 1.0-abs(2.0*fract(8.0*uv.x)-1.0));\n  fragColor *= step( 10.0/iResolution.y, 1.0-abs(2.0*fract(4.0*uv.y)-1.0));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// from fxt_book\n// https://jjj.de/\nuint yellow_code(uint a)\n{\n  uint m = ~0u >> 16u;\n  a ^= ((a & m) << 16u);\n  m ^= (m << 8u);\n  a ^= ((a & m) << 8u);\n  m ^= (m << 4u);\n  a ^= ((a & m) << 4u);\n  m ^= (m << 2u);\n  a ^= ((a & m) << 2u);\n  m ^= (m << 1u);\n  a ^= ((a & m) << 1u);\n  return a;\n}\n\n// from http://burtleburtle.net/bob/hash/integer.html\nuint avalanche0(uint a)\n{\n  a = (a+0x7ed55d16u) + (a<<12u);\n  a = (a^0xc761c23cu) ^ (a>>19u);\n  a = (a+0x165667b1u) + (a<<5u);\n  a = (a+0xd3a2646cu) ^ (a<<9u);\n  a = (a+0xfd7046c5u) + (a<<3u);\n  a = (a^0xb55a4f09u) ^ (a>>16u);\n  return a;\n}\n\n// from http://burtleburtle.net/bob/hash/integer.html\nuint avalanche1(uint a)\n{\n  a = (a+0x7fb9b1eeu) + (a<<12u);\n  a = (a^0xab35dd63u) ^ (a>>19u);\n  a = (a+0x41ed960du) + (a<<5u);\n  a = (a+0xc7d0125eu) ^ (a<<9u);\n  a = (a+0x071f9f8fu) + (a<<3u);\n  a = (a^0x55ab55b9u) ^ (a>>16u);\n  return a;\n}\n\n// from http://burtleburtle.net/bob/hash/integer.html\nuint avalanche2(uint a)\n{\n  a -= (a<<6);\n  a ^= (a>>17);\n  a -= (a<<9);\n  a ^= (a<<4);\n  a -= (a<<3);\n  a ^= (a<<10);\n  a ^= (a>>15);\n  return a;\n}\n\n// Also avalanche, last step from from murmur3 hash\n// see: \"Hash Functions for GPU Rendering\" \n// https://www.shadertoy.com/view/XlGcRh\nuint fmix(uint h)\n{\n  h ^= h >> 16;\n  h *= 0x85ebca6bu;\n  h ^= h >> 13;\n  h *= 0xc2b2ae35u;\n  h ^= h >> 16;\n  return h;\n}\n\n// Tomas Wang hash\n// http://burtleburtle.net/bob/hash/integer.html\n// also https://github.com/tugrul512bit/EpicWarCL/blob/master/EpicWarCL/bin/x64/Release/opencl_source/opencl_kernels.cl\nuint tw_hash(uint s)\n{\n  s = (s ^ 61u) ^ (s >> 16u);\n  s *= 9u;\n  s = s ^ (s >> 4u);\n  s *= 0x27d4eb2du;\n  s = s ^ (s >> 15u);\n  return s;\n}\n\n// Schechter and Bridson hash\n// https://www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf\nuint esgtsa(uint s)\n{\n  s = (s ^ 2747636419u) * 2654435769u;\n  s = (s ^ (s >> 16u)) * 2654435769u;\n  s = (s ^ (s >> 16u)) * 2654435769u;\n  return s;\n}\n\n// 32-bit xorshift\n//  - Marsaglia, Xorshift RNGs, Journal of Statistical Software, v8n14, 2003\nuint xorshift32(uint v)\n{\n  v ^= v << 13u;\n  v ^= v >> 17u;\n  v ^= v << 5u;\n  return v;\n}\n\nuint triple32(uint x)\n{\n  x ^= x >> 17u;\n  x *= 0xed5ad4bbu;\n  x ^= x >> 11u;\n  x *= 0xac4c1b51u;\n  x ^= x >> 15u;\n  x *= 0x31848babu;\n  x ^= x >> 14u;\n  return x;\n}\n\nuint pcg_hash(uint x)\n{\n  uint state = x * 747796405u + 2891336453u;\n  uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n  return (word >> 22u) ^ word;\n}\n\n// Morton Code taken from fg:\n// https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/\n\n// \"Insert\" a 0 bit after each of the 16 low bits of x\nuint Part1By1(uint x)\n{\n  x &= 0x0000ffffu;                  // x = ---- ---- ---- ---- fedc ba98 7654 3210\n  x = (x ^ (x <<  8u)) & 0x00ff00ffu; // x = ---- ---- fedc ba98 ---- ---- 7654 3210\n  x = (x ^ (x <<  4u)) & 0x0f0f0f0fu; // x = ---- fedc ---- ba98 ---- 7654 ---- 3210\n  x = (x ^ (x <<  2u)) & 0x33333333u; // x = --fe --dc --ba --98 --76 --54 --32 --10\n  x = (x ^ (x <<  1u)) & 0x55555555u; // x = -f-e -d-c -b-a -9-8 -7-6 -5-4 -3-2 -1-0\n  return x;\n}\n\n// \"Insert\" two 0 bits after each of the 10 low bits of x\nuint Part1By2(uint x)\n{\n  x &= 0x000003ffu;                  // x = ---- ---- ---- ---- ---- --98 7654 3210\n  x = (x ^ (x << 16u)) & 0xff0000ffu; // x = ---- --98 ---- ---- ---- ---- 7654 3210\n  x = (x ^ (x <<  8u)) & 0x0300f00fu; // x = ---- --98 ---- ---- 7654 ---- ---- 3210\n  x = (x ^ (x <<  4u)) & 0x030c30c3u; // x = ---- --98 ---- 76-- --54 ---- 32-- --10\n  x = (x ^ (x <<  2u)) & 0x09249249u; // x = ---- 9--8 --7- -6-- 5--4 --3- -2-- 1--0\n  return x;\n}\n\nuint EncodeMorton2(uint x, uint y)\n{\n  return (Part1By1(y) << 1u) + Part1By1(x);\n}\n\nuint EncodeMorton3(uint x, uint y, uint z)\n{\n  return (Part1By2(z) << 2u) + (Part1By2(y) << 1u) + Part1By2(x);\n}\n\n","name":"Common","description":"","type":"common"}]}