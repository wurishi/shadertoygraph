{"ver":"0.1","info":{"id":"MdjfWV","date":"1502325026","viewed":190,"name":"Ambient Dice","username":"rrika","description":"unoptimized implementation of http://miciwan.com/EGSR2017/AmbientDice.pdf","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["basis"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// See http://miciwan.com/EGSR2017/AmbientDice.pdf\n\n// Very bad implementation\n\n// 0 source data\n// 1 ambient die approximation\n// 2 ambient die approximation + grid\n// 3 difference\n// 4 UVs\n// 5 face group (red/green/blue/gray)\nconst int mode = 3;\n\n// 0 colors\n// 1 cubemap\nconst int source = 0;\n\n// false  colorsphere/cubemap sampled at die vertices\n// true   colorsphere/cubemap use integrated data from Buf A\nconst bool usebufA = false;\n\nconst float spinspeed = -0.3;\nconst float mousespeed = 0.0;\n\nconst float g = 1.61803398875; // golden ratio\nconst float t = 0.6180339887498547; // reciprocal of golden ratio\nconst float t2 = t*t;\n\nvec3 dieverts[12] = vec3[](\n    vec3(1, t, 0),\n    vec3(1, -t, 0),\n    vec3(-1, t, 0),\n    vec3(-1, -t, 0),\n    vec3(0, 1, t),\n    vec3(0, 1, -t),\n    vec3(0, -1, t),\n    vec3(0, -1, -t),\n    vec3(t, 0, 1),\n    vec3(-t, 0, 1),\n    vec3(t, 0, -1),\n    vec3(-t, 0, -1)\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 v, o;\n\n    {\n        // embed a -1…1 × -1…1 square inside the view\n        vec2 uvf = 2.0*(fragCoord.xy-iResolution.xy/2.0) / min(iResolution.x, iResolution.y);\n        vec2 uvm = 2.0*(iMouse.xy-iResolution.xy/2.0) / min(iResolution.x, iResolution.y);\n\t\t//if (iMouse.z == 0.0) uvm = vec2(0.0, 0.0);\n        \n        // get a normalized view vector\n    \tvec3 n = normalize(vec3(uvf, 1.0));\n        \n        // spin it\n\n        float s, c;\n        s = sin(uvm.y*mousespeed);\n    \tc = cos(uvm.y*mousespeed);\n    \tn = vec3(\n\t        n.x,\n\t        n.y * c + n.z * s,\n\t        n.y * s - n.z * c);\n        \n    \ts = sin(iTime*spinspeed - uvm.x*mousespeed);\n    \tc = cos(iTime*spinspeed - uvm.x*mousespeed);\n    \tn = vec3(\n\t        n.x * c + n.z * s,\n\t        n.y,\n\t        n.x * s - n.z * c);\n\n        v = n;\n    }\n\n    vec3 ref;\n    if (source == 0) {\n        ref = 0.5*v+0.5;\n    } else if (source == 1) {\n        ref = texture(iChannel0, v).xyz;\n    }\n    \n    vec3 diecolors[12];\n\n    if (mode == 0) {\n        o = ref;\n    } else {\n        \n        for (int i=0; i<12; i++) {\n            vec3 dc;\n            if (usebufA)\n                dc = texelFetch(iChannel1, ivec2(i, source), 0).xyz;\n            else if (source == 0)\n            \tdc = normalize(dieverts[i])*0.5+0.5;\n            else if (source == 1)\n                // read cubemap here directly (worse sampling)\n                dc = texture(iChannel0, dieverts[i]).xyz;\n            diecolors[i] = dc;\n        }\n            \n        vec3 av = abs(v);\n        vec3 n0 = vec3(1, t2, -t); // red-gray boundary\n        vec3 n1 = vec3(-t, 1, t2); // green-gray boundary\n        vec3 n2 = vec3(t2, -t, 1); // blue-gray boundary\n        vec3 f;\n        int n;\n        bool done = false;\n        bool corner = false;\n        bool showcolors = mode == 5;\n        int i0, i1, i2;\n        vec2 uv;\n        if (dot(n0, av)<0.0) {\n            // 4 triangles that cut the y-z plane (red)\n            f = v.xyz;\n            n = 0;\n            o = vec3(1.0, 0.0, 0.0);\n            done = showcolors;\n        } else if (dot(n1, av)<0.0) {\n            // 4 triangles that cut the x-y plane (green)\n            f = v.yzx;\n            n = 1;\n            o = vec3(0.0, 1.0, 0.0);\n            done = showcolors;\n        } else if (dot(n2, av)<0.0) {\n            // 4 triangles that cut the x-z plane (blue)\n            f = v.zxy;\n            n = 2;\n            o = vec3(0.0, 0.0, 1.0);\n            done = showcolors;\n        } else {\n            // 8 triangles that touch all three planes (gray)\n            o = vec3(0.5, 0.5, 0.5);\n            done = showcolors;\n            //o = 0.5*v+0.5;\n            float q = (1.0+t) / dot(av, vec3(1.0));\n            vec3 p = av * q;\n            vec3 v0 = vec3(t, 0, 1);\n            vec3 v1 = vec3(1, t, 0);\n            vec3 v2 = vec3(0, 1, t);\n            vec3 z01 = v1-(v0+v2)/2.0;\n            vec3 z02 = v2-(v0+v1)/2.0;\n            \n            float d1 = dot(p, z01) - dot(v0, z01);\n            float d2 = dot(p, z02) - dot(v0, z02);\n            \n            uv = vec2(d1/ (dot(v1, z01) - dot(v0, z01)),\n                      d2/ (dot(v2, z02) - dot(v0, z02)));\n\n            // identify corners\n            // 1) uncomment this\n            //  done = true;\n            // 2) uncomment one of these\n            //  o = vec3(sin(50.0*length(p-v0)));\n            //  o = vec3(sin(50.0*length(p-v1)));\n            //  o = vec3(sin(50.0*length(p-v2)));\n\n            i0 = 8+(v.x<0.0?1:0)+(v.z<0.0?2:0);\n            i1 = 0+(v.y<0.0?1:0)+(v.x<0.0?2:0);\n            i2 = 4+(v.z<0.0?1:0)+(v.y<0.0?2:0);\n            corner = true;\n        }\n\n        if (!corner) {\n            // here f is v permutated so all cases\n            // look like the red case\n            vec3 h = vec3(f.x, abs(f.y), abs(f.z));\n            float q = 1.0 / ((1.0-t)*h.y + h.z);\n            vec3 p = h * q;\n            uv = vec2(\n                p.x/(2.0*t)+0.5-p.y*0.5,\n                p.y);\n\n            int i=9+n*4+(f.z<0.0?2:0);\n            i0 = i%12;\n            i1 = (i+11)%12;\n            i2 = (f.y<0.0?2:0) + ((i&2)>>1) + ((i&~3)+8)%12;\n        }\n\n        // i0, i1, i2 and uv are ready now\n\n        vec3 interp =\n            diecolors[i0]+\n            (diecolors[i1]-diecolors[i0])*uv.x+\n            (diecolors[i2]-diecolors[i0])*uv.y;\n\n        float lines; {\n            vec3 ll = smoothstep(0.0, 0.01, abs(vec3(uv.x, uv.y, uv.x+uv.y-1.0)));\n            lines = ll.x * ll.y * ll.z;\n\t\t}\n\n        if (mode == 1) {\n            o = interp;\n        } else if (mode == 2) {\n            o = interp * lines;\n        } else if (mode == 3) {\n            o = vec3(5.0*abs(interp-ref));\n        } else if (mode == 4) {\n            o = vec3(uv, 0) * lines;\n        } else if (mode == 5) {\n            o = o * lines;\n        }\n\n        // display the twelve parameters in the corner\n        float padding = 3.0;\n        float scale = 10.0;\n        if (fragCoord.x >= padding && fragCoord.x < padding + 12.0*scale &&\n            fragCoord.y >= padding && fragCoord.y < padding + scale)\n        {\n            o = diecolors[int((fragCoord.x-padding) / scale)];\n        }\n    }\n\n\tfragColor = vec4(o, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// integrate the cubemap into twelve parameters for the die\n\nconst float g = 1.61803398875; // golden ratio\nconst float t = 0.6180339887498547; // reciprocal of golden ratio\nconst float t2 = t*t;\n\nvec3 dieverts[12] = vec3[](\n    vec3(1, t, 0),\n    vec3(1, -t, 0),\n    vec3(-1, t, 0),\n    vec3(-1, -t, 0),\n    vec3(0, 1, t),\n    vec3(0, 1, -t),\n    vec3(0, -1, t),\n    vec3(0, -1, -t),\n    vec3(t, 0, 1),\n    vec3(-t, 0, 1),\n    vec3(t, 0, -1),\n    vec3(-t, 0, -1)\n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int source = int(fragCoord.y);\n    if (source > 2) discard;\n    int index = int(fragCoord.x);\n    if (index > 12) discard;\n    float freq = sin(iTime)/2.0+1.0;\n    vec4 color;\n    int tt = int(iTime*100.0);\n    ivec2 off = ivec2(tt%64, (tt/64)%64);\n    vec4 rand = texelFetch(iChannel1, off, 0);\n\n    vec3 v = rand.xyz*2.0-1.0;\n    if (length(v)>1.0) discard; // to get uniform sampling over sphere\n\n    vec3 mapcolor;\n    if (source == 0) {\n        mapcolor = normalize(v)*0.5+0.5;\n    } else {\n        mapcolor = texture(iChannel2, v).xyz;\n    }\n\n    vec3 av = abs(v);\n    vec3 n0 = vec3(1, t2, -t); // red-gray boundary\n    vec3 n1 = vec3(-t, 1, t2); // green-gray boundary\n    vec3 n2 = vec3(t2, -t, 1); // blue-gray boundary\n    vec3 f;\n    int n;\n    bool corner = false;\n    int i0, i1, i2;\n    vec2 uv;\n    if (dot(n0, av)<0.0) { f = v.xyz; n = 0; }\n    else if (dot(n1, av)<0.0) { f = v.yzx; n = 1; }\n    else if (dot(n2, av)<0.0) { f = v.zxy; n = 2; }\n    else {\n        float q = (1.0+t) / dot(av, vec3(1.0));\n        vec3 p = av * q;\n        vec3 v0 = vec3(t, 0, 1);\n        vec3 v1 = vec3(1, t, 0);\n        vec3 v2 = vec3(0, 1, t);\n        vec3 z01 = v1-(v0+v2)/2.0;\n        vec3 z02 = v2-(v0+v1)/2.0;\n\n        float d1 = dot(p, z01) - dot(v0, z01);\n        float d2 = dot(p, z02) - dot(v0, z02);\n\n        uv = vec2(d1/ (dot(v1, z01) - dot(v0, z01)),\n                  d2/ (dot(v2, z02) - dot(v0, z02)));\n\n        i0 = 8+(v.x<0.0?1:0)+(v.z<0.0?2:0);\n        i1 = 0+(v.y<0.0?1:0)+(v.x<0.0?2:0);\n        i2 = 4+(v.z<0.0?1:0)+(v.y<0.0?2:0);\n        corner = true;\n    }\n    if (!corner) {\n        // here f is v permutated so all cases\n        // look like the red case\n        vec3 h = vec3(f.x, abs(f.y), abs(f.z));\n        float q = 1.0 / ((1.0-t)*h.y + h.z);\n        vec3 p = h * q;\n        uv = vec2(\n            p.x/(2.0*t)+0.5-p.y*0.5,\n            p.y);\n\n        int i=9+n*4+(f.z<0.0?2:0);\n        i0 = i%12;\n        i1 = (i+11)%12;\n        i2 = (f.y<0.0?2:0) + ((i&2)>>1) + ((i&~3)+8)%12;\n    }\n\n    // i0, i1, i2 and uv are ready now\n    float alpha = max(0.0,\n                      index == i0 ? 1.0-uv.x-uv.y :\n                      index == i1 ? uv.x :\n                      index == i2 ? uv.y : 0.0);\n\n    color = vec4(mapcolor, alpha);\n     \n\tvec4 prev = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n\tfragColor = vec4(mix(prev.rgb, color.rgb, color.a*0.08), 1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}