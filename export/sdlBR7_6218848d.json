{"ver":"0.1","info":{"id":"sdlBR7","date":"1644658367","viewed":119,"name":"reflect_Cornellbox","username":"namanonamako","description":"raymarch","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define time iTime\n\nprecision highp float;\n\n//uniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\n//vec3 lightDir = normalize(vec3(.6, .5, -.5));\n\nfloat rand(float a){\n\treturn fract(sin(a) * 3219.432);\n}\n\nfloat smoothmin(float d1, float d2, float k){\n\tfloat h = exp(-d1 * k) + exp(-d2 * k);\n\treturn -log(h) / k;\n}\n\nvec2 U(vec2 d1, vec2 d2){\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nvec3 hsv(float h, float s, float v){\n\treturn ((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\n\nfloat sdBox(vec3 p, vec3 b){\n\tp = abs(p) - b;\n\treturn length(max(p, 0.)) + min(max(max(p.x, p.y), p.z), 0.);\n}\n\nfloat sdSphere(vec3 p, float r){\n\treturn length(p) - r;\n}\n\nvec2 map(vec3 p){\n\tvec2 room = vec2(-sdBox(p, vec3(8., 3., 12.)), 0.);\n\t\n\tfloat d = sdSphere(p, 1.);\n\t\n\tfor(float i = 0.; i < 6.; i ++){\n\t\tvec3 q = p;\n\t\t\n\t\tq.x += sin(time * (.8 + rand(i + 3.)) + rand(i) * 2.) * 4.;\n\t\tq.y += cos(time * (.8 + rand(i + 3.)) + rand(i + 5.) * 2.) * 1.5 * (rand(i) + .5);\n\t\tq.z += sin(time * (.8 + rand(i + 4.)) + rand(2.*i) * 2.) * 2.;\n\t\tq.xy *= rot(time + rand(i));\n\t\tq.xz *= rot(time + rand(i));\n\t\t\n\t\td = smoothmin(d, sdBox(q, vec3(.75 * rand(i) + .3)) -.03, 4.);\n\t}\n\t\n\tvec2 d1 = vec2(d, 1.);\n\treturn U(d1, room);\n}\n\nvec3 genNormal(vec3 p){\n\tvec2 d = vec2(0.001, 0.);\n\treturn normalize(vec3(\n\t\tmap(p + d.xyy).x - map(p - d.xyy).x,\n\t\tmap(p + d.yxy).x - map(p - d.yxy).x,\n\t\tmap(p + d.yyx).x - map(p - d.yyx).x\n\t\t));\n}\n\nfloat genShadow(vec3 ro, vec3 rd, float lightdist){\n\tfloat c = 0.001;\n\tfloat h = 0.;\n\tfloat r = 1.;\n\tfloat shadowCoef = .5;\n\t\n\tfor(int i = 0; i < 50; i++){\n\t\th = map(ro + rd * c).x;\n\t\tif(h < 0.001){\n\t\t\treturn shadowCoef;\n\t\t}\n\t\tr = min(r, h * 16. / c);\n\t\tc += h;\n\t\tif(c > lightdist){\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn mix(shadowCoef, 1., r);\n}\n\t\n\nvec2 march(vec3 ro, vec3 rd, out vec3 ip){\n\tfloat d;\n\tvec2 dd;\n\tfor(int i = 0; i < 100; i++){\n\t\tip = ro + d * rd;\n\t\tdd = map(ip);\n\t\tif(dd.x < 0.001){\n\t\t\tbreak;\n\t\t}\n\t\td += dd.x;\n\t}\n\treturn dd;\n}\n\nvec3 lighting(vec3 rd, vec3 pos, vec3 normal, float mat){\n\tvec3 col;\n\t\n\tconst float lightnum = 6.;\n\t\n\tvec3 diff, amb, spec;\n\t\n\tfor(float i = 0.; i < lightnum; i++){\n\t\tvec3 lightpos = vec3(0., 0., 0.);\n\t\tlightpos.x += 5. * sin(time * (rand(i) - .5) * 3.);\n\t\tlightpos.y += .5* sin(time * (rand(3. * i) - .5) + rand(i) * 21.);\n\t\tlightpos.z += 7. * cos(time * (rand(6. * i) * 2. - .5) + rand(i * 6.) * 21.);\n\t\tvec3 tolight = lightpos - pos;\n\t\t\n\t\tvec3 lightcol = hsv(rand(float(i)), 1., 7.);\n\t\t\n\t\tdiff += clamp(dot(normalize(tolight), normal), 0., 1.) / pow(length(tolight), 2.) * lightcol;\n\t\tspec += pow(clamp(dot(reflect(rd, normal), normalize(tolight)), 0., 1.), 8.) / pow(length(tolight), 2.) * lightcol;\n\t\t\n\t\tfloat shadow = genShadow(pos + normal * .01, normalize(tolight), length(tolight));\n\t\tdiff *=shadow;\n\t}\n\tamb += .25;\n\tif(mat == 0.){\n\t\tcol += diff;\n\t\tcol += amb;\n\t\tif(normal.x != 0.){\n\t\t\tcol *= mix(vec3(1., 0., 0.), vec3(0., 1., 0.), step(normal.x, 0.));\n\t\t}\n\t}\n\tif(mat == 1.){\n\t\tcol += diff * .1;\n\t\tcol += spec * 1.;\n\t}\n\t//col *= shadow;\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 p = ( fragCoord.xy / iResolution.xy );\n\tp = (p - .5) * 2.;\n\tp.y *= iResolution.y / iResolution.x;\n\t//p = ( gl_FragCoord.xy * 2. - resolution.xy ) / min(resolution.x, resolution.y);\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tvec3 cp = vec3(4. * cos(time * .15), 0., -5.);\n\tvec3 t = vec3(0., 0., 0.);\n\tvec3 f = normalize(t - cp);\n\tvec3 u = vec3(0., 1., 0.);\n\tvec3 s = normalize(cross(u, f));\n\tu = normalize(cross(f, s));\n\tvec3 rd = normalize(p.x * s + p.y * u + f);\n\t\n\tvec3 ip;\n\t\n\tvec2 dd = march(cp, rd, ip);\n\t\n\t\n\tif(dd.x < 0.001){\n\t\tfloat reflectpow = .4;\n\t\tvec3 normal = genNormal(ip);\n\t\t\n\t\tcol += lighting(rd, ip, normal, dd.y);\n\t\t\n\t\t//reflect\n\t\tif(dd.y == 1.){\n\t\t\tcp = ip;\n\t\t\trd = reflect(rd, normal);\n\t\t\tdd = march(cp + normal * 0.1, rd, ip);\n\t\t\tnormal = genNormal(ip);\t\n\t\t\tcol += lighting(rd, ip, normal, dd.y) * reflectpow;\n\t\t\t\n\t\t\t//reflect2\n\t\t\tif(dd.y == 1.){\n\t\t\t\tcp = ip;\n\t\t\t\trd = reflect(rd, normal);\n\t\t\t\tdd = march(cp + normal * 0.1, rd, ip);\n\t\t\t\tnormal = genNormal(ip);\t\n\t\t\t\tcol += lighting(rd, ip, normal, dd.y) * reflectpow;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfragColor = vec4(col, 1.0 );\n\n}\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n*/","name":"Image","description":"","type":"image"}]}