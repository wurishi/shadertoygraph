{"ver":"0.1","info":{"id":"Md3Szj","date":"1460212417","viewed":557,"name":"Destruction Derby","username":"alan2here","description":"Based on code by Alexey Borisov in 2016.\n\nProbably contains too much redundant code from the original.\n\nUse W, S, A, D.\n\n---\n\nSimulation is running too quickly since taking out the track position progress stuff. :(","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["game","physics","car","driving","cars","kinematics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on code by Alexey Borisov in 2016\n\n// This code runs once for each pixel.\n//   Starting in mainImage.\n//   Indexed by fragCoord in mainImage.\n\n// Use W, S, A & D.\n\n// Probably too much redundant code from the original.\n\nconst float OFFSET = 0.0;\nconst float IS_INITED = 0.5;\nconst float CAR_POSE = 1.5;\nconst float CAR_VEL = 0.0;\nconst float carLength = 0.045;\nconst float carWidth = 0.02;\nconst float carLengthInv = 1.0 / carLength;\nconst float carWidthInv = 1.0 / carWidth;\nconst float cameraScale = 2.2;\nconst int cars = 200;\n\nfloat get_wheels_alpha(vec2 uv, vec2 carPos, vec2 carDir, vec2 carLeft)\n{\n    float k = 0.0;\n    k = max(k, 1.0 - length((uv + carDir * carLength * 0.65 + carLeft * carWidth * 0.6) * 70.0));\n    k = max(k, 1.0 - length((uv - carDir * carLength * 0.65 + carLeft * carWidth * 0.6) * 70.0));\n    k = max(k, 1.0 - length((uv + carDir * carLength * 0.65 - carLeft * carWidth * 0.6) * 70.0));\n    k = max(k, 1.0 - length((uv - carDir * carLength * 0.65 - carLeft * carWidth * 0.6) * 70.0));\n    return k;\n}\n\nfloat get_car_window_alpha(vec2 uv, vec2 carPos, vec2 carDir, vec2 carLeft)\n{\n    float curv = cos(dot(uv, carLeft) * carWidthInv);\n    float k = clamp((1.0 - length(vec2(abs(dot(uv + carDir * 0.028 * curv, carDir) * carLengthInv * 12.0), abs(dot(uv, carLeft) * carWidthInv * 1.2)))) * 3.0, 0.0, 1.0);\n    k = max(k, clamp((1.0 - length(vec2(abs(dot(uv - carDir * 0.013 * curv, carDir) * carLengthInv * 9.0), abs(dot(uv, carLeft) * carWidthInv * 1.2)))) * 4.0, 0.0, 1.0));\n    return k;\n}\n\nfloat get_car_box_alpha(vec2 uv, vec2 carPos, vec2 carDir, vec2 carLeft)\n{\n    return 1.0 - max(abs(dot(uv, carDir) * carLengthInv), abs(dot(uv, carLeft) * carWidthInv));\n}\n\nvec3 render_car(vec3 backgroundColor, vec3 carColor, vec2 uv, vec2 carPos, vec2 carDir)\n{\n    uv -= carPos;\n    vec2 carLeft = vec2(-carDir.y, carDir.x);\n    float k = get_wheels_alpha(uv, carPos, carDir, carLeft);\n    backgroundColor = mix(\n        backgroundColor,\n        vec3(1.0, 1.0, 1.0),\n        clamp(k * 20.0, 0.0, 1.0));    \n    k = get_car_box_alpha(uv, carPos, carDir, carLeft);\n    vec3 res = mix(backgroundColor, carColor, clamp(k * 20.0, 0.0, 1.0));\n    res = mix(res, carColor * 0.6, get_car_window_alpha(uv, carPos, carDir, carLeft));\n    return res;\n}\n\nvec3 car_color_from_index(int i)\n{\n    return abs(vec3(\n        cos(float(i) * 6.3) - 0.1001,\n        cos(float(i) * 82.0) - 0.1,\n        cos(float(i) * 33.0) - 0.1));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    vec2 cameraPos = texture(iChannel1, vec2(CAR_POSE, 0.0) / iResolution.xy).xy * 0.95;    \n\tvec2 uv = (fragCoord.xy * cameraScale) / (iResolution.x) - vec2(cameraScale * 0.5, cameraScale * 0.25) + cameraPos;\n\t\n    vec3 color = vec3(\n    \tmod(uv.y, 0.25) * 1.5,\n\t\t0.1 + (fract(uv.x * 2.0) > 0.5 ? 0.05 : 0.0),\n\t\t0.1);\n\t\n    // draw cars\n    for (int i = 0; i < cars; i++)\n    {\n        float carIdx = float(i) + OFFSET;\n    \tvec4 carPose = texture(iChannel1, vec2(CAR_POSE, carIdx) / iResolution.xy);\n        if (length(uv - carPose.xy) < carLength)\n        {\n    \t\tvec2 carPos = carPose.xy;\n    \t\tvec2 carDir = carPose.zw;\n\t        vec3 carColor = car_color_from_index(i);\n\t    \tcolor = render_car(color, carColor, uv, carPos, carDir);\n        }\n    }\n    \n\tfragColor = vec4(color.r, color.g, color.b, 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Based on code by Alexey Borisov in 2016.\n// Thanks to jadoo for the help.\n\n// I think each pixel in \"Buf A\" is a car.\n//   Starting in mainImage.\n//   Indexed by fragCoord in mainImage.\n\n// Probably too much redundant code from the original.\n\nconst float PI = 3.141592653;\n\nconst float OFFSET = 0.1;\n\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_R = 82.5 / 256.0;\nconst float KEY_LEFT = 37.5 / 256.0;\nconst float KEY_UP = 38.5 / 256.0;\nconst float KEY_DOWN = 40.5 / 256.0;\nconst float KEY_RIGHT = 39.5 / 256.0;\n\nconst float IS_INITED = 0.5;\nconst float CAR_POSE = 1.5;\nconst float CAR_VEL = 2.5;\nconst float MAX_SPEED = 1.2;\nconst float carLength = 0.045;\nconst float carWidth = 0.02;\n\nconst int cars_int = 200;\nconst float cars_float = 200.0;\n\nfloat is_key_pressed(float key_code)\n{\n    return texture(iChannel0, vec2((key_code), 0.0)).x;\n}\n\nvec4 get_val(float variable, float index)\n{\n    return texture(iChannel1, vec2(variable + OFFSET, index) / iResolution.xy);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // what does this do?\n    fragColor = vec4(0.45, 0.0, 0.0, 1.0);\n    float resolutionHash = iResolution.x;\n    float carIdx = fragCoord.y + OFFSET;\n    if (abs(get_val(IS_INITED, carIdx).x - resolutionHash) > 8.0\n        || is_key_pressed(KEY_R) > 0.5)\n    {\n        if (fragCoord.x < ceil(IS_INITED))\n            fragColor = vec4(resolutionHash, 0, 0, 1);\n        else if (fragCoord.x < ceil(CAR_POSE))\n        {\n            fragColor = vec4(1.2 + carIdx * 0.094 + (fract(carIdx * 0.5) - 0.2) * 0.2, 1.85 - carIdx * 0.074, -1.0, 0.8);\n            fragColor.zw = normalize(fragColor.zw);\n        }\n        else if (fragCoord.x < ceil(CAR_VEL))\n            fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n            else\n                fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n    \n    else\n    {\n        vec4 carPose = get_val(CAR_POSE, carIdx);\n        vec2 carPos = carPose.xy;\n        vec2 carDir = carPose.zw;\n        vec2 carLeft = normalize(vec2(-carDir.y, carDir.x));\n        vec3 carVel3 = get_val(CAR_VEL, carIdx).xyz;\n        vec2 carVel = carVel3.xy;\n        float carOmega = carVel3.z;\n\n        // Detect dt manually,\n        // this is workaround for iTimeDelta issue\n        float timeLoop = mod(iTime, 128.0);\n        float dt = clamp(timeLoop, 0.01, 1.0 / 30.0);\n\n        carOmega *= 0.85 - (dt - 1.0 / 60.0) * 11.0;\n\n        // player driver\n        if (carIdx <= 1.0) // remove line to auto-drive\n        {\n            if (is_key_pressed(KEY_W) > 0.5 || is_key_pressed(KEY_UP) > 0.5)\n                carVel += 1.0 * carDir * dt;\n            if (is_key_pressed(KEY_S) > 0.5 || is_key_pressed(KEY_DOWN) > 0.5)\n                carVel -= 1.0 * carDir * dt;\n            if (is_key_pressed(KEY_A) > 0.5 || is_key_pressed(KEY_LEFT) > 0.5)\n            {\n                carOmega += 6.0 * dt;\n                carVel *= 0.999;\n            }\n            if (is_key_pressed(KEY_D) > 0.5 || is_key_pressed(KEY_RIGHT) > 0.5)\n            {\n                carOmega -= 6.0 * dt;\n                carVel *= 0.999;\n            }\n        }\n\n        // bot drivers\n        else\n        {\n            carVel = (carVel + carDir * dt) * 0.9999;\n            vec2 wishPos = vec2(0.0, 2.5);\n            vec2 wishDir = normalize(wishPos - carPos);\n            carOmega +=\n                100.0 *\n                clamp(dot(wishDir, carLeft), -1.0, 1.0);\n        }\n\n        carOmega = clamp(carOmega, -1.0, 1.0);\n        carDir += carLeft * dt * min(length(carVel) * 4.0 * carOmega, 2.0);\n        carDir = normalize(carDir);\n\n        // collisions\n        {\n            for (int i = 0; i < cars_int; i++)\n            {\n                float secondIdx = float(i) + OFFSET;\n                if (abs(secondIdx - carIdx) > 0.5)\n                {\n                    vec4 secondPose = get_val(CAR_POSE, secondIdx);\n                    vec2 secondPos = secondPose.xy;\n                    vec2 secondDir = secondPose.wz;\n                    vec2 secondVel = get_val(CAR_VEL, secondIdx).xy;\n\n                    vec2 dir = normalize(carPos - secondPos);\n                    float cDist = (carLength - carWidth);\n                    float cWidth = carWidth * 2.1;\n                    float k = 0.0;\n                    k = max(k, (cWidth - length(carPos + cDist * carDir - secondPos - cDist * secondDir)) / cWidth);\n                    k = max(k, (cWidth - length(carPos - cDist * carDir - secondPos - cDist * secondDir)) / cWidth);\n                    k = max(k, (cWidth - length(carPos + cDist * carDir - secondPos + cDist * secondDir)) / cWidth);\n                    k = max(k, (cWidth - length(carPos - cDist * carDir - secondPos + cDist * secondDir)) / cWidth);\n                    k = max(k, (cWidth - length(carPos - cDist * carDir - secondPos)) / cWidth);\n                    k = max(k, (cWidth - length(carPos + cDist * carDir - secondPos)) / cWidth);\n\n                    carPos += dir * 0.02 * k;\n                    carVel += dir * 0.2 * k;\n                    carDir = normalize(carDir + secondDir * 0.1 * k);\n                }\n            }\n        }\n\n        // friction\n        {\n            float carSpeed = min(length(carVel), MAX_SPEED * 1.1);\n            float fr = carSpeed / MAX_SPEED;\n            carSpeed = max(carSpeed - dt * (0.1 + fr * fr * fr), 0.0);\n            if (carSpeed > 0.00001)\n                carVel = carSpeed * normalize(carVel + carDir * dt * 4.0);\n        }\n\n        carPos += carVel * dt;\n\n        // what does this do?\n        if (fragCoord.x < ceil(IS_INITED))\n            fragColor = vec4(resolutionHash, 1, 1, 1);\n        else if (fragCoord.x < ceil(CAR_POSE))\n        {\n            fragColor.xy = carPos;\n            fragColor.zw = carDir;\n        }\n        else if (fragCoord.x < ceil(CAR_VEL))\n            fragColor = vec4(mix(carVel, carVel3.xy, 0.25), carOmega, 0.0);\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}