{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// For performance, because I didn't need the extra precision\nprecision mediump float;\n\nstruct Ray\n{\n\tvec3 origin;\n\tvec3 direction; // assumed to be a unit vector\n};\n\t\nconst float MARCHES =100.0;\nconst float SHADOW_MARCHES = 50.0;\n\n// max terrain height\nconst float MAX_H = 1.3;\n\n// camera\nconst float CAMERA_HEIGHT = MAX_H;\nconst float CAMERA_PITCH_DEG = 45.0;\n\n// sky color\nconst vec4 SKY = vec4(1.0,1.0,1.0,1.0);\n\n// terrain texture scale\nconst float SCALE = 20.0;\n\n// shadowing\nconst float SHADOW_ANGLE_DEG = 170.0;\n\n\n// calcuations\nconst vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\nconst vec4 BLACK = vec4(0.0, 0.0, 0.0, 1.0);\nconst float INF = 1000000.0; // arbitrarily large number\nfloat CAMERA_PITCH_COS_RAD = 0.9063077870366499; //cos(radians(CAMERA_PITCH_DEG));\nfloat CAMERA_PITCH_SIN_RAD = 0.42261826174069944; //sin(radians(CAMERA_PITCH_DEG));\nfloat NEG_CAMERA_PITCH_SIN_RAD = -0.42261826174069944;\nconst float INV_SCALE = 1.0 / SCALE;\nconst float FD = 2.1583468527305348600363230610125;\nvec3 SHADOW_DIRECTION = vec3(cos(radians(SHADOW_ANGLE_DEG)), 0.0, sin(radians(SHADOW_ANGLE_DEG)));\n\n\n// codez...\n\nvec3 ShadowDirection()\n{\n\treturn \n\t\tmat3(cos(iTime/2.), -1.0 * sin(iTime/2.), 0.0, sin(iTime/2.), cos(iTime/2.), 0.0, 0.0, 0.0, 1.0)\n\t\t*\n\t\tSHADOW_DIRECTION;\n}\n\nbool TerrainMiss(Ray ray)\n{\n\treturn \n\t\t(ray.origin.z >= MAX_H && ray.direction.z >= 0.0) ||\n\t\t(ray.origin.z <= 0.0 && ray.direction.z <= 0.0);\n}\n\nRay CastRay(Ray ray, float dist)\n{\n\treturn Ray(ray.origin + ray.direction * dist, ray.direction);\n}\n\n\n\nvec4 TerrainColor(sampler2D sampler, vec3 pos)\n{\n\treturn texture(sampler, INV_SCALE * pos.xy) + 0.25 * texture(sampler, INV_SCALE * 5.0 * pos.xy);\n}\n\nfloat TerrainHeight(sampler2D sampler, vec3 pos)\n{\n\treturn length(TerrainColor(sampler, pos))/3.0 * MAX_H;\n}\n\nfloat ShadowAmount(vec3 pos)\n{\n\tvec3 shadowDirection = ShadowDirection();\n\tRay shadowRay = Ray(pos, shadowDirection);\n\tfloat delt = MAX_H / SHADOW_MARCHES / abs(shadowDirection.z);\n\t\n\tfor(float t = 0.0; t < INF; t++)\n\t{\n\t\tif (t > SHADOW_MARCHES)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfloat dist = delt * (t + SHADOW_MARCHES / MARCHES);\n\t\tRay ray = CastRay(shadowRay, dist);\n\t\t\n        float terrain_height = TerrainHeight(iChannel0, ray.origin);\n\t\tif (ray.origin.z <= terrain_height)\n\t\t{\n            float backup_z = (ray.origin.z - terrain_height);\n            dist = dist - backup_z;\n\t\t\treturn smoothstep(0.8,0.6,0.1*backup_z);\n\t\t}\n\t}\n\t\n\treturn 0.0;\n}\n\nvec4 RayMarch(Ray initialRay)\n{\n\tif (TerrainMiss(initialRay))\n\t{\n\t\treturn SKY;\n\t}\n\t\n\t// raycast directly to MAX_H if above MAX_H and casting downwards\n\tif (initialRay.origin.z > MAX_H && initialRay.direction.z < 0.0)\n\t{\n\t\tinitialRay = CastRay(initialRay, (initialRay.origin.z - MAX_H) / abs(initialRay.direction.z));\n\t}\n\t\n\tfloat delt = MAX_H / MARCHES / abs(initialRay.direction.z);\n\t\n\tfor(float t = 0.0; t <= MARCHES;  t++)\n\t{\t\t\t\t\n\t\tfloat dist = delt * t;\n\t\tRay ray = CastRay(initialRay, dist);\n\t\t\n\t\t// We marched our way right out of the terrain bounds...\n\t\tif (TerrainMiss(ray))\n\t\t{\n\t\t\treturn SKY;\n\t\t}\n\t\t\n\t\tif (ray.origin.z < TerrainHeight(iChannel0, ray.origin))\n\t\t{\n\t\t\treturn mix(TerrainColor(iChannel0, ray.origin), BLACK, ShadowAmount(ray.origin));\n\t\t}\n\t}\n\t\n\treturn RED;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// change pixel coordinate into world coordinates\n\tvec3 uv = vec3(fragCoord.xy / iResolution.xx, FD) - vec3(0.5, 0.5 * iResolution.y / iResolution.x, 0.0);\n\t\n\t// swizzle into standard coordinate system, so that z is up\n\tuv = uv.xzy;\n\t\n\tvec3 dir = normalize(mat3(1.0, 0.0, 0.0, 0.0, CAMERA_PITCH_COS_RAD, NEG_CAMERA_PITCH_SIN_RAD, 0.0, CAMERA_PITCH_SIN_RAD, CAMERA_PITCH_COS_RAD) * uv);\n\t\n\t// animate the camera\n\tvec3 pos = uv + vec3(1.0, 1.0 * iTime, CAMERA_HEIGHT);\n\t\n\t// raymarch the terrain\n\tfragColor = RayMarch(Ray(pos,dir));\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsB3Wz","date":"1385711441","viewed":271,"name":"Shadowed Terrain","username":"kp1197","description":"experimental shadowing on a terrina raymarcher","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["terrain","raymarch","shadowed"],"hasliked":0,"parentid":"","parentname":""}}