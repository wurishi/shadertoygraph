{"ver":"0.1","info":{"id":"MsGXD1","date":"1464252173","viewed":726,"name":"Real raytrace in 3D","username":"LaBodilsen","description":"As a comparison to my \t[url=https://www.shadertoy.com/view/MscXDX]Faux raytrace in 2D[/url], i wanted so see how well it compared to real raytracing,  so i recreated the same scene with raytracing. \n\nthanks to all authors of the original shaders..","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["3d","tutorial","raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Derived from the following shaders\n\nMain Raytracer from: \t  \t\t\t https://www.shadertoy.com/view/4ds3zs\nSpecular highlight from:  \t\t\t https://www.shadertoy.com/view/XllGRf\nChecker board floor and shadow from: https://www.shadertoy.com/view/lslXz8\nReflections from: \t\t\t\t\t https://www.shadertoy.com/view/lsfGWS\n*/\n\nfloat iSphere(in vec3 ro, in vec3 rd, in vec4 sphere)\n{\n    // a sphere centered at the origin has equation |xyz| = r\n    // meaning, |xyz|^2 = r^2, meaning <xyz, xyz> = r^2\n    // now, xyz = ro + t*rd, therefore |ro|^2+|t*rd|^2 + 2<ro, rd> t - r^2 = 0\n\t// |rd| = 1 (normalized) so equation reduce to |ro|^2+ t^2 + 2<ro, rd> t - r^2 = 0\n    // which is a quadratic equation, so\n\n    vec3 oc = ro - sphere.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - sphere.w*sphere.w;\n    float h = b*b - c;\n    if(h <0.0) return -1.0; //no intersection\n\n    //pick smaller one(i.e, close one)\n    //not (-b+sqrt(h)) /2\n    float t = (-b - sqrt(h));\n    return t;\n}\n\nvec3 nSphere(in vec3 pos, in vec4 sphere)\n{\n    //sphere center at (l, m, n) radius r\n    //normal at intersect point N= ( (x-l)/r, (y-m)/r, (z-n)/r )\n    return (pos - sphere.xyz)/sphere.w;\n}\n\nfloat iPlane(in vec3 ro, in vec3 rd)\n{\n    //equation of a plane, y=0 = ro.y+t*rd.y\n    // t = -ro.y/rd.y\n    return ro.y-.31/rd.y;  //-31 = plane y position\n}\nvec3 nPlane(in vec3 pos)\n{// normal of plane\n    return vec3(0.0, 1.0, 0.0);\n}\n\n\t//sphere center + movement\n\tvec4 sphere1 = vec4(-.143, -.05, .95, .3);\n\nfloat intersect(in vec3 ro, in vec3 rd, out float resT)\n{\n    resT = 1000.0;\n    float id = -1.;\n    float tsph = iSphere(ro, rd, sphere1);// intersect with a sphere\n    float tpla = iPlane(ro, rd);//intersect with a plane\n    if(tsph >0.0)//if intersect with sphere\n    {\n        id  = 1.;\n        resT = tsph;\n    }\n    if(tpla > 0.0 && tpla < resT)\n    {//if intersect with plane and nearer than sphere or -1\n        id = 2.;\n        resT = tpla;\n    }\n    return id;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //uv are the pixel coordinates, from -1 to 1\n    vec2 uv = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    float time = iTime*.15;\n    //we generate a ray with origin \"ro\" and direction \"rd\"\n    vec3 ro = vec3(.0, .0, 2.);\n\n    //Ray direction \n    vec3 rd = normalize(vec3( uv-vec2(0.,0.),-2.));\n\n    //we intersect the ray with the 3d scene\n    float t;\n    float id = intersect (ro, rd, t);\n    \n    //intersect position\n\tvec3 pos = ro + t*rd;\n\n    //light and direction\n    vec3 light = vec3(1.5, 1.75, 3.);\n    vec3 lightDir = normalize(light - pos);\n\n    //we draw gradien black to red, by default\n    vec3 col = vec3(.8-sqrt(uv.y),0.,0.);\n    if (id == 1.)\n    {//if we hit the sphere\n        //normal at intersect position\n        vec3 normal = nSphere(pos, sphere1);\n        //diffuse light cos(theta) = dot(surface normal, direction to light)\n        float dif = clamp(dot(normal, lightDir), 0., 1.);//use clamp restrict cos to[0, 1]\n\n    \tvec3 r = reflect(lightDir, normal);\n    \tvec3 spe = pow(max(dot(r, rd), 0.0), 50.) * vec3(1.5);        \n\n        col = vec3(1.2, 0.0, 0.)*dif+spe;\n\n\t\t// Reflections\n\t\tfloat id = intersect(pos, reflect(rd, normal),t);\n        if (id == 2.){\n\n            pos = pos + t*reflect(rd, normal);\n        \tvec3 normal = nPlane( pos );\n\t\t\t//ambient occlusion reflection\n            float amb = smoothstep(0.0, 1.* sphere1.w, length(pos.xz-sphere1.xz));\n\t    \tfloat falloff = length(pos.xz-light.xz);            \n            col += amb*vec3(1.)*dot(normal, lightDir)/falloff;\n\n            // Shadow reflection\n            vec3 shadowRay = normalize(light - pos);\n\t\t\tfloat shadow = 1.0;\n\t\n\t\t\tif(intersect(pos, shadowRay, t) > 0.0)\n\t\t\tshadow = 0.5;\n\t        col *= shadow;\n\n            // move the floor plane\n            pos.z -= time;\n            pos.x += sin(time*5.)/4.;\n            // checkerboard texture\n\t        if(fract(pos.x / .5) > 0.5 ^^ fract(pos.z / .5) > 0.5)\n   \t\t\tcol = vec3(1.2, 0.0, 0.)*dif+spe;\n        }\n    }\n    else if (id == 2.)\n    {//we hit the plane\n        vec3 normal = nPlane( pos );\n        //ambient occlusion\n        float amb = smoothstep(0.0, 1.2* sphere1.w, length(pos.xz-sphere1.xz));\n        float falloff = length(pos.xz-light.xz)/2.;\n        col = vec3(amb*vec3(1.)*dot(normal, lightDir-pos)/falloff);\n\n\t\t// Shadows\n        vec3 shadowRay = normalize(light - pos);\n\t\tfloat shadow = 1.0;\n\t\n\t\tif(intersect(pos, shadowRay, t) > 0.0)\n\t\t\tshadow = 0.5;\n        col *= shadow;\n\n        // move the floor plane\n        pos.z -= time;\n        pos.x += sin(time*5.)/4.;\n        // checkerboard texture\n        if(fract(pos.x / .5) > 0.5 ^^ fract(pos.z / .5) > 0.5)\n   \t\tcol *= 0.;\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}