{"ver":"0.1","info":{"id":"7lyfRG","date":"1664723934","viewed":86,"name":"10.02.2022:Complementary","username":"g___r___e___g","description":"Inspired by https://thebookofshaders.com/edit.php?log=160909065147 and trying to work with complementary colors.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fragtober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.2832\n\n// blackle noise https://suricrasia.online/demoscene/functions/\n#define FK(k) floatBitsToUint(cos(k))^floatBitsToUint(k)\nfloat hash(vec2 p) {\n  uint x = FK(p.x); uint y = FK(p.y);\n  return float((x-y*y)*(x*x+y)-x)/4.28e9;\n}\n\n// iq Smooth HSV to RGB conversion https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv(in vec3 c)\n{\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat stepLinear(float begin, float end, float t) {\n  return clamp((t - begin)/(end - begin), 0., 1.);\n}\n\n// Easing functions and inspiration taken from\n// https://thebookofshaders.com/edit.php?log=160909065147\nfloat easeInOutCubic(float t) {\n   if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t * t;\n    } else {\n        return 0.5 * ((t -= 2.0) * t * t + 2.0);\n    }\n}\n\nfloat easeInOutExpo(float t) {\n    if (t == 0.0 || t == 1.0) {\n        return t;\n    }\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * pow(2.0, 10.0 * (t - 1.0));\n    } else {\n        return 0.5 * (-pow(2.0, -10.0 * (t - 1.0)) + 2.0);\n    }\n}\n\nvec3 drawColor(vec3 current, vec3 color, float x, float t) {\n  t = easeInOutExpo(stepLinear(0.5, 1.75, t));\n  float line = step(x, t);\n  return mix(current, color, line);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n\n  vec3 color = vec3(0);\n\n  float duration = 3.;\n  float time = iTime;\n\n  float i = floor(time / duration);\n  float t = mod(time, duration);\n  float t2 = max(t - duration / 16., 0.);\n  float t3 = max(t - duration / 8., 0.);\n  bool evenStep = (mod(i, 2.) == 0.);\n\n  vec2 offset = vec2(234.,1004.);\n  float seed = hash(vec2(i, 0) + offset);\n  float nextSeed = hash(vec2(i+1., 0) + offset);\n\n  float primaryTurns = seed;\n  float complementTurns = fract(primaryTurns + 0.5);\n  float nextTurns = nextSeed;\n\n  float tColor = easeInOutCubic(stepLinear(2.0, 3.0, t));\n  float layer = mix(complementTurns, nextTurns, tColor);\n\n  color = hsv(vec3(primaryTurns, 0.6, 0.9));\n  color = drawColor(color, hsv(vec3(layer, 0.6, 0.5)), uv.x, t);\n  color = drawColor(color, hsv(vec3(layer, 0.6, 0.7)), uv.x, t2);\n  color = drawColor(color, hsv(vec3(layer, 0.6, 0.9)), uv.x, t3);\n\n  fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}