{"ver":"0.1","info":{"id":"XtVGDt","date":"1512911193","viewed":511,"name":"Universe - Star factory","username":"iapafoto","description":"star factory made when working on [clickable starfield] https://www.shadertoy.com/view/XlcSDr","likes":17,"published":1,"flags":32,"usePreview":1,"tags":["starsun"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat time;\n\n\n// TODO planet with low sun density\n#define SUN_DENSITY 50.\n//#define SUN_3D_SURFACE_ON\n\n// mix noise for alive animation, full source\nvec4 hash4( vec4 n ) { return fract(sin(n)*1399763.5453123); }\nvec3 hash3( vec3 n ) { return fract(sin(n)*1399763.5453123); }\n\nfloat hash(in float n) { return fract(sin(n)*43758.5453123); }\nfloat hash( const in vec3 p ) {\n    return fract(sin(dot(p,vec3(127.1,311.7,758.5453123)))*43758.5453123);\n}\n\nvec3 hpos( vec3 n ) { return hash3(vec3(dot(n,vec3(157.0,113.0,271.0)),dot(n,vec3(271.0,157.0,113.0)),dot(n,vec3(113.0,271.0,157.0)))); }\n\nfloat noise4q(vec4 x) {\n\tvec4 n3 = vec4(0,.25,.5,.75);\n\tvec4 p2 = floor(x.wwww+n3);\n\tvec4 b = floor(x.xxxx+n3) + floor(x.yyyy+n3)*157.0 + floor(x.zzzz +n3)*113.0;\n\tvec4 p1 = b + fract(p2*.00390625)*vec4(164352., -164352., 163840., -163840.);\n\t     p2 = b + fract((p2+1.)*.00390625)*vec4(164352., -164352., 163840., -163840.);\n\tvec4 f1 = fract(x.xxxx+n3);\n\tvec4 f2 = fract(x.yyyy+n3);\n\tf1*=f1*(3.0-f1-f1);\n\tf2*=f2*(3.0-f2-f2);\n\tvec4 n1 = vec4(0,1.,157.,158.),\n\tn2 = vec4(113.,114.,270.,271.),\t\n\tvs1 = mix(hash4(p1), hash4(n1.yyyy+p1), f1),\n\tvs2 = mix(hash4(n1.zzzz+p1), hash4(n1.wwww+p1), f1),\n\tvs3 = mix(hash4(p2), hash4(n1.yyyy+p2), f1),\n\tvs4 = mix(hash4(n1.zzzz+p2), hash4(n1.wwww+p2), f1);\t\n\tvs1 = mix(vs1, vs2, f2);\n\tvs3 = mix(vs3, vs4, f2);\n\tvs2 = mix(hash4(n2.xxxx+p1), hash4(n2.yyyy+p1), f1);\n\tvs4 = mix(hash4(n2.zzzz+p1), hash4(n2.wwww+p1), f1);\n\tvs2 = mix(vs2, vs4, f2);\n\tvs4 = mix(hash4(n2.xxxx+p2), hash4(n2.yyyy+p2), f1);\n\tvec4 vs5 = mix(hash4(n2.zzzz+p2), hash4(n2.wwww+p2), f1);\n\tvs4 = mix(vs4, vs5, f2);\n\tf1 = fract(x.zzzz+n3);\n\tf2 = fract(x.wwww+n3);\n\tf1*=f1*(3.0-f1-f1);\n\tf2*=f2*(3.0-f2-f2);\n\tvs1 = mix(vs1, vs2, f1);\n\tvs3 = mix(vs3, vs4, f1);\n\tvs1 = mix(vs1, vs3, f2);\n\tfloat r=dot(vs1,vec4(0.25));\n\t//r=r*r*(3.0-2.0*r);\n\treturn r*r*(3.0-r-r);\n}\n\n// rays of a star\nfloat ringRayNoise(vec3 ray, vec3 pos, float r, float size, float anim)\n{\n  \tfloat b = dot(ray,pos);\n    vec3 pr = ray*b-pos;\n    float c = length(pr),\n     \t  s = max(0.,(1.-size*abs(r-c)));\n    pr = pr/c;\n    float n=.4, ns=1., nd = noise4q(vec4(pr*1.0,c-.5+.5*cos(anim)))*2.0;\n    if (c > r) {\n        n  = noise4q(vec4(pr*10.0,-anim+c));\n        ns = noise4q(vec4(pr*50.0,-anim*2.5+ c+c))*2.;\n    }\n    n *= n*nd*nd*ns;\n    return s*s*(s*s+n);\n}\n\n\n\n// -- Common Tools ----------------------------------------------------\n\n\nfloat noise(in vec3 x) {\n    vec3 p = floor(x), f = fract(x);\n\tf *= f*(3.-f-f);\n\tvec2 rg = texture(iChannel0, (((p.xy+vec2(37.,17.)*p.z) + f.xy)+.5)/256., -100.).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\nbool intersectSphere(in vec3 ro, in vec3 rd, in float r, out float dist, out float edge) {\n\tfloat b = dot(rd,-ro), d = b*b - dot(ro,ro) + r*r;\n\tif (d < 0.) return false;\n    edge = sqrt(d);\n\tdist = b - edge;\n\treturn dist > 0.;\n}\n\n\n// +------------------------------------------------------+\n// |                  Sun Lava effect                     |\n// +------------------------------------------------------+\n\n\n\nconst mat3 msun = mat3(0., .8, .6, -.8, .36, -.48, -.6, -.48, .64);\n\nfloat smoothNoise(in vec3 q){\n\tfloat f  = .5000*noise(q); q=msun*q*2.01;\n          f += .2500*noise(q); q=msun*q*2.02;\n          f += .1250*noise(q); q=msun*q*2.03;\n          f += .0625*noise(q);\n\treturn f;\n}\n\n// Adapted from FabriceNeyret2 shader Black Body Spectrum plank [https://www.shadertoy.com/view/4tdGWM]\nvec3 blackBodyColor(float k) {\n    float T = (k*2.)*16000.;\n    vec3 c = vec3(1.,3.375,8.)/(exp((19e3*vec3(1.,1.5,2.)/T)) - 1.); // Planck law\n    return c / max(c.r,max(c.g,c.b));  // chrominance\n}\n\n\nvec3 getSunColor(in vec3 p, in vec4 id, in float time) {\n    float lava = smoothNoise((p+vec3(time*.03))*SUN_DENSITY*(.5+id.z) );\n    return blackBodyColor(.1+2.*id.x*(1. - sqrt(lava))); // todo: le faire sur une constante\n}\n\n\n// +----------------------------------------+\n// |           VOLUMIC SUN SURFACE          |\n// +----------------------------------------+\n\n\n#ifdef SUN_3D_SURFACE_ON\n\nconst float VOLUMIC_SURFACE_TICKNESS  = .08; //.023;\nconst int   VOLUMIC_SURFACE_NB_STEP   = 20;//70;\nconst float VOLUMIC_SURFACE_RAY_STEP  = .011; //.0023;\nconst float VOLUMIC_SURFACE_INTENSITY = .02; //.022;\n\nvec4 getLightRays(vec3 ro, vec3 rd, in float time) {\n\tvec3 p = vec3(0.0);\n \tfloat edge, dist, r = 1. + VOLUMIC_SURFACE_TICKNESS;\n\tbool hit = intersectSphere(ro - p, rd, r, dist, edge);\n\tvec2 uv;\t\n\tvec4 sampleCol, c = vec4(0);\n\tif (hit) {\n\t\tvec3 pos = ro + rd*dist;\n        pos += rd*hash(pos)*VOLUMIC_SURFACE_RAY_STEP;\n        float light, d;\n        \n\t\t// ray-march into volume\n\t\tfor(int i=0; i<VOLUMIC_SURFACE_NB_STEP; i++) {\n            d = length(pos);\n            if (d<1. || d>=r || c.a>0.95 ) break;\n  \t\t\t\n            sampleCol.rgb = vec3(.5,.01,.08)+getSunColor(normalize(pos), time);\n            light = length(sampleCol.rgb);\n\n\t\t\tsampleCol.a = VOLUMIC_SURFACE_INTENSITY*(.7+.3*hash(pos+iTime))*(light*light)*(1.-(d-1.)/VOLUMIC_SURFACE_TICKNESS);\n\t\t\tsampleCol.rgb *= sampleCol.a;\t\t\t\t\n\t\t\tc += sampleCol*(1. - c.a);\n\n\t\t\tpos += rd*VOLUMIC_SURFACE_RAY_STEP;\n\t\t}\n\t}\t\n\treturn c;\n}\n\n#endif // SUN_3D_SURFACE_ON\n\n\n\n// +----------------------------------------+\n// |                  Sun                   |\n// +----------------------------------------+\n\n\nvec4 renderSun(in vec3 ro, in vec3 rd, in vec4 id, in float time) {\n    float SunTwinklingFactor;\n    SunTwinklingFactor = 1.-.03*cos(5.*time+2.*hash(time));\n    \n\t// Rotate view to integrate sun rotation \n\n    float cosSunRot = cos(1.6-time*.5*id.w), \n\t\t  sinSunRot = sin(1.6-time*.5*id.w);\n    \n    mat2 rotSun = mat2(cosSunRot, sinSunRot, -sinSunRot, cosSunRot);\n    vec3 rdSpace = rd.yzx;\n    \n    ro.zx *= rotSun;\n    rd.zx *= rotSun;\n\n\n    float dist, edge;\n    vec4 color = vec4(0);\n\n    if (intersectSphere(ro, rd, 1., dist, edge)) {\n        vec3  pos = ro+rd*dist,\n        \t  nor = normalize(pos);\n        float lDif = clamp(dot(nor, -rd), .01, 1.),\n\t\t\t  a = smoothstep(0., .2, edge); \n        vec3 oCol = getSunColor(pos, id, time);\n    \tcolor = vec4(oCol, a);\n    }\n    \n\n// Sun special effects -------------------------------------------\n        \n#ifdef SUN_3D_SURFACE_ON\n    vec4 textColor3 = getLightRays(ro, rd, time);\n    color = textColor3 + color*color.a*(1.-textColor3.a);\n#endif\n    \n    float s3 = ringRayNoise(rd,ro,1.0,6.-5.*id.y,50.+time);\n    color.xyz += mix(blackBodyColor(id.x),vec3(1.0,0.95,1.0),s3*s3-.3)*s3;\n\tcolor.a = clamp(color.a+s3, 0., 1.);\n    color.rgb *= SunTwinklingFactor;\n\treturn color;\n}\n\n\n\n\n// ---------------------------------------------------\n// Bers : https://www.shadertoy.com/view/MscXzn\nvec4 processSliders(in vec2 uv, out vec4 sliderVal) {\n    sliderVal = texture(iChannel1,vec2(0));\n    if(length(uv.xy)>1.) {\n    \treturn texture(iChannel1,uv.xy/iResolution.xy);\n    }\n    return vec4(0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    time = 300.+iTime;\n    \n    vec4 sliderVal;\n    vec4 cSlider = processSliders(fragCoord, sliderVal);\n\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((fragCoord.xy-0.5*iResolution.xy)/iResolution.y, 2.));\n\tvec3 ro = vec3(0, 0., -6.);\n    \n    vec4 sum = vec4(0.,0.,0.,0.); \n    \n\tvec4 col = renderSun(ro, rd, sliderVal, time);\n\t\n    sum += (1.-sum.a)*col*col.a;\n\n    //Apply slider overlay\n    fragColor = vec4(mix(sum.xyz,cSlider.rgb,cSlider.a), 1.);\n  \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Buffer A : slider management (this is not required)\n// Bers : https://www.shadertoy.com/view/MscXzn\n\n#define saturate(x) clamp(x,0.0,1.0)\n\nvec4 sliderVal = vec4(0.25,0.72,0.7,0.31); //Default slider values [0-1]\n\nvoid SLIDER_setValue(float idx, float val)\n{\n    if(idx<0.) return;\n    else if(idx<0.25) sliderVal[0] = saturate(val);\n\telse if(idx<0.50) sliderVal[1] = saturate(val);\n\telse if(idx<0.75) sliderVal[2] = saturate(val);\n\telse if(idx<1.00) sliderVal[3] = saturate(val);\n}\n\nfloat SLIDER_getValue(float idx)\n{\n    if     (idx<0.25) return sliderVal[0];\n    else if(idx<0.50) return sliderVal[1];\n    else if(idx<0.75) return sliderVal[2];\n    else if(idx<1.00) return sliderVal[3];\n\telse return 0.;\n}\n\nvoid SLIDER_init(vec2 mousePos, vec2 cMin, vec2 cMax )\n{\n    vec4 cPingPong = texture(iChannel0,vec2(0));\n    if(length(cPingPong)>0.001)\n        sliderVal = cPingPong;\n        \n    float width = cMax.x-cMin.x;\n    float height = cMax.y-cMin.y;\n    if(mousePos.x>cMin.x && mousePos.x<cMax.x &&\n       mousePos.y>cMin.y && mousePos.y<cMax.y )\n    {\n        float t = (mousePos.y-cMin.y)/height;\n        t = clamp(t/0.75-0.125,0.,1.); //25% top/bottom margins\n\t\tSLIDER_setValue((mousePos.x-cMin.x)/width, t);\n    }\n}\n\n//Returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat UTIL_distanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    //       p\n    //      /\n    //     /\n    //    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    //Scalar projection of ap in the ab direction = dot(ap,ab)/|ab| : Amount of ap aligned towards ab\n    //Divided by |ab| again, it becomes normalized along ab length : dot(ap,ab)/(|ab||ab|) = dot(ap,ab)/dot(ab,ab)\n    //The clamp provides the line seg limits. e is therefore the \"capped orthogogal projection\", and length(p-e) is dist.\n    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\n//uv = slider pixel in local space [0-1], t = slider value [0-1], ar = aspect ratio (w/h)\nvec4 SLIDER_drawSingle(vec2 uv, float t, vec2 ar, bool bHighlighted)\n{\n    const vec3  ITEM_COLOR = vec3(1);\n    const vec3  HIGHLIGHT_COLOR = vec3(0.2,0.7,0.8);\n    const float RAD = 0.05;  //Cursor radius, in local space\n    const float LW  = 0.030; //Line width\n    float aa  = 14./iResolution.x; //antialiasing width (smooth transition)\n    vec3 selectionColor = bHighlighted?HIGHLIGHT_COLOR:ITEM_COLOR;\n    vec3 cheapGloss   = 0.8*selectionColor+0.2*smoothstep(-aa,aa,uv.y-t-0.01+0.01*sin(uv.x*12.));\n    vec2 bottomCenter = vec2(0.5,0.0);\n\tvec2 topCenter    = vec2(0.5,1.0);\n    vec2 cursorPos    = vec2(0.5,t);\n    float distBar = UTIL_distanceToLineSeg(uv*ar, bottomCenter*ar, topCenter*ar);\n    float distCur = length((uv-cursorPos)*ar)-RAD;\n    float alphaBar = 1.0-smoothstep(2.0*LW-aa,2.0*LW+aa, distBar);\n    float alphaCur = 1.0-smoothstep(2.0*LW-aa,2.0*LW+aa, distCur);\n    vec4  colorBar = vec4(mix(   vec3(1),vec3(0),smoothstep(LW-aa,LW+aa, distBar)),alphaBar);\n    vec4  colorCur = vec4(mix(cheapGloss,vec3(0),smoothstep(LW-aa,LW+aa, distCur)),alphaCur);\n    return mix(colorBar,colorCur,colorCur.a);\n}\n\n\n#define withinUnitRect(a) (a.x>=0. && a.x<=1. && a.y>=0. && a.y<=1.0)\nvec4 SLIDER_drawAll(vec2 uv, vec2 cMin, vec2 cMax, vec2 muv)\n{\n    float width = cMax.x-cMin.x;\n    float height = cMax.y-cMin.y;\n    vec2 ar = vec2(0.30,1.0);\n    uv  = (uv -cMin)/vec2(width,height); //pixel Normalization\n    muv = (muv-cMin)/vec2(width,height); //mouse Normalization\n    if( withinUnitRect(uv))\n    {\n        float t = SLIDER_getValue(uv.x);\n\t\tbool bHighlight = withinUnitRect(muv) && abs(floor(uv.x*4.0)-floor(muv.x*4.0))<0.01;\n\t\tuv.x = fract(uv.x*4.0); //repeat 4x\n\t\tuv.y = uv.y/0.75-0.125; //25% margins\n        return SLIDER_drawSingle(vec2(uv.x*2.-.5, uv.y),t,ar,bHighlight);\n    }\n    return vec4(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cMinSliders = vec2(0.8,0.80);\n    vec2 cMaxSliders = vec2(1.0,1.0);\n    vec2 uvSliders = fragCoord.xy / iResolution.xy;\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    SLIDER_init(mousePos, cMinSliders, cMaxSliders);\n    vec4 cSlider = SLIDER_drawAll(uvSliders,cMinSliders, cMaxSliders, mousePos);\n    \n    if(length(fragCoord.xy-vec2(0,0))<1.) \n        fragColor = sliderVal;\n\telse fragColor = cSlider;\n}","name":"Buffer A","description":"","type":"buffer"}]}