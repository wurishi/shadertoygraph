{"ver":"0.1","info":{"id":"clsBWH","date":"1692895660","viewed":51,"name":"IADB","username":"rcmz","description":"IADB\nBased on : https://ggx-research.github.io/publication/2023/05/10/publication-iadb.html","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["iadb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, vec2 fragCoord) {\n    int fragIndex = int(iResolution.x) * int(fragCoord.y) + int(fragCoord.x);\n    if (fragIndex >= nbPoint) return;\n    \n    randSeed(uint(iDate.w * 1000.0) + uint(fragIndex));\n    \n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 xA = data.xy;\n    vec2 start = data.zw;\n    \n    for (int t = 0; t < stepPerFrame; t++) {\n        int f = iFrame * stepPerFrame + t;\n        if (f >= nbStep) break;\n        \n        if (f == 0) {\n            start = sampleSquare();\n            xA = start;\n        } else {\n            vec2 x0;\n            vec2 x1;\n\n            if (f == 1) {\n                x0 = xA;\n                x1 = sampleCircle();\n            } else {\n                float aPrev = float(f - 1) / float(nbStep - 1);\n                for (int e = 0; e < 10; e++) {\n                    x0 = sampleSquare();\n                    x1 = x0 + (xA - x0) / aPrev;\n                    if (isInCircle(x1)) break;\n\n                    x1 = sampleCircle();\n                    x0 = x1 + (xA - x1) / (1.0 - aPrev);\n                    if (isInSquare(x0)) break;\n                }\n            }\n\n            float a = float(f) / float(nbStep - 1);\n            xA = x0 * (1.0 - a) + x1 * a;\n        }\n    }\n    \n    fragColor.xy = xA;\n    fragColor.zw = start;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define nbPoint 30000\n#define nbStep 100000\n#define stepPerFrame 1000\n\nvec2 snap(vec2 v, vec2 s) {\n    return floor(v / s) * s;\n}\n\nfloat taxiDistance(vec2 a, vec2 b) {\n    return abs(a.x - b.x) + abs(a.y - b.y);\n}\n\nfloat maxDistance(vec2 a, vec2 b) {\n    return max(abs(a.x - b.x), abs(a.y - b.y));\n}\n\nuint randState;\n\nuint randU() {\n    uint state = randState;\n    randState = randState * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n\nvoid randSeed(uint seed) {\n    randState = seed;\n    randU();\n}\n\nfloat randF() {\n    return float(randU()) / 4294967295.0;\n}\n\nvec2 randVec2() {\n    return vec2(randF(), randF());\n}\n\nbool isInSquare(vec2 uv) {\n    return maxDistance(uv, vec2(0.5, 0.5)) < 0.5;\n}\n\nbool isInCircle(vec2 uv) {\n    return distance(uv, vec2(2.0, 0.5)) < 0.5;\n}\n\nvec2 sampleSquare() {\n    return randVec2();\n}\n\nvec2 sampleCircle() {\n    while (true) {\n        vec2 point = vec2(1.5, 0.0) + randVec2();\n        if (isInCircle(point)) {\n            return point;\n        }\n    }\n}\n\nvec3 squareColor(vec2 uv) {\n    ivec2 i = ivec2(uv * 9.0) % ivec2(2);\n    return vec3(uv, 1.0) * vec3((i.x ^ i.y) == 0 ? 1.0 : 0.5);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, vec2 fragCoord) {\n    int f = iFrame * stepPerFrame;\n    \n    if (f > nbStep) {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n        return;\n    }\n    \n    vec2 uv = fragCoord / iResolution.y;\n    uv = uv * 2.0 - 0.5;\n\n    fragColor.rgb = vec3(0.0);\n    if (isInSquare(uv)) fragColor.rgb = squareColor(uv);\n\n    for (int p = 0; p < (f < nbStep ? 100 : nbPoint); p++) {\n        int w = int(iResolution.x);\n        ivec2 i = ivec2(p % w, p / w);\n        \n        vec4 data = texelFetch(iChannel0, i, 0);\n        vec2 xA = data.xy;\n        vec2 start = data.zw;\n        \n        if (distance(uv, xA) < 0.005) {\n            fragColor.rgb = squareColor(start);\n            return;\n        }\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}