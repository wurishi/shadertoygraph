{"ver":"0.1","info":{"id":"4dffDf","date":"1498445496","viewed":133,"name":"Fundamental theorem of Calculus","username":"bryanmehall","description":"rendering for fundamental theorem of calculus","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["math"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DERIVATIVE 0.1\n#define FADE_IN_DX  0.3333\n#define FADE_IN_BOX  0.09 //change\n#define SLIDE_AND_SCALE  0.9\n#define MAX_VEC_WIDTH 3.0 //in px\n\nfloat eq(in float x)\n{\n    return x*x;\n}\nfloat inv(in float y){\n    return sqrt(y);\n}\nvec4 HSLtoRGB(in vec4 hsl) //hue cycle is 0-6\n{\n\tfloat h = hsl[0];\n    float s = hsl[1];\n    float l = hsl[2];\n    vec3 rgb = clamp( abs(mod(h+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn vec4(l + s * (rgb-0.5)*(1.0-abs(2.0*l-1.0)),1.0);\n}\n\nvec4 block(\n\tin float xVec, //0 to 1 opacity of xvec\n\tin float yVec, //0 to 1\n\tin float fill, //0 to 1\n    in float hue, //0 to 6\n    in float dx,\n    in vec4 bounds, //xmin, ymin, xmax, ymax\n\tin vec2 vecWidth,\n\tin vec2 uv\n\t)\n{\t\n\t//reflect vector for negative derivatives\n    \n    vec2 hv = step(bounds.xy, uv) * step(uv, bounds.zw);\n    float l = hv.x * hv.y*fill;\n    \n    return HSLtoRGB(vec4(hue,1.0,l,1.0));\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //inputs\n    vec2 plotBounds = vec2(2.0,4.0);\n    vec2 selectedRange = vec2(0.0,2.0);\n    float tween = iMouse.x/iResolution.x;\n    float udx = 0.2;//user defined unfiltered dx\n    //inputs\n\tvec2 uv = (fragCoord.xy / iResolution.xy)*plotBounds;\n    //do more math here for non zero origin\n    float dx = max(udx, 0.0001);//prevent div by 0 with min\n    float hueStep = 5.0/(plotBounds[0]);\n    //hue shift from 0 to 5 so it doesn't go back to red\n   \tvec4 color;\n    if (tween < DERIVATIVE) //origFunction\n    {\n        float xMin = max(floor(inv(uv.y)/dx)*dx, selectedRange[0]);\n        float xMax = selectedRange[1];\n        float yMin = eq(xMin);\n        float yMax = eq(xMin+dx);\n        float hue = hueStep*xMin;\n        vec4 bounds = vec4(xMin,yMin,xMax,yMax);\n        vec2 vw = vec2(3.0,3.0);//vector width\n        color= block(0.8,0.8,0.8,hue,dx,bounds,vw,uv);\n    }\n    //sliding and scaling\n    else if (tween > FADE_IN_BOX && tween < SLIDE_AND_SCALE){\n        float subTween = (tween-FADE_IN_BOX)/(SLIDE_AND_SCALE-FADE_IN_BOX);\n        //x min and max values for bin\n        float xBinMin  = max(floor(uv.x/dx)*dx, selectedRange[0]);\n        float xBinMax = min(xBinMin+dx, selectedRange[1]);\n        //initial y values\n        float yMin0 = eq(xBinMin);\n        float yMax0 = eq(xBinMax);\n        //final y values\n        float yMinf = 0.0;\n        float yMaxf = (eq(xBinMin+dx)-eq(xBinMin))/dx;\n        //interpolated yValues\n        float yMin = subTween*(yMinf-yMin0)+yMin0;\n        float yMax = subTween*(yMaxf-yMax0)+yMax0;\n        //switch to use conditional x min and max\n        vec4 bounds;\n        float hue;\n        if (uv.y>yMin){\n            bounds = vec4(xBinMin,yMin,xBinMax,yMax);\n            hue = hueStep*xBinMin;\n        } else {\n            bounds = vec4(xBinMin,yMin,xBinMax,yMax);\n            hue = 1.0;\n        }\n        \n        \n        vec2 vw = vec2(3.0,3.0);//vector width\n        color= block(0.8,0.8,0.5,hue,dx,bounds,vw,uv);\n        \n    }\n    else if (tween > SLIDE_AND_SCALE)//fully differentiated\n    {\t\t\t\n      \tfloat xMin = max(floor(uv.x/dx)*dx, selectedRange[0]);\n        float xMax = selectedRange[1];\n        float yMin = 0.0;\n        float yMax = (eq(xMin+dx)-eq(xMin))/dx;\n        float hue = hueStep*xMin;\n        vec4 bounds = vec4(xMin,yMin,xMax,yMax);\n        vec2 vw = vec2(3.0,3.0);//vector width\n        color= block(0.8,0.8,0.5,hue,dx,bounds,vw,uv);\n    } else {\n        color= vec4(0.0,1.0,1.0,1.0);\n    }\n\tfragColor = color;\n}\n","name":"Image","description":"","type":"image"}]}