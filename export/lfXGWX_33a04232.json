{"ver":"0.1","info":{"id":"lfXGWX","date":"1703847933","viewed":270,"name":"Moving forward scene with TAA","username":"morimea","description":"Simple scene moving forward.\nPathtracer with reprojection and TAA and textures.\n","likes":30,"published":1,"flags":48,"usePreview":1,"tags":["procedural","antialiasing","repetition","pathtracer","reprojection","temporal","taa","agx"],"hasliked":0,"parentid":"dldGWj","parentname":"TEMPLATE 3d pathtracer TAA"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// Created by Danil (2023+) https://github.com/danilw\n// License - License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// self https://www.shadertoy.com/view/lfXGWX\n\n\n// For Quality:\n// increase number of rays in Common \n\n// Control:\n// To move with keys - remove define move_forward in Common\n// WASD or arrows to move, mouse click to rotate camera\n\n// Camera collision - Collision_floor in BufA\n// Other options in Common.\n\n// using:\n// TAA from https://www.shadertoy.com/view/DsfGWX\n// RayTracing Domain Repetition https://www.shadertoy.com/view/NlycW1\n// Agx from https://www.shadertoy.com/view/cd3XWr\n\n// this pathtracer template https://www.shadertoy.com/view/dldGWj\n\n\n\n\n// remember to set mipmaps to iChannel3 in Image to use bloom\n#define use_bloom\n#ifdef use_bloom\nmat3 gaussianFilter = mat3(41, 26, 7,\n                           26, 16, 4,\n                           7,  4,  1) / 273.;\n// bloom\nvec3 bloom(float scale, float threshold, vec2 fragCoord, sampler2D ich){\n    // this does not alway work\n    // Shadertoy allocate mipmap once and forever - no way to know if they exit actually\n    // maybe this is another webbrower WebGL implementation feature/bug idk\n    if(textureSize(ich,1).x<10) return vec3(0.);\n    float logScale = log2(scale);\n    vec3 bloom = vec3(0);\n    for(int y = -2; y <= 2; y++)\n        for(int x = -2; x <= 2; x++)\n            bloom += gaussianFilter[abs(x)][abs(y)] * textureLod(ich, (fragCoord+vec2(x, y)*scale)/iResolution.xy, logScale).rgb;\n    return max(bloom - vec3(threshold), vec3(0.));\n}\n#endif\n\n#ifdef use_dynamic_TAA\n#ifdef enable_volume\n// from https://www.shadertoy.com/view/Xltfzj\nvec4 GaussianBlur(in vec2 fragCoord, sampler2D ich)\n{\n    float Directions = 6.0;\n    float Quality = 3.0;\n    float Size = 3.0;\n    vec2 Radius = Size/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 Color = texture(ich, uv);\n    for( float d=0.0; d<TAU; d+=TAU/Directions)\n    {\n\t\tfor(float i=1.0/Quality; i<=1.001; i+=1.0/Quality)\n        {\n\t\t\tColor += textureLod( ich, uv+vec2(cos(d),sin(d))*Radius*i, 0.);\t\t\n        }\n    }\n    Color /= Quality * Directions+1.;\n    return Color;\n}\n#endif\n#endif\n\n// volume raymarch mix color\n//----------------------------------------------\n#ifdef enable_volume\n\nvec3 raymarchVolume_image(vec3 backGround, float absorb, vec3 sunColor, float lDotV, float fogLitPercent){\n    \n    float phaseMie = hGPhase(lDotV, 0.8);\n    \n    vec3 c_fogColorLit = backGround+sunColor * phaseMie*0.5+0.0005*(0.5+sunColor*0.5);\n    const vec3 c_fogColorUnlit = vec3(0.);\n    \n    vec3 fogColor = mix(c_fogColorUnlit, c_fogColorLit, fogLitPercent*fogLitPercent*fogLitPercent);\n    return mix(fogColor, backGround, absorb);\n}\n#endif\n//----------------------------------------------\n\n\nvec3 ACESFilm(vec3 x);\nvec3 color2agx(vec3 col);\nvec4 toLinear(vec4 sRGB);\nvec3 srgb_encode(vec3 v);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 fc = fragCoord.xy;\n    vec3 texture_color = vec3(1.);\n#ifdef use_dynamic_TAA\n    vec3 color = texelFetch(iChannel3, ivec2(fc), 0).rgb;\n#else\n    vec3 color = texelFetch(iChannel2, ivec2(fc), 0).rgb;\n#ifdef enable_textures\n    texture_color = unpack_Unormfloat3x10(texelFetch(iChannel2, ivec2(fc), 0).a);\n#endif\n#endif\n    \n#ifndef enable_textures\n#ifdef enable_volume\n    \n    // unjittering volume fog\n    vec2 halton_px_shift = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    if(load(INPUT0,iChannel0)<1.) halton_px_shift =vec2(0.);\n\n#ifdef use_dynamic_TAA\n    //float absorb = texelFetch(iChannel3, ivec2(fc), 0).a;\n    float absorb = GaussianBlur(fc, iChannel3).a; //additional Blur on top of TAA\n    float fogLitPercent = GaussianBlur(fc-halton_px_shift, iChannel1).a;\n    //float fogLitPercent = textureLod(iChannel1, vec2(fc-halton_px_shift)/iResolution.xy, 0.).a;\n#else\n    float absorb = textureLod(iChannel2, vec2(fc-halton_px_shift)/iResolution.xy, 0.).a;\n    float fogLitPercent = textureLod(iChannel1, vec2(fc-halton_px_shift)/iResolution.xy, 0.).a;\n#endif\n\n    vec2 uv = (fragCoord)/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 ro;\n    vec3 rd;\n    SetCamera(uv, iChannel0, ro, rd, iResolution.xy);\n    \n    vec3 sunColor = calculateSunColor(lightDir.y);\n    float lDotV = dot(rd, lightDir);\n    color = raymarchVolume_image(color, absorb, sunColor, lDotV, fogLitPercent);\n#endif\n#endif\n    vec3 blom = vec3(0.);\n#ifdef use_bloom\n#ifdef use_dynamic_TAA\n    blom += bloom(.015 * iResolution.y, 0.002,fragCoord,iChannel3)*0.05;\n    blom += bloom(.05 * iResolution.y, 0.002,fragCoord,iChannel3)*0.025;\n#else\n    //blom += bloom(.015 * iResolution.y, 0.002,fragCoord,iChannel2)*0.05;\n    //blom += bloom(.05 * iResolution.y, 0.002,fragCoord,iChannel2)*0.025;\n#endif\n#endif\n    \n    //color = ACESFilm(color*texture_color+blom);\n    //color = srgb_encode(color);\n    \n    //color = toLinear(vec4(color, 1.0)).rgb;\n    color = color2agx(color*texture_color+blom);\n    \n\tfragColor = vec4(color, 1.0 );\n    \n}\n\n\n\nvec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 srgb_encode(vec3 v) {\n  return mix(12.92*v,1.055*pow(v,vec3(.41666))-.055,step(.0031308,v));\n}\n\n\n\n\n\n\n\n// Agx from https://www.shadertoy.com/view/cd3XWr\n#define AGX_LOOK 0\n\n// AgX\n// ->\n\n// Mean error^2: 3.6705141e-06\nvec3 agxDefaultContrastApprox(vec3 x) {\n  vec3 x2 = x * x;\n  vec3 x4 = x2 * x2;\n  \n  return + 15.5     * x4 * x2\n         - 40.14    * x4 * x\n         + 31.96    * x4\n         - 6.868    * x2 * x\n         + 0.4298   * x2\n         + 0.1191   * x\n         - 0.00232;\n}\n\nvec3 agx(vec3 val) {\n  const mat3 agx_mat = mat3(\n    0.842479062253094, 0.0423282422610123, 0.0423756549057051,\n    0.0784335999999992,  0.878468636469772,  0.0784336,\n    0.0792237451477643, 0.0791661274605434, 0.879142973793104);\n    \n  const float min_ev = -12.47393f;\n  const float max_ev = 4.026069f;\n\n  // Input transform\n  val = agx_mat * val;\n  \n  // Log2 space encoding\n  val = clamp(log2(val), min_ev, max_ev);\n  val = (val - min_ev) / (max_ev - min_ev);\n  \n  // Apply sigmoid function approximation\n  val = agxDefaultContrastApprox(val);\n\n  return val;\n}\n\nvec3 agxEotf(vec3 val) {\n  const mat3 agx_mat_inv = mat3(\n    1.19687900512017, -0.0528968517574562, -0.0529716355144438,\n    -0.0980208811401368, 1.15190312990417, -0.0980434501171241,\n    -0.0990297440797205, -0.0989611768448433, 1.15107367264116);\n    \n  // Undo input transform\n  val = agx_mat_inv * val;\n  \n  // sRGB IEC 61966-2-1 2.2 Exponent Reference EOTF Display\n  //val = pow(val, vec3(2.2));\n\n  return val;\n}\n\nvec3 agxLook(vec3 val) {\n  const vec3 lw = vec3(0.2126, 0.7152, 0.0722);\n  float luma = dot(val, lw);\n  \n  // Default\n  vec3 offset = vec3(0.0);\n  vec3 slope = vec3(1.0);\n  vec3 power = vec3(1.0);\n  float sat = 1.0;\n \n#if AGX_LOOK == 1\n  // Golden\n  slope = vec3(1.0, 0.9, 0.5);\n  power = vec3(0.8);\n  sat = 0.8;\n#elif AGX_LOOK == 2\n  // Punchy\n  slope = vec3(1.0);\n  power = vec3(1.35, 1.35, 1.35);\n  sat = 1.4;\n#endif\n  \n  // ASC CDL\n  val = pow(val * slope + offset, power);\n  return luma + sat * (val - luma);\n}\n\n// <-\n\n\n\nvec3 color2agx(vec3 col)\n{\n  //col = toLinear(vec4(col, 1.0)).rgb;\n\n  col = agx(col);\n  col = agxLook(col);\n  col = agxEotf(col);\n\n  return col;\n}\n\n\nvec4 toLinear(vec4 sRGB) {\n  bvec4 cutoff = lessThan(sRGB, vec4(0.04045));\n  vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n  vec4 lower = sRGB/vec4(12.92);\n  \n  return mix(higher, lower, cutoff);\n}\n\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// this exist just because Shadertoy has only 4 buffers\n\n// r is OBJ_ID\n// g is current depth\n// b is last depth\n\n// camera control use 1 alpha pixel per value\n\n// also in alpha saved noise\n// noise everywhere except MEMORY_BOUNDARY and top right pixel\n\n\n\n#define keyboard_texture iChannel3\n\nconst vec3 start_pos = vec3(4.1, 2.15, 0.);\nconst vec2 start_mouse = vec2(3.1415926/2., -0.1);\n\nconst float speed = 1.5;\n\n\nvoid store(ivec2 P, ivec2 ipx, float V, inout vec4 fc){ if(ipx==P) fc.a = V;}\n\nfloat key(int K, sampler2D kb){return step(0.5, texelFetch(kb, ivec2(K, 0), 0).x);}\n\n\n\nconst int Key_Backspace = 8, Key_Tab = 9, Key_Enter = 13, Key_Shift = 16, Key_Ctrl = 17, \nKey_Alt = 18, Key_Pause = 19, Key_Caps = 20, Key_Escape = 27, Key_Space = 32, \nKey_PageUp = 33, Key_PageDown = 34, Key_End = 35,Key_Home = 36, Key_LeftArrow = 37, \nKey_UpArrow = 38, Key_RightArrow = 39, Key_DownArrow = 40, Key_Insert = 45, \nKey_Delete = 46, Key_0 = 48, Key_1 = 49, Key_2 = 50, Key_3 = 51, Key_4 = 52,\nKey_5 = 53, Key_6 = 54, Key_7 = 55, Key_8 = 56, Key_9 = 57, Key_A = 65, Key_B = 66, \nKey_C = 67, Key_D = 68, Key_E = 69, Key_F = 70, Key_G = 71, Key_H = 72,Key_I = 73, \nKey_J = 74, Key_K = 75, Key_L = 76, Key_M = 77, Key_N = 78, Key_O = 79, Key_P = 80,\nKey_Q = 81, Key_R = 82, Key_S = 83, Key_T = 84, Key_U = 85,Key_V = 86, Key_W = 87, \nKey_X = 88, Key_Y = 89, Key_Z = 90, Key_LeftWindow = 91, Key_RightWindows = 92, \nKey_Select = 93, Key_Numpad0 = 96, Key_Numpad1 = 97, Key_Numpad2 = 98, Key_Numpad3 = 99,\nKey_Numpad4 = 100, Key_Numpad5 = 101, Key_Numpad6 = 102, Key_Numpad7 = 103, \nKey_Numpad8 = 104, Key_Numpad9 = 105, Key_NumpadMultiply = 106, Key_NumpadAdd = 107,\nKey_NumpadSubtract = 109, Key_NumpadPeriod = 110, Key_NumpadDivide = 111, Key_F1 = 112,\nKey_F2 = 113, Key_F3 = 114, Key_F4 = 115, Key_F5 = 116, Key_F6 = 117, Key_F7 = 118,\nKey_F8 = 119, Key_F9 = 120, Key_F10 = 121, Key_F11 = 122, Key_F12 = 123, \nKey_NumLock = 144, Key_ScrollLock = 145,Key_SemiColon = 186, Key_Equal = 187, \nKey_Comma = 188, Key_Dash = 189, Key_Period = 190, Key_ForwardSlash = 191, \nKey_GraveAccent = 192, Key_OpenBracket = 219, Key_BackSlash = 220, \nKey_CloseBraket = 221, Key_SingleQuote = 222;\n\n\n\nvec2 KeyboardInput(sampler2D kb) {\n    ivec4 inputs1 = ivec4(Key_UpArrow, Key_DownArrow, Key_RightArrow, Key_LeftArrow); //ARROWS\n    ivec4 inputs2 = ivec4(Key_W, Key_S, Key_D, Key_A);//WASD\n    //ivec4 inputs2 = ivec4(Key_E, Key_D, Key_F, Key_S);//ESDF\n    \n\tvec2 i = vec2(max(key(inputs1.z,kb),key(inputs2.z,kb))   - max(key(inputs1.w,kb),key(inputs2.w,kb)), \n                  max(key(inputs1.x,kb),key(inputs2.x,kb)) - max(key(inputs1.y,kb),key(inputs2.y,kb)));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*0.707106);\n}\n\nvec3 CameraDirInput(vec2 vm, sampler2D kb) {\n    vec2 m = vm;\n    m.y = -m.y;\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    return (rotY * rotX) * vec3(KeyboardInput(kb), 0.0).xzy;\n}\n\n\nvoid Collision_floor(vec3 prev, inout vec3 p) {\n    if (p.y < 1.0) p = vec3(prev.xz, max(1.0, prev.y)).xzy;\n}\n\nvec2 render_new_minDist(in vec2 fragCoord, vec2 halton_px_shift, vec3 ro, vec2 m) {\n\n    vec2 fc=fragCoord.xy;\n    fragCoord.xy += halton_px_shift;\n    \n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 rd;\n    SetCamera_m(uv, m, rd, iResolution.xy);\n    \n    HitInfo hit;\n\tbool rayHit = minDist(ro, rd, hit);\n    \n    return vec2(float(hit.obj_type)+0.5,hit.t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    ivec2 ipx = ivec2(fragCoord);\n    \n// moved because BufB moved here\n//--------------------\n    float llmc = load(LMC,iChannel0);\n    vec2 res_l = vec2(load(RES_LAST0,iChannel0),load(RES_LAST1,iChannel0));\n    bool input_registered = false;\n    bool res_ch = ivec2(res_l)!=ivec2(iResolution.xy);\n    input_registered = res_ch;\n    // resolution control\n    input_registered = input_registered||(load(ivec2(iResolution.xy)-1, iChannel0))<0.5;\n    //input_registered=true;\n    bool input_registered_TMP = input_registered;\n    \n    \n    vec3 target      = vec3(load(TARGET0, iChannel0),load(TARGET1, iChannel0),load(TARGET2, iChannel0));   \n    vec3 position    = vec3(load(POSITION0, iChannel0),load(POSITION1, iChannel0),load(POSITION2, iChannel0));\n    vec3 position_l = position;\n    \n    vec2 pm          = vec2(load(PMOUSE0, iChannel0),load(PMOUSE1, iChannel0));\n    vec3 vm          = vec3(load(VMOUSE0, iChannel0),load(VMOUSE1, iChannel0),load(VMOUSE2, iChannel0));\n    \n    bool is_init = load(INIT0, iChannel0)<1.;\n    if (iFrame == 0 || is_init) \n    {\n        target = start_pos;\n        position = start_pos;\n        position_l = start_pos;\n        pm = start_mouse;\n        vm.xy = start_mouse.xy;\n    }\n    vec3 ptarget = target;\n#ifdef move_forward\n    float ttmr = smoothstep(5.5,8.5,iTime)*iTimeDelta;\n    if (iMouse.z>0.0){llmc+=-.95*iTimeDelta*llmc-0.001;}else{llmc+=1.25*iTimeDelta*llmc+0.001;}\n    llmc=clamp(llmc,0.,1.);\n    ttmr*=llmc;\n    target.x+=ttmr*0.65;\n    float a = position.z-1.5;\n    float b = fract(position.x*0.44/20.);\n    a+=(1.-smoothstep(0.25,0.37,abs(b-0.5)))*2.3;\n    target.z+=ttmr*(0.071+0.2*smoothstep(0.75,0.9,b))*smoothstep(0.0,0.2,abs(a))*sign(-a)*smoothstep(10.7,10.8,position.x);\n    float c = 0.5*sin(position.x*0.07);\n    target.y+=ttmr*0.1*smoothstep(0.0,0.2,abs(position.y-2.3+c))*sign(-position.y+2.3-c);\n#else\n    target += CameraDirInput(vm.xy, keyboard_texture) * min(iTimeDelta,1./10.) * speed;\n#endif\n    //Collision_floor(ptarget, target);\n    \n    vec3 lp = position;\n    position += (target - position) * min(iTimeDelta,1./10.) * 5.0;\n\n    \n    if(length(abs(position)-abs(lp))>0.0001)input_registered=true;\n    \n    vec3 ro = position;\n    vec2 im = vec2(0.);\n    \n    if (iMouse.z>0.0) {\n        vec2 tpm = pm + (abs(iMouse.zw) - iMouse.xy)/iResolution.y;\n        input_registered=input_registered||(abs(tpm.x-vm.x)>.5/iResolution.y||abs(tpm.y-vm.y)>.5/iResolution.y);\n    \tim = tpm;\n    }\n    else {\n    \tim = vm.xy;\n    }\n    //input_registered=true;\n    \n#ifdef use_dynamic_TAA\n    vec2 halton = (halton(iFrame % 16 + 1) - 0.5f);\n#else\n    vec2 halton = input_registered?vec2(0.):halton(iFrame % 16 + 1) - 0.5f;\n#endif\n    \n    fragColor.rg = render_new_minDist(fragCoord, halton, ro, im);\n    fragColor.b = texelFetch(iChannel0,ipx,0).y;\n    fragColor.a = texelFetch(iChannel0,ipx,0).a;\n    \n    if(ipx==ivec2(iResolution.xy)-1){\n        fragColor.a=2.; // resolution control for pause case\n        return;\n    }\n//--------------------\n    \n    \n    float bnoise=fragColor.a;\n    if(input_registered_TMP||iFrame==0)\n    if (any(greaterThan(ipx, MEMORY_BOUNDARY))){bnoise=Bnoise(fragCoord+iDate.w*0.01);fragColor.a=bnoise;}\n    \n    if (any(greaterThan(ipx, MEMORY_BOUNDARY))) return;\n    \n    vec2 vm_l = vec2(load(VMOUSE0, iChannel0),load(VMOUSE1, iChannel0));\n    \n    if (iFrame == 0 || is_init) {\n        vm_l=start_mouse;\n        vec3 position_l=start_pos;\n        store(POSITION0, ipx, start_pos.x, fragColor); // ro\n        store(POSITION1, ipx, start_pos.y, fragColor);\n        store(POSITION2, ipx, start_pos.z, fragColor);\n        store(POSITION_last0, ipx, position_l.x, fragColor); // last_ro\n        store(POSITION_last1, ipx, position_l.y, fragColor);\n        store(POSITION_last2, ipx, position_l.z, fragColor);\n        store(TARGET0, ipx, start_pos.x, fragColor); // mouse look\n        store(TARGET1, ipx, start_pos.y, fragColor);\n        store(TARGET2, ipx, start_pos.z, fragColor);\n        store(VMOUSE0, ipx, start_mouse.x, fragColor); // virtual mouse (rotation_mat)\n        store(VMOUSE1, ipx, start_mouse.y, fragColor);\n        store(VMOUSE_last0, ipx, vm_l.x, fragColor); // last virtual mouse\n        store(VMOUSE_last1, ipx, vm_l.y, fragColor);\n        store(PMOUSE0, ipx, start_mouse.x, fragColor); // real mouse pos\n        store(PMOUSE1, ipx, start_mouse.y, fragColor);\n        store(INIT0, ipx, 2., fragColor); // is_init(0 false, 2 true)\n        store(RES_CHANGE, ipx, 0., fragColor); // 0 true 1 false\n        store(INPUT0, ipx, 2., fragColor); // key_pressed(0 false, 2 true) \n        store(RES_LAST0, ipx, iResolution.x, fragColor); // xy = last_resolution\n        store(RES_LAST1, ipx, iResolution.y, fragColor);\n        store(HALTON0, ipx, halton.x, fragColor);\n        store(HALTON1, ipx, halton.y, fragColor);\n        store(HALTON_last0, ipx, 0., fragColor);\n        store(HALTON_last1, ipx, 0., fragColor);\n        store(LMC, ipx, 0., fragColor);\n        return;\n    }\n    \n    store(LMC, ipx, llmc, fragColor);\n    store(TARGET0, ipx, target.x, fragColor);\n    store(TARGET1, ipx, target.y, fragColor);\n    store(TARGET2, ipx, target.z, fragColor);\n    store(POSITION0, ipx, position.x, fragColor);\n    store(POSITION1, ipx, position.y, fragColor);\n    store(POSITION2, ipx, position.z, fragColor);\n    \n    if (iMouse.z>0.0) {\n        vec2 tpm = pm + (abs(iMouse.zw) - iMouse.xy)/iResolution.y;\n        input_registered=input_registered||(abs(tpm.x-vm.x)>.5/iResolution.y||abs(tpm.y-vm.y)>.5/iResolution.y);\n    \tstore(VMOUSE0, ipx, tpm.x, fragColor);\n        store(VMOUSE1, ipx, tpm.y, fragColor);\n        store(VMOUSE2, ipx, 1., fragColor);\n    }\n    else if (vm.z > 0.5) {\n    \tstore(PMOUSE0, ipx, vm.x, fragColor);\n        store(PMOUSE1, ipx, vm.y, fragColor);\n        store(VMOUSE2, ipx, 0., fragColor);\n    }\n    store(POSITION_last0, ipx, position_l.x, fragColor);\n    store(POSITION_last1, ipx, position_l.y, fragColor);\n    store(POSITION_last2, ipx, position_l.z, fragColor);\n    store(VMOUSE_last0, ipx, vm_l.x, fragColor);\n    store(VMOUSE_last1, ipx, vm_l.y, fragColor);\n    \n    store(INPUT0, ipx, input_registered?2.:0., fragColor);\n    \n    \n    store(HALTON0, ipx, halton.x, fragColor);\n    store(HALTON1, ipx, halton.y, fragColor);\n    \n    vec2 halton_last = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    store(HALTON_last0, ipx, halton_last.x, fragColor);\n    store(HALTON_last1, ipx, halton_last.y, fragColor);\n    \n    store(RES_LAST0, ipx, iResolution.x, fragColor);\n    store(RES_LAST1, ipx, iResolution.y, fragColor);\n    \n    store(RES_CHANGE, ipx, res_ch?0.:1., fragColor);\n    \n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n\n#define move_forward\n\n#define AORays 8\n#define reflectionRays 6\n#define shadowRays 6\n\n// edit parameters\n// ---------------\n\n// when enabled 2nd light bounce (num of rays=AORays)\n#define sunlight_2nd_bounce\n\n#define enable_reflections\n#define reflection_color_emi\n\n// when ConeVector used in bounce light and emision light have not correct form \n// (compare to CosineWeightedSample, comment define below)\n#define use_ConeVector\n#define use_reproject_TAA\n\n// when turned off dymanic TAA - BufD is unused\n#define use_dynamic_TAA\n\n// texture or volume, texture use single float in BufB\n// and BufC copy to self alpha, just to have less texture reads in BufD that apply albedo TAA\n// albedo addition to color moved to BufD because TAA-pixel-jitter\n#define enable_textures\n\n// when enabled dynamic TAA - there visible \"border\" on volume-shadow and object edges\n// look enable_volume in Image - ther unjittering and TAA applied to one component\n// there is small 1-2 pixel border on object-volume, look/remove GaussianBlur\n//#define enable_volume\n\n#define volumeSteps 10\nconst float volume_fogDensity = .125;\n\nconst float camera_fov = 70.;\n\n// ---------------\n\n//#define ANGLE_loops 0\n#define ANGLE_loops min(iFrame,0)\n\n\n\n#define MAX_DIST 1000.\n#define MIN_DIST .0001\n\n\n// OBJ_ is >=0, not negative\n#define OBJ_SKY 0\n#define OBJ_FLOOR 1\n\n\n// since I also encode normal to object id, because normal of cube is 6 directions\n// every OBJ_RRD use +6 index for normal\n#define OBJ_RRD1 10\n#define OBJ_RRD2 20\n#define OBJ_RRD3 30\n#define OBJ_RRD4 40\n#define OBJ_RRD5 50\n#define OBJ_RRD6 60\n#define OBJ_RRD7 70\n#define OBJ_RRD8 80\n#define OBJ_RRD9 90\n\n// extra norma for RayTracing_Domain_Repetition_b in OBJ_RRD7 for id 6-9 look get_normal_OBJ_RRD\n#define enorm normalize(vec3(0.5,-1.,1.75))\n\n\n// look material_OBJ_RRDT - if you move light edit position of emission\nconst vec3 lightDir = normalize(vec3(-0.19, .5, 1.0));\n\n\n\nconst vec3 upVec = vec3(0.0, 1.0, 0.0);\n\n#define PI 3.141592653589793\n#define TAU 6.283185307179586\n#define c_goldenRatioConjugate 0.61803398875f\n\n\n\n// Camera related (just to have less code in buffers)\n// ---------------\nconst ivec2 MEMORY_BOUNDARY = ivec2(2, 14); //BufA reserved (and top right pixel)\n\nconst ivec2 RES_LAST0 = ivec2(0, 0);\nconst ivec2 RES_LAST1 = ivec2(0, 1);\nconst ivec2 INIT0 = ivec2(0, 2);\nconst ivec2 TARGET0 = ivec2(0, 3);\nconst ivec2 TARGET1 = ivec2(0, 4);\nconst ivec2 TARGET2 = ivec2(0, 5);\n\nconst ivec2 POSITION0 = ivec2(0, 6);\nconst ivec2 POSITION1 = ivec2(0, 7);\nconst ivec2 POSITION2 = ivec2(0, 8);\nconst ivec2 POSITION_last0 = ivec2(0, 9);\nconst ivec2 POSITION_last1 = ivec2(0, 10);\nconst ivec2 POSITION_last2 = ivec2(0, 11);\n\nconst ivec2 VMOUSE0 = ivec2(1, 0);\nconst ivec2 VMOUSE1 = ivec2(1, 1);\nconst ivec2 VMOUSE2 = ivec2(1, 2);\nconst ivec2 VMOUSE_last0 = ivec2(1, 3);\nconst ivec2 VMOUSE_last1 = ivec2(1, 4);\n\nconst ivec2 INPUT0 = ivec2(1, 5);\nconst ivec2 HALTON0 = ivec2(1, 6);\nconst ivec2 HALTON1 = ivec2(1, 7);\nconst ivec2 HALTON_last0 = ivec2(1, 8);\nconst ivec2 HALTON_last1 = ivec2(1, 9);\nconst ivec2 PMOUSE0 = ivec2(1, 10);\nconst ivec2 PMOUSE1 = ivec2(1, 11);\n\nconst ivec2 RES_CHANGE = ivec2(0, 12);\nconst ivec2 LMC = ivec2(1, 12);\n\nfloat load(ivec2 P, sampler2D self){return texelFetch(self, ivec2(P), 0).a;}\n\n// Camera\nmat3 rotationMatrix(vec2 m){\n  mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n  mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n  return rotY*rotX;\n}\n\nvoid SetCamera(vec2 uv, sampler2D caminfo, out vec3 ro, out vec3 rd, vec2 ires)\n{\n    ro = vec3(load(POSITION0,caminfo),load(POSITION1,caminfo),load(POSITION2,caminfo));\n    vec2 m = vec2(load(VMOUSE0,caminfo),load(VMOUSE1,caminfo));\n    m.y = -m.y;\n    float fov=camera_fov;\n    float aspect = ires.x / ires.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    rd = vec3(uv*screenSize, 1./aspect);\n    \n    //rd+=0.000001*(1.-abs(sign(rd)));\n    rd = normalize(rd);\n    rd = rotationMatrix(m) * rd;\n}\n\nvoid SetCamera_prev(vec2 uv, sampler2D caminfo, out vec3 ro, out vec3 rd, vec2 ires)\n{\n    ro = vec3(load(POSITION_last0,caminfo),load(POSITION_last1,caminfo),load(POSITION_last2,caminfo));\n    vec2 m = vec2(load(VMOUSE_last0,caminfo),load(VMOUSE_last1,caminfo));\n    m.y = -m.y;\n    float fov=camera_fov;\n    float aspect = ires.x / ires.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    rd = vec3(uv*screenSize, 1./aspect);\n    \n    //rd+=0.000001*(1.-abs(sign(rd)));\n    rd = normalize(rd);\n    rd = rotationMatrix(m) * rd;\n}\n\nvoid SetCamera_m(vec2 uv, vec2 m, out vec3 rd, vec2 ires)\n{\n    m.y = -m.y;\n    float fov=camera_fov;\n    float aspect = ires.x / ires.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    rd = vec3(uv*screenSize, 1./aspect);\n    \n    //rd+=0.000001*(1.-abs(sign(rd)));\n    rd = normalize(rd);\n    rd = rotationMatrix(m) * rd;\n}\n\n// ---------------\n\n\n\n// ---------------\n\n// material by object id\n// remember about dFd bugs\n// ---------------\n\nvoid material_OBJ_FLOOR(vec3 pos, vec3 norm, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    albedo = vec3(1.,1.,1.)*0.35;\n    emission = vec3(0.,0.,0.);\n    roughness = 0.4;\n    metalness = 0.35;\n}\n\n// I simulate light-reflections by emission - if you move light it need editing\nvoid material_OBJ_RRDT(vec3 pos, int obj, vec3 norm, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    albedo = vec3(1.,1.,1.);\n    emission = vec3(0.,0.,0.);\n    roughness = 0.64;\n    metalness = 0.31;\n    \n    if(obj==OBJ_RRD3+5){\n        float a = fract((pos.x)*0.44);\n        emission = vec3(1.,0.8,0.7)*step(pos.y,3.5)*step(abs(a-.28),0.095)*0.28;\n    }\n    \n    if(obj==OBJ_RRD8+5){\n        float a = fract((pos.x+0.61)*0.44);\n        emission = vec3(1.,0.8,0.7)*step(pos.y,5.)*step(1.055,pos.y)*step(abs(a-.28),0.09)*0.28;\n    }\n    \n}\n\n\nvec3 get_normal_OBJ_FLOOR(vec3 pos){\n    return vec3(0.,1.,0.);\n}\n\nvec3 decode_norm(int n);\nvec3 get_normal_OBJ_RRD(int n){\n    bool a = n>=OBJ_RRD7&&n<OBJ_RRD7+10;\n    n=n%10;\n    a = a&&n>=6;\n    if(a){\n        if(n==6)return enorm;\n        else {\n            if(n==7)return -enorm;\n            else {\n                if(n==8)return vec3(-1.,1.,1.)*enorm;\n                else return vec3(-1.,1.,1.)*-enorm;\n            }\n        }\n        \n    }\n    return decode_norm(n);\n}\n\n// ---------------\n\n\n\n// sky\n//----------------------------------------------\n\nconst float sunAngularDiameter = .25;\n\nconst float sunIluminance = 2.5;\n\nconst float goldenAngle = 2.3999632297286533;\n\n// sky from https://www.shadertoy.com/view/3dlSW7\n\nfloat hGPhase(float cosTheta, const float g){\n\tfloat g2 = g * g;\n    \n    return 0.25 * (1.0 - g2) * pow(g2 - 2.0 * g * cosTheta + 1.0, -1.5);\n}\n\nvec3 calculateSunColor(float sunZenith){\n\treturn mix(vec3(1.0, 0.4, 0.05), vec3(1.0), max(sunZenith, 0.0));\n}\n\nfloat calculateSun(float lDotV){\n    const float cosRad = cos(radians(sunAngularDiameter));\n    const float sunLuminance = sunIluminance / ((1.0 - cosRad) * TAU);\n    \n    return smoothstep(cosRad,cosRad*1.001, lDotV) * sunLuminance;\n}\n\nvec3 calculateSky(vec3 background, float lDotU, float lDotV){\n    float phaseMie = hGPhase(lDotV, 0.8);\n    \n    float zenith = max(lDotU, 0.0);\n    \n    float sunZenith = lightDir.y;\n    const vec3 topCol = vec3(0.1, 0.34, 1.0);\n    const vec3 bottomCol = vec3(1.0);\n    \n    vec3 sky = mix(topCol, (bottomCol + topCol), exp2(-zenith * 8.0));\n         sky += phaseMie * exp2(-zenith * 6.0);\n    \n    vec3 absorbColor = calculateSunColor(1.0 - exp2(-zenith * 2.0));\n    \n    sky = sky * mix(absorbColor * 0.9 + 0.1, vec3(1.0), sunZenith);\n\treturn background * absorbColor + sky * sunIluminance * (1.0 - clamp(-sunZenith * 10.0, 0.0, 1.0));\t\n}\n\n//----------------------------------------------\n\n\n\n// pathtracing functions\n//----------------------------------------------\n\n// with ConeVector better visual result\n// ConeVector distribution, look this screenshots\n// https://danilw.github.io/GLSL-howto/vulkan_sh_launcher/upl_demos/pathtracer/ray_distr1.jpg\n// https://danilw.github.io/GLSL-howto/vulkan_sh_launcher/upl_demos/pathtracer/ray_distr2.png\n#ifdef use_ConeVector\n\nmat3 calculateTangentMatrix(vec3 direction){\n\tvec3 c1 = cross(direction, vec3(0.0, 0.0, 1.0));\n\tvec3 c2 = cross(direction, vec3(0.0, 1.0, 0.0));\n    \n    vec3 tangent = dot(c1, c1) > dot(c2, c2) ? c1 : c2;\n    vec3 biDir = cross(direction, tangent);\n    \n    return mat3(tangent, biDir, direction);\n}\n\nvec3 calculateConeVector(const float i, const float angularRadius, const int steps) {\n    float x = i * 2.0 - 1.0;\n    float y = i * float(steps) * 16.0 * 16.0 * goldenAngle;\n    \n    float angle = acos(x) * radians(angularRadius) * 1./PI;\n    float c = cos(angle);\n    float s = sin(angle);\n\n    return vec3(cos(y) * s, sin(y) * s, c);\n}\n\nvec3 calculateRoughSpecular(const float i, const int steps, float roughness) {\n    float r = roughness * roughness * roughness * roughness;\n    float x = (r * i) / max(1.0 - i,0.0001);\n    float y = i * float(steps) * 16.0 * 16.0 * goldenAngle;\n    //if(1.0 - i<0.)\n    //x = (r * i)*1000.;\n    float c = inversesqrt(x + 1.0);\n    float s = sqrt(x) * c;\n\n    return vec3(cos(y) * s, sin(y) * s, c);\n}\n\n#else\n\n// CosineWeightedSample\n\nfloat seed;\nfloat hash11_seed()\n{\n    float p=seed;\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    seed+=1.33;\n    return fract(p);\n}\n\nvec3 ortho(vec3 v) {\n  return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getCosineWeightedSample(vec3 dir, float radius) {\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = vec2(hash11_seed(), hash11_seed());\n\tr.x = r.x * 2.0 * PI;\n\tr.y = pow(r.y, radius);\n\tfloat oneminus = sqrt(abs(1.0-r.y*r.y));\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\n\n#endif\n//----------------------------------------------\n\n// reprojection\n//----------------------------------------------\n\nvec2 pos2uv(vec3 pos, sampler2D caminfo, vec2 ires){\n    vec3 ro_old = vec3(load(POSITION_last0,caminfo),load(POSITION_last1,caminfo),load(POSITION_last2,caminfo));\n    vec2 m_old = vec2(load(VMOUSE_last0,caminfo),load(VMOUSE_last1,caminfo))*vec2(1.,-1.);\n    vec3 td = pos - ro_old;\n    if(length(td)<0.0001)return vec2(-1.);\n    vec3 dir = normalize(td) * (rotationMatrix(m_old));\n    float fov=camera_fov;\n    float aspect = ires.x / ires.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    dir.z+=0.0001*(1.-abs(sign(dir.z)));\n    return dir.xy * (.5/screenSize) / dir.z ;\n}\n\nfloat distancePixel( vec2 prevFragCoord, vec3 pos, sampler2D samplerx, vec2 ires, vec3 p_ro, vec3 p_rd){\n    if(  min(ires.xy-1., prevFragCoord) != prevFragCoord\n      || max(vec2(0.)      , prevFragCoord) != prevFragCoord) return MAX_DIST;\n    \n    float prev_d = textureLod(samplerx, prevFragCoord/ires.xy,0.).b;\n    vec3 prevPos = p_ro + p_rd*prev_d;\n    return length(prevPos-pos);\n}\n\n\n#define PixelAcceptance 4.\n#define PixelCheckDistance .75\nvec4 previousSample(vec3 ro, vec3 pos, sampler2D caminfo, sampler2D last_pos_fbo, sampler2D last_color, vec2 ires){\n    vec2 old_halton_px_shift=vec2(load(HALTON_last0,caminfo),load(HALTON_last1,caminfo));\n    vec2 prevUv = pos2uv(pos, caminfo, ires) - old_halton_px_shift/ires.y;\n    vec2 prevFragCoord = prevUv * ires.y + ires.xy/2.0;\n    \n    vec2 pfc=vec2(0.);\n    vec2 finalpfc=vec2(0.);\n    float dist, finaldist = MAX_DIST;\n    for(int x = -1; x <= 1; x++){\n        for(int y = -1; y <= 1; y++){\n            pfc = prevFragCoord + PixelCheckDistance*vec2(x, y);\n            vec2 tuv = pfc/ires.xy * 2.0 - 1.0;\n            tuv.y *= ires.y/ires.x;\n            vec3 p_ro;\n            vec3 p_rd;\n            SetCamera_prev( tuv, caminfo, p_ro, p_rd, ires);\n            dist = distancePixel(pfc, pos, last_pos_fbo, ires, p_ro, p_rd);\n            if(dist < finaldist){\n                finalpfc = pfc;\n                finaldist = dist;\n            }\n      }\n    }\n    \n    if(finaldist < (PixelAcceptance/ires.y)*(length(pos-ro)))\n        return textureLod(last_color, finalpfc/ires.xy,0.);\n    return vec4(0.);\n}\n\n//----------------------------------------------\n\n\n\n\n\n\n// intersection template\n//----------------------------------------------\n\nstruct HitInfo {\n    float t;\n    vec3 norm;\n    vec4 color;\n    vec3 emisson;\n    float rough;\n    float metal;\n    int obj_type;\n};\n\n\nbool boxAABB(in vec3 dims, vec3 ro, vec3 rd) {\n    rd += 0.0001 * (1.0 - abs(sign(rd)));\n    vec3 n = ro / rd;\n    vec3 k = dims / abs(rd);\n    vec3 t1 = -k - n, t2 = k - n;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    return tN < tF && tF > 0.0;\n}\n\n\nbool PlaneIntersect(vec4 Plane, vec3 ro, vec3 rd, out float t, out vec3 norm) {\n    norm=vec3(0.,1.,0.);\n    t=-1.;\n    float dd = dot(rd, Plane.xyz);\n    if (dd == 0.0) return false;\n    float t1 = -(dot(ro, Plane.xyz) + Plane.w) / dd;\n    if (t1 < 0.0) return false;\n    norm = normalize(Plane.xyz);\n    t = t1;\n    return true;\n}\n\n\nvoid GroundIntersectMin(vec3 ro, vec3 rd, inout bool result, inout HitInfo hit, int obj) {\n    float tnew;\n    vec3 normnew;\n    vec4 pp=vec4(normalize(vec3(0.0, 1., 0.0)), 0.);\n    \n    // sunlight_2nd_bounce can be buggere here - visual bugs on floor\n    // +vec3(0.,1.,0.) - change y component to bigger, I do it in minDist, no idea why\n    \n    if (PlaneIntersect(pp, ro+vec3(0.,1.,0.), rd, tnew, normnew)) {\n        if (tnew < hit.t) {\n            vec3 tp = ro + tnew*rd;\n            if(tp.z<3.29+1.&&tp.z>-3.1-1.){\n                hit.t = tnew;\n                hit.norm = normnew;\n\n                hit.emisson = vec3(0.,0.,0.);\n                vec3 albedo;\n                material_OBJ_FLOOR(ro+rd*hit.t, hit.norm,  albedo, hit.emisson, hit.rough, hit.metal);\n\n                hit.color = vec4(albedo, 1.);\n                hit.obj_type = obj;\n                result = true;\n            }\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\n// base on https://www.shadertoy.com/view/NlycW1\n\nstruct its\n{\n\tfloat t;\n\tvec3 n;    //normal \n\t\n};\nconst its  NO_its=its(MAX_DIST,vec3(0.,1.,0.));\n\nstruct span\n{\n\tits n;\n\tits f;\n};\n\n//-----------Intersection functions--(based on Iq)------------------\nspan Inter(span a, span b)\n{\n   bvec4 cp = bvec4(a.n.t<b.n.t,a.n.t<b.f.t,a.f.t<b.n.t,a.f.t<b.f.t); \n   // if(b.n.t==NOHIT || a.n.t==NOHIT) return span(NO_its,NO_its);\n   \n   if(cp.x && cp.z) return span(NO_its,NO_its);\n   else if(cp.x && !cp.z && cp.w)  return span(b.n,a.f);\n   else if(cp.x && !cp.z && !cp.w) return b;\n   else if(!cp.x && cp.y &&  cp.w) return a;\n   else if(!cp.x && cp.y &&  !cp.w) return span(a.n,b.f);\n   else return span(NO_its,NO_its);\n}\n\nspan Sub(span a, span b)\n{\n   bvec4 cp = bvec4(a.n.t<b.n.t,a.n.t<b.f.t,a.f.t<b.n.t,a.f.t<b.f.t); \n   // if(a.n.t==NOHIT) return span(NO_its,NO_its);\n   // else if(b.n.t==NOHIT) return a;        \n   if     (cp.x && cp.z) return a;\n   else if(cp.x && !cp.z && cp.w)  return span(a.n,b.n);\n   else if(cp.x && !cp.z && !cp.w && b.n.t>0.) return span(a.n,b.n); \n   else if(cp.x && !cp.z && !cp.w && b.n.t<0.) return span(b.f,a.f); //+ secondary span =  span(b.f,a.f)\n   else if(!cp.x && cp.y && cp.w) return span(NO_its,NO_its);\n   else if(!cp.x && cp.y && !cp.w) return span(b.f,a.f);\n   else return a;\n   \n}\n\n// useful if transparent \nspan Union(span a, span b)\n{\n   bvec4 cp = bvec4(a.n.t<b.n.t,a.n.t<b.f.t,a.f.t<b.n.t,a.f.t<b.f.t); \n   if(b.n.t==MAX_DIST) return a;\n   else if(a.n.t==MAX_DIST) return b;   \n   else if(cp.x  && cp.z  && a.f.t>0.) return a;\n   else if(cp.x  && cp.z  && a.f.t<0.) return b;\n   else if(cp.x  && !cp.z && cp.w) return span(a.n,b.f);\n   else if(cp.x  && !cp.z && !cp.w) return a;\n   else if(!cp.x && cp.y  && cp.w) return b;\n   else if(!cp.x && cp.y  && !cp.w) return span(b.n,a.f);\n   else if(!cp.x && !cp.y  && a.f.t>0.) return b;\n   else /*if(!cp.x && !cp.y  && a.f.t<0.) */ return a;   \n}\n\nspan iSphere( in vec3 ro, in vec3 rd, float ra )\n{\n    vec3 oc = ro ;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0. ) return span(NO_its,NO_its); // no intersection\n    h = sqrt( h );\n    vec3 oNor =normalize(ro-(b+h)*rd); \n    vec3 fNor= normalize(ro-(b-h)*rd); \n    return span(its(-b-h,oNor) , its(-b+h,-fNor));\n}\n\nspan iBox( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1./rd; \n    vec3 n = m*ro;   \n    vec3 k = abs(m)*boxSize;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF ) return span(NO_its,NO_its); // no intersection\n    vec3 oNor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz); \n    vec3  fNor= sign(rd)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy); \n    return  span(its(tN,oNor) , its(tF,fNor));\n}\n\n// this is infinite long box\n// exist because Nvidia bugs https://www.shadertoy.com/view/NtfyD2\nspan iBox_2d( in vec3 ro, in vec3 rd, vec2 boxSize) \n{\n    rd+=0.000001*(1.-abs(sign(rd))); //fix against vertical line on middle\n    vec3 m = 1./rd; \n    vec3 n = m*ro;   \n    vec3 boxSize_t=vec3(1.,boxSize);\n    vec3 k = abs(m)*boxSize_t;\n    \n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( t1.y, t1.z );\n    float tF = min( t2.y, t2.z );\n    if( tN>tF ) return span(NO_its,NO_its); // no intersection\n    vec3 oNor = -sign(rd)*vec3(0.,step(t1.zy,t1.yz)); \n    vec3  fNor= sign(rd)*vec3(0.,step(t2.yz,t2.zy)); \n    return  span(its(tN,oNor) , its(tF,fNor));\n}\n\nspan iRBox( in vec3 ro, in vec3 rd, vec3 boxSize,mat3 rot  ) {\n\tmat3 txx = inverse( rot );   \n    span s= iBox(txx*ro,txx*rd,boxSize);\n    s.n.n=(rot*s.n.n).xyz;\n    s.f.n=(rot*s.f.n).xyz;    \n    return s;\n}\n\n\n//  plane with thickness h\nspan iPlane( in vec3 ro, in vec3 rd, in vec3 n ,float h)\n{\n    float d1= -dot(ro,n)/dot(rd,n),   d2= -(dot(ro-h*n,n))/dot(rd,n);\n    vec3  u = normalize(cross(n,vec3(0,0,1))), v = normalize(cross(u,n) );\n    vec3 oNor=n;\n    if(d1<d2) return span(its(d1,-oNor),its(d2,oNor));\n    return span(its(d2,oNor),its(d1,-oNor));\n}\n\n\nspan iCylinder( in vec3 ro, in vec3 rd, in vec3 ca, float cr )\n{\n    vec3  oc = ro ;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return span(NO_its,NO_its); //no intersection\n    h = sqrt(h);\n    vec2 t =vec2(-b-h,-b+h)/a;\n    vec2 d= vec2(dot(oc +t.x*rd,ca) ,dot(oc +t.y*rd,ca) );\n    vec3 nN=normalize( oc +t.x*rd -d.x*ca),nF=normalize( oc +t.y*rd -d.y*ca);\n    its iN= its( t.x, nN); //todo uv\n    its iF= its( t.y, nF);\n    return  span(iN , iF );   \n}\n\n\n\nvec3 opU( vec3 d, span s, inout vec3 normal, float mat ) {\n    its ix= s.n;   \n    //if(ix.t<0.) ix=s.f;\n    if( ix.t<d.y && ix.t>d.x) {\n        normal=ix.n;\n        d=vec3(d.x, ix.t, mat);\n    }\n\treturn d;\n}\n\nvec3 RayTracing_Domain_Repetition( in vec3 ro, in vec3 rd, out vec3 normal, float sc, float st, vec2 boxx) {\n    \n    vec3  d = vec3(MIN_DIST, MAX_DIST, 0.);\n    span s2,s3,s4;\n    s2= iBox_2d(ro,rd,boxx);\n    normal=vec3(0.,1.,0.);\n\n    if(s2.n.t<MAX_DIST){\n        float x = s2.n.t>0.? ro.x+ rd.x*s2.n.t:ro.x;\n        float xm = fract(x*sc),         \n              xf = floor(x*sc); \n              \n        // 2x visible only to single direction when Sub used\n        // add more loop iterations to see more layers repetitions when inside\n        for(int j=0; j<2;j++){\n            s3=  iPlane(ro-vec3((xf)/sc,0,0),rd,normalize(vec3(1.,0.,0.)),st);\n            s4=  Inter(s2,s3);\n            \n            d= opU(d,  s4,normal, xf);\n            xf+=sign(rd.x);\n        }\n\n    }\n    if(dot(rd,normal)>0.) normal=-normal;\n    return d;\n}\n\nvec3 RayTracing_Domain_Repetition_b( in vec3 ro, in vec3 rd, out vec3 normal, float sc, float st, vec2 boxx) {\n    \n    vec3  d = vec3(MIN_DIST, MAX_DIST, 0.);\n    span s2,s3,s4,s5;\n    s2= iBox_2d(ro,rd,boxx);\n    normal=vec3(0.,1.,0.);\n\n    if(s2.n.t<MAX_DIST){\n        float x = s2.n.t>0.? ro.x+ rd.x*s2.n.t:ro.x;\n        float xm = fract(x*sc),         \n              xf = floor(x*sc); \n              \n        // 2x visible only to single direction when Sub used\n        // add more loop iterations to see more layers repetitions when inside\n        for(int j=0; j<2;j++)\n        {\n            s3=  iPlane(ro-vec3((xf)/sc,0,0),rd,normalize(vec3(1.,0.,0.)),st);\n            s4=  Inter(s2,s3);\n            vec3 ix=vec3(float(int(xf)%2)*2.-1.,1.,1.);\n            s5=  iPlane(ro-vec3((xf+0.48)/sc,0.,-0.15),rd,ix*enorm,1.);\n            \n            s4=  Sub(s4,s5);\n            d= opU(d,  s4,normal, xf);\n            xf+=sign(rd.x);\n        }\n\n    }\n    if(dot(rd,normal)>0.) normal=-normal;\n    return d;\n}\n\n\n\nint encode_norm(vec3 n){\n    ivec3 na = ivec3(greaterThan(abs(n)+0.5,vec3(1.)));\n    ivec3 nb = ivec3(greaterThan((n)+0.5,vec3(1.)));\n    return na.x*nb.x+na.y*(2+nb.y)+na.z*(4+nb.z);\n}\n\nvec3 decode_norm(int n){\n    return vec3(float(n<2)*float(n*2-1),float(n>=2&&n<4)*float((n-2)*2-1),float(n>=4)*float((n-4)*2-1));\n}\n\nvoid RayTracing_Domain_RepetitionMin(vec3 ro, vec3 loc, vec3 rd, inout bool result, inout HitInfo hit, int obj, float sc, float st, vec2 boxx) {\n    float tnew;\n    vec3 normnew;\n    vec3 rrt = RayTracing_Domain_Repetition(ro+loc, rd, normnew, sc, st, boxx);\n    tnew = rrt.y;\n    if (tnew < hit.t) {\n        hit.t = tnew;\n        hit.norm = normnew;\n        vec3 albedo;\n        int en = encode_norm(hit.norm);\n        material_OBJ_RRDT(ro+rd*hit.t, obj+en, hit.norm,  albedo, hit.emisson, hit.rough, hit.metal);\n\n        hit.color = vec4(albedo, 1.);\n        hit.obj_type = obj+en; //+int(rrt.z);\n        result = true;\n    }\n}\n\nvoid RayTracing_Domain_RepetitionMin_b(vec3 ro, vec3 loc, vec3 rd, inout bool result, inout HitInfo hit, int obj, float sc, float st, vec2 boxx) {\n    float tnew;\n    vec3 normnew;\n    vec3 rrt = RayTracing_Domain_Repetition_b(ro+loc, rd, normnew, sc, st, boxx);\n    tnew = rrt.y;\n    if (tnew < hit.t) {\n        hit.t = tnew;\n        hit.norm = normnew;\n        \n        vec3 albedo;\n        int en;\n        if(floor(abs(hit.norm.z*100.))==floor(abs(enorm.z*100.))){\n        if(floor(hit.norm.z*100.)==floor(enorm.z*100.)){\n            if(floor(hit.norm.x*100.)==floor(enorm.x*100.))en=6;\n            else en=8;\n        }else{\n            if(floor(hit.norm.x*100.)==floor(enorm.x*100.))en=7;\n            else en=9;\n        }\n        } else en = encode_norm(hit.norm);\n        \n        material_OBJ_RRDT(ro+rd*hit.t, obj+en, hit.norm,  albedo, hit.emisson, hit.rough, hit.metal);\n\n        hit.color = vec4(albedo, 1.);\n        hit.obj_type = obj+en; //+int(rrt.z);\n        result = true;\n    }\n}\n\n\n\n\n// render NOT OPTIMIZED\n// can be optimized by separating normal/albedo calculation and hit(bool)\n// by making two functions, one used by shadows other by pathtracing\n// look get_scene_ \n//----------------------------------------------\n\nbool minDist(vec3 ro, vec3 rd, out HitInfo hit)\n{\n    hit.t = MAX_DIST;\n    hit.obj_type = OBJ_SKY;\n    hit.norm = vec3(0.,1.,0.);\n    \n    float lDotU = dot(rd, upVec);\n    float lDotV = dot(rd, lightDir);\n    \n    hit.color=vec4(calculateSky(calculateSun(lDotV)*calculateSunColor(lightDir.y), lDotU, lDotV),1.);\n    hit.emisson = vec3(0.,0.,0.);\n    bool result = false;\n\n\n    GroundIntersectMin(ro+vec3(0.,-2.,0.), rd, result, hit, OBJ_FLOOR);\n    \n    RayTracing_Domain_RepetitionMin(ro,vec3(0.,-1.-0.125,1.05), rd, result, hit, OBJ_RRD1, .4, 0.65, vec2(.125,.075));\n    RayTracing_Domain_RepetitionMin(ro,vec3((0.85-0.65)*0.5,-1.-0.125*2.-0.012,1.01), rd, result, hit, OBJ_RRD2, .4, 0.85, vec2(.012,.17));\n    \n    RayTracing_Domain_RepetitionMin(ro,vec3(0.,-1.-3.5,3.1), rd, result, hit, OBJ_RRD3, .44, 1.5, vec2(3.5,1.));\n    RayTracing_Domain_RepetitionMin(ro,vec3(0.,-1.-3.5,-3.29), rd, result, hit, OBJ_RRD4, .44, 1.5, vec2(3.5,1.));\n    \n    \n    RayTracing_Domain_RepetitionMin(ro,vec3(0.3,-1.-.35,3.1), rd, result, hit, OBJ_RRD5, .44*14., 1.8/14., vec2(.35,.9));\n    RayTracing_Domain_RepetitionMin(ro,vec3(0.3,-1.-.35,-3.29), rd, result, hit, OBJ_RRD6, .44*14., 1.8/14., vec2(.35,.9));\n    \n    RayTracing_Domain_RepetitionMin_b(ro,vec3(0.15,-1.-3.5-4.46,3.1-3.29), rd, result, hit, OBJ_RRD7, 0.44/5., 1.5*7.25, vec2(1.1,7.));\n    \n    RayTracing_Domain_RepetitionMin(ro,vec3(1.95,-1.-3.5,3.1-3.29+1.66), rd, result, hit, OBJ_RRD8, 0.44/20., 5.5, vec2(3.5,2.6));\n    \n    return result;\n}\n\n//----------------------------------------------\n\n\n// noise https://www.shadertoy.com/view/7sGBzW\n// hash https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n\n// saved in BufA as alpha\nfloat Bnoise(vec2 U) {\n    float v = 0.;\n    for (int k=0; k<9; k++)\n        v += hash12( U + vec2(k%3-1,k/3-1) ); \n    v=.9 *( 1.125*hash12(U)- v/8.) + .5;\n    //return clamp(v,0.,1.);\n    //return fract(abs(v));\n    return v < 0. ? -v : v > 1. ? 2.-v : v ;\n}\n\n// halton low discrepancy sequence, from https://www.shadertoy.com/view/wdXSW8\nvoid halton_loop(inout vec2 s, inout vec4 a){\n    const vec2 coprimes = vec2(2.0f, 3.0f);\n    a.xy = a.xy/coprimes;\n    a.zw += a.xy*mod(s, coprimes);\n    s = floor(s/coprimes);\n}\nvec2 halton (int index){\n    vec2 s = vec2(index, index);\n\tvec4 a = vec4(1,1,0,0);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    return a.zw;\n}\n\n\n\n// https://www.shadertoy.com/view/3ddfDj\nvec4 biplanar( sampler2D sam, in vec3 p, in vec3 n, vec3 dpdx, vec3 dpdy )\n{\n    n = abs(n);\n\n    // major axis (in x; yz are following axis)\n    ivec3 ma = (n.x>n.y && n.x>n.z) ? ivec3(0,1,2) :\n               (n.y>n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n    // minor axis (in x; yz are following axis)\n    ivec3 mi = (n.x<n.y && n.x<n.z) ? ivec3(0,1,2) :\n               (n.y<n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n        \n    // median axis (in x;  yz are following axis)\n    ivec3 me = ivec3(3) - mi - ma;\n    \n    // project+fetch\n    vec4 x = textureGrad( sam, vec2(   p[ma.y],   p[ma.z]), \n                               vec2(dpdx[ma.y],dpdx[ma.z]), \n                               vec2(dpdy[ma.y],dpdy[ma.z]) );\n    vec4 y = textureGrad( sam, vec2(   p[me.y],   p[me.z]), \n                               vec2(dpdx[me.y],dpdx[me.z]),\n                               vec2(dpdy[me.y],dpdy[me.z]) );\n    \n    // blend and return\n    vec2 m = vec2(n[ma.x],n[me.x]);\n    m = clamp( (m-0.5773)/(1.0-0.5773), 0.0, 1.0 );\n\n\treturn (x*m.x + y*m.y) / (m.x + m.y);\n}\n\nvec4 triplanar( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    \n    vec3 m = pow( abs(n), vec3(8.0) );\n    m+=0.000001*(1.-abs(sign(m)));\n\treturn (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\n\nvec4 triplanar2( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( sam, p.yz+p.zy*vec2(1.,-1.));\n\tvec4 y = texture( sam, p.zx+p.xz*vec2(1.,-1.));\n\tvec4 z = texture( sam, p.xy+p.yx*vec2(1.,-1.));\n    \n    vec3 m = pow( abs(n), vec3(8.0) );\n    m+=0.000001*(1.-abs(sign(m)));\n\treturn (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\n\n\n\n\n// https://www.shadertoy.com/view/Nls3Rn\n\n#define pack_Snormfloat3x10(x) uintBitsToFloat(packSnorm3x10(x))\n#define unpack_Snormfloat3x10(x) unpackSnorm3x10(floatBitsToUint(x))\n//#define pack_Unormfloat3x10(x) uintBitsToFloat(packSnorm3x10((x-0.5)*2.))\n//#define unpack_Unormfloat3x10(x) (unpackSnorm3x10(floatBitsToUint(x))/2.+0.5)\n\n// NOTE - Unormfloat3x10 above result noticeable \"jump\" when color~=0.5\n// Unormfloat3x10 will down/upscale 0.5+-0.001 to 0.5\n// look last few lines in BufB where pack_Unormfloat3x10 used for TAA feedback\n\n// As solution I use only >0 region of Snorm\n\n#define pack_Unormfloat3x10(x) uintBitsToFloat(packSnorm3x10(x))\n#define unpack_Unormfloat3x10(x) (unpackSnorm3x10(floatBitsToUint(x)))\n\nuint packSnorm3x10(vec3 x) {\n    x = clamp(x,-1., 1.) * 511.;\n    uvec3 sig = uvec3(mix(vec3(0), vec3(1), greaterThanEqual(sign(x),vec3(0))));\n    uvec3 mag = uvec3(abs(x));\n    uvec3 r = sig.xyz << 9 | mag.xyz;\n    return r.x << 22 | r.y << 12 | r.z << 2;\n}\n\nvec3 unpackSnorm3x10(uint x) {\n    uvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n    uvec3 sig = r >> 9;\n    uvec3 mag = r & uvec3(0x1FF);\n    vec3 fsig = mix(vec3(-1), vec3(1), greaterThanEqual(sig, uvec3(1)));\n    vec3 fmag = vec3(mag) / 511.;\n    return fsig * fmag;\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\n// using pathtracer functions https://www.shadertoy.com/view/3dlSW7\n// using reprojection functions https://www.shadertoy.com/view/WdjcDd\n\n// BufB - pathtraced bounce lighting and AO with reprojection of last frame \n// BufB (alpha) save fogLitPercent or Albedo when #define enable_textures set in Common\n\n// because I use \"pixel shift\" for antialiasing - there no way to separate render\n// no way to have color AO in BufB and shadow in BufC to have better quality of TAA\n// because antialiasing light will leak on edges from light*shadow (if separate light from shadow)\n// \n// Depth and why Fog/Volumetric separated from color:\n// When color combined with Volumetric - AA pixel shift\n// color will leak on edge because depth only for current frame when color is combined AA\n// so color on edges will leak if Fog/Volumetric were added here\n//\n// this why I have to save volumetric fogLitPercent and volumetric absorb as two floats\n// to prevend \"black border jittering\" if I just save fogLitPercent and calculate absorb from current frame depth\n// because current frame depth shifted to current frame AA shift, when fogLitPercent contain TAA summ\n// TAA black border will leak to current frame\n// when absorb also saved with TAA - there no problems because two values with TAA fit each other\n\n\n// About reprojection:\n//\n// needed to reproject last frame:\n// last camera_position(ro) last_mouse(rotation_mat) - saved in bufA(alpha) and last_pos\n// last_pos restored from BufA last_depth\n\n// to render current frame also needed normal and color\n// normal from BufA restored from obj_id, object_id from BufA, color generated from object_id\n\n\n// Optimization idea:\n// because shadow and reflection and volumetric dont need color\n// intersection function minDist() of each object can have 2 version\n// 1. return hit true/false and normal and depth and obj_id\n// 2. return only hit\n// With this - reflection/volumetric/shadow will skip calculation of normal and obj_id\n// this is NOT DONE in this code, I have only single minDist() that equal option 1\n\n\n//----------------------------------------------\n\nfloat get_scene_intersect(vec3 ro, vec3 rd, vec3 norm){\n    HitInfo hit;\n    //0.002 is light leak\n    return (minDist(ro+0.002*norm, rd, hit)?0.:1.);\n}\n\nfloat get_scene_bounce_light(vec3 ro, vec3 rd, vec3 innorm, out vec3 ndir, out vec3 albedo, out vec3 emission, out vec3 norm){\n    HitInfo hit;\n    bool d = minDist(ro+innorm*0.002, rd, hit);\n    ndir=vec3(0.0001);\n    albedo=vec3(0.0);\n    emission=vec3(0.0);\n    norm = vec3(0.0001);\n    if(d){\n        ndir=ro+rd*hit.t;\n        albedo=hit.color.rgb;\n        emission=hit.emisson;\n        norm = hit.norm;\n    }\n    \n    return d?0.:1.;\n}\n\nvoid get_scene_material(bool d, vec3 pos, vec3 norm, int obj_id, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    albedo=vec3(0.0);\n    emission=vec3(0.0);\n    roughness=0.0001;\n    metalness=0.0001;\n    // pos+= objpos todo\n    if(d){\n        if(obj_id==OBJ_FLOOR)\n            material_OBJ_FLOOR(pos, norm, albedo, emission, roughness, metalness);\n        else if(obj_id>=OBJ_RRD1)//&&obj_id<OBJ_RRD1+10)\n            material_OBJ_RRDT(pos, obj_id, norm, albedo, emission, roughness, metalness);\n    }\n}\n\n//----------------------------------------------\n\n\n\n\n\n// pathtracing functions\n//----------------------------------------------\n\n\n\n\nfloat calculateShadow(vec3 ro, vec3 rd, vec3 normal, float dither, int rays_shadow){\n\tfloat shadow = 0.0;\n    float rShadowRays = 1.0 / float(rays_shadow);\n    \n#ifdef use_ConeVector\n    mat3 tbl = calculateTangentMatrix(rd);\n#endif\n\tfor (int i = 0; i < rays_shadow+ANGLE_loops; ++i){\n#ifdef use_ConeVector\n        vec3 dir = tbl * calculateConeVector((float(i) + dither) * rShadowRays, sunAngularDiameter, rays_shadow);\n#else\n        vec3 dir = normalize(rd+radians(sunAngularDiameter)*getCosineWeightedSample(lightDir,0.15));\n#endif\n        float lDotN = dot(dir, normal);\n        if (lDotN <= 0.0) continue;\n        \n        lDotN = sqrt(clamp(lDotN, 0.0, 1.0));\n        \n\t\tfloat light = sunIluminance * lDotN;\n        float rayHit = get_scene_intersect(ro, dir, normal);\n\t\t\n\t\tshadow += rayHit * light;\n\t}\n    \n    return shadow * rShadowRays;\n}\n\nvec3 calculate_bouncelight_AO(vec3 ro, vec3 rd, vec3 normal, float percentSpecular, float roughness, vec3 sunColor, float noise){\t\n    vec3 AO = vec3(0.0);\n    const float rAORays = 1.0 / float(AORays);\n    \n#ifdef sunlight_2nd_bounce\n    vec3 bouncedLight = vec3(0.0);\n    vec3 abso = vec3(1.);\n#endif\n    \n#ifdef use_ConeVector\n    mat3 tbn = calculateTangentMatrix(normal);\n#endif\n\tfor (int i = 0; i < AORays+ANGLE_loops; ++i){\n#ifdef use_ConeVector\n\t\tvec3 dir = tbn * calculateConeVector((float(i) + noise) * rAORays, 90.0, AORays);\n#else\n\t\tvec3 dir = normalize(normal + 5.*getCosineWeightedSample(normal,0.5));\n#endif\n        float lDotN = dot(dir, normal);\n        if (lDotN <= 0.0) continue;\n        \n        lDotN = sqrt(clamp(lDotN, 0.0, 1.0));\n        float lDotU = dot(dir, upVec);\n        float lDotV = dot(dir, lightDir);\n        \n\t\tvec3 light = calculateSky(vec3(0.0), lDotU, lDotV) * lDotN;\n        \n#ifdef sunlight_2nd_bounce\n        vec3 bouncePos;\n        vec3 bounceNormal;\n        vec3 bouncedAlbedo;\n        vec3 bouncedEmissive;\n        float rayHit = get_scene_bounce_light(ro, dir, normal, bouncePos, bouncedAlbedo, bouncedEmissive, bounceNormal);\n        if(rayHit<0.5)\n        {\n            vec3 bouncedLighting = calculateShadow(bouncePos, lightDir, bounceNormal, noise, 2)*sunColor;\n            bouncedLighting += abso * (bouncedEmissive + bouncedAlbedo*bouncedLighting);\n            abso *= bouncedAlbedo;\n            bouncedLight += bouncedLighting * (1.0 - rayHit) * lDotN;\n        }\n#else\n        float rayHit = get_scene_intersect(ro, dir, normal);\n#endif\n\t\tAO += rayHit * light;\n\t}\n    \n    AO = AO * rAORays * 2./PI;\n#ifdef sunlight_2nd_bounce\n    bouncedLight = bouncedLight * rAORays;\n    AO+=bouncedLight;\n#endif\n    \n\treturn AO;\n}\n\n//----------------------------------------------\n\n// volume\n//----------------------------------------------\n#ifdef enable_volume\nfloat raymarchVolume(vec3 ro, vec3 rd, float noise){\n    const float rSteps = 1.0 / float(volumeSteps);\n    \n    vec3 start = vec3(0.0);\n    vec3 end = ro;\n    float endDepth = length(end);\n    end /= max(endDepth,0.0001);\n    endDepth = min(length(ro), MAX_DIST);\n    end *= endDepth;\n    \n    vec3 increment = (end - start) * rSteps;\n    vec3 rayPosition = noise * increment + start;\n    \n    float fogLitPercent = 0.0f;\n    for (int i = 0; i < volumeSteps+ANGLE_loops; i++){\n        float volumetricShadow = get_scene_intersect(rayPosition + rd, lightDir, rayPosition + rd);\n        fogLitPercent = mix(fogLitPercent, volumetricShadow, 1.0 / float(i+1));\n        rayPosition +=  increment;\n     }\n    return fogLitPercent;\n}\n#endif\n//----------------------------------------------\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n#ifndef use_ConeVector\n    seed = hash12(fragCoord.xy+hash21(float(iFrame%10000)*0.333)*1234.123);\n#endif\n    vec2 fc=fragCoord.xy;\n    vec2 halton_px_shift = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    fragCoord.xy += halton_px_shift;\n\n    vec2 screen_uv = fc.xy / iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec3 ro;\n    vec3 rd;\n    SetCamera(uv, iChannel0, ro, rd, iResolution.xy);\n    \n    float noise=0.; \n    \n#ifdef use_ConeVector\n    // noise for ConeVector\n    \n    ivec2 ipx = ivec2(fc);\n    ivec2 reserv = ivec2(5,MEMORY_BOUNDARY.y+5);\n    ipx=ipx%(ivec2(textureSize(iChannel0,0).xy)-reserv);\n    float n0 = texelFetch(iChannel0, textureSize(iChannel0,0).xy-ipx-1, 0).a;\n    noise = fract(n0 + 0.75*float(iFrame % 264) * c_goldenRatioConjugate);\n\n    // test hash12 as noise\n    //vec2 tfc = fc.xy+hash21(float(iFrame%10000)*0.333)*iResolution.y*2.;\n    //noise = hash12(tfc);\n    \n#endif\n\n    vec2 this_id_d = texelFetch(iChannel0, ivec2(fc), 0).xy;\n    int obj_id = int(this_id_d.x);\n    vec3 pos=ro+rd*this_id_d.y;\n    \n    bool rayHit = obj_id>0;\n    vec3 normal;\n    vec3 albedo;\n    vec3 emission;\n    float rough;\n    float metal;\n    \n    if(obj_id==OBJ_FLOOR)normal=get_normal_OBJ_FLOOR(pos);\n    else if(obj_id>=OBJ_RRD1)//&&obj_id<OBJ_RRD1+10)\n        normal=get_normal_OBJ_RRD(obj_id);\n    \n    \n    get_scene_material(rayHit, pos, normal, obj_id, albedo, emission, rough, metal);\n    \n    vec3 sunColor = calculateSunColor(lightDir.y);\n\tvec3 color_light_AO = calculate_bouncelight_AO(pos, rd, normal, metal, rough, sunColor, noise);\n    \n    vec3 shadow = calculateShadow(pos, lightDir, normal, noise, shadowRays)*sunColor;\n    \n    \n    //vec3 color = mix(color_light_AO+shadow,vec3(0.),dot(emission,vec3(1.))/3.);\n    //color = mix(albedo*color, emission, dot(emission,vec3(1.))/3.);\n    \n    vec3 fk_emission=vec3(0.); // I do not want to have it on color\n    vec3 color = mix(color_light_AO+shadow,vec3(0.),dot(fk_emission,vec3(1.))/3.);\n    color = mix(albedo*color, fk_emission, dot(fk_emission,vec3(1.))/3.);\n    \n    if (!rayHit) \n    {\n        float lDotU = dot(rd, upVec);\n        float lDotV = dot(rd, lightDir);\n        color=vec3(0.);\n        color = calculateSun(lDotV)*calculateSunColor(lightDir.y);\n        color = calculateSky(color, lDotU, lDotV);\n    }\n    \n    float fogLitPercent = 0.;\n#ifdef enable_textures\n    vec3 tpos = pos;\n    if(obj_id==OBJ_FLOOR)tpos*=.15;\n    vec3 te = triplanar2(iChannel3, tpos*.75, normal).rgb;\n    vec3 tef = triplanar2(iChannel2, tpos*.75, normal).rgb;\n    if(obj_id==OBJ_FLOOR)te=tef;\n    vec3 te2 = triplanar(iChannel3, .35*tpos, normal).rgb;\n    te *= 0.2+0.8*te2;\n    te *= 0.2+0.8*triplanar(iChannel2, tpos*2.75, normal).rgb;\n    if(obj_id==OBJ_FLOOR)te=te*0.25+0.75*dot(te,vec3(1.))/3.;\n    te = 1.25*(sqrt(te)-0.35)+0.5;\n    \n    if(obj_id>=OBJ_RRD1&&obj_id<OBJ_RRD2+10)te += vec3(.25);\n    te*=vec3(0.9,1.2,1.2);\n    \n    \n    te = clamp(te,0.,1.);\n    //te = pow(max(te,0.0),vec3(1.8));\n    fogLitPercent = pack_Unormfloat3x10(te);\n    // avoiding dfd bugs\n    if(obj_id==OBJ_SKY)fogLitPercent=pack_Unormfloat3x10(vec3(1.));\n#else\n#ifdef enable_volume\n    #ifdef use_ConeVector\n    fogLitPercent = raymarchVolume(pos - ro, ro, noise);\n    #else\n    fogLitPercent = raymarchVolume(pos - ro, ro, hash11_seed());\n    #endif\n#endif\n#endif\n    \n    color = max(color, 0.0);\n    bool input_registered = load(INPUT0,iChannel0)>1.;\n    fragColor = vec4(color, fogLitPercent);\n    //protection when camera go inside of shape and intersection function may return inf or nan\n    fragColor=clamp(fragColor,0.,100.); \n#ifdef enable_textures\n    fragColor.a = fogLitPercent;\n#endif\n#ifdef use_reproject_TAA\n    // reprojection TAA\n    bool res_ch = load(RES_CHANGE,iChannel0)<0.5;\n    if(input_registered||res_ch){\n        vec4 oldCol = previousSample(ro, pos,iChannel0, iChannel0, iChannel1, iResolution.xy);\n        float factor = (oldCol.a == 0.||res_ch) ? 0. : .95;\n        fragColor.rgb = mix(fragColor.rgb, oldCol.rgb, factor);\n#ifndef enable_textures\n        fragColor.a = mix(fragColor.a, oldCol.a, factor*0.75); \n#endif\n        //fragColor.a=fogLitPercent; // to disable reproj for volumtertic shadow\n    }else\n#endif\n    // default TAA\n    {\n        vec4 backColor = texelFetch(iChannel1, ivec2(fc),0);\n        fragColor.rgb = mix(fragColor.rgb, backColor.rgb, 0.95 * (1.-float(input_registered)));\n#ifndef enable_textures\n        fragColor.a = mix(fragColor.a, backColor.a, 0.95 * (1.-float(input_registered)));\n#else\n        fragColor.a = pack_Unormfloat3x10(mix(unpack_Unormfloat3x10(fragColor.a), unpack_Unormfloat3x10(backColor.a), 0.95 * (1.-float(input_registered))));\n#endif\n        \n    }\n#ifndef enable_textures\n    fragColor.a=max(fragColor.a,0.00001); // reprojection flag for previousSample in Comon, it return alpha 0. when no reprojection\n#endif\n}\n\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n\n// using https://www.shadertoy.com/view/3dlSW7\n// using https://www.shadertoy.com/view/WdjcDd\n\n// fragColor = vec4(color, absorb); // absorb for volumetric, volumetric rendered in Image\n\n//----------------------------------------------\n\n\nfloat get_scene_intersect(vec3 ro, vec3 rd, vec3 norm){\n    HitInfo hit;\n    //0.002 is light leak\n    return (minDist(ro+0.002*norm, rd, hit)?0.:1.);\n}\n\nfloat get_scene_bounce_light(vec3 ro, vec3 rd, vec3 innorm, out vec3 ndir, out vec3 albedo, out vec3 emission, out vec3 norm){\n    HitInfo hit;\n    bool d = minDist(ro+innorm*0.002, rd, hit);\n    ndir=vec3(0.0001);\n    albedo=vec3(0.0);\n    emission=vec3(0.0);\n    norm = vec3(0.0001);\n    if(d){\n        ndir=ro+rd*hit.t;\n        albedo=hit.color.rgb;\n        emission=hit.emisson;\n        norm = hit.norm;\n    }\n    \n    return d?0.:1.;\n}\n\nvoid get_scene_material(bool d, vec3 pos, vec3 norm, int obj_id, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    albedo=vec3(0.0);\n    emission=vec3(0.0);\n    roughness=0.0001;\n    metalness=0.0001;\n    // pos+= objpos todo\n    if(d){\n        if(obj_id==OBJ_FLOOR)\n            material_OBJ_FLOOR(pos, norm, albedo, emission, roughness, metalness);\n        else if(obj_id>=OBJ_RRD1)//&&obj_id<OBJ_RRD1+10)\n            material_OBJ_RRDT(pos, obj_id, norm, albedo, emission, roughness, metalness);\n    }\n}\n\n//----------------------------------------------\n\n\n\n\n\n// pathtracing functions\n//----------------------------------------------\n\nfloat calculateFresnel(float cosTheta, float f0){\n    cosTheta = 1.0 - cosTheta;\n\tcosTheta = cosTheta * cosTheta * cosTheta * cosTheta * cosTheta;\n    \n    return cosTheta * (1.0 - f0) + f0;\n}\n\n#ifdef enable_reflections\nvec3 calculateReflection(vec3 ro, vec3 rd, vec3 normal, float percentSpecular, float roughness, vec3 totalLighting, float noise){\t\n#ifdef use_ConeVector\n    mat3 tbn = calculateTangentMatrix(normal);\n#endif\n    vec3 reflection = vec3(0.0);\n    float rReflectionRays = 1.0 / float(reflectionRays);\n    float fresnel = 0.0;\n\n    for (int i = 0; i < reflectionRays+ANGLE_loops; ++i){\n#ifdef use_ConeVector\n        vec3 dir = tbn * calculateRoughSpecular(fract((float(i) + noise) * rReflectionRays), reflectionRays, roughness);\n#else\n        vec3 dir = normalize(normal + 3.5*roughness*roughness*getCosineWeightedSample(normal,0.1+0.4*roughness));\n#endif\n        dir = reflect(rd, dir);\n\n        float lDotN = dot(dir, normal);\n        float f = lDotN;\n        if (lDotN <= 0.0) continue;\n\n        float lDotU = dot(dir, upVec);\n        float lDotV = dot(dir, lightDir);\n\n        fresnel += calculateFresnel(f, percentSpecular);\n\n        vec3 light = calculateSky(vec3(0.0), lDotU, lDotV);\n        \n#ifdef reflection_color_emi\n        vec3 bouncePos;\n        vec3 bounceNormal;\n        vec3 bouncedAlbedo;\n        vec3 bouncedEmissive;\n        float rayHit = get_scene_bounce_light(ro, dir, normal, bouncePos, bouncedAlbedo, bouncedEmissive, bounceNormal);\n        reflection += rayHit * light;\n        reflection += (1.-rayHit) * bouncedEmissive;\n#else\n        float rayHit = get_scene_intersect(ro, dir, normal);\n        reflection += rayHit * light;\n#endif\n    }\n    \n    reflection = reflection * rReflectionRays;\n    fresnel = fresnel * rReflectionRays;\n\n    totalLighting = mix(totalLighting, reflection, fresnel);\n\t\n\treturn totalLighting;\n}\n#endif\n//----------------------------------------------\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n#ifndef use_ConeVector\n    seed = hash12(fragCoord.xy+hash21(float(iFrame%10000)*0.333)*1234.123);\n#endif\n    vec2 fc=fragCoord.xy;\n    vec2 halton_px_shift = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    fragCoord.xy += halton_px_shift;\n\n    vec2 screen_uv = fc.xy / iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 ro;\n    vec3 rd;\n    SetCamera(uv, iChannel0, ro, rd, iResolution.xy);\n    \n    \n    float noise=0.; \n    \n#ifdef use_ConeVector\n    // noise for ConeVector\n    \n    ivec2 ipx = ivec2(fc);\n    ivec2 reserv = ivec2(5,MEMORY_BOUNDARY.y+5);\n    ipx=ipx%(ivec2(textureSize(iChannel0,0).xy)-reserv);\n    float n0 = texelFetch(iChannel0, textureSize(iChannel0,0).xy-ipx-1, 0).a;\n    noise = fract(n0 + 0.75*float(iFrame % 264) * c_goldenRatioConjugate);\n\n    // test hash12 as noise\n    //vec2 tfc = fc.xy+hash21(float(iFrame%10000)*0.333)*iResolution.y*2.;\n    //noise = hash12(tfc);\n    \n#endif\n\n    vec2 this_id_d = texelFetch(iChannel0, ivec2(fc), 0).xy;\n    int obj_id = int(this_id_d.x);\n    vec3 pos=ro+rd*this_id_d.y;\n    \n    bool rayHit = obj_id>0;\n    vec3 normal;\n    vec3 albedo;\n    vec3 emission;\n    float rough;\n    float metal;\n    \n    if(obj_id==OBJ_FLOOR)normal=get_normal_OBJ_FLOOR(pos);\n    else if(obj_id>=OBJ_RRD1)//&&obj_id<OBJ_RRD1+10)\n        normal=get_normal_OBJ_RRD(obj_id);\n    \n    \n    get_scene_material(rayHit, pos, normal, obj_id, albedo, emission, rough, metal);\n    \n    vec3 sunColor = calculateSunColor(lightDir.y);\n    vec3 color = texelFetch(iChannel1, ivec2(fc), 0).rgb;\n#ifdef enable_reflections\n    color = calculateReflection(pos, rd, normal, metal, rough, color, noise);\n#endif\n    \n\tfloat lDotU = dot(rd, upVec);\n\tfloat lDotV = dot(rd, lightDir);\n\t\n    if (!rayHit) \n    {\n        color = vec3(0.0);\n        color += calculateSun(lDotV)*calculateSunColor(lightDir.y);\n        color = calculateSky(color, lDotU, lDotV);\n    }\n    float absorb = 0.;\n    \n#ifdef enable_textures\n    absorb = texelFetch(iChannel1, ivec2(fc), 0).a;\n#else\n#ifdef enable_volume\n    float depth = length(ro-pos);\n    absorb = exp(-depth * volume_fogDensity);\n    absorb = clamp(absorb,.25,1.);\n    absorb = 1.-(1.-smoothstep(MAX_DIST-MAX_DIST*0.1,MAX_DIST,depth))*(1.-absorb);\n#endif\n#endif\n    \n    color = max(color, 0.0);\n    bool input_registered = load(INPUT0,iChannel0)>1.;\n    fragColor = vec4(color, absorb);\n    //protection when camera go inside of shape and intersection function may return inf or nan\n    fragColor.rgb=clamp(fragColor.rgb,0.,100.); \n#ifdef use_reproject_TAA\n    // reprojection TAA\n    bool res_ch = load(RES_CHANGE,iChannel0)<0.5;\n    if(input_registered||res_ch){\n        vec4 oldCol = previousSample(ro, pos,iChannel0, iChannel0, iChannel2, iResolution.xy);\n        float factor = (oldCol.a == 0.||res_ch) ? 0. : .90;\n        fragColor.rgb = mix(fragColor.rgb, oldCol.rgb, factor);\n#ifndef enable_textures\n        fragColor.a = mix(fragColor.a, oldCol.a, factor*0.75); \n#endif\n        //fragColor.a=absorb; // to disable reproj for volumtertic shadow\n    }else\n#endif\n    // default TAA\n    {\n        vec4 backColor = texture(iChannel2, screen_uv);\n        fragColor.rgb = mix(fragColor.rgb, backColor.rgb, 0.905 * (1.-float(input_registered)));\n#ifndef enable_textures\n        fragColor.a = mix(fragColor.a, backColor.a, 0.905 * (1.-float(input_registered)));\n#else\n        fragColor.a = fragColor.a; //copy BufB texture color\n#endif\n    }\n#ifndef enable_textures\n    fragColor.a=max(fragColor.a,0.00001); // reprojection flag for previousSample in Comon, it return alpha 0. when no reprojection\n#endif\n    \n}\n\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n#ifndef use_dynamic_TAA\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    discard;\n}\n#else\n\n// from https://www.shadertoy.com/view/DsfGWX\n\n#define ENABLE_TAA\n#define TEMPORAL_REPROJECT\n\n#define VARIANCE_CLIPPING\n\n// debug\n//#define SHOW_MOTION\n//#define SHOW_DISOCCLUSION\n\n// TAA\n// alpha of this shader is unused, it used to store curr_d but hist.a used only in SHOW_DISOCCLUSION\n// when define enable_volume set - this Alpha used to filter absorb from BufC - so debug wont work here\n\n#define EPS 1e-4\n\n\n\n#define OFFSET_COUNT 4\n\nconst ivec2 off[OFFSET_COUNT] = ivec2[OFFSET_COUNT](\n \tivec2( 1,  0), ivec2( 0, -1), \n\tivec2( 0,  1), ivec2(-1,  0)\n);\n/*\n#define OFFSET_COUNT 8\n\nconst ivec2 off[OFFSET_COUNT] = ivec2[OFFSET_COUNT](\n    ivec2(-1, -1), ivec2(-1,  1), \n\tivec2( 1, -1), ivec2( 1,  1), \n\tivec2( 1,  0), ivec2( 0, -1), \n\tivec2( 0,  1), ivec2(-1,  0)\n);\n*/\n\n\nvec3 rgb2ycocg(in vec3 rgb)\n{\nreturn rgb;\n    float co = rgb.r - rgb.b;\n    float t = rgb.b + co / 2.0;\n    float cg = rgb.g - t;\n    float y = t + cg / 2.0;\n    return vec3(y, co, cg);\n}\n\n\nvec3 ycocg2rgb(in vec3 ycocg)\n{\nreturn ycocg;\n    float t = ycocg.r - ycocg.b / 2.0;\n    float g = ycocg.b + t;\n    float b = t - ycocg.g / 2.0;\n    float r = ycocg.g + b;\n    return vec3(r, g, b);\n}\n\nvec3 RGBtoYCoCg(vec3 c)\n{\nreturn c;\n    //return rgb2ycocg(c);\n    return mat3(0.25, 0.5, -0.25, 0.5, 0, 0.5, 0.25, -0.5, -0.25) * c;\n}\n\nvec3 YCoCgToRGB(vec3 c)\n{\nreturn c;\n    //return ycocg2rgb(c);\n    return mat3(1, 1, 1, 1, 0, -1, -1, 1, -1) * c;\n}\n\nvec4 clipToAABB(in vec4 cOld, in vec4 cNew, in vec4 center, in vec4 halfSize)\n{\n    vec4 r = cOld - cNew;\n    vec4 m = (center + halfSize) - cNew;\n    vec4 n = (center - halfSize) - cNew;\n    \n    if (r.x > m.x + EPS)\n\t\tr *= (m.x / r.x);\n\tif (r.y > m.y + EPS)\n\t\tr *= (m.y / r.y);\n\tif (r.z > m.z + EPS)\n\t\tr *= (m.z / r.z);\n    if (r.w > m.w + EPS)\n\t\tr.w *= (m.w / r.w);\n\n\tif (r.x < n.x - EPS)\n\t\tr *= (n.x / r.x);\n\tif (r.y < n.y - EPS)\n\t\tr *= (n.y / r.y);\n\tif (r.z < n.z - EPS)\n\t\tr *= (n.z / r.z);\n    if (r.w < n.w - EPS)\n\t\tr.w *= (n.w / r.w);\n\n\treturn cNew + r;\n}\n\nvec4 SampleTextureCatmullRom(sampler2D tex, vec2 texSize, vec2 uv)\n{\n    vec2 samplePos = uv * texSize;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n    vec2 f = samplePos - texPos1;\n\n    vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n    vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n    vec2 w3 = f * f * (-0.5 + 0.5 * f);\n    \n    vec2 w12 = w1 + w2;\n    vec2 offset12 = w2 / w12;\n\n    vec2 texPos0 = texPos1 - vec2(1.0);\n    vec2 texPos3 = texPos1 + vec2(2.0);\n    vec2 texPos12 = texPos1 + offset12;\n\n    texPos0 /= texSize;\n    texPos3 /= texSize;\n    texPos12 /= texSize;\n\n    vec4 result = vec4(0.0);\n    result += textureLod(tex, vec2(texPos0.x,  texPos0.y), 0.) * w0.x * w0.y;\n    result += textureLod(tex, vec2(texPos12.x, texPos0.y), 0.) * w12.x * w0.y;\n    result += textureLod(tex, vec2(texPos3.x,  texPos0.y), 0.) * w3.x * w0.y;\n\n    result += textureLod(tex, vec2(texPos0.x,  texPos12.y), 0.) * w0.x * w12.y;\n    result += textureLod(tex, vec2(texPos12.x, texPos12.y), 0.) * w12.x * w12.y;\n    result += textureLod(tex, vec2(texPos3.x,  texPos12.y), 0.) * w3.x * w12.y;\n\n    result += textureLod(tex, vec2(texPos0.x,  texPos3.y), 0.) * w0.x * w3.y;\n    result += textureLod(tex, vec2(texPos12.x, texPos3.y), 0.) * w12.x * w3.y;\n    result += textureLod(tex, vec2(texPos3.x,  texPos3.y), 0.) * w3.x * w3.y;\n\n    return result;\n}\n\nfloat distancePixel22( vec2 prevFragCoord, vec3 pos, sampler2D samplerx, vec2 ires, vec3 p_ro, vec3 p_rd){\n    if(  min(ires.xy-1., prevFragCoord) != prevFragCoord\n      || max(vec2(0.)      , prevFragCoord) != prevFragCoord) return MAX_DIST;\n    \n    float prev_d = textureLod(samplerx, prevFragCoord/ires.xy,0.).a;\n    vec3 prevPos = p_ro + p_rd*prev_d;\n    return length(prevPos-pos);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = .1;\n    \n    ivec2 ipx = ivec2(fragCoord);\n    \n    // adding halton_px_shift to fragCoord not needed\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec2 halton_px_shift = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    float curr_d = textureLod(iChannel0, (fragCoord - halton_px_shift) / iResolution.xy, 0.).y;\n    vec4 curr_color = textureLod(iChannel2, (fragCoord - halton_px_shift) / iResolution.xy, 0.).rgba;\n    vec3 curr_texture_col = vec3(1.);\n    \n#ifdef enable_textures\n    //texelFetch because data packed\n    curr_texture_col = unpack_Unormfloat3x10(texelFetch(iChannel2, ivec2(fragCoord - halton_px_shift), 0).a);\n    \n#endif\n    vec4 new = vec4(RGBtoYCoCg(curr_color.rgb*curr_texture_col),curr_color.a);\n\n#ifdef TEMPORAL_REPROJECT\n\n    vec3 ro;\n    vec3 rd;\n    SetCamera(uv, iChannel0, ro, rd, iResolution.xy);\n    \n    vec3 pro;\n    vec3 prd;\n    SetCamera_prev(uv, iChannel0, pro, prd, iResolution.xy);\n    \n    vec3 pos = ro + rd * curr_d;\n    \n    // adding prevUv to fragCoord not needed\n    vec2 prevUv = pos2uv(pos, iChannel0, iResolution.xy);\n    vec2 prevFragCoord = prevUv * iResolution.y + iResolution.xy/2.0;\n    vec2 puv = prevFragCoord/iResolution.xy;\n    \n    \n    //vec4 hist = texture(iChannel3, puv);\n    //vec4 hist = getTextureSmooth(iChannel3, iResolution.xy, puv);\n    vec4 hist = SampleTextureCatmullRom(iChannel3, iResolution.xy, puv);\n\n    vec4 old = vec4(RGBtoYCoCg(hist.rgb),hist.a);\n#else\n    vec4 old = vec4(RGBtoYCoCg(texelFetch(iChannel3, sp, 0).rgb),texelFetch(iChannel3, sp, 0).a);\n#endif\n\n#ifdef VARIANCE_CLIPPING\n    vec4 avg = new;\n    vec4 var = new * new;\n    \n    for (int i = 0; i < OFFSET_COUNT; i++)\n    {\n        vec4 tex_data = texelFetch(iChannel2, ipx + off[i], 0);\n        vec3 tex_color = vec3(1.);\n#ifdef enable_textures\n        tex_color = unpack_Unormfloat3x10(tex_data.a);\n#endif\n        vec4 tex = vec4(RGBtoYCoCg(tex_data.rgb*tex_color),tex_data.a);\n        \n        avg += tex;\n        var += tex * tex;\n    }\n    avg /= float(OFFSET_COUNT + 1);\n    var /= float(OFFSET_COUNT + 1);\n\n    vec4 sig = sqrt(max(var - avg * avg, vec4(0)));\n    \n    const float g = 1.;\n    vec4 cmin = avg - sig * g;\n    vec4 cmax = avg + sig * g;\n    \n    #if 0\n    vec4 clip = clamp(old, cmin, cmax);\n    #else\n    vec4 clip = clipToAABB(old, clamp(avg, cmin, cmax), avg, sig);\n    #endif\n    \n    old = mix(old, clip, 1.);\n#endif\n    bool res_ch = load(RES_CHANGE,iChannel0)<0.5;\n    vec4 col = iFrame != 0 && !res_ch ? mix(old, new, a) : new;\n#ifdef ENABLE_TAA\n#ifdef enable_volume\n    fragColor = vec4(YCoCgToRGB(col.rgb), col.a);\n#else\n    fragColor = vec4(YCoCgToRGB(col.rgb), curr_d);\n#endif\n#else\n    fragColor = vec4(texelFetch(iChannel2, ivec2(fragCoord), 0).rgb, curr_d);\n#endif\n\n\n#ifdef SHOW_DISOCCLUSION\n\n    if (puv.x < 0. || puv.x >= 1. || puv.y < 0. || puv.y >= 1. ||\n        distance(pos, (pro+prd*hist.a)) > 2.*0.1*curr_d)\n    {\n        fragColor = vec4(1, 0, 0, curr_d);\n    }\n#endif\n\n#ifdef SHOW_MOTION\n    fragColor = vec4((fragCoord/iResolution.xy - puv) * 50., 0, curr_d);\n#endif\n    fragColor.rgb=clamp(fragColor.rgb,0.,100.); // seems color can be little negative\n}\n#endif","name":"Buffer D","description":"","type":"buffer"}]}