{"ver":"0.1","info":{"id":"WldBDH","date":"1612674359","viewed":81,"name":"32 bit one channel color","username":"ming","description":"Extending the \"16-bit one channel color\" shader to encode RGBA into a single 32 bit channel.\nInterestingly, I am not able to use all the 32 bits while using floating point operations only.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["packing","encoding","encode","onechannel"],"hasliked":0,"parentid":"ldBfRW","parentname":"16 bit one channel color"},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat checker(vec2 fragCoord) {\n\n    vec2 grid = floor(fragCoord / 32.0);\n    return (mod(grid.x + grid.y, 2.0) == 0.) ? 0.9 : 0.75;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 decoded = decodeColor(texture(iChannel2,uv).r);\n\n#ifdef SHOW_ERROR\n    vec4 original = getColor(uv);\n    fragColor = vec4(dot(vec4(SHOW_ERROR_SCALE), abs(decoded - original)));\n#else\n    vec4 bg = vec4(checker(fragCoord));\n    fragColor = mix(decoded, bg, decoded.a);\n#endif\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// simply encode\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 color = getColor(uv);\n\tfragColor.r = encodeColor(color);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//#define SHOW_ERROR\n#define SHOW_ERROR_SCALE 2.0\n\n// try comment out USE_PREMUL to compare the error\n// without pre-multiplying by 0.5, the alpha channel is totally messed\n#define USE_PREMUL\n\n#define color_bits vec4( 7, 7, 7, 7 )\n#define color_values exp2( color_bits )\n#define color_rvalues (1. / color_values)\n#define color_maxValues (color_values - 1.)\n#define color_rmaxValues (1. / color_maxValues)\n\n#define color_positions vec4( color_values.x*color_values.y*color_values.z, color_values.x*color_values.y, color_values.x, 1. )\n#define color_rpositions (1. / color_positions)\n\n\n#ifdef USE_PREMUL\n\n#define premul_factor 0.5\n#define r_premul_factor 2.0\n\n#else\n\n#define premul_factor 1.0\n#define r_premul_factor 1.0\n\n#endif\n\nfloat encodeColor(vec4 a){\n\t\n    // convert from [0, 1] to [0, color_maxValues]\n    // pre-multiply 0.5 to a to avoid overflow\n    a = floor(a * (premul_factor * color_maxValues) + 0.5);\n    \n    // bit shift then OR\n\treturn dot( a, color_positions );\n}\n\nvec4 decodeColor(float a){\n\n    // bit shift \n    // (we 1.0 / color_values so that we can use fract() instead of mod()) for bit masking\n    vec4 a4 = a * (color_rpositions / color_values);\n    \n    // bit masking for each component\n    // use fract() instead of mod() for performance reason\n    a4 = fract(a4);\n    \n    // since we are using fract(), we need to multiply color_values back to a4\n    // then convert from [0, color_maxValues] back to [0, 1]\n    // multiply by 2.0 to cancel out the pre-multiplication while encoding\n    return a4 * (r_premul_factor * color_values / color_maxValues);\n}\n\nvec4 getColorImpl(sampler2D a, sampler2D b, vec2 uv, float t) {\n    float p = 0.5;\n    return vec4(\n        texture(a,uv).rgb,\n        smoothstep(p, 1., texture(b,uv * 0.5 + vec2(0.0, t)).r));\n}\n\n#define getColor(uv) getColorImpl(iChannel0, iChannel1, uv, iTime * 0.02)","name":"Common","description":"","type":"common"}]}