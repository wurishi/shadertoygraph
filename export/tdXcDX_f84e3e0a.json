{"ver":"0.1","info":{"id":"tdXcDX","date":"1585872500","viewed":106,"name":"36 Days Of Type - J","username":"nicolasdnl","description":"36 Days Of Type - J","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["letter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat msign( in float x ) { return (x>0.0)?1.0:-1.0; }\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( dot2(pa-ba*h), ba.x*pa.y-ba.y*pa.x );\n}\n\nfloat sdCrescent(vec2 p, float r0, float r1, float d, float sign0, float sign1)\n{\n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n    if( a < r0)\n    {\n        p.y = abs(p.y);\n        float b = sqrt(r0*r0-a*a);\n        float k = p.y*a - p.x*b;\n        float h = min(d*sign0*(d*(p.y-b)-k ),\n                      d*sign1*k);\n        if (h>0.0)\n        {\n            return length(p-vec2(a,b));\n        }\n    }\n    \n    return max(sign0*(length(p          )-r0),\n               sign1*(length(p-vec2(d,0))-r1));\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, float d2min )\n{\n    vec2  ba  = b-a;\n    float l   = length(ba);\n    float ra2 = h*h + l*l*0.25;\n\n    // recenter\n    p -= (a+b)/2.0 + vec2(-ba.y,ba.x)*h/l;\n    \n    float m = ba.y*p.x-ba.x*p.y;\n    float n = dot(p,p);\n    \n    if( abs(h)*abs(ba.x*p.x+ba.y*p.y) < msign(h)*l*0.5*m )\n    {\n        d2min = min( d2min, n + ra2 - 2.0*sqrt(n*ra2) );\n    }\n\n    return vec2(d2min, -max(m,ra2-n) );\n}\n\n\n//------------------------------------------------------------\n\n\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[5], float kPath[13] )\n//float sdShape( in vec2 p, int kType[2], float kPath[7] )\n{\n    vec2 vb = vec2(kPath[0],kPath[1]);\n    \n    float d = dot2(p-vb);\n    int off = 0;\n    float s = 1.0;\n    for( int i=0; i<kType.length(); i++ )\n    {\n        vec2 va = vb;\n        vec2 ds;\n        \n        if( kType[i]==0) // line (x,y)\n        {\n            vb = vec2(kPath[off+2],kPath[off+3]);\n            ds = sdSqLine( p, va, vb );\n            off += 2;\n        }\n        else if( kType[i]==1 || kType[i]==2 ) // arc (x,y,r)\n        {\n            vb = vec2(kPath[off+3],kPath[off+4]);\n            ds = sdSqArc(p, va, vb, kPath[off+2], d );\n        \toff += 3;\n\n        }\n        \n        // in/out test\n        if ( kType[i]==2 )\n        {\n            bvec3 cond = bvec3( p.y<va.y, p.y<vb.y, ds.y>0.0 );\n            if( all(cond) || all(not(cond)) ) s*=-1.0;\n        }\n        else\n        {\n            bvec3 cond = bvec3( p.y>=va.y, p.y<vb.y, ds.y>0.0 );\n            if( all(cond) || all(not(cond)) ) s*=-1.0;\n        }\n\n        d = min( d, ds.x );\n    }\n    \n    if( p.y > 0. ) s*=-1.0;\n    \n\treturn s*sqrt(d);\n}\n\nfloat sdA( in vec2 p )\n{\n    float width = 1.;\n    float height = 1.;\n    \n   \tint kType[] = int[](0,0,2,0,0);\n\tfloat kPath[] = float[](  0.0,  height*0.5,\n                              width*0.5, height*0.5,\n                              width*0.5, 0.0, 0.0,\n                             -width*0.5, 0.0,\n                              0.0, 0.0,\n                              0.0,  height*0.5 );\n    /*int kType[] = int[](1,0);\n\tfloat kPath[] = float[](  width*0.5, 0.0, 0.0,\n                             -width*0.5, 0.0,\n                              width*0.5, 0.0 );*/\n    return sdShape(p,kType,kPath );\n}\n\nvec3 generateBorder(in vec3 col, in float border)\n{\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.015,border) );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec2 p2 = p;\n    \n    // distance computations\n    float lineWidth = 0.08;\n    \n    float dMask = sdA(p);\n    \n    float t = mod(iTime * 0.5, 1.) * PI * 2.;\n    \n    p += vec2(-sin(t), cos(t)) * 0.08;\n    float transform = sign(mod(p.x, lineWidth) / lineWidth - 0.5);\n    float d = sdA(p);\n    \n    p2 -= vec2(-sin(t), cos(t)) * 0.08;\n    float transform2 = sign(mod(p2.x, lineWidth) / lineWidth - 0.5);\n    float d2 = sdA(p2);\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(1.0);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.15,abs(d)) );\n    col *= transform;\n    \n    vec3 col2 = vec3(1.0) - sign(d2)*vec3(1.0);\n\tcol2 = mix( col2, vec3(1.0), 1.0-smoothstep(0.0,0.15,abs(d2)) );\n    col2 *= transform2;\n    \n    vec3 color = col + col2;\n    \n    float mask = 1. - sign(dMask);\n\tmask = mix(mask, 1., 1.0-smoothstep(0.0,0.05,abs(dMask)));\n    \n    //color = (1.-color)*mask + color*(1.-mask);\n    color *= 1.-mask;\n\n    // output\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}