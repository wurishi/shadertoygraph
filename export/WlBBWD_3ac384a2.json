{"ver":"0.1","info":{"id":"WlBBWD","date":"1598907598","viewed":157,"name":"Raymarching Performance Test","username":"j91000","description":"A performance test for a simple raymarched landscape","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raymarching code Created by Beautypi/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n//  click and drag: pan camera\n//  wasd: move camera\n//  shift/spacebar: raise and lower camera\n//  f: toggle water heightmap mode\n//  t: toggle sediment load display\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//DAD\n#define MAXSTEPS 200\n#define MAXDIST 8.\n#define STEPFAC .1\nvec4 getTerrain(in vec3 pos){\n    vec2 q = pos.xz*0.1;\n    return texture(iChannel0,q);\n}\nfloat cosNoise( in vec2 p )\n{\n    return 0.5*( sin(p.x) + sin(p.y) );\n}\n\nconst mat2 m2 = mat2(1.6,-1.2,\n                     1.2, 1.6);\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat terrainHeight(in vec3 pos){\n        float h = 0.0;\n    h=getTerrain(pos).x;\n    return h;\n}\nfloat map( in vec3 pos )\n{\n    \n    float d1 = pos.y-terrainHeight(pos)*2.;\n    return d1;//smin( d1, d2, 1.0 );\n}\n\nfloat mapH( in vec3 pos )\n{\n\n    float d1 = pos.y-terrainHeight(pos)*3.;\n    \n    \n    return d1;//smin( d1, d2, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0) * 0.01;\n    \n    return normalize( e.xyy*mapH( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*mapH( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*mapH( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*mapH( pos + e.xxx ) );\n}\n\nfloat softShadows( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = map( pos );\n        res = min( res, max(h,0.0)*164.0/t );\n        if( res<0.001 ) break;\n        t += h*0.5;\n    }\n    \n    return res;\n}\n\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}\nmat3 fetchMouseRotation(){\n    float pi = atan(1.0) * 4.0;\nfloat tau = atan(1.0) * 8.0;\n    \n        \n    //Camera stuff   \n    vec3 angles = vec3(0);\n    \n    if(true||iMouse.xy == vec2(0,0))\n    {\n\t\tangles = vec3(vec2(.5) * pi, 0.);///starting angle\n        angles.xy *= vec2(1., .5);///starting angle\n    }\n    else\n    {    \n    \tangles = vec3((iMouse.xy / iResolution.xy) * pi, 0);\n        angles.xy *= vec2(2.0, 1.0);\n    }\n    \n    angles.y = clamp(angles.y, 0.0, tau / 4.0);\n    return Rotate(vec3(pi/2.,pi,0.))*Rotate(angles.yxz);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{float pi = atan(1.0) * 4.0;\nfloat tau = atan(1.0) * 8.0;\n    \n        \n    //Camera stuff   \n   \n    mat3 rotate = fetchMouseRotation();\n    \n\tvec2 p = fragCoord.xy / iResolution.xy;\n    vec2 q = (-iResolution.xy + 2.0* fragCoord.xy) / iResolution.y;\n    \n    float ani = -20.0 ;\n    \n    // ray\n    vec3 ro = vec3( 0.0, 4.0, -ani*0.5 )+vec3(texture(iChannel1,p).xzy);\n    \n    float roll =0.; 0.2*sin(0.1*ani);\n    q = mat2( cos(roll), -sin(roll), sin(roll), cos(roll) ) * q;\n    \n    vec3 rd = (normalize( vec3(q-vec2(-0.4,0.4),-2.0) )*rotate);\n    //rd*=Rotate(vec3(.5,-2.,0.));//DAD\n    vec3 col = vec3( 0.7, 0.8, 1.0 );\n    col *= 1.0 - 0.5*rd.y;\n\n    // raymarcher\n    float tmax = MAXDIST;\n    float t = 0.0;\n \tbool oob=false;\n    for( int i=0; i<MAXSTEPS; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        vec2 bounds=pos.xz*.1;\n     float a=0.001;\n        if(bounds.x<a||bounds.y<a||bounds.x>1.-a||bounds.y>1.-a){oob=true;break;}\n        float h = map( pos );\n        if( h<0.001 || t>tmax ) break;\n        t += h*STEPFAC;\n    }\n\n    vec3 light = normalize( vec3( 1.0, 0.9, -1.0) );//SUNANGLE\n    // hit\n    if( t<tmax &&!oob)\n    {\n        // shade and light\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        \n        float bak = clamp( dot(nor,normalize(-vec3(light.x,0.0,light.z))), 0.0, 1.0 );\n        float dif = clamp( dot(nor,light), 0.0, 1.0 );\n        float sha =softShadows( pos+nor*.01, light );\n        vec3 lig = vec3(2.0,1.5,1.0)*dif*1.5*sha;\n             lig += vec3(0.2,0.3,0.4)*max(nor.y,0.0)*0.9;\n             lig += vec3(0.1,0.1,0.1)*bak*0.5;\n        vec3 mate = vec3(0.3,0.3,0.3)*0.5;\n        vec3 tint=clamp(1.+5.*getTerrain(pos).yzw,0.,2.5);\n        mate = mix( mate*tint, tint*vec3(0.2,0.15,0.1)*0.73, smoothstep( 0.2,0.9,1.1*pow(nor.y,.8)));//nor.y) );\n        mate *=0.5 + texture( iChannel0, 0.5*pos.xz ).x*1.0;\n \n        col = mate * lig;\n\n        float fog = exp( -0.0015*t*t );\n        col *= fog;\n        col += (1.0-fog)*vec3(0.5,0.6,0.7);\n    }\n\n    float sun = clamp( dot(rd,light), 0.0, 1.0 );\n    col += vec3(1.0,0.8,0.6)*0.4*pow(sun,16.0);\n    col += vec3(1.0,0.8,0.6)*0.3*pow(sun,8.0);\n    \n    col = sqrt( col );\n    \n    col *= 0.5 + 0.5*pow(16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y),0.2);\n    \n    col = smoothstep( 0.0, 1.0, col );\n\n    col = mix( col, vec3(dot(col,vec3(0.33))), -0.25 );\n    \n\tfragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{float PI = atan(1.0) * 4.0;\n vec2 uv=fragCoord/iResolution.xy-vec2(.5);\n \n \n    vec4 finalC=vec4(sin(2.*PI*length(uv)));\n finalC-=texture(iChannel0,fragCoord/iResolution.xy);\n    fragColor = finalC;\n   if(fragCoord.x<1.||fragCoord.y<1.||fragCoord.x>iResolution.x-1.||fragCoord.y>iResolution.y-1.){fragColor=vec4(0.);}\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//this buffer stores the camera position, and applies keyboard inputs.\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPC =32 ;\nconst int KEY_SHIFT = 16;\nconst int KEY_A=65;\nconst int KEY_D=68;\nconst int KEY_W=87;\nconst int KEY_S=83;\n\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}    \nmat3 fetchMouseRotation(){\n    float pi = atan(1.0) * 4.0;\nfloat tau = atan(1.0) * 8.0;\n    \n        \n    //Camera stuff   \n    vec3 angles = vec3(0);\n    \n    if(true||iMouse.xy == vec2(0,0))//DAD\n    {\n        angles.y = tau * (1.5 / 8.0);\n        angles.x = iTime * 0.1;\n    }\n    else\n    {    \n    \tangles = vec3((1.-(iMouse.xy*vec2(1.,0.)+vec2(0.,iResolution.y)) / iResolution.xy) * pi, 0);\n        angles.xy *= vec2(2.0, 1.0);\n    }\n    \n    //angles.y = clamp(angles.y, 0.0, tau / 4.0);\n    return Rotate(vec3(0.,0.,-pi/2.))*Rotate(angles.yxz);\n}\n    \nvec3 keys(vec2 uv){\n    vec3 result=vec3(0.);\n if(0.<texelFetch( iChannel2, ivec2(KEY_SPC,0), 0 ).x){\n result+=vec3(-1.,0.,0.);\n }\n if(0.<texelFetch( iChannel2, ivec2(KEY_SHIFT,0), 0 ).x){\n result+=vec3(1.,0.,0.);\n }\n if(0.<texelFetch( iChannel2, ivec2(KEY_W,0), 0 ).x){\n     result+=vec3(0.,-1.,0.);\n }\n if(0.<texelFetch( iChannel2, ivec2(KEY_S,0), 0 ).x){\n     result+=vec3(0.,1.,0.);\n }\n    if(0.<texelFetch(iChannel2, ivec2(KEY_D,0),0).x){\n        result+=vec3(0.,0.,-1.);\n    }\n    if(0.<texelFetch( iChannel2, ivec2(KEY_A,0), 0 ).x){\n        result+=vec3(0.,0.,1.);\n    }\n    vec3 strt=normalize( vec3(0.-vec2(-0.4,0.4),-2.0));//vec3(1.,1.,-1.)\n    return (result/40.)*fetchMouseRotation();\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{vec2 uv=fragCoord/iResolution.xy;\n    vec3 data=texture(iChannel0,uv).xyz;\n    fragColor = vec4(data.xyz+keys(uv).zxy,.0);\n if(iFrame<100){fragColor=vec4(7.,-4.,-.5,0.);}//DAD\n}","name":"Buffer D","description":"","type":"buffer"}]}