{"ver":"0.1","info":{"id":"4d3GD8","date":"1449164542","viewed":186,"name":"sRGB demo, mod","username":"qwerty","description":"Modification of original \"sRGB demo\" from https://www.shadertoy.com/view/lsd3zN\nThis shows what would happen if textures were stored in linear format.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["srgb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//////////////////////////////////////////////////////////\n//\n// Modification of original sRGB demo from \n// https://www.shadertoy.com/view/lsd3zN\n//\n// This illustrates why we do use linear space to store\n// colours in in non-floating point textures.\n//\n// First, a gradient that appears linear (but is does not\n// actually have linear luminance) is created.\n//\n// Then, it is \"stored\" using:\n//  - left:   linear representation\n//  - middle: sRGB\n//  - right:  2.2 gamma\n// \n// which is then quantised to 6 bit, unpacked back\n// to linear, and again converted to expected output\n// format.\n//\n// Try changing the bit count - banding is still visible \n// with 8 bit precision!\n//\n//////////////////////////////////////////////////////////\n\nconst float bitCount = 6.0;\n\n\n// Taken from D3DX_DXGIFormatConvert.inl\nfloat D3DX_FLOAT_to_SRGB ( float val )\n{\n\tif( val < 0.0031308 )\n\t\tval *= 12.92;\n\telse\n\t\tval = 1.055 * pow(val,1.0/2.4) - 0.055;\n\treturn val;\n}\n\n// Taken from D3DX_DXGIFormatConvert.inl\n// Technically this is not bit-exact - that requires a look-up table,\n// but it's accurate enough for our purposes here.\nfloat D3DX_SRGB_to_FLOAT(float val)\n{\n    if( val < 0.04045 )\n        val /= 12.92;\n    else\n        val = pow((val + 0.055)/1.055,2.4);\n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float yShade = uv.y;\n\n    int colCol = int(floor(uv.x*4.0));\n\tfloat fraction = uv.x*4.0 - float(colCol);\n    int colRamp = int(floor(fraction * 3.1));\n       \n    // Make the basic colour.\n    vec3 baseCol;\n    if ( colCol == 0 )\n    {\n        baseCol = vec3(yShade,yShade,yShade); // white\n    }\n    else if ( colCol == 1 )\n    {\n        baseCol = vec3(yShade*0.6,yShade,0.0); // light green\n    }\n    else if ( colCol == 2 )\n    {\n        baseCol = vec3(yShade,yShade*0.5,yShade*0.2); // bronzeish\n    }\n    else\n    {\n        baseCol = vec3(yShade*0.5,0.0,yShade); // purple\n    }\n\n//  start from an eye-pleasing gradient based on 2.2 gamma ramp, stored in linear space\n//  (this looks like an evenly distributed gradient to a human eye, although the actual\n//  distribution of light is not linear)\n\tvec3 linearCol;    \n    linearCol.x = pow ( baseCol.x, 2.2 );\n    linearCol.y = pow ( baseCol.y, 2.2 );\n    linearCol.z = pow ( baseCol.z, 2.2 );\n\n   \n    \n//  now emulate storing it into a texture format using various interpretations \n    vec3 compressedCol;\n    if ( colRamp == 0 )\n    {\n        // Linear texture\n        compressedCol = linearCol;\n    }\n    else if ( colRamp == 1 )\n    {\n        // sRGB texture\n        compressedCol.x = D3DX_FLOAT_to_SRGB ( linearCol.x );\n        compressedCol.y = D3DX_FLOAT_to_SRGB ( linearCol.y );\n        compressedCol.z = D3DX_FLOAT_to_SRGB ( linearCol.z );\n    }\n    else if ( colRamp == 2 )\n    {\n        // 2.2 gamma for illustration\n        compressedCol.x = pow ( linearCol.x, 1.0/2.2 );\n        compressedCol.y = pow ( linearCol.y, 1.0/2.2 );\n        compressedCol.z = pow ( linearCol.z, 1.0/2.2 );\n    }\n    \n    \n   // Artificially quantise to emulate texture bit depth\n   float shadeSteps = pow ( 2.0, bitCount );\n   compressedCol = (1.0/shadeSteps) * floor ( compressedCol * shadeSteps );\n\n   // Now decompress back into linear to emulate texture loading\n   if ( colRamp == 0 )\n   {\n      // Linear texture\n      linearCol = compressedCol;\n   }\n   else if ( colRamp == 1 )\n   {\n      // sRGB texture\n      linearCol.x = D3DX_SRGB_to_FLOAT ( compressedCol.x );\n      linearCol.y = D3DX_SRGB_to_FLOAT ( compressedCol.y );\n      linearCol.z = D3DX_SRGB_to_FLOAT ( compressedCol.z );\n   }\n   else if ( colRamp == 2 )\n   {\n      // 2.2 gamma for illustration\n      linearCol.x = pow ( compressedCol.x, 2.2 );\n      linearCol.y = pow ( compressedCol.y, 2.2 );\n      linearCol.z = pow ( compressedCol.z, 2.2 );\n   }\n   else\n   {\n      // Separator.\n      linearCol = vec3(0.0,0.0,0.0);\n   }\n    \n\n   // But then assume the display we're outputting to is gamma 2.2\n   // (or if we are using a _SRGB render target then this is not needed)\n   float displayGamma = 2.2;\n   fragColor.x = pow ( linearCol.x, 1.0/displayGamma );\n   fragColor.y = pow ( linearCol.y, 1.0/displayGamma );\n   fragColor.z = pow ( linearCol.z, 1.0/displayGamma );\n   fragColor.w = 1.0;\n}","name":"","description":"","type":"image"}]}