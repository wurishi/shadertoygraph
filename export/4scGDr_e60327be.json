{"ver":"0.1","info":{"id":"4scGDr","date":"1448929402","viewed":1980,"name":"Fake TV Screen Malfunction","username":"TambakoJaguar","description":"Transforms your webcam in an old telly which doesn't work well anymore! ;)\n\nStill a work in progress, I have more ideas and I have to optimize the occurence of the random events.\n\nComments, suggestions and whatever are welcome.","likes":18,"published":1,"flags":10,"usePreview":0,"tags":["noise","color","tv","random","fun","webcam","television","telly","malfunction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Fake TV Screen Malfunction by Tambako\n//\n// To add:\n// * Smooth vert borders. Maybe lighter ?\n// * Black and white color definitions\n// * Emboss ?\n// * Vignette\n// * Horizontal oscillations\n// * Global time scale for harmonics etc.\n// * Saturation + contrast\n// * Convolution (separate for image and for noise)\n// * Sound\n//\n// - Set harmonics as arrays \n// - Warp ?\n// - Scanlines ?\n// - Specular ?\n\nconst vec3 black_point = vec3(0.05, 0.08, 0.24);\nconst vec3 white_point = vec3(0.94, 0.90, 0.87);\n\nconst float im_saturation = 0.5;\nconst float im_contrast = 1.2;\nconst float im_brightness = 0.1;\n\nconst float noise1_min = 0.13;\nconst float noise1_max = 0.93;\nconst vec4 noise1_freq = vec4(1.4, 2.2, 3.8, 4.2);\nconst vec4 noise1_amp = vec4(2.5, 1.85, 1.22, 0.9);\nconst float noise1_threshold = 0.83;\n\nconst float noise2_min = 0.06;\nconst float noise2_max = 0.81;\nconst vec4 noise2_freq = vec4(0.75, 1.74, 2.12, 3.05);\nconst vec4 noise2_amp = vec4(2.2, 1.45, 1.12, 0.7);\nconst float noise2_threshold = 0.78;\nconst float noise2_saturation = 0.2;\n\nconst vec4 colhsh_freq = vec4(0.86, 1.32, 1.82, 2.25);\nconst vec4 colhsh_amp = vec4(1.45, 2.35, 1.12, 0.58);\nconst float colhsh_threshold = 0.92;\nconst float colhsh_intmin = 0.37;\nconst float colhsh_intmax = 0.40;\n\nconst vec4 colvsh_freq = vec4(0.46, 1.92, 3.82, 4.15);\nconst vec4 colvsh_amp = vec4(2.45, 1.35, 1.02, 0.5);\nconst float colvsh_threshold = 0.92;\nconst float colvsh_intmin = 2.80;\nconst float colvsh_intmax = 2.85;\n\nconst vec4 vsize_freq = vec4(0.045, 0.084, 0.112, 0.161);\nconst vec4 vsize_amp = vec4(1.6, 2.3, 2.7, 1.3);\nconst float vsize_threshold = 0.73;\nconst float vsize_factor = 0.21;\n\nconst mat3 im_convm = mat3( 1.0,  2.0,  -4.0,\n                            2.0,  3.0,  3.0,\n                           -2.0,  2.0,  1.0);\n\nconst mat3 noise_convm = mat3( 1.0,  2.0,  1.0,\n                               2.0,  6.0,  0.0,\n                              -2.0,  2.0,  1.0);\n\nconst float border_smoothness1 = 0.012;\nconst float border_smoothness2 = 0.020;\nconst float border_maxint = 1.16;\n\nconst float vig_falloff = 0.32;\n\nconst float emb_delta = 3.;\nconst float emb_int = 0.07;\nconst vec2 emb_speed = vec2(400., 100);\n\nconst float hosc_yfreq1 = 105.;\nconst float hosc_tfreq1 = 34.;\nconst float hosc_amp1 = 0.00036;\nconst float hosc_yfreq2 = 188.;\nconst float hosc_tfreq2 = 57.;\nconst float hosc_amp2 = 0.00024;\n\nconst float time_factor = 0.75;\n\nfloat rand1(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.,85.5))) * 120.01);\n}\n\nfloat rand2(vec2 co)\n{\n    float r1 = fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n    return fract(sin(dot(vec2(r1, co.xy*1.562) ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 noise1(vec2 fragCoord)\n{\n\tvec2 uvr = 1.1*fragCoord.xy / iResolution.xy + iTime*14.9;\n    \n    return vec4(vec3(rand1(uvr)*0.7+0.3), 1.0);   \n}\n\nvec4 noise2(vec2 fragCoord)\n{\n\tvec2 uvr = 1.124*fragCoord.xy / iResolution.xy + iTime*3.3242;\n    vec2 uvg = 2.549*fragCoord.xy / iResolution.xy + iTime*4.2623;\n    vec2 uvb = 3.846*fragCoord.xy / iResolution.xy + iTime*6.2344;\n    \n    return vec4(mix(vec3(rand2(uvr))*1.5, vec3(rand2(uvr), rand2(uvg), rand2(uvb)), noise2_saturation), 1.0);\n}\n\nvec4 noise1conv(mat3 mat, vec2 pos)\n{\n   vec4 pixval = vec4(0.);\n   float csum = 0.;\n   \n   for (int y=0; y<3; y++)\n   {\n       for (int x=0; x<3; x++)\n       {\n           vec2 ipos = pos + vec2(float(x-1), float(y-1));\n           pixval+= noise1(ipos)*mat[x][y];\n           csum+= mat[x][y];\n       }\n   }\n   return pixval/csum; \n}\n\nvec4 noise2conv(mat3 mat, vec2 pos)\n{\n   vec4 pixval = vec4(0.);\n   float csum =0.;\n   \n   for (int y=0; y<3; y++)\n   {\n       for (int x=0; x<3; x++)\n       {\n           vec2 ipos = pos + vec2(float(x-1), float(y-1));\n           pixval+= noise2(ipos)*mat[x][y];\n           csum+= mat[x][y];\n       }\n   }\n   return pixval/csum; \n}\n\nfloat harms(vec4 freq, vec4 amp, float threshold)\n{\n   float val = 0.;\n   for (int h=0; h<4; h++)\n      val+= amp[h]*sin(iTime*time_factor*freq[h]);\n   val = (1. + val/(amp[0]+amp[1]+amp[2]+amp[3]))/2.;\n   return smoothstep(threshold, 1., val);\n}\n\nvec4 iconv(mat3 mat, vec2 pos)\n{\n   vec4 pixval = vec4(0.);\n   float csum =0.;\n   \n   for (int y=0; y<3; y++)\n   {\n       for (int x=0; x<3; x++)\n       {\n           vec2 ipos = pos + vec2(float(x-1)/iResolution.x, float(y-1)/iResolution.y);\n           pixval+= texture(iChannel0, ipos)*mat[x][y];\n           csum+= mat[x][y];\n       }\n   }\n   return pixval/csum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 im;\n    vec2 uv0 = fragCoord.xy / iResolution.xy;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float iTime2 = iTime*time_factor;\n    \n    // Vertical size\n    float vsize_f = 1. + vsize_factor*harms(vsize_freq, vsize_amp, vsize_threshold);\n    uv = uv*vec2(1., vsize_f) + vec2(0., (1.-vsize_f)/2.);\n    float vsize_f2 = border_smoothness1 + border_smoothness2 - 0.005;\n    uv.y*= 1. - 2.*vsize_f2;\n    uv.y+= vsize_f2;\n    \n    // Side oscillations\n    uv.x+= hosc_amp1*(sin(uv.y*hosc_yfreq1 + iTime2*hosc_tfreq1));\n    uv.x+= hosc_amp2*(sin(uv.y*hosc_yfreq2 + iTime2*hosc_tfreq2));\n\n    // Color specific dynamic shift\n    float colhsh_d = harms(colhsh_freq, colhsh_amp, colhsh_threshold);\n    float colvsh_d = harms(colvsh_freq, colvsh_amp, colvsh_threshold);\n    \n    vec2 uvr = mod(uv + vec2(colhsh_d*colhsh_intmin, colvsh_d*colvsh_intmin), 1.);\n    vec2 uvg = mod(uv + vec2(colhsh_d*(colhsh_intmin + colhsh_intmax)/2., colvsh_d*(colvsh_intmin + colvsh_intmax)/2.), 1.);\n    vec2 uvb = mod(uv + vec2(colhsh_d*colhsh_intmax, colvsh_d*colvsh_intmax), 1.);\n    \n    vec4 wcam;\n    \n    // Convolution\n    //wcam.r = texture(iChannel0, uvr).r;\n    //wcam.g = texture(iChannel0, uvg).g;\n    //wcam.b = texture(iChannel0, uvb).b;\n    wcam = iconv(im_convm, uvr); \n    wcam*= vsize_f;\n    \n    // Saturation\n    wcam = mix(vec4((wcam.r + wcam.g + wcam.b)/3.), wcam, im_saturation);\n    \n    // Constrast\n    wcam = wcam*im_contrast - 0.5*im_contrast + 0.5 + im_brightness;\n    \n    // Emboss\n    vec2 d = iTime2 * emb_speed;\n    vec2 uv1 = uv - d/iResolution.xy;\n    vec2 uv2 = uv  + (vec2(emb_delta, emb_delta) - d)/iResolution.xy;\n    uv1 = mod(uv1, 1.);\n    uv2 = mod(uv2, 1.);\n    vec4 embc = texture(iChannel0,uv2) - texture(iChannel0,uv1);\n    float embi = emb_int*(embc.r + embc.g + embc.b)/3.;\n    im = wcam + vec4(embi, embi, embi, 1.);\n    \n    // Pseudo-harmonic noise\n    float noise1_b = harms(noise1_freq, noise1_amp, noise1_threshold)*(noise1_max-noise1_min)+noise1_min;\n    im = mix(im, noise1conv(noise_convm, fragCoord), noise1_b);\n    \n    // White noise\n    float noise2_b = harms(noise2_freq, noise2_amp, noise2_threshold)*(noise2_max-noise2_min)+noise2_min;\n    im = mix(im, noise2conv(noise_convm, fragCoord), noise2_b);\n    \n    // Black and white point\n    im = im*vec4(white_point - black_point, 1.) + vec4(black_point, 1.);\n    \n    // Vignette (www.shadertoy.com/view/4lSXDm)\n    vec2 coord = (uv0 - 0.5) * (iResolution.x/iResolution.y) * 2.0;\n    float rf = sqrt(dot(coord, coord)) * vig_falloff;\n    float rf2_1 = rf * rf + 1.0;\n    float e = 1.0 / (rf2_1 * rf2_1);\n    im*= e;\n    \n    // Top/bottom borders\n    float border_maxint2 = border_maxint*vsize_f;\n    float border_smoothness22 = border_smoothness2*pow(vsize_f, 2.);\n    im*= smoothstep(0., border_smoothness1, uv.y)*(1. - smoothstep(1.-border_smoothness1, 1., uv.y));\n    im*= border_maxint2*(1./border_maxint2 + (1. - 1./border_maxint2)*(1. - smoothstep(border_smoothness1, border_smoothness1 + border_smoothness22, uv.y)));\n    im*= border_maxint2*(1./border_maxint2 + (1. - 1./border_maxint2)*(smoothstep(1. - border_smoothness1 - border_smoothness22, 1. - border_smoothness1, uv.y)));    \n    \n    fragColor = im;\n}","name":"","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float pi = 3.1415926;\n\nconst float noise1_min = 0.03;\nconst float noise1_max = 0.93;\nconst vec4 noise1_freq = vec4(1.4, 2.2, 3.8, 4.2);\nconst vec4 noise1_amp = vec4(2.5, 1.85, 1.22, 0.9);\nconst float noise1_threshold = 0.83;\n\nconst float noise2_min = 0.04;\nconst float noise2_max = 0.81;\nconst vec4 noise2_freq = vec4(0.75, 1.74, 2.12, 3.05);\nconst vec4 noise2_amp = vec4(2.2, 1.45, 1.12, 0.7);\nconst float noise2_threshold = 0.78;\nconst float noise2_saturation = 0.2;\n\nconst vec4 vsize_freq = vec4(0.045, 0.084, 0.112, 0.161);\nconst vec4 vsize_amp = vec4(1.6, 2.3, 2.7, 1.3);\nconst float vsize_threshold = 0.73;\nconst float vsize_factor = 0.16;\n\nconst float hosc_tfreq1 = 105.;\nconst float hosc_amp1 = 0.012;\nconst float hosc_tfreq2 = 188.;\nconst float hosc_amp2 = 0.018;\n\nconst float time_factor = 0.75;\n\nfloat rand1(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.,85.5))) * 120.01);\n}\n\nfloat rand2(vec2 co)\n{\n    float r1 = fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n    return fract(sin(dot(vec2(r1, co.xy*1.562) ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat harms(vec4 freq, vec4 amp, float threshold, float iTime)\n{\n   float val = 0.;\n   for (int h=0; h<4; h++)\n      val+= amp[h]*sin(iTime*time_factor*freq[h]);\n   val = (1. + val/(amp[0]+amp[1]+amp[2]+amp[3]))/2.;\n   return smoothstep(threshold, 1., val);\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    // Pseudo-harmonic noise\n    float noise1_b = harms(noise1_freq, noise1_amp, noise1_threshold, time)*(noise1_max-noise1_min)+noise1_min;\n    \n    // White noise\n    float noise2_b = harms(noise2_freq, noise2_amp, noise2_threshold, time)*(noise2_max-noise2_min)+noise2_min;\n    \n    // Side oscillations\n    float hosc1 = hosc_amp1*(smoothstep(abs(sin(time*hosc_tfreq1*2.*pi)), 0.12, 0.19));\n    float hosc2 = hosc_amp2*(smoothstep(abs(sin(time*hosc_tfreq2*2.*pi)), 0.12, 0.17));\n    \n    // Vertical size\n    float vsize_f = 1. + vsize_factor*harms(vsize_freq, vsize_amp, vsize_threshold, time);\n    \n    vec2 timevec = vec2((vsize_f - 1.)*1.5 + time*1.5, (vsize_f - 1.)*25. + 30.+time*1.6);\n    return vsize_f*vec2(noise1_b*rand1(timevec) + noise2_b*rand2(timevec) + hosc1+hosc2);\n    //return vec2(hosc1+hosc2);\n}","name":"","description":"","type":"sound"}]}