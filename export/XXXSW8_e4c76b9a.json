{"ver":"0.1","info":{"id":"XXXSW8","date":"1709398749","viewed":188,"name":"Stupid Ray Tracer","username":"DesertedGecko15","description":"a stupid ray tracer.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","balls","graphics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\nfloat random(inout uint state) \n{\n    uint a = uint(747796405);\n    uint b = uint(2891336453);\n    uint c = uint(28);\n    uint d = uint(4);\n    uint e = uint(277803737);\n\n    state = state * a + b;\n    uint result = ((state >>((state >> c) + d)) ^ state) * e;\n    return float(result) / 4294967295.0;\n}\nfloat randomNormalDistribution(inout uint seed) \n{\n    float theta = 2.0 * PI * random(seed);\n    float rho = sqrt(-2.0 * log(random(seed)));\n    return rho * cos(theta);\n}\nvec3 randomDirection(inout uint seed) \n{\n    float x = randomNormalDistribution(seed);\n    float y = randomNormalDistribution(seed);\n    float z = randomNormalDistribution(seed);\n    return normalize(vec3(x, y, z));\n}\n\nvec2 equirectangularProjection(vec3 p)\n{\n    float u = 0.5 + atan(p.x/p.z)/(2.0 * PI);\n    float v = 0.5 + asin(p.y)/PI;\n    return vec2(u, -v);\n}\n\nstruct Ray \n{\n    vec3 origin;\n    vec3 direction;\n};\nvec3 rayPoint(Ray ray, float t)\n{\n    return ray.origin + ray.direction * t;\n}\nstruct Material\n{\n    vec3 color;\n    float roughness;\n    float transmission;\n    float emission;\n};\nstruct HitInfo\n{\n    bool hasHit;\n    float t;\n    Material material;\n    vec3 hitNormal;\n};\nstruct Plane\n{\n    vec3 origin;\n    vec3 normal;\n    Material material;\n    bool isVisible;\n};\nstruct Sphere\n{\n    vec3 origin;\n    float radius;\n    Material material;\n    bool isVisible;\n};\nstruct Light\n{\n    vec3 origin;\n    float radius;\n    vec3 color;\n    float strength;\n    bool isVisible;\n};\n\nint numSamples = 2;\nint numLightBounces = 2;\nfloat blurDistance = 0.1;\nfloat blurStrength = 0.0;\nconst float fov = 60.0 * PI / 180.0;\n\nSphere spheres[3];\nPlane planes[1];\nLight lights[1];\n\nint numSpheres = 3;\nint numPlanes = 1;\nint numLights = 1;\n\nMaterial nullMaterial = Material(vec3(0.0, 0.0, 0.0), 0.0, 0.0, 0.0);\nHitInfo nullHitInfo = HitInfo(false, 10000000.0f, Material(vec3(0.0, 0.0, 0.0), 0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0));\n\nvoid generateObjects()\n{\n    Sphere sphere1 = Sphere(vec3(0.0, 0.0, 0.0), 1.5, Material(vec3(1.0, 1.0, 1.0), 1.0, 1.0, 0.0), true);\n    Sphere sphere2 = Sphere(vec3(-4.0, 0.0, 0.0), 1.5, Material(vec3(1.0, 0.0, 0.0), 1.0, 0.0, 0.0), true);\n    Sphere sphere3 = Sphere(vec3(4.0, 0.0, 0.0), 1.5, Material(vec3(0.3, 0.3, 1.0), 1.0, 0.0, 0.0), true);\n\n    Plane plane1 = Plane(vec3(0.0, -1.5, 0.0), vec3(0.0, 1.0, 0.0), Material(vec3(1.0, 0.0, 0.0), 0.1, 0.0, 0.0), true);\n    Light light1 = Light(vec3(0.0, 7.0, 0.0), 3.0, vec3(1.0, 1.0, 1.0), 500.0, true);\n   \n    spheres[0] = sphere1;\n    spheres[1] = sphere2;\n    spheres[2] = sphere3;\n    \n    planes[0] = plane1;\n    \n    lights[0] = light1;\n}\n\nHitInfo hitPlane(Ray ray, Plane plane)\n{\n    if (!plane.isVisible)\n        return nullHitInfo;\n\n    float dn = dot(ray.direction, plane.normal);\n    if (dn == 0.0) return nullHitInfo;\n\n    float t = dot(plane.origin - ray.origin, plane.normal)/dn;\n    if (t < 0.001)\n        return nullHitInfo;\n    return HitInfo(true, t, plane.material, plane.normal);\n}\n\nHitInfo hitSphere(Ray ray, Sphere sphere)\n{\n    if (!sphere.isVisible)\n        return nullHitInfo;\n\n    vec3 rayOrigin = ray.origin - sphere.origin;\n    vec3 rayDirection = ray.direction;\n\n    float rayDirectionLength = length(rayDirection);\n    float rayOriginLength = length(rayOrigin);\n\n    float a = rayDirectionLength * rayDirectionLength;\n    float b = 2.0 * dot(rayDirection, rayOrigin);\n    float c = rayOriginLength * rayOriginLength - sphere.radius * sphere.radius;\n\n    float d = b*b - 4.0 * a * c;\n    \n    if (d < 0.0f)\n        return nullHitInfo;\n\n    float t1 = (-b + sqrt(d))/(2.0*a);\n    float t2 = (-b - sqrt(d))/(2.0*a);\n\n    float t = 10000000.0f;\n    \n    if (t1 > 0.001 && t1 < t)\n        t = t1;\n    if (t2 > 0.001 && t2 < t)\n        t = t2;\n    \n    return HitInfo(true, t, sphere.material, rayPoint(ray, t) - sphere.origin);\n}\n\nHitInfo hitScene(Ray ray)\n{\n    HitInfo closestHit = nullHitInfo;\n    for (int i = 0; i < numSpheres; i++)\n    {\n        HitInfo hitInfo = hitSphere(ray, spheres[i]);\n        if (!hitInfo.hasHit) continue;\n        if (hitInfo.t < closestHit.t) closestHit = hitInfo;\n    }\n    for (int i = 0; i < numPlanes; i++)\n    {\n        HitInfo hitInfo = hitPlane(ray, planes[i]);\n        if (!hitInfo.hasHit) continue;\n        if (hitInfo.t < closestHit.t) closestHit = hitInfo;\n    }\n    return closestHit;\n}\n\nvec3 calculateDirectLight(vec3 surfaceNormal, vec3 hitPoint, Material material, inout uint seed)\n{\n    vec3 totalDirectLight = vec3(0.0, 0.0, 0.0);\n\n    Light light = lights[0];\n    vec3 shadowRayDirection = light.origin - hitPoint + randomDirection(seed) * light.radius;\n    float distanceToLight = length(shadowRayDirection);\n    shadowRayDirection = normalize(shadowRayDirection);\n    Ray shadowRay = Ray(hitPoint, shadowRayDirection);\n    HitInfo closestHit = hitScene(shadowRay);\n\n    if (closestHit.hasHit && closestHit.t < distanceToLight) \n        return vec3(0.0, 0.0, 0.0);\n\n    vec3 directLight = material.color * light.color * light.strength * dot(normalize(surfaceNormal), shadowRayDirection);\n    totalDirectLight += (directLight / (4.0 * PI * distanceToLight*distanceToLight));\n\n    return totalDirectLight + material.color * material.emission * 10.0;\n}\n\nvec3 calculateIndirectLight(Ray incidentRay, vec3 normal, vec3 hitPoint, Material hitMaterial, int maxBounces, inout uint seed)\n{\n    vec3 totalIndirectLight = vec3(0.0, 0.0, 0.0);\n    \n    for (int i = 0; i < maxBounces; i++)\n    {\n        vec3 reflectedRayDirection = normalize(incidentRay.direction) - 2.0 * dot(normalize(incidentRay.direction), normalize(normal)) * normal;\n        reflectedRayDirection = normalize(reflectedRayDirection + randomDirection(seed) * hitMaterial.roughness);\n        Ray reflectedRay = Ray(hitPoint, reflectedRayDirection);\n        HitInfo hitInfo = hitScene(reflectedRay);\n\n        if (hitInfo.hasHit)\n        {\n            totalIndirectLight += hitMaterial.color * calculateDirectLight(hitInfo.hitNormal, rayPoint(reflectedRay, hitInfo.t), hitInfo.material, seed);\n        }\n        else \n        {\n            vec4 hdriColor = texture(iChannel0, reflectedRayDirection);\n            totalIndirectLight += hitMaterial.color * vec3(hdriColor);\n        }\n        incidentRay = reflectedRay;\n        normal = hitInfo.hitNormal;\n        hitPoint = rayPoint(reflectedRay, hitInfo.t);\n        hitMaterial = hitInfo.material;\n    }\n    return totalIndirectLight / float(maxBounces) * 2.0;\n}\n\nvec3 trace(Ray ray, int maxBounces, inout uint seed)\n{\n    HitInfo closestHit = hitScene(ray);\n    if(closestHit.hasHit)\n    {\n        vec3 hitPoint = rayPoint(ray, closestHit.t);\n        vec3 directLight = calculateDirectLight(closestHit.hitNormal, hitPoint, closestHit.material, seed);\n        vec3 indirectLight = calculateIndirectLight(ray, closestHit.hitNormal, hitPoint, closestHit.material, maxBounces, seed);\n\n        return indirectLight + directLight;\n    }\n    vec2 textureCoordinate = equirectangularProjection(ray.direction);\n    vec4 texturePixelColor = texture(iChannel0, ray.direction);\n    return vec3(texturePixelColor);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    generateObjects();\n    uint seed = uint(gl_FragCoord.y * iResolution.x + gl_FragCoord.x);\n       \n    vec3 cameraOrigin = vec3(0.0, 1.0, -30.0);\n    vec3 cameraForward = vec3(0.0, 0.0, 1.0);\n    vec3 cameraRight = vec3(tan(fov/2.0), 0.0, 0.0);\n    vec3 cameraUp = vec3(0.0, tan(fov/2.0) * float(iResolution.y)/float(iResolution.x), 0.0);\n\n    float x = (gl_FragCoord.x - (float(iResolution.x)/2.0f)) / float(iResolution.x);\n    float y = (gl_FragCoord.y - (float(iResolution.y)/2.0f)) / float(iResolution.y);\n\n    vec3 rayDirection = normalize(cameraForward + x * cameraRight + y * cameraUp);\n    Ray ray = Ray(cameraOrigin, rayDirection);\n    vec3 rayPoint = rayPoint(ray, max(0.001, blurDistance));\n\n    vec3 averageColor = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < numSamples; i++)\n    {\n        ray.origin += randomDirection(seed) * blurStrength;\n        ray.direction = normalize(rayPoint - ray.origin);\n        averageColor += trace(ray, numLightBounces, seed);\n    }\n\n    fragColor = vec4(averageColor/float(numSamples), 1.0);\n}","name":"Image","description":"","type":"image"}]}