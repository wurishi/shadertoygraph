{"ver":"0.1","info":{"id":"NdSfRd","date":"1649339920","viewed":102,"name":"Rotating Box","username":"HinoKuro","description":"Rotating Box - LP MI AW","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["rotatingbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Alain Baptista - LP MI AW\n#define R iResolution.xy\n#define DIST_MIN 0.5 // minimum distance to objects\n#define DIST_MAX 50.0 // maximum distance to objects\n#define RAY_MARCH_STEPS 100\n#define RAY_MARCH_PRECI 0.001\n#define PI 3.14159265359\n\n// ray structure\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction\n};\n\n// Surface Structure\nstruct Surface {\n    float t; // surface distance\n    vec3 c; // surface color\n};\n\n// Fonction pour ajouter 2 surfaces\nSurface add( Surface s1, Surface s2) {\n if(s1.t < s2.t) return s1;\n return s2;\n}\n\n// Fonction pour ajouter un téthraèdre\nSurface sdOctahedron( vec3 p, float s, vec3 col)\n{\n  p = abs(p);\n  float dist = (p.x+p.y+p.z-s)*0.57735027;\n  return Surface(dist,col);\n}\n\n// Fonction pour ajouter une boite \"creuse\"\nSurface sdBoxFrame( vec3 p, vec3 b, float e, vec3 col )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  float dist = min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n  return Surface(dist, col);\n}\n\n\n// Matrix de rotation sur l'axe X\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n// Matrix de rotation sur l'axe Y\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n// Matrix de rotation sur l'axe Z\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Fonction pour créer la scene\nSurface scene(in vec3 p, in vec2 uv) {\n    vec3 t = p*6.;\n    float v1 = cos(t.x)*cos(t.y)*cos(t.z)/5.;\n    vec3 transfo = rotateY(2.0*iTime)*p*rotateZ(0.)*rotateX(1.3)*rotateY(1.3);\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col2 = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(4.,2.,0.));\n\n    Surface s1 = sdBoxFrame(transfo,vec3(2.,2.,2.),0.2,col);\n    Surface s2 = sdOctahedron(p*rotateY(1.)*rotateY(-iTime),abs(cos(iTime)), vec3(1.));\n    \n    Surface final = add(s1,s2);\n    \n    \n    return final;\n}\n\n\nSurface march(in Ray r, vec2 uv) {\n    float t = DIST_MIN;\n\n    for(int i=0;i<RAY_MARCH_STEPS,t<=DIST_MAX;++i) {\n        Surface s = scene(r.o+t*r.d, uv);\n\n        if(s.t<RAY_MARCH_PRECI) {\n            return Surface(t+s.t,s.c);\n        }\n\n        t = t+s.t;\n    }\n\n    return Surface(DIST_MAX,vec3(1.0+0.1*cos(1.*iTime*uv.x),1.0+0.1*cos(1.*iTime*uv.y),1.));\n}\n\nvec3 normalAt(in Surface s,in Ray r, in vec2 uv) {\n    const float e = 0.01;\n    vec3 p = r.o+s.t*r.d;\n    float nx = scene(vec3(p.x+e,p.y,p.z),uv).t-scene(vec3(p.x-e,p.y,p.z),uv).t;\n    float ny = scene(vec3(p.x,p.y+e,p.z), uv).t-scene(vec3(p.x,p.y-e,p.z),uv).t;\n    float nz = scene(vec3(p.x,p.y,p.z+e), uv).t-scene(vec3(p.x,p.y,p.z-e),uv).t;\n\n    return normalize(vec3(nx,ny,nz));\n}\n\n// Fonction pour initialiser la caméra\nRay camRay(in vec2 p) {\n    // Position normalisée de la souris\n    vec2 m = iMouse.xy/R.y;\n    \n    // Position de la camera\n    float DP = 20.;\n    float d = DP/2.;\n    vec3 ro = vec3(d*cos(6.0*m.x),DP/2.0,d*sin(6.0*m.x) );\n\n    // Point visé par la camera\n    vec3 ta = vec3(0.0,0.0,0.0);\n\n    // Vecteur de la camera\n    vec3 cw = normalize(ta-ro);\n\n    // Vecteur up de la camera\n    vec3 cp = vec3(0.0,1.0,0.0);\n\n    // Vecteur droit de la camera\n    vec3 cu = normalize(cross(cw,cp));\n\n    // Vecteur normalisé up de la camera\n    vec3 cv = normalize(cross(cu,cw));\n    \n    float fovDeg = 45.;\n    float fovRad = (fovDeg/360.)*2.*PI;\n    float zf = 1./tan(fovRad/2.);\n    \n    // Vecteur vue avec la perspective\n    vec3 rd = normalize(p.x*cu + p.y*cv*(R.y/R.x) + 2.*cw);\n\n    return Ray(ro,rd);\n}\n\nvec3 shade(in Surface surf, in Ray ray, vec2 uv) {\n    // tous les vecteurs nécessaires au shading\n    vec3 n = normalAt(surf,ray, uv);\n    vec3 l = normalize(vec3(1.,1.,0.));\n    vec3 v = ray.d;\n    vec3 r = reflect(l,n);\n    \n    // parametres du materiau\n    vec3 kd = surf.c;\n    vec3 ks = vec3(0.8);\n    float s = 20.;\n    \n    // coeficients diffus et spéculaires\n    float diff = max(dot(n,l)*0.5+0.5,0.);\n    float spec = pow(max(dot(r,v),0.),s);\n    return kd*diff + ks*spec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / R.xy)*2.-1.;\n    \n    Ray r = camRay(uv);\n    Surface s = march(r, uv);\n    vec3 c = s.c;\n    \n    if(s.t<DIST_MAX) {\n        c = shade(s,r, uv);\n    }\n    \n    fragColor = vec4(c,1.0);\n} ","name":"Image","description":"","type":"image"}]}