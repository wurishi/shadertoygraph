{"ver":"0.1","info":{"id":"3sSGzK","date":"1552755513","viewed":421,"name":"Occlusion and f(x,y)=z","username":"Minus256","description":"oh noez! wtf is happening to my shader!\nMade this to understand basics of f(x,y)=z function and ambient occlusion.\nthis seriously f'ed up...","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["occlusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Minus256\n//2019-03-17\n\nfloat maxitr = 500.0;//max marching\nint occitr = 10;//occlusion\nfloat sdwitr = 50.0;//shadow\n//random\nfloat random(vec2 f)\n{\n    return fract(sin(dot(f.xy,vec2(2.38843992,4.40872883))));\n}\n//ground mapping using random\nfloat m(vec2 xy)\n{\n    if(mod(xy.x,2.0) < 0.3 || mod(xy.y,4.0) < 0.6)//road\n        return 2.4;\n    else\n        return 0.95*(random(floor(xy*2.54))*0.5+random(floor(xy*9.1))*0.3)+2.0;//city\n        //return 0.95*(random(floor(xy*2.54))*0.5+random(floor(xy*5.7))*0.5+random(floor(xy*9.1))*0.3)+2.0;//city\n}\n//safe march optimization\nvoid premarch(inout vec3 pos,in vec3 ray,inout float leng,float safe)\n{\n    float safemarch = (pos.y-safe)/abs(ray.y);\n    leng += safemarch;\n    pos += ray*safemarch;\n}\n//reusable marcher\n//another method can be implemented\nvoid march(inout int chk,inout float chkud,inout vec3 pos,inout float eps,in vec3 ray,inout float leng)\n{\n    while(chk == 0)\n  \t{\n    ++chkud;\n    pos += ray*eps;\n    if(pos.y-m(pos.xz)<eps)\n\t\tchk = 1;\n    if(chkud>maxitr)\n        chk = 2;\n    leng += eps;\n    eps *= 1.0+chkud/150000.0; //varies marching step length\n    }\n}\n//exp occlusion function\nfloat occlusion(vec3 dir,vec3 pos,in float eps)\n{\n    float occ = .0;\n    eps *= 3.0;\n    pos += dir*eps;\n    for(int i=0;i<occitr;i++)\n    {\n    \tif(pos.y-m(pos.xz)<eps)\n        {\n        \tocc -= eps;\n            break;\n        }\n    \telse\n        \tocc += eps;\n    \tpos += dir*eps;\n    }\n    //return smoothstep(.0,1.0,1.0-min(max(pow(occ+1.5,1.5)-1.0,0.0),1.0));\n    return occ;\n}\nfloat shadow(vec3 dir,vec3 pos,in float eps,float lightleng)\n{\n    float shadow = .0;\n    eps *= 0.3;\n    for(float i=.0;i<sdwitr;i++)\n    {\n    \tpos += dir*eps;\n        eps *= 1.0+i/400.0;\n    \tif(pos.y-m(pos.xz)<eps)\n    \t{\n        \tpos -= dir*eps;\n        \tshadow = m(pos.xz);\n            break;\n        }\n    }\n    return shadow/lightleng;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xx;//not used xy because otherwise it will distort itself\n    //setting up camera\n    vec3 cen = vec3(.0,3.0,.0);\n    vec3 vp = vec3(-7.0*sin(iTime*0.1),4.0,-7.0); //camera's position\n    vec3 vdir = normalize(cen-vp);  //camera's direction\n    vec3 side = cross(vdir,vec3(.0,1.0,.0)); //side of camera(right)\n    vec3 upsd = cross(side,vdir);  //camera's upside\n    //view pixel of each ray\n    vec3 ray = normalize(vdir*(1.0+sin(iTime)*0.3)+side*uv.x+upsd*uv.y-side/2.0-upsd/2.0);\n    //ground march\n    float eps = 0.005;\n    float leng =.0;\n    vec3 pos = vp;\n    int chk = 0;\n    float chkud = 0.0;\n    float safe = 3.235;\n    premarch(pos,ray,leng,safe);\n    march(chk,chkud,pos,eps,ray,leng);\n    //get normal\n    vec2 dirs = vec2(eps,.0);\n    vec3 normal = normalize(vec3(m(pos.xz-dirs.xy)-m(pos.xz+dirs.xy),2.0*dirs.x,m(pos.xz-dirs.yx)-m(pos.xz+dirs.yx)));\n    if(chk == 2)//temporal!!\n        normal = vec3(.0,1.0,.0);\n    //and direction\n    vec3 lightpos = vec3(2.0*sin(iTime),5.0,4.0);//lightpos\n    vec3 lightdir = normalize(pos-lightpos);\n    float lightleng = length(pos-lightpos);\n    //reflection\n    vec3 shiny = reflect(vdir,normal);\n    float dif = dot(lightdir,normal);\n    //occlusion setup\n    float ambocc = occlusion(normal,pos,eps);\n    float spcocc = occlusion(shiny,pos,eps);\n    float dffocc = occlusion(lightdir,pos,eps);//light is neg signed because direction is pos to light ins of lit to pos\n    //shadow\n    float shadow = shadow(-lightdir,pos,eps,lightleng);\n    //fragColor = vec4(vec3(pos.y/10.0+leng/50.0+normal*0.5+spec),1.0);\n    //fragColor = vec4(vec3(1.0-ambocc-spcocc-dffocc-shadow),1.0);\n    //fragColor = vec4(vec3(shadow),1.0);\n    //fragColor = vec4(vec3(1.0-spcocc),1.0);\n    fragColor = vec4(vec3(1.0-(shadow*2.0-ambocc*1.0-dffocc*0.3+spcocc*0.4)),1.0);\n}","name":"Image","description":"","type":"image"}]}