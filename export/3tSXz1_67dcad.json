{"ver":"0.1","info":{"id":"3tSXz1","date":"1564967757","viewed":129,"name":"Really basic raytracer test","username":"legobrainiac","description":"Small raytracer test done when i really should be sleeping.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["ray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SPHERE_COUNT 5\n#define FOV 90.f\n#define ASPECT_RATIO 16.f / 9.f\n\nSphere spheres[SPHERE_COUNT];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Starting colour is cornflower blue\n    vec3 colour \t\t= vec3(0.392f, 0.584f, 0.929f);\n    \n    // Setup spheres\n    spheres[0].position = vec3(cos(iTime) * 4.f, 0.f, tan(iTime));\n    spheres[0].colour \t= vec3(0.4f, 1.f, 0.4f);\n    spheres[0].rad \t\t= 2.f;\n    spheres[0].ref\t\t= .9f;\n    \n    spheres[1].position = vec3(0.f, sin(iTime) * 5.f, 5.f);\n    spheres[1].colour \t= vec3(1.f, 1.f, 0.0f);\n    spheres[1].rad \t\t= 1.f;\n    spheres[1].ref\t\t= 1.f;\n    \n    spheres[2].position = vec3(tan(iTime / 4.f), tan(iTime / 4.f + 7.f), 5.f);\n    spheres[2].colour \t= vec3(1.f, 1.f, 1.f);\n    spheres[2].rad \t\t= 3.f;\n    spheres[2].ref\t\t= 0.5f;\n    \n    spheres[3].position = vec3(4.f + sin(iTime * 8.f), 2.f + cos(iTime * 8.f), 5.f);\n    spheres[3].colour \t= vec3(1.f, 0.f, 1.f);\n    spheres[3].rad \t\t= 1.f;\n    spheres[3].ref\t\t= 0.7f;\n    \n    spheres[4].position = vec3(-4.f + cos(iTime * 8.f), -2.f + sin(iTime * 8.f), 5.f);\n    spheres[4].colour \t= vec3(1.f, 1.f, 0.f);\n    spheres[4].rad \t\t= 1.f;\n    spheres[4].ref\t\t= 0.5f;\n    \n    // Setup some other variables\n    float invWidth = 1.f / float(iResolution.x);\n    float invHeight = 1.f / float(iResolution.y);\n    float angle = tan(PI * .5f * FOV / 180.f);\n\t\n    float xx = (2.f * ((fragCoord.x + 0.5f) * invWidth) - 1.f) * angle * ASPECT_RATIO;\n\tfloat yy = (1.f - 2.f * ((fragCoord.y + 0.5f) * invHeight)) * angle;\n    \n    vec3 direction = vec3(xx + cos(iTime), yy, 1.f);\n    direction = normalize(direction);\n    \n    // Run through all the spheres and test for intersection, none recursive raytracing\n    for(int i = 0; i < SPHERE_COUNT; ++i)\n    {\n    \tHitOut hit = Intersect(spheres[i], vec3(0.f), direction);\n    \n        if(hit.isHit)\n        {\n            vec3 hitPos = direction * hit.t0;\n            vec3 hitNormal = hitPos - spheres[i].position;\n            hitNormal = normalize(hitNormal);\n            \n            if(spheres[i].ref > 0.f)\n            {\n                for(int j = 0; j < SPHERE_COUNT; ++j)\n    \t\t\t{\n                \tvec3 reflection = reflect(direction, hitNormal);\n                \tHitOut hit2 = Intersect(spheres[j], hitPos, reflection);\n                    \n                    if(hit2.isHit)\n                    {\n                        // If a reflection if found, calculate pixel colour for that\n                        float lightIntensity = dot(hitNormal, vec3(0.f, 0.f, -1.f));\n                        \n                        colour = saturate(\n                            mix(\n                                spheres[j].colour * lightIntensity * vec3(0.392f, 0.584f, 0.929f),\n                                texture(iChannel0, -hit2.uv).xyz,\n                                spheres[i].ref\n                            )\n                        );\n                        break;\n                    }\n                    else\n                    {\n                        // If a reflection isn't found, use colour of the sky\n                        float lightIntensity = dot(hitNormal, vec3(0.f, 0.f, -1.f));\n                        \n                        colour = saturate(\n                            mix(\n                                spheres[i].colour * lightIntensity, \n                                texture(iChannel0,- hit.uv).xyz,\n                                spheres[i].ref\n                            )\n                        );\n                    }\n                }\n            }\n            else\n            {\n                // If sphere is not reflective, do normal colour stuff\n                float lightIntensity = dot(hitNormal, vec3(0.f, 0.f, -1.f));\n                \n            \tcolour = saturate(\n                    mix(\n                        spheres[i].colour * lightIntensity, \n\t\t\t\t\t\ttexture(iChannel0,- hit.uv).xyz,\n                        0.4f\n                    )\n                );\n            }\n        }\n    }\n    \n    // Final colour\n    fragColor = vec4(colour, 1.f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359f\n\nstruct Sphere\n{\n    vec3 position;\n    vec3 colour;\n    float rad;\n    float ref;\n};\n\nstruct HitOut\n{\n    float t0;\n    float t1;\n    vec2 uv;\n    bool isHit;\n};\n\nvec2 GetUv(Sphere sphere, vec3 hitPos)\n{\n    vec3 n = normalize(hitPos - sphere.position);\n\tfloat u = atan(n.x / n.z) / (2.f * PI) + 0.5f;\n\tfloat v = n.y * 0.5f + 0.5f;\n    \n    return vec2(u, v);\n}\n\nvec3 saturate(vec3 i)\n{\n    return clamp(i, 0.f, 1.f);\n}\n    \nHitOut Intersect(Sphere sphere, vec3 origin, vec3 direction)\n{\n    HitOut hit;\n    \n    vec3 l = sphere.position - origin;\n\n    float tca = dot(l, direction);\n    if (tca < float(0.f))\n    {\n        hit.isHit = false;\n        return hit;\n    }\n\n    float d2 = dot(l, l) - tca * tca;\n    if (d2 > sphere.rad)\n    {\n        hit.isHit = false;\n        return hit;\n    }\n\n    float thc = sqrt(sphere.rad - d2);\n    hit.t0 = tca - thc;\n    hit.t1 = tca + thc;\n    hit.uv = GetUv(sphere, direction * hit.t0);\n    hit.isHit = true;\n\n    return hit;\n}","name":"Common","description":"","type":"common"}]}