{"ver":"0.1","info":{"id":"cslGWs","date":"1667003610","viewed":69,"name":"JzAzBz blending","username":"quagnz","description":"Blending colors using the perceptually linear JzAzBz colorspace.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["colorspace","jzazbz"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A perceptually linear color space, so you can mix two jazbz values and they will blend light as percieved.\n// j = 0..1 brightness\n// az = -1..1 \"red\"/\"green\" value\n// bz = -1..1 \"blue\"/\"yellow\" value\nvec3 jazbzToSrgb255(vec3 jab) {\n    float j = jab.x;\n    float desat = sqrt(4.0 * j * (1.0 - j));\n    \n    float jz = j * 0.16717463120366200 + 1.6295499532821566e-11;\n    float az = jab.y * desat;\n    float bz = jab.z * desat;\n\n    float iz0 = jz + 1.6295499532821566e-11;\n    float iz1 = jz * 0.56 + 0.4400000000091254797;\n    float iz = iz0 / iz1;\n\n    float l0 = iz + az * 0.02208614618138942 + bz * 0.00924960217753215;\n    float m0 = iz + az * -0.02208614618138941 + bz * -0.00924960217753216;\n    float s0 = iz + az * -0.01530027310380666 + bz * -0.12937164966392752;\n\n    float l1 = pow(max(l0, 0.0), 0.007460772656268214777);\n    float m1 = pow(max(m0, 0.0), 0.007460772656268214777);\n    float s1 = pow(max(s0, 0.0), 0.007460772656268214777);\n\n    float l2 = 0.8359375 - l1; \n    float m2 = 0.8359375 - m1; \n    float s2 = 0.8359375 - s1; \n\n    float l3 = l1 * 18.6875000 - 18.8515625;\n    float m3 = m1 * 18.6875000 - 18.8515625;\n    float s3 = s1 * 18.6875000 - 18.8515625;\n\n    float l4 = l2 / l3; \n    float m4 = m2 / m3; \n    float s4 = s2 / s3; \n\n    float l5 = pow(max(l4, 0.0), 6.277394636015325670);\n    float m5 = pow(max(m4, 0.0), 6.277394636015325670);\n    float s5 = pow(max(s4, 0.0), 6.277394636015325670);\n\n    float sr0 = l5 * 592.8963755404249891 + m5 * -522.3947425797513470 + s5 * 32.59644233339026778;\n    float sg0 = l5 * -222.3295790445721752 + m5 * 382.1527473694614592 + s5 * -57.03433147128811548;\n    float sb0 = l5 * 6.270913830078805615 + m5 * -70.21906556220011906 + s5 * 166.6975603243740906;\n\n    float sr1 = sr0 * 12.92;\n    float sg1 = sg0 * 12.92;\n    float sb1 = sb0 * 12.92;\n\n    float sr2 = pow(max(sr0, 0.0), 0.4166666666666666666);\n    float sg2 = pow(max(sg0, 0.0), 0.4166666666666666666);\n    float sb2 = pow(max(sb0, 0.0), 0.4166666666666666666);\n\n    float sr3 = sr2 * 1.055 + -0.055;\n    float sg3 = sg2 * 1.055 + -0.055;\n    float sb3 = sb2 * 1.055 + -0.055;\n\n    float sr = sr0 <= 0.003130804953560371341 ? sr1 : sr3;\n    float sg = sg0 <= 0.003130804953560371341 ? sg1 : sg3;\n    float sb = sb0 <= 0.003130804953560371341 ? sb1 : sb3;\n\n    return vec3(sr, sg, sb);\n}\n\n// Convert chroma + hue to the az,bz values that can be linealry interpolated.\nvec2 chToAzbz(float chroma, float hue) {\n     float hz = hue*6.28318530717958647 + -3.14159265358979323;\n     return chroma * vec2(cos(hz), sin(hz));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 hue = chToAzbz(cos(iTime * 1.618) * 0.25 + 0.25 * uv.x, 0.5 + 0.5 * cos(iTime + uv.x));\n    vec3 jab = vec3(uv.y, hue.xy);\n    if (length(uv - vec2(0.5, 0.5)) < 0.3) {\n        vec3 royalBlue = vec3(0.268, -0.121, -0.749);\n        vec3 goldenYellow = vec3(0.817, 0.05, 0.66);\n        vec3 dot = mix(royalBlue, goldenYellow, uv.x);\n        float alpha = cos(iTime * 1.272) * 0.5 + 0.5;\n        jab = mix(jab, dot, alpha);\n    }\n    \n    vec3 srgb = jazbzToSrgb255(jab);\n    fragColor = vec4(srgb,1.0);\n}","name":"Image","description":"","type":"image"}]}