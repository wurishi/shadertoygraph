{"ver":"0.1","info":{"id":"DddGDM","date":"1677363117","viewed":130,"name":"specular swamp","username":"Masqualero","description":"i was gonna make something like this using \" mode 7 \" 3d graphics, but i gave up, and did it using ray-marching","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","specular","abstract1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 200.\n#define SURF_DIST .01\n\nfloat getDist(vec3 p){\n    float d = p.y-1.4 ;\n    \n    //height map is approximated by blurring the image(kinda) its not good\n    float hmap = texture(iChannel0, p.xz * 0.05 + vec2(0.005, 0)).x \n               + texture(iChannel0, p.xz * 0.05 - vec2(0.005, 0)).x\n               + texture(iChannel0, p.xz * 0.05).x;\n    \n    return d - 0.3 * hmap - 2.0 * texture(iChannel2, p.xz / 70.0).x;\n\n}\n\nvec2 rotate(vec2 p,float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd){\n    float dO = 0.0;\n    \n    for (int i=0 ; i<MAX_STEPS; i++){\n        \n        vec3 p  = ro +  rd * dO ;\n        float dS = getDist(p);\n        dO += dS ;\n        \n        if(dO > MAX_DIST || dS <SURF_DIST) break;\n        \n    }\n    \n    return dO ;\n}\n\nvec3 getNormal(vec3 p){\n\n    float d = getDist(p) ;\n    vec2 e = vec2(0.1, 0);\n    \n    vec3 n = d-vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx)) ;\n    \n    return normalize(n);\n}\n\nfloat getLight(vec3 p, vec3 pz){\n    vec3 l = normalize(pz - p) ;\n    vec3 n = getNormal(p);\n    \n    float dif = clamp( dot(n, l), 0.0, 1.0 ) ;\n    \n    float d = rayMarch(p + n, l);\n    \n    if (d<(length(pz- p))) dif*=0.4 ;\n    \n    dif = (1.0 - 0.3) * dif + 0.3 ;\n    \n    return dif;\n\n}\n\nfloat get_spec(vec3 p, vec3 pz, vec3 rd){\n    vec3 vl = normalize(pz - p);\n    vec3 r = reflect( vl, getNormal(p) );\n    return pow( clamp(dot(r, rd), 0.0, 1.0), 5.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y ; \n    \n    //distort camera by a parabolic curve\n    uv.y -= (1.0 - uv.x * uv.x) * 0.1;\n    \n    //determine ray origin and distance\n    vec3 ro = vec3(0, 8, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0)) ;\n    \n    //---------\n    \n    //distort position and rotation\n    rd.xz = rotate(rd.xz, iTime) ;\n    rd.yz = rotate(rd.yz, 0.4) ;\n    ro.zx += vec2(iTime) * vec2(20, 10);\n    \n    //the distance and point on the scene\n    float d = rayMarch(ro, rd) ;\n    vec3 p = ro + rd * d ;\n\n    \n    //calculate diffuse and specular lighting\n    vec3 lightPos = vec3(3, 10, 3);\n    float dif = getLight(p, lightPos);\n    float spec = get_spec(p, lightPos + ro, rd);\n    \n    \n    //color is initialized as the texture color\n    vec3 col = texture(iChannel0, p.xz * 0.05).xyz;\n    \n    //darken by the diffuse lighting\n    col *= dif ;\n    \n    //brighten by the specular lighting\n    col += spec ;\n    \n    //if the distance is too big, default to sky\n    if (d>=MAX_DIST) col=texture(iChannel1, rd).xyz ;\n    \n    //make color a foggy color based on the distance to the horizion\n    col = mix( vec3(0.3, 0.4, 0.5), col, 2.0 * abs(rd.y));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}