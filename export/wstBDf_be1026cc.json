{"ver":"0.1","info":{"id":"wstBDf","date":"1606188552","viewed":50,"name":"My Rainbow Flag","username":"zhengzhehui","description":"rainbow flag","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["zhehuizheng"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float paint(vec2 st, float y, float width)\n{\n    return step(y, st.y)-step(y+width, st.y);\n    //1.如果st落在函数y=f(x)上方，则返回1，否则返回0\n    //2.如果st落在函数y=f(x)+width下方，则返回1，否则返回0\n    //3.1和2相减，使得只有落在y=f(x)到y=f(x)+width之间的点才能返回0~1之间的值\n}    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float t = iTime;\n    \n    float z = sin(uv.x-t)/10.0-0.1;  //随时间移动的sin函数，控制颜色的上下摆动\n    \n    vec3 color;\n    \n\tcolor += paint(uv,z,0.2)*vec3(0.8,0.,0.);\n    color += paint(uv,z+0.2,0.2)*vec3(0.8,0.3,0.2);\n    color += paint(uv,z+0.4,0.2)*vec3(0.8,0.8,0.1);\n    color += paint(uv,z+0.6,0.2)*vec3(0.5,0.95,0.);\n    color += paint(uv,z+0.8,0.2)*vec3(0.1,0.5,0.95);\n    color += paint(uv,z+1.,0.2)*vec3(0.5,0.1,0.95);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}