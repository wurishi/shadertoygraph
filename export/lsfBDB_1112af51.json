{"ver":"0.1","info":{"id":"lsfBDB","date":"1497861849","viewed":570,"name":"Forest Sunset","username":"AlexM","description":"Trying out some of this terrain raymarching stuff. Fake forest looks a bit noisy.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589793 \n\nconst float WORLEYMAXDIST = 8.0; // worley noise max distance\nconst float MAXLENGTH = 190.0; // maximum ray length\nconst vec3  SUNDIRECTION = normalize(vec3(1.0, -0.3, -0.4)); //direction of the sunlight\nconst vec3  SUNCOLOR = normalize(vec3(0.960, 0.619, 0.180)); // sun color? \nconst float FOGHEIGHT = 0.01; // background fog height. \nconst float FOGFADEHEIGHT = 0.2; // background fog fade height - fades background fog into actual sky.\nconst vec3  FOGCOLOR = vec3(0.996, 0.878, 0.603);\n\nfloat random(in vec2 st) { \n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nmat3 rotateY(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( a, 0.0, b, 0.0, 1.0, 0.0, -b, 0.0, a );\n}\n\nmat3 rotateX(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( 1.0, 0.0, 0.0, 0.0, a, -b, 0.0, b, a );\n}\n\nfloat noise2D(vec2 uv) {\n    vec2 st = 0.1 * uv; \n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    \n    \n    vec2 u = f*f*(3.0-2.0*f);\n    float a1 = mix(a, b, u.x);\n    float a2 = mix(c, d, u.x);\n    float a3 = mix(a1, a2, u.y);\n    return clamp(a3, 0.0, 1.0); \n}\n\nfloat worley(vec2 uv) {\n\tvec2 tileCoord = floor(uv);    \n    \n    float dist = 9999999.0;\n    for (int y = -1; y <= 1; y++)\n    for (int x = -1; x <= 1; x++) {\n        vec2 currentTile = tileCoord + vec2(x, y);\n        vec2 point = currentTile + random(currentTile);\n        // not entirely correct but makes fakes trees look better... imho\n        dist = min(dist, sqrt(length(point-uv))); \n    }\n    dist = clamp(dist, 0.0, WORLEYMAXDIST) / WORLEYMAXDIST;\n    return dist;\n}\n\nfloat fbm(vec2 st) {\n    float value = 0.0;\n    float amplitud = 0.5;\n    float frequency = 0.2;\n\n    const int octaves = 3;\n    for (int i = 0; i < octaves; i++) {\n        value += amplitud * noise2D(st * frequency);\n        st *= 2.;\n        amplitud *= .5;\n        frequency *= 1.20;;\n    }\n    return value;\n}\n\nfloat trees(vec2 st) {\n    float a = fbm(st.xy * 1.9) + 1.0;\n    float x = 2.0 * worley(st * 7.5) - 1.0;\n    return a+(min(-x, 0.91)  * 2.5 * fbm(st * 20.0)); \n}\n\nfloat terrain(vec2 st) {\n    float a = fbm(st.xy * 1.9) + 1.0;\n    a = abs(1.0-a)  * 19.0 - 4.0;\n    float b = fbm(st.yx * 41.3);\n    return a - b*(a*0.20); \n}\n\nfloat map(vec2 st, out int mattype) {\n    float terrainh = terrain(st) + 2.0; \n    float treesh = trees(st * 1.1) * 1.4 + 0.35; \n    float h = max(treesh, terrainh);\n    if (h == terrainh)  mattype = 1; \n    if (h == treesh)    mattype = 2; \n    return h;\n}\n\nvec2 trace(vec3 ro, vec3 rd, out int mattype) {\n\n    float height = -1.0;\n    float t = 0.02;\n    float tmax = MAXLENGTH;\n   \n\n    for (;t < tmax;) {\n        int m = 0;\n        vec3 rp = ro + rd * t;\n        float h = map(rp.xz, m);\n        float d = rp.y - h;\n\n        if (d < 0.01) {\n            height = h;\n            mattype = m;\n            break;\n        }\n        t += 0.5 * d;\n    }\n\n    return vec2(height, t);\n}\n\nvec3 getNormal(vec3 rp) {\n    int unused = 0;\n    vec2 eps = vec2(0.01, 0.0);\n    vec3 normal = normalize(vec3( \n        map(rp.xz - eps.xy, unused) - map(rp.xz + eps.xy, unused),\n        2.0 * eps.x, \n        map(rp.xz - eps.yx, unused) - map(rp.xz + eps.yx, unused) \n    ));\n    return normal;\n}\n\n\nvec3 getShading(vec3 p, vec3 ld, vec3 n) {\n    int unused;\n    // lambert\n    float kd = max(0.0, dot(-ld, n));\n    // cast shadow ray...\n\n    vec3 a = p + vec3(0.0, 0.1, 0.0);\n    vec2 s = trace(a, -SUNDIRECTION, unused);\n    float sh = (s.x == -1.0) ? 1.0 : 0.0;\n\n    return (kd * SUNCOLOR * sh) ;\n}\n\n// that is really shitty AO but at least unlit fragments do not look so plain... :)\nfloat bad_ao(vec3 n) {\n    return abs(dot(n, vec3(0.0, 1.0, 0.0))); \n}\n\nfloat fog(float dist) {\n    const float density = 0.008;\n    return  1.0 - 1.0/exp(pow(dist * density, 2.0));\n}\n\n// shamelessly stol... borrowed this from a certain thread on pouet\nvec3 postprocess(vec3 color) {\n    const float contrast   = 0.15;\n    const float brightness = 2.4;\n    const float gamma = 1.5;  // higher => darker; lower => brighter\n    const float saturation = 1.4;\n\n    color = color * brightness;\n    color = pow(color, vec3(gamma));\n    color = color * 0.5 + contrast * 0.5;\n\n    float luminance = dot(vec3(0.2126, 0.7152, 0.0722), color);\n    color = luminance + (color - luminance) * saturation;\n\n    return clamp(color, 0.0, 1.0);\n}\n\nvec3 sky(vec3 ro, vec3 rd, vec2 st) {\n    vec3 color = vec3(0.8, 0.5, 0.4);\n    color += smoothstep(0.3, 0.6, fbm(rd.xz * 90.0 / rd.y));\n\n    float d = dot(-SUNDIRECTION, rd); // sun??\n    if (d > 0.0)          \n        color = mix(color, vec3(1.0, 1.0, 0.8), pow(d, 20.0));\n    if (rd.y < FOGFADEHEIGHT)     \n        color = mix(FOGCOLOR, color, (rd.y-FOGHEIGHT)/(FOGFADEHEIGHT-FOGHEIGHT));\n    if (rd.y < FOGHEIGHT) \n        color = FOGCOLOR;\n    return clamp(color, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 st = fragCoord.xy / iResolution.xy;\n    float finv = tan(90.0 * 0.5 * PI / 180.0);\n    float aspect = iResolution.x / iResolution.y;\n    st.x = st.x * aspect;\n    st = (st - vec2(aspect * 0.5, 0.5)) * finv;\n\n    vec3 rd = normalize(vec3(st, 1.0));\n    rd = rotateY(-iMouse.x*0.002+0.785398) * rotateX(iMouse.y*0.002-0.19) * rd;\n    rd = normalize(rd);\n \n    vec3 ro = vec3(0.0, 14.5, 0.0); \n  \n    ro += iTime  * normalize(vec3(-1.0, 0.0, 1.0));\n\n    int mattype = 0;\n    vec2 height = trace(ro, rd, mattype);\n\n    vec3 rp = ro + height.y * rd;\n    vec3 n = getNormal(rp);\n    vec3 kd = getShading(rp, SUNDIRECTION, n);\n\n    // texture slope fade constants\n    // anything below smin slope uses grass texture, anything above uses rock texture,\n    // values between are lerped.\n    float smin = 0.05;  \n    float smax = 0.15;\n\n    // terrain detail texture\n    float vmin = 0.4;\n    float vmax = 1.0;\n\n    vec3 color1 = vec3(1.0, 0.0, 0.0);\n    vec3 color2 = vec3(1.0, 0.0, 0.0);\n    if (mattype == 1) {\n        color1 = vec3(0.925, 0.964, 0.572); //  grass color;\n        color2 = vec3(0.474, 0.368, 0.207); // rock \n    }\n    if (mattype == 2) {\n        color1 = vec3(0.611, 0.686, 0.113); //  tree base;\n        color2 = vec3(0.760, 0.913, 0.427); //   tree top;\n        color1 = color1 + vec3(noise2D(rp.xz * 9.0),  noise2D(rp.zx * 2.0), noise2D(rp.zx)) * 0.20;\n        color2 = color2 + vec3(noise2D(rp.xz * 5.0),  noise2D(rp.zx * 9.0), noise2D(rp.zx)) * 0.20;\n        smin = 0.09;\n        smax = 0.24;\n        vmin = 0.5;\n        vmax = 1.0;\n    }\n\n    float slopefactor =  1.0 - abs(dot(n, vec3(0.0, 1.0, 0.0)));\n    float slopefactor2 = clamp(slopefactor, smin, smax);\n    slopefactor2 = (slopefactor2-smin) / (smax - smin);\n    \n    vec3 color = mix(color1, color2, slopefactor2);\n    float variation = (noise2D(rp.xz *225.0) + noise2D(rp.zx * 225.0)) * 0.5 ;\n    variation = clamp(variation, vmin, vmax);\n    color *= variation;\n    float ao = bad_ao(n);\n    color = color * 0.3 * ao + color * kd;\n\n    const vec3 fogcolor = vec3(0.996, 0.878, 0.603);\n    color = mix(color, fogcolor, fog(height.y));\n\n    if (height.x == -1.0) { color = sky(ro, rd, st); }\n    color = postprocess(color);\n    fragColor = vec4(color, 1.0); \n}","name":"Image","description":"","type":"image"}]}