{"ver":"0.1","info":{"id":"wdsSWH","date":"1551211067","viewed":280,"name":"Horribly Inefficient Tetris","username":"LexaPrime","description":"Move right: right arrow / D\nMove left: left arrow / A\nRotate right: arrow up / E\nRotate left: Q\nHard drop: arrow down / S\nSoft drop: W\nSpeed up: numpad +\nSpeed down: numpad -\nToggle ghost: G","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["game","tetris"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//=================================================\n//\n\n\nconst vec3 BG_COLOR1 = vec3(0.0);\nconst vec3 BG_COLOR2 = vec3(0.8, 0.8, 0.8);\n\nconst int BLOCK_CURRENT = -2;\nconst int BLOCK_GHOST = -1;\nconst int BLOCK_NONE = 0;\nconst int BLOCK_I = 1;\nconst int BLOCK_O = 2;\nconst int BLOCK_T = 3;\nconst int BLOCK_S = 4;\nconst int BLOCK_Z = 5;\nconst int BLOCK_J = 6;\nconst int BLOCK_L = 7;\nconst int BLOCK_BORDER = 8;\n\n\nconst vec3[9] BLOCK_COLOR = vec3[](\n    \t\t\t\t\t\t\t\tvec3(0.0, 0.0, 0.0),\n    \t\t\t\t\t\t\t\tvec3(0.4, 0.8, 1.0),\n\t\t\t\t\t\t\t\t\tvec3(0.7, 0.7, 0.2),\n\t\t\t\t\t\t\t\t\tvec3(0.9, 0.5, 1.0),\n\t\t\t\t\t\t\t\t\tvec3(0.3, 0.8, 0.3),\n\t\t\t\t\t\t\t\t\tvec3(1.0, 0.2, 0.2),\n\t\t\t\t\t\t\t\t\tvec3(0.0, 0.0, 1.0),\n\t\t\t\t\t\t\t\t\tvec3(0.9, 0.6, 0.3),\n\t\t\t\t\t\t\t\t\tvec3(0.8, 0.8, 0.8) );\n\n\nvec4 loadValue(ivec2 tx)\n{\n    return texelFetch( iChannel0, tx, 0 );\n}\n\n\nstruct GameState\n{    \n    /*\n    int points;\n    int level;\n    int linesCleared;\n    bool gameOver;\n    \n    float prevUpdateTime;\n    */\n    int currentBlockType;\n    ivec2 currentBlockPos;\n    int currentBlockRot;\n    /*\n    int numLinesToCheck;\n    int firstLineToCheck;\n    \n    int bags[14];\n    int bagIter;\n    int randSeed;\n    \n    float timeStep;\n\t*/\n    bool ghostVisible;\n};\n    \n\nvoid loadGameState(out GameState state)\n{    \n    /*\n    state.points = int( loadValue(ivec2(10, 1)).x );\n    state.level = int( loadValue(ivec2(10, 1)).y );\n    state.linesCleared = int( loadValue(ivec2(10, 1)).z );\n    state.gameOver = loadValue(ivec2(10, 1)).w > 0.5;\n    \n    state.prevUpdateTime = loadValue(ivec2(10, 2)).x;\n    */\n    state.currentBlockType = int( loadValue(ivec2(10, 3)).x );\n    state.currentBlockPos = ivec2( loadValue(ivec2(10, 3)).yz );\n    state.currentBlockRot = int( loadValue(ivec2(10, 3)).w );\n    /*\n    state.numLinesToCheck = int( loadValue(ivec2(10, 4)).x );\n    state.firstLineToCheck = int( loadValue(ivec2(10, 4)).y );\n\n    state.bags[0] = int( loadValue(ivec2(10, 6)).x );\n    state.bags[1] = int( loadValue(ivec2(10, 6)).y );\n    state.bags[2] = int( loadValue(ivec2(10, 6)).z );\n    state.bags[3] = int( loadValue(ivec2(10, 6)).w );\n    state.bags[4] = int( loadValue(ivec2(10, 7)).x );\n    state.bags[5] = int( loadValue(ivec2(10, 7)).y );\n    state.bags[6] = int( loadValue(ivec2(10, 7)).z );\n    state.bags[7] = int( loadValue(ivec2(10, 7)).w );\n    state.bags[8] = int( loadValue(ivec2(10, 8)).x );\n    state.bags[9] = int( loadValue(ivec2(10, 8)).y );\n    state.bags[10] = int( loadValue(ivec2(10, 8)).z );\n    state.bags[11] = int( loadValue(ivec2(10, 8)).w );\n    state.bags[12] = int( loadValue(ivec2(10, 9)).x );\n    state.bags[13] = int( loadValue(ivec2(10, 9)).y );\n    state.bagIter = int( loadValue(ivec2(10, 10)).x );\n    state.randSeed = int( loadValue(ivec2(10, 10)).y );\n    \n    state.timeStep = loadValue(ivec2(10, 5)).x;\n\t*/\n    state.ghostVisible = loadValue(ivec2(10, 5)).y > 0.5;\n}\n\n\n\nint getTile(ivec2 coords)\n{\n    if(coords.x < 0 || coords.y < 0 || coords.x > 9 || coords.y > 21)\n    {\n     \treturn BLOCK_BORDER;   \n    }\n    \n    return int( loadValue(coords).x );\n}\n\n\nbool inside(vec2 uv, vec4 rect)\n{\n \treturn uv.x >= rect.x && uv.y >= rect.y && uv.x < rect.z && uv.y < rect.w;   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    vec2 uv = fragCoord / iResolution.y;\n    float screenRatio = iResolution.x / iResolution.y;\n    uv.x -= screenRatio * 0.5 - 0.25;\n    uv *= 20.0;\n    \n\n    GameState state;\n    loadGameState(state);\n    \n    if( getTile(ivec2(floor(uv))) == BLOCK_CURRENT )\n    {\n        fragColor.xyz = BLOCK_COLOR[ state.currentBlockType ];\n        fragColor.xyz = mix(fragColor.xyz, vec3(1.0, 0.0, 0.0), clamp(0.0, 1.0, abs( mod(uv.x, 1.0) - 0.5 )*0.8-0.2));\n        fragColor.xyz = mix(fragColor.xyz, vec3(1.0, 0.0, 0.0), clamp(0.0, 1.0, abs( mod(uv.y, 1.0) - 0.5 )*0.8-0.2));\n    }\n    else if( getTile(ivec2(floor(uv))) == BLOCK_GHOST && state.ghostVisible )\n    {\n        fragColor.xyz = BLOCK_COLOR[ state.currentBlockType ] * 0.3;\n    }\n    else\n    //if(uv.x >= 0.0 && uv.y >= 0.0 && uv.x < 10.0 && uv.y < 20.0)\n    {\n   \t\tfragColor.xyz = BLOCK_COLOR[ getTile(ivec2(floor(uv))) ];\n        \n    }\n    \n    \n    if(uv.x < 0.0 || uv.x >= 10.0)\n    {\n     \tfragColor.xyz = texture( iChannel1, fragCoord / iResolution.xy).xyz;\n    }\n    \n    \n    if((fragColor.xyz != BG_COLOR1 && inside(uv, vec4(0.0, 0.0, 10.0, 20.0))) || (fragColor.xyz != BG_COLOR2 && inside(uv, vec4(13.0, 2.0, 17.0, 17.0))))\n    {\n    \tfragColor.xyz = mix(fragColor.xyz, vec3(1.0), clamp(0.0, 1.0, mod(uv.y, 1.0)*0.6-0.4));\n        fragColor.xyz = mix(fragColor.xyz, vec3(1.0), clamp(0.0, 1.0, mod(-uv.x, 1.0)*0.6-0.4));\n    }\n    \n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//=========================================================\n//\tBUFFER A - GAME LOGIC\n\n\n//=========================================================\n//\tBuffer layout:\n//\n//\t[0, 0] - [9, 23]\tPlayfield data:\n//\t\t\t\t\t\tx - block type\n//\n//\t[10, 0] - [13, 0]\tBlock queue:\n//\t\t\t\t\t\tx - block type\n//\n//\t[10, 1]\t\t\t\tx - points\n//\t\t\t\t\t\ty - level\n//\t\t\t\t\t\tz - lines cleared\n//\t\t\t\t\t\tw - is game over?\n//\n//\t[10, 2]\t\t\t\tx - previous update timestamp\n//\n//\t[10, 3]\t\t\t\tCurrent block\n//\t\t\t\t\t\tx - type\n//\t\t\t\t\t\ty, z - position\n//\t\t\t\t\t\tw - orientation\n//\n//\t[10, 4]\t\t\t\tLines to check for being full in Buffer B\n//\t\t\t\t\t\tx - num lines\n//\t\t\t\t\t\ty - top line\n//\n//\t[10, 5]\t\t\t\tx - block fall speed (time step)\n//\t\t\t\t\t\ty - is ghost visible?\n//\n//\t[10, 6] - [10, 9]\tPre-generated \"bags\"\n//\t\t\t\t\t\tone component is one block type\n//\n//\t[10, 10]\t\t\tx - bag iterator\n//\t\t\t\t\t\ty - rand seed\n//\n\n//---------------------------------------------------------\n//\n\n\n//=========================================================\n//\tConstants\n\n#define KB_LEFT 37\n#define KB_RIGHT 39\n#define KB_UP 38\n#define KB_DOWN 40\n#define KB_SPACE 32\n#define KB_NUMPAD_PLUS 107\n#define KB_NUMPAD_MINUS 109\n#define KB_W 87\n#define KB_A 65\n#define KB_S 83\n#define KB_D 68\n#define KB_Q 81\n#define KB_E 69\n#define KB_G 71\n\n\n//--------------------------------------------------------\n//\tBLOCK TYPES\n//\n//\tpos always refers to lower-left square\n//\n//\tI\n//\t\n//\t----\n//\t----\n//\t####\n//\t----\n//\n//\n//\tO\n//\n//\t##\n//\t##\n//\n//\n//\tT\n//\n//\t-#-\n//\t###\n//\t---\n//\n//\n//\tS\n//\n//\t-##\n//\t##-\n//\t---\n//\n//\n//\tZ\n//\n//\t##-\n//\t-##\n//\t---\n//\n//\n//\tJ\n//\n//\t#--\n//\t###\n//\t---\n//\n//\n//\tL\n//\n//\t--#\n//\t###\n//\t---\n//\n\nconst int BLOCK_CURRENT = -2;\nconst int BLOCK_GHOST = -1;\nconst int BLOCK_NONE = 0;\nconst int BLOCK_I = 1;\nconst int BLOCK_O = 2;\nconst int BLOCK_T = 3;\nconst int BLOCK_S = 4;\nconst int BLOCK_Z = 5;\nconst int BLOCK_J = 6;\nconst int BLOCK_L = 7;\nconst int BLOCK_BORDER = 8;\n\n\nconst ivec2 MAP[128] = ivec2[]( \t\n    \t\t\t\t\t\t\t\t// BLOCK_NONE\n    \t\t\t\t\t\t\t\tivec2(0, 0), ivec2(0, 0), ivec2(0, 0), ivec2(0, 0),\n\t\t\t\t\t\t\t\t\tivec2(0, 0), ivec2(0, 0), ivec2(0, 0), ivec2(0, 0),\n    \t\t\t\t\t\t\t\tivec2(0, 0), ivec2(0, 0), ivec2(0, 0), ivec2(0, 0),\n    \t\t\t\t\t\t\t\tivec2(0, 0), ivec2(0, 0), ivec2(0, 0), ivec2(0, 0),\n\n    \n    \t\t\t\t\t\t\t\t// BLOCK_I\n                            \t\tivec2(0, 2), ivec2(1, 2), ivec2(2, 2), ivec2(3, 2),\n\t\t\t\t\t\t\t\t\tivec2(2, 0), ivec2(2, 1), ivec2(2, 2), ivec2(2, 3),\n\t\t\t\t\t\t\t\t\tivec2(0, 1), ivec2(1, 1), ivec2(2, 1), ivec2(3, 1),\n\t\t\t\t\t\t\t\t\tivec2(1, 0), ivec2(1, 1), ivec2(1, 2), ivec2(1, 3),\n\n\t\t\t\t\t\t\t\t\t// BLOCK_O\n\t\t\t\t\t\t\t\t\tivec2(0, 0), ivec2(0, 1), ivec2(1, 0), ivec2(1, 1),\n\t\t\t\t\t\t\t\t\tivec2(0, 0), ivec2(0, 1), ivec2(1, 0), ivec2(1, 1),\n\t\t\t\t\t\t\t\t\tivec2(0, 0), ivec2(0, 1), ivec2(1, 0), ivec2(1, 1),\n\t\t\t\t\t\t\t\t\tivec2(0, 0), ivec2(0, 1), ivec2(1, 0), ivec2(1, 1),\n\n\t\t\t\t\t\t\t\t\t// BLOCK_T\n                \t\t\t\t\tivec2(0, 1), ivec2(1, 1), ivec2(2, 1), ivec2(1, 2),\n\t\t\t\t\t\t\t\t\tivec2(1, 2), ivec2(1, 1), ivec2(1, 0), ivec2(2, 1),\n\t\t\t\t\t\t\t\t\tivec2(0, 1), ivec2(1, 1), ivec2(2, 1), ivec2(1, 0),\n\t\t\t\t\t\t\t\t\tivec2(0, 1), ivec2(1, 2), ivec2(1, 1), ivec2(1, 0),\n\n\t\t\t\t\t\t\t\t\t// BLOCK_S\n\t\t\t\t\t\t\t\t\tivec2(0, 1), ivec2(1, 1), ivec2(1, 2), ivec2(2, 2),\n\t\t\t\t\t\t\t\t\tivec2(1, 2), ivec2(1, 1), ivec2(2, 1), ivec2(2, 0),\n\t\t\t\t\t\t\t\t\tivec2(0, 0), ivec2(1, 0), ivec2(1, 1), ivec2(2, 1),\n\t\t\t\t\t\t\t\t\tivec2(0, 2), ivec2(0, 1), ivec2(1, 1), ivec2(1, 0),\n\n\t\t\t\t\t\t\t\t\t// BLOCK_Z\n\t\t\t\t\t\t\t\t\tivec2(0, 2), ivec2(1, 2), ivec2(1, 1), ivec2(2, 1),\n\t\t\t\t\t\t\t\t\tivec2(1, 0), ivec2(1, 1), ivec2(2, 1), ivec2(2, 2),\n\t\t\t\t\t\t\t\t\tivec2(0, 1), ivec2(1, 1), ivec2(1, 0), ivec2(2, 0),\n\t\t\t\t\t\t\t\t\tivec2(0, 0), ivec2(0, 1), ivec2(1, 1), ivec2(1, 2),\n\n\t\t\t\t\t\t\t\t\t// BLOCK_J\n\t\t\t\t\t\t\t\t\tivec2(0, 2), ivec2(0, 1), ivec2(1, 1), ivec2(2, 1),\n\t\t\t\t\t\t\t\t\tivec2(1, 0), ivec2(1, 1), ivec2(1, 2), ivec2(2, 2),\n\t\t\t\t\t\t\t\t\tivec2(0, 1), ivec2(1, 1), ivec2(2, 1), ivec2(2, 0),\n\t\t\t\t\t\t\t\t\tivec2(0, 0), ivec2(1, 0), ivec2(1, 1), ivec2(1, 2),\n\n\t\t\t\t\t\t\t\t\t// BLOCK_L\n\t\t\t\t\t\t\t\t\tivec2(0, 1), ivec2(1, 1), ivec2(2, 1), ivec2(2, 2),\n\t\t\t\t\t\t\t\t\tivec2(1, 2), ivec2(1, 1), ivec2(1, 0), ivec2(2, 0),\n\t\t\t\t\t\t\t\t\tivec2(0, 0), ivec2(0, 1), ivec2(1, 1), ivec2(2, 1),\n\t\t\t\t\t\t\t\t\tivec2(0, 2), ivec2(1, 2), ivec2(1, 1), ivec2(1, 0) );\n\n\nconst int BOUNDS[8] = int[]( 0, 4, 2, 3, 3, 3, 3, 3 );\n\nconst int SPAWNPOS_X[8] = int[]( 0, 3, 4, 3, 3, 3, 3, 3 );\n\n//======================================================\n// Game state (excluding playfield state)\n\nstruct GameState\n{    \n    int points;\n    int level;\n    int linesCleared;\n    bool gameOver;\n    \n    float prevUpdateTime;\n    \n    int currentBlockType;\n    ivec2 currentBlockPos;\n    int currentBlockRot;\n    \n    int numLinesToCheck;\n    int firstLineToCheck;\n    \n    int bags[14];\n    int bagIter;\n    int randSeed;\n    \n    float timeStep;\n    bool ghostVisible;\n};\n\n\n//=====================================================\n    \nvec4 loadValue(ivec2 tx)\n{\n    return texelFetch( iChannel0, tx, 0 );\n}\n\nvoid writeValue(ivec2 tx, vec4 val, inout vec4 fragColor, vec2 fragCoord)\n{\n \tivec2 fc = ivec2( fragCoord );\n    fragColor = ( fc.x == tx.x && fc.y == tx.y ) ? val : fragColor;\n}\n    \nvoid loadGameState(out GameState state)\n{    \n    state.points = int( loadValue(ivec2(10, 1)).x );\n    state.level = int( loadValue(ivec2(10, 1)).y );\n    state.linesCleared = int( loadValue(ivec2(10, 1)).z );\n    state.gameOver = loadValue(ivec2(10, 1)).w > 0.5;\n    \n    state.prevUpdateTime = loadValue(ivec2(10, 2)).x;\n    \n    state.currentBlockType = int( loadValue(ivec2(10, 3)).x );\n    state.currentBlockPos = ivec2( loadValue(ivec2(10, 3)).yz );\n    state.currentBlockRot = int( loadValue(ivec2(10, 3)).w );\n    \n    state.numLinesToCheck = int( loadValue(ivec2(10, 4)).x );\n    state.firstLineToCheck = int( loadValue(ivec2(10, 4)).y );\n\n    state.bags[0] = int( loadValue(ivec2(10, 6)).x );\n    state.bags[1] = int( loadValue(ivec2(10, 6)).y );\n    state.bags[2] = int( loadValue(ivec2(10, 6)).z );\n    state.bags[3] = int( loadValue(ivec2(10, 6)).w );\n    state.bags[4] = int( loadValue(ivec2(10, 7)).x );\n    state.bags[5] = int( loadValue(ivec2(10, 7)).y );\n    state.bags[6] = int( loadValue(ivec2(10, 7)).z );\n    state.bags[7] = int( loadValue(ivec2(10, 7)).w );\n    state.bags[8] = int( loadValue(ivec2(10, 8)).x );\n    state.bags[9] = int( loadValue(ivec2(10, 8)).y );\n    state.bags[10] = int( loadValue(ivec2(10, 8)).z );\n    state.bags[11] = int( loadValue(ivec2(10, 8)).w );\n    state.bags[12] = int( loadValue(ivec2(10, 9)).x );\n    state.bags[13] = int( loadValue(ivec2(10, 9)).y );\n    state.bagIter = int( loadValue(ivec2(10, 10)).x );\n    state.randSeed = int( loadValue(ivec2(10, 10)).y );\n    \n    state.timeStep = loadValue(ivec2(10, 5)).x;\n    state.ghostVisible = loadValue(ivec2(10, 5)).y > 0.5;\n}\n\nvoid saveGameState(GameState state, inout vec4 fragColor, vec2 fragCoord)\n{\n    writeValue(ivec2(10, 1), vec4(float(state.points), float(state.level), float(state.linesCleared), state.gameOver ? 1.0 : 0.0), fragColor, fragCoord);\n    \n    writeValue(ivec2(10, 2), vec4(float(state.prevUpdateTime), 0.0, 0.0, 0.0), fragColor, fragCoord);\n    \n    writeValue(ivec2(10, 3), vec4(float(state.currentBlockType), vec2(state.currentBlockPos), float(state.currentBlockRot)), fragColor, fragCoord);\n    \n    writeValue(ivec2(10, 4), vec4( float(state.numLinesToCheck), float(state.firstLineToCheck), 0.0, 0.0 ), fragColor, fragCoord);\n    \n    writeValue(ivec2(10, 6), vec4(float(state.bags[0]), float(state.bags[1]), float(state.bags[2]), float(state.bags[3])), fragColor, fragCoord);\n    writeValue(ivec2(10, 7), vec4(float(state.bags[4]), float(state.bags[5]), float(state.bags[6]), float(state.bags[7])), fragColor, fragCoord);\n    writeValue(ivec2(10, 8), vec4(float(state.bags[8]), float(state.bags[9]), float(state.bags[10]), float(state.bags[11])), fragColor, fragCoord);\n    writeValue(ivec2(10, 9), vec4(float(state.bags[12]), float(state.bags[13]), 0.0, 0.0), fragColor, fragCoord);\n    writeValue(ivec2(10, 10), vec4(float(state.bagIter), float(state.randSeed), 0.0, 0.0), fragColor, fragCoord);\n    \n    writeValue(ivec2(10, 5), vec4(state.timeStep, state.ghostVisible ? 1.0 : 0.0, 0.0, 0.0), fragColor, fragCoord);\n}\n    \nint getTile(ivec2 coords)\n{\n    if(coords.x < 0 || coords.y < 0 || coords.x > 9 || coords.y > 23)\n    {\n     \treturn BLOCK_BORDER;   \n    }\n    \n    return int( loadValue(coords).x );\n}\n\n\nbool gGameOverWriteFlag = false;\n\nvoid setTile(ivec2 coords, int type, inout vec4 fragColor, vec2 fragCoord)\n{\n \tif(coords.x < 0 || coords.y < 0 || coords.x > 9 || coords.y > 23)\n    {\n     \treturn;   \n    }\n    \n    if(coords.y >= 20 && type > BLOCK_NONE && type < BLOCK_BORDER)\n    {\n     \tgGameOverWriteFlag = true;   \n    }\n    \n    writeValue(coords, vec4(float(type), 0.0, 0.0, 0.0), fragColor, fragCoord);\n}\n\n//------------------------------------------------------\n\nbool canPlaceBlock(ivec2 pos, int type, int rot)\n{\n\treturn \t\tgetTile(pos + MAP[16*type + 4*rot]) <= BLOCK_NONE\n         \t&&\tgetTile(pos + MAP[16*type + 4*rot + 1]) <= BLOCK_NONE\n            &&\tgetTile(pos + MAP[16*type + 4*rot + 2]) <= BLOCK_NONE\n            &&\tgetTile(pos + MAP[16*type + 4*rot + 3]) <= BLOCK_NONE;\n}\n\n\nbool canRotateBlock(ivec2 pos, int type)\n{\n    for(int y=0; y < BOUNDS[type]; ++y)\n    {\n     \tfor(int x=0; x < BOUNDS[type]; ++x)\n        {\n         \tif(getTile(pos + ivec2(x, y)) > BLOCK_NONE)\n            {\n             \treturn false;\n            }\n        }\n    }\n    \n    return true;\n}\n\nbool canRotateBlock(ivec2 pos, int type, int targetRot)\n{\n \treturn canPlaceBlock(pos, type, targetRot);   \n}\n\n\nvoid spawnBlock(int shape, ivec2 pos, int rot, int type, inout vec4 fragColor, vec2 fragCoord)\n{\n    for(int i=0; i < 4; ++i)\n    {\n    \tsetTile(pos + MAP[16*shape + 4*rot + i], type, fragColor, fragCoord);\n    }\n}\n\n\n//------------------------------------------------------\n\n\nint irand(inout int seed)\n{\n \treturn(((seed = seed * 214013 + 2531011) >> 16) & 0x7fff);   \n}\n\nvoid generateBag(inout GameState state, int bag)\n{\n \tfor(int i=0; i < 7; ++i)\n    {\n     \tstate.bags[i + 7*bag] = i+1;\n    }\n    \n    for(int i=0; i < 7; ++i)\n    {\n     \tint r = irand(state.randSeed) % 7;\n        \n        int temp = state.bags[i+7*bag];\n        state.bags[i+7*bag] = state.bags[r+7*bag];\n        \n        //state.bags[r+7*bag] = temp;\t// Can't use \"array reference as l-value\"\n        \n        // ... but almost-explicit lookup table works\n        if(r == 0){\tstate.bags[0+7*bag] = temp;}\n        else if(r == 1){\tstate.bags[1+7*bag] = temp;}\n        else if(r == 2){\tstate.bags[2+7*bag] = temp;}\n        else if(r == 3){\tstate.bags[3+7*bag] = temp;}\n        else if(r == 4){\tstate.bags[4+7*bag] = temp;}\n        else if(r == 5){\tstate.bags[5+7*bag] = temp;}\n        else if(r == 6){\tstate.bags[6+7*bag] = temp;}\n        // Dumb compiler.\n    }\n}\n\n   \nvoid forwardBlockQueue(inout GameState state)\n{\n    state.bagIter += 1;\n    \n    if(state.bagIter == 14)\n    {\n     \tstate.bagIter = 0;\n        generateBag(state, 1);\n    }\n    else if(state.bagIter == 7)\n    {\n     \tgenerateBag(state, 0);   \n    }\n    \n    state.currentBlockType = state.bags[state.bagIter];\n    state.currentBlockRot = 0;\n    state.currentBlockPos = ivec2(SPAWNPOS_X[state.currentBlockType], 20);\n}\n\n//------------------------------------------------------\n\nint calcCurrentBlockDropDist(GameState state)\n{\n \tint d = 40;\n    \n    for(int i=0; i < 4; ++i)\n    {\n        ivec2 currentTile = state.currentBlockPos + MAP[state.currentBlockType*16 + state.currentBlockRot*4 + i];\n        int y = 1;\n        \n     \twhile( getTile( currentTile - ivec2(0, y) ) <= BLOCK_NONE )\n        {\n            ++y;\n        }\n        \n        if(y < d)\n        {\n         \td = y;   \n        }\n    }\n    \n    return d - 1;\n}\n\n\n//------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x >= 15.0 || fragCoord.y >= 23.0)\n    {\n     \tdiscard;   \n    }\n    \n    GameState state;\n\n    \n    if(iFrame < 1)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \tstate.prevUpdateTime = -32768.0;\n        state.timeStep = 1.0;\n        \n        state.bagIter = 13;\n        state.randSeed = int(iDate.w);\n        state.ghostVisible = true;\n        generateBag(state, 0);\n        generateBag(state, 1);\n        forwardBlockQueue(state);\n        \n        saveGameState(state, fragColor, fragCoord);\n        return;\n    }\n    else\n    {\n        fragColor = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n    \tloadGameState(state);\n    }\n    \n    if(state.gameOver)\n    {\n     \treturn;   \n    }\n    \n    bool keyMoveLeft  \t= texelFetch( iChannel1, ivec2(KB_LEFT, 1), 0 ).x > 0.5 || texelFetch( iChannel1, ivec2(KB_A, 1), 0 ).x > 0.5;\n    bool keyMoveRight \t= texelFetch( iChannel1, ivec2(KB_RIGHT, 1), 0 ).x > 0.5 || texelFetch( iChannel1, ivec2(KB_D, 1), 0 ).x > 0.5;\n    bool keyRotateRight  \t= texelFetch( iChannel1, ivec2(KB_UP, 1), 0 ).x > 0.5 || texelFetch( iChannel1, ivec2(KB_E, 1), 0 ).x > 0.5;\n    bool keyRotateLeft = texelFetch( iChannel1, ivec2(KB_Q, 1), 0 ).x > 0.5;\n    bool keyHardDrop \t= texelFetch( iChannel1, ivec2(KB_DOWN, 1), 0 ).x > 0.5 || texelFetch( iChannel1, ivec2(KB_S, 1), 0 ).x > 0.5;\n    bool keySoftDrop = texelFetch( iChannel1, ivec2(KB_W, 1), 0 ).x > 0.5;\n    bool keySpeedUp = texelFetch( iChannel1, ivec2(KB_NUMPAD_PLUS, 1), 0 ).x > 0.5;\n    bool keySpeedDown = texelFetch( iChannel1, ivec2(KB_NUMPAD_MINUS, 1), 0 ).x > 0.5;\n    bool keyToggleGhost = texelFetch( iChannel1, ivec2(KB_G, 1), 0 ).x > 0.5;\n    \n    //----------------------------------------\n    \n    GameState prevState = state;\n    \n    state.numLinesToCheck = 0;\n    state.firstLineToCheck = 0;\n    \n    if(iTime - state.prevUpdateTime >= state.timeStep)\n    {\n     \tstate.prevUpdateTime = iTime;\n        \n        if( canPlaceBlock(state.currentBlockPos+ivec2(0, -1), state.currentBlockType, state.currentBlockRot) )\n        {\n            state.currentBlockPos += ivec2(0, -1);\n        }\n        else\n        {\n            keyHardDrop = true;\t// Drop down the block as if the key was pressed (just make sure we don't change its behaviour!)\n        }\n    }\n    \n    \n\t//----------------------------------------\n    \n    \n    if(keyMoveLeft)\n    {\n    \tif( canPlaceBlock(state.currentBlockPos+ivec2(-1, 0), state.currentBlockType, state.currentBlockRot) )\n        {\n            state.currentBlockPos += ivec2(-1, 0);\n        }\n    }\n    \n    if(keyMoveRight)\n    {\n\t\tif( canPlaceBlock(state.currentBlockPos+ivec2(1, 0), state.currentBlockType, state.currentBlockRot) )\n        {\n            state.currentBlockPos += ivec2(1, 0);\n        }\n    }\n    \n    if(keyRotateRight)\n    {\n     \tif( canRotateBlock(state.currentBlockPos, state.currentBlockType, (state.currentBlockRot+1)%4) )\n        {\n         \tstate.currentBlockRot = (state.currentBlockRot + 1) % 4; \n        }\n    }\n    \n    if(keyRotateLeft)\n    {\n     \tif( canRotateBlock(state.currentBlockPos, state.currentBlockType, (state.currentBlockRot+3)%4) )\n        {\n         \tstate.currentBlockRot = (state.currentBlockRot + 3) % 4; \n        }\n    }\n    \n    if(keyHardDrop)\n    {\n        ivec2 dropPos = state.currentBlockPos - ivec2(0, calcCurrentBlockDropDist(state));\n        \n        spawnBlock(prevState.currentBlockType, prevState.currentBlockPos, prevState.currentBlockRot, BLOCK_NONE, fragColor, fragCoord);\n        spawnBlock(state.currentBlockType, dropPos, state.currentBlockRot, state.currentBlockType, fragColor, fragCoord);\n        \n        state.numLinesToCheck = BOUNDS[state.currentBlockType];\n        state.firstLineToCheck = dropPos.y;\n        \n        forwardBlockQueue(state);\n    }\n    else if(keySoftDrop)\n    {\n     \tif( canPlaceBlock(state.currentBlockPos+ivec2(0, -1), state.currentBlockType, state.currentBlockRot) )\n        {\n            state.currentBlockPos += ivec2(0, -1);\n            state.prevUpdateTime = iTime;\n        }\n    }\n    \n    if(keySpeedUp)\n    {\n     \tstate.timeStep -= 0.1;\n        if(state.timeStep <= 0.0){\tstate.timeStep = 0.1;}\n    }\n    \n    if(keySpeedDown)\n    {\n     \tstate.timeStep += 0.1;   \n    }\n    \n    if(keyToggleGhost)\n    {\n     \tstate.ghostVisible = !state.ghostVisible;   \n    }\n\n    if(!keyHardDrop)\t// Things start to break if we try to update three things at once... two is fine.\n    {\n        spawnBlock(prevState.currentBlockType, prevState.currentBlockPos, prevState.currentBlockRot, BLOCK_NONE, fragColor, fragCoord);\n        \n    \tspawnBlock(prevState.currentBlockType, prevState.currentBlockPos - ivec2(0, calcCurrentBlockDropDist(prevState)), prevState.currentBlockRot, BLOCK_NONE, fragColor, fragCoord);\n    \tspawnBlock(state.currentBlockType, state.currentBlockPos - ivec2(0, calcCurrentBlockDropDist(state)), state.currentBlockRot, BLOCK_GHOST, fragColor, fragCoord); \n        \n        spawnBlock(state.currentBlockType, state.currentBlockPos, state.currentBlockRot, BLOCK_CURRENT, fragColor, fragCoord);\n    }\n\n    \n   \tif(!state.gameOver)\n    {\n\t\tstate.gameOver = gGameOverWriteFlag;\n    }\n    \n    saveGameState(state, fragColor, fragCoord);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//==================================================\n//\tBUFFER B - LINE CLEARING HANDLING\n\nconst int BLOCK_CURRENT = -2;\nconst int BLOCK_GHOST = -1;\nconst int BLOCK_NONE = 0;\nconst int BLOCK_I = 1;\nconst int BLOCK_O = 2;\nconst int BLOCK_T = 3;\nconst int BLOCK_S = 4;\nconst int BLOCK_Z = 5;\nconst int BLOCK_J = 6;\nconst int BLOCK_L = 7;\nconst int BLOCK_BORDER = 8;\n\n\nconst int POINTS_AWARDED[5] = int[]( 0, 400, 1000, 3000, 12000);\n\nstruct GameState\n{    \n    int points;\n    int level;\n    int linesCleared;\n    bool gameOver;\n    \n    float prevUpdateTime;\n    \n    int currentBlockType;\n    ivec2 currentBlockPos;\n    int currentBlockRot;\n    \n    int numLinesToCheck;\n    int firstLineToCheck;\n};\n\n\n//=====================================================\n    \nvec4 loadValue(ivec2 tx)\n{\n    return texelFetch( iChannel0, tx, 0 );\n}\n\nvoid writeValue(ivec2 tx, vec4 val, inout vec4 fragColor, vec2 fragCoord)\n{\n \tivec2 fc = ivec2( fragCoord );\n    fragColor = ( fc.x == tx.x && fc.y == tx.y ) ? val : fragColor;\n}\n    \nvoid loadGameState(out GameState state)\n{    \n    state.points = int( loadValue(ivec2(10, 1)).x );\n    state.level = int( loadValue(ivec2(10, 1)).y );\n    state.linesCleared = int( loadValue(ivec2(10, 1)).z );\n    state.gameOver = loadValue(ivec2(10, 1)).w > 0.5;\n    \n    state.prevUpdateTime = loadValue(ivec2(10, 2)).x;\n    \n    state.currentBlockType = int( loadValue(ivec2(10, 3)).x );\n    state.currentBlockPos = ivec2( loadValue(ivec2(10, 3)).yz );\n    state.currentBlockRot = int( loadValue(ivec2(10, 3)).w );\n    \n    state.numLinesToCheck = int( loadValue(ivec2(10, 4)).x );\n    state.firstLineToCheck = int( loadValue(ivec2(10, 4)).y );\n\n}\n\nvoid saveGameState(GameState state, inout vec4 fragColor, vec2 fragCoord)\n{\n    writeValue(ivec2(10, 1), vec4(float(state.points), float(state.level), float(state.linesCleared), state.gameOver ? 1.0 : 0.0), fragColor, fragCoord);\n    \n    writeValue(ivec2(10, 2), vec4(float(state.prevUpdateTime), 0.0, 0.0, 0.0), fragColor, fragCoord);\n    \n    writeValue(ivec2(10, 3), vec4(float(state.currentBlockType), vec2(state.currentBlockPos), float(state.currentBlockRot)), fragColor, fragCoord);\n    \n    writeValue(ivec2(10, 4), vec4( float(state.numLinesToCheck), float(state.firstLineToCheck), 0.0, 0.0 ), fragColor, fragCoord);\n}\n\nint getTile(ivec2 coords)\n{\n    if(coords.x < 0 || coords.y < 0 || coords.x > 9 || coords.y > 23)\n    {\n     \treturn BLOCK_BORDER;   \n    }\n    \n    return int( loadValue(coords).x );\n}\n\nvoid setTile(ivec2 coords, int type, inout vec4 fragColor, vec2 fragCoord)\n{\n \tif(coords.x < 0 || coords.y < 0 || coords.x > 9 || coords.y > 23)\n    {\n     \treturn;   \n    }\n    \n    writeValue(coords, vec4(float(type), 0.0, 0.0, 0.0), fragColor, fragCoord);\n}\n\n\nbool isLineFull(int line)\n{\n    if(line < 0 || line >= 20)\n    {\n     \treturn false;   \n    }\n    \n \tfor(int x=0; x < 10; ++x)\n    {\n     \tif( getTile(ivec2(x, line)) <= BLOCK_NONE )\n        {\n         \treturn false;   \n        }\n    }\n    \n    return true;\n}\n\n\nvoid clearLine(int line, inout vec4 fragColor, vec2 fragCoord)\n{\n\tfor(int x=0; x < 10; ++x)\n    {\n     \tfor(int y=line; y < 19; ++y)\n        {\n            if(getTile(ivec2(x, y)) < BLOCK_NONE)\n            {\n             \tcontinue;   \n            }\n            \n            int upperTile = getTile(ivec2(x, y+1));\n            if(upperTile < BLOCK_NONE)\n            {\n             \tupperTile = BLOCK_NONE;   \n            }\n            \n         \tsetTile(ivec2(x, y), upperTile, fragColor, fragCoord);\n        }\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x >= 15.0 || fragCoord.y >= 23.0)\n    {\n     \tdiscard;   \n    }\n    \n\tfragColor = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n    \n    GameState state;\n    loadGameState(state);\n    \n    \n    int linesToRemove[5] = int[]( 21, 21, 21, 21, 21 );\n    int ltmIt = 0;\n    for(int i=0; i < state.numLinesToCheck; ++i)\n    {\n    \tif( isLineFull(state.firstLineToCheck + i) )\n        {\n         \tlinesToRemove[ltmIt++] = state.firstLineToCheck + i;   \n        }\n    }\n    \n    int moveDistance = 1;\n    for(int i=0; i < state.numLinesToCheck; ++i)\n    {       \n        for(int y=linesToRemove[i]+1; y < linesToRemove[i+1]; ++y)\n        {\n            for(int x=0; x < 10; ++x)\n            {\n                int upperTile = getTile(ivec2(x, y));\n                if(upperTile < BLOCK_NONE)\n                {\n                 \tupperTile = BLOCK_NONE;   \n                }\n                \n            \tsetTile( ivec2(x, y-moveDistance), upperTile, fragColor, fragCoord );\n            }\n        }\n        \n        ++moveDistance;\n    }\n    \n    state.points += POINTS_AWARDED[ltmIt] * (state.level+1);\n    \n    state.linesCleared += ltmIt;\n    \n    saveGameState(state, fragColor, fragCoord);\n}\n\n\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//======================================================\n//\tBUFFER C - INTERFACE\n\n\nconst int BLOCK_CURRENT = -2;\nconst int BLOCK_GHOST = -1;\nconst int BLOCK_NONE = 0;\nconst int BLOCK_I = 1;\nconst int BLOCK_O = 2;\nconst int BLOCK_T = 3;\nconst int BLOCK_S = 4;\nconst int BLOCK_Z = 5;\nconst int BLOCK_J = 6;\nconst int BLOCK_L = 7;\nconst int BLOCK_BORDER = 8;\n\n\nconst vec3[9] BLOCK_COLOR = vec3[](\n    \t\t\t\t\t\t\t\tvec3(0.0, 0.0, 0.0),\n    \t\t\t\t\t\t\t\tvec3(0.4, 0.8, 1.0),\n\t\t\t\t\t\t\t\t\tvec3(0.7, 0.7, 0.2),\n\t\t\t\t\t\t\t\t\tvec3(0.9, 0.5, 1.0),\n\t\t\t\t\t\t\t\t\tvec3(0.3, 0.8, 0.3),\n\t\t\t\t\t\t\t\t\tvec3(1.0, 0.2, 0.2),\n\t\t\t\t\t\t\t\t\tvec3(0.0, 0.0, 1.0),\n\t\t\t\t\t\t\t\t\tvec3(0.9, 0.6, 0.3),\n\t\t\t\t\t\t\t\t\tvec3(0.8, 0.8, 0.8) );\n\n\nconst ivec2 MAP[128] = ivec2[]( \t\n    \t\t\t\t\t\t\t\t// BLOCK_NONE\n    \t\t\t\t\t\t\t\tivec2(0, 0), ivec2(0, 0), ivec2(0, 0), ivec2(0, 0),\n\t\t\t\t\t\t\t\t\tivec2(0, 0), ivec2(0, 0), ivec2(0, 0), ivec2(0, 0),\n    \t\t\t\t\t\t\t\tivec2(0, 0), ivec2(0, 0), ivec2(0, 0), ivec2(0, 0),\n    \t\t\t\t\t\t\t\tivec2(0, 0), ivec2(0, 0), ivec2(0, 0), ivec2(0, 0),\n\n    \n    \t\t\t\t\t\t\t\t// BLOCK_I\n                            \t\tivec2(0, 2), ivec2(1, 2), ivec2(2, 2), ivec2(3, 2),\n\t\t\t\t\t\t\t\t\tivec2(2, 0), ivec2(2, 1), ivec2(2, 2), ivec2(2, 3),\n\t\t\t\t\t\t\t\t\tivec2(0, 1), ivec2(1, 1), ivec2(2, 1), ivec2(3, 1),\n\t\t\t\t\t\t\t\t\tivec2(1, 0), ivec2(1, 1), ivec2(1, 2), ivec2(1, 3),\n\n\t\t\t\t\t\t\t\t\t// BLOCK_O\n\t\t\t\t\t\t\t\t\tivec2(0, 0), ivec2(0, 1), ivec2(1, 0), ivec2(1, 1),\n\t\t\t\t\t\t\t\t\tivec2(0, 0), ivec2(0, 1), ivec2(1, 0), ivec2(1, 1),\n\t\t\t\t\t\t\t\t\tivec2(0, 0), ivec2(0, 1), ivec2(1, 0), ivec2(1, 1),\n\t\t\t\t\t\t\t\t\tivec2(0, 0), ivec2(0, 1), ivec2(1, 0), ivec2(1, 1),\n\n\t\t\t\t\t\t\t\t\t// BLOCK_T\n                \t\t\t\t\tivec2(0, 1), ivec2(1, 1), ivec2(2, 1), ivec2(1, 2),\n\t\t\t\t\t\t\t\t\tivec2(1, 2), ivec2(1, 1), ivec2(1, 0), ivec2(2, 1),\n\t\t\t\t\t\t\t\t\tivec2(0, 1), ivec2(1, 1), ivec2(2, 1), ivec2(1, 0),\n\t\t\t\t\t\t\t\t\tivec2(0, 1), ivec2(1, 2), ivec2(1, 1), ivec2(1, 0),\n\n\t\t\t\t\t\t\t\t\t// BLOCK_S\n\t\t\t\t\t\t\t\t\tivec2(0, 1), ivec2(1, 1), ivec2(1, 2), ivec2(2, 2),\n\t\t\t\t\t\t\t\t\tivec2(1, 2), ivec2(1, 1), ivec2(2, 1), ivec2(2, 0),\n\t\t\t\t\t\t\t\t\tivec2(0, 0), ivec2(1, 0), ivec2(1, 1), ivec2(2, 1),\n\t\t\t\t\t\t\t\t\tivec2(0, 2), ivec2(0, 1), ivec2(1, 1), ivec2(1, 0),\n\n\t\t\t\t\t\t\t\t\t// BLOCK_Z\n\t\t\t\t\t\t\t\t\tivec2(0, 2), ivec2(1, 2), ivec2(1, 1), ivec2(2, 1),\n\t\t\t\t\t\t\t\t\tivec2(1, 0), ivec2(1, 1), ivec2(2, 1), ivec2(2, 2),\n\t\t\t\t\t\t\t\t\tivec2(0, 1), ivec2(1, 1), ivec2(1, 0), ivec2(2, 0),\n\t\t\t\t\t\t\t\t\tivec2(0, 0), ivec2(0, 1), ivec2(1, 1), ivec2(1, 2),\n\n\t\t\t\t\t\t\t\t\t// BLOCK_J\n\t\t\t\t\t\t\t\t\tivec2(0, 2), ivec2(0, 1), ivec2(1, 1), ivec2(2, 1),\n\t\t\t\t\t\t\t\t\tivec2(1, 0), ivec2(1, 1), ivec2(1, 2), ivec2(2, 2),\n\t\t\t\t\t\t\t\t\tivec2(0, 1), ivec2(1, 1), ivec2(2, 1), ivec2(2, 0),\n\t\t\t\t\t\t\t\t\tivec2(0, 0), ivec2(1, 0), ivec2(1, 1), ivec2(1, 2),\n\n\t\t\t\t\t\t\t\t\t// BLOCK_L\n\t\t\t\t\t\t\t\t\tivec2(0, 1), ivec2(1, 1), ivec2(2, 1), ivec2(2, 2),\n\t\t\t\t\t\t\t\t\tivec2(1, 2), ivec2(1, 1), ivec2(1, 0), ivec2(2, 0),\n\t\t\t\t\t\t\t\t\tivec2(0, 0), ivec2(0, 1), ivec2(1, 1), ivec2(2, 1),\n\t\t\t\t\t\t\t\t\tivec2(0, 2), ivec2(1, 2), ivec2(1, 1), ivec2(1, 0) );\n\nstruct GameState\n{    \n    //int points;\n    //int level;\n    //int linesCleared;\n    //bool gameOver;\n    \n    //float prevUpdateTime;\n    \n    //int currentBlockType;\n    //ivec2 currentBlockPos;\n    //int currentBlockRot;\n    \n    //int numLinesToCheck;\n    //int firstLineToCheck;\n    \n    int bags[14];\n    int bagIter;\n    //int randSeed;\n    \n    //float timeStep;\n    //bool ghostVisible;\n};\n    \n    \nvec4 loadValue(ivec2 tx)\n{\n    return texelFetch( iChannel0, tx, 0 );\n}\n\n    \nvoid loadGameState(out GameState state)\n{    \n    /*\n    state.points = int( loadValue(ivec2(10, 1)).x );\n    state.level = int( loadValue(ivec2(10, 1)).y );\n    state.linesCleared = int( loadValue(ivec2(10, 1)).z );\n    state.gameOver = loadValue(ivec2(10, 1)).w > 0.5;\n    \n    state.prevUpdateTime = loadValue(ivec2(10, 2)).x;\n    \n    state.currentBlockType = int( loadValue(ivec2(10, 3)).x );\n    state.currentBlockPos = ivec2( loadValue(ivec2(10, 3)).yz );\n    state.currentBlockRot = int( loadValue(ivec2(10, 3)).w );\n    \n    state.numLinesToCheck = int( loadValue(ivec2(10, 4)).x );\n    state.firstLineToCheck = int( loadValue(ivec2(10, 4)).y );\n\t*/\n    \n    state.bags[0] = int( loadValue(ivec2(10, 6)).x );\n    state.bags[1] = int( loadValue(ivec2(10, 6)).y );\n    state.bags[2] = int( loadValue(ivec2(10, 6)).z );\n    state.bags[3] = int( loadValue(ivec2(10, 6)).w );\n    state.bags[4] = int( loadValue(ivec2(10, 7)).x );\n    state.bags[5] = int( loadValue(ivec2(10, 7)).y );\n    state.bags[6] = int( loadValue(ivec2(10, 7)).z );\n    state.bags[7] = int( loadValue(ivec2(10, 7)).w );\n    state.bags[8] = int( loadValue(ivec2(10, 8)).x );\n    state.bags[9] = int( loadValue(ivec2(10, 8)).y );\n    state.bags[10] = int( loadValue(ivec2(10, 8)).z );\n    state.bags[11] = int( loadValue(ivec2(10, 8)).w );\n    state.bags[12] = int( loadValue(ivec2(10, 9)).x );\n    state.bags[13] = int( loadValue(ivec2(10, 9)).y );\n    state.bagIter = int( loadValue(ivec2(10, 10)).x );\n    /*\n    state.randSeed = int( loadValue(ivec2(10, 10)).y );\n    \n    state.timeStep = loadValue(ivec2(10, 5)).x;\n    state.ghostVisible = loadValue(ivec2(10, 5)).y > 0.5;\n\t*/\n}\n    \n\n//======================================================\n//\tFrom https://www.shadertoy.com/view/4dtGD2\n\n\n#define _f float\nconst lowp _f CH_A    = _f(0x69f99), CH_B    = _f(0x79797), CH_C    = _f(0xe111e),\n       \t  \t  CH_D    = _f(0x79997), CH_E    = _f(0xf171f), CH_F    = _f(0xf1711),\n\t\t  \t  CH_G    = _f(0xe1d96), CH_H    = _f(0x99f99), CH_I    = _f(0xf444f),\n\t\t  \t  CH_J    = _f(0x88996), CH_K    = _f(0x95159), CH_L    = _f(0x1111f),\n\t\t  \t  CH_M    = _f(0x9f999), CH_N    = _f(0x9bd99), CH_O    = _f(0x69996),\n\t\t  \t  CH_P    = _f(0x79971), CH_Q    = _f(0x69b5a), CH_R    = _f(0x79759),\n\t\t  \t  CH_S    = _f(0xe1687), CH_T    = _f(0xf4444), CH_U    = _f(0x99996),\n\t\t  \t  CH_V    = _f(0x999a4), CH_W    = _f(0x999f9), CH_X    = _f(0x99699),\n    \t  \t  CH_Y    = _f(0x99e8e), CH_Z    = _f(0xf843f), CH_0    = _f(0x6bd96),\n\t\t  \t  CH_1    = _f(0x46444), CH_2    = _f(0x6942f), CH_3    = _f(0x69496),\n\t\t  \t  CH_4    = _f(0x99f88), CH_5    = _f(0xf1687), CH_6    = _f(0x61796),\n\t\t  \t  CH_7    = _f(0xf8421), CH_8    = _f(0x69696), CH_9    = _f(0x69e84),\n\t\t  \t  CH_APST = _f(0x66400), CH_PI   = _f(0x0faa9), CH_UNDS = _f(0x0000f),\n\t\t  \t  CH_HYPH = _f(0x00600), CH_TILD = _f(0x0a500), CH_PLUS = _f(0x02720),\n\t\t  \t  CH_EQUL = _f(0x0f0f0), CH_SLSH = _f(0x08421), CH_EXCL = _f(0x33303),\n\t\t  \t  CH_QUES = _f(0x69404), CH_COMM = _f(0x00032), CH_FSTP = _f(0x00002),\n    \t  \t  CH_QUOT = _f(0x55000), CH_BLNK = _f(0x00000), CH_COLN = _f(0x00202),\n\t\t\t  CH_LPAR = _f(0x42224), CH_RPAR = _f(0x24442);\nconst lowp vec2 MAP_SIZE = vec2(4,5);\n#undef flt\n\n/*\n\treturns the status of a bit in a bitmap. This is done value-wise, so\n\tthe exact representation of the float doesn't really matter.\n*/\nfloat getBit( in float map, in float index )\n{\n    // Ooh -index takes out that divide :)\n    return mod( floor( map*exp2(-index) ), 2.0 );\n}\n\n/*\n\tTrades a float for a character bitmap. Here's to eliminating\n\tbranches with step()!\n*/\nfloat floatToChar( in float x )\n{\n    float res = CH_BLNK;\n    res += (step(-.5,x)-step(0.5,x))*CH_0;\n    res += (step(0.5,x)-step(1.5,x))*CH_1;\n    res += (step(1.5,x)-step(2.5,x))*CH_2;\n    res += (step(2.5,x)-step(3.5,x))*CH_3;\n    res += (step(3.5,x)-step(4.5,x))*CH_4;\n    res += (step(4.5,x)-step(5.5,x))*CH_5;\n    res += (step(5.5,x)-step(6.5,x))*CH_6;\n    res += (step(6.5,x)-step(7.5,x))*CH_7;\n    res += (step(7.5,x)-step(8.5,x))*CH_8;\n    res += (step(8.5,x)-step(9.5,x))*CH_9;\n    return res;\n}\n\n/*\n\tDraws a character, given its encoded value, a position, size and\n\tcurrent [0..1] uv coordinate.\n*/\nfloat drawChar( in float char, in vec2 pos, in vec2 size, in vec2 uv )\n{\n    // Subtract our position from the current uv so that we can\n    // know if we're inside the bounding box or not.\n    uv-=pos;\n    \n    // Divide the screen space by the size, so our bounding box is 1x1.\n    uv /= size;    \n    \n    // Create a place to store the result.\n    float res;\n    \n    // Branchless bounding box check.\n    res = step(0.0,min(uv.x,uv.y)) - step(1.0,max(uv.x,uv.y));\n    \n    // Go ahead and multiply the UV by the bitmap size so we can work in\n    // bitmap space coordinates.\n    uv *= MAP_SIZE;\n    \n    // Get the appropriate bit and return it.\n    res*=getBit( char, 4.0*floor(uv.y) + floor(uv.x) );\n    return clamp(res,0.0,1.0);\n}\n\n/*\n\tPrints a float as an int. Be very careful about overflow.\n\tThis as a side effect will modify the character position,\n\tso that multiple calls to this can be made without worrying\n\tmuch about kerning.\n*/\nfloat drawIntCarriage( in int val, inout vec2 pos, in vec2 size, in vec2 uv, in int places )\n{\n    // Create a place to store the current values.\n    float res = 0.0,digit = 0.0;\n    // Surely it won't be more than 10 chars long, will it?\n    // (MAX_INT is 10 characters)\n    for( int i = 0; i < 10; ++i )\n    {\n        // If we've run out of film, cut!\n        if(val == 0 && i >= places) break;\n        // The current lsd is the difference between the current\n        // value and the value rounded down one place.\n        digit = float( val-(val/10)*10 );\n        // Draw the character. Since there are no overlaps, we don't\n        // need max().\n        res += drawChar(floatToChar(digit),pos,size,uv);\n        // Move the carriage.\n        pos.x -= size.x*1.2;\n        // Truncate away this most recent digit.\n        val /= 10;\n    }\n    return res;\n}\n\n/*\n\tDraws an integer to the screen. No side-effects, but be ever vigilant\n\tso that your cup not overfloweth.\n*/\nfloat drawInt( in int val, in vec2 pos, in vec2 size, in vec2 uv )\n{\n    vec2 p = vec2(pos);\n    float s = sign(float(val));\n    val *= int(s);\n    \n    float c = drawIntCarriage(val,p,size,uv,1);\n    return c + drawChar(CH_HYPH,p,size,uv)*max(0.0, -s);\n}\n\n/*\n\tPrints a fixed point fractional value. Be even more careful about overflowing.\n*/\nfloat drawFixed( in float val, in int places, in vec2 pos, in vec2 size, in vec2 uv )\n{\n    // modf() sure would be nice right about now.\n    vec2 p = vec2(pos);\n    float res = 0.0;\n    \n    // Draw the floating point part.\n    res = drawIntCarriage( int( fract(val)*pow(10.0,float(places)) ), p, size, uv, places );\n    // The decimal is tiny, so we back things up a bit before drawing it.\n    p.x += size.x*.4;\n    res = max(res, drawChar(CH_FSTP,p,size,uv)); p.x-=size.x*1.2;\n    // And after as well.\n    p.x += size.x *.1;\n    // Draw the integer part.\n    res = max(res, drawIntCarriage(int(floor(val)),p,size,uv,1));\n\treturn res;\n}\n\n//\n//=========================================================\n\n\nfloat text( in vec2 uv, int score, int linesCleared )\n{\n    \n    vec2 charSize = vec2(0.03, 0.0375);\n    \n    vec2 charPos = vec2(0.05, 0.9);\n    \n    float chr = 0.0;\n    // SCORE:\n    chr += drawChar( CH_S, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_C, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_O, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_R, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_E, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_COLN, charPos, charSize, uv); charPos.x += .1;\n    \n    \n    charPos = vec2(0.45, 0.75);\n    chr += drawInt( score, charPos, charSize*2.4, uv );\n\n    \n    // LINES CLEARED:\n    charPos = vec2(0.05, 0.6);\n    chr += drawChar( CH_L, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_I, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_N, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_E, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_S, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_BLNK, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_C, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_L, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_E, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_A, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_R, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_E, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_D, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_COLN, charPos, charSize, uv); charPos.x += .1;\n\n    charPos = vec2(0.45, 0.45);\n  \tchr += drawInt( linesCleared, charPos, charSize*2.4, uv );\n    \n    charPos = vec2(1.25, 0.9);\n    chr += drawChar( CH_N, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_E, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_X, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_T, charPos, charSize, uv); charPos.x += .04;\n    chr += drawChar( CH_COLN, charPos, charSize, uv); charPos.x += .1;\n\n    return chr;\n}\n\nfloat textGameOver( vec2 uv )\n{\n    vec2 charSize = vec2(0.03, 0.0375)*1.5;\n    \n    vec2 charPos = vec2(0.05, 0.25);\n    \n    float chr = 0.0;\n    \n    chr += drawChar( CH_G, charPos, charSize, uv); charPos.x += .06;\n    chr += drawChar( CH_A, charPos, charSize, uv); charPos.x += .06;\n    chr += drawChar( CH_M, charPos, charSize, uv); charPos.x += .06;\n    chr += drawChar( CH_E, charPos, charSize, uv); charPos.x += .06;\n    chr += drawChar( CH_BLNK, charPos, charSize, uv); charPos.x += .06;\n    chr += drawChar( CH_O, charPos, charSize, uv); charPos.x += .06;\n    chr += drawChar( CH_V, charPos, charSize, uv); charPos.x += .06;\n    chr += drawChar( CH_E, charPos, charSize, uv); charPos.x += .06;\n    chr += drawChar( CH_R, charPos, charSize, uv); charPos.x += .06;\n    chr += drawChar( CH_EXCL, charPos, charSize, uv); charPos.x += .06;\n    \n    return chr;\n}\n\n\nbool inside(ivec2 uv, ivec4 rect)\n{\n \treturn uv.x >= rect.x && uv.y >= rect.y && uv.x < rect.z && uv.y < rect.w;   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.8,0.8,0.8,1.0);\n    \n    vec2 uv = fragCoord / iResolution.y;\n    float screenRatio = iResolution.x / iResolution.y;\n    uv.x -= screenRatio * 0.5 - 0.25;\n    uv *= 20.0;\n    \n    GameState state;\n    loadGameState(state);\n    \n    float points = loadValue(ivec2(10, 1)).x;\n    float linesCleared = loadValue(ivec2(10, 1)).z;\n    bool gameOver = loadValue(ivec2(10, 1)).w > 0.5;\n    \n    ivec2 iuv = ivec2(uv);\n    \n    \n    //-------------------------------------\n    // This slows things down significantly\n    \n    if(inside(iuv, ivec4(13, 14, 17, 17)))\n    {\n        for(int i=0; i < 4; ++i)\n        {\n         \tif(iuv == ivec2(13, 14) + MAP[ state.bags[(state.bagIter+1)%14]*16 + i ])\n            {\n                fragColor.xyz = BLOCK_COLOR[ state.bags[(state.bagIter+1)%14] ];\n            }\n        }\n    }\n    \n    if(inside(iuv, ivec4(13, 10, 17, 13)))\n    {\n        for(int i=0; i < 4; ++i)\n        {\n         \tif(iuv == ivec2(13, 10) + MAP[ state.bags[(state.bagIter+2)%14]*16 + i ])\n            {\n                fragColor.xyz = BLOCK_COLOR[ state.bags[(state.bagIter+2)%14] ];\n            }\n        }\n    }\n    \n    if(inside(iuv, ivec4(13, 6, 17, 9)))\n    {\n        for(int i=0; i < 4; ++i)\n        {\n         \tif(iuv == ivec2(13, 6) + MAP[ state.bags[(state.bagIter+3)%14]*16 + i ])\n            {\n                fragColor.xyz = BLOCK_COLOR[ state.bags[(state.bagIter+3)%14] ];\n            }\n        }\n    }\n    \n    if(inside(iuv, ivec4(13, 2, 17, 5)))\n    {\n        for(int i=0; i < 4; ++i)\n        {\n         \tif(iuv == ivec2(13, 2) + MAP[ state.bags[(state.bagIter+4)%14]*16 + i ])\n            {\n                fragColor.xyz = BLOCK_COLOR[ state.bags[(state.bagIter+4)%14] ];\n            }\n        }\n    }\n    \n    \n    fragColor.xyz = mix( fragColor.xyz, vec3(0.0), text(fragCoord / iResolution.y, int(points), int(linesCleared)) );\n    \n    if(gameOver)\n    {\n    \tfragColor.xyz = mix( fragColor.xyz, vec3(0.0), textGameOver(fragCoord / iResolution.y) );\n    }\n    \n}\n\n\n\n","name":"Buffer C","description":"","type":"buffer"}]}