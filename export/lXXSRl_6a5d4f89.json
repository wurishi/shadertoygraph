{"ver":"0.1","info":{"id":"lXXSRl","date":"1709820109","viewed":96,"name":"Diffuse sphere shader","username":"vlk65536","description":"Calculate sine between normal on sphere's surface and light direction to assign brightness","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"M3XSRl","parentname":"diffuse sphere shader"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct light {\n    // Direction\n    vec3 d;\n    // Colour\n    vec3 c;\n};\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // 3D point on screen\n    vec3 P = vec3(uv,0.0);\n    // Direction camera is looking in\n    vec3 v = vec3(0.0, 0.0, 1.0);\n    // Sphere centre\n    vec3 c = vec3(0.0, 0.0, 3.0);\n    // Radius of sphere\n    float r = 0.4;\n    // Direction of lighting\n    \n    // Array of lights (light(direction, colour))\n    light lights[3] = light[3](\n        light(normalize(vec3(sin(iTime),cos(0.5*iTime),sin(iTime*0.3))), vec3(1.0,0.0,0.0)),\n        light(normalize(vec3(1.0,cos(0.5*iTime),3.0)), vec3(0.0,1.0,0.0)),\n        light(normalize(vec3(cos(2.5*iTime),1.0,3.0)), vec3(0.0,0.0,1.0))\n    );\n    \n    // Construct ray P+Î»v and intersect with sphere. Solve for lambda\n    \n    float lambda = sqrt(r*r- dot((P.xy-c.xy),(P.xy-c.xy)) )+c.z;  \n    \n    // Find the normal of the sphere at the intersection\n    vec3 n = normalize(P+lambda*v-c);\n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    for (int i=0; i<lights.length();i++) {\n        // Find the sine of the angle between the normal and light direction\n        float a = max(0.0, dot(n,lights[i].d));\n        // Apply colour \n        col += lights[i].c*a;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n/*\nvec3 sphere(vec2 p, vec2 ss, vec3 o, float r) {\n    \n}\n*/","name":"Image","description":"","type":"image"}]}