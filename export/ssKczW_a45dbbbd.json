{"ver":"0.1","info":{"id":"ssKczW","date":"1654553217","viewed":298,"name":"Curly Noise","username":"0xBAMA","description":"messing with perlin based curl noise","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["perlin","curlnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float freq = 19.0;\nconst int octaves = 2;\nfloat noise( vec3 p ) {\n    return perlinfbm( p, freq, octaves );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 uv = vec3( vec2( ( ( fragCoord + 3. ) / 4. ) / iResolution.y ) * 1.0, iTime / 100.0 );\n    vec3 col;\n    \n    // general structure from: https://al-ro.github.io/projects/embers/\n    float n1, n2, a, b;\n    vec2 epsilon = vec2( 0.1, 0.0 );\n    n1 = noise( uv + epsilon.yxy );\n    n2 = noise( uv - epsilon.yxy );\n    a = ( n1 - n2 ) / ( 2.0 * epsilon.x );\n    n1 = noise( uv + epsilon.yyx );\n    n2 = noise( uv - epsilon.yyx );\n    b = ( n1 - n2 ) / ( 2.0 * epsilon.x );\n    col.x = a - b;\n    \n    n1 = noise( uv + epsilon.yyx );\n    n2 = noise( uv - epsilon.yyx );\n    a = ( n1 - n2 ) / ( 2.0 * epsilon.x );\n    n1 = noise( uv + epsilon.xyy );\n    n2 = noise( uv - epsilon.xyy );\n    b = ( n1 - n2 ) / ( 2.0 * epsilon.x );\n    col.y = b - a;\n\n    n1 = noise( uv + epsilon.xyy );\n    n2 = noise( uv - epsilon.xyy );\n    a = ( n1 - n2 ) / ( 2.0 * epsilon.x );\n    n1 = noise( uv + epsilon.yxy );\n    n2 = noise( uv - epsilon.yxy );\n    b = ( n1 - n2 ) / ( 2.0 * epsilon.x );\n    col.z = a - b;\n\n    // Output to screen\n    fragColor = vec4( normalize( col ), 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Hash by David_Hoskins\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\nvec3 hash33( vec3 p ) {\n\tuvec3 q = uvec3( ivec3( p ) ) * UI3;\n\tq = ( q.x ^ q.y ^ q.z )*UI3;\n\treturn -1.0 + 2.0 * vec3( q ) * UIF;\n}\n\n// Gradient noise by iq (modified to be tileable)\nfloat gradientNoise( vec3 x, float freq ) {\n    // grid\n    vec3 p = floor( x );\n    vec3 w = fract( x );\n    \n    // quintic interpolant\n    vec3 u = w * w * w * ( w * ( w * 6.0 - 15.0 ) + 10.0 );\n\n    // gradients\n    vec3 ga = hash33( mod( p + vec3( 0.0, 0.0, 0.0 ), freq ) );\n    vec3 gb = hash33( mod( p + vec3( 1.0, 0.0, 0.0 ), freq ) );\n    vec3 gc = hash33( mod( p + vec3( 0.0, 1.0, 0.0 ), freq ) );\n    vec3 gd = hash33( mod( p + vec3( 1.0, 1.0, 0.0 ), freq ) );\n    vec3 ge = hash33( mod( p + vec3( 0.0, 0.0, 1.0 ), freq ) );\n    vec3 gf = hash33( mod( p + vec3( 1.0, 0.0, 1.0 ), freq ) );\n    vec3 gg = hash33( mod( p + vec3( 0.0, 1.0, 1.0 ), freq ) );\n    vec3 gh = hash33( mod( p + vec3( 1.0, 1.0, 1.0 ), freq ) );\n    \n    // projections\n    float va = dot( ga, w - vec3( 0.0, 0.0, 0.0 ) );\n    float vb = dot( gb, w - vec3( 1.0, 0.0, 0.0 ) );\n    float vc = dot( gc, w - vec3( 0.0, 1.0, 0.0 ) );\n    float vd = dot( gd, w - vec3( 1.0, 1.0, 0.0 ) );\n    float ve = dot( ge, w - vec3( 0.0, 0.0, 1.0 ) );\n    float vf = dot( gf, w - vec3( 1.0, 0.0, 1.0 ) );\n    float vg = dot( gg, w - vec3( 0.0, 1.0, 1.0 ) );\n    float vh = dot( gh, w - vec3( 1.0, 1.0, 1.0 ) );\n\t\n    // interpolation\n    return va + \n           u.x * ( vb - va ) + \n           u.y * ( vc - va ) + \n           u.z * ( ve - va ) + \n           u.x * u.y * ( va - vb - vc + vd ) + \n           u.y * u.z * ( va - vc - ve + vg ) + \n           u.z * u.x * ( va - vb - ve + vf ) + \n           u.x * u.y * u.z * ( -va + vb + vc - vd + ve - vf - vg + vh );\n}\n\nfloat perlinfbm( vec3 p, float freq, int octaves ) {\n    float G = exp2( -0.85 );\n    float amp = 1.0;\n    float noise = 0.0;\n    for ( int i = 0; i < octaves; ++i ) {\n        noise += amp * gradientNoise( p * freq, freq );\n        freq *= 2.0;\n        amp *= G;\n    }\n    return noise;\n}","name":"Common","description":"","type":"common"}]}