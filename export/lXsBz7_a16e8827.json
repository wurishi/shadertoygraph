{"ver":"0.1","info":{"id":"lXsBz7","date":"1728223964","viewed":19,"name":"Find Integer Factor","username":"popojan","description":"a take on integer factorization\ntakes the integer part of displayed iTime as an input","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["math","numbers","integers","factorization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float ff(float n, float m) {\n    float a = 1.0;\n    float b = 1.0;\n    float ret = 0.0;\n    for(int i = 1; i <= int(m); ++i) {\n        a *= n - float(i);\n        b *= n + float(i);\n        float den = float(2 * i + 1);\n        ret += mod(mod(a, den) * mod(b, den), den) / den;\n    }\n    return 1.0/(1.0-mod(ret, 0.9999999));\n}\n\nfloat getm(float n) {\n    return floor(0.5 * (sqrt(n)-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float num = floor(float(iTime));\n    float mul = 1.0;\n    while(num > 2.0 && mod(num, 2.0) < 0.1) { //powers of 2\n        mul *= 2.0;\n        num /= 2.0; \n    }\n    while(num > 3.0 && mod(num, 3.0) < 0.1) { //powers of 3\n        mul *= 3.0;\n        num /= 3.0; \n    }\n    float p = mul * ff(num,getm(num)); //other factors\n    num *= mul;\n    float q = num / p;\n    if(p < 2.0) {  // fix primes before it breaks anyway\n        p = 1.0;   // due to insufficient precision\n        q = num;   // as big integers are absent in GLSL\n    }\n    vec2 xy = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(1.0,p * mod(xy.y,1.0/p), q * mod(xy.x,1.0/q),1.0);\n}","name":"Image","description":"","type":"image"}]}