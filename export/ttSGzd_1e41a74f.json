{"ver":"0.1","info":{"id":"ttSGzd","date":"1560708112","viewed":223,"name":"Chewed sphere","username":"Darien","description":"Playing and learning Ray-marching. Cheated a bit by using 2D noise for 3D displacement... maybe that's why there's a rotation glitch? which I like! :D  ","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589\n#define STEPS 32\n#define OCTAVES 5\n\n\nmat3 rotateY(float a) {\n\treturn mat3(\n\t\tvec3(cos(a), 0., -sin(a)),\n\t\tvec3(0, 1., 0.),\n\t\tvec3(sin(a), 0, cos(a))\n\t\t);\n}\n\nmat3 rotateX(float a) {\n\treturn mat3(\n\t\tvec3(1., 0., 0.),\n\t\tvec3(0., cos(a), -sin(a)),\n\t\tvec3(0., sin(a), cos(a))\n\t\t);\t\n}\n\nfloat random(vec2 st) {\n\treturn fract(sin(dot(st, vec2(15.13123, 45.56251))) * 45666.12) *2.-1.;\n}\n\nfloat noise(vec2 st) {\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\t// Create grid to spread out our noise\n\tfloat a = random(i);\n\tfloat b = random(i + vec2(1.0, 0.0));\n\tfloat c = random(i + vec2(0.0, 1.0));\n\tfloat d = random(i + vec2(1.0, 1.0));\n\t// Create our hermite cubic interpolation\n\tvec2 h = f * f * (3.0 - 2.0 * f);\n\t// Do our bilinear interpolation:\n\treturn \tmix(a, b, h.x) + \n\t\t\t(c - a) * h.y * (1.0 - h.x) +\n\t\t\t(d - b) * h.x * h.y;\n}\n\nfloat fbm(vec3 p){\n\tfloat amp = 2.0;\n\tfloat fbm = 0.;\n\tfloat scale = 2.0;\n\tfor(int i = 0; i < OCTAVES; i++){\n\t\tfbm += noise(p.xy) * amp;\n\t\tp *= scale;\n\t\tamp *= 0.5;\n\t}\n\treturn fbm;\n}\n\nfloat sphere(vec3 p, float r) {\n\treturn length(p) - 0.5 * r;\n}\n\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\tp *= rotateX(-PI*0.35);\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\nfloat scene(vec3 p) {\n\tp *= rotateY(PI*iTime);\n\tfloat noisySphere = max(sphere(p + fbm(p)*0.5, 12.), sphere(p, 12.));\n\tfloat torus = fTorus(p, 6.9, 9.);\n\treturn max(torus, noisySphere);\n}\n\nvec3 getNormals(vec3 p) {\n\tvec3 delta = vec3(0.01, 0., 0.);\n\tfloat x = scene(p + delta.xyy) - scene(p - delta.xyy);\n\tfloat y = scene(p + delta.yxy) - scene(p - delta.yxy);\n\tfloat z = scene(p + delta.yyx) - scene(p - delta.yyx);\n\treturn normalize(vec3(x, y, z));\n}\n\nfloat rayMarching(vec3 pos, vec3 dir, out vec3 p) {\n\tfloat currentDist = 0.;\n\tconst float min = 0.01;\n\tconst float max = 1000.0;\n\tfor(int i = 0; i < STEPS; ++i) {\n\t\tp = pos + (dir * currentDist);\n\t\tfloat distance2Obj = scene(p);\n\t\tif(distance2Obj < min) {\n\t\t\tbreak;\n\t\t}\n\t\tcurrentDist += distance2Obj;\n\t\tif(currentDist > max) {\n\t\t\tcurrentDist = 0.;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn currentDist;\n}\n\n\n// Standard Blinn lighting model.\n// This model computes the diffuse and specular components of the final surface color.\nvec3 calculateLighting(vec3 pointOnSurface, vec3 surfaceNormal, vec3 lightPosition, vec3 cameraPosition, vec3 col)\n{\n\tvec3 fromPointToLight = normalize(lightPosition - pointOnSurface); // Get normal\n\tfloat diffuseStrength = clamp( dot( surfaceNormal, fromPointToLight ), 0.0, 1.0 );\n\tvec3 diffuseColor = diffuseStrength * col;\n\tvec3 reflectedLightVector = normalize( reflect( -fromPointToLight, surfaceNormal ) );\n\tvec3 fromPointToCamera = normalize( cameraPosition - pointOnSurface );\n\tfloat specularStrength = pow( clamp( dot(reflectedLightVector, fromPointToCamera), 0.0, 1.0), 10.0);\n\t// Ensure that there is no specular lighting when there is no diffuse lighting.\n\tspecularStrength = min( diffuseStrength, specularStrength );\n\tvec3 specularColor = specularStrength * vec3( 1.0 );\n\tvec3 finalColor = diffuseColor + specularColor;\n\treturn finalColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 st = gl_FragCoord.xy / iResolution.xy * 2. - 1.;\n\tst.x *= iResolution.x / iResolution.y;\n\n\t// Define camera properties\n\tvec3 cameraPos = vec3(0., 0., -10.0);\n\tvec3 cameraDir = vec3(st.x, st.y, 1.);\n\tvec3 color = vec3(length(st))*0.05;\n\tvec3 p;\n\tfloat r = rayMarching(cameraPos, cameraDir, p);\n\t\n\tif(r > 0.0) {\n\t\tvec3 normals = getNormals(p);\n\t\tvec3 lightPosA = vec3(-12., 0., 0.);\n\t\tvec3 lightPosB = vec3(9., 0., -10.);\n\t\tfloat fbmCol = abs(fbm(p*4.0));\n\t\tvec3 colA = mix(vec3(cos(iTime)*0.5+0.5, .5, 0.25), vec3(0.1, 0.5, 0.9), fbmCol);\n\t\tvec3 colB = mix(colA, vec3(0.9, 0.9, 0.9), fbmCol);\n\t\tcolor = calculateLighting(p, normals, lightPosA, cameraPos, colA);\n\t\tcolor += calculateLighting(p, normals, lightPosB, cameraPos, colB);\t\n\t}\n\n\tfragColor = vec4(color, 1.);\n}\n\n","name":"Image","description":"","type":"image"}]}