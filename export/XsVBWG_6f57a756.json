{"ver":"0.1","info":{"id":"XsVBWG","date":"1530249782","viewed":7051,"name":"Jupiter II","username":"viclw17","description":"Based on https://www.shadertoy.com/view/MdyfWw\nModified on http://glslsandbox.com/e#20148.3\n","likes":46,"published":1,"flags":0,"usePreview":0,"tags":["3d","uv","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat rand(vec2 co, float seed){\n    return fract(sin(dot(co.xy + seed ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 makeJupiter(vec2 uv)\n{\n    float time = iTime;\n\tfloat timeScale = .5;\n\tvec2 zoom = vec2(20.,5.5);\n\tvec2 offset = vec2(2.,1.);\n\n    \n    vec2 point = uv * zoom + offset;\n    float p_x = float(point.x); \n    float p_y = float(point.y);\n    \n    float a_x = .2;\n    float a_y = .3;\n    \n    for(int i=1; i<int(10); i++){\n        float float_i = float(i); \n        point.x+=a_x*sin(float_i*point.y+time*timeScale);\n        point.y+=a_y*cos(float_i*point.x+time*.2);\n    }\n        \n    float r = cos(point.x+point.y+2.)*.5+.5;\n    float g = sin(point.x+point.y+2.2)*.5+.5;\n    float b = (sin(point.x+point.y+1.)+cos(point.x+point.y+1.5))*.5+.5;\n    \n    vec3 col = vec3(r,g,b);\n    col += vec3(.5);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n {\n\tvec2 resolution = iResolution.xy;\n\tvec2 texCoord = gl_FragCoord.xy / resolution.xy;\n\ttexCoord = vec2(texCoord.y,texCoord.x);\n\tvec2 position = ( gl_FragCoord.xy / resolution.xy );\n\t\n\tvec2 center = resolution.xy / 2.;\n\tfloat dis = distance(center, gl_FragCoord.xy);\n\tfloat radius = resolution.y / 3.;\n\tvec3 atmosphereColor = vec3(.7, .6, .5);\n\tif (dis < radius) {\n\t\t// Find planet coordinates\n\t\tvec2 posOnPlanet = (gl_FragCoord.xy - (center - radius));\n\t\tvec2 planetCoord = posOnPlanet / (radius * 2.0);\n\t\t\n\t\t// Spherify it\n\t\tplanetCoord = planetCoord * 2.0 - 1.0;\n\t\tfloat sphereDis = length(planetCoord);\n\t\tsphereDis = 1.0 - pow(1.0 - sphereDis, .6);\n\t\tplanetCoord = normalize(planetCoord) * sphereDis;\n\t\tplanetCoord = (planetCoord + 1.0) / 2.0;\n\t\t\n\t\t// Calculate light amounts\n\t\tfloat light = pow(planetCoord.x, 2.0*(cos(iTime*.1 +1.)+1.5));\n\t\tfloat lightAtmosphere = pow(planetCoord.x, 2.);\n\t\t\n\t\t// Apply light\n\t\tvec3 surfaceColor = makeJupiter(texCoord);\n\t\tsurfaceColor *= light;\n\t\t\n\t\t// Atmosphere\n\t\tfloat fresnelIntensity = pow(dis / radius, 3.);\n\t\tvec3 fresnel = mix(surfaceColor, atmosphereColor, fresnelIntensity * lightAtmosphere);\n\t\t\n\t\tfragColor = vec4(fresnel.rgb, 1);\n        fragColor *= texCoord.x * 2.;\n\t}\n\telse {\n\t\t// Render stars\n\t\tfloat starAmount = rand(gl_FragCoord.xy, 0.0);\n\t\tvec3 background = vec3(0, 0, 0);\n\t\tif (starAmount < .01) {\n\t\t\tfloat intensity = starAmount * 1000.0 / 4.0;\n\t\t\tintensity = clamp(intensity, .1, .3);\n\t\t\tbackground = vec3(intensity);\n\t\t}\n\t\t\n\t\t// Atmosphere on top\n\t\tfloat outter = distance(center, gl_FragCoord.xy) / resolution.y;\n\t\toutter = 1.0 - outter;\n\t\toutter = clamp(outter, 0.5, 0.8);\n\t\toutter = (outter - .5) / .3;\n\t\toutter = pow(outter, 2.8);\n\t\t//outter *= texCoord.x * 1.5;\n\t\t\n\t\t// Add atmosphere on top\n\t\tfragColor = vec4(background + atmosphereColor * outter, 1);\n\t}\n}\n","name":"Image","description":"","type":"image"}]}