{"ver":"0.1","info":{"id":"XtGGR1","date":"1472943230","viewed":164,"name":"T1000 Jr.","username":"movax","description":"Building core functions for raymarching, developing this for my own knowledge and education.  \n- Added simple lighting and cube mapped reflections\n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","boolean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITERATIONS 48\n#define d  0.25\n#define zz 1.2\n\n#define dx cos(iTime/4.0 + 5333.0 ) * d\n#define dy  cos(iTime/3.0 + 15333.0 ) * d\n#define dz  zz//cos(iTime/1.0 + 25333.0 ) * d - 5.1;\n\n#define dx2  cos(iTime/5.0 + 53333.0 ) * d\n#define dy2  cos(iTime/2.0 + 156333.0 ) * d + 0.1 \n#define dz2  cos(iTime/2.3 + 256333.0 ) * d + zz + 0.2\n\n#define dx3  cos(iTime/5.0 + 2333.0 ) * d\n#define dy3  cos(iTime/2.0 + 1333.0 ) * d \n#define dz3  cos(iTime/2.3 + 333.0 ) * d + zz - 0.2\n        \n        \nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat opI( float d1, float d2 ){\n    return max(d1,d2);\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat subtract( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat sdUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opBlend(float objectA, float objectB,float n )\n{\n  //  float d1 = primitiveA(p);\n//    float d2 = primitiveB(p);\n    return smin( objectA, objectB, n);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ){\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat opRep( vec3 p, vec3 spacing ) {\n    vec3 q = mod(p, spacing) - 0.5 * spacing;\n    return sdSphere(q, 0.5);//\n//    return udRoundBox( q, vec3(-0.2, -0.1, 0.4), 0.74 );\n//    return sdHexPrism( q, vec2( 0.2 + 0.1 * cos(iTime/2.), 1.0 + 0.9 * sin(3.14 + iTime/2.) ) );\n}\n\n\n//KC \n\nmat4 transpose2(mat4 a){\n \n    return mat4( vec4(a[0][0], a[1][0], a[2][0], a[3][0]), vec4(a[0][1], a[1][1], a[2][1], a[2][1]),\n                 vec4(a[0][2], a[1][2], a[2][2], a[3][2]), vec4(a[0][3], a[1][3], a[2][3], a[2][3]));\n                 \n}\n\n\n\n\nfloat object( vec3 p, vec3 pos, vec3 rotation, int type, float radius ){\n    \n    float cx = cos(rotation.x);\n    float cy = cos(rotation.y);\n    float cz = cos(rotation.z);\n    float sx = sin(rotation.x);\n    float sy = sin(rotation.y);\n    float sz = sin(rotation.z);\n               \n    //X Rotation\n    //Genereate rotation matrix and transpose it\n    mat4 rotC = mat4(vec4(1.0, 0.0, 0.0, 0.0), vec4(0.0, cx, sx, 0.0), vec4(0.0, -sx, cx, 0), vec4(0.0,0.0,0.0,1.0));\n    mat4 rotD = transpose2(rotC) ;       \n    //Y Rotation\n    //Genereate rotation matrix and transpose it\n    mat4 rotE = mat4(vec4(cy, 0.0, -sy, 0.0), vec4(0,1,0,0), vec4(sy,0.0,  cy, 0), vec4(0.0,0.0,0.0,1.0));\n    mat4 rotF = transpose2(rotE) ;\n     //Z Rotation\n    //Genereate rotation matrix and transpose it\n    mat4 rotA = mat4(vec4(cz, sz, 0.0, 0.0), vec4(-sz, cz, 0.0, 0.0), vec4(0,0,1.0,0.0), vec4(0.0,0.0,0.0,1.0));\n    mat4 rotB = transpose2(rotA) ;\n    //generate translation matrix\n    mat4 trans = mat4(vec4(1.0,0.0,0.0,0.0), vec4(0.0,1.0,0.0,0.0), vec4(0.0,0.0,1.0,0.0), vec4(-pos.x, -pos.y, -pos.z,1.0));\n\t//Create Inverted, apply to swizzled input point\n    mat4 matrixA = rotD * rotF * rotB * trans;       \n    vec4 point4 = vec4(p.xyz, 1.0);  \n\t//Generate translated    \n    vec4 q = matrixA * point4; \n    \n    //Run through shape disatance\n    if(type == 1){\n       return udBox(q.xyz, vec3(0.5, 0.5, 0.4)); \n    }\n    if(type == 2){\n       return sdHexPrism(q.xyz, vec2(0.5,0.4));////udBox(q.xyz, vec3(0.5, 0.5, 0.4)); \n    }\n    if(type == 3){\n        return udRoundBox( q.xyz, vec3(0.4,0.4,0.4), abs(cos(iTime)*0.14) + 0.05 );\n    }\n    return sdSphere(q.xyz, 0.5);//\n    \n  \n}\n\n\nfloat scene(vec3 ip){\n\n    float temp;\n        temp = object(ip , vec3(dx, dy, dz) , vec3(iTime / 3.1, iTime / 2.1 , iTime / 1.1),  3, 0.5);\n        float sphereB = object(ip , vec3(dx2, dy2, dz2) ,vec3(iTime / 2.1, iTime / 1.31 , iTime / 3.1), 3, 0.5);\n        temp = subtract(temp, sphereB);\n        float sphereC = object(ip , vec3(dx3,dy3,dz3),vec3(iTime * 1.9, iTime * 2.3 , iTime / 1.5), 3, 0.5);\n        temp = subtract(sphereC, temp);\n        \n\t\ttemp =    opBlend(temp, object(ip, vec3(dx,dy,dz2), vec3(0), 0 ,1.0), cos((iTime)) *0.5+0.5 );\n    //float bg = sdPlane( ip, vec4(2,2,-5,15) );\n\n    //temp = sdUnion(temp, bg);\n    return temp;\n        \n}\n\n\n// Tetrahedral normal, courtesy of IQ.\nvec3 getNormal( in vec3 pos )\n{\n    vec2 e = vec2(0.001, -0.001);//0.001);\n    return normalize(\n        e.xyy * scene(pos + e.xyy) + \n        e.yyx * scene(pos + e.yyx) + \n        e.yxy * scene(pos + e.yxy) + \n        e.xxx * scene(pos + e.xxx));\n}\n\n\n//Main\n\nvoid depth(vec3 origin, vec2 uv, out vec3 point, out int last_i, out float temp ){\n\t  // 1 : retrieve the fragment's coordinates\n    //uv.y = iResolution.x / iResolution.y;\n    //uv -= vec2(0.5, 0.5);\n  \n    \n\t// 2 : camera position and ray direction\n\t //vec3 pos = vec3( sin(iTime), 0, sin(iTime) * 5. );\n\tvec3 dir = normalize( vec3( uv, 1. ) );\n \t//vec3 sn = getNormal(origin)\n\t// 3 : ray march loop\n    // ip will store where the ray hits the surface\n\tvec3 ip;\n \n\t// variable step size\n\tfloat t = 0.0;\n\tfloat findThresh = 0.001;\n    last_i = 0;\n    \n\tfor(int i = 0; i < ITERATIONS; i++) {\n\t\tlast_i = i;        \n        //update position along path\n        ip = origin + dir * t;\n        //gets the shortest distance to the scene\n        //break the loop if the distance was too small\n        //this means that we are close enough to the surface\n \t\ttemp = scene(ip);\n\t\tif( temp < findThresh ) {\t\t\t\n\t\t\tbreak;\n\t\t}        \t\t\n\t\t//increment the step along the ray path\n\t\tt += temp;\n\t}\n\t\n    if (last_i == ITERATIONS - 1){\n        point = vec3(0,0,0);\n    }\n    else{\n    \tpoint = ip;\n    }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Lighting code from https://www.reddit.com/r/twotriangles/comments/1hy5qy/tutorial_1_writing_a_simple_distance_field/\n  \tvec3 cameraOrigin = vec3(0.0, 0.0, 0.0);\n  \tvec3 origin = vec3( 0.0);//sin(iTime), 0, iTime / 20. );\n\n\tvec3 cameraTarget = vec3(0.0, 0.0, 1.0);\n\tvec3 upDirection = vec3(0.0, 1.0, 0.0);\n\tvec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n\tvec3 cameraUp = cross(cameraDir, cameraRight);\n\tvec2 screenPos = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy; // screenPos can range from -1 to 1\n\tscreenPos.x *= iResolution.x / iResolution.y; // Correct aspect ratio \n    vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n\n    int last_i;\n    float t;\n    vec3 point;\n    \n    depth(origin, screenPos, point , last_i, t);\n    \n    // Light position, hovering around behind the camera.\n    vec3 lp = origin + vec3(cos(iTime/4.)*.5, sin(iTime/4.)*.5, -.5);\n    lp.x -= 10.0;\n    // Surface postion, surface normal and light direction.\n    vec3 sp = origin + point;\n    vec3 sn = getNormal(sp);\n    vec3 ld = lp - sp;    \n    //Lambert's law states that the amount of reflected light is proportional to the cosine of the angle of \n    //incidence (dot product). A surface is illuminated by a light source only if the angle of incidence is \n    //between 0 and 90 degrees.\n \tfloat diffuse = max(0.0, dot(-rayDir, sn));\n    float specular = pow(diffuse, 20.0);\n\t\n    vec4 tex = texture(iChannel0, vec2(diffuse * 0.1, 0.5)).bgra;\n    //texture = texture(iChannel0, vec2(sn.z * 0.5 + 0.5, sn.z * 0.5 + 0.5)).bgra;\n   // vec4 tex = texture( iChannel0,  sn);\n\t\n    \n    \n\tvec3 color = vec3(diffuse + specular) * tex.rgb;\n\n \n\t// make background black if no shape was hit\n    if(last_i == ITERATIONS - 1) {\n        fragColor = vec4(0,0,0,1.0);//vec4(ip - float(last_i) / float(ITERATIONS), 1.0 );\n\t}\n    else{\n       \tfragColor = vec4(color,1.0);//vec4(ip - float(last_i) / float(ITERATIONS), 1.0 );\n    }\n}    ","name":"Image","description":"","type":"image"}]}