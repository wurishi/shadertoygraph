{"ver":"0.1","info":{"id":"lXGGWw","date":"1717701156","viewed":57,"name":"Procedural Radar Effect ","username":"Lord_Hypersonic","description":"Radar effect ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","radar","polaruv"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14\n\nfloat random2d(vec2 coord){\n    return fract(sin(dot(coord.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nmat2 rotate(float angle){\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nfloat drawLine(vec2 uv, float offset, float thickness, float angle)\n{\n    float o = 0.0;\n    uv = rotate(angle * 0.0174533) * uv;\n    o = smoothstep(0.5, 0.5, 1.0 - length((uv - vec2(offset, 0.0)) * vec2(thickness, 0.0)));\n    return o;\n}\n\nfloat drawCircle(vec2 position, float radius){\n    return step(radius, length(position - vec2(0.5)));\n}\n\nfloat valueNoise(vec2 uv, float scale)\n{\n    float o = 0.0;\n    vec2 gridUV = fract(uv * scale);\n    vec2 gridID = floor(uv * scale);\n    gridUV = smoothstep(0.0, 1.0, gridUV);\n\n    float bottomLeftPoint  = random2d(gridID);\n    float bottomRightPoint = random2d(gridID + vec2(1.0, 0.0));\n    float b = mix(bottomLeftPoint, bottomRightPoint, gridUV.x);\n\n    float topLeftPoint = random2d(gridID + vec2(0.0, 1.0));\n    float topRightPoint = random2d(gridID + vec2(1.0, 1.0));\n    float t = mix(topLeftPoint, topRightPoint, gridUV.x);\n\n    o = mix(b, t, gridUV.y);\n    return o;\n}\n\nfloat generateNoiseTex(vec2 uv, float scale, float minRange, float maxRange)\n{\n    float o = (\n        (valueNoise(uv, scale) / 1.0) +\n        (valueNoise(uv, scale * 2.0) / 2.0) +\n        (valueNoise(uv, scale * 4.0) / 4.0) +\n        (valueNoise(uv, scale * 6.0) / 6.0) +\n        (valueNoise(uv, scale * 8.0) / 8.0)\n    ) / 2.0;\n    o = clamp(o, 0.0, 1.0);\n    o = mix(minRange, maxRange, o);\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    //==============================================\n    vec2 texCoords = fragCoord.xy/iResolution.xy;\n    texCoords.x -= 0.2;\n    texCoords *= vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 polarUV = texCoords;\n    vec4 color = vec4(0.0, 1.0, 0.0314, 1.0);\n    //==============================================\n    \n    texCoords.y = 1.0 - texCoords.y;\n    texCoords -= 0.5;\n    polarUV = vec2(sqrt((texCoords.x * texCoords.x) + (texCoords.y * texCoords.y)), atan(texCoords.y, texCoords.x));\n    polarUV.y = fract(polarUV.y / (2.0 * PI)); //dividing y coords with 2PI to make it cover full circle\n\n    polarUV.x *= 1.0;\n    polarUV.y *= 1.0;\n\n    float x1 = polarUV.x - (0.4); //x will act as radius\n    float y1 = polarUV.y - (iTime * 0.4); //y will act as angle\n\n    x1 = fract(x1 * 17.0);\n    y1 = clamp(fract(y1 * 1.0) +(1.0 - drawCircle(texCoords + 0.5, 0.01)), 0.0, 1.0);\n\n    float coordinatesAngle = 1.0;\n\n    float x2 = polarUV.x - (0.403); //x will act as radius\n    float y2 = (1.0 - polarUV.y) - (iTime * 0.1);\n    float y21 = polarUV.y - 0.4;\n    float y22 = polarUV.y - 0.401;\n    x2 = fract(x2 * 17.0);\n    y2 = fract(y2 * 4.0);\n    y21 = fract(y21 * 80.0);\n    y22 = fract(y22 * 80.0);\n\n    float mask1 = 1.0 - drawCircle(texCoords + 0.5, 0.403);\n    float mask2 = 1.0 - drawCircle(texCoords + 0.5, 0.43);\n    float mask3 = 1.0 - drawCircle(texCoords + 0.5, 0.42);\n\n    float dx = clamp((x2 - x1) * 50.0, 0.0, 1.0);\n    float lineThicknes1 = 300.0;\n    float lineThicknes2 = 150.0;\n    float cartesianDivision = clamp(\n        (\n            (\n                drawLine(texCoords, 0.0, lineThicknes1, 0.0) +\n                drawLine(texCoords, 0.0, lineThicknes1, 45.0) +\n                drawLine(texCoords, 0.0, lineThicknes1, -45.0) +\n                drawLine(texCoords, 0.0, lineThicknes1, 90.0)\n            ) * mask1\n        ) +\n        (\n            (\n                drawLine(texCoords, 0.0, lineThicknes2, 0.0) +\n                drawLine(texCoords, 0.0, lineThicknes2, 45.0) +\n                drawLine(texCoords, 0.0, lineThicknes2, -45.0) +\n                drawLine(texCoords, 0.0, lineThicknes2, 90.0)\n            ) *(mask2 - mask1)\n        ) +\n        (\n            y2 * ( 1.0 -drawCircle(texCoords + 0.5, 0.44) - mask2)\n        )+\n        (\n            clamp((y22 - y21) * 50.0, 0.0, 1.0) * (mask3 - mask1)\n        ), \n        0.0, 1.0\n    );\n    float radarMask = pow(y1, 15.0);\n    float radarWireFrame = clamp((dx * mask1 + cartesianDivision), 0.0, 1.0);\n    vec4 radarColor = vec4(0.0, 1.0, 0.0, 0.5) * radarMask * 0.5;\n    \n    //color = mix(vec4(color.rgb, 0.1), vec4(color.rgb, 0.4), radarWireFrame);\n    color = color * 0.3;\n    color += color * radarWireFrame;\n    color += radarColor * mask1;\n\n    vec2 noiseUV = vec2(texCoords.x + 0.5, texCoords.y + 0.5 * iTime * -0.3);\n    vec4 noiseTex = vec4(vec3(color.rgb), 1.0) * clamp(generateNoiseTex(noiseUV, 20.0, -50.0, 50.0) * 0.5 * mask1, 0.0, 1.0) * (polarUV.x * 0.8);\n    noiseTex *= radarMask * mask1;\n    color += noiseTex;\n\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}