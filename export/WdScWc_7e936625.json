{"ver":"0.1","info":{"id":"WdScWc","date":"1588106369","viewed":180,"name":"Raytrace stochastic","username":"hojo","description":"Rendering of a lens by intersection/difference of 2 or 3 spheres (other models in BufferA)\n+ scattering fog\nRender engine from RIOW 1.12, thanks to reinder!\n- PageUp and PgDown change the refraction index","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["mouse","raytracer","lens","csg","stochastic","realistic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Mostly based on \"RIOW 1.12: Where next?\" by reinder. https://shadertoy.com/view/XlycWh\n//          also reinder's Primitives https://www.shadertoy.com/view/tl23Rm for mouse aim\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n//\n// Test CSG of transparent spheres (1 to 3) to form lenses\n//    use the mouse to change the view\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\n    //vec4 data = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = vec4(sqrt(data.rgb/data.w),1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Test CSG of transparent spheres (lenses), by HOJO Apr. 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n//    BUG  strange texture artefact at groud origin on checkerboard\n//    TODO add extra material for negative spheres in CSG\n//   \n// ORIGINAL RENDER SHADER : Raytracing in one weekend, chapter 12: Where next? Created by Reinder Nijhoff 2018\n// @reindernijhoff https://www.shadertoy.com/view/XlycWh\n\n// Lens definition for CSG (change me! 1=>4)\n#define CSG_TYPE 1\n\n#define MAX_RECURSION 30\n\n/// FOG info\n///\n// apply fog ?\n#define USE_FOG true\n// Henyey-Greenstein coeeficient g, >0 forward scattering dominant\nfloat HGG = 0.6;\nconst float FOG_ABSORB  = 1./200.;\nconst float FOG_SCATTER = 1./80.;\nconst float FOG_EXTINCT = FOG_ABSORB + FOG_SCATTER;\n\n//sky sphere\n#define SKY_INTENS    0.6\n#define SKY_COLOR     vec3(.8,.85,.87)\n// spherical light source\n#define LIGHTS_INTENS 20.0\n#define LIGHTS_COLOR  vec3(.9,.87,.6)\n#define LIGHTS_POS    vec3(80,40,0)\n#define LIGHTS_RAD    15\n\n///\n/// CSG Object VARIABLES\n\n// transparent material for CSG positive shapes\nfloat csgIndex = 1.5; //glass\n\n\n#if CSG_TYPE==1\n// Thin converging Lens, convex-convex, with a bonus spherical hole on edge\nconst int NBCSG = 3;\nconst float radPos  = 12.0;\nconst float radNeg  = 9.6;\nconst float hThick  = min(radPos,radNeg)*0.5*0.05; //half thickness at 5%\n\nconst int CSG_OP_RES = 6; // 2*visi_1 + 4*visi_2 => 6=INTER, 4=2\\1, 2=1\\2\nconst hitable CSGH[NBCSG]=  hitable[NBCSG](\n    hitable(vec3(-radNeg+hThick,1.7,0), radNeg),\n \thitable(vec3( radPos-hThick,1.7,0), radPos), \n\thitable(vec3( 0,3.2,1            ), 0.6) );\n\n#elif CSG_TYPE==2\n// thin lens, convergent, concave-convex\nconst int NBCSG = 2;\nconst float radMax  = 6.0;\nconst float radMin  = 4.0;\nconst float hthick  = radMin*0.05*0.5; // thickness at 5%\n\nconst int CSG_OP_RES = 2; // 2*visi_1 + 4*visi_2 => 6=INTER, 4=2\\1, 2=1\\2\nconst hitable CSGH[NBCSG]=  hitable[NBCSG](\n    hitable(vec3(-radMin+hthick+0.3,1.8,0), radMin),\n \thitable(vec3(-radMax-hthick+0.3,1.8,0), radMax)   );\n\n\n#elif CSG_TYPE==3\n// thin lens, divergent, concave-concave\nconst int NBCSG = 3;\nconst float radPos  = 7.0;\nconst float radNeg  = 6.0;\nconst float thick  = min(radPos,radNeg)*0.02; // thickness at 3%\n\nconst int CSG_OP_RES = 8; // 2*visi_1 + 4*visi_2 +8*visi_3\nconst hitable CSGH[NBCSG]=  hitable[NBCSG](\n    hitable(vec3( radPos+thick/2.,1.5,0), radPos),\n \thitable(vec3(-radNeg-thick/2.,1.5,0), radNeg),\n\thitable(vec3(0,               1.5,0), 1.5 )   );\n\n#elif CSG_TYPE==4\n// intersection of 3 spheres on equilateral triangle\nconst int NBCSG = 3;\nconst float rad = 2.5;\nconst float rr = 1.2;\nconst float phase = -PI*2.*0.11;\nconst vec3 cc=vec3(1,1,0); //center\nconst int CSG_OP_RES = 14; //  2*visi_1 + 4*visi_2 + 8*visi_3\nconst hitable CSGH[NBCSG]=  hitable[NBCSG](\n    hitable(cc+rad*vec3(cos(0.+phase),       0,sin(0.+phase)),       rr*rad),\n \thitable(cc+rad*vec3(cos(2.*PI/3.+phase), 0,sin(2.*PI/3.+phase)), rr*rad), \n\thitable(cc+rad*vec3(cos(4.*PI/3.+phase), 0,sin(4.*PI/3.+phase)), rr*rad) );\n#endif\n\n// global variable for initial state of objects used in CSG\n// bit 1 => object 1, bit 2 for object 2 (bit 0 unused)\n// will be initialized at beginning\nint csgState;\n\n    \nbool inHitable(const hitable H, const vec3 pos) {\n    return (length(pos - H.center)<H.radius);\n}\n\nvoid initCSG(const vec3 pos) {\n    // ininitialize CSG state for all hitables\n    csgState = 0;\n    for (int i=1;i<=NBCSG;++i) {\n        csgState += (1<<i) * int(inHitable(CSGH[i-1], pos));\n    }\n}\n\nbool computeCSG(const int csgState) {\n    //compute CSG status using bit 1 and bit 2 (bit 0 not used)\n    //interection : both bits must be on\n    return (csgState==CSG_OP_RES); // INTERSECTION\n}\n\n/// GUI helpers\n///\nbool adjustRefrIndex(inout float csgIndex, const float r, \n                     const float vmin, const float vmax) {\n    bool changed=false;\n    if (texelFetch( iChannel1, ivec2(KEY_PGUP,0), 0).x == 1.) {\n            csgIndex *= r;\n            if (csgIndex>vmax) { \n                csgIndex=vmax; \n            } else {\n                 changed = true;\n            }\n    }\n    if (texelFetch( iChannel1, ivec2(KEY_PGDN,0), 0).x == 1.) {\n            csgIndex /= r;\n            if (csgIndex<vmin) { \n                csgIndex=vmin; \n            } else {\n                 changed = true;\n            }\n    }\n    return changed;\n}\n\nvoid fogScatter(inout ray r, const float dist)\n{\n    vec3 ur=r.direction;\n    \n    //update origin\n    r.origin += ur*dist;\n    \n    // Henyey and Greenstein scattering\n    // ur : unit ray\n    // cosP : cos pitch angle\n    float s = 2.*hash1(g_seed);\n    float cosP = (1.+ HGG*HGG - pow((1.-HGG*HGG)/(1.+HGG*s),2.))/(2.*HGG);    \n    \n    //find a unit vector normal to ur (any direction)\n    vec3 orth;\n    if (abs(ur.z) > 0.8) {\n        orth = normalize(vec3(ur.z,0,-ur.x));\n    } else {\n        orth = normalize(vec3(ur.y,-ur.x,0));\n    }\n    //rotate orth around ur, randomly\n    float roll=hash1(g_seed)*2.*PI;\n    vec3 voo=cross(ur,orth);\n    orth=cos(roll)*orth + sin(roll)*voo; //rotated by roll\n    // then rotate ur knowing cos pitch\n    r.direction = cosP*ur + sqrt(1.-cosP*cosP)*orth;    \n}\n\nbool material_scatter(const in ray r_in, const in hit_record rec, out vec3 attenuation, \n                      out ray scattered) {\n    \n    // CSG check if useful hit or not\n    if (rec.csg > 0) {\n        //compute state at ray intersction : invert one bit for given object\n        int newCsgState = csgState ^ (1<<rec.csg);\n        //check if CSG state stayed the same\n        if (computeCSG(newCsgState) == computeCSG(csgState)) {\n            //CSG object hit, but no change of state => keep tracing\n            attenuation = vec3(1.0);\n            //advance, don't change direction\n            scattered = ray(rec.p, r_in.direction);\n            //update CSG state for traversed object\n            csgState = csgState ^ (1<<rec.csg);\n            return true;\n        }\n    }\n    \n    if(rec.mat.type == LAMBERTIAN) {\n        // cos law => equiprobable on sphere tangent to surface\n        // TBC: random inside sphere or ON sphere??\n        vec3 rd = normalize(rec.normal + random_in_unit_sphere(g_seed));\n        \n        scattered = ray(rec.p, rd);\n        if (rec.tex) {\n            //volumic checkerboard\n        \tbool inv = (fract(.5*rec.p.x)<0.5)^^(fract(.5*rec.p.y)<=0.5)\n                ^^(fract(.5*rec.p.z)<0.5) ;\n            attenuation = inv ? vec3(1.0)-rec.mat.albedo : rec.mat.albedo;\n        } else {\n            attenuation = rec.mat.albedo;\n        }\n        return true;\n    } else if(rec.mat.type == METAL) {\n        vec3 rd = reflect(r_in.direction, rec.normal);\n        scattered = ray(rec.p, normalize(rd + rec.mat.v*random_in_unit_sphere(g_seed)));\n        attenuation = rec.mat.albedo;\n        return true;\n    } else if(rec.mat.type == DIELECTRIC) {\n        //normal is supposed to be directed out of object\n        // for CSG it it not necessarily the case\n        float flipNormal=1.0;\n        if (rec.csg>0) {\n            //if the currently traversed sphere is negtive in CSG\n            //  then reverse the normal\n            if (((1<<rec.csg) & CSG_OP_RES)==0) flipNormal=-1.0;\n        }\n        vec3 fpNormal = rec.normal * flipNormal;\n        vec3 outward_normal, refracted, \n             reflected = reflect(r_in.direction, fpNormal);\n        float ni_over_nt, reflect_prob, cosine;\n        \n        attenuation = vec3(1.);\n        if (dot(r_in.direction, fpNormal) > 0.) {\n            outward_normal = -fpNormal;\n            ni_over_nt = rec.mat.v;\n            cosine = dot(r_in.direction, fpNormal);\n            cosine = sqrt(1. - rec.mat.v*rec.mat.v*(1.-cosine*cosine));\n        } else {\n            outward_normal = fpNormal;\n            ni_over_nt = 1. / rec.mat.v;\n            cosine = -dot(r_in.direction, fpNormal);\n        }\n        \n        if (modified_refract(r_in.direction, outward_normal, ni_over_nt, refracted)) {\n\t        reflect_prob = schlick(cosine, rec.mat.v);\n        } else {\n            reflect_prob = 1.;\n        }\n        \n        if (hash1(g_seed) < reflect_prob) {\n            scattered = ray(rec.p, reflected);            \n        } else {\n            scattered = ray(rec.p, refracted);\n            //change status of CSG object only when refraction\n            if (rec.csg>0) {\n                //update csg object state : invert one bit for given object\n        \t\tcsgState = csgState ^ (1<<rec.csg);\n            }\n        }\n        return true;\n    } else if(rec.mat.type == LIGHTSOURCE) {\n        //top ray tracing (no more scattering)\n        attenuation = rec.mat.albedo;\n        return false;\n    }\n    return false;\n}\n\n\nbool hitable_hit(const in hitable hb, const in ray r, const in float t_min, \n                 const in float t_max, inout hit_record rec) {\n    // always a sphere\n    vec3 oc = r.origin - hb.center;\n    float b = dot(oc, r.direction);\n    float c = dot(oc, oc) - hb.radius * hb.radius;\n    float discriminant = b * b - c;\n    if (discriminant < 0.0) return false;\n\n\tfloat s = sqrt(discriminant);\n\tfloat t1 = -b - s;\n\tfloat t2 = -b + s;\n\t\n\tfloat t = t1 < t_min ? t2 : t1;\n    if (t < t_max && t > t_min) {\n        rec.t = t;\n        rec.p = r.origin + t*r.direction;\n        rec.normal = (rec.p - hb.center) / hb.radius; // away from cter\n        rec.tex=false; //force default to overwrite previous values\n        rec.csg=0;\n\t    return true;\n    } else {\n        return false;\n    }\n}\n\ncamera camera_const(const in vec3 lookfrom, const in vec3 lookat, const in vec3 vup, \n                    const in float vfov, const in float aspect, const in float aperture, \n                    const in float focus_dist) {\n    camera cam;    \n    cam.lens_radius = aperture / 2.;\n    float theta = vfov*3.14159265359/180.;\n    float half_height = tan(theta/2.);\n    float half_width = aspect * half_height;\n    cam.origin = lookfrom;\n    cam.w = normalize(lookfrom - lookat);\n    cam.u = normalize(cross(vup, cam.w));\n    cam.v = cross(cam.w, cam.u);\n    cam.lower_left_corner = cam.origin  - half_width*focus_dist*cam.u -half_height*focus_dist*cam.v - focus_dist*cam.w;\n    cam.horizontal = 2.*half_width*focus_dist*cam.u;\n    cam.vertical = 2.*half_height*focus_dist*cam.v;\n    return cam;\n}\n    \nray camera_get_ray(camera c, vec2 uv) {\n    vec2 rd = c.lens_radius*random_in_unit_disk(g_seed);\n    // add pixel antialiasing\n    vec2 aa = (hash2(g_seed)-0.5)/iResolution.y;\n    vec3 offset = c.u * rd.x + c.v * rd.y;\n    return ray(c.origin + offset, \n            normalize(c.lower_left_corner + (uv.x+aa.x)*c.horizontal + (uv.y+aa.y)*c.vertical - c.origin - offset));\n}\n\n//\n// Color & Scene\n//\n\nbool world_hit(const in ray r, const in float t_min, \n               const in float t_max, out hit_record rec) {\n    rec.t   = t_max;\n    rec.tex = false; //no tetxure\n    rec.csg = 0; //no csg\n    bool hit = false;\n\n    // GROUND: a very large sphere, checkerboard\n    if (hitable_hit(hitable(vec3(0,-1000,-3),1000.),r,t_min,rec.t,rec)) {\n         hit=true;\n         rec.mat=material(LAMBERTIAN,vec3(0.05),0.);\n         rec.tex=true;        \n    }\n\n    // LIGHT SOURCE : large spherical light source in the sky\n    if (hitable_hit(hitable(LIGHTS_POS,float(LIGHTS_RAD)),r,t_min,rec.t,rec))\n         hit=true,rec.mat=material(LIGHTSOURCE,LIGHTS_INTENS*LIGHTS_COLOR,0.);\n\n    // SKY LIGHT SOURCE : englobing sphere (alt 800m)\n    if (hitable_hit(hitable(vec3(0,-1000,-3),1500.),r,t_min,rec.t,rec))\n         hit=true,rec.mat=material(LIGHTSOURCE,SKY_INTENS*SKY_COLOR,0.);\n    \n\t//large brown sphere lambertian\n    if (hitable_hit(hitable(vec3(-5,0.8,-0),0.8),r,t_min,rec.t,rec)) \n        hit=true,rec.mat=material(LAMBERTIAN,vec3(.4,.2,.1),0.);\n        //hit=true,rec.mat=material(METAL,vec3(0.9),0.03);\n    \n    // BOOLEAN spheres for CSG intersection => must note their numbers\n    for(int i=0;i<NBCSG;i++) {\n        if (hitable_hit(CSGH[i] ,r,t_min,rec.t, rec)) {\n            hit=true;\n            rec.mat= material(DIELECTRIC,vec3(0.1), csgIndex);;\n            rec.csg = i+1;\n        }\n    }\n\n    // small spheres R G B between lens and large brown sphere\n    if (hitable_hit(hitable(vec3(-1,0.4,-1),0.4),r,t_min,rec.t,rec)) \n        hit=true,rec.mat=material(METAL,vec3(0.5,0.5,0.96),0.01);\n    if (hitable_hit(hitable(vec3(-2.2,0.4,0.1),0.4),r,t_min,rec.t,rec)) \n        hit=true,rec.mat=material(METAL,vec3(0.97,0.95,0.95),0.);\n    if (hitable_hit(hitable(vec3(-3,0.4,1),0.4),r,t_min,rec.t,rec)) \n        hit=true,rec.mat=material(LAMBERTIAN,vec3(0,1,0),0.);\n    if (hitable_hit(hitable(vec3(-4,0.4,-1.8),0.4),r,t_min,rec.t,rec)) \n        hit=true,rec.mat=material(LAMBERTIAN,vec3(1,0,0),0.);\n    \n    \n    return hit;\n}\n\nvec3 color(in ray r) {\n    vec3 col = vec3(1);  \n\thit_record rec;\n    \n    initCSG(r.origin);\n        \n    for (int i=0; i<(MAX_RECURSION+min(0,iFrame)); i++) {\n    \tif (world_hit(r, 0.0001, MAX_FLOAT, rec)) {\n            ray scattered;\n            vec3 attenuation;\n            \n            bool toScatter = true;\n            if (USE_FOG) {                \n                // check if we hit some fog particle\n                float inst = hash1(g_seed );\n                if (inst > exp2(-rec.t * FOG_EXTINCT)) {\n                    //there is fog interaction\n                    // distance of interaction is linked to the draw\n                    float interd = -log2(inst)/FOG_EXTINCT;\n                    float inst2 = hash1(g_seed);\n                    if (inst2 < FOG_ABSORB/FOG_EXTINCT) {\n                        //ray is absorbed by fog\n                        col=vec3(0); //TBC : other color?\n                        return col;\n                    } else {\n                        //ray is scattered by fog\n                        fogScatter(r,interd);\n                        // col unchanged TBC?\n                        toScatter=false;\n                    }                        \n                }            \t\n        \t}\n            if (toScatter) {\n                if (material_scatter(r, rec, attenuation, scattered)) {               \n                    col *= attenuation;\n                    r = scattered;\n                } else {\n                    col *= attenuation; // attenuation here is LIGHTSOURCE radiance\n                    return col;\n                }\n            }\n            \n        \n\t    } else {\n            // will never hapen because of SKY sphere\n            //   pointing at infinity (sky)           \n            col *= SKY_INTENS*SKY_COLOR;\n            return col;\n    \t}\n    }\n    return vec3(0); //too many recursions without finding a light source\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//\n// Main\n//\nvoid mainImage( out vec4 frag_color, in vec2 frag_coord ) {\n  \n    bool reset = (iFrame == 0);\n    \n    //initialise mouse position\n    vec2 mo = (iMouse.xy == vec2(0)) ? vec2(.125) : \n              abs(iMouse.xy)/iResolution.xy - .5;\n    \n    //get stored data from bottom-left pixel : index, mouse position & resolution X\n    vec4 data = texelFetch(iChannel0, ivec2(0), 0);\n    if (round(mo*iResolution.xy) != round(data.yz) \n         || round(data.w) != round(iResolution.x)) {\n        reset = true;\n    }\n    csgIndex = data.x;\n    if (csgIndex<1.) { csgIndex = 1.5; } //starting value\n    \n    // modify index if PGUP or PGDOWN\n    reset = reset || adjustRefrIndex(csgIndex, 1.005, 1., 2.65);\n    \n    // camera center from mouse (mo is between -0.5 and 0.5)\n    vec3 lookfrom = vec3(1. + 4.5 *cos(6.8*mo.x), \n                         4.5+ 9.*mo.y, \n                         0.2+ 3.5*sin(6.8*mo.x));\n    vec3 lookat   = vec3(-1,0.7,0.); //origin = bottom of lens\n    \n    float fpd = data.x;\n    if(all(equal(ivec2(frag_coord), ivec2(0)))) {\n        //store refraction index & mouse & resolution\n\t\tfrag_color = vec4(csgIndex, mo*iResolution.xy, iResolution.x);\n    } else {\n        g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+iTime;\n\n        //hash2 => looks like anti-aliasing random shoot in pixel\n        vec2 uv = (frag_coord + hash2(g_seed))/iResolution.xy;\n        float aspect = iResolution.x/iResolution.y;\n        \n        float focalD = length(lookfrom-lookat);  // focalizing distance\n        const float fov    = 38.; //vertical FoV, degrees\n        const float aperture = 0.03; // aperture diameter, for DoF\n        camera cam = camera_const(lookfrom, lookat, vec3(0,1,0), fov, aspect, aperture, focalD);\n            \n        ray r = camera_get_ray(cam, uv);\n     \n        vec3 col = color(r);\n        \n        if (reset) { \n            frag_color = vec4(col,1);\t        \n        } else {        \n\t        frag_color = vec4(col,1) + texelFetch(iChannel0, ivec2(frag_coord), 0);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// ORIGINAL SOURCE SHADER : Raytracing in one weekend, chapter 12: Where next? Created by Reinder Nijhoff 2018\n// @reindernijhoff https://www.shadertoy.com/view/XlycWh\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n\n#define MAX_FLOAT 1e5\n\n#define LAMBERTIAN 0\n#define METAL 1\n#define DIELECTRIC 2\n#define LIGHTSOURCE 3\n\n#define PI 3.141592653\n\n#define KEY_PGUP 33\n#define KEY_PGDN 34\n\n//\n// Hitable, for now this is always a sphere\nstruct hitable {\n    vec3 center;\n    float radius;\n};\n\n//\n// Ray\nstruct ray {\n    vec3 origin, direction;  \n};\n\n//\n// Material\nstruct material {\n    int type;\n    vec3 albedo;\n    float v;\n};\n\n//\n// Camera\nstruct camera {\n    vec3 origin, lower_left_corner, horizontal, vertical, u, v, w;\n    float lens_radius;\n};\n    \n//\n// Hit record\nstruct hit_record {\n    float t;\n    vec3 p, normal;\n    material mat;\n    int csg; //when hit object of CSG, record its id\n    bool tex; //true for basic texture\n};\n    \n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat g_seed = 0.;\n\nfloat hash1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n\n//\n// Ray trace helper functions\n//\nfloat schlick(float cosine, float ior) {\n    float r0 = (1.-ior)/(1.+ior);\n    r0 = r0*r0;\n    return r0 + (1.-r0)*pow((1.-cosine),5.);\n}\n\nbool modified_refract(const in vec3 v, const in vec3 n, const in float ni_over_nt, \n                      out vec3 refracted) {\n    float dt = dot(v, n);\n    float discriminant = 1. - ni_over_nt*ni_over_nt*(1.-dt*dt);\n    if (discriminant > 0.) {\n        refracted = ni_over_nt*(v - n*dt) - n*sqrt(discriminant);\n        return true;\n    } else { \n        return false;\n    }\n}\n\nvec2 random_in_unit_disk(inout float seed) {\n    vec2 h = hash2(seed) * vec2(1.,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r * vec2(sin(phi),cos(phi));\n}\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\n","name":"Common","description":"","type":"common"}]}