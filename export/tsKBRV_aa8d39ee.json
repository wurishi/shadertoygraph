{"ver":"0.1","info":{"id":"tsKBRV","date":"1607884052","viewed":137,"name":"Iron Flower","username":"ptemoche","description":"Practice with metal effect, this flower is a birthday gift to EDB.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","flower","metallic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.01\n#define PI 3.1415926535\n#define AA 2\n#define eAA 0.001\n#define wAA 1.0\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nvec3 rot3D(vec3 v, float angle){\n\n\tmat3 rotMatrix = mat3(cos(angle),0.0,-sin(angle),\n\t\t\t\t\t\t  0.0       ,1.0,        0.0,\n        \t              sin(angle),0.0,cos(angle));\n                      \n\treturn rotMatrix*v;\n\n}\n\nvec2 rot2D(vec2 v, float angle){\n\n    mat2 rotMatrix = mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n    return rotMatrix*v;\n\n}\n\nfloat sd_segment(vec3 p, float L,float r){\n    \n    p.y -= min(L,max(0.0,p.y));\n    return length(p)-r;\n}\n\nfloat sd_sphere(vec3 p, vec4 s){\n    return length(p-s.xyz)-s.w;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sd_petal(vec3 p,float ang1){\n    \n    p.xy = rot2D(p.xy,ang1);\n    p.y= abs(p.y);\n    p.y-=1.2;\n    \n    \n    float nY =p.y*0.5+0.5;\n    \n    p.xz*=mix(0.5,1.25,nY);\n    p.yz = rot2D(p.yz,pow(nY,2.0)*2.0);\n    float d = sdEllipsoid(p,vec3(0.5,1.,0.1));\n    \n    \n    return d;\n}\n\nfloat sd_twopetals(vec3 p,float scale,float z,float ang){\n    p.xy = rot2D(p.xy,ang);\n    p.z+=z;\n    p/=vec3(scale);\n    float d = sd_petal(p,0.0);\n    d = smin(d,sd_petal(p,PI*0.5),0.01);\n    \n    return d;\n}\n\nfloat sd_stem(vec3 p){\n\n    p.y+=4.75;\n    float nY = abs((p.y-5.1));\n    p.z+=sin(nY)*0.5;\n    float d = sd_segment(p,5.0,0.1);\n\n    return d;\n}\n\nfloat map(vec3 pos){\n    \n    float vy = pos.y+2.0;\n    pos.z += sin(iTime*0.5)*vy*0.18;\n    \n    float d = sd_stem(pos);\n    \n    pos.yz = rot2D(pos.yz,-0.45);\n    \n    \n    d = min(d,sd_sphere(pos,vec4(0,0,0,0.4)));\n    d = max(d,-sd_sphere(pos,vec4(0.,0,0.4,0.35)));\n    float c = 0.;\n    for(float i = 0.; i<0.5;i+=0.125){\n        \n        d = min(d,sd_twopetals(pos,0.65+i*1.5,i*0.75,PI*(0.5-(0.25*c))));\n        c = mod(c+1.,2.);\n    }\n    \n    return d*0.5;\n    \n}\n\n\nfloat raymarching(vec3 o, vec3 dir){\n    \n    float d = 0.;\n    vec3 pos = vec3(0.);\n    \n    for(int i = 0; i< MAX_STEPS;++i){\n     \n        pos = o+dir*d;\n        \n        float h = map(pos);\n        \n        d+=h;\n        \n        if(d > MAX_DIST || abs(h) < MIN_DIST)\n            break;\n        \n    }\n    \n    return d;\n    \n}\n\nvec3 getNormal(vec3 pos){\n \n    vec2 e = vec2(0.001,0.);\n    float d = map(pos);\n   \tvec3 n = d-vec3(map(pos-e.xyy),map(pos-e.yxy),map(pos-e.yyx));\n    return normalize(n);\n}\n\nvec3 getSkyMap(vec3 e){\n\n\tvec2 uv = vec2(0);\n    uv.x = acos(dot(vec3(1,0,0),e))/PI;\n\n    \n    uv.y = (e.y*0.5+0.5);\n    \n    return texture(iChannel0,e).xyz;\n\n}\n\n\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l)*0.3  + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {\n    \n    //float nrm = (s + 8.0) / (3.1415 * 8.0);\n    //return pow(max(dot(reflect(l,n),e),0.0),s);// * nrm;\n    vec3 h = normalize(l+e);\n    return pow(max(dot(n,h),0.0),s);\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}  \n\nfloat calculateAttenuation(vec3 p, vec3 l){\n    float d = length(p-l);\n    return 1.0/(d*d+1.0);\n}\n\nvec3 radiance(vec3 l, vec3 n, vec3 p){\n\n    vec3  lightColor  = vec3(23.47, 21.31, 20.79);\n    vec3  wi          = l;\n    float cosTheta    = max(dot(n, wi), 0.0);\n    float attenuation = calculateAttenuation(p, l);\n    vec3  radiance    = lightColor * attenuation * cosTheta;\n    \n    return radiance;\n\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\nvec2 sphericCoord(vec3 p){\n    \n    vec2 uv = vec2(0.);\n    vec3 proy = normalize(vec3(p.x,0.0,p.z));\n    \n    uv.x = acos(dot(proy,vec3(0,0,1)));\n    if(proy.x>0.0){\n        uv.x = 2.0*PI-uv.x;\n    }\n    \n    uv.y = p.y;\n    \n    return uv;\n\n}\n\nfloat grayScale(vec3 c){\n\n    return min(c.r*0.3+c.g*0.59+c.b+0.11,1.0);\n\n}\n\nvec3 ilumination(vec3 L, vec3 N, vec3 p){\n    \n    L = normalize(L-p);\n    vec3 Nr = rot3D(N,-iTime*0.5);\n    vec3 V = normalize(vec3(0.,0.,-3.)-p);\n    vec3 H = normalize(V+L);\n    vec3 tColor = texture(iChannel2,sphericCoord(N)).rgb;\n    float gray = pow((1.0-grayScale(tColor)),0.5);\n    tColor = texture(iChannel1,sphericCoord(N)).rgb;\n    gray += grayScale(tColor)*0.15;\n    float roughness = clamp(gray,0.,1.);\n    float ao = 0.1;\n    float metallic = 0.2;\n    vec3 albedo = pow(texture(iChannel0,reflect(-V,N)).rgb,vec3(4.5));\n    vec3 F0 = vec3(0.56); \n    F0      = mix(F0, albedo, metallic);\n    vec3 F  = fresnelSchlick(max(dot(H, V), 0.0), F0);\n    float NDF = DistributionGGX(N, H, roughness);       \n    float G   = GeometrySmith(N, V, L, roughness);\n    vec3 numerator    = NDF * G * F;\n    float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n    vec3 specular     = numerator / max(denominator, 0.001); \n    \n    vec3 kS = F;\n    vec3 kD = vec3(1.0) - kS;\n  \n    kD *= 1.0 - metallic;\n    \n    vec3 radiance = radiance(L,N,p);\n    float NdotL = max(dot(N, L), 0.0);        \n    vec3 Lo = (kD * albedo / PI + specular) * radiance * NdotL;\n\n    vec3 ambient = vec3(0.03) * albedo * ao;\n    vec3 color = ambient + Lo;\n\t\n    color = color / (color + vec3(1.0));\n    color = pow(color, vec3(1.0/2.2));\n    \n    return color;\n}\n\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = pow(1.0-e.y,2.0);\n    ret.y = 1.0-e.y;\n    ret.z = 0.6+(1.0-e.y)*0.4;\n    return ret;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    float radius = 5.0;\n    float vel = 0.3;\n    float ang = 0.5;\n\tvec3 ori = vec3(radius*sin(ang),0.,radius*cos(ang));\n    vec3 center = vec3(0.);\n    \n    float zoom = 1.0;\n    vec3 f = normalize(center-ori);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ori + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 dir = i-ori;\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n\n    \n  \n    vec3 e = vec3(eAA,-eAA,0.0);\n    vec3 e2 = vec3(eAA,-eAA,0.0)*0.7071;\n    vec3 sampling[8];\n    sampling[0]=e.xzz;\n    sampling[1]=e.zyz;\n    sampling[2]=e.yzz;\n    sampling[3]=e.zxz;\n    sampling[4]=e2.xxz;\n    sampling[5]=e2.yxz;\n    sampling[6]=e2.xyz;\n    sampling[7]=e2.yyz;\n    \n    \n    for(int i = 0; i<AA;++i){\n     \n        \n        vec3 dir2 = normalize(dir+sampling[i]);\n        float d = raymarching(ori,dir2);\n        vec3 p = ori+dir2*d;\n        vec3 sky =getSkyMap(dir2);\n        vec3 c = ilumination(vec3(3,1,2),getNormal(p),p);\n        c=(d<100.)?c:sky;\n        col += c/(float(AA)+wAA);\n                \n    }\n    \n    \n    \n   \t\n    \n    col =  pow(col, vec3(.4545));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}