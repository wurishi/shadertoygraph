{"ver":"0.1","info":{"id":"dl2fRK","date":"1694536313","viewed":48,"name":"First steps with sdf","username":"marindra","description":"Задание от 5.09","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","beginner"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3  eye      = vec3 ( 0, 1., 4. );\nconst vec3  light    = vec3  ( 0.0, 3.0, 5.0 );\nconst float step = 1.;\nconst int   maxSteps = 70;\nconst float eps      = 0.01;\nconst vec4 objectColor = vec4 ( 0.2, 0., 0.6, 1. );\nconst vec4 flowerColor = vec4 ( 0.6, 0., 0.8, 1. );\nconst vec4 planeColor = vec4 ( 1., 1., 1., 1. );\nconst float pi = 3.14;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\n\nfloat length8 ( in vec2 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ), 1.0/ 8.0 );\n}\n\nfloat length8 ( in vec3 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ) + pow ( p.z, 8.0 ), 1.0/ 8.0 );\n}\n\n\n\nfloat smin ( float a, float b, float k )\n{\n    float res = exp ( -k * a ) + exp ( -k * b );\n    return -log ( res ) / k;\n}\n\nfloat smin (float a, float b, float c, float d, float k)\n{\n    float res = exp ( -k * a ) + exp ( -k * b ) + exp ( -k * c ) + exp ( -k * d );\n    return -log (res) / k;\n}\n\n\n\nfloat dPlane ( vec3 p, in vec4 n )\n{\n    return dot ( p, n.xyz ) + n.w;\n}\n\nfloat dSphere ( vec3 p, in vec3 c )\n{\n\treturn length ( p - c ) - 1.0;\n}\n\nfloat dSphere ( vec3 p, in vec3 c, in float r )\n{\n    return length ( p - c ) - r;\n}\n\nfloat dBox ( in vec3 p, in vec3 c, in vec3 halfSize )\n{\n    vec3 pt = abs ( p - c) - halfSize;\n    return length ( max ( pt, .0 ) ) + min ( max ( pt.x, max ( pt.y, pt.z ) ), .0 );\n}\n\nfloat dBox (in vec3 p, in vec3 c, in vec3 halfSize, in float r) // rounded box\n{\n    return dBox ( p, c, halfSize ) - r;\n}\n\nfloat dBox2 ( in vec3 p, in vec3 c, in vec3 halfSize, float r )\n{\n    return dBox (p, c, halfSize) - r + 0.01 * cos ( 20. * p.x + 3.*iTime );\n}\n\nfloat dTorus ( in vec3 p, in vec3 c, in vec2 size )\n{\n    vec2 q = vec2 ( length ( ( p - c ).xy ) - size.x, ( p - c ).z );\n    return length ( q ) - size.y + .1 * cos ( p.x ) ;\n}\n\nfloat dCylinder ( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba   = b  - a;\n    vec3  pa   = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x    = length(pa*baba-ba*paba) - r*baba;\n    float y   = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat dCylinder (in vec3 p, in vec3 a, in vec3 b, in float r, in float smoothRadius)\n{\n    return dCylinder ( p, a, b, r ) - smoothRadius;\n}\n\n\n\nfloat stem ( in vec3 p )\n{\n    return smin (dCylinder ( p, vec3 ( 0., 0.025, 0.025 ), vec3 ( 0., -0.05, -0.075 ), 0.025 ),\n    dCylinder ( p, vec3 ( 0., -0.0625, -0.075 ), vec3 ( 0., -0.125, -0.125 ), 0.0225 ),\n    dCylinder ( p, vec3 ( 0.025, -0.295, -0.125 ), vec3 ( 0., -0.1375, -0.125 ), 0.0225 ),\n    dCylinder ( p, vec3 ( 0.025, -0.3125, -0.125 ), vec3 ( 0., -0.625, -0.125 ), 0.025 ),\n    64.);\n}\n\nfloat petal ( in vec3 p, in vec3 c, in vec3 halfSize, in float theta)\n{\n    mat3 rotator = rotateZ (theta);\n    vec3 newP = rotator * p;\n    return smin ( dBox ( newP, c, halfSize ), dSphere ( newP, ( c + vec3 ( 0., halfSize.y * 1.5, 0. ) ), halfSize.x / 2. ), 7.8 );\n}\n\n\n\n// type = 0 - plane\n// type = 1 - flower\n// type = 2 - object\nfloat sdf ( in vec3 p, in mat3 m, out int type )\n{\n    vec3 q = m * p;\n\n    float theta = sin ( iTime / 2. ) * 2. * pi;\n    float tempR = petal ( q, vec3 ( 0., 0.15, 0.05 ), vec3 ( .0625, .075, 0.00625 ), theta );\n    for (float i = 1.; i < 6.; i += 1.)\n    {\n        tempR = min (tempR, petal ( q, vec3 ( 0., 0.15, 0.05 ), vec3 ( .0625, .075, 0.00625 ), theta + i * pi / 3. ));\n    }\n    \n    float flowerRes = min ( smin ( stem ( q ),\n    max ( dSphere ( q, vec3 ( 0., 0., 0.125 ), .125 ), dSphere ( q, vec3 ( 0., 0., -0.025 ), .125 ) ), 32. ),\n    tempR);\n    \n    vec3 newQ = rotateY(iTime / 5.) * q;\n    \n    float objRes = smin ( smin (\n    max ( dSphere ( q, vec3 ( 0., -0.1, 0. ), 0.6 ), -dSphere ( q, vec3 ( 0., -0.1, 0. ), 0.5 ) ),\n     max ( dBox2 ( newQ, vec3 ( -1.4, -0.1, 0. ), vec3 ( 0.9, 0.3, 0.3 ), 0.01 ), -dBox ( newQ, vec3 ( -1.4, -0.1, 0. ), vec3 ( 0.8, 0.2, 0.2 ) ) ),\n     max ( dBox2 ( newQ, vec3 ( 1.4, -0.1, 0. ), vec3 ( 0.9, 0.3, 0.3 ), 0.01 ), -dBox ( newQ, vec3 ( 1.4, -0.1, 0. ), vec3 ( 0.8, 0.2, 0.2 ) ) ),\n     max ( dSphere ( newQ, vec3 ( 2.8, -0.1, 0. ), 0.6 ), -dSphere ( newQ, vec3 ( 2.8, -0.1, 0. ), 0.5 ) ), 32.),\n     max ( dSphere ( newQ, vec3 ( -2.8, -0.1, 0. ), 0.6 ), -dSphere ( newQ, vec3 ( -2.8, -0.1, 0. ), 0.5 ) ), 32.);\n    \n    float objR = max ( objRes, -dPlane ( q, vec4 ( 0., -1., 0., 0.1-.45 * sin ( iTime / 3. ) ) ) );\n    float tmpR = dPlane ( q, vec4 ( 0., 1., 0., 2. ) );\n    \n    type = 0;\n    \n    if (tmpR >= objR)\n    {\n        type = 2;\n    }\n    \n    if (tmpR >= flowerRes)\n    {\n        type = 1;\n    }\n    \n    if (type == 2 && objR > flowerRes)\n    {\n        type = 1;\n    }\n    \n    if (type == 1 && objR < flowerRes)\n    {\n        type = 2;\n    }\n    \n    return min ( smin ( flowerRes, objR, 32. ), tmpR);\n}\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m, out int type )\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m, type );\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += step * dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    int type = 0;\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m, type);\n    float dx2 = sdf(z - vec3(e, 0, 0), m, type);\n    float dy1 = sdf(z + vec3(0, e, 0), m, type);\n    float dy2 = sdf(z - vec3(0, e, 0), m, type);\n    float dz1 = sdf(z + vec3(0, 0, e), m, type);\n    float dz2 = sdf(z - vec3(0, 0, e), m, type);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 0, 0, 0, 1 );\n    int type = 0;\n    vec3 p     = trace ( eye, dir, hit, m, type );\n\n\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 50.0 );\n\t\t\n        if ( type == 0 ) {\n            vec3 q = m * p;\n            color = nl * ( texture ( iChannel0, q.xz / 2. ) );\n        } else if ( type == 1 ) {\n            color = 0.4 * vec4 ( nl) + 0.2 * flowerColor + 0.4 * sp * vec4 ( 0, 1, 0, 1 );\n        } else {\n            color = 0.4 * vec4 ( nl) + 0.2 * objectColor + 0.4 * sp * vec4 ( 0, 1, 0, 1 );\n        }\n\t} \n\n    // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}