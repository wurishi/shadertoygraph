{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/* \n---------------------------------------------------------------------------------------\n\n \"Dawn of the Tentacle\" by Pablo Roman Andrioli (Kali)\n \n Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n--------------------------------------------------------------------------------------- \n*/\n\n\n//smooth version by iq\n#define smoothversion \n\n//remove if you see a flat shaded tentacle \n//(it happens to me in firefox)\n#define underwater \n\n\n// Raymarching \nconst float zoom=.95; \nconst float detail=.017;    // distance to stop tracing\nconst float maxdist=14.;    // scene depth\nconst int maxsteps=55;      // max ray steps\n\n// Light \nconst vec3 lightdir=vec3(.6,-1.,0.); \nconst float diffuse=.7;\nconst float specular=.7;\nconst float specularexp=5.;\n\n// Tentacle Shape\nconst float maxiter=28.;    // Max iterations \nconst float width=.9; \nconst float height=0.52;\nconst float scaling=0.92;\t   // Scaling factor at each iteration\nconst vec3 rotvector=vec3(1.,0.,0.); // Base vector for rotation\nconst float anglevary=.2;    // Angle variation at each iteration\n\n// Animation \nconst float amplitude=0.55;   \nconst float speed=0.6;\nconst float dynscaling=0.9; // Scaling factor for the dynamic fractal animation\n\n\n//-------------------------------------------------------------------------------------------\n\nvec3 dir;\nvec2 pix;\nvec2 coord;\n\n\n// Rotation function included in MathUtils.frag of Syntopia's Fragmentarium \nmat3 rotationMat(vec3 v, float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\n\n// Water\nfloat water(vec3 p){\n\t//p.z-=15.;\n\tfloat l=length(p.xz);\n\tp.x+=l*3.;\n\tp.x-=iTime*1.5;\n\tfloat h=(sin(p.x)+cos(p.z))*.05;\n\tp.xz*=vec2(3,2.5);\n\tp.xz+vec2(1.,2.5);\n\th+=(cos(p.x)+sin(p.z))*.05;\n\th+=texture(iChannel0,p.xz*.2).z*max(0.1,.2-l*l*.01); //texture displacement\n\treturn p.y-h;\n}\n\n\nfloat smin( float a, float b )\n{\nfloat k = 0.1; float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\nreturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n// Scene DE\nvec2 DE(vec3 pos){\n\n\tfloat angle=0.;\n\tvec3 p=pos;\n\tint n = 0;\n\tfloat sc=1.;\n\tfloat time=iTime*speed+100.;\n\tfloat amp=sin(time/2.)*amplitude;\n\tfloat dtent=1e10;\n\tfloat dd=1e10;\n\tfloat minit=maxiter;\n\tvec3 minp=pos;\n\tfor (float n=0.; n < maxiter; n++) {\n\t\tfloat d1=length(p)-width*sc; \n\t\tfloat d2=length(p+vec3(width*sc*.75,0.,0.))-width*sc*.4; \n\t\tfloat d=min(d1,d2);\n\t\tif (n<1.) dtent=d;\n\t\tif (d<=dtent) { //test min distance and save iteration & vector\n\t\t\tdtent=d;\n\t\t\tminit=n;\n\t\t\tminp=p;\n\t\t}\n\t\t#ifdef smoothversion\n\t\tdd=smin(dd,d);\n\t\t#endif\n\t\t\n\t\tp*=rotationMat(normalize(rotvector+vec3(0.,sin(iTime)*.7,0.)),sin(time)*amp+angle);\n\t\tp.y-=height*sc; // go up\n\t\tsc*=scaling; // scale size\n\t//\tamp*=dynscaling; // scale amplitude\n\t\ttime/=dynscaling; // scale time\n\t\tangle+=radians(anglevary); // vary rotation\n\t}\n\t\t#ifdef smoothversion\n\t\tdtent=dd;\n\t\t#endif\t\n\t\n\tdtent+=length(texture(iChannel1,vec2(minp.y*2.,atan(minp.x,minp.z)*.8)).xyz)*.025;\n\t\n\tfloat dwat=water(pos);\n\tfloat de=min(dwat,dtent);\n\tfloat col=0.;\n\tif (de!=dwat) col=minit+1.; // return coloring parameter\n\treturn vec2(de,col);\n}\n\n\n// finite difference normal\nvec3 normal(vec3 pos) {\n\tvec3 e = vec3(0.0,detail,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tDE(pos+e.yxx).x-DE(pos-e.yxx).x,\n\t\t\tDE(pos+e.xyx).x-DE(pos-e.xyx).x,\n\t\t\tDE(pos+e.xxy).x-DE(pos-e.xxy).x\n\t\t\t)\n\t\t);\t\n}\n\n// coloring\nvec3 color(float obj, vec3 p) {\n\n\tif (obj<1.) { //water\n\t\tvec3 tex=texture(iChannel0,p.xz*.1).xyz;\n\t\treturn (tex+.2)*vec3(1.7,1.2,1.2);\n\t} \n\telse if (obj>0.) {//tentacle\n\t\tfloat g=(maxiter-obj)/maxiter;\n\t\treturn vec3(.9,g+.2,0.6);\n\t}\n\t\n}\n\n//lighting\nvec3 light(vec3 p) {\nvec3 ldir=normalize(lightdir);\nvec3 n=normal(p);\nfloat diff=max(0.0,dot(-n, ldir))*diffuse;\nvec3 r = reflect(ldir,n);\nfloat spec=max(0.,dot(dir,-r));\nreturn vec3(1.,.8,.5)*(diff+pow(spec,specularexp)*specular);\t\n}\n\n//raymarching\nvec3 raymarch(vec3 from, vec3 dir) {\n\tvec3 p,p2;\n\tfloat totdist=0., totdist2=0.;\n\tvec3 col;\n\tvec2 d=vec2(0.);\n\tfloat d2=100000.;\n\t//march\n\tfor (int i=1; i<maxsteps; i++) {\n\t\tp=from+totdist*dir;\n\t\td=DE(p);\n\t\tif (d.x<detail || totdist>maxdist) break;\n\t\t#ifdef smoothversion\n\t\t\ttotdist+=max(.1,d.x); \n\t\t#else\n\t\t\ttotdist+=max(.01,d.x); \n\t\t#endif\n\t}\n\n\t//underwater\n\tif (d.x<detail && d.y<.5) {\n\t\ttotdist2=totdist+detail*3.;\n\t\tfor (int i=1; i<maxsteps; i++) {\n\t\t\tp2=from+totdist2*dir;\n\t\t\td2=length(p2.xz)-width/scaling+p2.y*.2;\n\t\t\tif (d2<detail || totdist2>maxdist) break;\n\t\t\ttotdist2+=d2; \n\t\t}\n\t}\n\t\n\t\n\tvec3 back=mix(vec3(1.3,.95,.7),vec3(.52,.5,.56) //background gradient\n\t*1.25,clamp((dir.y+.13)*2.5,0.,1.35)); \n\tback+=vec3(1.,1.,.5)*(.04+dot(lightdir,-dir)*.4); //dawn\n\t\n\tif (d.x<detail) {\n\t\tcol=color(d.y,p)*light(p-detail*dir*.5); //apply color+light\n\t\tcol=mix(col,back,smoothstep(0.,2.2,totdist*.17)); //fog\n\t} else { //background-sky \n\t\tcol=back+.85*vec3(1.,.85,.7)*texture(iChannel1,\n\t\tvec2(dir.y*4.+.5,atan(dir.z,dir.x)*1.8)*.15+vec2(iTime*.002)).b*(dir.y*.75+.15)\n\t\t*vec3(max(0.1,.5-coord.y*2.5))*1.4;\n\t\tcol-=vec3(max(0.,coord.y*.3));\n\t}\n\t#ifdef underwater\n\tif (d2<detail) {\n\t\tvec3 col2=color(1.1,p2)*light(p+p2-detail*dir*.5); \n\t\tcol=mix(col,col2,.3); //underwater\n\t}\n\t#endif\n\t\n\tcol+=vec3(1.,.7,.5)*max(0.,9.-totdist)*.04; //camlight\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//Camera\n\tpix=fragCoord.xy / iResolution.xy;\n\tfloat viewangle=-135.+(iMouse.x/iResolution.x)*100.; \n\tmat3 rotview=rotationMat(vec3(0.,1.,0.),radians(viewangle));\n\tcoord = pix-vec2(.5);\n\tcoord.y*=iResolution.y/iResolution.x;\n\tvec3 from=vec3(0.,2.85,8.)*rotview*zoom;\n\tdir=normalize(vec3(coord*1.8,-1.))*rotview;\n\t\n\t//Draw scene\n\tvec3 col=vec3(0.);\n\tcol=raymarch(from,dir); \n\t\n\t//adjust levels\n\tcol*=pow(length(col),1.8)*.41; \n\tcol+=vec3(0.02,-.01,0.05);\n\tcol=mix(col,vec3(length(col))*.6,.3);\n\t\n\tfragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xtf3Rj","date":"1423183475","viewed":926,"name":"Dawn of the Tentacle","username":"Kali","description":"Mouse enabled.","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefield"],"hasliked":0,"parentid":"","parentname":""}}