{"ver":"0.1","info":{"id":"ctSGWm","date":"1675272377","viewed":1633,"name":"Ã€trous Wavelet Denoising","username":"Mathis","description":"Denoising shadows and reflections using two modified Ã€trous wavelet filters with temporal accumulation + TAA.\nNon-occluded diffuse indirect light is used and normals are calculated in screen space.\n\nUse the mouse to move the camera!","likes":86,"published":1,"flags":32,"usePreview":1,"tags":["ray","global","illumination","tracing","wavelet","denoising","trous"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nSome notes:\n    TAA\n        Uses catmull-rom for moving pixels -> produces blur for moving pixels\n        The city is not actual rendered geometry, so the reprojection is incorrect -> ghosting\n    Since normals are not computed from the geometry, lighting and shadows are simplified inside reflections\n    Anistropic surfaces are over-denoised/blurred -> can be reduced by projecting samples on the normal plane\n    Screen space normals results in false smooth edges and \"noisy\" normals\n        A possible improvement is to search in the whole 3x3 box around the pixel\n        More expensive + Tan and Bit can be parallel\n    EPIC CAMERA ANIMATIONS\n*/\n\nvec4 textureCube(vec2 UV) {\n    //Samples the cubemap\n    float Sign = -mod(floor(UV.y*I1024),2.)*2.+1.;\n    vec3 D = vec3(vec2(UV.x,mod(UV.y,1024.))*I512-1.,Sign);\n    if (UV.y>4096.) D = D.xzy;\n    else if (UV.y>2048.) D = D.zxy;\n    return texture(iChannel3,D);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float YOffset = floor(fragCoord.x*I1024)*1024.+floor(fragCoord.y*I1024)*3072.;\n    vec3 Color = textureCube(mod(fragCoord,1024.)+vec2(0.,YOffset)).xyz;\n        \n        \n        //DEBUG (if you find it interesting)\n        //Color = vec3(texture(iChannel2,fragCoord*IRES).w*0.1);\n        //Color = FloatToVec3(texture(iChannel2,fragCoord*IRES).w); //Normals\n            //Color = FloatToVec3(texture(iChannel0,fragCoord*IRES).z)*ReflConst; //Raw reflections\n                //Color = texture(iChannel0,fragCoord*IRES).www; //Raw shadows\n            //Color = texture(iChannel2,fragCoord*IRES).zzz; //Denoised shadows (B)\n                //Color = FloatToVec3(texture(iChannel1,fragCoord*IRES).y)*ReflConst; //Denoised reflections (B)\n        //vec2 sc = texture(iChannel2,fragCoord*IRES).xy;\n        //Color = vec3(FloatToVec2(sc.x)*ReflConst,sc.y); //Buffer C Reflection light\n        \n        \n    fragColor = vec4(pow(1.-exp(-1.2*Color),vec3(0.45)),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Constants\nconst float FOV = radians((65.)/2.);\nconst float ReflConst = 3.;\nconst float IReflConst = 1./ReflConst;\nconst vec3 SunLight = vec3(2.6,2.,1.);\nconst vec3 SunDir = normalize(vec3(1.,0.7,-0.3));\nconst float SunCR = 0.1;\nconst float PI = 3.14159265;\nconst float PI2 = PI*2.;\nconst float HPI = PI*0.5;\nconst float IPI = 1./PI;\nconst float ToRadians = PI/180.;\nconst float I3 = 1./3.;\nconst float I16 = 1./16.;\nconst float I26 = 1./26.;\nconst float I32 = 1./32.;\nconst float I64 = 1./64.;\nconst float I128 = 1./128.;\nconst float I255 = 1./255.;\nconst float I256 = 1./256.;\nconst float I300 = 1./300.;\nconst float I512 = 1./512.;\nconst float I1024 = 1./1024.;\nconst float I2048 = 1./2048.;\nconst float Sqrt2 = sqrt(2.);\nconst float ISqrt2 = sqrt(0.5);\nconst float Sqrt3 = sqrt(3.);\nconst float ISqrt3 = 1./sqrt(3.);\nconst vec2 eps = vec2(0.,0.001);\nconst float CFOV = tan(FOV);\nconst vec2 SSOffsets8[8] = vec2[8](vec2(0.,0.2),vec2(0.,-0.2),vec2(0.2,0.),vec2(-0.2,0.),\n                                  vec2(0.4),vec2(-0.4),vec2(-0.4,0.4),vec2(0.4,-0.4));\nconst vec2 SSOffsets[16] = vec2[16](vec2(0.),vec2(-0.4,-0.4),vec2(0.,0.2),vec2(0.15,-0.4),vec2(-0.4,-0.15),\n                                    vec2(0.15,0.4),vec2(-0.2,-0.2),vec2(-0.4,0.4),vec2(0.4,0.15),vec2(0.2,-0.2),\n                                    vec2(0.4,0.4),vec2(-0.4,0.15),vec2(0.4,-0.15),\n                                    vec2(-0.15,0.4),vec2(0.4,-0.4),vec2(-0.15,-0.4));\n//Defines\n#define RES iChannelResolution[0].xy\n#define IRES 1./iChannelResolution[0].xy\n#define ASPECT vec2(iChannelResolution[0].x/iChannelResolution[0].y,1.)\n\nstruct HIT { float D; vec3 DC; float M; float Specular; float Metal; };\n\n//SDF\nfloat DFBox(vec3 p, vec3 b) {\n    vec3 d = abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat DFBox(vec2 p, vec2 b) {\n    vec2 d = abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat DFBoxC2(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat DFExtrude(vec3 p, float sdf, float h) {\n    //By IQ: https://www.shadertoy.com/view/4lyfzw\n    vec2 w = vec2(sdf,abs(p.z)-h);\n  \treturn min(max(w.x,w.y),0.)+length(max(w,0.));\n}\n\nfloat DFDisk(vec3 p) {\n    float d = length(p.xz-0.5)-0.35;\n    vec2 w = vec2(d,abs(p.y));\n    return min(max(w.x,w.y),0.)+length(max(w,0.));\n}\n\nfloat DFLine(vec3 p, vec3 a, vec3 b) {\n    vec3 ba = b-a;\n    float k = dot(p-a,ba)/dot(ba,ba);\n    return length((a+clamp(k,0.,1.)*(b-a))-p);\n}\n\nvec2 Rotate(vec2 p, float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c-p.y*s,p.x*s+p.y*c);\n}\n\nvec2 Repeat(vec2 p, float n) {\n    float ang = 2.*3.14159/n;\n    float sector = floor(atan(p.x,p.y)/ang+0.5);\n    p = Rotate(p,sector*ang);\n    return p;\n}\n\nfloat smin(float a, float b, float k) {\n    //https://iquilezles.org/articles/smin\n    float h = max(k-abs(a-b),0.)/k;\n    return min(a,b)-h*h*h*k*(1.0/6.0);\n}\n\n//Analytic\nfloat SolidAngle(vec3 P, vec3 N, vec3 p0, vec3 p1, vec3 p2) {\n    //Returns the solid angle for a visible triangle\n    vec3 v0=normalize(p0-P);\n    vec3 v1=normalize(p1-P);\n    vec3 v2=normalize(p2-P);\n    float ret=abs(dot(N,normalize(cross(v0,v1)))*acos(dot(v0,v1))+\n                dot(N,normalize(cross(v1,v2)))*acos(dot(v1,v2))+\n                dot(N,normalize(cross(v2,v0)))*acos(dot(v2,v0)));\n    return ((isnan(ret))?0.:ret);\n}\n\nvec3 ARand23(vec2 uv) {\n    //Analytic random\n    return fract(sin(uv.x*uv.y)*vec3(403.125,486.125,513.432)+cos(dot(uv,vec2(13.18273,51.2134)))*vec3(173.137,261.23,203.127));\n}\n\nfloat ARand21(vec2 uv) {\n    //Analytic random\n    return fract(sin(uv.x*uv.y)*403.125+cos(dot(uv,vec2(13.18273,51.2134)))*173.137);\n}\n\nmat3 TBN(vec3 N) {\n    vec3 Nb,Nt;\n    if (abs(N.y)>0.999) {\n        Nb = vec3(1.,0.,0.);\n        Nt = vec3(0.,0.,1.);\n    } else {\n    \tNb = normalize(cross(N,vec3(0.,1.,0.)));\n    \tNt = normalize(cross(Nb,N));\n    }\n    return mat3(Nb.x,Nt.x,N.x,Nb.y,Nt.y,N.y,Nb.z,Nt.z,N.z);\n}\n\nvec3 TBN(vec3 N, out vec3 O) {\n    O = ((abs(N.y)>0.999)?vec3(1.,0.,0.):normalize(cross(N,vec3(0.,1.,0.))));\n    return normalize(cross(O,N));\n}\n\nfloat boxfar(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t2 = max(tMin,tMax);\n    return min(min(t2.x,t2.y),t2.z);\n}\n\nfloat boxfar(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax) {\n    vec2 tMin = (bmin-origin)*dir;\n    vec2 tMax = (bmax-origin)*dir;\n    vec2 t2 = max(tMin,tMax);\n    return min(t2.x,t2.y);\n}\n\nvec2 box(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t1 = min(tMin,tMax);\n    vec3 t2 = max(tMin,tMax);\n    return vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));\n}\n\nvec2 box(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax) {\n    vec2 tMin = (bmin-origin)*dir;\n    vec2 tMax = (bmax-origin)*dir;\n    vec2 t1 = min(tMin,tMax);\n    vec2 t2 = max(tMin,tMax);\n    return vec2(max(t1.x,t1.y),min(t2.x,t2.y));\n}\n\nvec3 boxNormal(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax, out vec2 bb) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t1 = min(tMin,tMax);\n    vec3 t2 = max(tMin,tMax);\n    bb = vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));\n    vec3 signdir = -max(vec3(0.),sign(dir))*2.+1.;\n    if (t1.x>max(t1.y,t1.z)) return vec3(signdir.x,0.,0.);\n    else if (t1.y>t1.z) return vec3(0.,signdir.y,0.);\n    else return vec3(0.,0.,signdir.z);\n}\n\nvec3 RandSampleCos(vec2 v) {\n    float theta = sqrt(v.x);\n    float phi = 2.*3.14159*v.y;\n    float x = theta*cos(phi);\n    float z = theta*sin(phi);\n    return vec3(x,z,sqrt(max(0.,1.-v.x)));\n}\n\nvec3 RandSampleCosXYer(vec2 v) {\n    float theta = sqrt(v.x);\n    float phi = 2.*3.14159*v.y;\n    float x = theta*cos(phi);\n    float z = theta*sin(phi);\n    return vec3(x,z,0.);\n}\n\nvec3 SchlickFresnel(vec3 r0, float angle) {\n    //Schlick Fresnel approximation\n    return r0+(1.-r0)*pow(1.-angle,5.);\n}\n\nvec3 SampleWindow(vec3 p, vec3 d, float M) {\n    //Samples the window\n    if (M>3.5) {\n        //Render city\n        float YCoeff = pow(1.-max(0.,d.y),8.);\n        vec3 L = mix(vec3(0.025,0.13,0.17)*YCoeff+vec3(0.3,0.05,0.02)*YCoeff*YCoeff,SunLight,pow(max(0.,dot(d,SunDir)),24.));\n        L *= float(d.y>0.);\n        //City\n        float R = 500.;\n        float BWidth = 40.;\n        float BHeight = 30.;\n        for (int i=0; i<4; i++) {\n            float A = dot(p.xz,p.xz)-R*R;\n            float B = 2.*dot(p.xz,d.xz);\n            float C = dot(d.xz,d.xz);\n            float cP = B/C;\n            float cQ = A/C;\n            float det = cP*cP*0.25-cQ;\n            float t1 = -cP*0.5+sqrt(det);\n            vec3 sp = p+d*t1;\n            float xcoord = atan(sp.x-2.,sp.z-2.)*R+20.;\n            vec3 RandV = ARand23(vec2(floor(xcoord/BWidth)+0.5));\n            if ((t1<L.x || L.y>=0.) &&\n                mod(xcoord,BWidth)-BWidth*0.5<floor(BWidth*(0.2+0.2*RandV.x)*0.5)*2. &&\n                sp.y<floor((-50.+BHeight*(0.5+0.5*RandV.y))*0.5)*2.) {\n                L = vec3(2.6/max(1.,1.+R*0.02)*float(DFBox(mod(vec2(xcoord,sp.y),vec2(2.))-vec2(0.4,0.5),vec2(1.2,1.2))<0.\n                         && ARand21(vec2(floor(xcoord*0.5),floor(sp.y*0.5))*0.25)<0.4));\n            }\n            R *= 0.5;\n            BHeight *= 1.4;\n        }\n        return L;\n    } else return SunLight;\n}\n\n//Float-Vec conversion\nvec3 FloatToVec3(float v) {\n    float x = fract(v);\n    float z = floor(v*I300);\n    float y = floor(v-z*300.)*I300;\n    return vec3(x,y,z*I300);\n}\n\nfloat Vec3ToFloat(vec3 v) {\n    v = min(v,vec3(0.998));\n    return v.x+floor(v.y*300.)+floor(v.z*300.)*300.;\n}\n\nvec2 FloatToVec2(float v) {\n    return vec2(fract(v),floor(v)*I2048);\n}\n\nfloat Vec2ToFloat(vec2 v) {\n    v = min(v,vec2(0.999));\n    return v.x+floor(v.y*2048.);\n}\n\n//Camera\nconst int NVecs = 11;\nvec3 Positions[NVecs] = vec3[NVecs](vec3(-1.5,3.5,-1.5),\n                            vec3(-1.5,0.5,-1.5),vec3(-1.5,0.5,-1.5),vec3(-1.5,0.5,-1.5), //Low position\n                            vec3(1.99,2.3,3.7),vec3(1.99,2.3,3.7), //Near door\n                            vec3(3.2,2.8,2.2),vec3(3.2,2.8,2.2), //Look out from window\n                            vec3(3.4,2.3,-2.5),vec3(3.4,2.3,-2.5), //Beside the window\n                            vec3(-1.5,3.5,-1.5)\n                            );\nvec3 Centers[NVecs] = vec3[NVecs](vec3(2.,1.,2.),\n                          vec3(2.,0.3,2.),vec3(2.,0.3,2.),vec3(2.,1.2,4.),\n                          vec3(3.,0.5,1.),vec3(4.,2.2,2.3),\n                          vec3(20.,-1.,2.),vec3(20.,-1.,2.),\n                          vec3(2.,1.5,2.),vec3(2.,1.5,2.),\n                          vec3(2.,1.,2.)\n                          );\nvec3 CameraCenter(vec4 Mouse, float t) {\n    if (Mouse.z>0.) {\n        return vec3(2.,1.,2.);\n    } else {\n        //Epic animation\n        float Time = t*(1.-exp(-t*0.125));\n        float TPeriod = 1.;\n        float ITPeriod = 1./TPeriod;\n        int PIndex = min(int(floor(Time*ITPeriod)),NVecs-1);\n        float fx = fract(Time*ITPeriod);\n        return mix(Centers[PIndex],Centers[(PIndex+1)%NVecs],fx*fx*(3.-2.*fx));\n    }\n}\n\nvec3 Position(vec4 Mouse, float t, vec2 ires) {\n    vec2 Angles = vec2(2.8,0.01)+Mouse.xy*ires*vec2(2.3,1.2);\n    if (Mouse.z>0.) {\n        return vec3(2.,2.,2.)+vec3(vec2(sin(Angles.x),cos(Angles.x))*cos(Angles.y),sin(Angles.y)).xzy*8.*(0.125*5.);\n    } else {\n        //Epic animation\n        float Time = t*(1.-exp(-t*0.125));\n        float TPeriod = 1.;\n        float ITPeriod = 1./TPeriod;\n        int PIndex = min(int(floor(Time*ITPeriod)),NVecs-1);\n        float fx = fract(Time*ITPeriod);\n        return mix(Positions[PIndex],Positions[(PIndex+1)%NVecs],fx*fx*(3.-2.*fx));\n    }\n}\n\n//SDF\nvoid Trace_WindowFrame(vec3 P, vec3 D, inout HIT OUT) {\n    float dft = 0.; float tmpt,aplen; vec3 ap,rp;\n    for (int i=0; i<128; i++) {\n        //SDF\n        ap = P+D*dft;\n        ap.yz = abs(ap.yz); //Symmetry\n        //Base pillars (idk)\n        tmpt = max(DFBox(ap-vec3(-0.1,0.,-0.1),vec3(0.1,1.9,0.2)),-length(ap.xz-vec2(-0.125,0.1))+0.075);\n        tmpt = min(tmpt,max(DFBox(ap-vec3(-0.1,-0.1,0.),vec3(0.1,0.2,1.9)),-length(ap.xy-vec2(-0.125,0.1))+0.075));\n        //Small pillar\n        rp = vec3(ap.x,Rotate(ap.yz,0.78539816339));\n        tmpt = min(tmpt,max(max(DFBox(rp-vec3(-0.1,-0.1,1.),vec3(0.1,0.2,0.9)),-length(rp.xy-vec2(-0.125,0.1))+0.075),\n                    -length(rp.xy-vec2(-0.125,-0.1))+0.075));\n        //Donuts\n        aplen = length(ap.yz);\n        tmpt = min(tmpt,max(max(length(vec2(ap.x,aplen-1.))-0.1,-length(vec2(ap.x+0.125,aplen-1.1))+0.075),\n                   -length(vec2(ap.x+0.125,aplen-0.9))+0.075));\n        tmpt = min(tmpt,max(max(length(vec2(ap.x,aplen-1.9))-0.1,-length(vec2(ap.x+0.125,aplen-2.))+0.075),\n                   -length(vec2(ap.x+0.125,aplen-1.8))+0.075));\n        //Check intersection\n        dft += tmpt;\n        if (dft>OUT.D) break;\n        if (tmpt<0.001) {\n            OUT = HIT(dft,vec3(0.5,0.2,0.1),0.2,0.25,0.95);\n            break;\n        }\n    }\n}\n\nvoid Trace_MetalCylinders(vec3 P, vec3 D, inout HIT OUT) {\n    //First vertical cylinder\n    vec3 RP = P-vec3(3.5,0.,0.);\n    float A = dot(RP.xz,RP.xz)-0.0289; //R = 0.17\n    float B = 2.*dot(RP.xz,D.xz);\n    float C = dot(D.xz,D.xz);\n    float cP = B/C;\n    float cQ = A/C;\n    float det = cP*cP*0.25-cQ;\n    if (det>=0.) {\n        //Valid intersection\n        det = sqrt(det);\n        float t0 = -cP*0.5-det;\n        float t1 = -cP*0.5+det;\n        vec3 sp = P+D*t0;\n        if (t0>0. && t0<OUT.D && sp.y<3.4) {\n            OUT = HIT(t0,vec3(1.),0.025,1.,1.);\n        }\n    }\n    //Bent cylinder\n    float dft = 0.; float tmpt,aplen; vec3 ap,rp;\n    for (int i=0; i<128; i++) {\n        //SDF\n        ap = P+D*dft;\n        aplen = length(ap.xy-vec2(3.1,3.4));\n        tmpt = max(max(length(vec2(ap.z,aplen-0.4))-0.17,-ap.y+3.4),-ap.x+3.1);\n        aplen = length(ap.xz-vec2(1.5,0.4));\n        tmpt = min(tmpt,max(max(length(vec2(ap.y-3.8,aplen-0.4))-0.17,ap.x-1.5),-ap.z-0.25));\n        //Check intersection\n        dft += tmpt;\n        if (dft>OUT.D) break;\n        if (tmpt<0.001) {\n            OUT = HIT(dft,vec3(1.),0.025,1.,1.);\n            break;\n        }\n    }\n    //Horisontal cylinder\n    RP = P-vec3(3.5,3.8,0.);\n    A = dot(RP.yz,RP.yz)-0.0289; //R = 0.18\n    B = 2.*dot(RP.yz,D.yz);\n    C = dot(D.yz,D.yz);\n    cP = B/C;\n    cQ = A/C;\n    det = cP*cP*0.25-cQ;\n    if (det>=0.) {\n        //Valid intersection\n        det = sqrt(det);\n        float t0 = -cP*0.5-det;\n        float t1 = -cP*0.5+det;\n        vec3 sp = P+D*t0;\n        if (t0>0. && t0<OUT.D && sp.x<=3.11 && sp.x>=1.5) {\n            OUT = HIT(t0,vec3(1.),0.025,1.,1.);\n        }\n    }\n}\n\nvoid Trace_RoundBox(vec3 P, vec3 D, vec3 Size, float R, inout HIT OUT) {\n    float dft = 0.; float tmpt;\n    for (int i=0; i<128; i++) {\n        //SDF\n        tmpt = DFBox(P+D*dft,Size)-R;\n        //Check intersection\n        dft += tmpt;\n        if (dft>OUT.D) break;\n        if (tmpt<0.001) {\n            OUT = HIT(dft,vec3(0.47,0.35,0.25),0.3,0.05,0.6);\n            break;\n        }\n    }\n}\n\nvoid Trace_Cylinder0(vec3 P, vec3 D, inout HIT OUT) {\n    float A = dot(P.xz,P.xz)-0.04;\n    float B = 2.*dot(P.xz,D.xz);\n    float C = dot(D.xz,D.xz);\n    float cP = B/C;\n    float cQ = A/C;\n    float det = cP*cP*0.25-cQ;\n    if (det>=0.) {\n        //Valid intersection\n        det = sqrt(det);\n        float t0 = -cP*0.5-det;\n        float t1 = -cP*0.5+det;\n        vec3 sp = P+D*t0;\n        if (t0>0. && t0<OUT.D && abs(sp.y-(0.05+(sin(atan(sp.x,sp.z)*4.+0.1)*0.5+0.5)*0.05))<0.1) {\n            OUT = HIT(t0,vec3(1.),0.,0.25,0.);\n        } else if (t1>0.) {\n            sp = P+D*t1;\n            if (t1<OUT.D && abs(sp.y-(0.05+(sin(atan(sp.x,sp.z)*4.+0.1)*0.5+0.5)*0.05))<0.1) {\n                OUT = HIT(t1,vec3(1.),0.,0.25,0.);\n            }\n        }\n    }\n}\n\nvoid Trace_Door(vec3 P, vec3 D, inout HIT OUT) {\n    //Wood door\n    float dft = 0.; float tmpt; vec3 sp;\n    for (int i=0; i<128; i++) {\n        //SDF\n        sp = P+D*dft;\n        tmpt = DFBox(sp-vec3(0.01),vec3(0.88,2.08,0.03))-0.01;\n        //Higher carving\n        tmpt = min(max(tmpt,-DFBox(sp-vec3(0.2,1.1,-0.01),vec3(0.5,0.8,0.))+0.05),\n                   DFBox(sp-vec3(0.3,1.2,0.04),vec3(0.3,0.6,0.))-0.01);\n        tmpt = min(max(tmpt,-DFBox(sp-vec3(0.2,0.15,-0.01),vec3(0.5,0.6,0.))+0.05),\n                   DFBox(sp-vec3(0.3,0.25,0.04),vec3(0.3,0.4,0.))-0.01);\n        //Check intersection\n        dft += tmpt;\n        if (dft>OUT.D) break;\n        if (tmpt<0.001) {\n            OUT = HIT(dft,vec3(0.9),0.2,0.1,0.3);\n            break;\n        }\n    }\n    //Handle\n    dft = 0.;\n    for (int i=0; i<128; i++) {\n        //SDF\n        tmpt = DFLine(P+D*dft,vec3(0.88,0.9,-0.04),vec3(0.78,0.9,-0.04))-0.02;\n        tmpt = min(tmpt,DFLine(P+D*dft,vec3(0.88,0.9,-0.04),vec3(0.88,0.9,0.))-0.02);\n        //Check intersection\n        dft += tmpt;\n        if (dft>OUT.D) break;\n        if (tmpt<0.001) {\n            OUT = HIT(dft,vec3(0.9,0.7,0.2),0.03,0.8,0.9);\n            break;\n        }\n    }\n}\n\nvoid Trace_DoorFrame(vec3 P, vec3 D, inout HIT OUT) {\n    //Wood door\n    float dft = 0.; float tmpt; vec3 sp;\n    for (int i=0; i<128; i++) {\n        //SDF\n        sp = P+D*dft;\n        tmpt = max(DFBox(sp-vec3(-0.15,0.,-0.08),vec3(0.15,2.25,0.08)),\n                   -DFLine(sp,vec3(-0.15,0.,-0.12),vec3(-0.15,2.25,-0.12))+0.1);\n        tmpt = min(tmpt,max(DFBox(sp-vec3(0.9,0.,-0.08),vec3(0.15,2.25,0.08)),\n                   -DFLine(sp,vec3(1.05,0.,-0.12),vec3(1.05,2.25,-0.12))+0.1));\n        tmpt = max(min(tmpt,DFBox(sp-vec3(0.,2.1,-0.08),vec3(0.9,0.15,0.08))),\n                   -DFLine(sp,vec3(-0.15,2.25,-0.12),vec3(1.05,2.25,-0.12))+0.1);\n        //Check intersection\n        dft += tmpt;\n        if (dft>OUT.D) break;\n        if (tmpt<0.001) {\n            OUT = HIT(dft,vec3(0.2,0.1,0.04),0.2,0.1,0.5);\n            break;\n        }\n    }\n}\n\nvoid Trace_Sphere(vec3 P, vec3 D, inout HIT OUT) {\n    //Wood door\n    float dft = 0.; float tmpt;\n    for (int i=0; i<128; i++) {\n        //SDF\n        tmpt = length(P+D*dft-vec3(3.1,0.5,1.))-0.5;\n        //Check intersection\n        dft += tmpt;\n        if (dft>OUT.D) break;\n        if (tmpt<0.001) {\n            OUT = HIT(dft,vec3(1.),0.04,1.,1.);\n            break;\n        }\n    }\n}\n\n//Trace function\nHIT Trace(vec3 P, vec3 D, float Time) {\n    HIT OUT = HIT(1000000000.,vec3(1.),-1.,-1.,-1.);\n    vec3 ID = 1./D;\n    //Ground and floor\n    if (D.y<0.) {\n        float GDist = -(P.y+0.1)/D.y;\n        OUT = HIT(GDist,vec3(0.2),0.15,0.6,1.);\n    }\n    vec2 bb = box(P,ID,vec3(0.,-0.1,0.),vec3(4.,0.,4.)); //Floor\n    if (bb.x>0. && bb.y>bb.x && bb.x<OUT.D) OUT = HIT(bb.x,vec3(0.2,0.1,0.04),0.2,0.1,0.1);\n    \n    //X-Normal wall\n    vec2 bb2 = box(P,ID,vec3(3.5,-0.1,0.),vec3(4.1,4.,4.));\n    if (bb2.x>0. && bb2.y>bb2.x && bb2.x<OUT.D || DFBox(P-vec3(3.5,-0.1,0.),vec3(0.6,4.1,4.))<=0.) {\n        //Wall\n        bb = box(P,ID,vec3(4.,-0.1,0.),vec3(4.1,4.,4.));\n        if (bb.x>0. && bb.y>bb.x && bb.x<OUT.D) {\n            OUT = HIT(bb.x,vec3(1.),0.1,0.75,0.05);\n            //Emissive circle\n            float CLen = length(P.zy+D.zy*bb.x-2.);\n            float CX = atan(P.z+D.z*bb.x-2.,P.y+D.y*bb.x-2.);\n            if (CLen<1.9 && P.x+D.x*bb.x<4.05) {\n                OUT.M = 3.;\n                //Broken windows\n                if ((CX>0. && CX<1.5707963 && CLen<0.9) ||\n                    (CX>2.35619449 && CLen>0.9)) OUT.M = 4.5;\n            }\n        }\n        //Window frame\n        Trace_WindowFrame(P-vec3(4.,2.,2.),D,OUT);\n    }\n    \n    //Z-Normal wall\n    bb2 = box(P,ID,vec3(0.,-0.1,3.6),vec3(4.,4.,4.1));\n    if (bb2.x>0. && bb2.y>bb2.x && bb2.x<OUT.D || DFBox(P-vec3(0.,-0.1,3.6),vec3(4.,4.1,0.5))<=0.) {\n        //Wall\n        bb = box(P,ID,vec3(0.,-0.1,4.),vec3(4.,4.,4.1));\n        if (bb.x>0. && bb.y>bb.x && bb.x<OUT.D) OUT = OUT = HIT(bb.x,vec3(1.,0.1,0.1),0.3,0.5,0.2);\n        //Metal cylinders\n        Trace_MetalCylinders(P-vec3(0.,-0.15,3.8),D,OUT);\n        Trace_MetalCylinders(P-vec3(-0.8,-0.65,3.8),D,OUT);\n        //Door\n        Trace_Door(P-vec3(1.2,0.,3.95),D,OUT);\n        Trace_DoorFrame(P-vec3(1.2,0.,4.),D,OUT);\n        //Leaning wood\n        vec3 RP = P-vec3(0.1,0.02,3.7); RP.yz = Rotate(RP.yz,-0.08);\n        vec3 RD = D; RD.yz = Rotate(RD.yz,-0.08);\n        bb = box(RP,1./RD,vec3(0.),vec3(0.24,2.8,0.06));\n        if (bb.x>0. && bb.y>bb.x && bb.x<OUT.D) OUT = HIT(bb.x,vec3(0.6,0.3,0.09),0.2,0.1,0.05);\n        RP = RP+vec3(0.08,0.06,0.06);\n        bb = box(RP,1./RD,vec3(0.),vec3(0.24,2.8,0.06));\n        if (bb.x>0. && bb.y>bb.x && bb.x<OUT.D) OUT = HIT(bb.x,vec3(0.6,0.3,0.09),0.2,0.1,0.05);\n        RP = RP+vec3(-0.1,0.06,0.06);\n        bb = box(RP,1./RD,vec3(0.),vec3(0.24,2.8,0.06));\n        if (bb.x>0. && bb.y>bb.x && bb.x<OUT.D) OUT = HIT(bb.x,vec3(0.6,0.3,0.09),0.2,0.1,0.05);\n    }\n    \n    //Boxes close to vec3(4,0,4)\n    bb2 = box(P,ID,vec3(2.,0.,1.5),vec3(4.,3.,4.));\n    if (bb2.x>0. && bb2.y>bb2.x && bb2.x<OUT.D || DFBox(P-vec3(2.,0.,1.5),vec3(2.,3.,2.5))<=0.) {\n        //Boxes\n        vec3 RP = P-vec3(3.1,0.,3.); RP.xz = Rotate(RP.xz,0.9);\n        vec3 RD = D; RD.xz = Rotate(RD.xz,0.9);\n        Trace_RoundBox(RP,RD,vec3(0.45),0.05,OUT);\n        RP = P-vec3(2.45,0.05,3.); RP.xz = Rotate(RP.xz,-0.1);\n        RD = D; RD.xz = Rotate(RD.xz,-0.1);\n        Trace_RoundBox(RP,RD,vec3(0.45,0.55,0.45),0.05,OUT);\n        //Rotated box\n        RP = P-vec3(2.4,0.3,2.12); RP.xz = Rotate(RP.xz,0.3); RP.zy = Rotate(RP.zy,0.8);\n        RD = D; RD.xz = Rotate(RD.xz,0.3); RD.zy = Rotate(RD.zy,0.8);\n        Trace_RoundBox(RP,RD,vec3(0.65,1.2,0.35),0.05,OUT);\n    }\n    \n    //Sphere\n    Trace_Sphere(P,D,OUT);\n    \n    //Rotating block\n    float TAngle = Time;\n    vec3 RP = P-vec3(-1.,-0.1,3.); RP.xz = Rotate(RP.xz,TAngle);\n    vec3 RD = D; RD.xz = Rotate(RD.xz,TAngle);\n    bb = box(RP,1./RD,vec3(-0.8,0.,-0.05),vec3(0.8,0.8,0.1));\n    if (bb.x>0. && bb.y>bb.x && bb.x<OUT.D) OUT = HIT(bb.x,vec3(0.),0.1,0.5,0.);\n    \n    //Return\n    return OUT;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Secondary rays\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.);\n    if (DFBox(fragCoord-3.,RES-6.)<0.) {\n        //\n        //CURRENT FRAME: secondary rays\n        //\n        float CurrentFrame = float(iFrame-1);\n        vec2 SSOffset = SSOffsets[(iFrame-1)%16];\n        float CurrentTime = texture(iChannel1,vec2(0.5,0.5)*IRES).x;\n        vec4 CurrentMouse = texture(iChannel1,vec2(1.5,0.5)*IRES);\n        vec3 Pos = Position(CurrentMouse,CurrentTime,IRES);\n        vec3 Eye = normalize(CameraCenter(CurrentMouse,CurrentTime)-Pos);\n        vec3 Dir = normalize(vec3(((fragCoord+SSOffset)*IRES*2.-1.)*CFOV*ASPECT,1.)*TBN(Eye));\n        float Distance = texture(iChannel2,fragCoord*IRES).w;\n        if (Distance>-0.5) {\n            //Geometry\n            HIT Pixel = Trace(Pos+Dir*(Distance-0.01),Dir,CurrentTime); //Get attributes\n            vec3 Normal = normalize(FloatToVec3(texture(iChannel3,fragCoord*IRES).w)*2.-1.);\n            vec3 PPos = Pos+Dir*Distance+Normal*0.002;\n            vec3 RandV = ARand23(fragCoord*IRES*(1.+mod(CurrentFrame*7.253,9.234)));\n            vec4 REF = vec4(0.,0.,0.,-1.);\n            vec2 SHAD = vec2(0.,-1.);\n            if (Pixel.M<2.5) {\n                //Reflections\n                vec3 RefDir = reflect(Dir,Normal);\n                float RefCR = Pixel.M*min(1.,tan((HPI-acos(dot(RefDir,Normal)))));\n                vec3 RefSample = normalize(RandSampleCos(RandV.xy)*TBN(RefDir)*RefCR+RefDir);\n                HIT RefHit = Trace(PPos,RefSample,CurrentTime);\n                if (RefHit.M>-0.5) {\n                    //Geometry\n                    REF.w = RefHit.D;\n                    if (RefHit.M>2.5) {\n                        REF.xyz = SampleWindow(PPos,RefSample,RefHit.M);\n                    } else if (PPos.x+RefSample.x*RefHit.D<3.99) {\n                        //Direct\n                        vec3 sPPos = PPos+RefSample*(RefHit.D-0.01);\n                        if (Trace(sPPos,SunDir,CurrentTime).M>2.5)\n                            REF.xyz = SunLight*RefHit.DC*(dot(-RefSample,SunDir)*0.5+0.5);\n                        //Indirect\n                        sPPos = PPos+RefSample*RefHit.D;\n                        vec3 IL = vec3(0.);\n                        if (!(sPPos.y<0.001 && -RefSample.y>0.99)) {\n                            IL += vec3(0.2,0.1,0.04)*1.5*\n                                    (SolidAngle(sPPos,-RefSample,vec3(4.,0.,2.),vec3(4.,0.,1.),vec3(2.,0.,2.))+\n                                    SolidAngle(sPPos,-RefSample,vec3(1.8,0.,1.),vec3(0.,0.,1.2),vec3(0.,0.,4.))+\n                                    SolidAngle(sPPos,-RefSample,vec3(2.,0.,4.),vec3(0.,0.,1.2),vec3(0.,0.,4.))\n                                    );\n                        }\n                        if (!(sPPos.z>3.999 && -RefSample.z<-0.99)) {\n                            IL += vec3(1.,0.2,0.2)*0.7*\n                                    (SolidAngle(sPPos,-RefSample,vec3(1.,0.,4.),vec3(0.,0.,4.),vec3(1.,1.5,4.)));\n                        }\n                        REF.xyz += IL/(2.*PI);\n                    }\n                } else {\n                    //Sky\n                    REF = vec4(0.,0.,0.,100000.);\n                }\n                //Shadows\n                vec3 ShadSample = normalize(RandSampleCos(RandV.xy)*TBN(SunDir)*SunCR+SunDir);\n                if (dot(ShadSample,Normal)>0. && PPos.x<4.01) {\n                    HIT ShadHit = Trace(PPos,ShadSample,CurrentTime);\n                    SHAD.y = ShadHit.D;\n                    if (ShadHit.M>2.5) SHAD.x = 1.;\n                }\n            }\n            //Output\n            Output = vec4(REF.w,SHAD.y,Vec3ToFloat(REF.xyz*IReflConst),SHAD.x);\n        } else {\n            //Sky\n            Output = vec4(-1.,-1.,0.,0.);\n        }\n    }\n    fragColor = Output;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Copy depth + Wavelet iteration 1 + Attributes\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.);\n    if (DFBox(fragCoord-3.,RES-6.)<0.) {\n        //\n        //PRIOR FRAME: copy depth\n        //\n        Output.w = texture(iChannel2,fragCoord*IRES).w; //Copy depth prior frame\n        Output.x = texture(iChannel3,fragCoord*IRES).w; //Copy normal\n        \n        \n        \n        \n        //\n        //CURRENT FRAME: wavelet iteration 1\n        //\n        float CShadow = 0.;\n        float ShadW = 1.;\n        float CurrentFrame = float(iFrame-1);\n        vec2 SSOffset = SSOffsets[(iFrame-1)%16];\n        float CurrentTime = texture(iChannel1,vec2(0.5,0.5)*IRES).x;\n        vec4 CurrentMouse = texture(iChannel1,vec2(1.5,0.5)*IRES);\n        vec3 Pos = Position(CurrentMouse,CurrentTime,IRES);\n        vec3 Eye = normalize(CameraCenter(CurrentMouse,CurrentTime)-Pos);\n        vec3 Tan; vec3 Bit = TBN(Eye,Tan);\n        mat3 EyeMat = TBN(Eye);\n        vec3 Dir = normalize(vec3(((fragCoord+SSOffset)*IRES*2.-1.)*CFOV*ASPECT,1.)*EyeMat);\n        float Distance = texture(iChannel2,fragCoord*IRES).w;\n        if (Distance>-0.5) {\n            //Geometry\n            HIT Pixel = Trace(Pos+Dir*(Distance-0.01),Dir,CurrentTime); //Get attributes\n            vec3 Normal = normalize(FloatToVec3(texture(iChannel3,fragCoord*IRES).w)*2.-1.);\n            vec3 PPos = Pos+Dir*Distance;\n            vec4 RefShad = texture(iChannel0,fragCoord*IRES);\n            vec2 RandV = ARand23(fragCoord*IRES*(1.+mod(CurrentFrame*7.253,9.234))).xy;\n            //Denoisers\n            if (Pixel.M<1.) {\n                //Non-emissive material\n                //Reflections denoiser\n                vec3 RefDir = reflect(Dir,Normal);\n                float RefCR = Pixel.M*min(1.,tan((HPI-acos(dot(RefDir,Normal)))));\n                vec3 Light = FloatToVec3(RefShad.z)*ReflConst*2.;\n                float W = 2.;\n                vec3 CVPos0 = vec3(RefShad.x*RefCR,0.,Distance+RefShad.x)*TBN(Dir);\n                vec3 CVPos1 = vec3(-RefShad.x*RefCR,0.,Distance+RefShad.x)*TBN(Dir);\n                vec3 LVPos0 = vec3(dot(CVPos0,Tan),dot(CVPos0,Bit),dot(CVPos0,Eye));\n                vec3 LVPos1 = vec3(dot(CVPos1,Tan),dot(CVPos1,Bit),dot(CVPos1,Eye));\n                vec2 Luv0 = ((LVPos0.xy/LVPos0.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n                vec2 Luv1 = ((LVPos1.xy/LVPos1.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n                float MaxRadius = min(32.,length(Luv0-Luv1)*0.5);\n                for (float x=-2.; x<2.5; x+=1.) {\n                    for (float y=-2.; y<2.5; y+=1.) {\n                        if (x==0. && y==0.) continue;\n                        vec2 Offset2 = normalize(vec2(x,y))*max(abs(x),abs(y))*(0.5*MaxRadius);\n                        vec2 SUV = floor(fragCoord+Offset2)+0.5;\n                        float SDistance = texture(iChannel2,SUV*IRES).w;\n                        vec3 SDir = normalize(vec3(((SUV+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat);\n                        if (SDistance<-0.5 || abs(dot(Pos+SDir*SDistance-PPos,Normal))>0.1 || DFBox(SUV-3.,RES-6.)>0.) continue;\n                        vec3 SNor = FloatToVec3(texture(iChannel3,SUV*IRES).w)*2.-1.;\n                        //Reflection direction\n                        vec4 SRefShad = texture(iChannel0,SUV*IRES);\n                        if (SRefShad.x<-0.5) continue;\n                        vec2 SRand = ARand23(SUV*IRES*(1.+mod(CurrentFrame*7.253,9.234))).xy;\n                        vec3 SRefDir = reflect(SDir,SNor);\n                        float SCR = Pixel.M*min(1.,tan((HPI-acos(dot(RefDir,Normal))))); //MÃ¥ste ray-tracea fÃ¶r Hit.y annars\n                        vec3 SRDir = normalize(RandSampleCos(SRand)*TBN(SRefDir)*SCR+SRefDir);\n                        vec3 HitP = Pos+SDir*SDistance+SNor*0.0015+SRDir*SRefShad.x;\n                        if (dot(HitP-PPos,Normal)<=0.) continue;\n                        if (sqrt(1./dot(normalize(HitP-PPos),RefDir)-1.)<=RefCR) {\n                            Light += FloatToVec3(SRefShad.z)*ReflConst;\n                            W += 1.;\n                        }\n                    }\n                }\n                Light = Light/W;\n                Output.y = Vec3ToFloat(Light*IReflConst);\n                //Shadow denoiser\n                CVPos0 = vec3(RefShad.y*SunCR,0.,Distance)*TBN(Dir);\n                CVPos1 = vec3(-RefShad.y*SunCR,0.,Distance)*TBN(Dir);\n                LVPos0 = vec3(dot(CVPos0,Tan),dot(CVPos0,Bit),dot(CVPos0,Eye));\n                LVPos1 = vec3(dot(CVPos1,Tan),dot(CVPos1,Bit),dot(CVPos1,Eye));\n                Luv0 = ((LVPos0.xy/LVPos0.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n                Luv1 = ((LVPos1.xy/LVPos1.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n                MaxRadius = min(32.,length(Luv0-Luv1)*0.5);\n                CShadow = RefShad.w*2.;\n                ShadW = 2.;\n                for (float x=-2.; x<2.5; x+=1.) {\n                    for (float y=-2.; y<2.5; y+=1.) {\n                        if (x==0. && y==0.) continue;\n                        vec2 Offset2 = normalize(vec2(x,y))*max(abs(x),abs(y))*(MaxRadius*0.5);\n                        vec2 SUV = floor(fragCoord+Offset2)+0.5;\n                        float SDistance = texture(iChannel2,SUV*IRES).w;\n                        vec3 SDir = normalize(vec3(((SUV+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat);\n                        if (SDistance<-0.5 || abs(dot(Pos+SDir*SDistance-PPos,Normal))>0.1 || DFBox(SUV-3.,RES-6.)>0.) continue;\n                        vec4 SRefShad = texture(iChannel0,SUV*IRES);\n                        if (SRefShad.y<-0.5) continue;\n                        vec2 SRand = ARand23(SUV*IRES*(1.+mod(CurrentFrame*7.253,9.234))).xy;\n                        vec3 HitP = Pos+SDir*SDistance+normalize(RandSampleCos(SRand.xy)*TBN(SunDir)*SunCR+SunDir)*SRefShad.y;\n                        if (dot(HitP-PPos,Normal)<=0.) continue;\n                        CShadow += SRefShad.w;\n                        ShadW += 1.;\n                    }\n                }\n                Output.z = CShadow/ShadW;\n            }\n        } else {\n            //Sky\n        }\n    } else {\n        //Boundary: attributes\n        if (fragCoord.y<1.) {\n            if (fragCoord.x<1.) Output = vec4(iTime,texture(iChannel1,vec2(0.5)*IRES).xy,0.); //Prior frame time, time\n            else if (fragCoord.x<2.) Output = iMouse; //Mouse\n            else if (fragCoord.x<3.) Output = texture(iChannel1,vec2(1.5,0.5)*IRES); //Prior frame mouse\n            else if (fragCoord.x<4.) Output = texture(iChannel1,vec2(2.5,0.5)*IRES); //Prior prior frame mouse\n            \n        }\n    }\n    fragColor = Output;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Primary rays + Wavelet iteration 2\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.);\n    if (DFBox(fragCoord-3.,RES-6.)<0.) {\n        //\n        //PRIOR FRAME: primary rays\n        //\n        vec2 SSOffset = SSOffsets[(iFrame)%16];\n        float CurrentTime = iTime;\n        vec3 Pos = Position(iMouse,CurrentTime,IRES);\n        vec3 Eye = normalize(CameraCenter(iMouse,iTime)-Pos);\n        vec3 Dir = normalize(vec3(((fragCoord+SSOffset)*IRES*2.-1.)*CFOV*ASPECT,1.)*TBN(Eye));\n        HIT Pixel = Trace(Pos,Dir,CurrentTime);\n        Output.w = ((Pixel.M<0.)?-1.:Pixel.D);\n        \n        \n        \n        \n        //\n        //CURRENT FRAME: wavelet iteration 2\n        //\n        float CurrentFrame = float(iFrame-1);\n        SSOffset = SSOffsets[(iFrame-1)%16];\n        CurrentTime = texture(iChannel1,vec2(0.5,0.5)*IRES).y;\n        vec4 CurrentMouse = texture(iChannel1,vec2(2.5,0.5)*IRES);\n        Pos = Position(CurrentMouse,CurrentTime,IRES);\n        Eye = normalize(CameraCenter(CurrentMouse,CurrentTime)-Pos);\n        vec3 Tan; vec3 Bit = TBN(Eye,Tan);\n        mat3 EyeMat = TBN(Eye);\n        Dir = normalize(vec3(((fragCoord+SSOffset)*IRES*2.-1.)*CFOV*ASPECT,1.)*EyeMat);\n        float Distance = texture(iChannel1,fragCoord*IRES).w;\n        if (Distance>-0.5) {\n            //Geometry\n            HIT Pixel = Trace(Pos+Dir*(Distance-0.01),Dir,CurrentTime); //Get attributes\n            vec3 Normal = normalize(FloatToVec3(texture(iChannel3,fragCoord*IRES).w)*2.-1.);\n            vec3 PPos = Pos+Dir*Distance;\n            vec4 RefShad = texture(iChannel0,fragCoord*IRES);\n            vec2 RandV = ARand23(fragCoord*IRES*(1.+mod(CurrentFrame*7.253,9.234))).xy;\n            //Denoisers\n            if (Pixel.M<1.) {\n                //Non-emissive material\n                //Reflections denoiser\n                vec3 RefDir = reflect(Dir,Normal);\n                float RefCR = Pixel.M*min(1.,tan((HPI-acos(dot(RefDir,Normal)))));\n                vec3 Light = FloatToVec3(texture(iChannel1,fragCoord*IRES).y)*ReflConst*2.;\n                float W = 2.;\n                vec3 CVPos0 = vec3(RefShad.x*RefCR,0.,Distance+RefShad.x)*TBN(Dir);\n                vec3 CVPos1 = vec3(-RefShad.x*RefCR,0.,Distance+RefShad.x)*TBN(Dir);\n                vec3 LVPos0 = vec3(dot(CVPos0,Tan),dot(CVPos0,Bit),dot(CVPos0,Eye));\n                vec3 LVPos1 = vec3(dot(CVPos1,Tan),dot(CVPos1,Bit),dot(CVPos1,Eye));\n                vec2 Luv0 = ((LVPos0.xy/LVPos0.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n                vec2 Luv1 = ((LVPos1.xy/LVPos1.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n                float MaxRadius = min(8.,length(Luv0-Luv1)*0.5);\n                for (float x=-2.; x<2.5; x+=1.) {\n                    for (float y=-2.; y<2.5; y+=1.) {\n                        if (x==0. && y==0.) continue;\n                        vec2 Offset2 = normalize(vec2(x,y))*max(abs(x),abs(y))*(MaxRadius*0.5);\n                        vec2 SUV = floor(fragCoord+Offset2)+0.5;\n                        float SDist = texture(iChannel1,SUV*IRES).w;\n                        vec3 SDir = normalize(vec3(((SUV+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat);\n                        if (SDist<-0.5 || abs(dot(Pos+SDir*SDist-PPos,Normal))>0.1 || DFBox(SUV-3.,RES-6.)>0.) continue;\n                        vec3 SNor = FloatToVec3(texture(iChannel3,SUV*IRES).w)*2.-1.;\n                        //Reflection direction\n                        vec4 SRefShad = texture(iChannel0,SUV*IRES);\n                        if (SRefShad.x<-0.5) continue;\n                        vec2 SRand = ARand23(SUV*IRES*(1.+mod(CurrentFrame*7.253,9.234))).xy;\n                        vec3 SRefDir = reflect(SDir,SNor);\n                        float SCR = Pixel.M*min(1.,tan((HPI-acos(dot(RefDir,Normal))))); //MÃ¥ste ray-tracea fÃ¶r Hit.y annars\n                        vec3 SRDir = normalize(RandSampleCos(SRand)*TBN(SRefDir)*SCR+SRefDir);\n                        vec3 HitP = Pos+SDir*SDist+SNor*0.0015+SRDir*SRefShad.x;\n                        if (dot(HitP-PPos,Normal)<=0.) continue;\n                        if (sqrt(1./dot(normalize(HitP-PPos),RefDir)-1.)<=RefCR) {\n                            Light += FloatToVec3(texture(iChannel1,SUV*IRES).y)*ReflConst;\n                            W += 1.;\n                        }\n                    }\n                }\n                Light = Light/W;\n                Output.xy = vec2(Vec2ToFloat(Light.xy*IReflConst),Light.z);\n                //Shadow denoiser\n                CVPos0 = vec3(RefShad.y*SunCR,0.,Distance+RefShad.y)*TBN(Dir);\n                CVPos1 = vec3(-RefShad.y*SunCR,0.,Distance+RefShad.y)*TBN(Dir);\n                LVPos0 = vec3(dot(CVPos0,Tan),dot(CVPos0,Bit),dot(CVPos0,Eye));\n                LVPos1 = vec3(dot(CVPos1,Tan),dot(CVPos1,Bit),dot(CVPos1,Eye));\n                Luv0 = ((LVPos0.xy/LVPos0.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n                Luv1 = ((LVPos1.xy/LVPos1.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n                MaxRadius = min(8.,length(Luv0-Luv1)*0.5);\n                float CShadow = texture(iChannel1,fragCoord*IRES).z*2.;\n                float ShadW = 2.;\n                for (float x=-2.; x<2.5; x+=1.) {\n                    for (float y=-2.; y<2.5; y+=1.) {\n                        if (x==0. && y==0.) continue;\n                        vec2 Offset2 = normalize(vec2(x,y))*max(abs(x),abs(y))*(MaxRadius*0.5);\n                        vec2 SUV = floor(fragCoord+Offset2)+0.5;\n                        vec4 SRefShad = texture(iChannel1,SUV*IRES);\n                        float SDistance = SRefShad.w;\n                        vec3 SDir = normalize(vec3(((SUV+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat);\n                        if (SDistance<-0.5 || abs(dot(Pos+SDir*SDistance-PPos,Normal))>0.1 || DFBox(SUV-3.,RES-6.)>0.) continue;\n                        float RayDist = texture(iChannel0,SUV*IRES).y;\n                        if (RayDist<-0.5) continue;\n                        vec2 SRand = ARand23(SUV*IRES*(1.+mod(CurrentFrame*7.253,9.234))).xy;\n                        vec3 HitP = Pos+SDir*SDistance+normalize(RandSampleCos(SRand.xy)*TBN(SunDir)*SunCR+SunDir)*RayDist;\n                        if (dot(HitP-PPos,Normal)<=0.) continue;\n                        CShadow += SRefShad.z;\n                        ShadW += 1.;\n                    }\n                }\n                Output.z = CShadow/ShadW;\n            }\n        } else {\n            //Sky\n        }\n    }\n    fragColor = Output;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//Normals + Temporal accumulation + Composition\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.);\n    if (DFBox(fragCoord-3.,RES-6.)<0.) {\n        //\n        //PRIOR FRAME: normals\n        //\n        vec2 SSOffset = SSOffsets[(iFrame)%16];\n        float CurrentTime = iTime;\n        vec3 Pos = Position(iMouse,CurrentTime,IRES);\n        vec3 Eye = normalize(CameraCenter(iMouse,iTime)-Pos);\n        vec3 VDir = normalize(vec3(((fragCoord+SSOffset)*IRES*2.-1.)*CFOV*ASPECT,1.));\n        mat3 EyeMat = TBN(Eye);\n        vec3 Dir = VDir*EyeMat;\n        //Compute normal\n        vec3 PixelVP = VDir*texture(iChannel2,fragCoord*IRES).w;\n        vec3 Tan = vec3(0.,0.,0.);\n        vec3 Bit = vec3(0.,0.,0.);\n        vec2 XD = vec2(texture(iChannel2,(fragCoord+vec2(1.,0.))*IRES).w,texture(iChannel2,(fragCoord+vec2(-1.,0.))*IRES).w);\n        vec3 XP0 = normalize(vec3(((fragCoord+vec2(1.,0.)+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.))*XD.x;\n        vec3 XP1 = normalize(vec3(((fragCoord-vec2(1.,0.)+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.))*XD.y;\n        if (XD.x>-0.5) Tan = XP0-PixelVP;\n        if (XD.y>-0.5 && (XD.x<-0.5 || length(Tan)>length(XP1-PixelVP))) Tan = XP1-PixelVP;\n        vec2 YD = vec2(texture(iChannel2,(fragCoord+vec2(0.,1.))*IRES).w,texture(iChannel2,(fragCoord+vec2(0.,-1.))*IRES).w);\n        vec3 YP0 = normalize(vec3(((fragCoord+vec2(0.,1.)+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.))*YD.x;\n        vec3 YP1 = normalize(vec3(((fragCoord-vec2(0.,1.)+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.))*YD.y;\n        if (YD.x>-0.5) Bit = YP0-PixelVP;\n        if (YD.y>-0.5 && (YD.x<-0.5 || length(Bit)>length(YP1-PixelVP))) Bit = YP1-PixelVP;\n        vec3 Normal = normalize(cross(Bit,Tan))*EyeMat;\n        Normal *= sign(dot(Normal,-Dir));\n        Output.w = Vec3ToFloat(Normal*0.5+0.5);\n        \n        \n        \n        \n        //\n        //CURRENT FRAME: Temporal accumulation + TAA + Composition\n        //\n        float CurrentFrame = float(iFrame-1);\n        SSOffset = SSOffsets[(iFrame-1)%16];\n        CurrentTime = texture(iChannel1,vec2(0.5,0.5)*IRES).y;\n        vec4 CurrentMouse = texture(iChannel1,vec2(2.5,0.5)*IRES);\n        Pos = Position(CurrentMouse,CurrentTime,IRES);\n        Eye = normalize(CameraCenter(CurrentMouse,CurrentTime)-Pos);\n        Bit = TBN(Eye,Tan);\n        EyeMat = TBN(Eye);\n        Dir = normalize(vec3(((fragCoord+SSOffset)*IRES*2.-1.)*CFOV*ASPECT,1.)*EyeMat);\n        float Distance = texture(iChannel1,fragCoord*IRES).w;\n        if (Distance>-0.5) {\n            //Geometry\n            HIT Pixel = Trace(Pos+Dir*(Distance-0.01),Dir,CurrentTime); //Get attributes\n            vec3 Normal = normalize(FloatToVec3(texture(iChannel3,fragCoord*IRES).w)*2.-1.);\n            vec3 PPos = Pos+Dir*Distance;\n            vec4 RefShad = texture(iChannel0,fragCoord*IRES);\n            //Denoisers\n            if (Pixel.M>2.5) {\n                //Emissive\n                vec3 WindowLight = SampleWindow(Pos,Dir,Pixel.M);\n                Output.xyz = vec3(Vec2ToFloat(WindowLight.xy*IReflConst),Vec2ToFloat(vec2(WindowLight.z*IReflConst,0.)),0.);\n            } else if (Pixel.M<1.) {\n                //Non-emissive material\n                vec3 BCRef = texture(iChannel2,fragCoord*IRES).xyz;\n                vec3 ReflectionLight = vec3(FloatToVec2(BCRef.x)*ReflConst,BCRef.y);\n                float Shadow = BCRef.z;\n                vec3 FinalColor = vec3(0.);\n                //Reprojection\n                float PriorTime = texture(iChannel1,vec2(0.5,0.5)*IRES).z;\n                vec4 PriorMouse = texture(iChannel1,vec2(3.5,0.5)*IRES);\n                vec3 PriorPos = Position(PriorMouse,PriorTime,IRES);\n                vec3 PriorEye = normalize(CameraCenter(PriorMouse,PriorTime)-PriorPos);\n                vec3 PriorTan; vec3 PriorBit = TBN(PriorEye,PriorTan);\n                vec3 PriorVPos = vec3(dot(PPos-PriorPos,PriorTan),dot(PPos-PriorPos,PriorBit),dot(PPos-PriorPos,PriorEye));\n                vec2 PriorUV = ((PriorVPos.xy/PriorVPos.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n                if (DFBox(PriorUV-3.,RES-6.)<0.) {\n                    //\n                    //Reflections\n                    //\n                    vec3 LReflectionLight = FloatToVec3(texture(iChannel3,PriorUV*IRES).z)*ReflConst;\n                    //Clamping\n                    vec3 RMIN = vec3(1000.);\n                    vec3 RMAX = vec3(0.);\n                    for (float x=-1.; x<1.5; x+=1.) {\n                        for (float y=-1.; y<1.5; y+=1.) {\n                            BCRef.xy = texture(iChannel2,(fragCoord+vec2(x,y))*IRES).xy;\n                            vec3 Sample = vec3(FloatToVec2(BCRef.x)*ReflConst,BCRef.y);\n                            RMIN = min(RMIN,Sample);\n                            RMAX = max(RMAX,Sample);\n                        }\n                    }\n                    LReflectionLight = clamp(LReflectionLight,RMIN,RMAX);\n                    //Output\n                    ReflectionLight = (ReflectionLight+LReflectionLight*15.)/16.;\n                    \n                    \n                    \n                    \n                    //\n                    //Shadows\n                    //\n                    float LShadow = FloatToVec2(texture(iChannel3,PriorUV*IRES).y).y;\n                    //Clamping\n                    float SMIN = 1000.;\n                    float SMAX = 0.;\n                    for (float x=-1.; x<1.5; x+=1.) {\n                        for (float y=-1.; y<1.5; y+=1.) {\n                            BCRef.x = texture(iChannel2,(fragCoord+vec2(x,y))*IRES).z;\n                            SMIN = min(SMIN,BCRef.x);\n                            SMAX = max(SMAX,BCRef.x);\n                        }\n                    }\n                    LShadow = clamp(LShadow,SMIN,SMAX);\n                    //Output\n                    Shadow = (Shadow+LShadow*15.)/16.;\n                }\n                \n                \n                \n                \n                //\n                //Indirect diffuse\n                //\n                vec3 IndirectDiffuse = vec3(0.);\n                if (!(PPos.y<0.001 && Normal.y>0.99)) {\n                    IndirectDiffuse += vec3(0.2,0.1,0.04)*1.5*\n                            (SolidAngle(PPos,Normal,vec3(4.,0.,2.),vec3(4.,0.,1.),vec3(2.,0.,2.))+\n                            SolidAngle(PPos,Normal,vec3(1.8,0.,1.),vec3(0.,0.,1.2),vec3(0.,0.,4.))+\n                            SolidAngle(PPos,Normal,vec3(2.,0.,4.),vec3(0.,0.,1.2),vec3(0.,0.,4.))\n                            );\n                }\n                if (!(PPos.z>3.999 && Normal.z<-0.99)) {\n                    IndirectDiffuse += vec3(1.,0.2,0.2)*0.7*\n                            (SolidAngle(PPos,Normal,vec3(1.,0.,4.),vec3(0.,0.,4.),vec3(1.,1.5,4.)));\n                }\n                IndirectDiffuse /= (2.*PI);\n                \n                \n                \n                \n                //\n                //Composition\n                //\n                vec3 DiffuseLight = SunLight*Shadow*max(0.,dot(SunDir,Normal));\n                DiffuseLight = max(vec3(0.),DiffuseLight)*Pixel.DC+IndirectDiffuse*Pixel.DC;\n                vec3 FresnelTerm = SchlickFresnel(vec3(Pixel.Specular),dot(Normal,-Dir));\n                FinalColor = DiffuseLight*(1.-Pixel.Metal)+Pixel.Metal*mix(DiffuseLight,ReflectionLight,FresnelTerm);\n                \n                \n                \n                \n                //\n                //Output\n                //\n                Output.xyz = vec3(Vec2ToFloat(FinalColor.xy*IReflConst),\n                                  Vec2ToFloat(vec2(FinalColor.z*IReflConst,Shadow)),\n                                  Vec3ToFloat(ReflectionLight*IReflConst));\n            }\n        } else {\n            //Sky\n            Output.xyz = vec3(0.);\n            Output.xyz = vec3(Vec2ToFloat(Output.xy*IReflConst),\n                                  Vec2ToFloat(vec2(Output.z*IReflConst,0.)),0.);\n        }\n    }\n    fragColor = Output;\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"//TAA\n    //Catmull-rom by hornet: https://www.shadertoy.com/view/MtVGWz\n\nvec4 textureCube(vec2 UV) {\n    //Samples the cubemap\n    float Sign = -mod(floor(UV.y*I1024),2.)*2.+1.;\n    vec3 D = vec3(vec2(UV.x,mod(UV.y,1024.))*I512-1.,Sign);\n    if (UV.y>4096.) D = D.xzy;\n    else if (UV.y>2048.) D = D.zxy;\n    return texture(iChannel3,D);\n}\n\nvec3 sampleLevel0(vec2 PriorUV) {\n    float YOffset = floor(PriorUV.x*I1024)*1024.+floor(PriorUV.y*I1024)*3072.;\n    return textureCube(mod(PriorUV,1024.)+vec2(0.,YOffset)).xyz;\n}\n\nvec3 SampleTextureCatmullRom(vec2 uv) {\n    vec2 samplePos = uv;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n    vec2 f = samplePos - texPos1;\n    vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n    vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n    vec2 w3 = f * f * (-0.5 + 0.5 * f);\n    vec2 w12 = w1 + w2;\n    vec2 offset12 = w2 / w12;\n    vec2 texPos0 = texPos1 - vec2(1.0);\n    vec2 texPos3 = texPos1 + vec2(2.0);\n    vec2 texPos12 = texPos1 + offset12;\n    vec3 result = vec3(0.);\n    result += sampleLevel0( vec2(texPos0.x,  texPos0.y)) * w0.x * w0.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos0.y)) * w12.x * w0.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos0.y)) * w3.x * w0.y;\n    result += sampleLevel0( vec2(texPos0.x,  texPos12.y)) * w0.x * w12.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos12.y)) * w12.x * w12.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos12.y)) * w3.x * w12.y;\n    result += sampleLevel0( vec2(texPos0.x,  texPos3.y)) * w0.x * w3.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos3.y)) * w12.x * w3.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos3.y)) * w3.x * w3.y;\n    return max(vec3(0.),result);\n}\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    vec4 Output = vec4(0.,0.,0.,0.);\n    vec2 UV; vec3 aDir = abs(rayDir);\n    if (aDir.z>max(aDir.x,aDir.y)) {\n        //Z-side\n        UV = floor(((rayDir.xy/aDir.z)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.z<0.) UV.y += 1024.;\n    } else if (aDir.x>aDir.y) {\n        //X-side\n        UV = floor(((rayDir.yz/aDir.x)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.x>0.) UV.y += 2048.;\n        else UV.y += 3072.;\n    } else {\n        //Y-side\n        UV = floor(((rayDir.xz/aDir.y)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.y>0.) UV.y += 4096.;\n        else UV.y += 5120.;\n    }\n    vec2 RESOffset = vec2((mod(floor(UV.y*I1024)+0.5,3.)-0.5)*1024.,floor(UV.y*I1024*I3)*1024.);\n    vec2 CUV = mod(UV,1024.)+RESOffset;\n    if (DFBox(CUV-3.,RES-6.)<0.) {\n        //Inside the screen\n        vec2 BCRef = texture(iChannel0,CUV*IRES).xy;\n        vec3 FinalColor = vec3(FloatToVec2(BCRef.x),FloatToVec2(BCRef.y).x)*ReflConst;\n        //Reprojection\n        float CurrentFrame = float(iFrame-1);\n        vec2 SSOffset = SSOffsets[(iFrame-1)%16];\n        float CurrentTime = texture(iChannel1,vec2(0.5,0.5)*IRES).y;\n        vec4 CurrentMouse = texture(iChannel1,vec2(2.5,0.5)*IRES);\n        vec3 Pos = Position(CurrentMouse,CurrentTime,IRES);\n        vec3 Eye = normalize(CameraCenter(CurrentMouse,CurrentTime)-Pos);\n        vec3 Tan; vec3 Bit = TBN(Eye,Tan);\n        mat3 EyeMat = TBN(Eye);\n        vec3 Dir = normalize(vec3(((CUV+SSOffset)*IRES*2.-1.)*CFOV*ASPECT,1.)*EyeMat);\n        float Distance = texture(iChannel1,CUV*IRES).w;\n        if (Distance<-0.5) Distance = 100000.; //Sky pixel\n        HIT Pixel = Trace(Pos+Dir*(Distance-0.01),Dir,CurrentTime);\n        vec3 Normal = normalize(FloatToVec3(texture(iChannel1,CUV*IRES).x)*2.-1.);\n        vec3 PPos = Pos+Dir*Distance;\n        float PriorTime = texture(iChannel1,vec2(0.5,0.5)*IRES).z;\n        vec4 PriorMouse = texture(iChannel1,vec2(3.5,0.5)*IRES);\n        vec3 PriorPos = Position(PriorMouse,PriorTime,IRES);\n        vec3 PriorEye = normalize(CameraCenter(PriorMouse,PriorTime)-PriorPos);\n        vec3 PriorTan; vec3 PriorBit = TBN(PriorEye,PriorTan);\n        vec3 PriorVPos = vec3(dot(PPos-PriorPos,PriorTan),dot(PPos-PriorPos,PriorBit),dot(PPos-PriorPos,PriorEye));\n        vec2 PriorUV = ((PriorVPos.xy/PriorVPos.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n        if (DFBox(PriorUV-3.,RES-6.)<0.) {\n            //Valid reprojection\n            vec3 LFinalColor;\n            if (length(PriorUV-CUV-SSOffset)>0.02) {\n                //Catmull-rom sampling\n                PriorUV -= SSOffsets[(iFrame-2)%16];\n                LFinalColor = SampleTextureCatmullRom(PriorUV);\n            } else {\n                //Nearest neighbour sampling\n                PriorUV = floor(PriorUV)+0.5;\n                float YOffset = floor(PriorUV.x*I1024)*1024.+floor(PriorUV.y*I1024)*3072.;\n                LFinalColor = textureCube(mod(PriorUV,1024.)+vec2(0.,YOffset)).xyz;\n            }            \n            //Clamping\n            vec3 FMIN = vec3(1000.);\n            vec3 FMAX = vec3(0.);\n            for (float x=-1.; x<1.5; x+=1.) {\n                for (float y=-1.; y<1.5; y+=1.) {\n                    BCRef = texture(iChannel0,(CUV+vec2(x,y))*IRES).xy;\n                    vec3 Sample = vec3(FloatToVec2(BCRef.x),FloatToVec2(BCRef.y).x)*ReflConst;\n                    FMIN = min(FMIN,Sample);\n                    FMAX = max(FMAX,Sample);\n                }\n            }\n            LFinalColor = clamp(LFinalColor,FMIN,FMAX);\n            //Output\n            Output = vec4((FinalColor+LFinalColor*15.)/16.,0.);\n        } else {\n            //Invalid reprojection\n            Output.xyz = FinalColor;\n        }\n    }\n    //Output\n    fragColor = Output;\n}","name":"Cube A","description":"","type":"cubemap"}]}