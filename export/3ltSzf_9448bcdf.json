{"ver":"0.1","info":{"id":"3ltSzf","date":"1581455943","viewed":74,"name":"Cuarto chico-color-v2--II","username":"jorge2017a1","description":"Cuarto chico-color-v2--II","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cuartochicocolorv2ii"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Referencia https://www.shadertoy.com/view/wt3XzX\n//Modificado por: jorge flores p. *(jorge2017a1)\n\n#define SHADERTOY\n#define SHADERTOY_ZOOM 2.0\n#define BLEND_COLOR\nprecision mediump float;\nuniform vec3 uOrigin;\nuniform mat3 uView;\nuniform vec2 uInvSize;\n\n\n#define PI 3.141592653589793\n#define PI_2 1.5707963267948966\n#define SQRT1_2 0.7071067811865476\n#define SQRT2 1.4142135623730951\n\n\n\n\n\nconst int CInf = 1;\nconst int CSup = 2;\nconst int CDer = 3;\nconst int CIzq = 4;\nconst int CAtras = 5;\nconst int CPlane = 6;\nconst int CLight = 7;\nconst int CSky = 8;\nconst int CPlane2 = 15; //9;\n\n\nfloat closeObj = 0.0;\n\nstruct TObj\n{\n    float tipo;\n    float dist;\n};\n    \n\nTObj mObj;\n\n////---------------------------------------------\n// raymarching code from https://www.shadertoy.com/view/Xds3zN\n\n// blend color for chamfer and round operators (sd is simple operator distance)\nvec3 colorBlending( float sd,  vec4 a,  vec4 b) {\n  float ra = clamp(sd / a.x, 0.0, 1.0);\n  float rb = clamp(sd / b.x, 0.0, 1.0);\n  return (a.yzw * ra + b.yzw * rb) / (ra + rb);\n}\n\nvec3 colorUnion( vec4 a,  vec4 b){\n#ifdef BLEND_COLOR\n  return colorBlending(min(a.x, b.x), a, b);\n#else\n  return (a.x < b.x) ? a.yzw : b.yzw;\n#endif\n}\n\nvec3 colorInter( vec4 a,  vec4 b){\n#ifdef BLEND_COLOR\n  return colorBlending(max(a.x, b.x), a, b);\n#else\n  return (a.x < b.x) ? a.yzw : b.yzw;\n#endif\n}\n\nvec2 pR45( vec2 p) {\n  return (p + vec2(p.y, -p.x)) * SQRT1_2;\n}\n\n/////////////\n// PRIMITIVES\n/////////////\n\nfloat cullPlane( vec3 p) {\n  return p.y >= -0.502 ? p.y + 0.5 : 20.0;\n}\n\n\nfloat sdSphere( vec3 p,  float s) {\n  return length(p) - s;\n}\n\n\nfloat sdBox( vec3 p,  vec4 b) {\n  vec3 d = abs(p) - b.xyz;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - b.w;\n}\n\n\n/*float sdTorus( vec3 p,  vec2 t) {\n  return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n*/\n\nfloat sdCapsule( vec3 p,  vec2 rh) {\n  return mix(length(p.xz) - rh.x, length(vec3(p.x, abs(p.y) - rh.y, p.z)) - rh.x, step(rh.y, abs(p.y)));\n}\n\nfloat sdEllipsoid(  vec3 p,  vec3 r) {\n  return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\n///////////////\n// COMBINATIONS\n///////////////\n\n// UNION\nfloat opUnion( float a,  float b) {\n  return min(a, b);\n}\n\n\n// INTER\nfloat opInter( float a,  float b) {\n  return max(a, b);\n}\n\n\n// SUB\nfloat opSub( float a,  float b) {\n  return max(-b, a);\n}\n\n// see hg_sdf.glsl\n/////////////////////\n// COMBINATIONS ROUND\n/////////////////////\n\n\n///////////////////////\n// COMBINATIONS CHAMFER\n///////////////////////\n\n// UNION CHAMFER\n//////////////////////\n// COMBINATION COLUMNS\n//////////////////////\n/////////////\n// REPETITION\n/////////////\n\nvec3 pMod( vec3 p,  vec3 size) {\n  vec3 pmod = p;\n  if(size.x > 0.0) pmod.x = mod(p.x + size.x * 0.5, size.x) - size.x * 0.5;\n  if(size.y > 0.0) pmod.y = mod(p.y + size.y * 0.5, size.y) - size.y * 0.5;\n  if(size.z > 0.0) pmod.z = mod(p.z + size.z * 0.5, size.z) - size.z * 0.5;\n  return pmod;\n}\n\n\n\n///------------------------------------------\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\n\n/*float sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n*/\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n///--------------------------------------------\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n///----------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return vec3(1, 0.5, 0);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(0, 1, 1);\n        \n    case 5:\n        return vec3(85./255., 205./255., 252./255.);\n    case 6:\n        //return vec3(247./255., 168./255.,  184./255.);\n        return  vec3(0.5, 0.8, 0.9);\n        \n    case 7:\n        return vec3(1.0, 1.0, 1.0);\n    case 8:\n        //return vec3(247./255., 168./255.,  184./255.); \n        //return vec3(55./255., 30./255.,  255./255.); \n        return vec3(0.425, 0.56, 0.9); \n    case 9:\n        //return vec3(85./255., 205./255., 252./255.); \n        return vec3(0.5, 0.6, 0.6); \n    case 10:\n        return vec3(0.0, 1.0, 0.0);\n    \n    \n        \n    } \n}\n\n//---------------------------------------------------\n\n////////////\n// HELPERS\n////////////\n\nfloat mapDistance( vec3 point) {\n  float d;\n    float dif1;\n    float dif2;\n    float dif3;\n    vec3 p;\n    p=point; \n    \n    d=999.9;\n    float planeDist = p.y;\n   \n    \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    res = opU(res, vec2(planeDist, 6));\n    \n    \n    float bxInf = sdBox (p-vec3(0.0,1,4.5),vec3(1.65,0.1,0.5));\n    float bxDer = sdBox (p-vec3(-1.6,1.9,4.5),vec3(0.1,1.0,0.5));\n    float bxIzq = sdBox (p-vec3(1.6,1.9,4.5),vec3(0.1,1.0,0.5));\n    float bxSup = sdBox (p-vec3(-0.0,3.0,4.5),vec3(2.5,0.1,0.5));\n    float bxAtras = sdBox(p-vec3(-0.1,2.1,5.0),vec3(1.65,1.0,0.1));\n    \n    res = opU(res, vec2(bxInf, CInf));\n    \n    \n    float bxAtrasVentana = sdBox (p-vec3(-0.5,2.1,5.0),vec3(0.5,0.5,0.4));\n    float bxAtrasPuerta = sdBox (p-vec3(0.8,1.8,5.0),vec3(0.45,0.8,0.4));\n    float bxSupVentana = sdBox (p-vec3(0.0,3.0,4.5),vec3(0.5,0.21,0.4));\n    float bxIzqVentana = sdBox (p-vec3(1.6,1.9,4.5),vec3(0.11,0.30,0.25));\n    float bxDerVentana = sdBox (p-vec3(-1.6,1.9,4.5),vec3(0.11,0.55,0.25));\n    \n    \n    dif2=differenceSDF(bxIzq,bxIzqVentana);     \n    res = opU(res, vec2(dif2, CIzq));\n    \n    \n    dif1 = differenceSDF(bxAtras,bxAtrasVentana);\n    dif1= differenceSDF(dif1,bxAtrasPuerta);\n    res = opU(res, vec2(dif1, CAtras));   \n  \n    dif2=differenceSDF(bxSup,bxSupVentana);     \n    res = opU(res, vec2(dif2, CSup));\n  \n    dif3=differenceSDF(bxDer,bxDerVentana);     \n    res = opU(res, vec2(dif3, CDer));\n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n        \n    return d;\n}\n    \nvec4 castRay( vec3 ro,  vec3 rd) {\n  float t = 1.0;\n  float tmax = 50.0;\n\n  float precis = 0.002;\n  for(int i = 0; i < 50; i++) {\n    float dist = mapDistance(ro + rd * t);\n    if(dist < precis || t > tmax)\n      break;\n    t += dist;\n  }\n\n    vec3 m =vec3(1.0);\n  //vec3 m = t > tmax ? vec3(-1.0) : mapDistance(ro + rd * t).yzw;\n  return vec4(t, m);\n}\n\nfloat softshadow( vec3 ro,  vec3 rd) {\n  float t = 0.02;\n  float tmax = 2.5;\n  float precis = 0.001;\n  float res = 1.0;\n  for(int i = 0; i < 32; i++) {\n    float h = mapDistance(ro + rd * t);\n    res = min(res, 20.0 * h / t);\n    t += clamp( h, 0.02, 0.10 );\n    if(h < 0.001 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal( vec3 pos) {\n  vec3 eps = vec3(0.001, 0.0, 0.0);\n  vec3 nor = vec3(\n      mapDistance(pos + eps.xyy) - mapDistance(pos - eps.xyy),\n      mapDistance(pos + eps.yxy) - mapDistance(pos - eps.yxy),\n      mapDistance(pos + eps.yyx) - mapDistance(pos - eps.yyx));\n  return normalize(nor);\n}\n\nfloat calcAO( vec3 pos,  vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for(int i = 0; i < 5; i++) {\n      float hr = 0.01 + 0.03 * float(i);\n      vec3 aopos = nor * hr + pos;\n      occ += (hr - mapDistance(aopos)) * sca;\n      sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0 * occ, 0.0, 1.0 );    \n}\n\nvec3 render( vec3 ro,  vec3 rd) {\n  vec3 col = vec3(0.5, 0.5, 0.5);\n  vec4 res = castRay(ro, rd);\n  TObj Obj;  \n  Obj=mObj;\n    \n  if(res.y >= 0.0) {\n    vec3 pos = ro + res.x * rd;\n    vec3 nor = calcNormal(pos);\n\n    vec3 ref = reflect( rd, nor );\n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize(vec3(-0.6, 0.7, -0.5));\n    float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float dif = clamp(dot(nor, lig), 0.0, 1.0);\n    float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0 ) * clamp( 1.0 - pos.y, 0.0, 1.0);\n    float dom = smoothstep(-0.1, 0.1, ref.y);\n    float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n    float spe = pow(clamp(dot(ref, lig), 0.0, 1.0),16.0);\n        \n    dif *= softshadow(pos, lig);\n    dom *= softshadow(pos, ref);\n\n    vec3 colorobj= getSphereColor(int( Obj.tipo));  \n      \n    vec3 lin = vec3(0.0);\n    lin += 1.20 * dif * colorobj;\n    lin += 1.20 * spe * colorobj * dif;\n    lin += 0.20 * amb * colorobj* occ;\n    lin += 0.30 * dom * colorobj* occ;\n    lin += 0.30 * bac * colorobj* occ;\n    lin += 0.40 * fre * colorobj* occ;\n\n    \n      col = (res.yzw * lin)/1.5;\n  }\n\n  return clamp(col, 0.0, 1.0);\n}\n\n\nmat3 setCamera(  vec3 ro,  vec3 ta, const float cr ){\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr),0.0);\n  vec3 cu = normalize( cross(cw,cp) );\n  vec3 cv = normalize( cross(cu,cw) );\n  return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n  vec2 p = -1.0 + 2.0 * q;\n  p.x *= iResolution.x / iResolution.y;\n  vec2 mo = iMouse.xy / iResolution.xy;\n  float time = 15.0 + iTime;\n\n  // camera \n  //vec3 ro = SHADERTOY_ZOOM * vec3( -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x), 1.0 + 2.0 * mo.y, 0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n \n // vec3 ro  =vec3(0.0,3.0,10.-cos(0.1 * time + 6.0 ));\n  vec3 ro = vec3(0, 2.5, 1.5+1.5*sin(iTime));  \n    \n  vec3 ta = vec3(-0.5, 0.4, 0.5);\n\n  // camera-to-world transformation\n  mat3 ca = setCamera(ro, ta, 0.0);\n\n  // ray direction\n  \n        \n\tvec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n\n  fragColor = vec4(render(ro, rd), 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}