{"ver":"0.1","info":{"id":"ldGXzw","date":"1463443240","viewed":411,"name":"Mandelbrot convergence dance","username":"stduhpf","description":"A visualisation of the convergence at each iteration in the mandelbrot set.With music. And colors.\nNote: with few changes, you can draw the buddabrot fractal with this techenique.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["complex","maths"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Code in buf A\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor =texture(iChannel0,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int n = 64;\nconst float seed = 10.4542;\n\nvec2 csqr(vec2 a)\n{return vec2(a.x*a.x-a.y*a.y,2.*a.x*a.y);}\n\nfloat rand(vec2 co)\n{\n    return fract(seed+sin(seed+co.y*seed+co.x*dot(co,vec2(12.9898,78.233)))*43758.5453);\n}\nvec2 grad(vec2 co){\n    return vec2(rand(co),rand(vec2(2,3)*co.yx+.5));\n        }\nfloat perlin(vec2 uv)\n{\n    vec2 relco = fract(uv);\n    vec2 inco = floor(uv);\n    \n    vec2 grad1 = grad(inco);\n    vec2 grad2 = grad(inco+vec2(1,0));\n    vec2 grad3 = grad(inco+vec2(1,1));\n    vec2 grad4 = grad(inco+vec2(0,1));\n    \n    float s = dot(grad1,relco);\n    float t = dot(grad2, relco-vec2(1,0));\n    float u = dot(grad3, relco-1.);\n    float v = dot(grad4, relco-vec2(0,1));\n    \n    float n1 = mix(s,t,smoothstep(0.,1.,relco.x));\n    float n2 = mix(v,u,smoothstep(0.,1.,relco.x));\n\n    return mix(n1,n2,smoothstep(0.,1.,relco.y));\n}\nfloat fbm(vec2 co)\n{\n    mat2 r = mat2(0.69670670934,-0.7173560909,0.7173560909,0.69670670934);\n    float f = .5*perlin(co);co*=r*2.02;\n    f += .25*perlin(co);co*=r*2.01;\n    f += .125*perlin(co);co*=r*2.03;\n    return f + .0625*perlin(co);\n}\n                \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 back = texture(iChannel0,fragCoord/iResolution.xy);\n    vec2 uv = fragCoord/iResolution.y;\n    uv = 3.*(uv-vec2(.5+(iResolution.x-iResolution.y)/(2.*iResolution.y),.5));\n    \n    vec4 col = vec4(0);\n    vec2 z = vec2(0);\n    float beat = texture(iChannel1,vec2(0.2,0)).r;\n    //beat*=0.;//do disable the dance\n    float mov = iTime*.1+(beat-.5)*.2;\n    vec2 c = vec2(15,5)*vec2(fbm(vec2(mov+beat/20.)),fbm(vec2(6.1,5.)+mov-beat/20.))-vec2(.5,.2);\n    // c = 3.*(iMouse.xy/iResolution.y-vec2(.5+(iResolution.x-iResolution.y)/(2.*iResolution.y),.5));\n    float f = 0.;\n    \n    for(int i = 0;i<n;i++)\n    {    \n        z = csqr(z)+c;\n        if (distance(z,uv)<(.025))col.rgb+=normalize(abs(vec3(rand(vec2(f,seed)),rand(vec2(seed,f)),rand(vec2(seed+f)))));\n        f++;\n    }\n    \n    fragColor = back*.9+col;\n    fragColor = min(fragColor,normalize(fragColor));\n}","name":"Buf A","description":"","type":"buffer"}]}