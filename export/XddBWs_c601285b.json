{"ver":"0.1","info":{"id":"XddBWs","date":"1527259653","viewed":714,"name":"Hyperspace Travel","username":"noxbuds","description":"My attempt at making the cool sci-fi hyperspace effects in space movies.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////\n//                                             //\n//                 CONSTANTS                   //\n//                                             //\n/////////////////////////////////////////////////\n#define PI 3.14\n#define TA 6.28\n#define PH 1.57\n\n/////////////////////////////////////////////////\n//                                             //\n//              NOISE GENERATION               //\n//                                             //\n/////////////////////////////////////////////////\n\n// 2D value noise\nfloat noisev(vec2 p)\n{\n    return fract(sin(p.x * 1234.0 + p.y * 2413.0) * 5647.0);\n}\n\n// Smoother noise\nfloat noise(vec2 uv)\n{\n    // Noise vector\n    vec2 nv = vec2(0.0);\n    \n    // Local positions\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    // Interpolate lv\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    \n    // Calculate each corner\n    float bl = noisev(id);\n    float br = noisev(id + vec2(1, 0));\n    float tl = noisev(id + vec2(0, 1));\n    float tr = noisev(id + vec2(1, 1));\n    \n    // Interpolate values\n    float b = mix(bl, br, lv.x);\n    float t = mix(tl, tr, lv.x);\n    float n = mix(b, t, lv.y);\n    \n    // Return n\n    return n;\n}\n\n// FBM function\nfloat fbm(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= 2.01;\n    f += 0.2500 * noise(p+vec2(0.0, 1.0)); p *= 2.02;\n    f += 0.1250 * noise(p+vec2(1.0, 0.0)); p *= 2.03;\n    f += 0.0625 * noise(p+vec2(1.0, 1.0)); p *= 2.04;\n    f /= 0.9375;\n    return f;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//             HYPERSPACE EFFECT               //\n//                                             //\n/////////////////////////////////////////////////\n\n// Calculates the hyperspace tunnel at uv\nvec3 tunnel(vec2 uv)\n{\n    // Setup colour\n    vec3 col = vec3(0.0);\n    \n    // Calculate polar co-ordinates\n    float r = 0.5 / length(uv) + iTime;\n    float mr = mod(r + 1000.0, 700.0);\n    if (mr < 400.0)\n        mr += 400.0;\n    float theta = atan(uv.x, uv.y);\n    \n    // Calculate the colour\n    // Convert the new polar co-ordinates to cartesian\n    vec2 ptc = vec2(mr * cos(theta / TA), mr * sin(theta / TA));\n    \n    // Then create some noise\n    float snv = fbm(ptc * 2.0);\n    if (snv > 0.8)\n        col = vec3(1.0);\n    \n    // Then make the tunnel. Use two noise values,\n    // which are mirrors of each other. Use a small\n    // value added to theta to prevent artifacts.\n    float fbm1 = fbm(vec2( r, mod(theta + 0.001, PI) ));\n    float fbm2 = fbm(vec2( r, PI - mod(theta - 0.001, PI) ));\n    \n    // Change fbm1 and fbm2 to make more contrast\n    fbm1 = pow(fbm1, 2.0);\n    fbm2 = pow(fbm2, 2.0);\n    \n    // More mirrored noise for colouring\n    float fbm3 = fbm(vec2( r, mod(theta + 0.001, PI) ) * 2.0);\n    float fbm4 = fbm(vec2( r, PI - mod(theta - 0.001, PI) ) * 2.0);\n    \n    // Colours for the tunnel\n    vec3 tc1 = vec3(0.0, 1.0, 0.5);\n    vec3 tc2 = vec3(0.0, 0.5, 1.0);\n    \n    // Set the noise value based on the angle\n    if (theta > 0.0)\n    \tcol = mix(col, mix(tc1, tc2, fbm4), fbm2);\n    else\n        col = mix(col, mix(tc1, tc2, fbm3), fbm1);\n    \n    // Return colour\n    return col;\n}\n\n// Calculates the pixel at uv\nvec3 calcPixel(vec2 uv)\n{\n    // Correct the UV co-ordinates\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Setup colour\n    vec3 col = vec3(0.0);\n    \n    // Draw the tunnel\n    col = tunnel(uv);\n    \n    // Return colour\n    return col;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//              IMAGE PROCESSING               //\n//                                             //\n/////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Setup colour\n    vec3 col = vec3(0.0);\n    \n    // Do some supersampling\n    for (float x = -1.0; x < 2.0; x += 0.5)\n    {\n        for (float y = -1.0; y < 2.0; y += 0.5)\n        {\n            // Calculate pixel here\n            vec3 pixel = calcPixel((fragCoord + vec2(x, y)) / iResolution.xy);\n            \n            // Add it, and make a bloom effect\n            col += pixel;\n        }\n    }\n    \n    // Average it out\n    col /= 16.0;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}