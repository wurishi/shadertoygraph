{"ver":"0.1","info":{"id":"3ldSRj","date":"1581355185","viewed":131,"name":"Brickwork patterns","username":"mdv","description":"Support for different patterns of Bricks.  -  Same code as my 'Bricks 2'   but with support for different layouts\n\nSet  'BRICK_PATTERN'  in code to compile different patterns.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","brick"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//--------------------------------------------------------------------------------------------------------------------------------------//  Brick wall with self-shadowing.\n//\n//  set BRICK_PATTERN   to select the pattern to compile  ( or add more patterns...)\n//\n//  The surface is seen as an array of tesselating rectangular cells. \n//  Each cell has a series of entries. Each entry represents a single brick (0,0)  to  shiftAndSizes[entry].zw  in the cell corner. \n//  shiftAndSizes[entry].xy  has the offset of the cell, for that entry  (cells effectively overlap per entry).\n//\n//  This enables the definition of different brick patterns.\n//  \n//  \n//  CELLSIZEU and CELLSIZEV are set for the pattern.  If we add to these, we space the cells out.\n//\n//  All code, feel free to use, abuse and improve...\n//\n//  'BRICK_PATTERN'   set this for a few simple patterns I set up - 0,1,2,3.  \n//   \n//--------------------------------------------------------------------------------------------------------------------------------------\n\n#define  USE_SHADOW \n#define  BRICK_PATTERN 3\n\n// LIGHT_DIRECTION:   y  is  negative as coming from ABOVE.\n//                    (  y close to 0  has numerical stability issues for shadow  (ie. light straight down).\n//                      producing sparkle on brick edges. )\n\nconst vec3   LIGHT_DIRECTION =  normalize(vec3(  0.917,  -0.62,  -0.4 ));  \nconst float  LIGHT_AMBIENT_INTENSITY = 0.5f;   \n\n // TODO:   have brick sizes per 'shiftAndSizes' entry.  More than one entry can have the same 'V' offset so should be easy\n //         to have mixed size bricks on one row.  This would make it possible to do herringbone etc.  \n \n#if BRICK_PATTERN == 0\t\t// regular brick\n\n\tconst float BRICK_ULEN = 0.1; \n\tconst float BRICK_UGAP = 0.05;\n\n\tconst float BRICK_VLEN = 0.35; \n\tconst float BRICK_VGAP = 0.05; \n\n\tconst int maxLayers = 2;\n\tconst vec4 shiftAndSizes[maxLayers] = vec4[]\n\t(\n      vec4( 0, 0,     BRICK_ULEN, BRICK_VLEN ),  \n      vec4( BRICK_ULEN + BRICK_UGAP, 0.5 * (BRICK_VLEN + BRICK_VGAP ),  BRICK_ULEN, BRICK_VLEN ) \n\t);\n  \n\tconst float CELLSIZEU  = (BRICK_ULEN + BRICK_UGAP ) * 2.0 + 0.001;\n\tconst float CELLSIZEV  = (BRICK_VLEN + BRICK_VGAP ) + 0.001;\n\tconst float  DepthOfBrick = 0.04439;\n\n#elif BRICK_PATTERN == 1      //  short and long alternate\n  \n\tconst float BRICK_ULEN = 0.1; \n\tconst float BRICK_UGAP = 0.05;\n\n\tconst float BRICK_VLEN = 0.35; \n\tconst float BRICK_VGAP = 0.05; \n\tconst float BRICK_VLEN_SHORT = 0.11 ;\n\n\n\tconst float dispIn = (BRICK_VGAP + BRICK_VLEN_SHORT) * 0.5 ; \n\tconst int maxLayers = 4;\n\tconst vec4 shiftAndSizes[maxLayers] = vec4[]\n\t(\n      vec4( 0, 0,   BRICK_ULEN, BRICK_VLEN_SHORT), \n      vec4( 0, BRICK_VLEN_SHORT + BRICK_VGAP,  BRICK_ULEN, BRICK_VLEN ), \n      vec4( BRICK_ULEN + BRICK_UGAP,  dispIn,  BRICK_ULEN, BRICK_VLEN ) ,\n      vec4( BRICK_ULEN + BRICK_UGAP, dispIn + BRICK_VLEN  + BRICK_VGAP,    BRICK_ULEN, BRICK_VLEN_SHORT ) \n\t);\n \n\tconst float CELLSIZEU  = (BRICK_ULEN + BRICK_UGAP ) * 2.0 + 0.001;\n\tconst float CELLSIZEV  = (BRICK_VLEN + BRICK_VGAP ) + (BRICK_VLEN_SHORT + BRICK_VGAP ) + 0.001;\n\tconst float  DepthOfBrick = 0.04439;\n\n#elif BRICK_PATTERN == 2        // square cycle\n  \n\tconst float SCL = 0.8;\t// scale to what looks pretty...\n\tconst float BRICK_SA = 0.1 * SCL;\n\tconst float BRICK_SB = 0.05* SCL;\n\tconst float BRICK_SC = 0.25* SCL;\n    const float BRICK_SD = 0.05* SCL; \n    \n\tconst int maxLayers = 4;\n\tconst vec4 shiftAndSizes[maxLayers] = vec4[]\n\t(\n      vec4( 0, 0, BRICK_SC, BRICK_SA ), \n      vec4( 0,                    BRICK_SA + BRICK_SB, BRICK_SA, BRICK_SC  ) , \n      vec4( BRICK_SA + BRICK_SB,  BRICK_SA + BRICK_SB +  BRICK_SC - BRICK_SA,   BRICK_SC, BRICK_SA ) ,  \n      vec4( BRICK_SC + BRICK_SB, 0,  BRICK_SA, BRICK_SC ) \n\t);\n \n\tconst float CELLSIZEU  =  BRICK_SA + BRICK_SB  +  BRICK_SC + BRICK_SD  + 0.001;\n\tconst float CELLSIZEV  =  BRICK_SA + BRICK_SB  +  BRICK_SC + BRICK_SD  + 0.001; \n\tconst float  DepthOfBrick = 0.04439; \n\n#elif BRICK_PATTERN == 3        // square cycle staggered\n  \n\tconst float SCL = 0.65;// scale to what looks pretty...\n\tconst float BRICK_SA = 0.1 * SCL;\n\tconst float BRICK_SB = 0.05* SCL;\n\tconst float BRICK_SC = 0.25* SCL;\n    const float BRICK_SD = 0.05* SCL; \n  \n\tconst float staggerU = (BRICK_SA + BRICK_SB  +  BRICK_SC + BRICK_SD);\n\tconst float staggerV = (BRICK_SA + BRICK_SB  +  BRICK_SC + BRICK_SD) * 0.5;\n\n\tconst int maxLayers = 8;\n\tconst vec4 shiftAndSizes[maxLayers] = vec4[]\n\t(\n      vec4( 0, 0, BRICK_SC, BRICK_SA ), \n      vec4( 0, BRICK_SA + BRICK_SB, BRICK_SA, BRICK_SC  ) , \n      vec4( BRICK_SA + BRICK_SB,  BRICK_SA + BRICK_SB +  BRICK_SC - BRICK_SA,   BRICK_SC, BRICK_SA ) ,  \n      vec4( BRICK_SC + BRICK_SB, 0,  BRICK_SA, BRICK_SC ),\n        \n      vec4( staggerU, staggerV, BRICK_SC, BRICK_SA   ), \n      vec4( staggerU, BRICK_SA + BRICK_SB + staggerV, BRICK_SA, BRICK_SC  ) , \n      vec4( staggerU + BRICK_SA + BRICK_SB,  BRICK_SA + BRICK_SB +  BRICK_SC - BRICK_SA + staggerV,   BRICK_SC, BRICK_SA  ) ,  \n      vec4( staggerU + BRICK_SC + BRICK_SB, staggerV,  BRICK_SA, BRICK_SC) \n\t);\n \n\tconst float CELLSIZEU  =  2.0 * (BRICK_SA + BRICK_SB  +  BRICK_SC + BRICK_SD)  + 0.001;\n\tconst float CELLSIZEV  =  (BRICK_SA + BRICK_SB  +  BRICK_SC + BRICK_SD)  + 0.001;\n\tconst float  DepthOfBrick = 0.035; \n #endif\n\n\nconst float  y0 =  -0.43;  \n\nconst float  xLo =  - 1.2; \nconst float  xHi =    1.56;\nconst float  zLo =    0.48;  //-2.0; \nconst float  zHi =    2.22;\n\n\n\t// colors per face. For testing\n\nconst vec3 colr0[5] = vec3[]\n(\n    vec3(0,0,0),\n    vec3(1,0.5,0),  \n\tvec3(0.2,0.3,0.4),  \n\tvec3(1,0,0),\n\tvec3(0.7,0.5,0.39)  // 4 is mortar \n); \nconst vec3 colr1[5] = vec3[]\n(\n    vec3(0,0,0),\n    vec3(0.85,0.5 ,0.44 ), \n    vec3(1,0.5,0),  \n\tvec3(0.8,0.5,0.2),\n\tvec3(0.7,0.5,0.39)  // 4 is mortar \n);   \n\nfloat  RECIP_CELLSIZEU = 1.0 / CELLSIZEU;\nfloat  RECIP_CELLSIZEV = 1.0 / CELLSIZEV;  \n\nconst float  y1 =  y0 - DepthOfBrick;\n\nconst vec4 boundsA = vec4(zLo, -zHi, xLo, -xHi );\nconst vec4 boundsB = vec4(-1.0, 1.0, -1.0, 1.0);\n\n\t// FPT limits, needed for ensuring numerical stability as ray axes approach alignment with the world space.\n    //  https://en.wikipedia.org/wiki/IEEE_754-1985\n\nconst float SMALLEST_POSITIVE_IEEE754_FPT =  intBitsToFloat(1); // ±2^−23 × 2^−126  are closest representable numbers to 0\nconst float BIGGEST_IEEE754_FPT = \tintBitsToFloat(0x7F7FFFFF);  \n\n// Fed up with typing  'clamp(..., 0.0, 1.0)'   when we know it will go to a saturate and\n// probably get it for free on the GPU.\n\nfloat saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\nvec2 saturate(vec2 x)\n{\n    return clamp(x, 0.0, 1.0);\n}\nvec3 saturate(vec3 x)\n{\n    return clamp(x, 0.0, 1.0);\n} \nvec4 saturate(vec4 x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nfloat random2(vec2 st)\n{\n    // Quick random-ish used for determining a random scalar for a brick (for color, etc.)\n    //  modded from hash function at:    https://www.shadertoy.com/view/XlXcW4\n    //  ( taken one xor line,  good enough for this test! )\n     \n    uint  a = floatBitsToUint(st.x);\n    uint  b = floatBitsToUint(st.y);\n    \n    float h = float(((a>>8U)^b)*1103515245U) / float(0xffffffffU); \n    return h;              \n} \n\t\n\nint BrickWall( in vec3 ro, in vec3 rd,  out bool inShadow, out vec3 normal,  out vec2 idx,  inout vec3 posn)  \n{  \n    inShadow = false;\n    normal = vec3(0.0, -1.0, 0.0);\n    idx = vec2(0);\n    posn = vec3(0); \n     \n    float t0 =  ( -ro.y + y0) *  rd.y; \n    float t1 =  ( -ro.y + y1) *  rd.y;\n    \n    float sum = t0 + t1;\n    t0 = min(t0,t1);\n    \n    if( t0 < 0.0 )     // early out if intersection is behind camera\n        return 0;\t\t\n    \n    t1 = sum - t0;  \t\t\n    vec3  rd2 = rd * rd;  \n    vec3  intersect0 = ro * rd2.y + t0 * rd;\n    \n \t// NOTE:  if rd.y == 0  (ie. ray is coplanar, then  intersect0 == 0, and the bounds test passes, (if we had used the\n    // nieve approach, then  intersect0 would approach infinity as rd.y approaches 0, because we would be using 1/rd.y - \n    // but we multiply up by rd.y^2  to avoid divisions AND maintain the inequality tests.\n    //  (In the case of rd2.y very close to 0, then early out). \n    \n    if( rd2.y <  SMALLEST_POSITIVE_IEEE754_FPT )   // consider ray as coplanar,  rd2.y = y^2 so always +ve \n        return 0;\n    \n    \n    if( dot(saturate( boundsA * rd2.y + intersect0.zzxx * boundsB ), vec4(1.0)) !=  0.0 )\n    {\n         return 0;   \n    }\n    \n    float bestFaceCode = 4.0;\t\t// Default to Mortar\n    \n    float  recip_rd2y = 1.0 / rd2.y;    \n    intersect0 *= recip_rd2y;    // We have already checked that rd2.y >=  SMALLEST_POSITIVE_IEEE754_FPT,  above\n    \n    // Early out on brick face, no need to test anything else if ray intersects the main face of a brick. \n    \n    for( int layer = 0; layer < maxLayers; ++layer)\n    {\n        vec4 ss = shiftAndSizes[layer]; \n    \n        vec2 fufv   = floor((intersect0.xz - ss.xy ) * vec2(RECIP_CELLSIZEU, RECIP_CELLSIZEV)); \n    \tvec2 cellUV = fufv  * vec2(CELLSIZEU, CELLSIZEV) + ss.xy ; \n        \n        vec2 a = saturate( intersect0.xz - cellUV.xy -  ss.zw );\n        if ((a.x + a.y) == 0.0)  \n    \t{\n       \t \t // brick face \n            idx =  fufv + float(layer) ; \n            posn = intersect0;\n            return 3;\n    \t}\n    }\n        \n    // Deal with sides and ends of brick.\n     \n    float rdxrdz = rd.x * rd.z;\n    float rdxrdz2 = rdxrdz * rdxrdz; \n    vec2 C01 =  rdxrdz * rd.zx; \n    vec2  C4  = vec2(y0,y1) * rdxrdz2 ;  \n    \n    \n    // +/- 1 depending on half-space for each axis X, Z\n    \n    vec2 hsPlusMinus =  vec2 (  ( rd.x >= 0.0 ) ? 1.0 : -1.0 ,  ( rd.z >= 0.0 ) ? 1.0 : -1.0 );    \n    \n    float bestT = BIGGEST_IEEE754_FPT;  \n      \n    vec2  F01 = vec2(CELLSIZEU, CELLSIZEV) * C01 ; \n    vec2  D01 = -(vec2(CELLSIZEU,CELLSIZEV) + ro.xz ) * C01; \n    \n    float bestSy = 0.0;\n    vec2  fl2 =  vec2(CELLSIZEU, CELLSIZEV); \n    \n    float S1 =  ro.y * rdxrdz2;\n    vec4  vecE0E1 = vec4( 0.0, 1.0,  0.0, 1.0); \n    if( C01.x < 0.0 )\n        vecE0E1.xy = vec2(1.0, 0.0);\n    if( C01.y < 0.0 )\n        vecE0E1.zw = vec2(1.0, 0.0); \n    \n    vec4 C5 = vecE0E1 * C01.xxyy;\n    \n    for( int layer = 0; layer < maxLayers; ++layer)\n    {\n        vec4  ss = shiftAndSizes[layer]; \n         \n        vec4 sortOffset = C5 * ss.zzww; \n        \n        vec2 fufv = floor((intersect0.xz - ss.xy ) * vec2(RECIP_CELLSIZEU, RECIP_CELLSIZEV));  \n   \n    \tvec2 cellUV = fufv * vec2(CELLSIZEU, CELLSIZEV) + ss.xy ;\n       \n        vec2 currentIdx =  fufv  +  fl2 ;  \n        float dIdxV = currentIdx.y;\n          \n        vec2 dudvYstart = cellUV.y * C01.y + D01.y + sortOffset.zw; \n        \n        vec4 t;\n        t.xy = cellUV.x * C01.x + D01.x  + sortOffset.xy; \n        for( int u = 0; u < 3; u++ )\n        {  \n            currentIdx.y = dIdxV ;\n            currentIdx.x++; \n            t.zw  = dudvYstart;       \n            for(int v = 0; v  < 3; v++ )\n            {\n                //  s is an associated value for tv,  so that we know after ordering  tv, whether a line segment\n                //  crosses / intersects a cell   ( when s.x != s.y ).\n                               \n                currentIdx.y++;\n                \n        \t\tvec4 tv = t;\n                vec3 s =  vec3(0.0,0.0,1.0);\n                 \n                if(tv.x > tv.z) { tv.z = tv.x; s.xz = vec2(1.0, 0.0);  }  \n   \t\t\t\tif(tv.y > tv.w) { tv.y = tv.w; s.y = 1.0;   } \n   \t\t\t\tif(tv.y > tv.z) { tv.y = tv.z; s.y = s.z;  }  \n      \n    \t\t\tfloat ds = s.x - s.y;\n                float p =  S1 + tv.y * rd.y;  \n                  \n    \t\t\tif( (  \n                     saturate(1.0 - ds*ds) + \n                     saturate( tv.y - bestT) +  \n                     saturate( p  - C4.x ) +  \n                     saturate( C4.y - p  )) == 0.0)\n            \t\t{  \n                  \t\tbestT = tv.y; \n                        bestSy =  s.y; \n                        idx =  currentIdx;    \n            \t\t}\n            \n                 t.zw += F01.y;\n            }\n            t.xy += F01.x; \n        }\n        fl2 += float(maxLayers); \n    } \n    \n    if( bestT != BIGGEST_IEEE754_FPT )\n    {\n\t\tnormal = vec3( hsPlusMinus.x * (1.0 -bestSy), 0.0, hsPlusMinus.y * bestSy  ) ;  \n        bestFaceCode = bestSy + 1.0;  \n    }\n\n    // Trim edge    \n    \n   if (bestFaceCode != 4.0)\n   {  \n        rd2.y = rdxrdz2;\n        t1 = bestT; \n   }\n    \n   vec3  coord = ro  * rd2.y + t1 * rd;  // ray intersection point multiplied by rd2.y,  ie. ray-direction 'y' squared\n    \n   if( dot(saturate( boundsA * rd2.y + coord.zzxx * boundsB ), vec4(1.0)) !=  0.0 )\n   {\n        return 0;   \n   } \n    \n   #if defined(USE_SHADOW)\n   \n    // If light source is from behind wall,  or behind a brick end or side, then always in shadow..\n    \n    bool  shadow = ((saturate( LIGHT_DIRECTION.y )  + saturate( -dot( normal.xz, LIGHT_DIRECTION.xz ))  ) != 0.0);\n    \n     // Otherwise examine adjacent cells for projecting the eye ray intersection point along the reverse light direction\n     // (Since all edges are vertical in the plane, we only need to detect the XZ ray crossing the brick area of a cell.\n    \n    if( !shadow)\n    { \n         float t0 =  ( y0 * rd2.y -coord.y ) ; \n         intersect0.xz = coord.xz - t0 * LIGHT_DIRECTION.xz; \n        \n         float rdxrdz = LIGHT_DIRECTION.x * LIGHT_DIRECTION.z; \n    \t vec2  C01    =  -rdxrdz * vec2( LIGHT_DIRECTION.z, LIGHT_DIRECTION.x); \n         float rdxrdz2   = rdxrdz * rdxrdz * rd2.y; \n         float G1 = rdxrdz2 * rd2.y;\n    \t vec2  C4  = vec2(y0,y1) * G1 ; \n     \n   \t     vec2 hsPlusMinus =  vec2 (  ( LIGHT_DIRECTION.x <= 0.0 ) ? 1.0 : -1.0 ,  ( LIGHT_DIRECTION.z <= 0.0 ) ? 1.0 : -1.0 );   \n      \n    \t vec2  D01 = -(vec2(CELLSIZEU, CELLSIZEV)  * rd2.y + coord.xz) * C01; \n         vec3  G0 = -LIGHT_DIRECTION * rd2.y;   //-ve to allow + in loop,  easier to mad\n         vec4  S0 = boundsA * G1;\n         vec3  S1 = coord * rdxrdz2;\n          \n        vec4  vecE0E1 = vec4( 0.0, 1.0,  0.0, 1.0); \n    \tif( C01.x < 0.0 )\n        \tvecE0E1.xy = vec2(1.0, 0.0);\n    \tif( C01.y < 0.0 )\n        \tvecE0E1.zw = vec2(1.0, 0.0); \n        \n         vec2  C23 = C01  * rd2.y;  \n    \t vec2  F10 = vec2(CELLSIZEU, CELLSIZEV) * C23 ;  \n         vec4  C5 = C23.xxyy * vecE0E1; \n        \n         intersect0 /= rd2.y;\n    \t for( int layer = 0; layer < maxLayers; ++layer)\n    \t {\n        \tvec4 ss = shiftAndSizes[layer];\n       \t\t  \n            vec4 sortOffset = C5 * ss.zzww;\n    \t\tfloat fu = (intersect0.x - ss.x ) * RECIP_CELLSIZEU;\n    \t\tfloat fv = (intersect0.z - ss.y ) * RECIP_CELLSIZEV; \n    \n    \t\tfloat cellU = floor(fu ) * CELLSIZEU + ss.x ;\n    \t\tfloat cellV = floor(fv ) * CELLSIZEV + ss.y ; \n            \n            vec2 dudvYstart = cellV * C23.y + D01.y + sortOffset.zw;\n\n            vec4 t ; \n            t.xy =  cellU * C23.x + D01.x  + sortOffset.xy;\n        \tfor( int u = 0; u < 3; u++ )\n        \t{   \n                t.zw  = dudvYstart; \n               \tfor(int v = 0; v  < 3; v++ )\n            \t{  \n        \t\t\tvec4 tv = t;  //  tv.x <=  tv.y,    tv.z <= tv.w\n                \tvec3 s =  vec3(0.0,0.0,1.0);\n                   \n                \tif(tv.x > tv.z) { tv.z = tv.x; s.xz = vec2(1.0, 0.0);  }  \n   \t\t\t\t\tif(tv.y > tv.w) { tv.y = tv.w; s.y = 1.0;   } \n   \t\t\t\t\tif(tv.y > tv.z) { tv.y = tv.z; s.y = s.z;  }    \n                    \n                    float ds = s.x - s.y;\n                    vec3  p  = S1 + tv.y * G0;   \n                    vec4  a  = saturate( S0 + p.zzxx * boundsB ); \n                    \n                    // could break out as soon as shadow is true.  probably worth doing (wavefronts ? )\n                    \n                    shadow = shadow ||\n    \t\t\t\t   ( \n                         (saturate(1.0 - ds*ds) + \n                          saturate( -tv.y ) +  \n       \t\t\t\t      saturate(  p.y - C4.x ) +\n                          saturate(  C4.y - p.y ) +\n                          a.x + a.y + a.z + a.w               // using dot(a,vec4(1.0)) is not good on GCN chips.\n                         ) == 0.0\n                       ) ;\n                     \n                \tt.zw += F10.y;\n            \t}   \n            \tt.xy += F10.x;\n        \t} \n    \t}  \n    } \n    inShadow = shadow;\n    \n   #endif\n     \n   posn = coord / rd2.y;\n    \n   return int(bestFaceCode);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) *  vec2(iResolution.x/iResolution.y, 1.0);\n    \n\tvec3 ro;\n    ro.y = -0.2;\n  \n    vec2 maxSpan = vec2( xHi - xLo, zHi - zLo ) * 0.4; \n    \n    float pt = iTime;\n    ro.x = xLo + (  xHi - xLo) * 0.5 + sin(pt * 0.2) * maxSpan.x;\n    ro.z = zLo + (  zHi - zLo) * 0.5 + cos(pt * 0.2) * maxSpan.y;\n    float theta = 1.4 + iMouse.x * 0.01;\n    float c = cos(theta);\n    float s = sin(theta);\n    mat2 rotn;\n    rotn[0][0] = c;\n    rotn[0][1] = -s;\n    rotn[1][0] =  s;\n    rotn[1][1] = c;\n    \n    vec3 dirn = vec3(uv,1.0) ;\n    dirn.xz *= rotn; \n    \n    \t// Now do something more interesting....\n    bool inShadow = false;\n    vec3 normal = vec3(0); \n    vec3 posn = vec3(0); \n    \n    vec2 idx;   \n       \n    int faceCode = BrickWall( ro, normalize(dirn), inShadow, normal,  idx, posn);   \n        \n    float idCoeff = random2( idx.xy *  1.2341 ); \n    \n    \t// Apply the color,  simple dp lighting and darken if the point is in shadow,\n    \n    vec4  faceColor  =  vec4(  mix(colr0[faceCode], colr1[faceCode],idCoeff) , 1.0 );  \n    \t\t\t\t\t \n    if( faceCode != 0)\t\t// Do not light if not on wall surface \n    {\n   \t \tfloat intensity =  mix( LIGHT_AMBIENT_INTENSITY, 1.0, clamp(dot(normal, LIGHT_DIRECTION), 0.0, 1.0) ) ;\n   \t \tfaceColor.xyz *= intensity;\n    \tif(inShadow)\n    \t{\n       \t \tfaceColor.xyz *= 0.6;   \n   \t\t} \n    }  \n       \n    fragColor = faceColor; \n     \n}","name":"Image","description":"","type":"image"}]}