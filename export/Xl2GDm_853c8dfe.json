{"ver":"0.1","info":{"id":"Xl2GDm","date":"1429613478","viewed":2121,"name":"Squircles go to the disco!","username":"gouky","description":"Not the cleanest code ever... ** Not for epileptic! **\n\n#TeamSquircle \n","likes":18,"published":1,"flags":0,"usePreview":1,"tags":["lighting","disco","squircle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","previewfilepath":"/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"//\n// #TeamSquircle\n//\n#define PI\t\t\t\t3.1415926535\n#define STEP_COUNT\t\t16\n#define EPS\t\t\t\t0.01\n\n#define ROTATE_LIGHT\t\t\t1\n#define DANCING_SQUIRCLES\t\t1\n\n// Smoke noise based on https://www.shadertoy.com/view/Mlj3W1\n#define ENABLE_SMOKE\t1\t// Change me!Change me!Change me!Change me!\n\nstruct\tSquircle\n{\n    vec3\tcolor;\n    float\td;\n    vec2\tuv;\n};\n\n#define SMOKE_MAX_STEPS  8\n#define SMOKE_MIN_STEP  0.010\n    \n// noise from iq's hell shader\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel1, (uv+ 0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z ) - 0.5;\n}\n\n///////////////////////////////\nfloat NoiseSample(vec3 orp)\n{\n    float t = iTime * 0.01;\n    float m = 0.0;\n    \n    vec3 uv = orp + vec3(t, 0.0, 0.0);\n    float n = noise(uv * 10.0) - 0.5;\n\n    uv = orp + vec3(t * 0.2, 0.0, 0.0);\n    n += noise(uv * 22.50) * 0.5;\n\n    uv = orp + vec3(t * 1.0, 0.0, 0.0);\n    n += noise(uv * 52.50) * 0.5;\n\n    uv = orp + vec3(t * 1.8, 0.0, 0.0);\n    n += noise(uv * 152.50) * 0.25;\n\n    return n;\n}\n\nfloat Smoke(in vec3 ro, in vec3 rd)\n{\n    vec3 rp = ro;\n    float smoke = 0.0;\n    \n    for (int i = 0; i < SMOKE_MAX_STEPS; ++i)\n    {\n        rp += rd * max(SMOKE_MIN_STEP, 0.0);\n        float h = NoiseSample(vec3(rp.xy, float(i)*1.5));\n        \n        smoke += abs(h);\n    }\n    \n    smoke /= float(SMOKE_MAX_STEPS+1);\n    \n    return smoke;\n}\n\n// shamelessly stolen from iq!\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nSquircle\tcheck(Squircle x, Squircle y)\n{\n    if(x.d <= y.d)\n        return x;\n    \n    return y;\n    //return x.d <= y.d ? x : y;\n}\n\nSquircle f(vec2 p, vec2 centre, float mult, float radius, float bias, float fft)\n{\n    Squircle ret;\n    \n    ret.color = vec3(1.0, 0.0, 1.0);\n    \n    float cosTheta = cos(iTime);\n    float sinTheta = sin(iTime);\n    \n    vec2 ab = p-centre;\n    \n    vec2 rotatedPos = vec2(ab.x * cosTheta - ab.y * sinTheta, ab.x * sinTheta + ab.y * cosTheta);\n    ab = rotatedPos;\n    \n#if DANCING_SQUIRCLES == 0\n    float power = 0.5 + 2.0*(1.0+sin(iTime+bias));\n#else\n    float power = 0.5 + 0.90*(sin((fft * (30.0+bias))+2.0)*0.5+0.5);\n#endif\n    \n    float dist = pow(abs(ab.x),power) + pow(abs(ab.y),power);\n   \n    ret.d = dist < pow(radius,power) ? EPS : 1.0;\n    ret.uv = vec2(\n            (abs(ab.x+radius) / radius*0.5),\n            (abs(ab.y+radius) / radius*0.5));\n   \t    \n    return ret;\n}\n\nSquircle SampleScene(in vec2 uv, in float fft)\n{\n    Squircle r;\n    \n    r.d = 100.0;\n    \n    vec2 pos;\n    \n    pos.x = cos(iTime)*0.5;\n    pos.y = sin(iTime)*0.5;\n    \n    r = check(r, f(uv, pos, 1.0, 0.15, 0.0, fft));\n\n    pos.x = cos(iTime+PI/2.0)*0.5;\n    pos.y = sin(iTime+PI/2.0)*0.5;\n    \n    r = check(r, f(uv, pos, 1.0, 0.15, 0.5, fft));\n   \n    pos.x = cos(iTime+PI)*0.5;\n    pos.y = sin(iTime+PI)*0.5;\n    \n    r = check(r, f(uv, pos, 1.0, 0.15, 1.0, fft));\n      \n    pos.x = cos(iTime-PI/2.0)*0.5;\n    pos.y = sin(iTime-PI/2.0)*0.5;\n    \n    r = check(r, f(uv, pos, 1.0, 0.15, 1.5, fft));\n   \n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 uv = -1.0 + 2.0 * q;\n    uv.x *= iResolution.x/iResolution.y;\n    \n\tvec3 color = vec3(0.0);\n    vec2 pos = vec2(0.0,0.0);\n    \n    float cosTheta = cos(iTime);\n    float sinTheta = sin(iTime);\n           \n\tfloat smoke = 1.0;\n\n#if ENABLE_SMOKE == 1\n    smoke = Smoke(vec3(0.0, 0.0, -1.1), vec3(uv, 1.0)) * 1.5;\n#endif\n    \n    //\t\n    float freqs = 0.0;\n\n    float weights[5];\n    weights[0] = 0.4;\n    weights[1] = 0.1;\n    weights[2] = 0.2;\n    weights[3] = 0.2;\n    weights[4] = 0.2;\n\n    //\tdirty approx.\n    freqs += texture( iChannel0, vec2( 0.01, 0.25 ) ).x * weights[0];\t\t// 0.01\n    freqs += texture( iChannel0, vec2( 0.25, 0.25 ) ).x * weights[1];\t\t// 0.07\n    freqs += texture( iChannel0, vec2( 0.50, 0.25 ) ).x * weights[2];\t\t// 0.15\n    freqs += texture( iChannel0, vec2( 0.75, 0.25 ) ).x * weights[3];\t\t// 0.30\n    freqs += texture( iChannel0, vec2( 0.99, 0.25 ) ).x * weights[4];\t\t// 0.30\n\n    float fft = freqs;///5.0;\n    fft += 0.5;\n\n    //\tScene\n    Squircle scene = SampleScene(uv, fft);    \n    \n    //\tlights\n    {\n        vec4 lightColor[5];\n    \tvec2 lightPos[5];\n        \n        lightPos[0] \t= vec2(0.0, 0.0);\n        lightPos[1] \t= vec2(1.0, 0.0);\n        lightPos[2] \t= vec2(-1.0, 0.0);\n        lightPos[3] \t= vec2(0.0, 1.0);\n        lightPos[4] \t= vec2(0.0,-1.0);\n        lightColor[0] \t= vec4(1.0, 0.2, 0.4, 0.1); \t//\t2.0\n        lightColor[1] \t= vec4(1.0, 1.0, 0.5, 0.5);\t\t//\t0.0\n        lightColor[2] \t= vec4(0.2, 1.0, 1.0, 0.5);\t\t//\t0.5\n        lightColor[3] \t= vec4(1.0, 0.2, 1.0, 1.2);\t\t//\t1.5\n        lightColor[4] \t= vec4(0.2, 1.0, 0.2, 1.2);\t\t//\t1.0\n\n#if ROTATE_LIGHT == 1        \n        lightPos[1].y = cos(iTime);\n        lightPos[1].x = sin(iTime);\n        lightPos[2].y = -cos(iTime);\n        lightPos[2].x = -sin(iTime);\n\t\tlightPos[3].y = -cos(PI*0.5+iTime);\n        lightPos[3].x = -sin(PI*0.5+iTime);\n\t\tlightPos[4].y = cos(PI*0.5+iTime);\n        lightPos[4].x = sin(PI*0.5+iTime);        \n#endif\n        \n        color = vec3(0.0);\n        for(int i = 0; i < 5; ++i)\n        {\n            vec2 rayOrigin = vec2(uv);\n            vec2 ray = lightPos[i] - rayOrigin;\n            float rayLength = length(ray);\n            vec2 rayDir = ray / rayLength;\n\n            float raySteps = rayLength / float(STEP_COUNT);\n\n            float acc = 0.0;\n            float t = 0.0;\n            float offset = hash(fragCoord.y*iResolution.x + fragCoord.x + iTime);\n\n            for(int stepIndex = 0; stepIndex < STEP_COUNT; stepIndex++)\n            {\n                vec2 P = rayOrigin + rayDir * (t + offset * 0.1);\n                float d = SampleScene(P, fft).d;\n\n                if(d <= EPS) \n                {\n                    acc += 1.0;\n                }\n\n                t += raySteps;\n            }\n\n            acc = acc/float(STEP_COUNT);\n            acc = clamp(1.0-acc, 0.0, 1.0);\n\n#if ENABLE_SMOKE == 1\n            smoke = scene.d <= EPS ? 1.0 : smoke * acc;\n#endif            \n            \n            const float maxAtten = 0.22;\t\t//0.2\n            \n            float attenDist = max(clamp(maxAtten*(sin((fft * 20.0)+lightColor[i].w)*0.5+0.5), 0.0, maxAtten), 0.01);\n            attenDist = i == 0 ? max(attenDist, 0.1) : attenDist;\n            float atten = (rayLength/attenDist);\n            \n            acc = acc / atten;\n\n            color += vec3(acc) * lightColor[i].xyz * smoke;// * color;\n        }\n    }\n    \n    // Squircles are the best!   \n    if(scene.d <= EPS)\n    {\n        vec2 squircleUv = scene.uv * 2.0 - 1.0;\n        float gradient = (1.0 - length(squircleUv) * 0.5);\n       \n        vec3 basecolor = mix(vec3(1.0, 0.2, 0.4), vec3(1.0, 1.0, 0.0), cos(iTime));\n        basecolor = color;//vec3(1.0);\n        color = vec3(gradient) * basecolor * 2.0;\n    }\n    \n    fragColor = vec4(color,1.0); \n}","name":"","description":"","type":"image"}]}