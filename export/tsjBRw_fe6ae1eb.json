{"ver":"0.1","info":{"id":"tsjBRw","date":"1590541319","viewed":188,"name":"RayMarching Coronavirus","username":"AlancitoBalanza","description":"Raymarching Test","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n#define MAXITER 100\n\nfloat sdSphere(vec3 pos, float rad) {\n    \n    //vec2 ang = vec2(atan(pos.y / length(pos.xz)), vec2(pos.z / pos.x));\n    vec3 norm = normalize(pos);\n    //Sphere UV mapping\n    //vec2 uv = vec2(0.5 + atan(norm.z/norm.x)/(2.0*PI), 0.5 - asin(norm.y)/PI);\n    vec2 uv = vec2(0.5 + atan(norm.z/norm.x)/(2.0*PI), 0.5 - asin(norm.y)/PI);\n    uv *= 30.0;\n    \n    float bump = sin(uv.x)*sin(uv.y);\n    //bump = abs(bump);\n    //float bump = sin(pos.x*10.0)*sin(pos.y*10.0)*sin(pos.z*10.0) * 0.5 + 0.5;\n    bump = pow(bump, 5.0);\n    bump *= 5.0;\n    bump = min(1.0, bump);\n    bump /= 5.0;\n\t//bump = 0.0;\n    return length(pos) - rad - bump;\n}\n\nfloat sdPlane(vec3 pos) {\n\treturn pos.y+sin(pos.x)+sin(pos.z);\n}\n\n\nfloat sceneDist(vec3 pos) {\n    \n    vec3 rep = mod(pos+2.0, 4.0)-2.0;\n    //vec3 rep = pos;\n    float sphere1 = sdSphere(rep-vec3(0.0, 0.0, 0.0), 1.0);\n    float d = sphere1;\n    //float sphere2 = sdSphere(pos-vec3(0.0, 0.75, 0.0), 0.1);\n    //d = min(d, sphere2);\n    //float sphere3 = sdSphere(pos-vec3(0.0, 0.0, 0.75), 0.1);\n    //d = min(d, sphere3);\n    float plane = sdPlane(pos-vec3(0, -10.0, 0));\n    d = min(d, plane);\n    d *= 0.6;\n\t//return min(sphere1, sphere2);\n\treturn d;\n}\n\nmat3 rotation(vec2 angles) {\n    mat3 id = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);\n    {\n        vec3 u = vec3(cos(angles.x), 0, sin(angles.x));\n        vec3 v = vec3(0, 1, 0);\n        vec3 w = vec3(-sin(angles.x), 0, cos(angles.x));\n        id = id * mat3(u, v, w);\n\t}\n    {\n        vec3 u = vec3(1, 0, 0);\n        vec3 v = vec3(0, cos(angles.y), -sin(angles.y));\n        vec3 w = vec3(0, sin(angles.y), cos(angles.y));\n        id = id * mat3(u, v, w);\n\t}\n    return id;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 lookingAngle = vec2(iTime, (sin(iTime)*0.5+0.5)*-PI/2.0*0.5);\n    //vec2 lookingAngle = vec2(iTime, 0);\n    //lookingAngle.x = iMouse.x / 100.0;\n    //lookingAngle.y = -iMouse.y / 100.0;\n    \n    mat3 rot = rotation(lookingAngle);\n    \n    vec3 pos = rot * vec3(0, 0, 1);\n    pos *= -10.0;\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 dir = rot * normalize(vec3(uv.xy, 2.5));\n    \n    bool collide = false;\n    int i;\n    for (i = 0; i < MAXITER && !collide; i++) {\n    \tfloat dist = sceneDist(pos);\n        if (dist < 0.0001)\n            collide = true;\n       \tif (dist > 1000.0)\n        {\n            i=MAXITER;\n\t        break;\n\t    }\n        pos += dir * dist;\n    }\n    vec3 col = vec3(float(i) / float(MAXITER));\n    bool lost = float(i) > 0.8*float(MAXITER);\n    /*\n    if (collide)\n        col = vec3(1.0);\n    else\n        col = vec3(0.0);\n*/\n    \n    //if (lost) col.x = 0.0;\n    //col = dir.zzz;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}