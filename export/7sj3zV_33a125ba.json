{"ver":"0.1","info":{"id":"7sj3zV","date":"1618539950","viewed":116,"name":"Monte Carlo Sample","username":"Yon","description":"Some step of my SH Visualize Practices\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["montecarlo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// From iq\n#define PI 3.14159\n\nmat3 camMat;\n\nfloat rnd(float seed) { return fract(sin(seed)*43758.5453123); }\n\nstruct ray{\n    vec3 ori;\n    vec3 dir;\n};\n\n//draw sphere,return hit pos\nfloat hit_sphere(vec3 center, float radius, ray r){\n    vec3 oc = r.ori - center;\n    float a = dot(r.dir,r.dir);\n    float b = 2.*dot(oc,r.dir);\n    float c = dot(oc,oc)- radius*radius;\n    float discriminant = b*b - 4.*a*c;\n    if (discriminant < 0.) {\n        return -1.0;\n    } else {\n        return (-b - sqrt(discriminant) ) / (2.0*a);\n    }\n}\n\nvec3 draw(ray r){\n    float t;\n    for(int i;i<=1024;i++){\n        float theta = 2.*acos(sqrt(1.-rnd(247.2297*float(i))));\n        float phi = 2.* PI *rnd(78.2834*float(i));\n\n        float x = sin(phi) * cos(theta);\n        float y = sin(phi) * sin(theta);\n        float z = cos(phi);\n        \n        vec3 cen_pos = vec3(0.,0.,0.);\n        \n        vec3 sample_pos = cen_pos + 0.7*vec3(x,y,z);\n        \n        t = hit_sphere(sample_pos,0.01,r);\n        if (t > 0.0) {\n        vec3 N = normalize (r.ori + r.dir*t - sample_pos);\n        vec3 light = vec3(-1.,-1.,0.);\n        vec3 color = vec3(dot(light,N)*0.5+0.5);\n        return color;\n        }   \n    }\n    \n    //BackGround\n    vec3 dir = normalize(r.dir);\n    t = 0.5*(dir.y + 1.0);\n    return (1.-t)*vec3(1.,1.,1.) + t*vec3(0.2,0.3,1.0);\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.yy;\n    \n    // Mouse\n    vec2 mo = vec2(0.0);\n    if (iMouse.z > 0.0) {\n        mo += (2.0 * iMouse.xy - iResolution.xy) / iResolution.yy;\n    }\n    // Camera position\n    float dist = 1.;\n    vec3 ro = vec3(dist * cos(iTime * 0.1 + 6.0 * mo.x), 2.0 + mo.y * 4.0, dist * sin(iTime * 0.1 + 6.0 * mo.x));\n    \n    // Rotate the camera\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    \n    // Compute the ray\n    camMat = setCamera(ro, target, 0.0);\n    vec3 rd = camMat * normalize(vec3(p.xy, 1.5));\n    \n    ray r;\n    r.ori = ro;\n    r.dir = rd;\n    \n    vec3 color = draw(r);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}