{"ver":"0.1","info":{"id":"fsKBzD","date":"1657766861","viewed":158,"name":"Strange Clouds","username":"westgarthb","description":"Warped clouds with FBM noise","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noise","clouds","fmb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const mat3 mtx = mat3( 0.80,  0.60, -0.60,  0.80 , -0.40, 0.60, 0.44, 0.65, 0.83);\n\nvec3 hash( vec3 p ) // replace this by something better. really. do\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat noise( in vec3 x )\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    \n    // gradients\n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    return va + \n           u.x*(vb-va) + \n           u.y*(vc-va) + \n           u.z*(ve-va) + \n           u.x*u.y*(va-vb-vc+vd) + \n           u.y*u.z*(va-vc-ve+vg) + \n           u.z*u.x*(va-vb-ve+vf) + \n           u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}\n\nfloat fbm0( vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*(-1.0+2.0*noise( p )); p = mtx*p*2.02;\n    f += 0.2500*(-1.0+2.0*noise( p )); p = mtx*p*2.03;\n    f += 0.1250*(-1.0+2.0*noise( p )); p = mtx*p*2.01;\n    f += 0.0625*(-1.0+2.0*noise( p ));\n    return f/0.9375;\n}\n\nfloat fbm1( vec3 p )\n{\n    float f = 0.0;\n    f += 0.500000*noise( p ); p = mtx*p*2.02;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\n    f += 0.015625*noise( p );\n    return f/0.96875;\n}\n\nvec3 pattern(vec2 p)\n{\n    float time_var = smin(pow(0.07*iTime, 2.0), 0.6, 0.5);\n    vec2 q;\n    vec2 r;\n    q.x = fbm1( vec3(p, 0.0) );\n    q.y = fbm0( vec3(p + vec2(-5.2,1.3), 0.0) );\n    \n    r.x = fbm1( vec3(p + 4.0*q*time_var + vec2(1.7,9.2+(iTime / 10.0)), 0.0) );\n    r.y = fbm1( vec3(p + 4.0*q*time_var + vec2(-2.3+(iTime / 10.0),2.8), 0.0) );\n    \n    vec2 index;\n    vec2 base;\n    base.x = fbm1( vec3(p + 2.0*r,0.0) );\n    base.y = fbm0( vec3(p + 2.0*r, 0.0) );\n    index.x = base.x - 50.0;\n    index.y = base.y - 200.0;\n    \n    return vec3(length(base)/3.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y + vec2(0.02*iTime, 0.04*iTime);\n    float rand_samp = texelFetch(iChannel0, ivec2(fragCoord)%1024, 0).x;\n\n    \n    vec3 mixVal = pattern(uv*3.0);\n    vec3 col;\n\n    \n    float weight = smoothstep(0.4, 1.0, length(mixVal));\n    col = mix(vec3(0.4, 0.6, 0.8), vec3(1.0), weight);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}