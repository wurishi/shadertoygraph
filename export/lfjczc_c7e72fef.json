{"ver":"0.1","info":{"id":"lfjczc","date":"1722784198","viewed":21,"name":"{Mobius Ball}","username":"inverse_transpose","description":"Mobius","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["mobius"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NORTH_POLE(s) (s.xyz + s.w * vec3(0.0, 1.0, 0.0))\n#define BOUNDS 2.0\n\nconst vec3 COLOUR_PLANE = vec3(.8);\n\nconst vec3 LIGHT_SOURCE = vec3(10000.0, 10000.0, -10.5);\n\nfloat dot2(in vec3 g)\n{\n    return dot(g, g);\n}\n\nvoid rotate(inout vec3 q)\n{\n    float t = 0.4*iTime;\n    float ct = cos(t);\n    float st = sin(t);\n    mat2 mat = mat2(\n        ct, st,\n       -st, ct\n    );\n    \n    q.xz *= mat;\n    q.xy *= mat;\n}\n\nvec3 directionPlaneToSphere(in vec3 p, in vec4 sd)\n{\n    return normalize(NORTH_POLE(sd) - p);\n}\n\nvec3 directionSphereToPlane(in vec3 p, in vec4 sd)\n{\n    return normalize(p - NORTH_POLE(sd));\n}\n\nfloat iSphere(in vec3 ro, in vec3 rd, in vec3 sc, in float r)\n{\n    vec3 oc = ro - sc;\n    float b = dot(rd, oc);\n    float c = dot(oc, oc) - r*r;\n    float t = b*b - c;\n    \n    if (0.0 > t)\n        return -1.0;\n        \n    float g = sqrt(t);\n    return min((-b + g), (-b - g));\n}\n\nfloat iPlane(in vec3 ro, in vec3 rd, in vec4 pl)\n{\n    vec3 N = normalize(pl.xyz);\n    float D = pl.w*(dot2(N));\n    return (-dot(N, ro) + D)/dot(N, rd);\n}\n\nfloat squared(in float t)\n{\n    return t*t;\n}\n\nvec3 get_plane_colour_for_point(in vec3 col, in vec3 p)\n{\n    float t;\n    \n    t  = step(abs(p.x), BOUNDS);\n    t *= step(abs(p.z), BOUNDS);\n    \n    int k = iFrame % 2000;\n    \n    if (0.0 < t && (abs(abs(p.x) - BOUNDS)<0.2 || abs(abs(p.z) - BOUNDS)<0.2))\n        return vec3(.15);\n    else\n    {\n        if (1000 > k)\n            return mix(col,texture(iChannel0, p.xz*.25).rrr, t);\n        else\n            return mix(col,texture(iChannel1, p.xz*.25).rrr, t);\n    }\n}\n\nmat3 camera_uvw(in vec3 camera, in vec3 lookat)\n{\n    vec3 w = normalize(lookat - camera);\n    vec3 u = normalize(cross(w, vec3(0.0, 1.0, 0.0)));\n    vec3 v = normalize(cross(u, w));\n    \n    return mat3(u, v, w);\n}\n\nvec3 get_sky_colour(in vec3 rd, in vec3 ro)\n{\n    const vec3 sky0 = vec3(0.5, 0.7, 0.5);\n    const vec3 sky1 = vec3(0.4, 0.3, 0.35);\n\n    vec3 result = smoothstep(1.0, 0.0, rd.y+.1) * sky0\n                + smoothstep(0.5, 0.0, rd.y+.2) * sky1;\n                    \n    return result;\n}\n\nvec3 renderPlane(in vec3 ro, in vec3 rd)\n{\n    return vec3(1.0);\n}\n\nvec3 renderSphere(in vec3 ro, in vec3 rd)\n{\n    return vec3(1.0);\n}\n\nvec3 renderScene(in vec3 ro, in vec3 rd)\n{\n    return vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float radius = 1.0;\n    const float plane_bounds = 3.0;\n    const vec4 plane = vec4(0.0, 1.0, 0.0, -radius);\n    float time = iTime*0.2;\n    \n    vec4 sd = vec4(0.0, 1.0 - 4.0*squared(fract(time*1.0) - 0.5), 0.0, radius);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    float off = 4.0*(0.5+0.5*cos(time));\n    vec3 ro = vec3(cos(iTime)*5.0, 2.73+off, 5.75+sin(time)*.5+off);\n    \n    mat3 uvw = camera_uvw(ro, vec3(0.0));\n    vec3 rd = normalize(vec3(uv.x * uvw[0] + uv.y * uvw[1] + uvw[2]));\n    \n    vec3 col = get_sky_colour(rd, vec3(0));\n    \n    float t = iSphere(ro, rd, sd.xyz, sd.w);\n    \n    if (!(0.0 > t))\n    {\n        vec3 p = ro + t*rd;\n        vec3 n = p - sd.xyz;\n        vec3 refl = reflect(rd, normalize(n));\n        \n        vec3 reflection = get_sky_colour(refl, p);\n        \n        col *= 0.4;\n        col += reflection;\n        \n        vec3 rn = n;\n        \n        rotate(rn);\n        \n        vec3 nro = rn + sd.xyz;\n        vec3 nrd = normalize(nro - NORTH_POLE(sd));\n        \n        const vec3 light_source = vec3(1.0, 1.0, 0.25);\n        vec3 to_light = normalize(LIGHT_SOURCE - p);\n        vec3 to_camera = normalize(ro - p);\n       \n        t = iPlane(nro, nrd, plane);\n        \n        if (!(0.0 > t))\n        {\n            vec3 p = nro + t*nrd;\n            vec2 s = vec2(p.x, p.z);\n            \n            col = get_plane_colour_for_point(col, p);\n            col = mix(col, COLOUR_PLANE, 0.2);\n        }\n    }\n\n    if (0.0 > t)\n    {\n        t = iPlane(ro, rd, plane);\n        \n        if (!(0.0 > t))\n        {\n            vec3 p = ro + t*rd;\n            \n            vec3 k = normalize(NORTH_POLE(sd) - p);\n            t = iSphere(p, k, sd.xyz, sd.w);\n            col = vec3(1,0,0);\n            \n            vec3 q = p + k*t;\n            vec3 n = q - sd.xyz;\n\n            vec3 q_to_p = normalize(q - p);\n            float m = abs(dot(q_to_p, vec3(0.0, 1.0, 0.0)));\n\n            float occ = length(p) < 50.0 ? 1.45 - (0.5 + 0.5 * dot(q_to_p, normalize(LIGHT_SOURCE))) : 1.0;\n\n            rotate(n);\n\n            q = n + sd.xyz;\n\n            vec3 nrd = normalize(q - NORTH_POLE(sd));\n\n            t = iPlane(q, nrd, plane);\n\n            vec3 g = q + t*nrd;\n\n            col = get_plane_colour_for_point(vec3(.9), g);\n            col = mix(get_sky_colour(rd, g), col, tanh(400.0 / dot2(p)));\n\n            col *= occ;\n        }\n    }\n\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}