{"ver":"0.1","info":{"id":"4sKGDG","date":"1475354369","viewed":686,"name":"PBR Editor","username":"AxleMike","description":"Hopefully I'm doing everything correctly, if not please correct/contact me :)\nControls: Mouse and A/D keys\n\nTODO:\n-fix reflections, proper glossy reflections, monte carlo bugs, crashes on some platforms, IBL, code cleanup, fix initial flash","likes":14,"published":1,"flags":48,"usePreview":0,"tags":["editor","pbr","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Alexander Lemke, 2016\n// Text Display\n\nfloat Saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\n// Materials\nstruct Material\n{\n    vec3    mBaseColor;\n    float \tmRoughness;\n    float \tmMetallic;\n    float   mReflectance;\n    float   mAmbient;\n    \n    int\t\tmDiffuseType;\n    int \tmMicrofacetDistributionType;\n    int\t\tmGeometricAttenuationType;\n    \n    int \tmIndex;\n};\n    \n// Diffuse Types\nconst int LAMBERT_DIFFUSE \t\t\t= 0;\nconst int DISNEY_DIFFUSE  \t\t\t= 1;\n    \n// Microfacet Distribution Types\nconst int GGX_MICROFACET \t \t\t= 0;    \nconst int BECKMAN_MICROFACET \t\t= 1;\n\n// Geometric Attenuation Types\nconst int VSMITH_GGX_GEOMETRIC \t\t= 0;\nconst int UE4_GEOMETRIC \t\t\t= 1;\nconst int COOK_TORRANCE_GEOMETRIC \t= 2;\n\nconst int NUMBER_OF_MATERIALS = 11;\nconst vec4 txMaterials = vec4(3.0, 0.0, 3.0 + float(NUMBER_OF_MATERIALS), 3.0);\n\n// Text\n#define LETTER_A(position) BitCheck(0x3F, 0x48, 0x48, 0x48, 0x3F, position); position.x -= 7.0 \n#define LETTER_B(position) BitCheck(0x7F, 0x49, 0x49, 0x49, 0x36, position); position.x -= 7.0 \n#define LETTER_C(position) BitCheck(0x3E, 0x41, 0x41, 0x41, 0x41, position); position.x -= 7.0 \n#define LETTER_D(position) BitCheck(0x7F, 0x41, 0x41, 0x41, 0x3E, position); position.x -= 7.0 \n#define LETTER_E(position) BitCheck(0x7F, 0x49, 0x49, 0x49, 0x49, position); position.x -= 7.0 \n#define LETTER_F(position) BitCheck(0x7F, 0x48, 0x48, 0x48, 0x48, position); position.x -= 7.0 \n#define LETTER_G(position) BitCheck(0x3E, 0x41, 0x41, 0x49, 0x49, 0x2E, position); position.x -= 8.0 \n#define LETTER_H(position) BitCheck(0x7F, 0x8, 0x8, 0x8, 0x7F, position); position.x -= 7.0 \n#define LETTER_I(position) BitCheck(0x41, 0x41, 0x7F, 0x41, 0x41, position); position.x -= 7.0 \n#define LETTER_J(position) BitCheck(0x42, 0x41, 0x41, 0x7E, 0x40, 0x40, position); position.x -= 8.0 \n#define LETTER_K(position) BitCheck(0x7F, 0x8, 0x8, 0x14, 0x22, 0x41, position); position.x -= 8.0 \n#define LETTER_L(position) BitCheck(0x7F, 0x1, 0x1, 0x1, 0x1, position); position.x -= 7.0 \n#define LETTER_M(position) BitCheck(0x7F, 0x40, 0x20, 0x1F, 0x20, 0x40, 0x7F, position); position.x -= 9.0 \n#define LETTER_N(position) BitCheck(0x7F, 0x20, 0x18, 0x6, 0x1, 0x7F, position); position.x -= 8.0 \n#define LETTER_O(position) BitCheck(0x3E, 0x41, 0x41, 0x41, 0x41, 0x3E, position); position.x -= 8.0 \n#define LETTER_P(position) BitCheck(0x7F, 0x48, 0x48, 0x48, 0x30, position); position.x -= 7.0 \n#define LETTER_Q(position) BitCheck(0x3E, 0x41, 0x41, 0x45, 0x42, 0x3D, position); position.x -= 8.0 \n#define LETTER_R(position) BitCheck(0x7F, 0x48, 0x4C, 0x4A, 0x31, position); position.x -= 7.0 \n#define LETTER_S(position) BitCheck(0x31, 0x49, 0x49, 0x49, 0x46, position); position.x -= 7.0 \n#define LETTER_T(position) BitCheck(0x40, 0x40, 0x7F, 0x40, 0x40, position); position.x -= 7.0 \n#define LETTER_U(position) BitCheck(0x7E, 0x1, 0x1, 0x1, 0x7E, position); position.x -= 7.0 \n#define LETTER_V(position) BitCheck(0x70, 0xE, 0x1, 0xE, 0x70, position); position.x -= 7.0 \n#define LETTER_W(position) BitCheck(0x7C, 0x2, 0x1, 0x7E, 0x1, 0x2, 0x7C, position); position.x -= 9.0 \n#define LETTER_X(position) BitCheck(0x63, 0x14, 0x8, 0x14, 0x63, position); position.x -= 7.0 \n#define LETTER_Y(position) BitCheck(0x60, 0x10, 0xF, 0x10, 0x60, position); position.x -= 7.0 \n#define LETTER_Z(position) BitCheck(0x41, 0x43, 0x45, 0x49, 0x51, 0x61, position); position.x -= 8.0 \n#define SPACE(position) position.x -= 8.0 \n#define DASH(position) BitCheck(0x8, 0x8, 0x8, position); position.x -= 5.0 \n#define COLON(position) BitCheck(0x63, 0x63, position); position.x -= 5.0 \n#define PERIOD(position) BitCheck(0x3, 0x3, position); position.x -= 4.0 \n#define NUMBER_1(position) BitCheck(0x21, 0x21, 0x7F, 0x1, 0x1, position); position.x -= 7.0 \n#define NUMBER_2(position) BitCheck(0x23, 0x45, 0x49, 0x49, 0x31, position); position.x -= 7.0 \n#define NUMBER_3(position) BitCheck(0x49, 0x49, 0x49, 0x49, 0x36, position); position.x -= 7.0 \n#define NUMBER_4(position) BitCheck(0x78, 0x8, 0x8, 0x7F, 0x8, position); position.x -= 7.0 \n#define NUMBER_5(position) BitCheck(0x72, 0x49, 0x49, 0x49, 0x46, position); position.x -= 7.0 \n#define NUMBER_6(position) BitCheck(0x3E, 0x49, 0x49, 0x49, 0x26, position); position.x -= 7.0  \n#define NUMBER_7(position) BitCheck(0x41, 0x42, 0x44, 0x48, 0x50, 0x60, position); position.x -= 8.0  \n#define NUMBER_8(position) BitCheck(0x36, 0x49, 0x49, 0x49, 0x36, position); position.x -= 7.0 \n#define NUMBER_9(position) BitCheck(0x32, 0x49, 0x49, 0x49, 0x3E, position); position.x -= 7.0 \n#define NUMBER_0(position) BitCheck(0x3E, 0x41, 0x41, 0x41, 0x3E, position); position.x -= 7.0 \n\n#define START_TEXT    textCursor.y=1.0-textCursor.y;float tS=scale;vec2 mFC=floor((uv.xy*iResolution.xy)/floor(tS));vec2 tP=floor(mFC.xy-(textCursor.xy*iResolution.xy/tS)+1.0);if(tP.y<0.0||tP.y>8.0){return 0.0;}if(fragCoord.x+(tS*2.0)<textCursor.x){return -1.0;}float bV=0.0;\n#define END_TEXT\t  return bV;\n\n////////////////////////////////////////////////////////\n// Strings\n#define EDIT_MODE_STRING bV+=LETTER_E(tP);bV+=LETTER_D(tP);bV+=LETTER_I(tP);bV+=LETTER_T(tP);SPACE(tP);bV+=LETTER_M(tP);bV+=LETTER_O(tP);bV+=LETTER_D(tP);bV+=LETTER_E(tP);\n#define ITERATION_STRING bV+=LETTER_I(tP);bV+=LETTER_T(tP);bV+=LETTER_E(tP);bV+=LETTER_R(tP);bV+=LETTER_A(tP);bV+=LETTER_T(tP);bV+=LETTER_I(tP);bV+=LETTER_O(tP);bV+=LETTER_N(tP);bV+=COLON(tP);SPACE(tP);\n\n#define MATERIAL_STRING bV+=LETTER_M(tP);bV+=LETTER_A(tP);bV+=LETTER_T(tP);bV+=LETTER_E(tP);bV+=LETTER_R(tP);bV+=LETTER_I(tP);bV+=LETTER_A(tP);bV+=LETTER_L(tP);bV+=COLON(tP);SPACE(tP);\n#define INVALID_STRING bV+=LETTER_I(tP);bV+=LETTER_N(tP);bV+=LETTER_V(tP);bV+=LETTER_A(tP);bV+=LETTER_L(tP);bV+=LETTER_I(tP);bV+=LETTER_D(tP);\n\n#define BASE_COLOR_STRING bV+=LETTER_B(tP);bV+=LETTER_A(tP);bV+=LETTER_S(tP);bV+=LETTER_E(tP);SPACE(tP);bV+=LETTER_C(tP);bV+=LETTER_O(tP);bV+=LETTER_L(tP);bV+=LETTER_O(tP);bV+=LETTER_R(tP);bV+=COLON(tP);SPACE(tP);\n#define ROUGHNESS_STRING bV+=LETTER_R(tP);bV+=LETTER_O(tP);bV+=LETTER_U(tP);bV+=LETTER_G(tP);bV+=LETTER_H(tP);bV+=LETTER_N(tP);bV+=LETTER_E(tP);bV+=LETTER_S(tP);bV+=LETTER_S(tP);bV+=COLON(tP);SPACE(tP);\n#define METALLIC_STRING bV+=LETTER_M(tP);bV+=LETTER_E(tP);bV+=LETTER_T(tP);bV+=LETTER_A(tP);bV+=LETTER_L(tP);bV+=LETTER_L(tP);bV+=LETTER_I(tP);bV+=LETTER_C(tP);bV+=COLON(tP);SPACE(tP);\n#define REFLECTANCE_STRING bV+=LETTER_R(tP);bV+=LETTER_E(tP);bV+=LETTER_F(tP);bV+=LETTER_L(tP);bV+=LETTER_E(tP);bV+=LETTER_C(tP);bV+=LETTER_T(tP);bV+=LETTER_A(tP);bV+=LETTER_N(tP);bV+=LETTER_C(tP);bV+=LETTER_E(tP);bV+=COLON(tP);SPACE(tP);\n#define AMBIENT_STRING bV+=LETTER_A(tP);bV+=LETTER_M(tP);bV+=LETTER_B(tP);bV+=LETTER_I(tP);bV+=LETTER_E(tP);bV+=LETTER_N(tP);bV+=LETTER_T(tP);bV+=COLON(tP);SPACE(tP);\n\n#define DIFFUSE_STRING bV+=LETTER_D(tP);bV+=LETTER_I(tP);bV+=LETTER_F(tP);bV+=LETTER_F(tP);bV+=LETTER_U(tP);bV+=LETTER_S(tP);bV+=LETTER_E(tP);bV+=COLON(tP);SPACE(tP);\n#define LAMBERT_STRING bV+=LETTER_L(tP);bV+=LETTER_A(tP);bV+=LETTER_M(tP);bV+=LETTER_B(tP);bV+=LETTER_E(tP);bV+=LETTER_R(tP);bV+=LETTER_T(tP);\n#define DISNEY_STRING bV+=LETTER_D(tP);bV+=LETTER_I(tP);bV+=LETTER_S(tP);bV+=LETTER_N(tP);bV+=LETTER_E(tP);bV+=LETTER_Y(tP);\n\n#define MICROFACET_DISTRIBUTION_STRING bV+=LETTER_M(tP);bV+=LETTER_I(tP);bV+=LETTER_C(tP);bV+=LETTER_R(tP);bV+=LETTER_O(tP);bV+=LETTER_F(tP);bV+=LETTER_A(tP);bV+=LETTER_C(tP);bV+=LETTER_E(tP);bV+=LETTER_T(tP);bV+=COLON(tP);SPACE(tP);\n#define GGX_STRING bV+=LETTER_G(tP);bV+=LETTER_G(tP);bV+=LETTER_X(tP);\n#define BECKMAN_STRING bV+=LETTER_B(tP);bV+=LETTER_E(tP);bV+=LETTER_C(tP);bV+=LETTER_K(tP);bV+=LETTER_M(tP);bV+=LETTER_A(tP);bV+=LETTER_N(tP);\n\n#define GEOMETRIC_ATTENUTATION_STRING bV+=LETTER_G(tP);bV+=LETTER_E(tP);bV+=LETTER_O(tP);bV+=LETTER_M(tP);bV+=LETTER_E(tP);bV+=LETTER_T(tP);bV+=LETTER_R(tP);bV+=LETTER_I(tP);bV+=LETTER_C(tP);bV+=COLON(tP);SPACE(tP);\n#define VSMITH_GGX_STRING bV+=LETTER_V(tP);bV+=LETTER_S(tP);bV+=LETTER_M(tP);bV+=LETTER_I(tP);bV+=LETTER_T(tP);bV+=LETTER_H(tP);SPACE(tP);bV+=LETTER_G(tP);bV+=LETTER_G(tP);bV+=LETTER_X(tP);\n#define UE4_STRING bV+=LETTER_U(tP);bV+=LETTER_E(tP);bV+=NUMBER_4(tP);\n#define COOK_TORRANCE_STRING bV+=LETTER_C(tP);bV+=LETTER_O(tP);bV+=LETTER_O(tP);bV+=LETTER_K(tP);SPACE(tP);bV+=LETTER_T(tP);bV+=LETTER_O(tP);bV+=LETTER_R(tP);bV+=LETTER_R(tP);bV+=LETTER_A(tP);bV+=LETTER_N(tP);bV+=LETTER_C(tP);bV+=LETTER_E(tP);\n\n////////////////////////////////////////////////////////\n// Bit Checks for text\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in int c5, in int c6, in int c7, in vec2 textPos) \n{\n    float columnBits = 0.0;\n    \n    int textColumn = int(textPos.x);\n    \n    if (textColumn == 1) { columnBits = float(c1); }\n    else if (textColumn == 2) { columnBits = float(c2); }\n    else if (textColumn == 3) { columnBits = float(c3); }\n    else if (textColumn == 4) { columnBits = float(c4); }\n    else if (textColumn == 5) { columnBits = float(c5); }\n    else if (textColumn == 6) { columnBits = float(c6); }\n    else if (textColumn == 7) { columnBits = float(c7); }\n       \n    return floor(fract(columnBits / pow(2.0, floor(textPos.y))) * 2.0);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in int c5, in int c6, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, c4, c5, c6, 0, textPos);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in int c5, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, c4, c5, 0, textPos);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in int c4, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, c4, 0, textPos);\n}\n\nfloat BitCheck(in int c1, in int c2, in int c3, in vec2 textPos) \n{\n    return BitCheck(c1, c2, c3, 0, textPos);\n}\n\nfloat BitCheck(in int c1, in int c2, in vec2 textPos) \n{\n    return BitCheck(c1, c2, 0, textPos);\n}\n\nfloat DisplayDigit(in int digit, out vec2 textPos)\n{\n    float bitVal = 0.0;\n    \n    if(digit == 0)      { bitVal += NUMBER_0(textPos); }\n    else if(digit == 1) { bitVal += NUMBER_1(textPos); }\n    else if(digit == 2) { bitVal += NUMBER_2(textPos); }\n    else if(digit == 3) { bitVal += NUMBER_3(textPos); }\n    else if(digit == 4) { bitVal += NUMBER_4(textPos); }\n    else if(digit == 5) { bitVal += NUMBER_5(textPos); }\n    else if(digit == 6) { bitVal += NUMBER_6(textPos); }\n    else if(digit == 7) { bitVal += NUMBER_7(textPos); }\n    else if(digit == 8) { bitVal += NUMBER_8(textPos); }\n    else if(digit == 9) { bitVal += NUMBER_9(textPos); }\n    \n    return bitVal;\n}\n\nfloat WriteFloat(inout vec2 textPos, in vec2 uv, in float scale, in float number, in bool displayMultipleZeroes)\n{\n    const int MAX_NUMBER_OF_DIGITS = 4;\n    if (textPos.y < 1.0 || textPos.y > 8.0) \n        return 0.0;\n      \n    float bitVal = 0.0;   \n    if(number < 0.0)\n    {\n     \tnumber = -number;\n        bitVal += DASH(textPos);\n    }\n        \n    bitVal += DisplayDigit(int(number), textPos);\n    number *= 10000.0;\n    bitVal += PERIOD(textPos);\n   \n    bool foundNonZero = false;\n    for(int i = 1; i <= MAX_NUMBER_OF_DIGITS; ++i)\n    {         \n        int digit = int(mod(float(number) / pow(10.0, float(MAX_NUMBER_OF_DIGITS - i)), 10.0)); \n        foundNonZero = (digit != 0 || displayMultipleZeroes) ? true : foundNonZero;\n        \n        if(digit == 0)\n        {\n            if(foundNonZero || (number == 0.0 && i == 1))\n                bitVal += DisplayDigit(digit, textPos);\n        }\n        else\n        {\n            bitVal += DisplayDigit(digit, textPos);\n        }\n    }\n    return bitVal; \n}\n\nfloat WriteInterger(inout vec2 textPos, in vec2 uv, in float scale, in int number)\n{\n    const int MAX_NUMBER_OF_DIGITS = 2;\n    if (textPos.y < 1.0 || textPos.y > 8.0) \n        return 0.0;\n      \n    float bitVal = 0.0;   \n    if(number < 0)\n    {\n     \tnumber = -number;\n        bitVal += DASH(textPos);\n    }\n   \n    bool foundNonZero = false;\n    for(int i = 1; i <= MAX_NUMBER_OF_DIGITS; ++i)\n    {         \n        int digit = int(mod(float(number) / pow(10.0, float(MAX_NUMBER_OF_DIGITS - i)), 10.0)); \n        foundNonZero = (digit != 0) ? true : foundNonZero;\n        \n        if(digit == 0)\n        {\n            if(foundNonZero || (number == 0 && i == 1))\n                bitVal += DisplayDigit(digit, textPos);\n        }\n        else\n        {\n            bitVal += DisplayDigit(digit, textPos);\n        }\n    }\n    return bitVal; \n}\n\nfloat WriteInterger8(inout vec2 textPos, in vec2 uv, in float scale, in int number)\n{\n    const int MAX_NUMBER_OF_DIGITS = 8;\n    if (textPos.y < 1.0 || textPos.y > 8.0) \n        return 0.0;\n      \n    float bitVal = 0.0;   \n    if(number < 0)\n    {\n     \tnumber = -number;\n        bitVal += DASH(textPos);\n    }\n   \n    bool foundNonZero = false;\n    for(int i = 1; i <= MAX_NUMBER_OF_DIGITS; ++i)\n    {         \n        int digit = int(mod(float(number) / pow(10.0, float(MAX_NUMBER_OF_DIGITS - i)), 10.0)); \n        foundNonZero = (digit != 0) ? true : foundNonZero;\n        \n        if(digit == 0)\n        {\n            if(foundNonZero || (number == 0 && i == 1))\n                bitVal += DisplayDigit(digit, textPos);\n        }\n        else\n        {\n            bitVal += DisplayDigit(digit, textPos);\n        }\n    }\n    return bitVal; \n}\n////////////////////////////////////////////////////////\n// Formatted Strings\nfloat WriteEditString(in vec2 textCursor, in vec2 uv, in vec2 fragCoord, in float scale){START_TEXT EDIT_MODE_STRING END_TEXT}\n\nfloat WriteBaseColorString(in vec2 textCursor, in vec2 uv, in vec2 fragCoord, in float scale, in vec3 baseColor)\n{START_TEXT BASE_COLOR_STRING END_TEXT}\n\nfloat WriteRoughnessString(in vec2 textCursor, in vec2 uv, in vec2 fragCoord, in float scale, in float roughness)\n{START_TEXT ROUGHNESS_STRING bV+=WriteFloat(tP, uv, 1.1, roughness, true); END_TEXT}\n\nfloat WriteMetallicString(in vec2 textCursor, in vec2 uv, in vec2 fragCoord, in float scale, in float metallic)\n{START_TEXT METALLIC_STRING bV+=WriteFloat(tP, uv, 1.1, metallic, true); END_TEXT}\n\nfloat WriteReflectanceString(in vec2 textCursor, in vec2 uv, in vec2 fragCoord, in float scale, in float reflectance)\n{START_TEXT REFLECTANCE_STRING bV+=WriteFloat(tP, uv, 1.1, reflectance, true); END_TEXT}\n\nfloat WriteAmbientString(in vec2 textCursor, in vec2 uv, in vec2 fragCoord, in float scale, in float ambient)\n{START_TEXT AMBIENT_STRING bV+=WriteFloat(tP, uv, 1.1, ambient, true); END_TEXT}\n\nfloat WriteDiffuseString(in vec2 textCursor, in vec2 uv, in vec2 fragCoord, in float scale, in int diffuseType)\n{\n    START_TEXT  \n    DIFFUSE_STRING       \n    if(diffuseType == LAMBERT_DIFFUSE){LAMBERT_STRING}\n    else if(diffuseType == DISNEY_DIFFUSE){DISNEY_STRING}   \n    END_TEXT\n}\n\nfloat WriteMicrofacetString(in vec2 textCursor, in vec2 uv, in vec2 fragCoord, in float scale, in int microfacetType)\n{\n    START_TEXT  \n    MICROFACET_DISTRIBUTION_STRING       \n    if(microfacetType == GGX_MICROFACET){GGX_STRING}\n    else if(microfacetType == BECKMAN_MICROFACET){BECKMAN_STRING}   \n    END_TEXT\n}\n\nfloat WriteGeometricAttenuationString(in vec2 textCursor, in vec2 uv, in vec2 fragCoord, in float scale, in int geometricAttenuationType)\n{\n    START_TEXT  \n    GEOMETRIC_ATTENUTATION_STRING       \n    if(geometricAttenuationType == VSMITH_GGX_GEOMETRIC){VSMITH_GGX_STRING}\n    else if(geometricAttenuationType == UE4_GEOMETRIC){UE4_STRING} \n    else if(geometricAttenuationType == COOK_TORRANCE_GEOMETRIC){COOK_TORRANCE_STRING} \n    END_TEXT\n}\n\nfloat WriteMaterialIndexString(in vec2 textCursor, in vec2 uv, in vec2 fragCoord, in float scale, in int materialIndex)\n{\n    const int NUMBER_OF_MATERIALS = 11; \n    START_TEXT     \n    MATERIAL_STRING\n    if((materialIndex >= 0) && (materialIndex < NUMBER_OF_MATERIALS))\n    {\n         bV += WriteInterger(tP, uv, tS, materialIndex);\n    }\n    else\n    {\n        INVALID_STRING\n    }\n    END_TEXT\n}\n\nfloat WriteIterationString(in vec2 textCursor, in vec2 uv, in vec2 fragCoord, in float scale, in int iteration)\n{\n    START_TEXT \n    ITERATION_STRING \n    bV += WriteInterger8(tP, uv, tS, iteration); \n    END_TEXT\n}\n\nvec4 LoadValueBufferA(in vec2 re)\n{\n    return texture(iChannel1, (0.5 + re) / iChannelResolution[1].xy, -100.0);\n}\n\nMaterial LoadMaterial(in int materialIndex)\n{\n    vec4 materialInfo0 = LoadValueBufferA(txMaterials.xy + vec2(float(materialIndex), 0.0));\n    vec4 materialInfo1 = LoadValueBufferA(txMaterials.xy + vec2(float(materialIndex), 1.0));\n    vec4 materialInfo2 = LoadValueBufferA(txMaterials.xy + vec2(float(materialIndex), 2.0));\n\n    return Material(materialInfo0.xyz, materialInfo0.w, materialInfo1.x, materialInfo1.y, \n                    materialInfo1.z, int(materialInfo2.x), int(materialInfo2.y), int(materialInfo2.z), materialIndex);\n}\n\n////////////////////////////////////////////////////////\n// Editor\nvec4 DisplaySlider(in vec2 uv, in float height, in float value, in vec3 color)\n{\n    float inSliderBounds = step(0.015, uv.x)*step(uv.x, 0.29)*step(uv.y, 1.0-(height+0.01))*step(1.0-(height+0.04), uv.y);\n    float barU = (value * 0.275 + 0.015);\n    \n    float inBarBounds = step(barU - 0.005, uv.x)*step(uv.x, barU + 0.005)*step(uv.y, 1.0-(height+0.005))*step(1.0-(height+0.045), uv.y);\n    float gradientAmount = inSliderBounds * Saturate(uv.x / 0.259); \n    return vec4((gradientAmount * color) * (1.0 - inBarBounds) + vec3(0.0) * inBarBounds, inSliderBounds + inBarBounds);\n}\n\nvec4 DisplayClickBox(in vec2 uv, in float height, in vec3 color)\n{\n    float inBounds = step(0.01, uv.x)*step(uv.x, 0.29) *step(uv.y, 1.0-(height))*step(1.0-(height+0.035), uv.y);\n\treturn vec4(color * inBounds, inBounds);\n}    \n    \nvec4 DisplayMaterial(in vec2 fragCoord, in vec2 uv, in Material selectedMaterial)\n{\n    const float xSpacing = 0.015;\n    \n    vec4 finalColor = vec4(0.0);\n    \n    float text = WriteBaseColorString(vec2(xSpacing, 0.075), uv, fragCoord, 1.1, selectedMaterial.mBaseColor); \n    vec4 sliderColor = DisplaySlider(uv, 0.18, selectedMaterial.mBaseColor.r, vec3(1, 0, 0));\n    sliderColor += DisplaySlider(uv, 0.225, selectedMaterial.mBaseColor.g, vec3(0, 0, 1));\n    sliderColor += DisplaySlider(uv, 0.27, selectedMaterial.mBaseColor.b, vec3(0, 1, 0));\n    \n    text += WriteRoughnessString(vec2(xSpacing, 0.3), uv, fragCoord, 1.1, selectedMaterial.mRoughness); \n    sliderColor += DisplaySlider(uv, 0.365, selectedMaterial.mRoughness, vec3(1.0));\n\n    text += WriteMetallicString(vec2(xSpacing, 0.4), uv, fragCoord, 1.1, selectedMaterial.mMetallic);\n\tsliderColor += DisplaySlider(uv, 0.455, selectedMaterial.mMetallic, vec3(1.0));\n\n    text += WriteReflectanceString(vec2(xSpacing, 0.5), uv, fragCoord, 1.1, selectedMaterial.mReflectance);\n    sliderColor += DisplaySlider(uv, 0.55, selectedMaterial.mReflectance, vec3(1.0));  \n    \n    text += WriteAmbientString(vec2(xSpacing, 0.6), uv, fragCoord, 1.1, selectedMaterial.mAmbient);\n    sliderColor += DisplaySlider(uv, 0.65, selectedMaterial.mAmbient, vec3(1.0));\n\n    text += WriteDiffuseString(vec2(xSpacing, 0.75), uv, fragCoord, 1.1, selectedMaterial.mDiffuseType);\n \tvec4 buttonColor = DisplayClickBox(uv, 0.75, vec3(0.5)); \n    \n    text += WriteMicrofacetString(vec2(xSpacing, 0.805), uv, fragCoord, 1.1, selectedMaterial.mMicrofacetDistributionType);\n\tbuttonColor += DisplayClickBox(uv, 0.8, vec3(0.5)); \n    \n    text += WriteGeometricAttenuationString(vec2(xSpacing, 0.865), uv, fragCoord, 1.1, selectedMaterial.mGeometricAttenuationType);\n \tbuttonColor += DisplayClickBox(uv, 0.85, vec3(0.5)); \n    \n    finalColor = vec4(((1.0 - buttonColor.w) * finalColor.rgb) + vec3(buttonColor.w) * buttonColor.rgb, buttonColor.w);\n    finalColor = vec4(((1.0 - text) * finalColor.rgb) + vec3(text) * vec3(0.0), text);\n    finalColor = vec4(((1.0 - sliderColor.w) * finalColor.rgb) + (vec3(sliderColor.w) * sliderColor.rbg), text + sliderColor.w);\n    \n    return finalColor;\n}\n\n// Scene\nconst vec2 txSceneModeInfo = vec2(0.0, 0.0); // x = scene mode, selected material, z = monte carlo starting frame, w = monte carlo starting time\n\n//////////////////////////////////////////////////\n// Modes\nconst float ATTRACT_MODE \t\t= 0.0;\nconst float EDIT_MODE \t\t\t= 1.0;\nconst float MONTE_CARLO_MODE \t= 2.0;\n\n//////////////////////////////////////////////////\n// Implementation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 sceneInfo = LoadValueBufferA(txSceneModeInfo);\n    float sceneMode = sceneInfo.x;\n    \n    vec3 finalColor = texture(iChannel0, uv).rgb;\n    \n    if(sceneMode == EDIT_MODE)\n    {\n      \tint materialIndex = int(sceneInfo.y);\n        \n        // Menu\n        const float menuWidth = 0.3;\n        float edge = step(menuWidth, uv.x);\n    \tfinalColor = (1.0 - edge) * (finalColor * 0.5 + vec3(0.5)) + edge * finalColor;    \n        \n        float text = WriteEditString(vec2(0.015, 0.005), uv, fragCoord, 2.1); \n        text += WriteMaterialIndexString(vec2(0.015, 0.1), uv, fragCoord, 1.0, materialIndex); \n        finalColor.rgb = ((1.0 - text) * finalColor.rgb) + vec3(text) * vec3(0.0);\n        \n        if((materialIndex >= 0) && (materialIndex < NUMBER_OF_MATERIALS))\n        {\n        \tMaterial selectedMaterial = LoadMaterial(materialIndex);  \n            \n            vec4 materialMenuColor = DisplayMaterial(fragCoord, uv, selectedMaterial);            \n            finalColor = step(materialMenuColor.w, 0.0) * finalColor + step(0.0, materialMenuColor.w) * materialMenuColor.rgb;\n        }\n    }\n    else if(sceneMode == MONTE_CARLO_MODE)\n    {\n       int iteration = iFrame - int(sceneInfo.z);\n       finalColor = finalColor / float(iteration);\n        \n       float text = WriteIterationString(vec2(0.015, 0.0), uv, fragCoord, 1.1, iteration); \n       finalColor.rgb = ((1.0 - text) * finalColor.rgb) + vec3(text);\n    }\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Alexander Lemke, 2016\n// Data Storage and Slider Implementation\n//\n// References\n// https://www.shadertoy.com/view/MddGzf\n\n//////////////////////////////////////////////////\n// Constants\nconst float     PI \t\t\t     = 3.14159265359;\n\n//////////////////////////////////////////////////\n// Helpers \nfloat Saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\nmat3 Create3x3RotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float rc = 1.0 - c;\n    \n    return mat3(rc * axis.x * axis.x + c,          rc * axis.x * axis.y - axis.z * s, rc * axis.z * axis.x + axis.y * s,\n                rc * axis.x * axis.y + axis.z * s, rc * axis.y * axis.y + c,          rc * axis.y * axis.z - axis.x * s,\n                rc * axis.z * axis.x - axis.y * s, rc * axis.y * axis.z + axis.x * s, rc * axis.z * axis.z + c);\n}\n\nconst vec2 txSceneModeInfo = vec2(0.0, 0.0); // x = scene mode, selected material, z = monte carlo starting frame, w = monte carlo starting time\nconst vec2 txPreviousKeyboard = vec2(0.0, 1.0);\nconst vec2 txPreviousMouse = vec2(0.0, 2.0);\n\nconst vec2 txCameraPosition = vec2(1.0, 0.0);\nconst vec2 txCameraForward = vec2(1.0, 1.0);\nconst vec2 txCameraRight = vec2(1.0, 2.0);\n\n//////////////////////////////////////////////////\n// Materials\nconst int NUMBER_OF_MATERIALS = 11;\nconst vec4 txMaterials = vec4(3.0, 0.0, 3.0 + float(NUMBER_OF_MATERIALS), 3.0);\n\nstruct Material\n{\n    vec3    mBaseColor;\n    float \tmRoughness;\n    \n    float \tmMetallic;\n    float   mReflectance;\n    float   mAmbient;\n    \n    int\t\tmDiffuseType;\n    int \tmMicrofacetDistributionType;\n    int\t\tmGeometricAttenuationType;\n};\n  \n// Metallics don't use reflectance\n#define METALLIC 1.0, 0.0     \n\n// Diffuse Types\nconst int LAMBERT_DIFFUSE \t\t\t= 0;\nconst int DISNEY_DIFFUSE  \t\t\t= 1;\n    \n// Microfacet Distribution Types\nconst int GGX_MICROFACET \t \t\t= 0;    \nconst int BECKMAN_MICROFACET \t\t= 1;\n\n// Geometric Attenuation Types\nconst int VSMITH_GGX_GEOMETRIC \t\t= 0;\nconst int UE4_GEOMETRIC \t\t\t= 1;\nconst int COOK_TORRANCE_GEOMETRIC \t= 2;\n\n#define DEFAULT_TYPES LAMBERT_DIFFUSE, GGX_MICROFACET, VSMITH_GGX_GEOMETRIC\n\nMaterial gMaterials[NUMBER_OF_MATERIALS];\n\nconst vec3 gold = vec3(1.0, 0.71, 0.29);\nconst vec3 copper = vec3(0.95, 0.64, 0.54);\nconst vec3 iron = vec3(0.56, 0.57, 0.58);\nconst vec3 aluminum = vec3(0.91, 0.92, 0.92);\nconst vec3 silver = vec3(0.95, 0.93, 0.88);\n\nvoid ResetMaterialsScene()\n{\n    float defaultAmbient = 0.05;\n    \n    // Plane\n    gMaterials[0] = Material(silver, 0.01, METALLIC, defaultAmbient, DEFAULT_TYPES); \n    gMaterials[1] = Material(vec3(0.0), 0.25, 0.0, 0.05, defaultAmbient, DEFAULT_TYPES); // Wood\n        \n    // Spheres\n    \n    // Metallics\n    gMaterials[2] = Material(iron, 0.22, METALLIC, defaultAmbient, DEFAULT_TYPES);\n    gMaterials[3] = Material(gold, 0.1, METALLIC, defaultAmbient, DEFAULT_TYPES);  \n    gMaterials[5] = Material(silver, 0.75, METALLIC, defaultAmbient, DEFAULT_TYPES);   \n    gMaterials[6] = Material(copper, 0.2, METALLIC, defaultAmbient, DEFAULT_TYPES);\n\n    // dielectric \n   \tgMaterials[4] = Material(vec3(0.9, 0.1, 0.1), 0.9, 0.0, 0.05, defaultAmbient, DEFAULT_TYPES);\n    gMaterials[7] = Material(vec3(0.9, 0.1, 0.1), 0.1, 0.0, 0.05, defaultAmbient, DEFAULT_TYPES);\n    gMaterials[10] = Material(vec3(0.9, 0.1, 0.1), 0.02, 0.0, 0.15, defaultAmbient, DEFAULT_TYPES);  \n    gMaterials[9] = Material(vec3(0.9, 0.1, 0.1), 0.02, 0.0, 0.8, defaultAmbient, DEFAULT_TYPES);\n    gMaterials[8] = Material(vec3(0.9, 0.1, 0.1), 0.02, 0.0, 0.4, defaultAmbient, DEFAULT_TYPES);\n}\n\n//////////////////////////////////////////////////\n// Camera\nstruct Camera\n{\n\tvec3 mPosition;\n    vec3 mForward;\n    vec3 mRight;\n};\nCamera gCamera;\n   \n//////////////////////////////////////////////////\n// Editor\nvec2 CheckSlider(in vec4 mouseCoords, in float height)\n{\n    vec2 clickUV = mouseCoords.zw / iResolution.xy;\n    float cursorX = mouseCoords.x / iResolution.x;\n    float inSliderBounds = step(0.015, clickUV.x)*step(clickUV.x, 0.29) *step(clickUV.y, 1.0-(height+0.01))*step(1.0-(height+0.04), clickUV.y);\n    return vec2(inSliderBounds, Saturate((cursorX - 0.015) / 0.275) * inSliderBounds);   \n}\n\nfloat CheckClickBox(in vec4 mouseCoords, in float height)\n{\n    vec2 clickUV = mouseCoords.zw / iResolution.xy;\n    float inBounds = step(0.01, clickUV.x)*step(clickUV.x, 0.29) *step(clickUV.y, 1.0-(height))*step(1.0-(height+0.035), clickUV.y);\n    return inBounds;   \n}\n\n//////////////////////////////////////////////////\n// Loading and Saving\nfloat IsInside(in vec2 p, in vec2 c) \n{ \n    vec2 d = abs(p - 0.5 - c) - 0.5; \n    return -max(d.x, d.y); \n}\n\nfloat IsInside(in vec2 p, in vec4 c) \n{ \n    vec2 d = abs(p - 0.5 - c.xy - c.zw * 0.5) - 0.5 * c.zw - 0.5; \n    return -max(d.x, d.y); \n}\n\nvec4 LoadValue(in vec2 re)\n{\n    return texture(iChannel0, (0.5 + re) / iChannelResolution[0].xy, -100.0);\n}\n\nvoid StoreValue(in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (IsInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nvoid StoreValue(in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (IsInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nMaterial LoadMaterial(in int materialIndex)\n{\n    vec4 materialInfo0 = LoadValue(txMaterials.xy + vec2(float(materialIndex), 0.0));\n    vec4 materialInfo1 = LoadValue(txMaterials.xy + vec2(float(materialIndex), 1.0));\n    vec4 materialInfo2 = LoadValue(txMaterials.xy + vec2(float(materialIndex), 2.0));\n\n    return Material(materialInfo0.xyz, materialInfo0.w, materialInfo1.x, materialInfo1.y, \n                    materialInfo1.z, int(materialInfo2.x), int(materialInfo2.y), int(materialInfo2.z));\n}\n\nvoid LoadMaterials()\n{\n    for(int materialIndex = 0; materialIndex < NUMBER_OF_MATERIALS; ++materialIndex)\n    {\n    \tgMaterials[materialIndex] = LoadMaterial(materialIndex);\n    }\n}\n\nvoid StoreMaterial(in vec2 re, in Material material, inout vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 materialInfo0 = vec4(material.mBaseColor.xyz, material.mRoughness);\n    vec4 materialInfo1 = vec4(material.mMetallic, material.mReflectance, material.mAmbient, 0.0);\n    vec4 materialInfo2 = vec4(material.mDiffuseType, material.mMicrofacetDistributionType, material.mGeometricAttenuationType, 0.0);\n\n    StoreValue(re, materialInfo0, fragColor, fragCoord);\n    StoreValue(re + vec2(0.0, 1.0), materialInfo1, fragColor, fragCoord);\n    StoreValue(re + vec2(0.0, 2.0), materialInfo2, fragColor, fragCoord);\n}\n\nvoid StoreMaterials(inout vec4 fragColor, in vec2 fragCoord)\n{\n    for(int materialIndex = 0; materialIndex < NUMBER_OF_MATERIALS; ++materialIndex)\n    {\n    \tStoreMaterial(txMaterials.xy + vec2(materialIndex, 0.0), gMaterials[materialIndex], fragColor, fragCoord);\n    }\n}\n   \nvoid LoadCamera()\n{\n    vec3 cameraPosition = LoadValue(txCameraPosition.xy).xyz;\n    vec3 cameraForward  = LoadValue(txCameraForward.xy).xyz;\n\tvec3 cameraRight = LoadValue(txCameraRight.xy).xyz;\n    gCamera = Camera(cameraPosition, cameraForward, cameraRight);\n}\n\nvoid StoreCamera(inout vec4 fragColor, in vec2 fragCoord) \n{\n    StoreValue(txCameraPosition, vec4(gCamera.mPosition, 0.0), fragColor, fragCoord);\n    StoreValue(txCameraForward, vec4(gCamera.mForward, 0.0), fragColor, fragCoord);\n    StoreValue(txCameraRight, vec4(gCamera.mRight, 0.0), fragColor, fragCoord);\n}\n\nvoid UpdateCamera()\n{\n    float xRotationValue = (iMouse.z > 0.0) ? (iMouse.y / iResolution.y - 1.75) * (PI * 1.15) : 0.8;\n    mat3 xRotationMatrix = Create3x3RotationMatrix(vec3(1.0, 0.0, 0.0), xRotationValue);\n    float yRotationValue = (iMouse.z > 0.0) ? (iMouse.x / iResolution.x) * (PI * 2.0) : (iTime * PI) * 0.05;\n    mat3 yRotationMatrix = Create3x3RotationMatrix(vec3(0.0, -1.0, 0.0), yRotationValue);\n\n    // Determine our camera info\n    const float distanceFromOrigin = 3.5;\n    gCamera.mPosition.xyz = vec3(distanceFromOrigin * sin(yRotationValue) * cos(xRotationValue), distanceFromOrigin * sin(xRotationValue), distanceFromOrigin * cos(yRotationValue) * cos(xRotationValue));\n    gCamera.mForward.xyz = yRotationMatrix * xRotationMatrix * vec3(0.0, 0.0, -1.0);\n    gCamera.mRight.xyz = yRotationMatrix * xRotationMatrix * vec3(1.0, 0.0, 0.0);\n}\n\n//////////////////////////////////////////////////\n// Keys\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_W     = 87.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nbool GeyKeyState(in float key)\n{\n\treturn (texture(iChannel1, vec2(key, 0.25)).x > 0.5);   \n}\n\nstruct KeyboardState\n{\n    bool mKeyModeForward[2];\n\tbool mKeyModeBackwards[2];\n\tbool mKeyW[2];\n\n    bool mKeyS[2];\n};\nKeyboardState gKeyboardState;\n    \nvoid LoadKeyboardState()\n{\n    vec4 previousKeyboardState = LoadValue(txPreviousKeyboard);\n    \n    // current keys\n    gKeyboardState.mKeyModeForward[0]   = GeyKeyState(KEY_D) || GeyKeyState(KEY_RIGHT);\n    gKeyboardState.mKeyModeBackwards[0] = GeyKeyState(KEY_A) || GeyKeyState(KEY_LEFT);\n    gKeyboardState.mKeyW[0] = GeyKeyState(KEY_W);\n    gKeyboardState.mKeyS[0] = GeyKeyState(KEY_S);\n  \n    // previous keys\n    gKeyboardState.mKeyModeForward[1] \t= (previousKeyboardState.x > 0.0);\n    gKeyboardState.mKeyModeBackwards[1] = (previousKeyboardState.y > 0.0);\n    gKeyboardState.mKeyW[1] = (previousKeyboardState.z > 0.0);\n    gKeyboardState.mKeyS[1] = (previousKeyboardState.w > 0.0);\n}\n\nvoid StoreKeyboardState(inout vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 previousKeyboardState = vec4(float(gKeyboardState.mKeyModeForward[0]), float(gKeyboardState.mKeyModeBackwards[0]), float(gKeyboardState.mKeyW[0]), float(gKeyboardState.mKeyS[0]));\n    StoreValue(txPreviousKeyboard, previousKeyboardState, fragColor, fragCoord);\n}\n \nbool WasKeyJustPressed(in float key)\n{\n    if(key == KEY_RIGHT)\n    {\n        return (gKeyboardState.mKeyModeForward[0] && (gKeyboardState.mKeyModeForward[1] == false));\n    }    \n\telse if(key == KEY_LEFT)\n    {\n        return (gKeyboardState.mKeyModeBackwards[0] && (gKeyboardState.mKeyModeBackwards[1] == false));\n    }\n    return false;\n}\n\n//////////////////////////////////////////////////\n// Modes\nconst float ATTRACT_MODE \t\t= 0.0;\nconst float EDIT_MODE \t\t\t= 1.0;\nconst float MONTE_CARLO_MODE \t= 2.0;\n\nfloat UpdateSceneMode(in float currentSceneMode)\n{\n    if(WasKeyJustPressed(KEY_LEFT))\n    {\n        currentSceneMode = (currentSceneMode >= MONTE_CARLO_MODE) ? ATTRACT_MODE : (currentSceneMode + 1.0);\n    }\n    else if(WasKeyJustPressed(KEY_RIGHT))\n    {\n        currentSceneMode = (currentSceneMode <= ATTRACT_MODE) ? MONTE_CARLO_MODE : (currentSceneMode - 1.0);\n    } \n    return currentSceneMode;\n}\n\nint NextDiffuseType(in int currentDiffuseType)\n{\n    return (currentDiffuseType >= DISNEY_DIFFUSE) ? 0 : (currentDiffuseType + 1);\n}\n\nint NextMicrofacetType(int currentMicrofacetType)\n{\n    return (currentMicrofacetType >= BECKMAN_MICROFACET) ? 0 : (currentMicrofacetType + 1);\n}\n\nint NextGeometricAttenuationType(int currentGeometricAttenuationType)\n{\n    return (currentGeometricAttenuationType >= COOK_TORRANCE_GEOMETRIC) ? 0 : (currentGeometricAttenuationType + 1);\n}\n\nvoid ApplyOptions(in int materialIndex, in float previousMouseX)\n{\n    vec2 redColorSlider \t= CheckSlider(iMouse, 0.18);\n    vec2 greenColorSlider \t= CheckSlider(iMouse, 0.225);\n    vec2 blueColorSlider \t= CheckSlider(iMouse, 0.27);\n    \n    vec2 roughnessSlider \t= CheckSlider(iMouse, 0.365);\n    vec2 metallicSlider \t= CheckSlider(iMouse, 0.455);\n    vec2 reflectanceSlider \t= CheckSlider(iMouse, 0.55);\n    vec2 ambientSlider \t\t= CheckSlider(iMouse, 0.65);\n    \n\tfor(int i = 0; i < NUMBER_OF_MATERIALS; ++i)\n    {\n        if(i == materialIndex)\n        {\n            gMaterials[i].mBaseColor.r = (redColorSlider.x > 0.0) ? redColorSlider.y : gMaterials[i].mBaseColor.r;\n            gMaterials[i].mBaseColor.g = (greenColorSlider.x > 0.0) ? greenColorSlider.y : gMaterials[i].mBaseColor.g;\n            gMaterials[i].mBaseColor.b = (blueColorSlider.x > 0.0) ? blueColorSlider.y : gMaterials[i].mBaseColor.b;\n\n            gMaterials[i].mRoughness \t= max((roughnessSlider.x > 0.0) ? roughnessSlider.y : gMaterials[i].mRoughness, 0.01); // min roughness is 0.01  \n            gMaterials[i].mMetallic \t= (metallicSlider.x > 0.0) ? metallicSlider.y : gMaterials[i].mMetallic;\n            gMaterials[i].mReflectance \t= (reflectanceSlider.x > 0.0) ? reflectanceSlider.y : gMaterials[i].mReflectance;\n            gMaterials[i].mAmbient \t\t= (ambientSlider.x > 0.0) ? ambientSlider.y : gMaterials[i].mAmbient;\n            \n            if(previousMouseX < 0.0)\n            {\n                gMaterials[i].mDiffuseType = (CheckClickBox(iMouse, 0.75) > 0.0) ? NextDiffuseType(gMaterials[i].mDiffuseType) : gMaterials[i].mDiffuseType;\n                gMaterials[i].mMicrofacetDistributionType = (CheckClickBox(iMouse, 0.8) > 0.0) ? NextMicrofacetType(gMaterials[i].mMicrofacetDistributionType) : gMaterials[i].mMicrofacetDistributionType;\n                gMaterials[i].mGeometricAttenuationType = (CheckClickBox(iMouse, 0.85) > 0.0) ? NextGeometricAttenuationType(gMaterials[i].mGeometricAttenuationType) : gMaterials[i].mGeometricAttenuationType;\n            }\n    \t}\n    }\n}\n\n//////////////////////////////////////////////////\n// Implementation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if((fragCoord.x > 15.0) || (fragCoord.y > 3.0))\n    \tdiscard;\n        \n    vec4 sceneInfo = LoadValue(txSceneModeInfo);   \n    vec4 previousMouse = LoadValue(txPreviousMouse);\n    LoadCamera();\n \tLoadMaterials();\n    LoadKeyboardState();\n    \n    if(iFrame == 0)\n    {\n        sceneInfo = vec4(ATTRACT_MODE, -1.0, 0.0, 0.0);\n        ResetMaterialsScene();\n        \n        UpdateCamera();\n    }\n    else if(iFrame == 1)\n    {\n        sceneInfo.x = EDIT_MODE;\n    }\n    else\n    {\n        float previousSceneMode = sceneInfo.x;      \n        float currentSceneMode = UpdateSceneMode(previousSceneMode);\n        \n        if(previousSceneMode != currentSceneMode)\n        {\n         \tsceneInfo.zw = vec2(iFrame, iTime);   \n        }\n        \n        if(currentSceneMode == ATTRACT_MODE)\n        {\n \t\t\tUpdateCamera();\n        }\n        else if(currentSceneMode == EDIT_MODE)\n        {\n            if(iMouse.z > 0.0)\n            {\n                float pendingMaterialIndex = texture(iChannel2, iMouse.xy / iChannelResolution[2].xy).w;\n                const float menuWidth = 0.3;\n                if(iMouse.z > (menuWidth * iResolution.x))\n                {\n                    sceneInfo.y  = pendingMaterialIndex;\n                }\n\n                int currentMaterialIndex = int(sceneInfo.y);\n                if((currentMaterialIndex >= 0) && (currentMaterialIndex < NUMBER_OF_MATERIALS))\n                {\n                    ApplyOptions(currentMaterialIndex, previousMouse.z);\n            \t}\n            }\n        } \n        sceneInfo = vec4(currentSceneMode, sceneInfo.y, sceneInfo.z, sceneInfo.w);\n    }\n    \n    fragColor = vec4(0.0);\n    \n    StoreValue(txSceneModeInfo, sceneInfo, fragColor, fragCoord);\n    StoreValue(txPreviousMouse, iMouse, fragColor, fragCoord);\n    StoreCamera(fragColor, fragCoord);\n    StoreMaterials(fragColor, fragCoord);\n    StoreKeyboardState(fragColor, fragCoord);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Alexander Lemke, 2016\n// Scene Display\n\n// References:\n//\n// PBR\n// https://www.shadertoy.com/view/MlB3DV\n// http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n// http://www.trentreed.net/blog/physically-based-shading-and-image-based-lighting/\n// \n// Monte Carlo References\n// https://www.shadertoy.com/view/MsdGzl\n// https://www.shadertoy.com/view/Xtt3Wn\n\nconst vec2 txSceneModeInfo = vec2(0.0, 0.0); // x = scene mode, selected material, z = monte carlo starting frame, w = monte carlo starting time\nconst vec2 txCameraPosition = vec2(1.0, 0.0);\nconst vec2 txCameraForward = vec2(1.0, 1.0);\nconst vec2 txCameraRight = vec2(1.0, 2.0);\n\n\nconst int NUMBER_OF_MATERIALS = 11;\nconst vec4 txMaterials = vec4(3.0, 0.0, 3.0 + float(NUMBER_OF_MATERIALS), 3.0);\n\n//////////////////////////////////////////////////\n// Settings\n#define     NUMBER_OF_BOUNCES   \t2\n#define     SHADOWS_ENABLED     \t1\n\n//////////////////////////////////////////////////\n// General Constants and Globals\nconst float     PI \t\t\t     = 3.14159265359;\nconst float     MAX_DISTANCE \t = 10.0;\nconst float     EPSILON \t\t = 0.001;\nconst float \tMONTE_CARLO_MODE = 2.0;\n\nvec4 \t\t\tgSceneInfo;\nfloat \t\t\tgTimeValue;\nfloat \t\t\tgSA;\n\n//////////////////////////////////////////////////\n// Helpers \nfloat Saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\nvec3 Saturate(in vec3 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nfloat Hash(in float seed)\n{\n    return fract(sin(seed) * 43758.5453);\n}\n\nvec3 GammaCorrect(in vec3 color)\n{\n    return pow(color, vec3(2.2));\n}\n\nvec3 GammaEncode(in vec3 color)\n{\n    return pow(color, vec3(1.0 / 2.2));\n}\n\nvec3 SampleCubeMap(in vec3 direction, in float x)\n{\n    vec3 sharp = GammaCorrect(texture(iChannel0, direction).rgb);\n    vec3 blurry = texture(iChannel1, direction).rgb;\n    \n    //vec3 linearGammaColor = textureLodEXT(iChannel0, direction, mix(0.0, 8.0, saturate(x))).rgb; :(\n    vec3 linearGammaColor = mix(sharp, blurry, Saturate(x));\n    \n    return linearGammaColor;\n}\n\nvec4 LoadValue(in vec2 re)\n{\n    return texture(iChannel3, (0.5 + re) / iChannelResolution[3].xy, -100.0);\n}\n\nvec3 RandomDirection(in float seed, in vec3 startingDirection)\n{\n    startingDirection = normalize(startingDirection);\n    \n    vec3 direction = normalize(vec3(Hash(78.233 + seed), Hash(10.873 + seed), Hash(27.873 + seed)));\n    direction = (dot(direction, startingDirection) < 0.0) ? -direction : direction;\n    return direction;\n}\n\nvec3 RandomDirectionAroundRange(in float seed, in float range, in vec3 startingDirection)\n{\n    vec3 direction = RandomDirection(seed, startingDirection);\n    direction = (dot(direction, startingDirection) < range) ? startingDirection : direction;\n    return direction;\n}\n\n//////////////////////////////////////////////////\n// Materials\nstruct Material\n{\n    vec3    mBaseColor;\n    float \tmRoughness;\n    float \tmMetallic;\n    float   mReflectance;\n    float   mAmbient;\n    \n    int\t\tmDiffuseType;\n    int \tmMicrofacetDistributionType;\n    int\t\tmGeometricAttenuationType;\n    \n    int \tmIndex;\n};\n    \n// Diffuse Types\nconst int LAMBERT_DIFFUSE \t\t\t= 0;\nconst int DISNEY_DIFFUSE  \t\t\t= 1;\n    \n// Microfacet Distribution Types\nconst int GGX_MICROFACET \t \t\t= 0;    \nconst int BECKMAN_MICROFACET \t\t= 1;\n\n// Geometric Attenuation Types\nconst int VSMITH_GGX_GEOMETRIC \t\t= 0;\nconst int UE4_GEOMETRIC \t\t\t= 1;\nconst int COOK_TORRANCE_GEOMETRIC \t= 2;\n\n    \nMaterial gMaterials[NUMBER_OF_MATERIALS];\n\nMaterial LoadMaterial(in int materialIndex)\n{\n    vec4 materialInfo0 = LoadValue(txMaterials.xy + vec2(float(materialIndex), 0.0));\n    vec4 materialInfo1 = LoadValue(txMaterials.xy + vec2(float(materialIndex), 1.0));\n    vec4 materialInfo2 = LoadValue(txMaterials.xy + vec2(float(materialIndex), 2.0));\n\n    return Material(materialInfo0.xyz, materialInfo0.w, materialInfo1.x, materialInfo1.y, \n                    materialInfo1.z, int(materialInfo2.x), int(materialInfo2.y), int(materialInfo2.z), materialIndex);\n}\n\nvoid LoadMaterials()\n{  \n    for(int i = 0; i < NUMBER_OF_MATERIALS; ++i)\n    {\n    \tgMaterials[i] = LoadMaterial(i);\n    }\n}\n\n//////////////////////////////////////////////////\n// Geometry\nstruct Ray\n{\n    vec3    mPosition;\n    vec3    mDirection;\n};    \n\nstruct Sphere\n{\n    vec3    \tmCenter;\n    float   \tmRadius;\n};\n\nstruct Plane\n{\n    vec3    \tmNormal;\n    float   \tmD;\n};\n        \n//////////////////////////////////////////////////\n// Intersection Helpers   \nstruct IntersectionPoint\n{\n    vec3        mPoint;\n    vec3        mNormal;\n    float       mT;\n    Material    mMaterial;\n};\n    \nIntersectionPoint GetClosestIntersection(in IntersectionPoint a, in IntersectionPoint b)\n{\n    if(a.mT < b.mT)\n    {\n        return a;\n    }\n    return b;  \n}\n  \nbool IsIntersectionValid(in IntersectionPoint a)\n{\n    return (a.mT < (MAX_DISTANCE - EPSILON));  \n}\n\n#define INVALID_INTERSECTION IntersectionPoint(vec3(0.0), vec3(0.0), MAX_DISTANCE, gMaterials[0])\n\n//////////////////////////////////////////////////\n// Intersection Tests\nIntersectionPoint RayPlaneIntersectionTest(in Ray ray, in Plane plane)\n{\n    IntersectionPoint intersection = INVALID_INTERSECTION;\n    \n    float numerator = plane.mD - dot(plane.mNormal, ray.mPosition);\n    float denominator = dot(plane.mNormal, ray.mDirection);\n    if(abs(denominator) > EPSILON)\n    {\n        float t = numerator / denominator;\n        if(t > EPSILON)\n        {\n            intersection.mPoint = ray.mPosition + ray.mDirection * t;\n            intersection.mNormal = plane.mNormal;\n            intersection.mT = t;\n        }\n    }\n    return intersection;\n}\n\nIntersectionPoint RaySphereIntersectionTest(in Ray ray, in Sphere sphere)\n{   \n    IntersectionPoint intersection = INVALID_INTERSECTION;\n\n    vec3 eDistance = ray.mPosition - sphere.mCenter;\n    \n    float b = dot(eDistance, normalize(ray.mDirection));\n    float c = dot(eDistance, eDistance) - (sphere.mRadius * sphere.mRadius);\n    \n    if((c > 0.0 && b > 0.0) == false)\n    {   \n        float discriminant = (b * b) - c;\n        if(discriminant >= EPSILON)\n        {\n            float t = max(-b - sqrt(discriminant), 0.0); // clamp t to zero incase it started inside the sphere\n\n            intersection.mPoint = ray.mPosition + ray.mDirection * t;\n            intersection.mNormal = normalize(intersection.mPoint - sphere.mCenter);\n            intersection.mT = t;         \n        } \n       \n    }\n    return intersection;\n}\n\nIntersectionPoint CheckSceneForIntersection(in Ray currentRay)\n{\n    float sphereRadius = 0.5;\n    \n    // Spheres\n    Sphere sphere0 = Sphere(vec3(-1.5, 0.0, -1.5), sphereRadius);  \n    Sphere sphere1 = Sphere(vec3(-1.5, 0.0, 0.0), sphereRadius);  \n    Sphere sphere2 = Sphere(vec3(-1.5, 0.0, 1.5), sphereRadius);\n    Sphere sphere3 = Sphere(vec3(0.0, 0.0, -1.5), sphereRadius);\n    Sphere sphere4 = Sphere(vec3(0.0, 0.0, 0.0), sphereRadius);\n    Sphere sphere5 = Sphere(vec3(0.0, 0.0, 1.5), sphereRadius);\n    Sphere sphere6 = Sphere(vec3(1.5, 0.0, -1.5), sphereRadius);\n    Sphere sphere7 = Sphere(vec3(1.5, 0.0, 0.0), sphereRadius);\n    Sphere sphere8 = Sphere(vec3(1.5, 0.0, 1.5), sphereRadius);\n\n    // Check scene for intersection   \n    IntersectionPoint sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere0);\n    sphereIntersection0.mMaterial = gMaterials[2];\n\n    IntersectionPoint sphereIntersection1 = RaySphereIntersectionTest(currentRay, sphere1);\n    sphereIntersection1.mMaterial = gMaterials[3];\n    IntersectionPoint closestIntersection = GetClosestIntersection(sphereIntersection0, sphereIntersection1);\n    \n    sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere2);\n    sphereIntersection0.mMaterial = gMaterials[4];  \n    closestIntersection = GetClosestIntersection(closestIntersection, sphereIntersection0);\n    \n    sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere3);\n    sphereIntersection0.mMaterial = gMaterials[5];\n    closestIntersection = GetClosestIntersection(closestIntersection, sphereIntersection0);\n    \n    sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere4);\n    sphereIntersection0.mMaterial = gMaterials[6];\n    closestIntersection = GetClosestIntersection(closestIntersection, sphereIntersection0);\n    \n    sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere5);\n    sphereIntersection0.mMaterial = gMaterials[7];\n    closestIntersection = GetClosestIntersection(closestIntersection, sphereIntersection0);\n    \n    sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere6);\n    sphereIntersection0.mMaterial = gMaterials[8];\n    closestIntersection = GetClosestIntersection(closestIntersection, sphereIntersection0);\n    \n    sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere7);\n    sphereIntersection0.mMaterial = gMaterials[9];\n    closestIntersection = GetClosestIntersection(closestIntersection, sphereIntersection0);\n    \n    sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere8);\n    sphereIntersection0.mMaterial = gMaterials[10];\n    closestIntersection = GetClosestIntersection(closestIntersection, sphereIntersection0);\n    \n    // Ground Plane \n    Plane plane0 = Plane(vec3(0.0, 1.0, 0.0), -0.5);  \n    IntersectionPoint planeIntersection = RayPlaneIntersectionTest(currentRay, plane0);\n\n    planeIntersection.mMaterial = gMaterials[1];  \n    planeIntersection.mMaterial.mBaseColor = texture(iChannel2, planeIntersection.mPoint.xz * vec2(1.5)).rgb;\n    \n    vec2 tile = mod(planeIntersection.mPoint.xz + vec2(0.1), vec2(2.0));\n    if((tile.x + tile.y < 2.0) && (max(abs(planeIntersection.mPoint.x), abs(planeIntersection.mPoint.z)) < 25.0))\n    {\n        planeIntersection.mMaterial = gMaterials[0];\n    }\n    closestIntersection = GetClosestIntersection(closestIntersection, planeIntersection);\n     \n    return closestIntersection;\n}\n\n//////////////////////////////////////////////////////\n// Specular BRDF - Normal Distribution Function (NDF)\n\nfloat BeckmannMicrofacetDistribution(in float NdotH, in float roughnessSquared)\n{\n    float NHSquared = NdotH * NdotH;\n\n    return (1.0 / roughnessSquared * NHSquared * NHSquared) * (exp(-((1.0 - NHSquared) / (roughnessSquared * NHSquared))));\n}\n\nfloat GGXDistribution(in float NdotH, in float roughnessSquared)\n{\n\t// Divide by PI is applied later\n\t//float roughnessSquared = roughness * roughness;\n\t//float f = (NdotH * roughnessSquared - NdotH) * NdotH + 1.0;\n\t//return roughnessSquared / (f * f);\n    \n    //float roughnessSquared = roughness * roughness;\n    //float NdotHSquared = NdotH * NdotH;\n    //float density = NdotHSquared * roughnessSquared + (1.0 - NdotHSquared);\n    //return ((NdotH > 0.0) ? 1.0 : 0.0) * roughnessSquared / (PI * density * density);   \n    \n    float f = (NdotH * roughnessSquared - NdotH) * NdotH + 1.0;\n    return roughnessSquared / (f * f);\n}\n  \nfloat GetMicrofacetDistribution(in int type, in float NdotH, in float roughnessSquared)\n{\n\tif(type == GGX_MICROFACET)\n    {\n        return GGXDistribution(NdotH, roughnessSquared);\n    }\n    return BeckmannMicrofacetDistribution(NdotH, roughnessSquared); // Otherwise we'll assume beckmann\n}\n\n//////////////////////////////////////////////////////\n// Geometric Attenuation\n\n//////////////////////////////////////////////////////\n// Cook Torrance Geometric Attenuation\nfloat CookTorranceGeometricAttenuation(in float NdotH, in float NdotL, in float VdotH, in float NdotV)\n{\n\treturn (min(1.0, min((2.0 * NdotH * NdotL) / VdotH, (2.0 * NdotH * NdotV) / VdotH)));\n}\n\n//////////////////////////////////////////////////////\n// GGXSmith\n//\n// http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n// http://graphicrants.blogspot.co.uk/2013/08/specular-brdf-reference.html\nfloat VSmithGGXCorrelated(in float NdotL, in float NdotV, in float roughnessSquared)\n{\n\t// Original formulation of G_SmithGGX Correlated\n\t//float lambda_l = (-1.0 + sqrt(1.0 + roughnessSquared * (1.0 - NdotV * NdotV) / NdotV * NdotV)) * 0.5;\n    //float lambda_v = (-1.0 + sqrt(1.0 + roughnessSquared * (1.0 - NdotL * NdotL) / NdotL * NdotL)) * 0.5;\n \t\n \t//float G_SmithGGXCorrelated = 1.0 / (1.0 + lambda_v + lambda_l);\n \t//float V_SmithGGXCorrelated = G_SmithGGXCorrelated / (4.0 * NdotL * NdotV);\n\n    //return G_SmithGGXCorrelated * V_SmithGGXCorrelated;\n    \n \t// This is the optimized version\n \t// Caution : the \" NdotL *\" and \" NdotV *\" are explicitely inversed , this is not a mistake.\n \tfloat Lambda_GGXV = NdotL * sqrt((-NdotV * roughnessSquared + NdotV) * NdotV + roughnessSquared);\n \tfloat Lambda_GGXL = NdotV * sqrt((-NdotL * roughnessSquared + NdotL) * NdotL + roughnessSquared);\n\n\treturn Saturate(0.5 / (Lambda_GGXV + Lambda_GGXL));\n}\n\n//////////////////////////////////////////////////////\n// Unreal\n//\n// http://graphicrants.blogspot.co.uk/2013/08/specular-brdf-reference.html\nfloat UE4GeometricAttenuation(in float roughnessSquared, in float NdotV)\n{\n\tfloat k = roughnessSquared / 2.0;\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nfloat GetGeometricAttenuation(int type, in float NdotH, in float NdotL, in float VdotH, in float NdotV, in float roughnessSquared)\n{\n    if(type == VSMITH_GGX_GEOMETRIC)\n    {\n        return VSmithGGXCorrelated(NdotV, NdotL, roughnessSquared);\n    }\n    else if(type == UE4_GEOMETRIC)\n    {\n        return UE4GeometricAttenuation(roughnessSquared, NdotV);\n    }\n    return CookTorranceGeometricAttenuation(NdotH, NdotL, VdotH, NdotV); // Otherwise we'll assume cook torrance\n}\n\n//////////////////////////////////////////////////////\n// Fresnel \nvec3 SchlickFresnel(in float u, in vec3 fresnelReflectanceIndex0, in float fresnelReflectanceIndex90)\n{\n    return fresnelReflectanceIndex0 + (fresnelReflectanceIndex90 - fresnelReflectanceIndex0) * pow(Saturate(1.0 - u), 5.0);\n}\n\n//////////////////////////////////////////////////////\n// Diffuse\nfloat DisneyDiffuse(in float NdotV, in float NdotL, in float LdotH, in float linearRoughness)\n{\n    float energyBias = mix(0.0, 0.5, linearRoughness);\n    float energyFactor = mix(1.0, 1.0 / 1.51,  linearRoughness);\n    float fd90 = energyBias + 2.0 * LdotH * LdotH * linearRoughness;\n    \n    vec3 f0 = vec3(1.0);\n    float lightScatter = SchlickFresnel(NdotL,f0, fd90).x;\n    float viewScatter = SchlickFresnel(NdotV, f0, fd90).x;\n    return lightScatter * viewScatter * energyFactor;\n}\n\nfloat GetDiffuse(in int type, in float NdotV, in float NdotL, in float LdotH, in float linearRoughness)\n{\n    if(type == DISNEY_DIFFUSE)\n    {\n        return DisneyDiffuse(NdotV, NdotL, LdotH, linearRoughness) / PI;\n    }\n    return 1.0 / PI; // otherwise we assume lambert\n}\n\nstruct DirectionalLight\n{\n    vec3 mDirection;\n    vec3 mColor;\n}; \n\nstruct BRDFOutput\n{\n\tvec3 mDiffuse;\n    vec3 mSpecular;\n    vec3 mLighting;\n    vec3 mBackgroundReflectionColor;\n};\n\nBRDFOutput GetBRDFOutput(in vec3 point, in vec3 normal, in vec3 eye, in vec3 lightDirection, in vec3 lightColor, in float attenutation, in Material material)\n{  \n    BRDFOutput returnValue;\n    \n    // Determine some values\n    float roughness = max(material.mRoughness, 0.01); // min roughness is 0.01\n    float roughnessSquared = roughness * roughness;\n    \n    vec3 viewVector = normalize(eye - point);   \n    vec3 halfVector = normalize(lightDirection + viewVector);\n\t\n    float NdotL = Saturate(dot(normal, lightDirection));\n    float NdotH = Saturate(dot(normal, halfVector));\n    float NdotV = abs(dot(normal, viewVector)) + EPSILON;\n    float VdotH = Saturate(dot(viewVector, halfVector));\n    float LdotH = Saturate(dot(lightDirection, halfVector));\n    \n    // D = MicrofacetDistribution\n    float microfacetDistribution = GetMicrofacetDistribution(material.mMicrofacetDistributionType, NdotH, roughnessSquared);\n    \n    // G = Geometric attenuation\n    float geometricAttenuation = GetGeometricAttenuation(material.mGeometricAttenuationType, NdotH, NdotL, VdotH, NdotV, roughnessSquared);\n    \n    // F = Fresnel\n    float reflectanceSquared = material.mReflectance * material.mReflectance;\n    //vec3 f0 = ((material.mReflectance) * (1.0 - material.mMetallic)) + (material.mBaseColor * material.mMetallic);    \n    vec3 f0 = (0.16 * (reflectanceSquared) * (1.0 - material.mMetallic)) + (material.mBaseColor * material.mMetallic);    \n    \n    float f90 = Saturate(50.0 * dot(f0, vec3(0.33)));\n    vec3 fresnel = SchlickFresnel(LdotH, f0, f90);\n    \n    // Diffuse \n    vec3 diffuseColor = ((1.0 - material.mMetallic) * material.mBaseColor);\n    returnValue.mDiffuse = diffuseColor * GetDiffuse(material.mDiffuseType, NdotV, NdotL, LdotH, roughness);\n\n    // Specular\n    returnValue.mSpecular = (fresnel * microfacetDistribution * geometricAttenuation) / PI;\n    \n    // Lighting\n    returnValue.mLighting = NdotL * lightColor * attenutation;\n    \n    vec3 reflectionDirection = reflect(-viewVector, normal); \n    returnValue.mBackgroundReflectionColor = SampleCubeMap(reflectionDirection.xyz, material.mRoughness);\n    \n    return returnValue;\n}\n\nBRDFOutput ApplyDirectionalLight(in DirectionalLight light, in Material material, in vec3 point, in vec3 normal, in vec3 eye, in bool castShadow)\n{\n    vec3 lightDirection = normalize(-light.mDirection);\n    BRDFOutput returnValue = GetBRDFOutput(point, normal, eye, lightDirection, light.mColor, 1.0, material);\n                 \n    // Cast a ray to check for shadows\n    float shadow = 1.0;\n#if SHADOWS_ENABLED\n    if(castShadow)\n    {\n    \tvec3 shadowRayDirection = (gSceneInfo.x == MONTE_CARLO_MODE) ? RandomDirectionAroundRange(float(iFrame), 0.7, lightDirection) : lightDirection;\n    \tRay shadowRay = Ray(point + (EPSILON * normal), shadowRayDirection);\n    \tIntersectionPoint lightIntersection = CheckSceneForIntersection(shadowRay);\n    \tshadow = IsIntersectionValid(lightIntersection) ? 0.0 : shadow; // Determine if we hit an object and are in a shadow region \n    }\n#endif // SHADOWS_ENABLED\n    returnValue.mLighting *= shadow;\n    \n\treturn returnValue;\n}\n\nBRDFOutput AddBRDFOutput(in BRDFOutput a, in BRDFOutput b)\n{\n\tBRDFOutput returnValue;\n    \n    returnValue.mDiffuse =  max(a.mDiffuse, b.mDiffuse);\n    returnValue.mSpecular = max(a.mSpecular, b.mSpecular);\n    returnValue.mLighting = a.mLighting + b.mLighting;\n    returnValue.mBackgroundReflectionColor = a.mBackgroundReflectionColor;\n    \n    return returnValue;\n}\n\nBRDFOutput CalculateLighting(in Material material, in vec3 point, in vec3 normal, in vec3 eye)\n{\n    BRDFOutput returnValue;\n    \n    DirectionalLight directionalLight = DirectionalLight(vec3(0.0, -1.0, 0.0), vec3(1.0));;    \n    returnValue = ApplyDirectionalLight(directionalLight, material, point, normal, eye, true);\n\n    directionalLight.mDirection = normalize(vec3(15.0 * sin(gTimeValue), -8.0, 15.0 * cos(gTimeValue)));\n    returnValue = AddBRDFOutput(returnValue, ApplyDirectionalLight(directionalLight, material, point, normal, eye, true));\n    \n    directionalLight.mDirection = normalize(vec3(-15.0 * cos(-gTimeValue), -8.0, 15.0 * sin(-gTimeValue)));\n    returnValue = AddBRDFOutput(returnValue, ApplyDirectionalLight(directionalLight, material, point, normal, eye, true));\n    \n    return returnValue;\n}\n\nvec4 CalculateColor(in Ray ray, in float sa, in int currentFrameIndex)\n{\n    vec3 colorMask = vec3(1.0);\n    vec3 accumulatedColor = vec3(0.0);\n\n    int materialIndex = NUMBER_OF_MATERIALS;\n \tfloat previousRoughness = 0.0;   \n\n    IntersectionPoint currentIntersection = CheckSceneForIntersection(ray);\n\tbool isIntersectionValid = IsIntersectionValid(currentIntersection);\n   \n    if(isIntersectionValid)\n    {\n        vec3 point = currentIntersection.mPoint;\n        vec3 normal = currentIntersection.mNormal;\n        materialIndex = currentIntersection.mMaterial.mIndex;\n\t\tpreviousRoughness = currentIntersection.mMaterial.mRoughness;\n        \n        BRDFOutput brdfOutput = CalculateLighting(currentIntersection.mMaterial, point, normal, ray.mPosition);\n\n        vec3 ambientColor = (currentIntersection.mMaterial.mAmbient * currentIntersection.mMaterial.mBaseColor); \n        \n        if(gSceneInfo.x != MONTE_CARLO_MODE)\n        {\n        \taccumulatedColor = ((brdfOutput.mDiffuse + brdfOutput.mSpecular * brdfOutput.mBackgroundReflectionColor) * brdfOutput.mLighting + ambientColor);        \n        }\n        else\n        {\n            accumulatedColor = ((brdfOutput.mDiffuse + brdfOutput.mSpecular) * brdfOutput.mLighting + ambientColor);        \n        }\n        colorMask *= brdfOutput.mSpecular;\n\n        // Determine the bounce direction of the ray incase we need it\n        vec3 reflectionDirection = reflect(ray.mDirection, normal);\n        reflectionDirection = RandomDirectionAroundRange(float(currentFrameIndex) / 37.81, mix(1.0, 0.5, currentIntersection.mMaterial.mRoughness), reflectionDirection);\n        ray.mDirection = reflectionDirection;       \n        ray.mPosition = point + ray.mDirection * EPSILON;  \n    }\n    else\n    {\n        accumulatedColor = SampleCubeMap(ray.mDirection, 0.0);\n    }\n     \n    // Only apply the bounces if we actually hit something\n   \tif((gSceneInfo.x == MONTE_CARLO_MODE) && isIntersectionValid)\n    {\n        vec3 sceneColor = vec3(0.0);\n        for(int bounceIndex = 0; bounceIndex < NUMBER_OF_BOUNCES; ++bounceIndex)\n        {\n            if(isIntersectionValid == false)\n            {\n                break;\n            }\n            \n            ray.mDirection = normalize(ray.mDirection);\n            IntersectionPoint currentIntersection = CheckSceneForIntersection(ray);\n\n            // Only apply the bounces if we actually hit something\n            isIntersectionValid = IsIntersectionValid(currentIntersection);\n            if(isIntersectionValid)\n            {\n                vec3 point = currentIntersection.mPoint;\n                vec3 normal = currentIntersection.mNormal;\n                previousRoughness = currentIntersection.mMaterial.mRoughness;\n    \n                BRDFOutput brdfOutput = CalculateLighting(currentIntersection.mMaterial, point, normal, ray.mPosition);\n\n                vec3 ambientColor = (currentIntersection.mMaterial.mAmbient * currentIntersection.mMaterial.mBaseColor); \n                vec3 sceneColor = ((brdfOutput.mDiffuse + brdfOutput.mSpecular * brdfOutput.mBackgroundReflectionColor) * brdfOutput.mLighting + ambientColor);        \n\n                // Add direct lighting\n                accumulatedColor += sceneColor * colorMask;\n                colorMask *= brdfOutput.mSpecular;\n\n                vec3 reflectionDirection = reflect(ray.mDirection, normal);\n                reflectionDirection = RandomDirectionAroundRange(float(currentFrameIndex) / 37.87, mix(1.0, 0.5, currentIntersection.mMaterial.mRoughness), reflectionDirection);\n                ray.mDirection = reflectionDirection;\n                ray.mPosition = point + ray.mDirection * EPSILON;           \n            }\n            else\n            {\n                sceneColor =  SampleCubeMap(ray.mDirection, previousRoughness).rgb;\n                accumulatedColor += sceneColor * colorMask;\n            }\n        }  \n    }\n \treturn vec4(accumulatedColor, float(materialIndex));   \n}\n\n//////////////////////////////////////////////////\n// Implementation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    LoadMaterials();\n    \n    gSceneInfo = LoadValue(txSceneModeInfo);\n    gTimeValue = (gSceneInfo.x == MONTE_CARLO_MODE) ? gSceneInfo.w : iTime;\n\n    vec2 screenCoord = (fragCoord.xy / iResolution.xy);\n    float aspect = (iResolution.x / iResolution.y);\n    vec2 aspectRatioAdjustedUVs = vec2((screenCoord.x * 2.0 - 1.0) * aspect, (screenCoord.y * 2.0 - 1.0));\n \n    vec3 cameraPosition = LoadValue(txCameraPosition.xy).xyz;\n    vec3 cameraForward = LoadValue(txCameraForward.xy).xyz;\n    vec3 cameraRight = LoadValue(txCameraRight.xy).xyz;\n\n    if(iFrame == 0)\n    {\n    \tcameraPosition = vec3(0.0, 0.0, 3.5);\n        cameraForward = vec3(0.0, 0.0, -1.0);\n    \tcameraRight = vec3(1.0, 0.0, 0.0);\n        \n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    vec3 cameraUp = -cross(cameraForward, cameraRight);  \n    vec3 cameraDirection = normalize(cameraForward + (aspectRatioAdjustedUVs.x * cameraRight) + (aspectRatioAdjustedUVs.y * cameraUp));\n    \n    gSA = 0.0;\n    int currentMonteCarloFrame = iFrame - int(gSceneInfo.z);\n    \n    if(gSceneInfo.x == MONTE_CARLO_MODE)\n    {\n        gSA = Hash(dot(fragCoord, vec2(12.9898, 78.233)) + 1113.1 * (float(currentMonteCarloFrame)));\n    \tvec2 cameraOffset = -0.5 + vec2(Hash(gSA + 13.271), Hash(gSA + 63.216));\n\n        cameraOffset *= (1.0 / iResolution.xy);\n    \tcameraDirection = normalize(cameraDirection + (cameraOffset.x * cameraRight) + (cameraOffset.y * cameraUp));    \n    }\n    \n    Ray ray = Ray(cameraPosition, cameraDirection);\n    fragColor = CalculateColor(ray, gSA, currentMonteCarloFrame);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Alexander Lemke, 2016\n// Monte Carlo Rendering\n//\n// Monte Carlo References\n// https://www.shadertoy.com/view/MsdGzl\n// https://www.shadertoy.com/view/Xtt3Wn\n\nconst vec2 txSceneModeInfo = vec2(0.0, 0.0); // x = scene mode, selected material, z = monte carlo starting frame, w = monte carlo starting time\nconst float MONTE_CARLO_MODE = 2.0;\n\nvec4 LoadValueBufferA(in vec2 re)\n{\n    return texture(iChannel2, (0.5 + re) / iChannelResolution[2].xy, -100.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 sceneInfo = LoadValueBufferA(txSceneModeInfo);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 sceneColor = texture(iChannel0, uv);\n\n    if((iFrame > 0) && (sceneInfo.x == MONTE_CARLO_MODE))\n    {\n   \t\tvec3 accumulatedColor = texture(iChannel1, uv).rgb;    \n    \tsceneColor = vec4(accumulatedColor.rgb + sceneColor.rgb, 1.0); \n    }  \n    fragColor = sceneColor;\n}","name":"Buf C","description":"","type":"buffer"}]}