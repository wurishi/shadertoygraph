{"ver":"0.1","info":{"id":"ddfGz2","date":"1666431263","viewed":98,"name":"Distance field coloring","username":"Envy24","description":"Exploring iq routine for coloring distance field.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","distance","field","function","coloring"],"hasliked":0,"parentid":"DdfGD7","parentname":"Blobs __"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n#define NZMY                      ( (iMouse.y+iMouse.y-R.y) / R.y )  // in range [-1.0; 1.0]\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define FIELD_SCALE                 2.0\n#define TAU                         6.2831853071795862\n#define PI                          3.1415926535897932\n\n/* L1 metric *\n#define METRIC(B, E) ( L1(B, E) )\n#define SEGMENT(P, B, E, R) ( segmentSDF_L1(P, B, E, R) )\n/* L2 metric */\n#define METRIC(B, E) ( L2(B, E) )\n#define SEGMENT(P, B, E, R) ( segmentSDF_L2(P, B, E, R) )\n/* Linf metric *\n#define METRIC(B, E) ( Linf(B, E) )\n#define SEGMENT(P, B, E, R) ( segmentSDF_Linf(P, B, E, R) )\n/**/\n\n// Define parametric curve\nvec2 parametric_curve2(float t) { return vec2(tan(sin(t)), tan(cos(t))); }\nfloat parametric_curve1(float t) { return 1.5*sin(t); }\n\n/* Pick curve definition. */\n#define CURVE(T) ( parametric_curve2(T) )\n//#define CURVE(T) ( vec2(T, parametric_curve1(T)) )\n\nfloat parametricSDF(\n    in vec2 NDC)\n{\n    float min_dist = 99.,\n          count = 200.,\n          a = -AR*FIELD_SCALE*1.1, b = AR*FIELD_SCALE*1.1,\n          dt = (b-a) / (count-1.);\n    \n    vec2 B = CURVE(a);\n      \n    for (float i = 1.; i < count; i += 1.)\n    {\n        vec2 E = CURVE(a + dt * i);\n        min_dist = \n            min(min_dist, SEGMENT(NDC, B, E, 0.));\n        B = E;\n    }\n    \n    float R = sinOSC(0.1, 0.4, iTime); \n    return min_dist-R;\n}\n\n#define UNIT                      ( 8.0 / R.y )                      // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define F                         ( 30. )\n/* original IQ coloring routine */\nvec3 colorize_field_iq(float dist, vec3 color)\n{      \n    color = 1.0 - sign(dist) * color;      // Change color if dist is negative.    \n\tcolor *= 1.0 - exp(-4.0 * abs(dist));  // Attenuate color around edges.   \n\tcolor *= 0.7 + 0.2 * cos(F * dist);    // Add interleaved curves.   \n    // Add white edges.\n    return mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 6./R.y, abs(dist)));\n}\n\n// exponential decay/raise: https://www.shadertoy.com/view/dsfGz2\nvec3 colorize_field0(float dist, vec3 color){ return mix(color * exp(-4.*dist), vec3(1), SMAA(abs(dist)) ); }\nvec3 colorize_field1(float dist, vec3 color){ return mix(color * exp(-4.*abs(dist)), vec3(1), SMAA(abs(dist)) ); }\nvec3 colorize_field2(float dist, vec3 color){ return mix(color * (1.-exp(-4.*abs(dist))), vec3(1), SMAA(abs(dist)) ); }\nvec3 colorize_field3(float dist, vec3 color) { return mix((1.-color) * (1.-exp(-4.*abs(dist))), vec3(1), SMAA(abs(dist)) ); }\nvec3 colorize_field4(float dist, vec3 color)\n{    \n    float freq = F*dist, aa = 1./F, C = 0.7, amp = 0.2, width = 0.3,\n          waves_sdf = C + amp*SMAA((width+cos(freq)) * aa),\n          //waves_sdf = c + amp*SMAA(cos(freq) * aa),\n          //waves_sdf = 0.7 + 0.2*(cos(freq)), // iq variant\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= waves_sdf;               // Add waves.\n    \n    return mix(color, vec3(1), SMAA(abs(dist)) );\n}\n\nvec3 add_metric_function(\n    vec2 NDC,\n    vec3 color)\n{\n    float unit = 7.0 / R.y;\n\n    vec2 M = \n        LMB_IS_HOLD ?\n            TO_CENTERED_NDC(iMouse.xy) * FIELD_SCALE :\n            rotateAroundZ(vec2(1, 0), iTime * 0.5) * 1.5;\n            //vec2(0);\n    \n    //M=vec2(0.0, 0.0);\n    \n    // Add point\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(NDC - M) - 0.008));\n\n    float dist_form_point_to_box_edge = METRIC(NDC, M) - abs(parametricSDF(M));\n    float outline = abs(dist_form_point_to_box_edge);\n    \n    // Add metric function\n    return mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, outline));\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC) * FIELD_SCALE;\n    float minDist = parametricSDF(NDC);\n    \n    float T = iTime*0.25;\n    vec3 c = HASH3(T, T+1., T+2.);\n    vec3 color;\n    \n    int case_ = int((SC.y/R.y) * 6.) % 6;\n    switch (case_)\n    {\n    case 0: color = colorize_field0(minDist, c); break;\n    case 1: color = colorize_field2(minDist, c); break;\n    case 2: color = colorize_field4(minDist, c); break;\n    case 3: color = colorize_field_iq(minDist, c); break;\n    case 4: color = colorize_field3(minDist, c); break;\n    case 5: color = colorize_field1(minDist, c); break;\n    }\n    \n    if (NDC.x > AR) { color = colorize_field4(minDist, c); }\n    else if (NDC.x < -AR) { color = colorize_field_iq(minDist, c); }\n    \n    color = add_metric_function(NDC, color);\n\n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}\n\nfloat L1(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return abs(D.x) + abs(D.y);\n}\n\nfloat L2(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return sqrt(D.x*D.x + D.y*D.y);\n}\n\nfloat Linf(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return max(abs(D.x), abs(D.y));\n}\n\n#define P(t) (S + (E - S)*t)\nfloat segmentSDF_L1(\n    vec2 NDC,\n    vec2 S,\n    vec2 E,\n    float R)\n{\n    float invD0 = 1.0 / (S.y-E.y);\n    return min(L1(P(clamp((NDC.x-S.x) / (E.x-S.x), 0.0, 1.0)), NDC), \n               min(L1(P(clamp((NDC.y+S.y) * invD0, 0.0, 1.0)), NDC),\n                   L1(P(clamp((S.y-NDC.y) * invD0, 0.0, 1.0)), NDC))) - R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E,\n    float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}\n\nfloat segmentSDF_Linf(\n    vec2 NDC,\n    vec2 S,\n    vec2 E,\n    float R)\n{\n    return min(Linf(P(clamp((S.y-S.x+NDC.x-NDC.y)/(E.x-S.x+S.y-E.y), 0.0, 1.0)), NDC), \n               Linf(P(clamp((S.y-NDC.y+S.x-NDC.x)/(S.x-E.x+S.y-E.y), 0.0, 1.0)), NDC)) - R;\n}\n\n/* \n    Returns random vec3([-1.0; 1.0], [-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec3 hash3to3(\n    const uint x,\n    const uint y,\n    const uint z)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 1200u;\n    const uint entropy1 = 4500u;\n    const uint entropy2 = 6700u;\n    const uint entropy3 = 8900u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = z * entropy3 * entropy2 + y * entropy2 + x;\n    uint value1 = y * entropy3 * entropy2 + x * entropy2 + z;\n    uint value2 = x * entropy3 * entropy2 + z * entropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += entropy1; value0 *= 445593459u; value0 ^= entropy0;\n    value1 += entropy1; value1 *= 445593459u; value1 ^= entropy0;\n    value2 += entropy1; value2 *= 445593459u; value2 ^= entropy0;\n\n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return vec3(\n        float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n        float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f,\n        float(value2 * value2 * value2) * 4.6566128730773926e-10f - 1.0f);\n}\n#define HASH3(x, y, z) ( abs(hash3to3(uint(x), uint(y), uint(z))) )","name":"Common","description":"","type":"common"}]}