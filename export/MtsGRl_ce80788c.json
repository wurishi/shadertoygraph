{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"music","id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define time iTime\n#define EPSILON .001\nconst float PI=3.14159265;\nconst int MAX_ITER = 250;\nvec3 lightDir       =normalize(vec3(14., -1.6, -9.)); \n    vec2 of; //= texture( iChannel2, vec2( 0., 0.15 ) ).xy*vec2(1,-0.8) +  vec2(0.5,1.5);\nstruct mat\n{\n  float typeMat;        \n     \n};\nmat materialMy = mat(0.0);\n\n//-----------------------------\nvec3 getNormal(in vec3 p);\nfloat renderFunction(in vec3 pos);\nfloat render(in vec3 posOnRay, in vec3 rayDir);\nvec4 getColorPixel(inout vec3 ro, vec3 rd, inout vec3 normal, float dist, float typeColor);\n//-----------------------------\n//---------------------------------------------\nvec3 rotationCoord(vec3 n)\n{\n vec3 result;\n\n   float t = time;\n   vec2 sc = vec2(sin(t), cos(t));\n   mat3 rotate;\n\n      rotate = mat3( sc.y,  0.0, -sc.x,\n                     0.0,   1.0,  0.0,\n                     sc.x,  0.0, sc.y);   \n\n  result = n * rotate;\n  return result;\n}\n//------------------------------------------\nvec2 rot(vec2 p,float r)\n{\n  vec2 ret;\n  ret.x=p.x*cos(r)-p.y*sin(r);\n  ret.y=p.x*sin(r)+p.y*cos(r);\n  return ret;\n}\n//------------------------------------------\nvec2 rotsim(vec2 p,float s)\n{\n  vec2 ret=p;\n  ret=rot(p,-PI/(s*2.0));\n  ret=rot(p,floor(atan(ret.x,ret.y)/PI*s)*(PI/s));\n  return ret;\n}\n//----------------------------------------------------\n//----------------------------------------------------\n//ÐŸÑ€Ð¸Ð¼Ð¸Ñ‚Ð¸Ð²Ñ‹\n//----------------------------------------------------\nfloat trunCapsuleY(vec3 p, float r, float h)\n{\n    p.y -= clamp(p.y, 0.0, h * 2. );\n    return max(length(p) - r ,  abs(p.z)- h / 2.);\n}\n//--------------------------------------------------\nfloat sdHeart(in vec3 pos, in float r, in float d) \n{\n    pos = -pos; \n    pos.x = abs(pos.x);\n    pos.xy = sqrt(3.5)* 0.15 *mat2(1.,-1.,1.,1.)*pos.xy;\n    float hr = trunCapsuleY(pos-vec3(r, 0, 0), r, d);\n    return hr;\n}\n//----------------------------------------------------\nfloat dSphere(vec3 p, float r)\n{\n   return length(p) - r;\n}\n//----------------------------------------------------\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float basic = 0.61;\n    return max(q.z-h.y,max(q.x* basic +p.y*0.5,-p.y)-h.x*0.5);\n}\n//-------------------------\nfloat pTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n//----------------------------------------------------\nfloat zCylinder(vec3 p, vec2 h) \n{\n    return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//----------------------------------------------------\nfloat yCylinder(vec3 p, vec2 h) \n{\n    return max( length(p.xy)-h.x, abs(p.z)-h.y );\n}\n//----------------------------------------------------\n//--------------------------------------------------\nfloat smin( float a, float b, float k ) \n{\n   float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n   return mix( b, a, h ) - k*h*(1.0-h);\n}\n//------------------------------------------\nfloat plush(in vec3 p) \n{\n   p=abs(fract(p ));\n    for (int i=0; i< 9; i++) \n   {\n      p=abs(p)/dot(p,p)-0.5;\n   }\n   float l=min(3.,length(p));\n   return pow(l , 1.1);\n}\n\n//---------------------------------------------\nfloat distMat(inout float curDist, float dist, in float typeMat)\n{\n   float res = curDist;\n   if (dist < curDist) \n   {\n      materialMy.typeMat     = typeMat;\n      res                    = dist;\n     return res;\n   }\n   return curDist;\n}\n//--------------------------------------------------ÐœÐµÐ´Ð²ÐµÐ´ÑŒ\nfloat bear(in vec3 pos )\n{\n  float d = 1.;\n   d = dSphere(pos, 6.);\n   pos.y +=15.;\n   d = smin(d, dSphere(pos * vec3(0.8, 0.5, 0.8), 6.), 0.8); \n   d = smin(d, dSphere(pos * vec3(1.03, 1.08, -0.64) + vec3(0., -15.58, 1.52), 3.8), 0.1);\n   vec3 p1 = pos;\n   p1.x = abs(p1.x);   \n   // Ð£ÑˆÐ¸\n   d = smin(d, dSphere(p1 * vec3(1.14, 0.94, 1.68) + vec3(-5, -18., 0.), 3.), 0.3);   \n   d = max(d, -dSphere(p1  + vec3(-4.6, -19.6, -1.), 1.5));    \n   //ÐÐ¾Ð³Ð¸\n   d = smin(d, dSphere(p1 * vec3(1.75, 1.72, -0.7 ) + vec3(-8., 15., 4.), 6.), 1.8); \n   d = smin(d, dSphere(p1 * vec3(1.46, 0.78, 1.28) + vec3(-6., 5.25, -18.6), 4.), 0.3);    \n   //Ð›Ð°Ð¿Ñ‹\n   d = smin(d, dSphere(p1 * vec3(2.39, 1.72, -0.96 ) + vec3(-14.6, -10.8, 4.5), 6.), 1.8); \n  // Ð›ÐµÐ²Ð°Ñ\n   d = smin(d, dSphere(pos  * vec3(1., 1.16, 1. ) + vec3(3.18, -6., -10.3), 3.), 1.8);    \n  // ÐŸÑ€Ð°Ð²Ð°Ñ\n   d = smin(d, dSphere(pos  * vec3(1.2, 0.88, 1.1) + vec3(-7., -8., -12.), 3.), 1.8);\n  return d;\n  \n}\n//--------------------------------------------------Ð’ÐµÑ€Ñ‚ÑƒÑˆÐºÐ°\nfloat whirligig(in vec3 p )\n{\n p.zy = rot(p.zy,(time )* 5.);\n p.yz=rotsim(p.yz,3.0);\n return sdTriPrism( p, vec2(1.5, 5.) );;\n}\n//--------------------------------------------------Ð ÑƒÑ‡ÐºÐ°\nfloat grip(in vec3 p )\n{\n float grip = zCylinder(p  ,vec2(0.4, 11.)) ;\n p += vec3(0.2, 10.6, -2.5);\n p.xz = rot(p.xz, 1.5);\n return min(grip, max(pTorus(p  , vec2(2.5, 0.4)), p.y + 0.25));\n}\n//--------------------------------------------------\nfloat myObject(in vec3 p)\n{\n   materialMy.typeMat = 0.0;\n   vec3 pos = p;\n   pos += vec3(0., -10., 12.);\n   pos = rotationCoord(pos);     \n   float d = 1.0;\n   d =  distMat(d, zCylinder(pos + vec3(0., 26.7, 0.),vec2(30., 0.3)), 6.) ;   \n  \n   vec3 p1 = pos;\n   p1.x = abs(p1.x);\n   p1 += vec3(-3.12, -1.62, -4.54);   \n   float eyes = dSphere(p1, 1.);\n   d =  distMat(d,   eyes ,  3.0); \n   d =  distMat(d,   dSphere(pos * vec3(0.78, 1.18, 1.) + vec3(0., -0.36, -7.5), 1.55) ,  3.0);    \n\n   float det =  pTorus(pos * vec3(0.88, 1.41, 0.68) + vec3(0., 2.4, -4.2), vec2(2., 0.26)); \n   p1 = pos;\n   p1 += vec3(0., 1.14, -6.37);\n   p1.xz = rot(p1.xz, 1.5);\n   det = min(det, pTorus(p1 * vec3(1.08, 1.06, 0.6) ,  vec2(2., 0.26)));\n   d =  distMat(d,  det , 2.);\n  // ÐœÐ¸ÑˆÐºÐ°\n  float toy = bear(pos );\n   toy *=  plush(pos);\n   d =  distMat(d,   toy ,  1.0);     \n   vec3 pos1 = pos;\n  // Ð¡ÐµÑ€Ð´Ñ†Ðµ \n//    float of = texture( iChannel2, vec2( .01, .25 ) ).x;\n   p1 = pos;\n   p1.xy *=  of;//p1.xy * sin(of)  ;\n   p1 += vec3(0., 6., -9) ;\n   \n   float hr = sdHeart(p1, 1., 1.8);\n   d =  distMat(d,    hr ,  5.0);   \n// Ð ÑƒÑ‡ÐºÐ° \n float g = grip(pos + vec3(-6., 0., -13.));\n\n d = distMat(d, g, 2.); \n // Ð’ÐµÑ€Ñ‚ÑƒÑˆÐºÐ°\n float w = whirligig(pos + vec3(-7.5, -10.6, -12.8));\n d = distMat(d, w, 4.); \n\nreturn d; \n}\n//-------------------------------------------------\n// Ð²Ñ‹Ð²Ð¾Ð´ Ð¾Ð±ÑŠÐµÐºÑ‚Ð°\nfloat renderFunction(in vec3 pos)\n{\n    return  myObject(pos);    \n}\n//------------------------------------------------- \nvec3 getNormal(in vec3 p)\n{\n\n   vec3 e = vec3( 0.1, 0., 0. );\n   vec3 nor = vec3(\n       renderFunction(p+e.xyy) - renderFunction(p-e.xyy),\n       renderFunction(p+e.yxy) - renderFunction(p-e.yxy),\n       renderFunction(p+e.yyx)- renderFunction(p-e.yyx));\n   return normalize(nor);  \n\n}\n//------------------------------------------\nvec3 getlighting(in vec3 ro, in vec3 rd ,in vec3 norm, in vec3 lightDir, in vec4 color)\n{\n     vec3 ref = reflect( rd, norm );\n     vec3 col = vec3(0.0);\n     col += mix( vec3(0.05,0.02,0.0), 1.2*vec3(0.8,0.9,1.0), 0.5 + 0.5*norm.y );\n     col *= 1.0 + 1.5*vec3(0.7,0.5,0.3)*pow( clamp( 1.0 + dot(norm,rd), 0.0, 1.0 ), 2.0 );\n     col += 27. *clamp(0.3 + 2. * norm.y, 0.0,1.0)* pow(texture( iChannel0, ref ).xyz,vec3(2.2));//*(rim);\n     col *= color.w;\n     col *= color.rgb;\n \n  //  vec2 q = fragCoord.xy / iResolution.xy;// gl_TexCoord[0].xy;      \n  //  col *= -0.16 + 0.68 * pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );  \n    return col ;    \n\n}\n//----------------------------------------------------------------------\nvec4 getColorPixel(inout vec3 ro, vec3 rd, inout vec3 normal, float dist, float typeColor)\n{\n\n  vec4 color = vec4(1.);\n  vec3 hitPos = ro + rd * dist;\n  normal = normalize(getNormal(hitPos));  \n  float diffuse = max(0.0, dot(normal, -lightDir)) * 0.5 + 0.5;\n \n  float specular = 0.0;   \n      if (dot(normal, -lightDir) < 0.0) \n         specular = 0.0;\n     else \n         specular = pow(max(0.0, dot(reflect(-lightDir, normal), normalize(ro - hitPos))), 5.0);\n\n//----------------------------------\n   if (materialMy.typeMat == 0.0) \n  {\n     color =  texture(iChannel0, rd);\n     diffuse = 1.0;\n   } \n   else if (materialMy.typeMat == 1.0) \n     color = vec4(1.);\n   else if (materialMy.typeMat == 2.0) \n     color = vec4(0.37, 0.16, 0.16, 1.);\n   else if (materialMy.typeMat == 3.0) \n     color = vec4(0.35, 0.33, 0.36, 1.);\n   else if (materialMy.typeMat == 4.0) \n     color = vec4(0.9, 0.25, 1., 1.);  \n   else if (materialMy.typeMat == 5.0)\n    color = vec4(0.85, 0., 0.05, 1.);  \n   else if (materialMy.typeMat == 6.0)    \n   {\n       vec3 pos = rotationCoord(hitPos);     \n        color.rgb = texture( iChannel1, 0.05 *  pos.xz ).xyz;\n   }    \n   float mat =  materialMy.typeMat;\n   if(mat != 0.0)\n  {\n     if( mat > 2.5 && mat < 5.5)\n      color.rgb =  getlighting(hitPos, rd ,normal, lightDir, color);\n     else\n        color.rgb *= diffuse + specular;   \n  }\n  ro = hitPos;\n  return color ;\n}\n\n//-------------------------------------------------\nfloat render(in vec3 posOnRay, in vec3 rayDir)\n{ \n  float t = 0.0;\n  float maxDist = 76.;\n  for(int i=0; i<MAX_ITER; ++i)\n  {\n    float d = renderFunction(posOnRay + t*rayDir); \n    if (abs(d) < 0.01 || t > maxDist) \n         break;\n    t += d;\n  }\n   return t;\n}\n//------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos     =  fragCoord.xy / iResolution.xy * 2. - 1.;\n    pos.x *= iResolution.x / iResolution.y;    \n    of = texture( iChannel2, vec2( 0., 0.15 ) ).xy*vec2(1,-0.8) +  vec2(0.5,1.5);\n    \n    float t = time* 0.1;\n    vec3 camP = vec3(0., 4., 30.);\n    vec3 camUp = vec3(0. , 1., 0.);\n    vec3 camDir = normalize(-camP);\n    vec3 u = normalize(cross(camUp,camDir));\n    vec3 v = cross(camDir,u);\n    vec3 rayDir = normalize(2. * camDir + pos.x * u + pos.y * v);  \n  vec4 color    = vec4(1.0);\n  vec3 normal   = vec3(1.0);\n\n//------------------------------\n   \n  vec3 posOnRay = camP; \n  float path = 0.;\n  //--------------------------- \n     path =  render(posOnRay, rayDir);  \n     color = getColorPixel(posOnRay, rayDir, normal, path, materialMy.typeMat); \n     fragColor =  color;\n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MtsGRl","date":"1424438301","viewed":161,"name":"gift ","username":"Lio","description":"Experimentation with forms and materials","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflect"],"hasliked":0,"parentid":"","parentname":""}}