{"ver":"0.1","info":{"id":"NscBWs","date":"1657414165","viewed":506,"name":"ISampling: GGX VNDF (Specular)","username":"LVutner","description":"Because I like shiny balls with less noise\n","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["importancesampling","ibl","pbr","ggx","vndf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    GGX VNDF - Smith importance sampling.\n    Specular only.\n    \n    Author:\n        @LVutner\n\n    Credits: \n        @Stubman - Raycast logic\n    \n    Info:\n        That's just an example of importance sampling (GGX VNDF - Smith BRDF)\n        Btw. VNDF is better than classic GGX sampling. \n        Praise Eric Heitz, the master of microfacets\n        \n    References:\n        [R. Cook & K. Torrance, 1982] \"A Reflectance Model for Computer Graphics\"\n        [B. Walter et al, 2007] \"Microfacet Models for Refraction through Rough Surfaces\"\n        [E. Heitz, 2014] \"Understanding the Masking-Shadowing Function in Microfacet-based BRDFs\"  \n        [E. Heitz, 2018] \"Sampling the GGX Distribution of Visible Normals\"\n        [J. Dupuy & A. Benyoub, 2023] \"Sampling Visible GGX Normals with Spherical Caps\"        \n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Sample scene color\n    vec3 color = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n\n    //Apply exposure\n    color *= 2.0;\n\n    //Tonemapping\n    color = color * ACESInputMat;\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n    color = clamp(color, 0.0, 1.0);\n\n    //Transform from linear to sRGB\n    color = fromLinear(color);\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    GGX VNDF - Smith importance sampling.\n    Specular only.\n    \n    Author:\n        @LVutner\n\n    Credits: \n        @Stubman - Raycast logic\n    \n    Info:\n        That's just an example of importance sampling (GGX VNDF - Smith BRDF)\n        Btw. VNDF is better than classic GGX sampling. \n        Praise Eric Heitz, the master of microfacets\n        \n    References:\n        [R. Cook & K. Torrance, 1982] \"A Reflectance Model for Computer Graphics\"\n        [B. Walter et al, 2007] \"Microfacet Models for Refraction through Rough Surfaces\"\n        [E. Heitz, 2014] \"Understanding the Masking-Shadowing Function in Microfacet-based BRDFs\"  \n        [E. Heitz, 2018] \"Sampling the GGX Distribution of Visible Normals\"\n        [J. Dupuy & A. Benyoub, 2023] \"Sampling Visible GGX Normals with Spherical Caps\"        \n*/\n\n//Traces the scene [thx Stubman]\nHitInfo TraceRay(RayDesc ray)\n{\n    HitInfo sphere_hit; \n    {\n        //Set up materials\n        vec3 ior = vec3(0.18299, 0.42108, 1.3734); //Gold\n        vec3 absorption = vec3(3.4242, 2.3459, 1.7704); //Gold\n        float roughness = gl_FragCoord.x < 0.5 * iResolution.x ? 0.25 : 1.0;\n\n        //Create materials\n        Material sphere_material = remap_materials(ior, absorption, roughness);\n            \n        //Ray cast\n        ray_sphere_intersection(ray, vec4(0.0, 2.0, 2.0, 1.0), sphere_material, sphere_hit);\n    }\n    return sphere_hit;\n}\n\n//Returns microfacet visible normal with GGX distribution\nvec3 sample_ggx_vndf(vec3 V_tangent, vec2 Xi, float alpha)\n{\n\t//stretch the view direction\n    vec3 V_tangent_stretched = normalize(vec3(V_tangent.xy * alpha, V_tangent.z));\n\n\t//sample a spherical cap in (-wi.z, 1]\n    float phi = PI * 2.0 * Xi.x;\n    \n\tvec3 hemisphere = vec3(cos(phi), sin(phi), 0.0);\n\n\t//normalize (z)\n\themisphere.z = (1.0 - Xi.y) * (1.0 + V_tangent_stretched.z) + -V_tangent_stretched.z;\t\n\n\t//normalize (hemi * sin theta)\n\themisphere.xy *= sqrt(clamp(1.0 - hemisphere.z * hemisphere.z, 0.0, 1.0));\n\n\t//halfway direction\n\themisphere += V_tangent_stretched;\n\n\t//unstretch and normalize\n\treturn normalize(vec3(hemisphere.xy * alpha, hemisphere.z));\n}\n\n//Calculates VNDF estimator\nvec3 ggx_vndf_estimator(float NdotL, float NdotV, float VdotH, HitInfo ray)\n{\n    //Masking-shadowing\n    float G2 = G2_Smith(NdotL, NdotV, ray.material.alpha);\n    \n    //Masking\n    float G1 = G1_Smith(NdotV, ray.material.alpha);\n    \n    //Fresnel\n    vec3 F = F_Conductor(ray.material.rgbN, ray.material.rgbK, VdotH);\n    \n    //Estimator\n    //Fresnel * Shadowing\n    //Much simpler than brdf * costheta / pdf heh\n    vec3 estimator = F * (G2 / G1);\n\n    //Output\n    return estimator;\n}\n\n//Returns shiny ball :P\nvec3 ggx_vndf_smith_is(vec3 N, vec3 V, HitInfo ray)\n{\n    //Othronormal basis\n    mat3 TBN;  \n    TBN[0] = normalize(V - N * dot(N, V));\n    TBN[1] = cross(N, TBN[0]); \n    TBN[2] = N;\n    \n    //Rotate (world) view direction to tangent space\n    vec3 V_tangent = V * TBN;\n\n    //Accumulator\n    vec3 lighting = vec3(0.0);\n    \n    for(int i = 0; i < IS_SAMPLE_COUNT; i++)\n    {  \n        //Sample microfacet normals in tangent space\n        vec3 H_tangent = sample_ggx_vndf(V_tangent, RandNext2F(), ray.material.alpha);\n        H_tangent = V_tangent.z <= 0.0 ? -H_tangent : H_tangent; //bugfix\n        \n        //Calculate light direction in tangent space\n        vec3 L_tangent = reflect(-V_tangent, H_tangent);\n\n        //Dot products\n        //Hence we work in tangent space, there is no need for\n        //additional dot(x,y) instructions.\n        float VdotH = dot(V_tangent, H_tangent);         \n        float NdotL = clamp(L_tangent.z, 0.0, 1.0);\n        float NdotV = clamp(V_tangent.z, 0.0, 1.0);\n\n        //We don't want NaNs. Let's check if we got valid samples\n        if(L_tangent.z > 0.0)\n        {\n            //Rotate L_tangent to world space\n            vec3 L = TBN[0].xyz * L_tangent.x + (TBN[1].xyz * L_tangent.y + (TBN[2].xyz * L_tangent.z));\n            \n            //Sample cubemap with new direction\n            vec3 sampled_cube = toLinear(textureLod(iChannel1, L, 0.0).xyz);\n\n            //Sample estimator\n            vec3 estimator = ggx_vndf_estimator(NdotL, NdotV, VdotH, ray);\n\n            //Accumulate the samples\n            lighting += sampled_cube * estimator;\n        }     \n    }\n    lighting /= float(IS_SAMPLE_COUNT);\n\n    //Output\n    return lighting;\n}\n\n\n//Scene rendering\nvec3 get_scene_color(vec2 frag)\n{\n    //Clip space position\n    vec2 p = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.x;\n    \n    //Jitter the position for anti-alias effect\n    p += RandNext2F() * (2.0 / iResolution.xy);\n\n    //Camera origin\n    vec3 camera_origin = vec3(0.0, 2.0, -1.0);\n    \n    //Camera direction\n    vec3 camera_direction = normalize(vec3(p, 1.0));\n\n    //Primary ray data\n    RayDesc primaryRay;\n    primaryRay.Origin = camera_origin;\n    primaryRay.Direction = camera_direction;\n\n    //Shoot primary ray\n    HitInfo rayHit = TraceRay(primaryRay);\n    bool hit = rayHit.dist > 0.0;\n\n    //Background\n    vec3 color = toLinear(textureLod(iChannel1, primaryRay.Direction, 0.0).xyz);\n\n    //If we hit something, let's calculate all stuff\n    if(hit) \n    {\n        //Vectors\n        vec3 N = rayHit.normal;\n        vec3 V = -normalize(primaryRay.Direction);\n\n        //Final lighting\n        color = ggx_vndf_smith_is(N, V, rayHit);\n    }\n    return color;\n}\n\n//Render everything\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    //Initialize RNG\n    InitRand(uint(fragCoord.x) + uint(iResolution.x) * (uint(fragCoord.y) + uint(iResolution.y) * uint(iFrame)));\n\n    //Sample the scene\n    vec3 color = get_scene_color(fragCoord);\n\n    //Previous frame\n    vec3 color_prev = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n\n    //Blend\n    color = mix(color_prev, color, 1.0 / float(iFrame + 1));\n\n    //Output to framebuffer\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n    GGX VNDF - Smith importance sampling.\n    Specular only.\n    \n    Author:\n        @LVutner\n\n    Credits: \n        @Stubman - Raycast logic\n    \n    Info:\n        That's just an example of importance sampling (GGX VNDF - Smith BRDF)\n        Btw. VNDF is better than classic GGX sampling. \n        Praise Eric Heitz, the master of microfacets\n        \n    References:\n        [R. Cook & K. Torrance, 1982] \"A Reflectance Model for Computer Graphics\"\n        [B. Walter et al, 2007] \"Microfacet Models for Refraction through Rough Surfaces\"\n        [E. Heitz, 2014] \"Understanding the Masking-Shadowing Function in Microfacet-based BRDFs\"  \n        [E. Heitz, 2018] \"Sampling the GGX Distribution of Visible Normals\"\n        [J. Dupuy & A. Benyoub, 2023] \"Sampling Visible GGX Normals with Spherical Caps\"        \n*/\n\n//////////////////////////////////////////////////////////////////////////////\n//Settings\n//////////////////////////////////////////////////////////////////////////////\n\n//Quality settings\n#define IS_SAMPLE_COUNT 8 //Sample count\n\n//Raycast settings\n#define MAX_DISTANCE 200.0 //Max distance of primary ray\n\n//Hardcoded values\n#define PI float(3.141592)\n\n//////////////////////////////////////////////////////////////////////////////\n//BRDF UTILS\n//////////////////////////////////////////////////////////////////////////////\n\n//Lambda used in G2-G1 functions\nfloat Lambda_Smith(float NdotX, float alpha)\n{    \n    float alpha_sqr = alpha * alpha;\n    float NdotX_sqr = NdotX * NdotX;\n    return (-1.0 + sqrt(alpha_sqr * (1.0 - NdotX_sqr) / NdotX_sqr + 1.0)) * 0.5;\n}\n\n//Masking function\nfloat G1_Smith(float NdotV, float alpha)\n{\n\tfloat lambdaV = Lambda_Smith(NdotV, alpha);\n\n\treturn 1.0 / (1.0 + lambdaV);\n}\n\n//Height Correlated Masking-shadowing function\nfloat G2_Smith(float NdotL, float NdotV, float alpha)\n{\n\tfloat lambdaV = Lambda_Smith(NdotV, alpha);\n\tfloat lambdaL = Lambda_Smith(NdotL, alpha);\n\n\treturn 1.0 / (1.0 + lambdaV + lambdaL);\n}\n\n//Fresnel\nvec3 F_Conductor(vec3 n, vec3 k, float cos_theta)\n{\n   float c2 = cos_theta * cos_theta;\n   vec3 n2_k2 = n * n + k * k;\n   vec3 nc2 = 2.0 * n * cos_theta;\n\n   vec3 rs_a = n2_k2 + c2;\n   vec3 rp_a = n2_k2 * c2 + 1.0;\n   vec3 rs = (rs_a - nc2) / (rs_a + nc2); //spolarized\n   vec3 rp = (rp_a - nc2) / (rp_a + nc2); //ppolarized\n\n   return 0.5 * (rs + rp);\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//IMAGE\n//////////////////////////////////////////////////////////////////////////////\n\n//sRGB to linear\nvec3 toLinear(vec3 sRGB)\n{\n    bvec3 cutoff = lessThan(sRGB, vec3(0.04045));\n    vec3 higher = pow((sRGB + vec3(0.055)) / vec3(1.055), vec3(2.4));\n    vec3 lower = sRGB / vec3(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\n//Linear to sRGB\nvec3 fromLinear(vec3 linearRGB)\n{\n    bvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n    vec3 higher = vec3(1.055) * pow(linearRGB, vec3(1.0 / 2.4)) - vec3(0.055);\n    vec3 lower = linearRGB * vec3(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v) \n{\n    vec3 a = v * (v + 0.0245786);\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//RAYCAST\n//////////////////////////////////////////////////////////////////////////////\n\n\nstruct RayDesc\n{\n    vec3 Origin; //Ray origin\n    vec3 Direction; //Ray direction\n    float TMin; //Minimal distance\n    float TMax; //Max distance\n};\n\nstruct Material\n{\n    vec3 rgbN; //N\n    vec3 rgbK; //K\n    float alpha; //GGX alpha\n};\n\nstruct HitInfo\n{\n    vec3 position; //Position\n    vec3 normal; //Normal\n    float dist; //Traveled distance    \n    Material material; //Materials\n};\n\nvoid ray_sphere_intersection(RayDesc ray, vec4 sphere, Material mat, inout HitInfo hit)\n{\n    //from iq...\n\tvec3 position = ray.Origin - sphere.xyz;\n\tfloat b = dot(position, ray.Direction);\n\tfloat c = dot(position, position) - sphere.w * sphere.w;\n\tfloat h = b * b - c;\n\n    float dist = h < 0.0 ? -1.0 : -b - sqrt(h);\n\n    if(dist > 0.0)\n    {\n        hit.dist = dist;\n        hit.position = ray.Origin + ray.Direction * hit.dist;\n        hit.normal = (hit.position - sphere.xyz) / sphere.w;\n        hit.material = mat;\n    }\n    else\n        hit.dist = -1.0;\n}\n\n//Creates materials for metallic-roughness workflow\nMaterial remap_materials(vec3 n, vec3 k, float roughness)\n{\n    Material o;\n    \n    //IOR\n    o.rgbN = n; \n    \n    //Absorption coefficient\n    o.rgbK = k;\n    \n    //GGX alpha  \n    o.alpha = clamp(roughness * roughness, 1.0 / 255.0, 1.0);\n\n    //Output\n    return o;\n}\n\nHitInfo overrideHit(HitInfo a, HitInfo b) \n{ \n    if (a.dist < b.dist) \n        return a; \n    else \n        return b; \n}\n\n////////////////////////////////////////////////\n//RNG\n////////////////////////////////////////////////\n\nuint triple32(uint x) \n{\n\t// https://nullprogram.com/blog/2018/07/31/\n\tx ^= x >> 17;\n\tx *= 0xed5ad4bbu;\n\tx ^= x >> 11;\n\tx *= 0xac4c1b51u;\n\tx ^= x >> 15;\n\tx *= 0x31848babu;\n\tx ^= x >> 14;\n\treturn x;\n}\n\nuint randState;\n\nvoid InitRand(uint seed) \n{ \n    randState = triple32(seed); \n}\n\nuint RandNext() \n{ \n    return randState = triple32(randState); \n}\n\n#define RandNextF() (float(RandNext()) / float(0xffffffffu))\n\n#define RandNext2() uvec2(RandNext(), RandNext())\n#define RandNext2F() (vec2(RandNext2()) / float(0xffffffffu))\n","name":"Common","description":"","type":"common"}]}