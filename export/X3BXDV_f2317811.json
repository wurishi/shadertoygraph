{"ver":"0.1","info":{"id":"X3BXDV","date":"1711129821","viewed":81,"name":"N-Points Bezier Curve","username":"3t13nn3","description":"N-Points Bezier curve , you can mouve points with mouse, or even add points in Common...","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["2d","mouse","bezier","animation","interaction","curve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float binomialCoefficient(float n, float k) {\n    float res = 1.0;\n    if (k > n - k)\n        k = n - k;\n    for (float i = 0.0; i < k; ++i) {\n        res *= (n - i) / (i + 1.0);\n    }\n    return res;\n}\n\nfloat bezierBasis(float i, float N, float t) {\n    float basis = binomialCoefficient(N, i);\n    basis *= pow(1.0 - t, N - i) * pow(t, i);\n    return basis;\n}\n\nvec2 bezierCurve(vec2[NB_POINTS] points, float t) {\n    int N = points.length() - 1;\n    vec2 result = vec2(0.0);\n    for (int i = 0; i <= N; ++i) {\n        result += points[i] * bezierBasis(float(i), float(N), t);\n    }\n    return result;\n}\n\nvec3 sdBezier(vec2 uv, vec2[NB_POINTS] points) {\n    vec3 acc = vec3(0.);\n    float step = 0.02;\n    vec2 prevPoint = bezierCurve(points, 0.0);\n    for (float t = step; t <= 1.0; t += step) {\n        vec2 currentPoint = bezierCurve(points, t);\n        //float dist = length(uv - currentPoint);\n        float dist = smoothstep(0.0, 0.2, length(uv - currentPoint));\n        if (dist < 0.0125) {\n            acc = vec3(0.8 + t * 2., 0.2 + sin(t) / 2., 0.8 - t * 2.);\n            break;\n        }\n        prevPoint = currentPoint;\n    }\n    return acc;\n}\n\nvec3 map(vec2 p) {\n    vec3 res = mix(vec3(0., 0.4, 0.6), vec3(0.1, 0.5, 0.6), p.y + 0.5);\n    \n    for(int i = 0; i < NB_POINTS - 1; ++i) {\n        vec2 startPoint = POINTS[i];\n        vec2 endPoint = POINTS[i + 1];\n        \n        float distToLine = abs((endPoint.y - startPoint.y) * p.x - (endPoint.x - startPoint.x) * p.y + endPoint.x * startPoint.y - endPoint.y * startPoint.x) / length(endPoint - startPoint);\n        \n\n        if (p.x >= min(startPoint.x, endPoint.x) && p.x <= max(startPoint.x, endPoint.x) &&\n            p.y >= min(startPoint.y, endPoint.y) && p.y <= max(startPoint.y, endPoint.y)) {\n            if(distToLine < 0.0025) {\n                res -= vec3(1.0);\n            }\n        }\n    }\n    res = max(res, sdBezier(p, POINTS));\n    \n    for(int i = 0; i < NB_POINTS; ++i) {\n        if(distance(p, POINTS[i]) < pointRadius) {\n            if(distance(p, POINTS[i]) < pointRadius / 2.)\n                res = 1. - vec3(0., 0.5, 0.7);\n            else {\n                res = vec3(0.1);\n            }\n        }\n    }\n    \n    float T = mod((iTime + 1.5) / 3.0, 2.0) > 1.0 ? 1.0 - fract((iTime + 1.5)  / 3.0) : fract((iTime + 1.5)  / 3.0);\n    vec2 ballPos = bezierCurve(POINTS, T);\n    float distToBall = distance(p, ballPos);\n    if (distToBall < pointRadius) {\n        if (distToBall < pointRadius / 2.0) {\n            res = vec3(0.5, 0.7, 0.0);\n        } else {\n            res = vec3(0.2);\n        }\n\n        \n    } else {\n        if (distToBall < pointRadius * 10.0) {\n            float delta = 0.001;\n            vec2 tangent = normalize(bezierCurve(POINTS, T + delta) - bezierCurve(POINTS, T - delta));\n\n\n            vec2 endPoint = ballPos + tangent;\n            float distToLine = abs((endPoint.y - ballPos.y) * p.x - (endPoint.x - ballPos.x) * p.y + endPoint.x * ballPos.y - endPoint.y * ballPos.x) / distance(endPoint, ballPos);\n            if (distToLine < 0.0025) {\n                res = vec3(0.5, 1.0, 0.0) / 1.33;\n            }\n        }\n    }\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    if(iFrame != 0) {\n        for(int i = 0; i < NB_POINTS; ++i) {\n            POINTS[i] = readPoint(i, iChannel0);\n        }\n    }\n    \n    vec3 col = map(uv);\n    \n\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int currI = int(floor(fragCoord.x));\n    vec2[NB_POINTS] pts;\n    for (int i = 0; i < NB_POINTS; ++i)\n        pts[i] = readPoint(i, iChannel0);\n        \n    if(iFrame == 0) {\n        pts[currI] = POINTS[int(floor(fragCoord.x))];\n    } else if (iMouse.z > 0.0) { \n        vec2 mousePos = (iMouse.xy - iResolution.xy * 0.5) / iResolution.y;\n        \n        if (distance(mousePos, pts[currI]) < 0.2) {\n            bool collision = false;\n            for (int i = 0; i < NB_POINTS; ++i) {\n                if (i != currI) {\n                    if (distance(mousePos, pts[i]) < pointRadius * 5.0) {\n                        collision = true;\n                        break;\n                    }\n                }\n            }\n            \n            if(!collision) pts[currI] = mousePos;\n        }\n    }\n    \n    fragColor = vec4(pts[currI] ,0.0,0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define NB_POINTS 4\n\nvec2[NB_POINTS] POINTS = vec2[NB_POINTS](vec2(-0.75, -0.35), vec2(-0.25, 0.25), vec2(0.25, -0.25), vec2(0.75, 0.35));\n\nconst float pointRadius = 0.02;\n\nvec2 readPoint(int i, sampler2D tex) {\n    return texelFetch(tex, ivec2(i,0),0).xy;\n}","name":"Common","description":"","type":"common"}]}