{"ver":"0.1","info":{"id":"7tjcRd","date":"1650142539","viewed":89,"name":"Revision 2022 Jam #2 shader","username":"Exca","description":"Shader made during revision 2022 second shader jam.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","revision"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat time = 0.0;\nfloat ffts;\nfloat ffti;\nfloat beat;\nfloat beatstep;\nfloat bar;\n\nfloat glow;\n\nvec3 rotate( vec3 p, float x, float y, float z)\n{\n  mat3 rotx = mat3( 1.0, 0.0, 0.0, 0.0, cos(x), -sin(x), 0.0, sin(x), cos(x));\n  mat3 roty = mat3( cos(y), 0.0, sin(y), 0.0, 1.0, 0.0, -sin(y), 0.0, cos(y));\n  mat3 rotz = mat3( cos(z), -sin(z), 0.0, sin(z), cos(z), 0.0, 0.0, 0.0, 1.0);\n  return rotx*roty*rotz * p;\n}\n\nvec3 repeat( vec3 p, vec3 q)\n{\n  return mod( p +q*0.5, q) - q*0.5;\n}\n\n\nvec3 getcam( vec3 cam, vec3 target, vec2 uv, float fov)\n{\n  vec3 forward = normalize( target - cam);\n  vec3 right = normalize( cross(vec3(0,1,0), forward));\n  vec3 up = normalize(cross( forward, right));\n  return normalize( forward*fov + right*uv.x + up*uv.y);\n}\n\nvec3 texmap( vec3 p, vec3 n)\n{\n  return mat3( texture(iChannel3, p.yz).rgb, texture(iChannel3, p.xz).rgb, texture(iChannel3,p.xy).rgb)*n;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x, p.y);\n  return length(q)-t.y;\n}\n\nfloat roundbox( vec3 p, vec3 b, float r)\n{\n  vec3 d = abs(p)-b;\n  return min(max(d.x, max(d.y, d.z)), 0.0)+ length( max(d, 0.0))-r;\n}\n\nfloat sphere( vec3 p, float r)\n{\n  return length(p) -r;\n}\n\nfloat ground(vec3 p, float h)\n{\n  return p.y-h;\n}\n  \nvec3 map( vec3 p)\n{\n  float g = ground(p, -3.0);\n  \n  \n  p*=1.0-smoothstep(0.0, 0.15,ffts*5.0);\n  \n  p = rotate(p, time*1.2, time*0.25, time*0.1);\n  \n  float tc = roundbox( p, vec3(0.1, 0.1, 2.1), 0.05);\n  \n  float t = torus( p, vec2(2.5, 0.15));\n  \n  //t = min(tc,t);\n  \n  p = rotate(p, time*1.2, time*0.25, time*0.1);\n  \n  float t1 = torus( p, vec2(2.0, 0.15));\n  p = rotate(p, time*1.2, time*0.25, time*0.1);\n  float t2 = torus( p, vec2(1.5, 0.15));\n  p = rotate(p, time*1.2, time*0.25, time*0.1);\n  float t3 = torus( p, vec2(1.0, 0.15));\n  \n  \n  \n  \n  t = min( t,t1);\n  t = min( t,t2);\n  t = min( t,t3);\n  \n  float mat = t < g ? 1.0 : 2.0;\n  t = min(t,g);\n  \n  return vec3(t, mat, 1.0);\n}\n\nvec3 march( vec3 cam ,vec3 rd, out vec3 p ,out float t)\n{\n  float lowest = 999.0;\n  for(int i = 0; i < 200; i++)\n  {\n    p = cam + rd*t;\n    vec3 r = map(p);\n    t +=r.x*0.5;\n    lowest = min( lowest, r.x);\n    \n    if(r.x < 0.05) glow +=r.x;\n    \n    if(r.x < 0.001){\n      return r;\n    }\n    if(t > 50.0){\n      t = 50.0;\n      return vec3(lowest, -1,-1);\n    }\n  }\n  return vec3(lowest, -1,-1);\n}\n\nvec3 normal( vec3 p)\n{\n  vec3 c = map(p);\n  vec2 e = vec2(0.01, 0.0);\n  return normalize( vec3(\n    map( p + e.xyy).x,\n    map( p + e.yxy).x,\n    map( p + e.yyx).x\n  )-c.x);\n}\n  \nfloat light( vec3 p, vec3 l, vec3 n)\n{\n  return max( 0.0, dot(n, normalize( l- p)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  vec2 vuv = uv;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n  ffts = texture(iChannel1, vec2(0.1,0.5)).r*0.015;\n  ffti = iTime*0.25;\n  \n  \n  beat = floor( iTime * 136.0/60.0);\n  beatstep = fract( iTime * 136.0/60.0);\n  bar = floor( beat /8.0);\n  \n  time = ffti*2.5 + iTime*0.1;\n  \n  vec3 col = vec3(0.0);\n  vec3 cam = vec3(\n    sin(time*0.1-bar*2.0)*10.0,\n    abs(sin(time*0.05 + bar*3.0)*7.9)-1.5,\n    cos(time*0.1+bar*1.1)*7.0\n    );\n  vec3 target = vec3(0,0,0);\n  \n  target -= cam*0.25;\n  \n  float fov = 2.040 + sin(bar*5.3);\n  \n  vec3 light1 = vec3(sin(time*10.0), 10.0, 0.0);\n  \n  vec3 rd = getcam(cam, target, uv, fov);\n  \n  rd *= 1.0 +0.05* vec3( sin(time*0.25), cos(time*0.3), sin(time*0.4));\n  \n  vec3 p = cam; float t = 2.0;\n  vec3 res = march( cam, rd, p, t);\n  \n  vec3 gold = vec3(1.8, 1.5, 0.5);\n  \n  if(res.y > 1.5){\n    \n    vec3 n= normal(p);\n    vec2 pat = vec2( \n      step( mod(p.x, 1.0),0.5),\n      step( mod(p.z, 1.0),0.5)\n    );\n    col = mix(gold, gold*0.25, pat.x-pat.y) * light(p,light1,n)*0.25;\n    \n    col = max( col, gold*0.25) *  texmap(p*0.25,n*1.0) * 5.0;\n    \n    vec3 outp = vec3(0.0);\n    float outt = 0.0;\n    vec3 shadow = march( p + n * 0.1, normalize( light1-p), outp, outt)*0.95;\n    \n    col *=0.125+ 1.0*smoothstep( 0.0, 0.5, shadow.x);\n    \n    \n  }\n  else if(res.y > -0.5){\n    \n    vec3 n= normal(p);\n    col = gold * light(p,light1,n);\n    \n    vec3 refrd = reflect( rd, n);\n    vec3 refp = p;\n    vec3 refc = vec3(0.0);\n    float reft = 0.0;\n    vec3 refres = march( p+rd*0.01, refrd, refp, reft);\n    \n    vec3 refn = normal(refp);\n    if(refres.y > 1.5)\n    {\n      col = vec3(1.0) * light(refp,light1,refn);\n    }\n    else if(refres.y > 0.5)\n    {\n      vec2 pat = vec2( \n        step( mod(refp.x, 1.0),0.5),\n        step( mod(refp.z, 1.0),0.5)\n      );\n      refc = col = mix(gold, gold*0.25, pat.x-pat.y) * light(refp,light1,refn);\n    }\n    col = mix(col, refc, 0.5);\n    \n  }\n  \n  \n  col +=gold* glow*0.04;\n  \n  col = mix( col, vec3(0.0), smoothstep(5.0, 50.0, t));\n  \n  \n  vuv -=0.5;\n  vuv *= 0.97;\n  vuv +=0.5;\n  \n  \n  vec3 previous = texture( iChannel0, vuv).rgb;\n  col += previous * 0.9 * smoothstep(0.0, 0.1, ffts*10.0);\n  \n  if(mod(bar, 5.0) < 0.5) col.rgb = col.bgr;\n  else if(mod(bar, 5.0) < 1.5) col.rgb = col.grb;\n  else if(mod(bar, 5.0) < 2.5) col.rgb = col.gbr;\n  else if(mod(bar, 5.0) < 3.5) col.rgb = vec3(length(col)*0.5);\n  \n  \n\tfragColor = vec4( col, 1.0);;\n}\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}