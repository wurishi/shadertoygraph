{"ver":"0.1","info":{"id":"XsGXDm","date":"1464713058","viewed":2180,"name":"Cayley transform of Quaternions","username":"MBR","description":"The map from the positive 4D half-sphere to the 3D unit ball.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["quaternion","transform"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// An illustration for:\n// http://marc-b-reynolds.github.io/quaternions/2016/05/30/QuatHDAngleCayley.html\n\n// Not so brief description: \n// Think of the image's Y axis as being some choice of 3D axis of rotation,\n// then the circle is the intersection of the 4D sphere (all unit quaternions)\n// and the plane that contains Y and reals..and the set of all unit quaternions\n// which represent rotations about that axis-of-rotation are on the circle.\n// The blueish point (call it Q) just animates all of them and since Q and -Q \n// represent the same rotation the red (-Q) are same rot and they flip colors so\n// the blueish is always on right hand side and red on left. So we only need the\n// half-circle for all rotation about the axis.  The two blue line\n// segments start at (-1,0) one to Q and other to -Q.  These are projections from\n// (-1,0) to the (again image space) Y axis and green points indicate the points\n// of projection.  The green point associated with the \"current blue\" is alway\n// inside or on the edge of the circle and the other is always outside or on the\n// edge.  If we just choose a green point and follow then it speeds up and when\n// the associate blue segment is point straight up then it's at infinity, the\n// segment jumps to straight down and it has moved through infinity and is approaching\n// the circle.  So all rotations about the given axis can be represented by the line\n// segment in the visualization space from (0,-1) to (0,1). If we visualize a green\n// line segment between these point, make everything else go away and replace it with\n// a sphere in standard 3D space..we still have the green line segement through its\n// center and touching the edge which can represent all rotations about an axis with\n// the same direction as the segement.  Expanding this to all possible axis-of-rotation\n// fills the sphere, so we can represent all possible 3D rotations as a point on or\n// inside a 3D sphere (aka unit ball).\n//\n// The red line segments simply change the projection from (-1,0) to (1,0) all the\n// same things hold but flip side of the circle which maps to inside/outside.\n//\n// I also talk about this projection here:\n// * http://marc-b-reynolds.github.io/quaternions/2017/05/02/QuatQuantPart1.html\n\n#define W0 0.5545497\n#define W1 0.308517\n#define W3 0.618034\n\n// [-1,1]\nfloat tnoise(in vec2 c)\n{   \n  c = c*fract(c*vec2(W0,W1));\n  float p  = c.x*c.y;\n  float i  = floor(p);\n  float u0 = p-i;\n  float u1 = fract(W3*i);\n  return u0-u1;\n}\n\n\n\nfloat circle(vec2 uv, vec3 c)\n{\n  float r = length(c.xy - uv);\n  float d = abs(r - c.z);  \n  return smoothstep(0.015, 0.0, d) + 0.5*smoothstep(0.06, 0.01, r-c.z);\n}\n\n\nfloat saturate(float x)\n{\n  return clamp(x, 0.0, 1.0);\n}\n\nfloat seg(vec2 p, vec2 a, vec2 b, float r)\n{  \n  b = b-a;\n  a = p-a;\n    \n  float h  = saturate(dot(a,b)/dot(b,b));\n  float d  = length(a - b*h) - r;\n  \n  return smoothstep(0.0095, 0.0, d);\n}\n\nfloat dseg(vec2 p, vec2 a, vec2 b0, vec2 b1, float r)\n{\n  float r0 = seg(p,a,b0,r);\n  float r1 = seg(p,a,b1,r);\n  return max(r0,r1);\n}\n\n\n\n#define RADIUS 0.5\n\nconst vec2 x0 = vec2(RADIUS, 0.0);\nconst vec2 y0 = vec2(0.0, RADIUS);\n\nconst vec3 blue  = vec3(0.7, 0.7, 1.9);\nconst vec3 red   = vec3(1.9, 0.7, 0.7);\nconst vec3 green = vec3(0.5, 0.9, 0.5);\nconst vec3 mag   = vec3(0.8, 0.4, 0.8);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2.0 * (fragCoord.xy/iResolution.xy) - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n    \n  vec2 q;\n   \n    if (iMouse.z <= 0.0) {\n      float t = iTime;\n      q =vec2(cos(t), sin(t));\n    }\n    else {\n      q = (2.0 * iMouse.xy / iResolution.xy) - 1.0;\n      q.x *= iResolution.x / iResolution.y;\n      q = normalize(q);  \n    }\n    \n  vec3 q0 = vec3( RADIUS*q, 0.008);\n  vec3 q1 = vec3(-RADIUS*q, 0.008);\n  \n  vec3 p0 = vec3(0.0,  RADIUS*q.y/(1.0+q.x), 0.005);\n  vec3 p1 = vec3(0.0, -RADIUS*q.y/(1.0-q.x), 0.005);\n    \n  // projection from +1 is the conjugate\n  vec3 n0 = p1; n0.y = -n0.y;\n  vec3 n1 = p0; n1.y = -n1.y;\n  \n  vec3 c = vec3(0.0);\n  vec3 c0,c1,c2;\n \n  // draw the lines of the projections  \n  if (q.x >= 0.0) {\n    c0  = blue;\n    c1  = red;\n    c  += 0.5*blue*seg(uv, -x0, q0.xy ,0.00005);\n    c  += 0.5*mag *seg(uv,  x0, q1.xy ,0.00005);\n    c  += 0.5*blue*seg(uv, -x0, p1.xy ,0.00005);\n    c  += 0.5*mag *seg(uv,  x0, n0.xy ,0.00005);\n \n  } else {\n    c1  = blue;\n    c0  = red;\n    c  += 0.5*blue*seg(uv, -x0, q1.xy ,0.00005);\n    c  += 0.5*mag *seg(uv,  x0, q0.xy ,0.00005);\n    c  += 0.5*blue*seg(uv, -x0, p0.xy ,0.00005);\n    c  += 0.5*mag *seg(uv,  x0, n1.xy ,0.00005);\n  }\n        \n   c += vec3(0.5, 0.5, 0.5) * circle(uv, vec3(0, 0, RADIUS));\n    \n   // Q and -Q\n   c += c0 * circle(uv, q0);\n   c += c1 * circle(uv, q1);\n    \n   // (Q-1)/(Q+1)\n   c += green * circle(uv, p0);\n   c += green * circle(uv, p1);\n     \n   // (Q+1)/(Q-1)\n   c += mag * circle(uv, n0);\n   c += mag * circle(uv, n1);\n   \n   c = c+(8.0/256.0)*tnoise(fragCoord);\n    \n  fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}