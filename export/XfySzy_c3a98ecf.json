{"ver":"0.1","info":{"id":"XfySzy","date":"1715371142","viewed":39,"name":"Distorted box under something","username":"burbokop","description":"Distorted box under something and there is sphere that is trying to escape from it","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec2 mouseOrTime() {\n    return vec2(\n        iMouse.x == 0. ? iTime * 10.5432 : iMouse.x,\n        iMouse.y == 0. ? iTime * 1.4321 : iMouse.y);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 boxPal(in float x) {\n    return pal(x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\nmat3 rotateYMatrix(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat sphereSDF(vec3 point, vec3 center, float radius) {\n    return length(point - center) - radius;\n}\n\n\nfloat boxSDF(vec3 point, vec3 center, vec3 b, mat3 tr)\n{  \n    vec3 q = abs((point - center) * tr) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nstruct Shape {\n    float dst;\n    vec3 color;\n};\n\n\nShape shapeUnion(Shape s0, Shape s1) {\n    if(s0.dst < s1.dst) {\n        return s0;\n    } else {\n        return s1;\n    }\n}\n\nfloat dstToT(in float x) {\n    return 1. / x - 2.2;\n}\n\n\nShape mySphere(vec3 point, in float rd) {\n    vec3 r = vec3(sin(iTime * 4.) / 4., sin(iTime * 2.) / 2., sin(iTime)) * (mouseOrTime().y/iResolution.y) * 2.;\n    vec3 c = vec3(0.,0., -3.);\n    \n    vec3 cpos = vec3(\n        cos(iTime) * r.x + c.x,\n        sin(iTime) * r.y + c.y,\n        sin(iTime) * r.z + c.z\n    );\n    \n    float dst = sphereSDF(point, cpos, 0.5);\n    vec3 color = pal((rd + dst) * cos(iTime*1.111)*1., vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n\n    return Shape(\n        dst,\n        color\n    );\n}\n\nShape myBox(vec3 point, in float rd) {\n    float dst = boxSDF(point, vec3(0,0, -3), vec3(1.,1.,1.), rotateYMatrix(iTime));\n    return Shape(\n        dst, \n        boxPal(dstToT((rd + dst) * sin(iTime*0.123))));\n}\n\n\nfloat sinDisplacement(in vec3 p, in float coef) {\n    return sin(coef * p.x) * sin(coef * p.y) * sin(coef * p.z);\n}\n\n\nShape opDisplace( in Shape shape, in vec3 p, in float displacementCoef)\n{\n    float d1 = shape.dst;\n    float d2 = sinDisplacement(p, displacementCoef);\n    return Shape(d1 + d2, shape.color);\n}\n\n\nShape shapeSmoothUnion(Shape s1, Shape s2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(s2.dst-s1.dst)/k, 0.0, 1.0 );\n    return Shape(\n        mix(s2.dst, s1.dst, h) - k*h*(1.0-h),\n        mix(s2.color, s1.color, h) - k*h*(1.0-h)        \n        );\n}\n\nShape scene(in vec3 point, in float rd) {\n    return shapeSmoothUnion(\n        mySphere(point, rd),\n        opDisplace(myBox(point, rd), point, sin(iTime)+(mouseOrTime().y/iResolution.y) * 20.),\n        0.5);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float ratio = iResolution.y / iResolution.x;\n\n    vec3 rayBegin = vec3(fragCoord.x / iResolution.x * 2. - 1., (fragCoord.y / iResolution.y * 2. - 1.) * ratio, 0);\n\n    vec3 focalPoint = vec3(0, 0, 1.);\n    vec3 rayVector = normalize(rayBegin - focalPoint);    \n\n    vec3 background = vec3(0.1,0.1,0.1);\n    vec3 color = background;       \n\n    float rd = 0.;\n    int i = 0;\n    int iterationCount = int(80. * mouseOrTime().x / iResolution.x);\n    for(; i < iterationCount; ++i) {\n        vec3 rayEnd = rayBegin + rayVector * rd;\n        \n        Shape s = scene(rayEnd, rd);\n                                \n        rd += s.dst;\n        if(abs(s.dst) < 0.01) {        \n            color = s.color;            \n            break;\n        }\n    }\n    \n    float maxVisibleDistance = 20.;\n   \n    if(rd>maxVisibleDistance) rd = maxVisibleDistance;\n   \n    float normalizedDst = 1. - rd / maxVisibleDistance;\n    float depth = 1. - float(i) / float(iterationCount);    \n\n    fragColor = vec4(mix(background, color, mix(normalizedDst, depth, mouseOrTime().x / iResolution.x)), 1);\n}\n","name":"Image","description":"","type":"image"}]}