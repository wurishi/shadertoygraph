{"ver":"0.1","info":{"id":"XfyGD3","date":"1713323610","viewed":39,"name":"waaaaaaaaaaaaaaaaaaaaaaawaaaa","username":"reganly1809","description":"CONNOR (Spelt right), I definitely over complicated this at the beginning","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["homework"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 0.0001;\nconst float NEAR = 0.001;\nconst float FAR = 100.0;\n\nfloat sdSphere(vec3 p, float r)\n{\n  return length(p) - r;\n}\n\nfloat sdOctahedron( vec3 p, float s )\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat map(vec3 p)\n{\n    float ground = p.y + 0.95;\n    vec3 spherePosition = vec3(/*sin(iTime) * 3.0*/0.0, 0.0, 0.0);\n    float sphere = sdSphere(p - spherePosition, 0.3); \n    float coolshape = sdOctahedron( p + vec3(2.0, -1.0 ,0.0), 1.0);\n    //return sphere;\n    return min(coolshape, min(sphere, ground));\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 DirectionalLight(vec3 position, vec3 normal, vec3 cameraPosition,\n    vec3 lightPosition, vec3 lightColor,\n    float ambientIntensity, float diffuseIntensity, float specularPower)\n    {\n    vec3 N = normal;\n    vec3 L = normalize(position + lightPosition);\n    vec3 V =  normalize(position + cameraPosition);\n    vec3 R = reflect( -L, N);\n    \n    float dotNL = max(dot(N,L), 0.0);\n    float dotVR = max( dot(V,R), 0.0);\n    \n    \n    vec3 C = vec3(0.0,0.0,0.0);\n    C += lightColor * ambientIntensity;\n    C += lightColor * diffuseIntensity * dotNL;\n    C += lightColor * pow(dotVR, specularPower) ;\n\n    return C; \n    }\n    \nvec3 SpotLighting(vec3 position, vec3 normal, vec3 cameraPosition,\n    vec3 lightPosition, vec3 lightColor,\n     float diffuseIntensity, float specularPower, vec3 spotLightDir, float coneAngle) \n{\n    vec3 N = normal;\n    vec3 L = normalize(position + lightPosition);\n    vec3 V =  normalize(position + cameraPosition);\n    vec3 R = reflect( -L, N);\n    \n    \n    // 2. Calculate lighting vector similarities\n    float dotNL = max(dot(N,L), 0.0);\n    float dotVR = max( dot(V,R), 0.0);\n    \n    float spotCosine = cos(coneAngle * 0.5);\n    float spotDirection = dot(normalize(-spotLightDir), normalize(position - lightPosition));\n    \n    float spotIntensity = step(spotCosine, spotDirection);\n   \n    // 3. Apply ambient, diffuse, and specular contributions\n    // let C = base color (black)\n    vec3 C = vec3(0.0,0.0,0.0);\n    C += lightColor * diffuseIntensity * dotNL * spotIntensity;\n    C += lightColor * pow(dotVR, specularPower) * spotIntensity;\n\n    \n    return C;\n}\n\nvec3 PointLight(vec3 position, vec3 normal, vec3 cameraPosition,\n    vec3 lightPosition, vec3 lightColor, float diffuseIntensity, float specularPower,float pointLightIntensity)\n    {\n        \n    vec3 N = normal;\n    vec3 L = normalize(lightPosition - position);\n    vec3 V =  normalize(cameraPosition - position);\n    vec3 R = reflect( -L, N);\n    vec3 halfWay = normalize(V + L);\n    \n    \n    // 2. Calculate lighting vector similarities\n    float dotNL = max(dot(N,L), 0.0);\n    float dotVR = max( dot(V,R), 0.0);\n    float dotNH = max(dot(halfWay, N), 0.0);\n    \n    float distance = length(lightPosition - position);\n    float attenuation = 1.0 / (distance * distance); \n       \n        vec3 C = vec3(0.0,0.0,0.0);\n    C += lightColor * dotNL;\n    C += lightColor * pow(dotNH, specularPower) ;\n    C *= diffuseIntensity * attenuation;\n    C *= pointLightIntensity;\n    return C;\n    }\n    \nvec3 CalculateLighting(vec3 position, vec3 normal, vec3 cameraPosition)\n{\n    vec3 lightColorPink = vec3(1.11,0.65,0.9);\n    vec3 lightColorGreen = vec3(0,1.0,0.4);\n    vec3 lightColorBlue = vec3(0.2,0.2,1.0);\n    \n    vec3 lightPosition = vec3(sin(iTime) * 0.0, 4.0, 1.0);\n    vec3 lightPosition1 = vec3(sin(iTime) * 3.0, 4.0, 1.0);\n    vec3 lightPosition2 = vec3(1.5, 0.0, -1.0);\n    vec3 lightPosition3 = vec3( 3.0, 4.0,tan(iTime) *  1.0);\n    vec3 lightPosition4 = vec3(0.0, 10.0, -5.0);\n     \n    float pointLightIntensity = 2.5;\n    \n    vec3 spotlightDir = normalize(vec3(0.0, 1.0, 0.0)); \n    vec3 directionallightDir = normalize(vec3(0.0, -0.0, -4.0));     \n    float coneAngle = 1.0;\n    float ambient = 0.25;\n    float diffuse = 0.45;\n    float specular = 34.0;\n    vec3 TotalLighting = vec3(0.0);\n    \n    \n    TotalLighting += SpotLighting(position, normal, cameraPosition, lightPosition, lightColorPink,  diffuse, specular, spotlightDir, coneAngle);\n    TotalLighting += SpotLighting(position, normal, cameraPosition, lightPosition1, lightColorPink,  diffuse, specular, spotlightDir, coneAngle);\n    TotalLighting += SpotLighting(position, normal, cameraPosition, lightPosition3, lightColorPink,  diffuse, specular, spotlightDir, coneAngle);\n    TotalLighting += DirectionalLight(position, normal, cameraPosition, lightPosition4, lightColorBlue, ambient, diffuse, specular);\n    TotalLighting += PointLight(position, normal, cameraPosition, lightPosition2, lightColorGreen, diffuse, specular,pointLightIntensity);\n    return TotalLighting;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // [0, 1] --> [-1, 1]\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    // Ray origin\n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    \n    // FoV of 90 degrees\n    float fov = tan(45.0 * 3.14 / 180.0);\n    \n    // Ray direction\n    vec3 rd = normalize(vec3(uv * fov, 1.0));\n    \n    // Distance along ray\n    float t = 0.0;\n    \n    for (int i = 0; i < 80; i++)\n    {\n        // Scene position\n        vec3 p = ro + rd * t;\n        \n        // Determine maxmimum safe stepping distance\n        float d = map(p);\n        \n        // Step along ray by distance d\n        t += d;\n        \n        // Intersection if distance is very close to surface (SDF --> -1)\n        if (d < NEAR) break;\n        \n        // No intersection if distance along ray exceeds view distance\n        if (t > FAR) break;\n    }\n    \n    vec3 p = ro + rd * t;\n    vec3 n = estimateNormal(p);\n   \n    \n    vec3 lighting = CalculateLighting(p, n, ro);\n    \n    bool hit = t < FAR - EPSILON;\n    vec3 color = hit ? lighting : vec3(0.25, 0.25, 0.25);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}