{"ver":"0.1","info":{"id":"7ssyWj","date":"1642735152","viewed":95,"name":"NOISEEEEE","username":"nshelton","description":"basic noise. fractal cell noise is one of my favs","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Hash(float p) {\n\n    return fract( sin(p) * 435548.5453 );\n\n}\n\nfloat hash2( vec2 p, float seed)\n{\n    vec2 K1 = vec2(\n        23.14069263277926, // e^pi (Gelfond's constant)\n         2.665144142690225 // 2^sqrt(2) (Gelfondâ€“Schneider constant)\n    );\n    return fract( cos( dot(p,K1) * 0.1 + seed ) * 192345.6789 );\n}\n\n\nfloat sNoise( vec2 x )\n{\n\tvec2\tp = floor(x);\n\tvec2\tf = fract(x);\n\n\tf = smoothstep( 0.0, 1.0, f );\n\n \n    float BL = hash2(p, 1.0);\n    float BR = hash2(p + vec2(1.0, 0.0) , 1.0);\n    float TL = hash2(p + vec2(0.0, 1.0), 1.0);\n    float TR = hash2(p + vec2(1.0, 1.0), 1.0);\n\n    float top = mix(TL, TR, f.x);\n    float bottom = mix(BL, BR, f.x);\n \n\treturn  mix(bottom, top, f.y );\n}\n\nfloat fbm(vec2 p) {\n    float theta = 1.2 + iTime* 0.01;\n    \n    mat2 rot = mat2( cos(theta), -sin(theta), sin(theta), cos(theta));\n    \n    float result = 0.0;\n    \n    result += sNoise(p) * 0.500; p *= rot * 2.0; \n    result += sNoise(p) * 0.250; p *= rot * 2.0; \n    result += sNoise(p) * 0.125; p *= rot * 2.0; \n    result += sNoise(p) * 0.125; p *= rot * 2.0; \n\n    \n    return result;\n\n}\n\nvec2 getCell(vec2 p) {\n\n   float theta = 1.2 + iTime* 0.9;\n    \n    mat2 rot = mat2( cos(theta), -sin(theta), sin(theta), cos(theta));\n    \n    vec2 result = vec2(\n        hash2(p, 0.0), \n        hash2(p, 7.0));\n        \n       result = rot * (result - 0.5);\n       \n       result += 0.5;\n        \n       return result;\n    \n}\n\nvec2 cell(vec2 x) {\n\tvec2\tp = floor(x);\n\tvec2\tf = fract(x);\n    \n    float minDist = 2.0;\n    float secondMinDist = 2.0;\n    \n    for (int y = -1; y <= 1; y++)\n    {\n        for (int x = -1; x <= 1; x++)\n        {\n            \n           vec2 pos = getCell(vec2(x, y) + p) + vec2(x, y);\n           \n           float d = distance(pos, f); \n           \n           if ( d < minDist) {\n           \n               if(minDist <secondMinDist) {\n                   secondMinDist = minDist;\n               }\n               \n               minDist = d;\n               \n           } else if (d < secondMinDist) {\n           \n               secondMinDist = d;\n           }\n        }\n    }\n    \n    \n    return vec2(minDist, secondMinDist);\n\n}\n\n\nfloat fbmCell(vec2 p) {\n    float theta = 1.2 + iTime* 0.01;\n    \n    mat2 rot = mat2( cos(theta), -sin(theta), sin(theta), cos(theta));\n    \n    float result = 0.0;\n    \n    result += cell(p).x * 0.500; p *= rot * 2.0; \n    result += cell(p).x * 0.250; p *= rot * 2.0; \n    result += cell(p).x * 0.125; p *= rot * 2.0; \n    result += cell(p).x * 0.125; p *= rot * 2.0; \n\n    \n    return result;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2( 0.5, 0.5);\n    \n    uv.x *=  iResolution.x/ iResolution.y;\n       \n    vec3 col = vec3( fbmCell(uv * 2.0));\n     \n     \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}