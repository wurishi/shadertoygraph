{"ver":"0.1","info":{"id":"wdtSDs","date":"1573169607","viewed":353,"name":"[TWITCH] Boss Key","username":"Flopine","description":"The is a shader I made during a live session on Twitch. I wanted to do something NPR and also experiment with procedural texturing and interactivity :) \nYou can watch the stream here: https://www.twitch.tv/flopine","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","mouse","interactive","zelda","npr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and others to sprout :)  https://twitter.com/CookieDemoparty\n\n#define ITER 64.\n#define time iTime \n#define PI 3.141592\n\n#define circle(uv,r) smoothstep(0.13,0.1, length(uv)-r)\n#define anim (2.*(iMouse.xy/iResolution.xy)-1.)\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid moda(inout vec2 p, float rep)\n{\n    float per = (2.*PI)/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a, per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\nfloat key (vec3 p)\n{\n    vec3 pp = p;\n\n    float c1 = cyl(p.xzy, 0.2-p.y*0.08, 1.);\n    float c2 = cyl(p.xzy-vec3(0.,0.,0.7), 0.2,0.1);\n    float c3 = cyl(p.xzy-vec3(0.,0.,0.96), 0.2,0.1);\n\n    p.y -= 0.45;\n    moda(p.xz, 4.);\n    p.x -= 0.25;\n    float c4 = cyl(p.yzx, 0.02-p.x*0.4, 0.2);\n\n    p = pp;\n    p.y += 0.45;\n    p.y -= pow(max(0.,p.x),5.)*0.3;\n    p.x -= 0.5;\n    float c5 = cyl(p.yzx, 0.05-p.x*0.2, 0.55);\n    p.y += 0.35;\n    p.x -= 0.1;\n    c5 = min(c5, cyl(p.yzx, 0.05-p.x*0.2, 0.55));\n\n\n    p = pp;\n    p.y -= 1.88;\n    float c6 = max(abs(cyl(p, 0.7,1.))-0.1,abs(p.z)-0.21);\n\n    p = pp;\n    float cut_c = cyl(p-vec3(0.,1.7,0.), 0.77,2.);\n    p.x = abs(p.x);\n    p.y -= 1.8;\n    p.x -= .8;\n\n    p.xy *= rot(PI/8.);\n    p.y -= pow(abs(p.x+0.2), 2.)*0.5;\n\n    float c7 = max(-cut_c,cyl(p.yzx, 0.2-p.x*0.2, 1.));\n\n    return min(c7,min(min(c5,c6),min(min(c3,c2),min(c1,c4))));\n}\n\nfloat center_key (vec3 p)\n{\n    p.y -= 1.8;\n    return cyl(p, .65, 0.1);\n}\n\nint mat_id;\nvec3 final_p;\nfloat SDF (vec3 p)\n{\n    p.xz *= rot(time);\n    p.xy *= rot(PI/4.);\n    p.y += 0.8;\n    final_p = p;\n    float k = key(p);\n    float ck = center_key(p);\n    float d = min(k,ck);\n\n    if(d == k) mat_id = 1;\n    if(d == ck) mat_id = 2;\n\n    return d;\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps= vec2(0.01,0.);\n    return normalize(SDF(p) - vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)) );\n}\n\nfloat lighting (vec3 n, vec3 l)\n{return dot(n, normalize(l))*0.5+0.5;}\n\nvec4 eye (vec2 uv)\n{\n    float spec_stain = circle(uv-vec2(.1),0.01);\n    float pupil = clamp(circle(uv,0.05)-spec_stain,0.,1.);\n    float iris = clamp(circle(uv, 0.2) - (spec_stain + pupil),0.,1.);\n    float outer_ring = clamp(circle(uv, 0.3)-(iris+pupil + spec_stain),0.,1.);\n\n    return vec4(spec_stain,pupil,iris,outer_ring);\n}\n\nvec3 eye_color (vec2 uv)\n{\n    vec4 e = eye(uv);\n    return vec3(1.)*e.x +\n        vec3 (0.)*e.y + \n        vec3(0.9,0.,0.)*e.z +\n        vec3 (0.9,0.8,0.)*e.w+\n        vec3 (0.5,0.2,0.7) * (1.-clamp(e.x+e.y+e.z+e.w,0.,1.));\n}\n\n// courtesy of Alkama\nfloat pales (vec2 uv, float speed, float number)\n{\n    uv *= rot(-time*speed);\n    return floor(smoothstep(0.1, 0.2,cos(atan(uv.y, uv.x)*number)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(0.,0.,-6.),\n        p = ro, \n        rd = normalize(vec3(uv,1.)),\n        col = mix(vec3(0.1,0.5,0.1),vec3(0.7,0.8,0.5),pales(uv, 0.2, 5.))+pales(uv, -0.5, 10.)*0.3;\n\n\n    float shad = 0.;\n    bool hit = false;\n\n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n\n        p += d*rd*0.5;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p),\n            l = normalize(vec3(5., 2., -4.)),\n            h = normalize(l-rd);\n        float spec = pow(abs(dot(n,h)), 25.);\n\n        if (mat_id == 1) \n        {\n            vec3 diffuse = mix(vec3(0.3,0.2,0.0), vec3(0.7,0.7,0.2),smoothstep(0.5,0.65,lighting(n,l)));\n\n            float fre = pow(clamp(1.-abs(dot(-rd,n)),0.,1.), 2.);\n\n            col = diffuse + vec3(1.,0.7,0.7)*spec + fre * vec3(0.8,0.7, 0.3);\n        }\n        \n        if (mat_id == 2)\n        {\n            vec2 p_eye = (final_p.xy-clamp(anim,-0.3,.3))-vec2(0.,1.88); \n            vec3 diffuse = eye_color(p_eye);\n\n            col = diffuse * lighting(n,l) + spec*(eye(p_eye).w);\n        }\n    }\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}