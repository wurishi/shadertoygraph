{"ver":"0.1","info":{"id":"7lKGDG","date":"1638289979","viewed":443,"name":"pencil_drawn_crystal_world_space","username":"skaplun","description":"Need your help! See first comment\n\nHatches redone in world-space to avoid shower door effect,\nOriginal postprocessing shader made by @flockaroo - https://www.shadertoy.com/view/MsKfRw.\n","likes":38,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf","postproc"],"hasliked":0,"parentid":"styGDw","parentname":"pencil_drawn_crystal"},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NoiseTex iChannel1\n#define prevPass iChannel0\n\n#define VIGNETTING\n//#define STROKE_THICKNESS (min(iResolution.x,iResolution.y)/500.)\n#define GRADIENT_EPS (STROKE_THICKNESS * .4)\n\nstruct DistortionParams{\n    float value, amplitude;\n} NO_DISTORTION = DistortionParams(0., 0.);\n#define DISTORTION_OUTLINE_1(x) DistortionParams( 1.7 * pow(1.3, -x * 5.), .15 * pow(1.3, x * 5.)))\n#define DISTORTION_OUTLINE_2(x) DistortionParams(10.7 * pow(1.3, -fi * 5.), .4 * pow(1.3, fi * 5.)))\n\n\nvec4 distortedDiffuseColor(const in vec2 pos, const in DistortionParams distortionParams){\n    vec2 distortionValue = (distortion(pos * .05 * distortionParams.value/STROKE_THICKNESS, iChannel1) - .5).xy * 15. * distortionParams.amplitude;\n    vec2 uv = (pos + distortionValue * STROKE_THICKNESS)/iResolution.xy;\n    return texture(prevPass, uv);\n}\n\nfloat luminance(const in vec2 pos, const in DistortionParams distortionParams){\n    return saturate(distortedDiffuseColor(pos, distortionParams).x);\n}\n\nvec2 gradient(const in vec2 pos, const in DistortionParams distortionParams){\n    vec2 d = vec2(GRADIENT_EPS, 0.);\n    return vec2(luminance(pos + d.xy, distortionParams) - luminance(pos - d.xy, distortionParams),\n                luminance(pos + d.yx, distortionParams) - luminance(pos - d.yx, distortionParams))/GRADIENT_EPS/2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    float stroke = 0.;\n    for(int i=0; i<3; i++){\n        float fi = float(i)/2.;\n        float strokeStrength = .03 + .5 * fi;\n        // one closely matched edge-line\n        stroke += .4 * (.5 + fi) * smoothstep(0., strokeStrength, length(gradient(fragCoord, DISTORTION_OUTLINE_1(fi)) * STROKE_THICKNESS);\n        // another wildly varying edge-line\n        stroke += .8 * (.2 + fi) * smoothstep(0., strokeStrength, length(gradient(fragCoord, DISTORTION_OUTLINE_2(fi)) * STROKE_THICKNESS);\n    }\n    vec4 r2 = distortion(fragCoord * 1.2/sqrt(STROKE_THICKNESS), iChannel1);\n    fragColor.xyz = vec3(1.) - saturate(stroke * (.5 + .5 * r2.z));\n\n    fragColor.xyz *= texture(prevPass, fragCoord/iResolution.xy).y;\n    \n    \n    // subtraction of 2 rand values, so its [-1..1] and noise-wise not as white anymore\n    vec4 r = distortion(fragCoord * 1.2/sqrt(STROKE_THICKNESS), iChannel1)\n           - distortion(fragCoord * 1.2/sqrt(STROKE_THICKNESS) + vec2(1, -1) * 1.5, iChannel1);\n    // paper\n    fragColor.xyz *= .95 + .06 * r.xxx + .06 * r.xyz;\n    fragColor.w = 1.;\n    \n#ifdef VIGNETTING\n    {\n        vec2 scc = (fragCoord - .5 * iResolution.xy)/iResolution.x;\n        float vign = 1. - .3 * dot(scc, scc);\n        vign *= 1. - .7 * exp(-sin(fragCoord.x/iResolution.x * PI) * 40.);\n        vign *= 1. - .7 * exp(-sin(fragCoord.y/iResolution.y * PI) * 20.);\n        fragColor.xyz *= vign;\n    }\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n#define EPSILON 1e-2\n#define rx(a) mat3(cos(a), -sin(a), 0., sin(a), cos(a), 0., 0., 0., 1.)\n#define ry(a) mat3(cos(a), 0., sin(a), 0., 1., 0., -sin(a), 0., cos(a))\n#define rz(a) mat3(1., 0., 0., 0., cos(a), -sin(a), -sin(a), 0., cos(a))\n#define rotate(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define saturate(x) clamp(x, 0., 1.)\n#define SIDE  vec3(1., 0., 0.);\nconst float PI = acos(-1.);\nconst float PI2 = 2. * PI;\n\nstruct Ray{vec3 origin, direction;};\nstruct Box{ vec3 o; vec3 size;};\nstruct HitRecord{float dist[2];vec3 ptnt[2];vec3 nrm[2];};\n\n\n#define STROKE_THICKNESS (min(iResolution.x,iResolution.y)/800.)\n\nvec4 distortion(const in vec2 pos, sampler2D NoiseTex){\n    vec2 noiseTextureRes = vec2(textureSize(NoiseTex, 0));\n    vec2 uv = pos/noiseTextureRes;\n    uv += .6 * sin(uv * noiseTextureRes * PI2)/PI2/noiseTextureRes;\n    return texture(NoiseTex, uv * .5);\n}\n \nbool plane_hit(in vec3 ro, in vec3 rd, in vec3 po, in vec3 pn, out float dist) {\n    float denom = dot(pn, rd);\n    if (denom > MIN_FLOAT) {\n        vec3 p0l0 = po - ro;\n        float t = dot(p0l0, pn) / denom;\n        if(t >= MIN_FLOAT && t < MAX_FLOAT){\n\t\t\tdist = t;\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h){\n    return dot(p,n) + h;\n}\n\nvec2 opMax(vec2 a, vec2 b){\n    return a.x >= b.x ? a : b;\n}\n\n#define MIN x\n#define MAX y\nbool box_hit(const in Box inbox, in Ray inray, out vec2 dst){\n    vec2 tx, ty, tz;\n    vec3 maxbounds = inbox.o + vec3( inbox.size);\n    vec3 minbounds = inbox.o + vec3(-inbox.size);\n    tx = ((inray.direction.x >= 0.?vec2(minbounds.x, maxbounds.x):vec2(maxbounds.x, minbounds.x)) - inray.origin.x) / inray.direction.x;\n\tty = ((inray.direction.y >= 0.?vec2(minbounds.y, maxbounds.y):vec2(maxbounds.y, minbounds.y)) - inray.origin.y) / inray.direction.y;\n    if ((tx.MIN > ty.MAX) || (ty.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, ty.MIN), min(tx.MAX, ty.MAX));\n\ttz = ((inray.direction.z >= 0.?vec2(minbounds.z, maxbounds.z):vec2(maxbounds.z, minbounds.z)) - inray.origin.z) / inray.direction.z;\n    if ((tx.MIN > tz.MAX) || (tz.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, tz.MIN), min(tx.MAX, tz.MAX));\n    \n    if(tx.MIN >= 0. || tx.MAX >= 0.){\n        dst = vec2(tx.MIN, tx.MAX);\n        return true;\n    }\n        \n    return false;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define AA (10./max(iResolution.x, iResolution.y))\n\nconst int CUTOFF_PLANES_COUNT = 12;\nmat3 cutoffPlanes[CUTOFF_PLANES_COUNT];\n\nvec2 world(vec3 p){\n    vec2 res = vec2(length(p) - 3., MAX_FLOAT);\n    for(int i=0; i<CUTOFF_PLANES_COUNT; i++){\n        res = opMax(res, vec2(sdPlane(p, cutoffPlanes[i] * vec3(1., 0., 0.), -1.5), float(i)));\n    }\n    return res;\n}\n\nconst int MAX_MARCHING_STEPS = 64;\nvec2 march(in Ray r, float minDst, float maxDst){\n    float t = minDst;\n    for(int i = 0; i <= MAX_MARCHING_STEPS; i++){\n        vec3 p = r.origin + r.direction * t;\n        vec2 dst = world(p);\n        if(dst.x < .01)\n            return vec2(t, dst.y);\n        t += dst.x;\n        if(t > maxDst)\n            break;\n    }\n    return vec2(-1.);\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        world(vec3(p.x + EPSILON, p.y, p.z)).x - world(vec3(p.x - EPSILON, p.y, p.z)).x,\n        world(vec3(p.x, p.y + EPSILON, p.z)).x - world(vec3(p.x, p.y - EPSILON, p.z)).x,\n        world(vec3(p.x, p.y, p.z  + EPSILON)).x - world(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\nfloat hatches(vec2 uv, float lum){\n    vec4 r = distortion(uv * 1.2/sqrt(STROKE_THICKNESS), iChannel0)\n           - distortion(uv * 1.2/sqrt(STROKE_THICKNESS) + vec2(1, -1) * 1.5, iChannel0);\n\n    // cross hatch\n    const int HATCHES_COUNT = 5;\n#define N(v) (v.yx * vec2(-1, 1))\n#define CS(ang) cos(ang - vec2(0, 1.6))\n    float hatchesSum = 0.;\n    float strongestHatch = 0.;\n    float actualHatchesCount = 0.;\n    for(actualHatchesCount = 0.; actualHatchesCount < float(HATCHES_COUNT); actualHatchesCount++)\n    {\n        // chose the hatch angle to be prop to i*i\n        // so the first 2 hatches are close to the same angle, \n        // and all the higher i's are fairly random in angle\n        float hatchAng = -.5 - .08 * actualHatchesCount * actualHatchesCount;\n        vec2 rotatedUV = mat2(CS(hatchAng), N(CS(hatchAng))) * uv/sqrt(STROKE_THICKNESS) * vec2(.05, 1) * 2.3;\n        float rh = pow(distortion(rotatedUV + vec2(sin(rotatedUV.y), 0.), iChannel0), vec4(1.)).x;\n        float currentHatch = 1. - smoothstep(.5, 1.5, (rh) + lum) - .3 * abs(r.z);\n        hatchesSum += currentHatch;\n        strongestHatch = max(strongestHatch, currentHatch);\n        if(actualHatchesCount >= 2. && actualHatchesCount > (1. - lum) * float(HATCHES_COUNT)) break;\n    }\n\n    float res = 1. - saturate(mix(hatchesSum/actualHatchesCount, strongestHatch, .5));\n    res = 1. - ((1. - res) * .7);\n    \n    return res;\n}\n\nvec2 crystalColor(vec3 pos, vec3 viewDir, float specMul, float matId){\n    vec3 norm = estimateNormal(pos);\n\n    vec3 lights[] = vec3[2](vec3(2., 3., 3.), vec3(-2., -1., -4.));\n    float totalDiff = 0.;\n    float totalSpec = 0.;\n    for(int i=0; i<2; i++) {\n        vec3 lightDir = normalize(lights[i] - pos);\n        vec3 reflectDir = reflect(-lightDir, norm);\n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.);\n        //totalSpec += .5 * spec;\n        totalDiff += max(dot(norm, lightDir), 0.1);\n    }\n    float lum = totalDiff + totalSpec * specMul;\n    \n    vec2 uv = (inverse(cutoffPlanes[int(matId)]) * pos).zy * 25. + 50.;\n    //vec2 uv = (cutoffPlanes[int(matId)] * pos).zy * 15. + 30.;\n    return vec2(lum, hatches(uv, max(lum, .3)));\n}\n\n\n\nvec3 color(in vec2 fragCoord){\n    {\n        int planeIndex = 0;\n        for(float i=0.; i<float(CUTOFF_PLANES_COUNT/3); i++){\n            vec3 h = hash33(vec3(3.17, 47.121, i)) * 2. - 1.;\n            vec3 h2 = hash33(vec3(41.17, i, 71.121)) * 2. - 1.;\n            \n            cutoffPlanes[planeIndex++] = mat3(1.) * ry(radians(90. * i + 15. * h.x)) * rx(-radians(30. + 5. * h.y));\n            cutoffPlanes[planeIndex++] = mat3(1.) * ry(radians(90. * i - 25. + 35. * h.z));\n            cutoffPlanes[planeIndex++] = mat3(1.) * ry(radians(90. * i + 15. + 15. * h2.x)) * rx(radians(30. + 10. * h2.y));\n        }\n    }\n    \n    vec2 uv = fragCoord/iResolution.y;\n    float ang = (iMouse.x/iResolution.x) * PI2 + iTime * .5;\n    vec3 eye = vec3(20. * sin(ang), 3., 20. * cos(ang));\n    vec3 viewDir = rayDirection(45., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, vec3(0., -1.12, 0.), vec3(0., 1., 0.)) * viewDir;\n    \n    Ray r = Ray(eye, worldDir);\n    \n    vec2 color = vec2(0.);\n    vec4 dst = vec4(MAX_FLOAT);\n    if(box_hit(Box(vec3(0.), vec3(2., 3.2, 2.)), r, dst.xy)){\n        dst.zw = march(r, dst.x, dst.y);\n        if (dst.z >= 0.) {\n            vec3 pos = r.origin + r.direction * dst.z;\n            color.xy += crystalColor(pos, r.direction, 1., dst.w);\n        }else{\n            dst.z = MAX_FLOAT;\n        }\n    }\n    \n    float hitFloor = (-3.-r.origin.y)/r.direction.y;\n    if(hitFloor >= 0. && hitFloor < dst.z){\n        vec3 p = r.origin + r.direction * hitFloor;\n        float f = mod(floor(p.z * .25) + floor(p.x * .25), 2.);\n        float lum = (.35 + f * .5) * smoothstep(150., 25., distance(p.xz, vec2(0.)));\n        color.xy = vec2(lum, hatches(p.xz * 25. + 50., lum));\n        \n        Ray r2 = Ray(p, reflect(r.direction, vec3(0., 1., 0.)));\n        vec4 dst = vec4(-MAX_FLOAT);\n        if(box_hit(Box(vec3(0.), vec3(2., 3.2, 2.)), r2, dst.xy)){\n            dst.zw = march(r2, max(dst.x, 0.), max(dst.x, dst.y));\n            if (dst.z >= 0.) {\n                vec3 pos = r2.origin + r2.direction * dst.z;\n                color += .5 * crystalColor(pos, r2.direction, .1, dst.w);\n            }\n        }\n    }\n    \n    return vec3(color, 1.);\n}\n\n#define SS 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = vec4(0.);\n    for(int y = 0; y < SS; ++y)\n        for(int x = 0; x < SS; ++x){\n            fragColor.rgb += clamp(color(fragCoord + vec2(x, y) / float(SS)), 0., 1.);\n        }\n    \n    fragColor.rgb /= float(SS * SS);\n}","name":"Buffer A","description":"","type":"buffer"}]}