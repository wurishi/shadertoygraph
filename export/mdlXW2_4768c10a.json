{"ver":"0.1","info":{"id":"mdlXW2","date":"1669607145","viewed":495,"name":"watercolor propagation","username":"aeva","description":"This is an experiment to try to simulate a watercolor-like post processing effect.  I've added some inline implementation notes to Buffer A.","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["blur","water","cmyk","ink","watercolor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 UV = fragCoord / iResolution.xy;\n    vec4 Color = texture(iChannel0, UV).rgba;\n    fragColor = vec4(CMYKtoRGB(Color), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 MakeUV(vec2 fragCoord, vec2 Offset)\n{\n    return (fragCoord + Offset) / iResolution.xy;\n}\n\n\nvec2 BiasUV(vec2 fragCoord, vec2 Offset)\n{\n    return (fragCoord + Offset) / vec2(256);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 LastSize = texture(iChannel3, vec2(0.0)).rg;\n\n    if (iFrame <= 10 || any(notEqual(LastSize, iResolution.xy)))\n    {\n        vec2 UV = fragCoord / iResolution.xy;\n        vec3 Color = texture(iChannel0, UV).rgb;\n        \n        // Performing the effect in CMYK space gives a somewhat nicer saturation\n        // bleed, which I think looks a little more realistic.  I think RGB ends\n        // up looking more washed out.\n        fragColor = RGBtoCMYK(Color);\n    }\n    else\n    {\n        vec2 Kernel[8] = vec2[8](\n            vec2(-1.0,  0.0),\n            vec2(-1.0, -1.0),\n            vec2( 0.0, -1.0),\n            vec2( 1.0, -1.0),\n            vec2( 1.0,  0.0),\n            vec2( 1.0,  1.0),\n            vec2( 0.0,  1.0),\n            vec2(-1.0,  1.0)\n        );\n        \n        vec4 Color = vec4(0.0);\n\n        for (int i = 0; i < 8; ++i)\n        {\n            // The pixel wetness factor here is arbitrary.  Ideally it should drop\n            // to zero over time to simulate evaporation.\n            vec2 ScreenUV = fragCoord / iResolution.xy;\n            float Wetness = max(ScreenUV.y * ScreenUV.y, 0.025);\n        \n            vec2 Offset = normalize(Kernel[i]);\n            \n            // The bias is intended to provide a basic flow map for ink propagation.\n            // The wetness determines how far away to sample from.  This seems to be\n            // more useful to getting a good spreading effect than many successive\n            // iterations.\n            vec2 Bias = texture(iChannel2, BiasUV(fragCoord, Offset)).rg * 2.0 - 1.0;\n            vec2 UV = MakeUV(fragCoord, (Offset + Bias) * Wetness * 5.0);\n            \n            // The blur itself is just a simple average of several samples.\n            vec4 Sample = texture(iChannel1, UV).rgba;\n            Color += Sample;\n        }\n        Color /= 8.0;\n    \n        fragColor = Color;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// From https://gist.github.com/mattdesl/e40d3189717333293813626cbdb2c1d1, which\n// cites the book \"Graphics Shaders\"\n\nvec3 CMYKtoRGB (vec4 cmyk) {\n    float c = cmyk.x;\n    float m = cmyk.y;\n    float y = cmyk.z;\n    float k = cmyk.w;\n\n    float invK = 1.0 - k;\n    float r = 1.0 - min(1.0, c * invK + k);\n    float g = 1.0 - min(1.0, m * invK + k);\n    float b = 1.0 - min(1.0, y * invK + k);\n    return clamp(vec3(r, g, b), 0.0, 1.0);\n}\n\nvec4 RGBtoCMYK (vec3 rgb) {\n    float r = rgb.r;\n    float g = rgb.g;\n    float b = rgb.b;\n    float k = min(1.0 - r, min(1.0 - g, 1.0 - b));\n    vec3 cmy = vec3(0.0);\n    float invK = 1.0 - k;\n    if (invK != 0.0) {\n        cmy.x = (1.0 - r - k) / invK;\n        cmy.y = (1.0 - g - k) / invK;\n        cmy.z = (1.0 - b - k) / invK;\n    }\n    return clamp(vec4(cmy, k), 0.0, 1.0);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = iResolution.xyxy;\n}","name":"Buffer B","description":"","type":"buffer"}]}