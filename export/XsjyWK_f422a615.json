{"ver":"0.1","info":{"id":"XsjyWK","date":"1493831067","viewed":621,"name":"Noodle State Of Mind","username":"lherm","description":"Playing with short raymarching ideas","likes":11,"published":3,"flags":32,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on a LOT of code from Connor Bell\n\n// From netgrind\nvec4 hue(vec4 color, float shift) {\n\n    const vec4  kRGBToYPrime = vec4 (0.299, 0.587, 0.114, 0.0);\n    const vec4  kRGBToI     = vec4 (0.596, -0.275, -0.321, 0.0);\n    const vec4  kRGBToQ     = vec4 (0.212, -0.523, 0.311, 0.0);\n\n    const vec4  kYIQToR   = vec4 (1.0, 0.956, 0.621, 0.0);\n    const vec4  kYIQToG   = vec4 (1.0, -0.272, -0.647, 0.0);\n    const vec4  kYIQToB   = vec4 (1.0, -1.107, 1.704, 0.0);\n\n    // Convert to YIQ\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I      = dot (color, kRGBToI);\n    float   Q      = dot (color, kRGBToQ);\n\n    // Calculate the hue and chroma\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    // Make the user's adjustments\n    hue += shift;\n\n    // Convert back to YIQ\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    // Convert back to RGB\n    vec4    yIQ   = vec4 (YPrime, I, Q, 0.0);\n    color.r = dot (yIQ, kYIQToR);\n    color.g = dot (yIQ, kYIQToG);\n    color.b = dot (yIQ, kYIQToB);\n\n    return color;\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n    vec2 R=iResolution.xy, u = (g/R);\n    vec4 tex = texture(iChannel0, u), col=tex, tmp;\n    for (int i = 0; i < 8; i++)\n    {\n        tmp = texture(iChannel0, u + .09*sin(float(i) + iTime));\n        tmp.g = 0.;\n        col += hue(tmp*.5, iTime + tmp.r);\n    }\n    f = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define R(p, a) {p = p * cos(a) + sin(a) * vec2(p.y, -p.x);}\nvoid mainImage( out vec4 O, in vec2 g )\n{\n    O-=O;\n    vec2 R = iResolution.xy;\n\tvec4 p = vec4((g+g-R)/R.y, 0, 1), d=p;\n    float x=1., i=x, T=iTime;\n    R(p.xy, T);\n    p.y -= T;\n    for (;i > 0. && x > 1e-4; i-=.02)\n        x = length(cos(p.xx*.5 - T)*(.5 * sin(T)) - sin(vec2(p.y, p.w) - T)*.5 - length(cos(p.xw + T))*.05)-.05,\n        O += i*i - O,\n        p -= d*x;\n}","name":"Buf A","description":"","type":"buffer"}]}