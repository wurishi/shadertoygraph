{"ver":"0.1","info":{"id":"4sd3zf","date":"1451438109","viewed":532,"name":"Pixel clouds","username":"ambi","description":"Some pixelart clouds for games","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["clouds","pixelart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// modded from https://www.shadertoy.com/view/MdBGRh \"Nightsky\" by Bysse\n// noise from https://www.shadertoy.com/view/4sfGzS by iq\n\n#define STEPS 4.0\n#define CLOUD_DETAIL 1.3\n\n#define XPIXELS 320.0\n#define YPIXELS 200.0\n\nfloat hash(float n) { return fract(sin(n)*753.5453123); }\n\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z)-0.4;\n}\n\nfloat clouds(vec3 p) {\n\tvec3 q = p+vec3(-0.1,0.37,1.0)*2.0*iTime+vec3(0.0, sin(p.y)*100.0, 0.0);\n\tfloat v = 0.0;\n\tv += 0.550 * noise(q*0.051);\n\tv += 0.250 * noise(q*0.111);\n\tv += 0.125 * noise(q*0.211);\n    \n\treturn v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t//uv.y *= iResolution.y / iResolution.x;\n    uv.x = floor(uv.x*XPIXELS)/XPIXELS;\n    uv.y = floor(uv.y*YPIXELS)/YPIXELS;\n\tvec2 pos = -1.0 + 2.0 * uv;\n\n\t// camera setup\n\tvec3 camTarget = vec3(-3.4, 4.0, 0.0);\n\t\n\tvec3 camPos = vec3(0.0, 0.0, -1.5);\t\n\tvec3 up = vec3(0, 1, 0);\n\t\n\tvec3 camDir = normalize((camTarget - camPos));\n\tvec3 camLeft = normalize(cross(up, camDir));\n\tvec3 camUp = cross(camDir, camLeft);\n\t\n\tvec3 rayPos = camPos + normalize(camDir + pos.x * camLeft + pos.y * camUp);\n\tvec3 rayDir = normalize(rayPos - camPos);\n\t\n\tfloat t = (20.0 - rayPos.y) / rayDir.y;\t\t\n\n    float colv = 0.0;\n\tif (t >= 0.0 || t < -350.0) {\t\t\t\t\n\t\t// clouds\n\t\tfloat cloudA = 1.0;\n        cloudA *= pow(smoothstep(0.0, 1.0, 90.0/t), 1.5);\t// lower dim\n        cloudA *= pow((smoothstep(0.0, 1.0, t/35.0)), 1.5); //upper dim\n\t\tcolv += cloudA * smoothstep(0.0, 0.8, 0.2+clouds(t *CLOUD_DETAIL* rayDir));\t\t\t\t\n\t}\t\t\n\t\n    colv*=1.5;\n    colv *= min(1.0, colv);\n    \n    const float step1 = 1.0/STEPS;\n    float testvar = mod(colv, step1);\n    \n    bool xgrid = mod(uv.x*XPIXELS, 2.0)<1.0;\n    bool ygrid = mod(uv.y*YPIXELS, 2.0)<1.0;\n\n    // dither\n    colv += testvar>step1*0.20 &&  xgrid &&  ygrid ? step1:0.0;\n    colv += testvar>step1*0.40 && !xgrid && !ygrid ? step1:0.0;\n    colv += testvar>step1*0.60 &&  xgrid && !ygrid ? step1:0.0;\n    colv += testvar>step1*0.80 && !xgrid &&  ygrid ? step1:0.0;\n\n    \n    \n    colv = colv-mod(colv*STEPS, 1.0)/STEPS;\n    \n    \n    // color corrections from b&w\n    vec3 col = vec3(colv);\n    col *= vec3(0.9, 0.7, 1.4);\n    col += vec3(0.15, 0.1, 0.3); \n\n\tfragColor = vec4(col, 1.0);\t\n}\n","name":"","description":"","type":"image"}]}