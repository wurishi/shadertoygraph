{"ver":"0.1","info":{"id":"MstGWl","date":"1454436054","viewed":173,"name":"Interrupted polyconic projection","username":"nico_mgd","description":"Imprecisions at the equator - wish I could upload/use a real globe map texture :)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["geographic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define num_lobes 18\n\nconst float epsilon = 1e-6;\nconst float eps_equator = 2e-2;\nconst float pi = 3.141592653589793;\nconst float halfPi = pi * 0.5;\n\nconst float lng_offset = -10.0 * pi / 180.0;\n\n/*\nfunction sinusoidal(Î», Ï†) {\n  return [\n    Î» * Math.cos(Ï†),\n    Ï†\n  ];\n}\n\nsinusoidal.invert = function(x, y) {\n  return [\n    x / Math.cos(y),\n    y\n  ];\n};\n*/\nvec2 sinusoidal(vec2 lnglat) {\n    return vec2(\n        lnglat.x * cos(lnglat.y),\n    \tlnglat.y\n    );\n}\n\nvec2 sinusoidal_inv(vec2 xy) {\n    return vec2(\n        xy.x / cos(xy.y),\n        xy.y\n    );\n}\n\n/*\nfrom https://github.com/d3/d3-geo-projection/blob/master/src/polyconic.js\nmath http://mathworld.wolfram.com/PolyconicProjection.html\n\nfunction polyconic(Î», Ï†) {\n  if (Math.abs(Ï†) < Îµ) return [Î», 0];\n  var tanÏ† = Math.tan(Ï†),\n      k = Î» * Math.sin(Ï†);\n  return [\n    Math.sin(k) / tanÏ†,\n    Ï† + (1 - Math.cos(k)) / tanÏ†\n  ];\n}\n? inverse( sin(x*sin(y)) / tan(y) )\n, inverse( y + (1-cos(x*sin(y))) / tan(y) )\n*/\nvec2 polyconic(vec2 lnglat) {\n    \n    if (abs(lnglat.y) < epsilon) return vec2(lnglat.x, 0.0);\n    float tanY = tan(lnglat.y);\n    float k = lnglat.x * sin(lnglat.y);\n    return vec2(\n        sin(k) / tanY,\n        lnglat.y + (1.0 - cos(k)) / tanY\n    );\n}\n\n/*\npolyconic.invert = function(x, y) {\n  if (Math.abs(y) < Îµ) return [x, 0];\n  var k = x * x + y * y,\n      Ï† = y * .5,\n      i = 10, Î´;\n  do {\n    var tanÏ† = Math.tan(Ï†),\n        secÏ† = 1 / Math.cos(Ï†),\n        j = k - 2 * y * Ï† + Ï† * Ï†;\n    Ï† -= Î´ = (tanÏ† * j + 2 * (Ï† - y)) / (2 + j * secÏ† * secÏ† + 2 * (Ï† - y) * tanÏ†);\n  } while (Math.abs(Î´) > Îµ && --i > 0);\n  tanÏ† = Math.tan(Ï†);\n  return [\n    (Math.abs(y) < Math.abs(Ï† + 1 / tanÏ†) ? asin(x * tanÏ†) : sgn(x) * (acos(Math.abs(x * tanÏ†)) + halfÏ€)) / Math.sin(Ï†),\n    Ï†\n  ];\n};\n*/\nvec2 polyconic_inv(vec2 xy) {\n    \n    float lat = xy.y * 0.5;\n    \n    vec2 lin_approx = vec2(xy.x, xy.y);\n    float blend_approx = smoothstep(eps_equator, 2.0*eps_equator, abs(xy.y));\n    if (blend_approx == 0.0) return lin_approx;\n\n    // NOTE(nico) hide the artifacts near the equator\n    //float blend_approx = 0.0;\n    //if (abs(xy.y) < 2.0*eps_equator) blend_approx = (2.0*eps_equator - abs(xy.y)) / eps_equator;\n    \n    float k = dot(xy, xy);\n    float b = 1.0;\n    for (int i=0; i<10; i++) {\n        if (abs(b) < epsilon) break;\n        float tanA = tan(lat);\n        float secA = 1.0 / cos(lat);\n        float j = k - 2.0 * xy.y * lat + lat * lat;\n        b = (tanA * j + 2.0 * (lat - xy.y)) / (2.0 + j * secA * secA + 2.0 * (lat - xy.y) * tanA);\n        lat -= b;\n    }\n    float tanA = tan(lat);\n    \n    vec2 result = vec2(\n        // NOTE(nico) sign(xy.x*xy.y) is needed to fix south pole issue\n        (abs(xy.y) < abs(lat + 1.0/tanA) ? asin(xy.x * tanA) : sign(xy.x*xy.y) * (acos(abs(xy.x * tanA)) + halfPi)) / sin(lat),\n        lat\n    );\n    \n    result = mix(lin_approx, result, blend_approx);\n    return result;\n}\n\nconst float lobe_size = (2.0 * pi) / float(num_lobes);\n\nvec2 forward(vec2 lnglat) {\n    \n    // unprojected space lnglat\n    float lobe = floor(lnglat.x / lobe_size);\n    float lng_lobe_mid = (lobe + 0.5) * lobe_size;\n    vec2 coord = polyconic( vec2(lnglat.x-lng_lobe_mid, lnglat.y) );\n    float lat_lobe_mid = 0.0;\n    coord.x += polyconic( vec2(lng_lobe_mid, lat_lobe_mid) ).x;\n    return coord;\n}\n\nvec2 polyconic_inv_gores(vec2 lnglat) {\n    \n    // NOTE(nico) find the current lobe in projected space\n    // based on https://github.com/d3/d3-geo-projection/blob/master/src/interrupt.js\n    float lobe;\n    float lng_lobe_left;\n    float lng_lobe_right;\n    float lng_lobe_mid;\n    float lat_lobe_bottom;\n    float lat_lobe_top;\n    float lat_lobe_mid;\n    bool found = false;\n    \n    for (int i=0; i<num_lobes; i++) {\n        \n        lobe = float(i);\n        lng_lobe_left = -pi + lobe * lobe_size;\n        lng_lobe_right = lng_lobe_left + lobe_size;\n        lng_lobe_mid = lng_lobe_left + 0.5*lobe_size;\n        lat_lobe_bottom = -halfPi;\n        lat_lobe_top = halfPi;\n        lat_lobe_mid = 0.0;\n        float lat_lobe = (lnglat.y >= 0.0) ? lat_lobe_top : lat_lobe_bottom;\n        \n        float x0 = polyconic_inv( vec2(lng_lobe_left, lat_lobe_mid) ).x;\n        float x1 = polyconic_inv( vec2(lng_lobe_right, lat_lobe_mid) ).x;\n        float y0 = polyconic_inv( vec2(lng_lobe_mid, lat_lobe_mid) ).y;\n        float y1 = polyconic_inv( vec2(lng_lobe_mid, lat_lobe) ).y;\n        if (y0 > y1) {\n            float temp = y0;\n            y0 = y1;\n            y1= temp;\n        }\n        if (x0 <= lnglat.x && lnglat.x < x1/* && y0 <= lnglat.y && lnglat.y < y1*/)\n        {\n            found = true;\n            break;\t// found\n        }\n    }\n    \n    if (!found) return vec2(0.0);\n    \n    float offset = polyconic_inv( vec2(lng_lobe_mid, 0.0) ).x;\n    vec2 result = polyconic_inv( lnglat - vec2(offset,0.0) );\n    result.x = result.x + lng_lobe_mid;\n    \n    if (true) { //abs(result.y) >= 2.0*eps_equator) {\n        vec2 f = forward(result);\n        if (length(f-lnglat) > 2e-3) result = vec2(0.0);\n    }\n    \n    return result;\n}\n\nvec2 uv2lnglat(vec2 uv01) {\n    return vec2(pi, halfPi) * (2.0 * uv01 - vec2(1.0));\n}\n\nvec2 lnglat2uv(vec2 lnglatlobe) {\n    vec2 result = lnglatlobe.xy / vec2(pi, halfPi);\n    result = 0.5 * result + vec2(0.5);\n    return result;\n}\n\nvec2 polyconic_uv( vec2 fragCoord_ ) {\n\n    vec2 uv = fragCoord_.xy / iResolution.xy;\n    uv += 0.0*vec2( cos(iTime), sin(0.3*iTime) );\n    //uv = uv - vec2(0.5);\n    //uv *= 2.0;\n    //uv -= vec2(0.5);\n\n    vec2 lnglat = uv2lnglat( uv );\n\n    //uv.x = uv.x / cos(uv.y * 3.14 / 2.0);\n    //uv = sinusoidal_inv(uv);\n    lnglat = polyconic_inv_gores(lnglat);\n    lnglat.x += lng_offset;\n    if (lnglat.x < -pi) lnglat.x += 2.0 * pi;\n    if (lnglat.x > pi) lnglat.x -= 2.0 * pi;\n    \n    uv = lnglat2uv( lnglat );\n\n    //uv.y = 1.0 - uv.y;\n    //uv = clamp(uv, vec2(0.0), vec2(1.0));\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fc = fragCoord + vec2(0.5, 0.5);\n\tvec2 uv = polyconic_uv(fc.xy);\n\tvec2 uvX = polyconic_uv(fc.xy + vec2(1.0,0.0));\n\tvec2 uvY = polyconic_uv(fc.xy + vec2(0.0,1.0));\n    fragColor = textureGrad( iChannel0, uv, uvX-uv, uvY-uv );\n    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {\n        fragColor = vec4(0.0);\n    }\n    //fragColor = texture( iChannel0, uv );\n}\n","name":"Image","description":"","type":"image"}]}