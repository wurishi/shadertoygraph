{"ver":"0.1","info":{"id":"MtGcRW","date":"1561527782","viewed":446,"name":"Gamma Corrected Subpixel AA","username":"Tynach","description":"Some testing with subpixel antialiased line drawing. Click+drag to change the line.\n\nTo use Shadertoy's signed distance font texture:\n1. Move the '/*' from the start of line 211, to instead be at the start of line 204.\n2. Set 'thick' on line 155 to 0.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["antialiasing","gamma","aa","subpixel","srgb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Structures\n */\n\n// Parameters for transfer characteristics (gamma curves)\nstruct transfer {\n\t// Exponent used to linearize the signal\n\tfloat power;\n\n\t// Offset from 0.0 for the exponential curve\n\tfloat off;\n\n\t// Slope of linear segment near 0\n\tfloat slope;\n\n\t// Values below this are divided by slope during linearization\n\tfloat cutoffToLinear;\n\n\t// Values below this are multiplied by slope during gamma correction\n\tfloat cutoffToGamma;\n};\n\n\n/*\n * Gamma curve parameters\n */\n\n// Gamma of 1.0; linear light\nconst transfer gam10 = transfer(1.0, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 1.8; Approximately what old Apple computers used\nconst transfer gam18 = transfer(1.8, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.0\nconst transfer gam20 = transfer(2.0, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.2; not linear near 0. Was defined abstractly to be used by early\n// NTSC systems, before SMPTE 170M was modified to specify a more exact curve\nconst transfer gam22 = transfer(2.2, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.4; not linear near 0. Seems a popular choice among some people\n// online, so I included it. I don't think any standard uses this\nconst transfer gam24 = transfer(2.4, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.5; not linear near 0. Approximately what old Sony TVs used\nconst transfer gam25 = transfer(2.5, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.8; not linear near 0. Loosely defined gamma for European SDTV\nconst transfer gam28 = transfer(2.8, 0.0, 1.0, 0.0, 0.0);\n\n// Modern SMPTE 170M, as well as Rec. 601, Rec. 709, and a rough approximation\n// for Rec. 2020 content as well. Do not use with Rec. 2020 if you work with\n// high bit depths!\nconst transfer gam170m = transfer(1.0/0.45, 0.099, 4.5, 0.0812, 0.018);\n\n// Gamma for sRGB. Besides being full-range (0-255 values), this is the only\n// difference between sRGB and Rec. 709.\nconst transfer gamSrgb = transfer(2.4, 0.055, 12.92, 0.04045, 0.0031308);\n\n// Gamma for the CIE L*a*b* Lightness scale\nconst transfer gamLab = transfer(3.0, 0.16, 243.89/27.0, 0.08, 216.0/24389.0);\n\n\n/*\n * Conversion Functions\n */\n\n// Converts RGB colors to a linear light scale\nvoid toLinear(inout vec3 color, const transfer trc)\n{\n\tbvec3 cutoff = lessThan(color, vec3(trc.cutoffToLinear));\n\tbvec3 negCutoff = lessThanEqual(color, vec3(-trc.cutoffToLinear));\n\tvec3 higher = pow((color + trc.off)/(1.0 + trc.off), vec3(trc.power));\n\tvec3 lower = color/trc.slope;\n\tvec3 neg = -pow((color - trc.off)/(-1.0 - trc.off), vec3(trc.power));\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n}\n\n// Gamma-corrects RGB colors to be sent to a display\nvoid toGamma(inout vec3 color, const transfer trc)\n{\n\tbvec3 cutoff = lessThan(color, vec3(trc.cutoffToGamma));\n\tbvec3 negCutoff = lessThanEqual(color, vec3(-trc.cutoffToGamma));\n\tvec3 higher = (1.0 + trc.off)*pow(color, vec3(1.0/trc.power)) - trc.off;\n\tvec3 lower = color*trc.slope;\n\tvec3 neg = (-1.0 - trc.off)*pow(-color, vec3(1.0/trc.power)) + trc.off;\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n}\n\n\n/*\n * Utility Functions\n */\n\n// Distance from a line segment\nfloat segmentDistance(vec2 start, vec2 end, vec2 position)\n{\n\t// Ray representing the line segment\n\tvec2 ray = end - start;\n\n\t// Length of the ray squared (to avoid sqrt)\n\tfloat lenSq = dot(ray*ray, vec2(1));\n\n\t// Distance from the start of the segment, where a line going through it and\n\t// position will be perpendicular to the ray\n\tfloat perp = clamp(dot(position - start, ray)/lenSq, 0.0, 1.0);\n\n\t// Intersection of perpendicular line and the original line segment,\n\t// projecting position onto the line segment\n\tvec2 projected = start + perp*ray;\n\n\treturn distance(position, projected);\n}\n\n// Distance from a line segment\nfloat lineDistance(vec2 start, vec2 end, vec2 position)\n{\n\t// Ray representing the line\n\tvec2 ray = end - start;\n\n\t// Length of the ray squared (to avoid sqrt)\n\tfloat lenSq = dot(ray*ray, vec2(1));\n\n\t// Distance from the start of the line, where a line going through it and\n\t// position will be perpendicular to the ray\n\tfloat perp = dot(position - start, ray)/lenSq;\n\n\t// Intersection of perpendicular line and the original line, projecting\n\t// position onto the line\n\tvec2 projected = start + perp*ray;\n\n\treturn distance(position, projected);\n}\n\n\n/********************************************************\n * Settings - Change these to adjust the displayed line *\n ********************************************************/\n\n// Gamma map to use for blending\nconst transfer gamBl = gam10;\n\n// Gamma map to use for displaying\nconst transfer gamTo = gamSrgb;\n\n// Antialiasing sharpness, as inverse of the filter width (in pixels) Higher\n// values create sharper lines\nconst float sharp = 1.0;\n\n// Line thickness (in pixels)\nconst float thick = 1.0;\n\n// Zoom level (thickness of pixels)\nconst float zoom = 1.0;\n\n// Subpixel configuration, as the position of the blue subpixel relative to the\n// green subpixel. Default setting is for standard horizontal RGB subpixels\nconst vec2 subPos = vec2(1.0/3.0, 0);\n\n\n/**\n * Texture Settings\n */\n\n// Stepping distance multiplier for signed distance field\nconst float subStep = 255.0/4.0;\n\n// How much to scale the texture by\nconst float texScale = 1.0;\n\n\n// Main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 start = abs(iMouse.zw);\n\tvec2 end = iMouse.xy;\n\n\tstart = floor(start/zoom);\n\tend = floor(end/zoom);\n\tfragCoord = floor(fragCoord/zoom);\n\n\t// Handle both default case before interaction, and if user doesn't drag\n\tif (ivec2(start) == ivec2(end)) {\n\t\tfloat maxRes = max(iResolution.x, iResolution.y);\n\t\tstart -= maxRes;\n\t\tend += maxRes;\n\t}\n\n\tvec3 colorFg = vec3(0, 0, 0);\n\tvec3 colorBg = vec3(1, 1, 1);\n\n\t// Convert foreground and background colors into gamma used for blending\n\ttoLinear(colorFg, gamTo);\n\ttoGamma(colorFg, gamBl);\n\n\ttoLinear(colorBg, gamTo);\n\ttoGamma(colorBg, gamBl);\n\n\t// Find the distance to the line for each subpixel (new)\n\tfloat distR = lineDistance(start, end, fragCoord - subPos);\n\tfloat distG = lineDistance(start, end, fragCoord);\n\tfloat distB = lineDistance(start, end, fragCoord + subPos);/**/\n\n\t// Comment out the above, and uncomment this, to use a texture instead of a\n\t// line. It's recommended that if you use a font texture, you should also\n\t// set thickness to zero, and subStep to an appropriate for your texture\n\t/*vec2 texRes = vec2(textureSize(iChannel0, 0));\n\tvec2 uvScale = texRes*min(iResolution.x/texRes.x, iResolution.y/texRes.y)*texScale;\n\tvec2 uv = fragCoord/uvScale;\n\n\tfloat subScale = uvScale.x/texRes.x*subStep;\n\tfloat distR = (texture(iChannel0, uv - subPos/uvScale).a - 0.5)*subScale;\n\tfloat distG = (texture(iChannel0, uv).a - 0.5)*subScale;\n\tfloat distB = (texture(iChannel0, uv + subPos/uvScale).a - 0.5)*subScale;/**/\n\n\t// Find the distance to the line segment for each subpixel\n\t/*float distR = segmentDistance(start, end, fragCoord - subPos);\n\tfloat distG = segmentDistance(start, end, fragCoord);\n\tfloat distB = segmentDistance(start, end, fragCoord + subPos);/**/\n\n\t// Find the distance to the line for each subpixel (old)\n\t/*vec2 unit = normalize(end - start);\n\n\tvec2 toUvR = end - (fragCoord - subPos);\n\tfloat distR = length(toUvR - dot(toUvR, unit)*unit);\n\tvec2 toUvG = end - fragCoord;\n\tfloat distG = length(toUvG - dot(toUvG, unit)*unit);\n\tvec2 toUvB = end - (fragCoord + subPos);\n\tfloat distB = length(toUvB - dot(toUvB, unit)*unit);/**/\n\n\t// Subpixel distances\n\tvec3 subDist = ((thick - vec3(distR, distG, distB)*2.0)*sharp + 1.0)/2.0;\n\n\tvec3 color = mix(colorBg, colorFg, clamp(subDist, 0.0, 1.0));\n\n\t// If zoom level is divisible by 3, show subpixels in grayscale\n\tif (mod(zoom, 3.0) == 0.0) {\n\t\tfloat subSize = zoom/3.0;\n\n\t\tvec3 subpixel = floor(vec3(gl_FragCoord.x/subSize) - vec3(0, 1, 2));\n\t\tsubpixel = clamp(mod(subpixel, vec3(3)), 0.0, 1.0);\n\n\t\tcolor = mix(vec3(color.r), color, subpixel.r);\n\t\tcolor = mix(vec3(color.g), color, subpixel.g);\n\t\tcolor = mix(vec3(color.b), color, subpixel.b);\n\t}\n\n\t// Perform gamma conversion\n\ttoLinear(color, gamBl);\n\ttoGamma(color, gamTo);\n\n\tfragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}