{"ver":"0.1","info":{"id":"NtfyDS","date":"1648589420","viewed":25,"name":"BURGER TIME","username":"Aurore_B","description":"After a pizza, it's time for burger ! ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["miam"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Union(float d1, float d2){ return min(d1,d2); }\nfloat Sub(float d1, float d2){ return max(-d1,d2);}\n\nfloat SUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nvec2 opU2(vec2 d1, vec2 d2){\n    return (d1.x < d2.x) ? d1 : d2;\n}\nvec2 opS2(vec2 d1, vec2 d2){\n    return (-d1.x > d2.x) ? d1 : d2;\n}\n\nmat2 rot(float a){\n     float c = cos(a) , s = sin(a);\n     return mat2(c,-s, s, c);\n}\n\nvec3 palette( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nvec2 map(vec3 pos){\n    \n    float t = iTime; \n    \n    float fac1 = 7.;\n    float fac2 = 3.8;\n    float fac3 = 3.0;\n    float fac4 = 2.5;\n    float fac5 = 2.3;\n    //torus\n    //gestion de la rotation\n    pos.yz *= rot(3.14/2.);\n    \n    //rotation sur elle meme\n    pos.xz *= rot(3.14/1.9 + iTime*0.45);\n    \n    //------ pain\n    vec2 base = vec2(sdCappedCylinder(pos, 0.4,.05), 0.0);\n    vec2 c =  base;\n    \n    //------- steak\n    vec2 steak = vec2(sdCappedCylinder(pos + vec3(0.,0.1+max(sin(t*2.)/fac1,0.0),0.), 0.38,.036),1.0);\n    c = opU2(steak, c);\n    \n    //--- fromage\n    vec3 saveCoord = pos;\n    //pos.y += min(sin(pos.z*8.+2.)/10.,0.0002); \n    //pos.z += min(sin(saveCoord.z*8.+2.)/10.,0.0002); \n    \n    vec2 from = vec2(sdBox(pos + vec3(0.,0.15+max(sin(t*2.)/fac2,0.0),0.),vec3(0.36,0.012,0.326)),2.);\n    c = opU2(from, c);\n    \n    pos = saveCoord;  \n    \n    //------ salade\n    saveCoord = pos;\n    //wave sur la hauteur\n    pos.y += sin(pos.z*24.)/30.;\n    //wave side\n    pos.x += sin(saveCoord.z*10.)/18.;  \n    pos.z +=sin(saveCoord.x*13.)/20.;; \n    \n    vec2 salad = vec2(sdCappedCylinder(pos + vec3(0.,0.2+max(sin(t*2.)/fac3,0.0),0.), 0.4,.01),3.);\n    c = opU2(salad, c);\n    \n    pos = saveCoord; \n    \n    //------ tomatoes\n    saveCoord = pos;\n    //pos.x = pos.x*1.3;\n    \n    vec2 tom1 = vec2(sdTorus(pos + vec3(0.10,0.28+max(sin(t*2.)/fac4,0.0),0.2), vec2(0.15,.05)),4.0);\n    c = opU2(tom1, c);\n    \n    pos.yz *= rot(3.14/7.);\n    vec2 tom2 = vec2(sdTorus(pos + vec3(0.0,0.34+max(sin(t*2.)/fac4,0.0),0.04), vec2(0.15,.05)),4.0);\n    c = opU2(tom2, c);\n    \n    pos = saveCoord; \n    \n    //------- top bun\n    \n    saveCoord = pos;\n    \n    //vec2 topbun = vec2(sdSphere(pos + vec3(0.0,0.25,0.0), 0.42),0.);\n    //vec2 boolrect = vec2(sdBox(pos+vec3(0.0,-0.03,0.0), vec3(0.6,0.4,0.6)),0.);\n    //c = Union(boolrect,c);\n    \n    //vec2 boolRes = opS2(boolrect, topbun);\n    \n    float topbun = sdSphere(pos + vec3(0.0,0.25+max(sin(t*2.)/fac5,0.0),0.0), 0.42);\n    float boolrect = sdBox(pos+vec3(0.0,-0.03+max(sin(t*2.)/fac5,0.0),0.0), vec3(0.6,0.4,0.6));\n    float boolRes = Sub(boolrect, topbun);\n    \n    vec2 bun = vec2(boolRes, 0.0);\n\n    c = opU2(bun,c);\n    \n    pos = saveCoord; \n    \n    \n    return c;\n    \n}\n\nvec3 GetNormal(vec3 pos){\n    float v = map(pos).x;\n    vec2 e = vec2(.001,.0);\n    return normalize(vec3( map(pos+e.xyy).x, map(pos+e.yxy).x, map(pos+e.yyx).x) - v);\n}\n\n//ro = rayon origine et rd = rayon direction\nvec2 CastRay( vec3 ro, vec3 rd){\n    \n    float contact = .0;\n    \n    for(int i= 0; i < 64; i++){\n        \n        vec2 ray = map(ro+ rd * contact);\n        \n        if(ray.x<(0.00001*contact))\n        {\n            return vec2(contact, ray.y);\n        }\n        contact += ray.x;\n    }\n    \n    return vec2(-1.,0.);\n}\n\nvec3 render(vec3 ro, vec3 rd){\n    \n    vec2 contact = CastRay(ro, rd);\n    \n    vec3 nor = GetNormal(ro + rd * contact.x);\n    \n    \n    vec3 lightDir = vec3(-1.7,-2.8,-1.5);\n    \n    float lambert = dot(nor, lightDir);\n    \n    \n    \n    vec3 col = vec3(0.0);\n    \n    if (contact.x == -1.)\n    {\n        col = vec3(0.45,0.73,0.48);\n    }\n    else\n    {\n            \n        if (contact.y == 0.)\n        {\n            col = vec3(0.89,0.77,0.53);\n        }\n        else\n        {\n\n             if (contact.y == 1.)\n            {\n                col = vec3(0.30,0.22,0.09);\n            }\n            else\n            {\n                 if (contact.y == 2.)\n                {\n                    col = vec3(0.97,0.64,0.11);\n                }\n                else\n                {\n                     if (contact.y == 3.)\n                    {\n                        col = vec3(0.58,0.61,0.09);\n                    }\n                    else\n                    {\n                       if (contact.y == 4.)\n                        {\n                            col = vec3(0.81,0.06,0.02);\n                        }\n                        else\n                        {\n                            col = vec3(1.0,0.98,0.541);\n                        }\n                    }\n                }\n        \n            }\n           \n        }\n        \n    float toon = step(lambert,.2);\n    col *= (1.-toon)*.5+0.5;\n\n    }\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized and centred pixel coordinates (from 0 to 1)\n    vec2 uv =2.*fragCoord/iResolution.xy-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float t = iTime;\n    \n    //CAM PAS ANIM\n    vec3 cameraPos =  vec3(0.22,-2.5,.8);\n    //CAM ANIM\n    //vec3 cameraPos =  vec3(0.9*cos(t)-2.*sin(t),-0.9*sin(t)-2.*cos(t),2.);\n    //cameraPos.xz= cameraPos.xz* rot(3.14+t);\n    \n    \n    vec3 cameraTar = vec3(0.,1.8,0.);\n    \n    //ligne directive\n    vec3 forward = normalize(cameraTar - cameraPos);\n    \n    //cross = prend la perpendiculaire\n    vec3 right = normalize(cross(vec3(0.0,-1,0.0), forward));\n    vec3 up =  normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up + 2.*forward);\n    \n   \n    vec3 c = render(cameraPos, viewDir);\n\n    // Output to screen\n    fragColor = vec4(c,1.);\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}