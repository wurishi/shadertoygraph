{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// distance field ray caster\n// simon green 06/01/2011\n// alex dunn - lollipop\n// \n// based on Inigo Quilezles's:\n// https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n// \n// Google Android robot:\n// http://www.android.com/branding.html\n\nprecision mediump float;\n\n#define SKY_COLOR vec3(0.1,0.4,0.9)\n#define HORIZON_COLOR vec3(0.8, 0.8, 0.8)\n#define SUN_COLOR vec3(1.0,1.0,0.8)\n\n#define MIN_DISTANCE 0.01\n\n#define SKIP_PRIMITIVES 0\n\n#if SKIP_PRIMITIVES\n#define EARLY_OUT if(d<MIN_DISTANCE) return d;\n#else \n#define EARLY_OUT\n#endif\n\n// CSG operations\nfloat _union(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat intersect(float a, float b)\n{\n    return max(a, b);\n}\n\nfloat difference(float a, float b)\n{\n//    return max(a, -b);\n\treturn max(a, 0.0-b); // work around PowerVR bug\n}\n\n// primitive functions\n// these all return the distance to the surface from a given point\n\nfloat plane(vec3 p, vec3 planeN, vec3 planePos)\n{\n    return dot(p - planePos, planeN);\n}\n\nfloat box(vec3 p, vec3 abc )\n{\n    vec3 di=max(abs(p)-abc, 0.0);\n    return dot(di,di);\n    //return length(di);\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// capsule in Y axis\nfloat capsuleY(vec3 p, float r, float h)\n{\n    p.y -= clamp(p.y, 0.0, h);\n    return length(p) - r;\n}\n\n// given segment ab and point c, computes closest point d on ab\n// also returns t for the position of d, d(t) = a + t(b-a)\nvec3 closestPtPointSegment(vec3 c, vec3 a, vec3 b, out float t)\n{\n    vec3 ab = b - a;\n    // project c onto ab, computing parameterized position d(t) = a + t(b-a)\n    t = dot(c - a, ab) / dot(ab, ab);\n    // clamp to closest endpoint\n    t = clamp(t, 0.0, 1.0);\n    // compute projected position\n    return a + t * ab;\n}\n\n// generic capsule\nfloat capsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    float t;\n    vec3 c = closestPtPointSegment(p, a, b, t);\n    return length(c - p) - r;\n}\n\nfloat cylinderY(vec3 p, float r, float h)\n{\n     float d = length(vec2(p.x, p.z)) - r;\n     d = intersect(d, plane(p, vec3(0.0, 1.0, 0.0), vec3(0.0, h, 0.0)));\n     d = intersect(d, plane(p, vec3(0.0, -1.0, 0.0), vec3(0.0)));\n     return d;\n}\n\n// transforms\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = p.x;\n    r.y = ca*p.y - sa*p.z;\n    r.z = sa*p.y + ca*p.z;\n    return r;\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    \n    vec3 r;\n    r.x = ca*p.x + sa*p.z;\n    r.y = p.y;\n    r.z = -sa*p.x + ca*p.z;\n    return r;\n}\n\nfloat halfSphere(vec3 p, float r)\n{\n    return difference( \n               sphere(p, r),\n               plane(p, vec3(0.0, 1.0, 0.0), vec3(0.0)) );\n}\n\nfloat sceneInterp() \n{\n    const float speed=0.5;\n\n    return clamp(sin(iTime*speed)*1.75,-1.0,1.0) *0.5+0.5;\n}\n\nfloat droid(vec3 p)\n{\n    float d;\n\n    p.x = abs(p.x);  // mirror in X to reduce no. of primitives\n\n    vec3 hp = p;\n\n    // head\n    d = halfSphere(hp, 1.0);\n\n    EARLY_OUT\n\n    // eyes\n    d = _union(d, sphere(hp - vec3(0.3, 0.3, 0.9), 0.1));\n    \n    EARLY_OUT\n\n    // antenna\n    d = _union(d, capsule(hp, vec3(0.4, 0.7, 0.0), vec3(0.75, 1.2, 0.0), 0.05));\n\n    EARLY_OUT\n\n    // body\n    d = _union(d, capsuleY((p*vec3(1.0, 4.0, 1.0) - vec3(0.0, -4.6, 0.0)), 1.0, 4.0));\n\n    EARLY_OUT\n\n    // arm\n    d = _union(d, capsuleY(p - vec3(1.2, -0.9, 0.0), 0.2, 0.7));\n    \n    EARLY_OUT\n\n    // legs\n    d = _union(d, capsuleY(p - vec3(0.4, -1.8, 0.0), 0.2, 0.5));\n\n    return d;\n}\n\nfloat lollipop(vec3 p)\n{\n    float d = capsuleY(p - vec3(0.0, -2.0, 0.0), 0.02, 2.0);\n\n    EARLY_OUT\n\n    d = _union(d, cylinderY(vec3(p.x,-p.z,p.y) - vec3(0.0, -0.1, 0.0), 0.9, 0.2)); // hand rotate by 90 in X\n    \n    return d;\n}\n\n\n// distance to scene\nfloat scene(vec3 p)\n{\n    return mix(droid(p),lollipop(p),sceneInterp());\n}\n\n// calculate scene normal\nvec3 sceneNormal( in vec3 pos, in float d )\n{\n    float eps = 0.14;\n    vec3 n;\n#if 1\n    // central difference\n    n.x = scene( vec3(pos.x+eps, pos.y, pos.z) ) - scene( vec3(pos.x-eps, pos.y, pos.z) );\n    n.y = scene( vec3(pos.x, pos.y+eps, pos.z) ) - d;//scene( vec3(pos.x, pos.y-eps, pos.z) );\n    n.z = scene( vec3(pos.x, pos.y, pos.z+eps) ) - scene( vec3(pos.x, pos.y, pos.z-eps) );\n#else\n    // forward difference\n   // float d = scene( vec3(pos.x, pos.y, pos.z) );\n    n.x = scene( vec3(pos.x+eps, pos.y, pos.z) ) - d;\n    n.y = scene( vec3(pos.x, pos.y+eps, pos.z) ) - d;\n    n.z = scene( vec3(pos.x, pos.y, pos.z+eps) ) - d;\n#endif\n\n return normalize(dot(n,n) == 0.0 ? vec3(1.0) : n);\n}\n\n// ambient occlusion approximation\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const float delta = 0.5;\n    const float weight = 1.0;\n    const float d = 0.5 * delta; \n\n    float a = weight*(d - scene(p + n*d));    \n    \n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\n// lighting\nvec3 shade(vec3 pos, vec3 n, vec3 eyePos)\n{\n    const vec3 lightPos = vec3(5.0, 10.0, 5.0);\n\n    vec3 color1 = vec3(0.643, 0.776, 0.223);\n\n    vec3 p=pos;\n    float x=1.0-clamp(length(p),0.0,1.0);\n    float t=cos(sin(atan(p.y,p.x)*3.0+9.0*x+iTime*2.0)*2.0)*x;\n    float m=clamp(t,0.0,1.0);\n\n    vec3 color2 = mix(mix(vec3(1.0),vec3(1.0,0.6,0.9),clamp(x*10.0,0.0,1.0)), vec3(1.0,0.0,0.0), m+(x*x*x));\n\n    vec3 color=mix(color1,color2,sceneInterp());\n\n    vec3 specColor = mix(HORIZON_COLOR, SKY_COLOR,n.y*0.5+0.5);\n    const float shininess = 30.0;\n\n    vec3 l = normalize(lightPos - pos);\n    vec3 v = normalize(eyePos - pos);\n    vec3 h = normalize(v + l);\n    \n    float diff = dot(n, l);\n    float spec = dot(h, n);\n\n    vec2 light = max(vec2(0.0), vec2(diff, spec));\n    light = pow(light, vec2(1.0,shininess));\n    \n    \n    diff = light.x;\n    spec = light.y;\n    diff = 0.5+0.5*diff;\n\n    float fresnel = pow(1.0 -dot(n, v), 3.0);\n    float ao = ambientOcclusion(pos, n);\n\n    //return vec3(diff) * color + vec3(spec + fresnel*0.5);\n    return diff*ao*SUN_COLOR * color + vec3(spec+fresnel) * specColor * 0.5;\n   // return vec3(ao);\n   // return vec3(fresnel);\n   // return vec3(diff);\n   //return vec3(spec*specColor);\n}\n\n// trace ray using sphere tracing\nvec3 trace(vec3 ro, vec3 rd, out bool hit, out float d)\n{\n    const int maxSteps = 32;\n    hit = false;\n    vec3 pos = ro + rd;\n\n    for(int i=maxSteps; i >= 0; --i)\n    {\n        d = scene(pos);\n\n        hit = d<MIN_DISTANCE;\n        if(hit) break;\n\t\t\n        pos += d*rd;\n    }\n    return pos;\n}\n\nvec3 background(vec3 rd)\n{\n     return mix(HORIZON_COLOR, SKY_COLOR, rd.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float maxRes = max(iResolution.x, iResolution.y);\n\tvec2 uv = (fragCoord.xy / maxRes) * vec2(2.0) - vec2(1.0);\n\t\n    // compute ray origin and direction\n    vec3 rd = normalize(vec3(uv.x, uv.y, -2.0));\n    vec3 ro = vec3(0.0, 1.0, 7.5);\n\n   \t// move camera\n    float a;\n    a = iTime*0.5;\n    rd = rotateY(rd, a);\n    ro = rotateY(ro, a);\n\n    // trace ray\n    bool hit;\nfloat d;\n    vec3 pos = trace(ro, rd, hit, d);\n\n    vec3 rgb;\n    if(hit)\n    {\n        // calc normal\n        vec3 n = sceneNormal(pos, d);\n        // shade\n        rgb = shade(pos, n, ro);\n\n#if 0\n        // reflection\n        vec3 v = normalize(ro - pos);\n        float fresnel = 0.1 + 0.4*pow(1.0 - dot(n, v), 5.0);\n\n        ro = pos + n*0.01; // offset to avoid self-intersection\n        rd = reflect(-v, n);\n        pos = trace(ro, rd, hit);\n\n        if (hit) {\n            vec3 n = sceneNormal(pos);\n            rgb += shade(pos, n, ro) * vec3(fresnel);\n        } else {no\n            rgb += background(rd) * vec3(fresnel);\n        }\n#endif \n\n     } else {\n        rgb = background(rd);\n     }\n\n    // vignetting\n   // rgb *= 0.5+0.5*smoothstep(2.0, 0.5, dot(pixel, pixel));\n\n    fragColor=vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lll3R4","date":"1419384447","viewed":231,"name":"Android 5.0","username":"smb02dunnal","description":"A tribute to android lollipop, modification of Simon Greens original android shader.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["android","lollipop","50"],"hasliked":0,"parentid":"","parentname":""}}