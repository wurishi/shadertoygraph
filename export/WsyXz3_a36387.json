{"ver":"0.1","info":{"id":"WsyXz3","date":"1623252907","viewed":132,"name":"Devil Square","username":"104","description":"Modulating a sine wave field with a signed distance field","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// as usual, signed distance funcs credit iq\n\nconst float waveHeight = .2;\nconst float waveAmp = .1;\nconst float waveAmpOffset = .01;\n\nmat2 rot2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n// signed distance to a n-star polygon with external angle en\nfloat sdStar(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\nfloat sdShape(vec2 uv) {\n    uv *= rot2D(-iTime*.4);\n    return sdStar(uv, 1.6, 4, 2.4);\n}\n\n// https://www.shadertoy.com/view/3t23WG\n// Distance to y(x) = a + b*cos(cx+d)\nfloat udCos( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n    \n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<7; i++ ) // bisection, 7 bits more or less\n    {\n        float x = 0.5*(xa+xb);\n        float si = sin(x);\n        float co = cos(x);\n        float y = x-p.x+b*c*si*(p.y-b*c*co);\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n    for( int i=0; i<4; i++ ) // newtown-raphson, 28 bits more or less\n    {\n        float si = sin(x);\n        float co = cos(x);\n        float  f = x - p.x + b*c*(p.y*si - b*c*si*co);\n        float df = 1.0     + b*c*(p.y*co - b*c*(2.0*co*co-1.0));\n        x = x - f/df;\n    }\n    \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n\nvec3 dtoa(float d, in vec3 amount){\n    return 1. / clamp(d*amount, amount/amount, amount);\n}\n\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nvoid mainImage( out vec4 o, vec2 C)\n{\n    vec2 R = iResolution.xy;\n    vec2 N2 = C/R;\n    vec2 N = C/R-.5;\n    vec2 uv = N;\n    uv.x *= R.x/R.y;\n    float t = iTime  *.1;\n    \n    uv *= 2.;\n\n    float a2 = 1e5;\n    vec2 uvsq = uv;\n    float a = sdShape(uvsq);\n    vec2 uv2 = uv;\n\n    uv.y = mod(uv.y, waveHeight) - waveHeight*.5;\n    \n    for (float i = -3.; i <= 3.; ++ i) {\n    \tvec2 uvwave = vec2(uv2.x, uv.y + i * waveHeight);\n        float b = (smoothstep(1., -1.,a)*waveAmp)+ waveAmpOffset;\n        float c = 15.;\n    \ta2 = min(a2, udCos(uvwave, 0., b, c, t));// a + b*cos(cx+d)\n    }\n    \n\tvec3 tint = vec3(1.5,.6,.45);\n    o.rgb = dtoa(pow(mix(a2, a, .2), 2.), 200.*tint);\n    o = 1.-o;\n    o *= 1.-dot(N,N);\n}\n\n\n\n\n","name":"Image","description":"","type":"image"}]}