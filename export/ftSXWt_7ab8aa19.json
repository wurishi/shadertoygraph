{"ver":"0.1","info":{"id":"ftSXWt","date":"1628814289","viewed":174,"name":"Chromatic Aberration Particles","username":"playmobil","description":"A simulation of attraction fields  between particles, coloring their halo under the aesthetics of a chromatic aberration from lenses and prisms.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["metaballs","particles","balls","chromatic","aberration","rainbow","attraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Chromatic Aberration Particles - By Sandro Benigno - Aug 2021\n\n#define objs_num 4\nvec2[objs_num] objs;\n\n//Random functions\nvec2 random2(vec2 p) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//A special kind of clamping\nfloat range(float val,float minim, float maxim){\n  if(val < minim){\n    val = 0.0;\n  }\n  else if(val > maxim){\n    val = 1.0; \n  }\n  return val;\n}\n\n//Polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n//Generating fluid metaballs aspect\n//by using polynomial smoothing as an attraction field\n\nvec4 fluid2(vec2 px, float rad)\n{\n  \n  //shapping\n  \n  //Calc distance from objs\n  float dist[objs_num];\n  for(int i=0; i<objs_num; i++){\n    dist[i] = distance(px,objs[i]);\n  }\n  \n  //Coloring\n  float c = 0.0;\n  float flu = 0.0;\n  float mag = float(objs_num);\n\n  //Coloring the objs from distance and rad\n  for(int i=0; i<objs_num; i++){\n    c += smoothstep(rad+0.02,rad-0.02,dist[i]);\n  } \n  \n  //Calc polynomial smooth combs\n  float flutmp,flux;\n  for(int i=0; i<objs_num; i++){\n    for(int j=0; j<objs_num; j++){\n      if(i < objs_num){\n        if(i < j){\n          //Only combine above local index\n          //It also skips the last one because there is no one above\n          flutmp = smin(dist[i],dist[j],mag*rad);\n          flux = flux + flutmp * (1.0/float(objs_num)); //Summing the normalized poly-smooth-min\n          flu = flu + smoothstep(rad+0.02,rad-0.02,flutmp);// * (1.0/objs_num); //Summing the normalized poly-smooth-min\n          flu = clamp(flu,0.0,1.0);\n        }\n      }\n    }\n  } \n  \n  \n  float mx = flu + c;\n  return vec4(c,flux,flu,mx);\n}\n\n//HSB to RGB\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,0.0,1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n//Color mapping from customized Polar YUV values\nvec4 cmap(float hue, float shf){\n  float pi = 3.141592;\n  float lum = hue; \n  hue = abs(hue - (1.0 + shf));//Loop aroud clock shift\n  \n  vec3 spectrum = vec3(0.0);\n  spectrum = hsb2rgb(vec3(hue,1.0,lum));\n  \n  return vec4(spectrum,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  //Base vars \n  vec2 uv = fragCoord/iResolution.xy;\n  float ratio = iResolution.x / iResolution.y;\n  uv = uv * 2.0 - 1.0;\n  uv.x *= ratio;\n  \n  uv /= 1.1;\n  \n  float pi = 3.141592;\n  \n  float tmp = iTime/5.0;\n  //tmp = 0.0;\n  \n  vec2 translate = vec2(cos(tmp),sin(tmp));\n  uv += translate*0.1;\n  \n  \n  //Objects\n  objs[0] = vec2(0.5*sin(tmp*pi),0.5*cos(tmp*pi*2.0));\n  objs[1] = vec2(0.5*cos(tmp*pi),0.5*sin(tmp*pi*2.0));\n  objs[2] = vec2(0.5*cos(tmp),0.7*sin(tmp*1.5));\n  objs[3] = vec2(0.35*cos(tmp*pi),0.75*sin(tmp*pi*1.2));\n  \n  \n  //Coloring by adding some chromatic offsets\n  vec4 mba = fluid2(uv,0.1);\n  vec4 mbb = fluid2(uv,0.12);\n  vec4 mbc = fluid2(uv,0.07);\n  \n  \n  fragColor = cmap(mbc.x,tmp);// * 0.75;\n  fragColor += cmap(mbb.z,tmp) * 0.75;\n  fragColor += cmap(1.0-mbb.y,0.2) * 0.3;\n  fragColor.gb *= (1.0-mbb.y);\n  fragColor += cmap(mbc.x,1.0);\n\n}","name":"Image","description":"","type":"image"}]}