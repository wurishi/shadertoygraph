{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"\nfloat inter (in float a,in float b,in float x){\n    return (1.-x)*a+x*b;\n}\nfloat rng (in vec2 pos){\n    return fract(sin(dot(pos-floor(pos/400.),vec2(12.9898,78.233)))*43758.5453123)*2.-0.5;\n}\n//RGB\nvec3 An = vec3(1.,0.,0.);\nvec3 Bn = vec3(0.,1.,0.);\nvec3 Cn = vec3(0.,0.,1.);\n\nconst mat2 skew = mat2 (\n    1.,0.,\n    1./tan(3.14/3.),1./sin(3.14/3.)\n);\n                            //0           1           2           3\nvec2 NorP[4] = vec2[4](vec2(0.,0.),vec2(0.,1.),vec2(1.,1.),vec2(1.,0.));\n\n//DEBUG, see the interpolation\nconst bool DEBUG = false;\n\nvec3 Ac = vec3(1.,0.,0.);\nvec3 Bc = vec3(0.,1.,0.);\nvec3 Cc = vec3(0.,0.,1.);\n\nvec3  interpolateSimplex (in vec2 p,in float t){\n    vec2 a = NorP[0]; //0,0\n    vec2 b;\n    vec2 c;\n    if (t==1.){ //checking if its a up or down simplex\n        b=NorP[1];\n        c=NorP[2];\n    }else{\n        b=NorP[3];\n        c=NorP[2];\n    }\n    a+=floor(p);\n    b+=floor(p);\n    c+=floor(p);\n    \n    float A = ((b.y-c.y)*(p.x-c.x)+(c.x-b.x)*(p.y-c.y))/((b.y-c.y)*(a.x-c.x)+(c.x-b.x)*(a.y-c.y));\n    float B = ((c.y-a.y)*(p.x-c.x)+(a.x-c.x)*(p.y-c.y))/((b.y-c.y)*(a.x-c.x)+(c.x-b.x)*(a.y-c.y));\n    float C = 1.-A-B;\n    \n    //bisentric interpolation? ^^^\n    //vec2 lp = fract(p);\n    /*vec2 hold = a-p;\n    float A = sqrt(hold.x*hold.x+hold.y*hold.y);\n    hold = b-p;\n    float B = sqrt(hold.x*hold.x+hold.y*hold.y);\n    hold = c-p;\n    float C = sqrt(hold.x*hold.x+hold.y*hold.y);\n    A=-A+1.;\n    B=-B+1.;\n    C=-C+1.;\n    A=clamp(A,0.,1.);\n    B=clamp(B,0.,1.);\n    C=clamp(C,0.,1.);*/\n    if (DEBUG==false){\n        return vec3((A*rng(a))+(B*rng(b))+(C*rng(c)));\n        /*if (A>B && A>C){\n            return vec3(A*rng(a)*Ac);\n        }else if (B>A && B>C){\n            return vec3(B*rng(b)*Bc);\n        }else if (C>B && C>A){\n            return vec3(C*rng(c)*Cc);\n        }*/\n    }else{\n        return ((A*Ac)+(B*Bc)+(C*Cc));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*for(int i=0;i<=4;i++){\n        NorP[i]=skew*NorP[i];\n    }*/\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv*=16.;\n    uv+=iTime;\n    uv.x*=iResolution.x/iResolution.y;\n    /*positions are streched along the x axis here, we need to\n      un-stretch it.\n    */\n    uv=skew*uv; //shifting the y axis over, to create equaladeral triangles\n    vec2 fp = fract(uv); //fract\n    vec3 col = interpolateSimplex(uv,step(fp.x,fp.y));\n    //vec3 col = vec3(rng(uv));\n    //if (step(uv.x,uv.y)==0.){col*=1.5;}\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XcGBRm","date":"1733876999","viewed":39,"name":"Simplex random test","username":"FF_stu","description":"testing of a random simplex","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["simplex"],"hasliked":0,"parentid":"XfGBRW","parentname":"Simplex Interpolation, example"}}