{"ver":"0.1","info":{"id":"ltSXDm","date":"1444144262","viewed":1310,"name":"Aerogel","username":"bit2shift","description":"Raymarching a translucent volume.\nI'm trying to figure out the best way to render a voxel world.\n\nImplements \"A Fast Voxel Traversal Algorithm for Ray Tracing\" by J. Amanatides and A. Woo\n[url]http://www.cse.yorku.ca/~amana/research/grid.pdf[/url]","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["3d","raymarching","voxel","dda"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Revision s\n * - flipped comparison and removed fog in voxel_color() for a more cousy terrain\n *\n * Revision r\n * - movement via Buffer A (mouse, arrow keys, control and shift)\n *\n * Revision q\n * - finally fixed the line glitch for odd resolutions\n *\n * Revision p\n * - prettier volume terrain\n *\n * Revision o\n * - using the new volume textures\n * - removed dithering\n *\n * Revision n\n * - ordered dithering (for testing purposes)\n *\n * Revision m\n * - fixed \"red\" glitch\n *\n * Revision l\n * - disable loop unrolling (maybe?)\n *\n * Revision k\n * - opaque voxels\n *\n * Revision j\n * - it's a cave!\n *\n * Revision i\n * - tweaked initialisation part\n *\n * Revision h\n * - radial blur?\n *\n * Revision g\n * - prettier terrain\n *\n * Revision f\n * - show noise texture as terrain\n *\n * Revision e\n * - optimized tMax calculation and loop iteration\n *\n * Revision d\n * - implemented \"A Fast Voxel Traversal Algorithm for Ray Tracing\" by J. Amanatides and A. Woo\n *   > http://www.cse.yorku.ca/~amana/research/grid.pdf\n *\n * Revision c\n * - dual approach rendering\n *   > forward-n-backward raymarching to find the ray-cube intersection points\n *   > march ray between intersections with appropriate step\n *\n * Revision b\n * - tweaked raymarching code\n *\n * Revision a\n * - removed unused code\n */\n\nconst int STEPS = 256;\nconst float GRID = 16.0;\nconst float EPSY = 0.001;\n\nvec4 voxel_color(vec3 p)\n{\n    vec3 v = (p / (GRID * GRID));\n    vec4 c = texture(iChannel0, v).r * texture(iChannel1, v);\n    return (length(c) < 0.666) ? c : vec4(0);\n}\n\nvec4 trace(vec3 origin, vec3 direction)\n{\n    origin *= GRID;\n    \n    vec3 point = floor(origin);\n    vec3 steps = sign(direction);\n    vec3 tDelta = 1.0 / max(abs(direction), EPSY);\n    vec3 tMax = (1.0 - fract(origin * steps)) * tDelta;\n    vec4 color = vec4(vec3(0), 1);\n    \n    #pragma optionNV (unroll 1)\n    for(int i = 0; i < STEPS; i++)\n    {\n        // front-to-back blending\n        vec4 c = voxel_color(point);\n        color.rgb += (color.a * c.a * c.rgb);\n        color.a   *= (1.0 - c.a);\n        \n        if(color.a <= EPSY)\n            break;\n        \n        // branchless iteration\n        bvec3 a = lessThan(tMax, tMax.yzx);\n        bvec3 b = lessThanEqual(tMax, tMax.zxy);\n        vec3 select = vec3(a) * vec3(b);\n        \n        point += select * steps;\n        tMax += select * tDelta;\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 packed = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    vec2 angle = unpackHalf2x16(floatBitsToUint(packed.w));\n    vec3 direction = vec3(vec2(sin(angle.x)), cos(angle.x)) * vec3(cos(angle.y), sin(angle.y), 1);\n    fragColor = trace(packed.xyz, direction);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float FOV = 120.0;\nconst float VIEW_SPEED = 90.0;\nconst float WALK_SPEED = 0.01;\n\nconst ivec2 KEY_SHIFT   = ivec2(16, 0);\nconst ivec2 KEY_CONTROL = ivec2(17, 0);\nconst ivec2 KEY_LEFT    = ivec2(37, 0);\nconst ivec2 KEY_UP      = ivec2(38, 0);\nconst ivec2 KEY_RIGHT   = ivec2(39, 0);\nconst ivec2 KEY_DOWN    = ivec2(40, 0);\n\nmat3 rotX(float angle)\n{\n    float cs = cos(radians(angle));\n    float sn = sin(radians(angle));\n    \n    vec3 c0 = vec3(1,   0,  0);\n    vec3 c1 = vec3(0,  cs, sn);\n    vec3 c2 = vec3(0, -sn, cs);\n    return mat3(c0, c1, c2);\n}\n\nmat3 rotY(float angle)\n{\n    float cs = cos(radians(angle));\n    float sn = sin(radians(angle));\n    \n    vec3 c0 = vec3(cs, 0, -sn);\n    vec3 c1 = vec3( 0, 1,   0);\n    vec3 c2 = vec3(sn, 0,  cs);\n    return mat3(c0, c1, c2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = ((2.0 * fragCoord) - iResolution.xy) / min(iResolution.x, iResolution.y) * tan(radians(FOV) / 2.0);\n    vec2 ms = ((2.0 * iMouse.xy) - iResolution.xy) / min(iResolution.x, iResolution.y) * VIEW_SPEED;\n    \n    mat3 rot = rotY(ms.x) * rotX(-ms.y);\n    vec3 uvw = rot * normalize(vec3(uv, 1));\n    \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    fragColor.xyz += rot[0] * WALK_SPEED * (texelFetch(iChannel1, KEY_RIGHT, 0).x - texelFetch(iChannel1, KEY_LEFT,    0).x);\n    fragColor.xyz += rot[1] * WALK_SPEED * (texelFetch(iChannel1, KEY_SHIFT, 0).x - texelFetch(iChannel1, KEY_CONTROL, 0).x);\n    fragColor.xyz += rot[2] * WALK_SPEED * (texelFetch(iChannel1, KEY_UP,    0).x - texelFetch(iChannel1, KEY_DOWN,    0).x);\n    \n    fragColor.w = uintBitsToFloat(packHalf2x16(vec2(acos(uvw.z), atan(uvw.y, uvw.x))));\n}\n","name":"Buffer A","description":"","type":"buffer"}]}