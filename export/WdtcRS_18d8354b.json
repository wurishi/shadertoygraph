{"ver":"0.1","info":{"id":"WdtcRS","date":"1601164265","viewed":235,"name":"rotation problem...solved! ","username":"danhel95","description":" collision with rotation upon impact, solved in a hacky way ::)\n ","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["collision","tutorial","physics","state"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// learning tutorial 12 \n// collision with rotation upon impact\n\n\n#define ZERO min(iFrame,0)\n\n\nvoid load_obj(int i) {\n    vec4 pos = texelFetch(iChannel0, ivec2(i,POS), 0);\n    vec4 opos = texelFetch(iChannel0, ivec2(i,OPOS), 0);\n    vec4 ang = texelFetch(iChannel0, ivec2(i,AN), 0);\n    vec4 axis = texelFetch(iChannel0, ivec2(i,AX), 0);\n\n    rbody rb = obs[i].rb;\n    rb.pos = pos.xyz;\n    rb.opos = opos.xyz;\n    rb.axis = axis.xyz;\n    rb.ang = ang.xyz;\n    obs[i].rb  = rb ;\n }\n\nvoid rbodies(  vec3 p , int idx ) {\n\n    obj o = obs[idx] ;\n    if (idx == 0)\n        o.d = box(p, o.rb.pos , o.rb.dim);\n    else if (idx == 1)\n        o.d = torus(p,  o.rb.pos , o.rb.dim.xy);\n    else if (idx == 2)\n        o.d = sphere(p,  o.rb.pos , o.rb.dim.x);\n    \n    obs[idx] = o;\n\n}\nvoid update( vec3 p , int i) {\n\n        load_obj(i);\n        rbody r = obs[i].rb ;\n    \tp -= r.pos;\n        p =   R3( p , r.axis , r.ang.x);\n        p += r.pos;        \n        rbodies(p,i);\n    \t\n}\n\n\n\nobj scene(vec3 p) {\n\n\n    float dp = box(p ,vec3(0.) , vec3(5.,.1,5.) )  ;\n    \n    for(int i = 0; i < NP; i++) {\n        update(p,i);\n   }\n\t\n\n    obj bx1 = obs[0];\n    obj bx2 = obs[1];\n    obj sph = obs[2];\n    pln.d = dp;\n\n    obj r = uop(bx1,bx2);\n    r = uop(r,sph);\n    r = uop(r,pln);\n\n    return r;\n\n\n}\n\n\nvec3 grad(vec3 p) {\n\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*scene(p+0.0005*e).d;\n      if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n}\n\n\n\n\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    const float maxHei = 2.;\n    float tp = (maxHei-ro.y)/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<8; i++ )\n    {\n\t\tfloat h = scene( ro + rd*t ).d;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.1, 1.0 );\n}\n\n\nobj march(in vec3 ro, in vec3 rd)\n{\n\n    float t = 0.; obj s; vec3 p;\n    for (float i = 0.; i < 1. && t <= FAR; i+=1./ITR)\n    {\n        p = ro + rd * t;\n        s = scene(p);\n        if (abs(s.d) <= SURF)break;\n        s.id > 3. ?  t += abs(s.d) : t += s.d ;\n    }\n\n    s.d = t;\n    return s;\n}\n\n\n\nvoid let_be_light(vec3 p, vec3 rd, vec3 normal,star l, inout obj ob) {\n\n\n    vec3 lp = normalize(l.pos-p);\n    float Kd = clamp( dot( normal, lp ), .1, 1. );\n    vec3  s = normalize( lp-rd );\n    //vec3  s = normalize( reflect(-rd,normal) );\n    float Ks = pow(dot( normal, s ), ob.mtr.shiness);\n\n    Kd *= shadow(p, lp, .1, 3.);\n\n    vec3 dif =  ob.mtr.col * Kd * l.col* ob.mtr.diffuse;\n    vec3 spec = ob.mtr.col * Ks * l.col*  ob.mtr.specular;\n    vec3 ambi = ob.mtr.col *  ob.mtr.amb;\n\n    ob.mtr.col *= dif + spec + ambi ;\n\n\n}\n\n\n\n\nvec3 render(ray r) {\n\n    vec3 resCol = vec3(0);\n    vec3 p = r.o;\n    float alpha = 1.;\n    obj ob;\n    float radius = 2.  ,theta= iTime*.5;\n    vec3 spos = vec3(radius * cos(theta), 2.0 + sin(theta ) * .5, radius * sin(theta));\n    star blue = star(spos, vec3(.9,.6,.1), 1. );\n\n\n    for(float i = 0.; i < 1.; i += 1./REF) {\n        ob = march(p,r.d);\n        p +=  ob.d * r.d ;\n    \tnormal = grad(p);\n        let_be_light(p, r.d, normal,blue, ob);\n\n        ob.mtr.col *= pow(smoothstep(FAR, 10., 2.*ob.d), 2.);\n\n        resCol += ob.mtr.col * alpha  ;\n        alpha *= .1;\n        r.d = reflect(r.d, normal);\n\n       if(ob.id < 2.) break;\n\n        p += r.d * 1e-3;\n\n\n    }\n\treturn resCol;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 ms = iMouse.xy/iResolution.xy ;\n    vec3 color = vec3(.0);\n\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\n    ray r = raydir(uv,ms);\n    color = render(r);\n\n    //color = sqrt( color );\n\n\n    color = pow(color,vec3(0.75));\n    fragColor = vec4( color, 1.0);\n\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define EPSILON\t1e-3\n#define ITR 60.\n#define SURF 1e-2\n#define FAR 60.\n#define REF 2.\n#define pow(a,b) pow(abs(a),(b))\n#define NP 3\n#define POS  0\n#define OPOS 1\n#define AN 2\n#define AX 3\n\n\n\n\nstruct star{\n    vec3 pos;\n    vec3 col;\n    float rad;\n};\n\n\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n    vec3 t;\n    float zoom;\n};\n\nstruct rbody\n{\n    vec3 pos;\n    vec3 opos;\n    vec3 v;\n    vec3 acc;\n    vec2 m;\n    vec3 axis;\n    vec3 ang;\n    vec3 dim;\n};\n\nstruct material {\n    vec3 col;\n    float amb;\n    float diffuse;\n    float specular;\n    float shiness;\n    float transparency;\n\n};\n\nstruct obj\n{\n\n    float d;\n    float id;\n    material mtr;\n    rbody rb;\n\n};\n\nconst vec3 wcol = vec3(.059, .059, .855);\nvec3 normal;\nobj obs[3] = obj[3](\n    \n    obj(FAR , 2.,\n    material(vec3(.8,.8,.7),.5, 1., 3., 100.,.1),\n    rbody(vec3(0.,1.,0.),vec3(0.),vec3(0.),vec3(0.),vec2(2.,1.),vec3(.0),vec3(.0) ,vec3(.5))\n    ),\n \n    obj(FAR , 3.,\n    material(vec3(.6,.5,.1),.5, 1., 3., 100.,.1),\n    rbody(vec3(1.,2.,2.),vec3(0.),vec3(0.),vec3(0.),vec2(1.,.5),vec3(.0),vec3(.0) ,vec3(.5,.2,.5))\n    ) ,\n\n\tobj(FAR , 4.,\n    material(vec3(.8,.2,.2),.5, 1., 3., 100.,.1),\n    rbody(vec3(2.,3.,0.),vec3(0.),vec3(0.),vec3(0.),vec2(2.,1.),vec3(.0),vec3(.0) ,vec3(.5))\n    )\n\n);\n\n\nobj pln = obj(FAR , 1.,\n    material(wcol,.5, 1., 3., 100.,.1),\n    rbody(vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec2(1.,.5),vec3(.0),vec3(.0) ,vec3(3.,.1,3.)));\n\n\n\n\nmat2 R2(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 R3(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\n\nmat3 camera(ray r , float roll)\n{\n\tvec3 f = normalize(r.t-r.o);\n    vec3 up = vec3(sin(roll),cos(roll),0.);\n    vec3 u = normalize(cross(f,up));\n    vec3 v = normalize(cross(u,f));\n    return mat3(u,v,f);\n}\n\nvec3 cam_to_world(ray r , vec2 uv , float roll){\n    mat3 viewCam = camera(r, roll); // viewCam = mat(u,v,f)\n    vec3 o = vec3(uv,r.zoom);\n    vec3 rd =  viewCam * normalize(o); // basically rd = uv.x*u + uv.y*v +zoom*f\n    return normalize(rd) ;\n}\n\nray raydir(vec2 uv, vec2 m) {\n\n    float roll = 0.;\n    ray r ;\n    r.zoom = 1.;\n    r.o = vec3(0., 6., 10.);\n    r.t = vec3(.5);\n\n    // float ang = .3 * iTime;\n    r.o.zx *= R2( - m.x * TWO_PI );\n    r.o.xy *= R2( - m.y * PI/4. + .5);\n\n    r.d = cam_to_world(r,uv,roll);\n    return r;\n}\n\n\n\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat smax(float a,float b, float k)\n{\n    return -smin(-a,-b,k);\n}\n\n\nfloat torus( in vec3 p, vec3 pos, vec2 rad )\n{\n    p = p - pos ;\n    float d = length( vec2(length(p.xz)-rad.x,p.y) )-rad.y;\n\n    return d;\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat box(vec3 p,vec3 pos, vec3 b) {\n    vec3 d = abs(p-pos) - b;\n    float dd = length(max(d, 0.));\n    return  dd + min(max(d.x, max(d.y, d.z)), 0.) - .1 ;\n}\n\n\nfloat plane(vec3 p,vec3 p0, vec4 n) {\n  return dot(p-p0,n.xyz) + n.w;\n}\n\nfloat plane(vec3 p, vec4 n) {\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sphere(vec3 p, vec3 pos, float r)\n{\n    return length(p-pos) - r ;\n\n}\n\n\nobj uop(in obj a, in obj b)\n{\n    if(a.d < b.d) return a;\n    return b;\n\n    }\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define dt iTimeDelta*3.\n\n\nvec3 wind = vec3(.4,.1 ,.35 );\nvec3 gravity = vec3(.0, -.2 ,.0 );\nfloat bounce = .95;\nfloat friction = .8;\n\nobj load_obj(int i) {\n    vec4 pos = texelFetch(iChannel0, ivec2(i,POS), 0);\n    vec4 opos = texelFetch(iChannel0, ivec2(i,OPOS), 0);\n    vec4 ang = texelFetch(iChannel0, ivec2(i,AN), 0);\n    vec4 axis = texelFetch(iChannel0, ivec2(i,AX), 0);\n\n    obj o = obj(FAR , 1.,\n    material(vec3(0.),.5, 1., 3., 100.,.1),\n    rbody(vec3(0.),vec3(0.),vec3(0.),vec3(0.),vec2(1.,.5),vec3(.0),vec3(.0) ,vec3(.5)));\n\n\n    rbody rb = o.rb;\n    rb.pos = pos.xyz;\n    rb.opos = opos.xyz;\n    rb.axis = axis.xyz;\n    rb.ang = ang.xyz;\n    o.rb  = rb ;\n    return o ;\n }\n\n\nvoid correct_position(inout rbody rb, vec3 n,float depth){\n        rb.pos +=   n * abs(depth + .2) ;\n}\n\n\nvoid apply_force(inout rbody rb, vec3 force) {\n    vec3 gamma =  force * (1./rb.m.x);\n    rb.acc += gamma;\n}\n\nvoid applyTorque(inout rbody rb , vec3 P , vec3 impulse ){\n\n    vec3 torque = cross( P , impulse) ;\n    vec3 torque_axis = normalize(torque);\n    float torque_mag = length(torque);\n    rb.axis = torque_axis;\n    rb.ang.z +=   torque_mag/rb.m.y  ;\n}\n\nvoid applyImpulse(inout rbody rb , vec3 impulse){\n    rb.acc +=   impulse * 1./rb.m.x;\n}\n\nvoid apply_torque_and_impulse(inout rbody rb,vec3 P,vec3 impulse){\n    applyImpulse(rb, impulse);\n    applyTorque(rb, P,impulse);\n}\n\n\nvec3 impact_normal(inout rbody s, inout rbody rb){\n    vec3 n = (s.pos - rb.pos);\n    return normalize(n);\n}\n\nvec3 impact_point(inout rbody s, inout rbody rb){\n    float r1 = s.dim.x, r2 = rb.dim.x;\n    if (dot(s.pos,rb.pos) < length(rb.pos))\n        return s.pos + (r1 / (r1 + r2)) * (rb.pos - s.pos);\n    else\n        return rb.pos + (r2 / (r1 + r2)) * (s.pos - rb.pos);\n}\n\nvec3 impact_impulse(inout rbody s, inout rbody rb, vec3 pc, vec3 n){\n\n    float e = .7,\n        m1 = s.m.x,\n        m2 = rb.m.x,\n        si = s.m.y,\n        oi = rb.m.y;\n\n    float ism = 1./m1;\n    float iom = 1./m2;\n    vec3 vs = s.pos - s.opos;\n    vec3 vo = rb.pos - rb.opos;\n    vec3 rap = pc - s.pos;\n    vec3 rbp = pc - rb.pos;\n    float deno = ism + iom + length(cross(rap,n))/si + length(cross(rbp,n))/oi;\n    float numer = -(1.+e) * dot( vs - vo , n);\n    float j =  (deno == 0.) ? .001 : numer / deno;\n    return  n * j * 10. ;\n}\n\nvoid after_mate(inout rbody s, inout rbody rb,vec3 pc, vec3 n) {\n    vec3 f_impulse = impact_impulse(s, rb, pc, n);\n    apply_torque_and_impulse(rb, pc, f_impulse);\n    apply_torque_and_impulse(s, pc, -f_impulse);\n}\n\n\n\n\nvoid process_impact(inout rbody s, inout rbody rb){\n\n    float depth = s.dim.x + rb.dim.x - length(s.pos - rb.pos);\n    vec3 n = impact_normal(s, rb);\n    vec3 pc = impact_point(s, rb);\n    correct_position(s, n, depth);\n    after_mate(s, rb, pc, n);\n\n}\nvoid check_collision(inout rbody rb , inout rbody s){\n    if (length(rb.pos - s.pos) <= (rb.dim.x + s.dim.x) +.2){\n        process_impact(s, rb);\n    }\n}\n\n\nvoid check_borders(inout rbody rb) {\n\n    float r0 = rb.dim.x;\n    float up = 4.;\n    float   w = 4.8,\n            down= .2;\n\n    if  ( rb.pos.x + r0   > w )  {\n            rb.pos.x =   w -r0 ;\n            rb.opos.x *= -bounce ;\n\n    }\n\n    if  ( rb.pos.x - r0 < -w ){\n            rb.pos.x =   -w + r0 ;\n            rb.opos.x *= -bounce ;\n\n    }\n\n\n    if  ( rb.pos.y - r0 < down ){\n            rb.pos.y = down + r0  ;\n            rb.opos.y *= -bounce  ;\n\n    }\n\n    if  ( rb.pos.y + r0   > up )  {\n            rb.pos.y = up - r0 ;\n            rb.opos.y *= - bounce ;\n\n    }\n\n\n    if  ( rb.pos.z + r0   > w )  {\n            rb.pos.z =   w -r0 ;\n            rb.opos.z *= -bounce ;\n\n    }\n\n    if  ( rb.pos.z - r0 < -w ){\n            rb.pos.z =   -w + r0 ;\n            rb.opos.z *= -bounce ;\n\n    }\n\n\n\n}\n\n\nvoid rotate(inout rbody rb){\n    rb.ang.y = rb.ang.z * dt ;\n    rb.ang.x = rb.ang.y * exp(-.1 * dt) ;\n    rb.ang.z *= friction;\n\n}\nvoid translate(inout rbody rb){\n\n    //rb.opos *= exp(-.01 * dt) ;\n    rb.opos +=  rb.acc  * dt ;\n    rb.pos += rb.opos * friction * dt ;\n    rb.acc = vec3(0.);\n}\n\n\n\nvec3 update_an(rbody rb) {\n    return rb.ang;\n}\nvec3 update_ax( rbody rb) {\n    return rb.axis;\n}\n\nvec3 update_op(rbody rb) {\n    return rb.opos;\n}\n\nvec3 update_p( rbody rb) {\n    return rb.pos;\n}\n\n\nvoid animate(inout obj o, int idx) {\n    rbody rb = o.rb;\n    wind *= .25*sin(cos(.1*rb.pos.y) + .1*iTime*(.5 + (float(idx))));\n\n    apply_force(rb,gravity);\n    apply_force(rb,wind);\n    translate(rb);\n    rotate(rb);\n    for(int i = 0; i < NP; i++) {\n        obj so = load_obj(i);\n        rbody sr = so.rb ;\n        if (i != idx){\n\t      check_collision(sr,rb);\n        }\n        so.rb = sr;\n    }\n    \n    check_borders(rb);\n\n   o.rb = rb ;\n\n}\n\n\n\n\n\nvoid mainImage( out vec4 F, in vec2 U ) {\n\n    F = vec4(0.);\n    int index = int(U.x);\n    int row = int(U.y);\n    if(index > 2 || row > 3) {\n        discard;\n    }\n\n    if (iFrame < 10) {\n            if (row == POS)\n                F = vec4(obs[index].rb.pos,0.);\n            else if (row == OPOS)\n                F = vec4(obs[index].rb.opos,.0);\n            else if (row == AN)\n                F = vec4(obs[index].rb.ang,.0);\n            else if (row == AX)\n                F = vec4(obs[index].rb.axis,.0);\n        }\n    else{\n\n      obj this_ob = load_obj(index);\n      animate(this_ob,index);\n        if (row == POS) {\n            vec3 npos = update_p(this_ob.rb);\n            F = vec4(npos, .0);\n        } else if (row == OPOS) {\n                vec3 nOpos = update_op(this_ob.rb) ;\n                F = vec4(nOpos, 0.0);\n        } else if (row == AN) {\n            vec3 an = update_an(this_ob.rb) ;\n            F = vec4(an, 0.0);\n        } else if (row == AX) {\n            vec3 nax = update_ax(this_ob.rb) ;\n            F = vec4(nax, 0.0);\n        }else {\n            F = vec4(-1.0);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}