{"ver":"0.1","info":{"id":"WtS3Rm","date":"1558831961","viewed":217,"name":"Wavy Hills","username":"samwarren","description":"Mouse click to look left and right. :)","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["noise","raymarch","sky","rayleigh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Rayleigh Mie Skydome approximation based off Scratchapixel article and Nvidia GPU Gems.\n//Use mouse click to look left and right.\n\n#define PI 3.141592\n\n//-------------------------------------SKYDOME STUFF---------------------------------------------\n\n//Atmosphere parameters:\n//Constants that multiply the phase functions.\n#define rpv  0.0596831\n#define mpv  0.1193662\n//Mie phase function g constant.\n#define g 0.76\n//Earth radius and centre.\n#define earthRad 6320e3\n#define earthCen vec3(0,0,0)\n//Radius of atmosphere limit (space).\n#define atmosRad 6420e3\n//Sun intensity (biased slightly towards red wavelength).\n#define sunPow vec3(10,10, 10)\n//Scale height values for both scatter types.\n#define Hr 8e3\n#define Hm 12e2\n//Beta values at sea level (peak rgb intensities).\n#define Bs0Rayleigh vec3(58e-7, 135e-7, 250e-7)\n#define Bs0Mie vec3(210e-6)\n//Samples for numerical integration.\n#define samples 15\n#define sunSamples 6\n\n//Fractal noise paramters.\n#define FRACTAL_NOISE\n#define octaves 4\n#define WAVEY\n//Raymarch parameters.\n#define ep .02\n#define smallEp .0001\n#define maxIterations 120\n\n//Camera FOV constants.\n#define fov 1.05\n#define asp vec2(1.0, .5625)\n#define tanTheta tan(fov)\n#define tanTheta2 2.0*tanTheta\n#define tanThetaAspY asp.y*tanTheta\n#define tanTheta2AspY 2.0*tanThetaAspY\n\n//Camera parameters.\n#define skyCamO vec3(0, earthRad+1.0,0)\n#define camO vec3(0)\n#define fExposure 2.5\nconst float theta = 0.0;\nfloat phi = 0.0;\n\nvec3 sunDir = vec3(0,1,0);\n\nstruct Ray { vec3 o, d; };\n\nRay PinholeCamera(vec2 uv, in vec3 origin) {\n    float cosTheta = cos(theta);\n\tvec3 zH = vec3(cosTheta*sin(phi), sin(theta), cosTheta*cos(phi));\n    vec3 xH = cross(zH, vec3(0,1,0));\n    vec3 yH = cross(zH, xH);\n    vec3 p = xH*(uv.x*-tanTheta2+tanTheta) + yH*(uv.y*-tanTheta2AspY + tanThetaAspY) + zH;\n    return Ray(origin, normalize(p));\n}\n    \nbool SphereRayIntersect(Ray r, vec3 o, float rad, inout float t) {\n\tvec3 l = o - r.o;\n    float rl = dot(l, r.d);\n    float a2 = dot(l,l) - rl*rl;\n    float rad2 = rad*rad;\n    if(a2 > rad2) { return false; }\n\tt = sqrt(rad2 - a2) + rl;\n    return true;\n}\n\nfloat RayleighPhaseFunction(float cosTheta) {\n    return rpv*(1.0+cosTheta*cosTheta);\n}\n\nfloat MiePhaseFunction(float cosTheta) {\n\treturn mpv*( (1.0-g*g)*(1.0+cosTheta*cosTheta) ) / ( (2.0+g*g)*pow(1.0+g*g-2.0*g*cosTheta, 1.5) );\n}\n\n//Returns unfinished transmittance: the non exponent version for optimisation purposes.\nvoid Transmittance(vec3 Pa, vec3 Pb, inout vec3 tr, inout vec3 tm) {\n    vec3 d = Pb-Pa;\n    float dLen = length(d);\n    float ds = dLen / float(sunSamples);\n    d /= dLen;\n    float opticalDepthR = 0.0;\n    float opticalDepthM = 0.0;\n    float ms = 0.0;\n    for(int i = 1; i < sunSamples; i++) {\n        vec3 p = Pa + d*(ms + .5 * ds);\n        float h = length(p - earthCen) - earthRad;\n    \topticalDepthR += exp(-h/Hr)*ds;\n        opticalDepthM += exp(-h/Hm)*ds;\n        ms += ds;\n    }\n    tr = Bs0Rayleigh*opticalDepthR;\n    tm = Bs0Mie*opticalDepthM;\n}\n\nvec3 SkyColour(Ray r) {\n    float t;\n    if(SphereRayIntersect(r, earthCen, atmosRad, t)) {\n        vec3 Pa = r.o + r.d*t;\n        float ds = length(Pa-r.o) / float(samples);\n        \n        // T(Pc,X) * T(X, Ps) * Bs(h)ds between Pc and Pa:\n        vec3 integralR = vec3(0);\n        vec3 integralM = vec3(0);\n        float ms = 0.0;\n        for(int j = 1; j < samples; j++) {\n            vec3 X = r.o + r.d*(ms + .5 * ds);\n            \n            float ts;\n            SphereRayIntersect(Ray(X, sunDir), earthCen, atmosRad, ts);\n            vec3 Ps = X + sunDir*ts;\n            float h = length(X-earthCen) - earthRad;\n            \n            vec3 T1r, T1m, T2r, T2m;\n            Transmittance(r.o, X, T1r, T1m);\n            Transmittance(X, Ps, T2r, T2m);\n\n            //Optimisation here due to lots of exponents...\n            //For each integral: += T(Pc, X) * T(X, Os) * Bs(h)\n            //\t\t\t\t\t  = e^(-T1r-T2r -h/H)\n            integralR += exp(-(T1r+T2r) -h/Hr) * ds;\n            integralM += exp(-(T1m+T2m) -h/Hm) * ds;\n            ms += ds;\n        }\n        float mu = dot(r.d, sunDir);\n        integralR *= RayleighPhaseFunction(mu) * Bs0Rayleigh;\n        integralM *= MiePhaseFunction(mu) * Bs0Mie;\n        return sunPow * (integralR + integralM);\n    }\n    return vec3(1,0,1);\n}\n\n//-----------------------------NOISE SURFACE STUFF------------------------------\n\n#define invep 1.0 / ep\n#define invsmallEp 1.0 / smallEp\n\nfloat Hash1(in float n ) { return fract(sin(n)*43758.5453); }\n\nvec2 Hash(in vec2 p) { return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453); }\n\nfloat Lerp(in float a, in float b, in float r) { return a + (b-a)*r; }\n\nfloat Quintic(in float x) { return x*x*x*(x*(x*6.0 - 15.0) + 10.0); }\n\nfloat GradDot(in vec2 gd, in vec2 p) { return dot(gd-p, Hash(gd*.00018)*2.0-vec2(1.0)); }\n\nfloat Perlin(in vec2 p) {\n\tfloat ix0 = floor(p.x), ix1 = ix0+1.0;\n    float iy0 = floor(p.y), iy1 = iy0+1.0;\n    float sx = Quintic(p.x - ix0);\n    float v1 = Lerp(GradDot(vec2(ix0,iy0), p), GradDot(vec2(ix1,iy0), p), sx);\n    float v2 = Lerp(GradDot(vec2(ix0,iy1), p), GradDot(vec2(ix1,iy1), p), sx);\n    return Lerp(v1,v2, Quintic(p.y - iy0));\n}\n\nfloat FractalPerlin(in vec2 p) {\n    float o = 0.0;\n    float a  = .5;\n    for(int i = 1; i < octaves; i++) {\n        o += a * Perlin(p);\n        p *= 2.0;\n        a *= .5;\n    }\n    return o;\n}\n\nfloat D(in vec3 p) {\n    #ifdef WAVEY\n    p.xz += iTime*.25;\n    #endif\n    #ifdef FRACTAL_NOISE\n    return p.y - FractalPerlin(p.xz)+1.1;\n\t#else\n\treturn p.y - Perlin(p.xz)+1.1;\t\n    #endif\n}\n\nfloat DirectionalDerivative(in vec3 x, in vec3 l, in float dep) {\n\treturn clamp((D(x+l*dep) - D(x)) / dep, 0.0, 1.0);\n}\n\nbool SphereMarch(in Ray r, out float t, out float dep) {\n    int i = 0;\n    t = 0.0;\n    float d = ep+1.0;\n    dep = ep;\n    while(i < maxIterations && d > dep) {\n    \td = D(r.o+r.d*t);\n        t += d * .5;\n        i++;\n        dep = ep + t*t*3.5e-4;\n    }\n    if(i >= maxIterations) { return false; }\n    return true;\n}\n\nvoid ToneMap(inout vec4 c) {\n\tc.xyz = 1.0 - exp(-fExposure*c.xyz);\n}\n\n#define sr1 normalize(vec3(.5,.01,-1.0))\n#define sr2 normalize(vec3(.5,.01,1.0))\n#define sr4 normalize(vec3(.5,.01,0))\n#define sr5 normalize(vec3(-.5,.01,0))\n#define SURFACE_RAY(dir) Ray(vec3(0,earthRad,0), normalize(dir))\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    bool onBase = uv.y < .5;\n    \n    sunDir = normalize(vec3(0,abs(sin(iTime*.1+smallEp)),cos(iTime*.1+smallEp)));\n    phi = (iMouse.x / iResolution.x - .5) * PI;\n    \n    Ray r = PinholeCamera(uv, camO);\n    \n    float t, dep;\n    if(onBase && SphereMarch(r, t, dep)) {\n   \t\tvec3 p = r.o + r.d*t;\n        \n        float check = (fract(p.x)<.5 == fract(p.z)<.5) ? .95 : .1;\n        \n        vec3 s1 = DirectionalDerivative(p, sunDir, dep) * SkyColour(SURFACE_RAY(sunDir));\n        vec3 s2 = DirectionalDerivative(p, sr1, dep) * SkyColour(SURFACE_RAY(sr1));\n        vec3 s3 = DirectionalDerivative(p, sr2, dep) * SkyColour(SURFACE_RAY(sr2));\n        vec3 s5 = DirectionalDerivative(p, sr4, dep) * SkyColour(SURFACE_RAY(sr4));\n        vec3 s6 = DirectionalDerivative(p, sr5, dep) * SkyColour(SURFACE_RAY(sr5));\n        \n        fragColor.xyz = (s1+s2+s3+s5+s6) * check;\n        fragColor.xyz = mix(fragColor.xyz, SkyColour(SURFACE_RAY(r.d)), clamp(t*t*5e-4,0.0,1.0));\n    }\n    else {\n        r.o = skyCamO;\n  \t\tfragColor.xyz = SkyColour(r);\n    }\n    ToneMap(fragColor);\n}","name":"Image","description":"","type":"image"}]}