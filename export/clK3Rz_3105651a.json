{"ver":"0.1","info":{"id":"clK3Rz","date":"1687465142","viewed":41,"name":"Octet!","username":"dansh0","description":"Wanted to work out the octet unit cell structures. Cheers to HG_SDF link in code for help with domain repeating and mirroring. Use mouse to spin camera.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf","orthographic","beams","lattice","octet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 1000\n#define MAX_DIST 200.\n#define MIN_DIST 0.0001\n#define DOTS_PER_MM 10.\n#define NORM_EPS 0.001\n#define PI 3.141592\n#define PHI 1.618\n\n// PARAMS\nfloat scale = 20.; // Geo scale\nfloat cameraDist = 100.; // Camera distance from center\nvec3 objCol = vec3(1.0, 1.0, 1.0); // Base material color\nvec3 lightCol = vec3(1.0, 1.0, 1.0); // Light color\nvec3 lightPos = vec3(50.); // Light source position\nfloat ambiStrength = 0.6; // Ambient light strength\nfloat diffStength = 0.6; // Diffuse light strength\nfloat specStrength = 0.4; // Specular light strength\nfloat specPow = 4.0; // Specular light power (spread)\n\n// MATH TOOLS\n\n// Vector Component Max\nfloat vmax(vec3 vec) {\n\treturn max(max(vec.x, vec.y), vec.z);\n}\n\n// Smooth Max\nfloat smoothMax(float distA, float distB, float factor) {\n    return log(exp(factor * distA) + exp(factor * distB)) / factor;\n}\n\n// Smooth Min\nfloat smoothMin(float distA, float distB, float factor) {\n    return -smoothMax(-distA, -distB, factor);\n}\n\n// 3D repition from HG_SDF https://mercury.sexy/hg_sdf/\nvoid pMod3(inout vec3 p, vec3 size) {\n\tp = mod(p + size*0.5, size) - size*0.5;\n}\n\n\n// GEOMETRY\n\n// Box\nfloat distBox(vec3 point, vec3 center, float halfSideLen, float edgeRadius) {\n    float boxHeight = abs(sin(iTime*0.25)) * halfSideLen;\n    center.y = center.y - (halfSideLen - boxHeight);\n    vec3 transPoint = (point - center);\n    vec3 size = vec3(halfSideLen, abs(sin(iTime*0.25)) * halfSideLen, halfSideLen);\n    vec3 cheapDist = abs(transPoint) - (size - edgeRadius);\n    return length(max(cheapDist, vec3(0.))) + vmax(min(cheapDist, vec3(0.))) - edgeRadius;\n}\n\n// Beam\nfloat distBeam(vec3 point, vec3 normal, float radius) {\n    return length(point - dot(point, normal) * normal) - radius;\n}\n    \n// Sphere\nfloat distSphere(vec3 point, vec3 center, float radius) {\n    vec3 transPoint = (point - center);\n    return length(transPoint) - radius;\n}\n    \n    \n// GEOMETRY COMBINATIONS\n\n// Distance Function Combine\nfloat distCombine( vec3 position ) {\n    \n    // geometry\n    float box = distBox(position, vec3(0.), scale, 0.0);\n    \n    float spacing = scale;\n    float beamRadius = scale/10.0;\n    \n    vec3 positionShiftXZ = position + vec3(spacing/2.0, 0.0, spacing/2.0);\n    vec3 positionShiftXY = position + vec3(spacing/2.0, spacing/2.0, 0.0);\n    \n    pMod3( position, vec3(spacing));\n    position.x = abs(position.x);\n    position.y = abs(position.y);\n    position.z = abs(position.z);\n    if (position.y > position.x) { position.xy = position.yx; } \n    if (position.z > position.y) { position.yz = position.zy; } \n    \n    float beamPlanar = distBeam(position, normalize(vec3(1.0,1.0,0.0)), beamRadius); \n    \n    pMod3( positionShiftXZ, vec3(spacing));\n    positionShiftXZ.x = abs(positionShiftXZ.x);\n    positionShiftXZ.y = abs(positionShiftXZ.y);\n    positionShiftXZ.z = abs(positionShiftXZ.z);\n    if (positionShiftXZ.y > positionShiftXZ.x) { positionShiftXZ.xy = positionShiftXZ.yx; } \n    if (positionShiftXZ.z > positionShiftXZ.y) { positionShiftXZ.yz = positionShiftXZ.zy; } \n\n    float beamAngles = distBeam(positionShiftXZ, normalize(vec3(1.0,1.0,0.0)), beamRadius);\n    \n    \n    pMod3( positionShiftXY, vec3(spacing));\n    positionShiftXY = abs(positionShiftXY);\n    float beamSection = distBeam(positionShiftXY, normalize(vec3(1.0,0.0,1.0)), beamRadius);\n    \n    float beams = min(min(beamPlanar, beamAngles), beamSection);\n    \n    return max(box, beams);\n    \n}     \n\n    \n// RAY TOOLS\n    \n// Ray March\nfloat marcher(vec3 position, vec3 direction) {\n    float dist = 0.;\n    for (int iStep=0; iStep<MAX_STEPS; iStep++) {\n        float safeMarchDist = distCombine(position);\n        if (safeMarchDist > MIN_DIST && dist < MAX_DIST) {\n            position += safeMarchDist * direction;\n            dist += safeMarchDist;\n        } else {\n            return dist;\n        }\n    }\n    return 0.;\n}\n    \n// Normal Test\nvec3 marchNormal(vec3 position, vec3 direction) {\n    float xChange = marcher(position + vec3(NORM_EPS, 0, 0), direction) - marcher(position - vec3(NORM_EPS, 0, 0), direction);\n    float yChange = marcher(position + vec3(0, NORM_EPS, 0), direction) - marcher(position - vec3(0, NORM_EPS, 0), direction);\n    float zChange = marcher(position + vec3(0, 0, NORM_EPS), direction) - marcher(position - vec3(0, 0, NORM_EPS), direction);\n    return normalize( vec3(xChange, yChange, zChange) );\n}\n\n\n// CAMERA TOOLS\n\n// Orbit Controls\nvec3 orbitControls(float cameraDist, vec2 sphericalAngles) {\n    // spherical angles is x = theta -PI to PI and y = phi -PI/2 to PI/2\n    float xPos = cameraDist * cos(sphericalAngles.x) * sin(sphericalAngles.y);\n    float zPos = cameraDist * sin(sphericalAngles.x) * sin(sphericalAngles.y);\n    float yPos = cameraDist * cos(sphericalAngles.y);\n    return vec3(xPos, yPos, zPos);  \n}    \n\n\n// Camera Fragment Position (Orthographic)\nvec3 orthoFragPos(vec3 cameraPos, vec3 cameraDir, vec2 cameraSize, vec2 fragCoord) {\n    vec3 initialUp = vec3(0.0, 1.0, 0.0);\n    if (cameraDir.x == 0.0 && cameraDir.z == 0.0 && cameraDir.y != 0.0) {\n        initialUp = vec3(0.0, 0.0, 1.0);\n    }\n    vec2 offset = ((fragCoord / iResolution.xy) * cameraSize) - (cameraSize * 0.5);\n    vec3 rightChange = normalize(cross(cameraDir, initialUp));\n    vec3 upChange = normalize(cross(rightChange, cameraDir));\n    vec3 worldOffset = offset.x * rightChange + offset.y * upChange;\n    return cameraPos + worldOffset;\n}\n\n    \n// MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Background color default\n    vec3 col = vec3(0.0);\n    \n    // Init camera\n    vec2 cameraSize = iResolution.xy / DOTS_PER_MM;\n    \n    // Mouse effects on camera\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    vec2 mouseAngles = vec2(mouseUV.x * (2.* PI) + PI/4., mouseUV.y * PI + PI/4.);\n    vec3 cameraPos = orbitControls(cameraDist, mouseAngles);\n    vec3 cameraDir = normalize(-cameraPos);\n    vec3 fragPos = orthoFragPos(cameraPos, cameraDir, cameraSize, fragCoord);\n    \n    // Animated Light Source\n    vec2 lightSphericalPos = vec2(iTime*0.5, iTime*0.2);\n    lightPos = orbitControls(cameraDist, lightSphericalPos);\n    \n    // Ray March\n    float objDist = marcher(fragPos.xyz, cameraDir);\n    vec3 objPos = fragPos + cameraDir * objDist;\n    \n    if (objDist < MAX_DIST) {\n        // Find Normal\n        vec3 normal = marchNormal(fragPos.xyz, cameraDir);\n        objCol = 1.0-0.25*abs(normal);\n        \n        // Ambient Lighting\n        vec3 ambiLight = lightCol * ambiStrength;\n        \n        // Diffuse Lighting\n        vec3 diffDir = normalize(lightPos - objPos);\n        vec3 diffLight = lightCol * diffStength * max(dot(normal, diffDir), 0.0);\n        \n        // Specular Lighting\n        vec3 reflDir = reflect(-diffDir, normal);\n        float specFact = pow(max(dot(-cameraDir, reflDir), 0.0), specPow);\n        vec3 specLight = lightCol * specStrength * specFact;\n        \n        // Phong Combined Lighting\n        vec3 combLight = ambiLight + diffLight + specLight;\n        col = combLight * objCol;\n\n    } \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}