{"ver":"0.1","info":{"id":"dlSSDd","date":"1676786837","viewed":1670,"name":"Moominhouse","username":"ytt","description":"Moominhouse exterior and landscape","likes":70,"published":1,"flags":112,"usePreview":1,"tags":["reflection","outline","bridge","anime","moominhouse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4ljSWc","filepath":"https://soundcloud.com/ytt-888128007/moomin/s-wrlrQq7gdYl","previewfilepath":"https://soundcloud.com/ytt-888128007/moomin/s-wrlrQq7gdYl","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//                ____    ____                _  _   _  _   _   ____   _   _   ____  ____\n//     /\\  /\\    / __ \\  / __ \\    /\\  /\\    | || \\ | || | | | / __ \\ | | | | / ___||  __|\n//    /  \\/  \\  | |  | || |  | |  /  \\/  \\   | ||  \\| || |_| || |  | || | | || |__  | |__\n//   / /\\  /\\ \\ | |  | || |  | | / /\\  /\\ \\  | || \\ \\ ||  _  || |  | || | | | \\__ \\ |  __|\n//  / /  \\/  \\ \\| |__| || |__| |/ /  \\/  \\ \\ | || |\\  || | | || |__| || |_| | ___| || |__\n// /_/        \\_\\\\____/  \\____//_/        \\_\\|_||_| \\_||_| |_| \\____/  \\___/ |____/ |____|\n\n// *** Sorry about the long compilation time (can take up to 5 minutes on an old hardware) ***\n\n//\n// Quickstart:\n//\n// - Click to stop the auto rotation\n// - Move with W,A,S,D\n// - Change the resolution with +,-\n//\n\n//\n// Inputs:\n//\n// - Mouse drag - Swivel\n// - Ctrl + Mouse drag - Zoom\n// - Shift + Mouse drag - Pan\n// - Mouse click - Set pivot\n// - Mouse double click - Set pivot and center view (Inspect) / Teleport (Walk)\n//\n// - F1 - Toggle render mode (Compose, Steps, Normal, Depth, Shadow, Outline, Edge, UV)\n// - N - Toggle navigation mode (Inspect, Walk)\n// - W,A,S,D - Move horizontally\n// - E,C - Move vertically\n// - +,- - Change render resolution\n// - R - Reset view\n//\n\n// MIT License\n// - Empty scene template:\n//   https://www.shadertoy.com/view/mlsSRN\n\n// Image - Scale and text\n// Inputs: Buffer C, Font\n\n#define fontTexture(coord) texture(iChannel1, (coord) / vec2(1024.0))\n\nconst int[] text = int[](\n    73, 110, 115, 112, 101, 99, 116, -1, // 0 - \"Inspect\"\n    87, 97, 108, 107, -1, // 1 - \"Walk\"\n    67, 111, 109, 112, 111, 115, 101, -1, // 2 - \"Compose\"\n    83, 116, 101, 112, 115, -1, // 3 - \"Steps\"\n    78, 111, 114, 109, 97, 108, -1, // 4 - \"Normal\"\n    68, 101, 112, 116, 104, -1, // 5 - \"Depth\"\n    83, 104, 97, 100, 111, 119, -1, // 6 - \"Shadow\"\n    79, 117, 116, 108, 105, 110, 101, -1, // 7 - \"Outline\"\n    69, 100, 103, 101, -1, // 8 - \"Edge\"\n    85, 86, -1); // 9 - \"UV\"\n\n\nfloat characterTexture(vec2 pos, int index)\n{\n    vec2 index2 = vec2(float(index % 16), float(15 - index / 16));\n    return pos.x < 0.0 || pos.x > 64.0 || pos.y < 0.0 || pos.y > 64.0  ? 0.0 :\n        fontTexture(pos + 64.0 * index2).r;\n}\n\nvec2 numberTexture(vec2 pos, float value, int digits) // (mask, width)\n{\n    vec2 pos1 = pos;\n    float result = 0.0;\n\n    if (value < 0.0)\n    {\n        result += characterTexture(pos1, 45);\n        pos1.x -= 32.0;\n        value = abs(value);\n    }\n\n    int magnitude = int(max(floor(log(value) / 2.302585), 0.0)) + 1;\n\n    value /= pow(10.0, float(magnitude - 1));\n\n    while (magnitude > -digits)\n    {\n        int digit = int(floor(value));\n        result += characterTexture(pos1, digit + 48);\n        value = fract(value) * 10.0;\n\n        pos1.x -= 32.0;\n        magnitude--;\n\n        if (magnitude == 0 && digits > 0)\n        {\n            result += characterTexture(pos1, 46);\n            pos1.x -= 32.0;\n        }\n    }\n\n    return vec2(pos.x - pos1.x, min(result, 1.0));\n}\n\nfloat stringTexture(vec2 pos, int index)\n{\n    float result = 0.0;\n\n    int i = 0;\n    while (i < text.length() && index > 0)\n    {\n        if (text[i] == -1)\n        {\n            index--;\n        }\n\n        i++;\n    }\n\n    while (i < text.length() && text[i] != -1)\n    {\n        result += characterTexture(pos, text[i]);\n        pos.x -= 32.0;\n        i++;\n    }\n\n    return result;\n}\n\nfloat getTargetMask(vec2 pos)\n{\n    const float thickness = 2.0;\n    const float opening = 5.0;\n    const float size = 15.0;\n\n    pos.xy = abs(pos.xy);\n    pos = vec2(max(pos.x, pos.y), min(pos.x, pos.y));\n\n    return ((pos.x > opening && pos.x < size && pos.x > thickness && pos.y < thickness)) ? 1.0 : 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    deserializeState(iChannel0, iResolution.xy);\n\n    vec2 skipState = fragCoord.x < STATE_SIZE + 2.0 && fragCoord.y < 3.0 ? vec2y(3.0) : vec2(0.0);\n    vec2 uv = (fragCoord.xy + skipState) / iResolution.xy;\n\n    float renderScale = state.renderScale;\n\n    #ifndef SMOOTH_SCALE\n        uv = round(uv * renderScale * iResolution.xy) / (renderScale * iResolution.xy);\n    #endif\n\n    uv *= renderScale;\n    uv += (1.0 - renderScale) / 2.0;\n\n    vec3 color = texture(iChannel0, uv).rgb;\n\n    float annotation = 0.0;\n\n    vec2 p = fragCoord.xy;\n\n    vec2 p2 = p;\n    if (iTime < state.targetAnnotation.z + 0.05 && state.targetAnnotation.w > 0.0)\n    {\n        annotation += getTargetMask(p2 - state.targetAnnotation.xy);\n    }\n\n    #ifdef DISPLAY_DEBUG_VALUE\n        p2 = p;\n        p2 /= TEXT_SCALE;\n        vec4 displayValue = state.debug;\n        p2.y -= 3.0 * 60.0; // 3 lines up\n        annotation += numberTexture(p2, displayValue.x, 2).y; p2.y += 60.0;\n        annotation += numberTexture(p2, displayValue.y, 2).y; p2.y += 60.0;\n        annotation += numberTexture(p2, displayValue.z, 2).y; p2.y += 60.0;\n        annotation += numberTexture(p2, displayValue.w, 2).y; p2.y += 60.0;\n    #endif\n\n    if (state.modeAnnotation.x > 0.0 && iTime < state.modeAnnotation.y + 1.0)\n    {\n        p2 = p;\n        p2.y -= iResolution.y;\n        p2 /= TEXT_SCALE;\n        p2.y += 75.0;\n\n        if (state.modeAnnotation.x > 2.0)\n        {\n            vec2 p3 = p2;\n            vec2 t2 = numberTexture(p3, state.nextRenderScale * 100.0, 0);\n            annotation += t2.y;\n            p3.x -= t2.x;\n            annotation += characterTexture(p3, 37); // \"%\"\n\n            p3 = p2;\n            p3.y += 60.0;\n            t2 = numberTexture(p3, state.nextRenderScale * iResolution.x, 0);\n            annotation += t2.y;\n            p3.x -= t2.x;\n            annotation += characterTexture(p3, 120); // \"x\"\n            p3.x -= 32.0;\n            t2 = numberTexture(p3, state.nextRenderScale * iResolution.y, 0);\n            annotation += t2.y;\n        }\n        else if (state.modeAnnotation.x > 1.0)\n        {\n            annotation += stringTexture(p2, int(state.navigationMode));\n        }\n        else\n        {\n            annotation += stringTexture(p2, 2 + int(state.nextRenderMode));\n        }\n    }\n\n    vec3 annotationColor = vec3(min(step(color.r, 0.2) + step(color.g, 0.2) + step(color.b, 0.2), 1.0));\n    color = mix(color, annotationColor, min(annotation, 1.0));\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// MIT License\n\n// Common\n\n// ---Render options ---\n#define RENDER_GROUND\n#define RENDER_MOUNTAINS\n#define RENDER_HOUSE\n#define RENDER_HOUSE_DETAILS\n#define RENDER_BRIDGE\n#define RENDER_GRASS\n#define RENDER_ROCKS\n#define RENDER_TRANSPARENCY\n#define RENDER_TREES\n#define RENDER_FLOWERS\n#define RENDER_CLOUDS\n//#define RENDER_CAKE\n\n// include transparent object shadow\n//#define RENDER_TRANSPARENCY_SHADOW\n// non pixelated scaling\n//#define SMOOTH_SCALE\n// display state.debug value\n//#define DISPLAY_DEBUG_VALUE\n\n#define MAX_STEPS 100\n#define MAX_SHADOW_STEPS 40\n#define MAX_REFLECTION_STEPS 30\n#define MAX_DIST 600.0\n#define MAX_DIST_LOG 6.4\n#define FIELD_OF_VIEW 1.8\n#define SURF_DIST 0.0001\n#define BOUNDS_MARGIN 0.2\n#define BOUNDS_MARGIN_LARGE 0.4\n#define TEXT_SCALE 0.6\n\n// --- Interaction ---\n#define ZOOM_DRAG_SPEED 4.0\n#define ZOOM_SCROLL_SPEED 0.3\n#define MOVE_CAMERA_HEIGHT 1.0\n#define MOVE_SPEED1 4.0\n#define MOVE_SPEED2 8.0\n#define MOVE_GRAVITY 4.0\n#define MOVE_COLLISION 6.0\n#define SWIVEL_SPEED 5.0\n#define CLICK_TIME 0.4\n#define MIN_CAMERA_HEIGHT 0.2\n\n// --- Scene parameters ---\nconst vec3 INITIAL_TARGET = vec3(0.0, 18.0, 0.0); // house\nconst vec3 INITIAL_ORIGIN = vec3(-1.95, 1.39, 62.0); // bridge entrance\nconst vec3 SUN_DIRECTION = normalize(vec3(1.0));\n\n// Materials\n#define MATERIAL_EMPTY 0.0\n#define MATERIAL_SKY 1.0\n#define MATERIAL_GRASS 2.0\n#define MATERIAL_GRASS_FLOWER1 3.0\n#define MATERIAL_GRASS_FLOWER2 4.0\n#define MATERIAL_MOUNTAIN 5.0\n#define MATERIAL_CLOUD 6.0\n#define MATERIAL_OUTER_WALL 7.0\n#define MATERIAL_INNER_WALL 8.0\n#define MATERIAL_PAINTED_WOOD 9.0\n#define MATERIAL_WOOD1 10.0\n#define MATERIAL_WOOD2 11.0\n#define MATERIAL_WOOD3 12.0\n#define MATERIAL_WOOD4 13.0\n#define MATERIAL_TILE 14.0\n#define MATERIAL_BRICK 15.0\n#define MATERIAL_METAL1 16.0\n#define MATERIAL_METAL2 17.0\n#define MATERIAL_METAL3 18.0\n#define MATERIAL_METAL4 19.0\n#define MATERIAL_BASE_ROCK 20.0\n#define MATERIAL_ROPE 21.0\n#define MATERIAL_RIVERBED 22.0\n#define MATERIAL_SOIL 23.0\n#define MATERIAL_PATHWAY 24.0\n#define MATERIAL_PATHWAY_ROCK 25.0\n#define MATERIAL_TREE_BRANCH 26.0\n#define MATERIAL_TREE_BARK 27.0\n#define MATERIAL_STEM 28.0\n#define MATERIAL_FLOWER1 29.0\n#define MATERIAL_FLOWER2 30.0\n#define MATERIAL_HAT 31.0\n#define MATERIAL_HAT_RIBBON 32.0\n#define MATERIAL_SKIN 33.0\n#define MATERIAL_EYE 34.0\n#define MATERIAL_PUPIL 35.0\n#define MATERIAL_MOUTH 36.0\n#define MATERIAL_SCARF 37.0\n#define MATERIAL_PORCELIN 38.0\n#define MATERIAL_CAKE1 39.0\n#define MATERIAL_CAKE2 40.0\n\n// Transparent materials (leave gap for added reflection material)\n#define MATERIAL_WINDOW_GLASS 50.0\n#define MATERIAL_DOOR_GLASS1 52.0\n#define MATERIAL_DOOR_GLASS2 54.0\n#define MATERIAL_DOOR_GLASS3 56.0\n#define MATERIAL_GLASS1 58.0\n#define MATERIAL_GLASS2 60.0\n#define MATERIAL_GLASS3 62.0\n#define MATERIAL_GLASS4 64.0\n\n// Transparent material with reflection\n#define MATERIAL_WATER 68.0\n#define MATERIAL_JUICE 70.0\n\n// Materials properties\n#define materialHasOutline(m) ((m) > MATERIAL_CLOUD || (m) >= MATERIAL_GRASS_FLOWER1 && (m) <= MATERIAL_GRASS_FLOWER2)\n#define materialHasInnerLines(m) ((m) >= MATERIAL_MOUNTAIN)\n#define materialFadeOutlines(m) ((m) >= MATERIAL_GRASS && (m) <= MATERIAL_GRASS_FLOWER2)\n#define materialFadeInnerLines(m) ((m) != MATERIAL_MOUNTAIN)\n#define materialCastsShadow(m) ((m) > MATERIAL_CLOUD && (m) < MATERIAL_WATER)\n#define materialReceivesShadow(m) ((m) > MATERIAL_SKY && (m) < MATERIAL_MOUNTAIN || (m) > MATERIAL_CLOUD)\n#define materialIsTransparent(m) ((m) >= MATERIAL_WINDOW_GLASS)\n#define materialIsTransparentWithReflection(m) ((m) >= MATERIAL_WATER)\n#define materialIsTransparentObject(m) (false)\n#define materialIsReflected(m) ((m) > MATERIAL_SKY)\n#define materialHasGroundBounceLight(m) ((m) > MATERIAL_GRASS && (m) < MATERIAL_SKIN)\n\n// --- Constants ---\n#define PI025 0.78539816339\n#define PI05 1.57079632679\n#define PI075 2.35619449019\n#define PI 3.14159265359\n#define PI2 6.28318530718\n\n#define map11_01(x) (((x) + 1.0) * 0.5)\n#define map01_11(x) ((x) * 2.0 - 1.0)\n\n#define vec2x(x) vec2(x, 0.0)\n#define vec2y(y) vec2(0.0, y)\n#define vec3x(x) vec3(x, 0.0, 0.0)\n#define vec3y(y) vec3(0.0, y, 0.0)\n#define vec3z(z) vec3(0.0, 0.0, z)\n\n#define vec2x1 vec2(1.0, 0.0)\n#define vec2y1 vec2(0.0, 1.0)\n#define vec3x1 vec3(1.0, 0.0, 0.0)\n#define vec3y1 vec3(0.0, 1.0, 0.0)\n#define vec3z1 vec3(0.0, 0.0, 1.0)\n\n#define KEY_SHIFT 16\n#define KEY_CONTROL 17\n#define KEY_A 65\n#define KEY_C 67\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_N 78\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_W 87\n#define KEY_KP_PLUS 107\n#define KEY_KP_MINUS 109\n#define KEY_F1 112\n#define KEY_EQUALS 61\n#define KEY_MINUS 173\n#define BUTTON_LEFT 245\n#define BUTTON_MIDDLE 246\n#define BUTTON_RIGHT 247\n#define MOUSE_SCROLL_UP 250\n#define MOUSE_SCROLL_DOWN 251\n\n#define inputTexture(coord) texture(iChannel0, (coord) / iResolution.xy)\n#define inputTextureState(i) texture(iChannel0, vec2(float(i) + 0.5, 0.5) / iResolution.xy)\n\n// --- Serialization ---\n\n// Buffer definition (broken into [whole].[fraction] parts):\n//     x: outline.depth\n//     y: material.uv_x\n//     z: edge.uv_y\n//     w: tint.shadow\n\n#define getOutlineComponent(t) floor(t.x)\n#define getDepthComponent(t) fract(t.x)\n#define getMaterialIndexComponent(t) floor(t.y)\n#define getEdgeGroupComponent(t) floor(t.z)\n#define getMaterialUvComponent(t) fract(t.yz)\n#define getTintIndexComponent(t) floor(t.w)\n#define getShadowComponent(t) fract(t.w)\n\n#define setOutlineComponent(t, g) vec4(fract(t.x) + g, t.yzw)\n#define serializeDepth(d) clamp(log((d) + 1.0) / MAX_DIST_LOG, 0.0, 0.9999)\n#define deserializeDepth(d) (exp((d) * MAX_DIST_LOG) - 1.0)\n\nstruct State\n{\n    bool initialized; // 0 - state initialized\n    vec3 origin; // 1 - camera origin\n    vec3 target; // 2 - camera target\n    vec3 targetOffset; // 3 - camera target offset (when target is set but not centered)\n    vec4 targetAnnotation; // 4 - camera target offset (when target is set but not centered)\n    vec3 nextOrigin; // 5 - next frame navigated origin\n    vec3 nextTarget; // 6 - next frame navigated target\n    vec3 nextTargetOffset; // 7\n    vec3 viewX; // 8 - camera x axis (cached)\n    vec3 viewY; // 9 - camera y axis (cached)\n    vec3 viewZ; // 10 - camera z axis (cached)\n    vec3 viewOrigin; // 11 - clipped camera origin (above ground)\n    float dragStartTime; // 12\n    vec2 dragStartPosition; // 13\n    vec2 dragLastPosition; // 14 - non applied drag delta start\n    float renderMode; // 15\n    float renderScale; // 16\n    float nextRenderMode; // 17\n    float nextRenderScale; // 18\n    float navigationMode; // 19\n    bool focused; // 20 - viewport was clicked\n    float clickTime; // 21\n    float clickCount; // 22\n    vec2 modeAnnotation; // 23\n    vec4 debug; // 24\n} state;\n\n#define STATE_SIZE 25.0\n\nvoid deserializeState(sampler2D iChannel0, vec2 iResolution)\n{\n    state.initialized = inputTextureState(0).x > 0.0;\n    state.origin = inputTextureState(1).xyz;\n    state.target = inputTextureState(2).xyz;\n    state.targetOffset = inputTextureState(3).xyz;\n    state.targetAnnotation = inputTextureState(4);\n    state.nextOrigin = inputTextureState(5).xyz;\n    state.nextTarget = inputTextureState(6).xyz;\n    state.nextTargetOffset = inputTextureState(7).xyz;\n    state.viewX = inputTextureState(8).xyz;\n    state.viewY = inputTextureState(9).xyz;\n    state.viewZ = inputTextureState(10).xyz;\n    state.viewOrigin = inputTextureState(11).xyz;\n    state.dragStartTime = inputTextureState(12).x;\n    state.dragStartPosition = inputTextureState(13).xy;\n    state.dragLastPosition = inputTextureState(14).xy;\n    state.renderMode = inputTextureState(15).x;\n    state.renderScale = inputTextureState(16).x;\n    state.nextRenderMode = inputTextureState(17).x;\n    state.nextRenderScale = inputTextureState(18).x;\n    state.navigationMode = inputTextureState(19).x;\n    state.focused = inputTextureState(20).x > 0.0;\n    state.clickTime = inputTextureState(21).x;\n    state.clickCount = inputTextureState(22).x;\n    state.modeAnnotation = inputTextureState(23).xy;\n    state.debug = inputTextureState(24);\n}\n\nvec4 serializeState(int index)\n{\n    if (index == 0) return vec4(state.initialized ? 1.0 : 0.0, 0.0, 0.0, 0.0);\n    if (index == 1) return vec4(state.origin, 0.0);\n    if (index == 2) return vec4(state.target, 0.0);\n    if (index == 3) return vec4(state.targetOffset, 0.0);\n    if (index == 4) return vec4(state.targetAnnotation);\n    if (index == 5) return vec4(state.nextOrigin, 0.0);\n    if (index == 6) return vec4(state.nextTarget, 0.0);\n    if (index == 7) return vec4(state.nextTargetOffset, 0.0);\n    if (index == 8) return vec4(state.viewX, 0.0);\n    if (index == 9) return vec4(state.viewY, 0.0);\n    if (index == 10) return vec4(state.viewZ, 0.0);\n    if (index == 11) return vec4(state.viewOrigin, 0.0);\n    if (index == 12) return vec4(state.dragStartTime, 0.0, 0.0, 0.0);\n    if (index == 13) return vec4(state.dragStartPosition, 0.0, 0.0);\n    if (index == 14) return vec4(state.dragLastPosition, 0.0, 0.0);\n    if (index == 15) return vec4(state.renderMode, 0.0, 0.0, 0.0);\n    if (index == 16) return vec4(state.renderScale, 0.0, 0.0, 0.0);\n    if (index == 17) return vec4(state.nextRenderMode, 0.0, 0.0, 0.0);\n    if (index == 18) return vec4(state.nextRenderScale, 0.0, 0.0, 0.0);\n    if (index == 19) return vec4(state.navigationMode, 0.0, 0.0, 0.0);\n    if (index == 20) return vec4(state.focused ? 1.0 : 0.0, 0.0, 0.0, 0.0);\n    if (index == 21) return vec4(state.clickTime, 0.0, 0.0, 0.0);\n    if (index == 22) return vec4(state.clickCount, 0.0, 0.0, 0.0);\n    if (index == 23) return vec4(state.modeAnnotation, 0.0, 0.0);\n    if (index == 24) return vec4(state.debug);\n\n    return vec4(0.0);\n}\n\nvoid resetState()\n{\n    state.initialized = false;\n    state.origin = vec3(0.0);\n    state.target = vec3(0.0);\n    state.targetOffset = vec3(0.0);\n    state.nextOrigin = vec3(0.0);\n    state.nextTarget = vec3(0.0);\n    state.nextTargetOffset = vec3(0.0);\n    state.viewX = vec3(0.0);\n    state.viewY = vec3(0.0);\n    state.viewZ = vec3(0.0);\n    state.viewOrigin = vec3(0.0);\n    state.dragStartTime = 0.0;\n    state.dragStartPosition = vec2(0.0);\n    state.dragLastPosition = vec2(0.0);\n    state.renderMode = 0.0;\n    state.renderScale = 0.0;\n    state.nextRenderMode = 0.0;\n    state.nextRenderScale = 0.0;\n    state.navigationMode = 0.0;\n    state.focused = false;\n    state.clickTime = 0.0;\n    state.clickCount = 0.0;\n    state.modeAnnotation = vec2(0.0);\n    state.debug = vec4(0.0);\n}\n\n// --- Common functions ---\n\nfloat smin(float a, float b, float k) // smooth min\n{\n    k = max(k, 0.001);\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * h * k / 6.0;\n}\n\nvec3 smin(vec3 a, vec3 b, float k) // x component smooth min\n{\n    float x = smin(a.x, b.x, k);\n    return vec3(x, a.x <= b.x ? a.yz : b.yz);\n}\n\nfloat smax(float a, float b, float k) // smooth max\n{\n    k = max(k, 0.001);\n    float h = max(k - abs(a - b), 0.0) / k;\n    return max(a, b) + h * h * h * k / 6.0;\n}\n\nvec3 smax(vec3 a, vec3 b, float k) // x component smooth max\n{\n    float x = smax(a.x, b.x, k);\n    return vec3(x, a.x <= b.x ? b.yz : a.yz);\n}\n\nvec2 minx(vec2 a, vec2 b) // x component min\n{\n    return a.x <= b.x ? a : b;\n}\n\nvec3 minx(vec3 a, vec3 b) // x component min\n{\n    return a.x <= b.x ? a : b;\n}\n\nvec2 maxx(vec2 a, vec2 b) // x component max\n{\n    return a.x >= b.x ? a : b;\n}\n\nvec3 maxx(vec3 a, vec3 b) // x component max\n{\n    return a.x >= b.x ? a : b;\n}\n\nmat2 rotation(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, s, -s, c);\n}\n\nmat2 rotationApprox(float angle)\n{\n    float s = angle - angle * angle * angle / 6.0;\n    float c = 1.0 - 0.5 * angle * angle;\n    return mat2(c, s, -s, c);\n}\n\nfloat pow2(float value)\n{\n    return value * value;\n}\n\nfloat stretchAxis(float p, float w)\n{\n    p += w * 0.5;\n    return p - clamp(p, 0.0, w);\n}\n\nfloat stretchAxis(float p, float a, float b)\n{\n    return p - clamp(p, a, b) + a;\n}\n\nvec2 radialMod(vec2 p, float count, out float index)\n{\n    float angle = atan(p.y, p.x);\n    float size = PI2 / count;\n\n    index = angle / size + 0.5;\n    angle = (fract(index) - 0.5) * size;\n\n    index = floor(index);\n    return vec2(cos(angle), sin(angle)) * length(p.xy);\n}\n\nvec4 hexCoordinates(vec2 p, float scale)\n{\n    // hexagon edge length is 1\n    const float a = sqrt(0.75); // hexagon width is 2a\n    const float b = sqrt(0.25); // hexagon height is 2b+1\n\n    p /= scale;\n\n    vec2 gridSize = vec2(2.0 * a, 2.0 * (b + 1.0));\n    vec2 index = floor(p / gridSize);\n\n    index *= 2.0; // center hexagon has an even index\n\n    vec2 q = p;\n    q -= 0.5 * gridSize * (index + 1.0); // center\n    vec2 s = sign(q);\n\n    q = vec2(abs(q.x), 0.5 + b - abs(q.y)); // mirror, and flip y\n    if (b * q.x > a * q.y) // cell corners, move to previous or next hexagon\n    {\n        index += s;\n    }\n\n    p -= 0.5 * gridSize * (index + 1.0); // center\n\n    p *= scale;\n\n    return vec4(p, index);\n}\n\nfloat lineIntersection(vec2 p, vec2 a, vec2 b)\n{\n    vec2 v1 = p - a;\n    vec2 v2 = b - a;\n    float t = dot(v1, v2) / dot(v2, v2);\n    return t;\n}\n\n// Noise\n\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec2 pos)\n{\n    vec2 p = floor(pos);\n    vec2 f = fract(pos);\n\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p.x + 7.0 * p.y;\n\n    return mix(mix(hash(n), hash(n + 1.0), f.x),\n               mix(hash(n + 7.0), hash(n + 8.0), f.x), f.y);\n}\n\nfloat noise(vec3 pos)\n{\n    vec3 p = floor(pos);\n    vec3 f = fract(pos);\n\n    f = f * f * (3.0 - 2.0 * f);\n\n    float a = 37.0;\n    float b = 19.0;\n\n    float n = p.x + a * p.y + b * p.z;\n\n    float res = mix(mix(mix(hash(n), hash(n + 1.0), f.x),\n                        mix(hash(n + a), hash(n + a + 1.0), f.x), f.y),\n                    mix(mix(hash(n + b), hash(n + b + 1.0), f.x),\n                        mix(hash(n + a + b), hash(n + a + b + 1.0), f.x), f.y), f.z);\n    return res;\n}\n\nfloat fbm(vec2 p)\n{\n    float f = 0.5 * noise(p);\n    p *= 2.1; f += 0.25 * noise(p);\n    p *= 2.1; f += 0.25 * noise(p);\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n    float f = 0.5 * noise(p);\n    p *= 2.1; f += 0.25 * noise(p);\n    return f;\n}\n\nvec2 voronoi(vec2 pos)\n{\n    vec2 p = floor(pos);\n    vec2 f = fract(pos);\n\n    vec2 result = vec2(1.0, 0.0);\n\n    for( int i = 0; i < 9; i++)\n    {\n        vec2 offset = vec2(float(i % 3), float(i / 3)) - 1.0;\n        vec2 r = offset - f + hash(p + offset);\n\n        float d = dot(r, r);\n        float id = hash(p + offset);\n\n        result = minx(result, vec2(d, id));\n    }\n\n    return result;\n}\n\n\n// SDF\n\nfloat sdLine(vec2 pos, float len)\n{\n    return length(vec2(max(0.0, abs(pos.x) - len), pos.y));\n}\n\nfloat sdLine(vec2 pos, vec2 a, vec2 b)\n{\n    float t = lineIntersection(pos, a, b);\n    vec2 c = a + clamp(t, 0.0, 1.0) * (b - a);\n    return length(pos - c);\n}\n\nfloat sdLine(vec2 pos, float x, float y)\n{\n    return sdLine(pos, vec2x(x), vec2y(y));\n}\n\nfloat sdCircle(vec2 pos, float r)\n{\n    return length(pos) - r;\n}\n\nfloat sdTriangle(vec2 p, float r)\n{\n    const float m = 1.7320508075; //sqrt(3.0);\n\n    float h = m * r;\n\n    p.x = abs(p.x);\n    p.y += h / 3.0;\n\n    // edge line is y = h-m*x\n    // perpendicular line is y = c+x/m\n    // intersection point is (a,b)\n    float c = p.y - p.x / m;\n    float a = m * (h - c) / 4.0;\n    a = clamp(a, 0.0, r);\n    float b = h - m * a;\n\n    float d = length(p - vec2(a, b)); // distance from side edge\n    d = p.x < r ? min(d, abs(p.y)) : d; // distance from base edge\n    d = p.y > 0.0 && p.y < b ? -d : d; // sign\n\n    return d;\n}\n\nfloat sdRectangle(vec2 pos, vec2 size)\n{\n   vec2 d = abs(pos) - size;\n   return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdRectangle(vec2 pos, vec2 size, vec2 thickness)\n{\n   vec2 d = abs(pos) - size;\n   return length(max(d, 0.0)) - min(max(d.x + thickness.x, d.y + thickness.y), 0.0);\n}\n\nfloat sdRectangleApprox(vec2 pos, vec2 size)\n{\n    vec2 d = abs(pos) - size;\n    return max(d.x, d.y);\n}\n\nfloat sdRoundedRectangle(vec2 pos, vec2 size, vec4 r)\n{\n    r.xy = pos.x < 0.0 ? r.zw : r.xy;\n    r.x  = pos.y < 0.0 ? r.y : r.x;\n    vec2 q = abs(pos) - size + r.x;\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n}\n\nfloat sdHexApprox(vec2 p, float scale)\n{\n      // hex edge length is 1\n    const float a = sqrt(0.75); // hex width is 2a\n    const float b = sqrt(0.25); // hex height is 2b+1\n    const float m = b / a; // slope\n\n    p /= scale;\n\n    float y = 0.5 + b - m * abs(p.x);\n    float h = abs(p.y) - y;\n\n    float d1 = a * h;\n    float d2 = abs(p.x) - a;\n    d1 = max(d1, d2);\n\n    d1 *= scale;\n\n    return d1;\n}\n\nfloat sdEllipse(vec2 pos, vec2 rad)\n{\n    float k0 = length(pos / rad);\n    float k1 = length(pos / rad / rad);\n    return k0 * (k0 - 1.0) / k1;\n}\n\nfloat sdSurface(vec3 pos)\n{\n    return pos.y;\n}\n\nfloat sdSphere(vec3 pos, float rad)\n{\n    return length(pos) - rad;\n}\n\nfloat sdEllipsoid(vec3 pos, vec3 rad)\n{\n    float k0 = length(pos / rad);\n    float k1 = length(pos / rad / rad);\n    return k0 * (k0 - 1.0) / k1;\n}\n\nfloat sdBox(vec3 pos, vec3 size)\n{\n    vec3 d = abs(pos) - size;\n    return length(max(d, 0.0)) + min(max(max(d.x, d.y), d.z), 0.0);\n}\n\nfloat sdBox(vec3 pos, vec3 size, vec3 origin, float bevel)\n{\n    return sdBox(pos - origin * size, size - bevel) - bevel;\n}\n\nfloat sdBoxApprox(vec3 pos, vec3 size)\n{\n    vec3 d = abs(pos) - size;\n    return max(max(d.x, d.y), d.z);\n}\n\nfloat sdBoxApprox(vec3 pos, vec3 size, vec3 origin)\n{\n    return sdBoxApprox(pos - origin * size, size);\n}\n\nfloat sdBoxFlatBevel(vec3 pos, vec3 size, float bevel)\n{\n    const float a = 0.70710678;\n    const float b = 0.54690282;\n\n    pos = abs(pos);\n    size -= bevel;\n\n    float d = pos.x - size.x;\n    d = max(d, pos.y - size.y);\n    d = max(d, pos.z - size.z);\n    d = max(d, a * (pos.x + pos.y - size.x - size.y));\n    d = max(d, a * (pos.x + pos.z - size.x - size.z));\n    d = max(d, a * (pos.y + pos.z - size.y - size.z));\n    d = max(d, b * (pos.x + pos.y + pos.z - size.x - size.y - size.z));\n\n    d -= bevel;\n\n    return d;\n}\n\nfloat sdArc(vec3 pos, float len, float angle, float width, float taper)\n{\n    angle = map01_11(step(0.0, angle)) * max(abs(angle), 0.01);\n\n    // parameters\n    vec2 sc = vec2(sin(angle), cos(angle));\n    float ra = 0.5 * len / angle;\n\n    // recenter\n    pos.x -= ra;\n\n    // reflect\n    vec2 q = pos.xy - 2.0 * sc * max(0.0, dot(sc, pos.xy));\n\n    float u = abs(ra) - length(q);\n    float d2 = (q.y < 0.0) ? dot(q + vec2(ra, 0.0), q + vec2(ra, 0.0)) : u * u;\n    float s = sign(angle);\n\n    float t = (pos.y > 0.0) ? atan(s * pos.y, -s * pos.x) * ra : (s * pos.x < 0.0) ? pos.y : len - pos.y;\n    width = max(0.001, width - t * taper);\n\n    return sqrt(d2 + pos.z * pos.z) - width;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp( dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\n  return length(pa - ba * h) - r;\n}\n\nfloat sdPlane(vec3 pos, vec3 size)\n{\n    float t = lineIntersection(pos.xy, vec2(0.0, 0.0), size.xy);\n    vec3 c = vec3(size.xy * clamp(t, 0.0, 1.0), clamp(pos.z, 0.0, size.z)); // closest point\n    return length(pos - c);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// MIT License\n\n// Buffer A - Model and navigation\n// Inputs: Buffer A, Keyboard\n\n#define keyboardTexture(coord) texture(iChannel1, (coord) / vec2(256.0, 3.0))\n\n// steps view values\nint marchSteps = 0;\nint marchTransparentSteps = 0;\nint marchReflectionSteps = 0;\nint marchShadowSteps = 0;\n\n// Consts\nconst vec3 WELL_POSITION = vec3(-7.0, -0.1, -5.5);\nconst vec3 HAT_POSITION = vec3(133.1, 0.0, 32.3);\nconst float HOUSE_HEIGHT = 14.0;\nconst float HILL_HEIGHT = 10.0;\n\nconst mat2 rotation_0 = mat2(1.0, 0.0, 0.0, 1.0);\nconst mat2 rotation_1 = mat2(0.9998476, 0.0174524, -0.0174524, 0.9998476);\nconst mat2 rotation_7_5 = mat2(0.9914448, 0.1305261, -0.1305261, 0.9914448);\nconst mat2 rotation_10 = mat2(0.9848077, 0.1736481, -0.1736481, 0.9848077);\nconst mat2 rotation_15 = mat2(0.9659258, 0.258819, -0.258819, 0.9659258);\nconst mat2 rotation_20 = mat2(0.9396926, 0.342020, -0.342020, 0.9396926);\nconst mat2 rotation_25 = mat2(0.9063077, 0.422618, -0.422618, 0.9063077);\nconst mat2 rotation_30 = mat2(0.8660254, 0.5, -0.5, 0.8660254);\nconst mat2 rotation_45 = mat2(0.7071067, 0.7071067, -0.7071067, 0.7071067);\nconst mat2 rotation_60 = mat2(0.5, 0.8660254, -0.8660254, 0.5);\nconst mat2 rotation_90 = mat2(0.0, 1.0, -1.0, 0.0);\nconst mat2 rotation_93 = mat2(-0.0523359, 0.9986295, -0.9986295, -0.0523359);\nconst mat2 rotation_120 = mat2(-0.5, 0.8660254, -0.8660254, -0.5);\nconst mat2 rotation_145 = mat2(-0.8191520, 0.5735764, -0.5735764, -0.8191520);\nconst mat2 rotation_180 = mat2(-1.0, 0.0, 0.0, -1.0);\n\n\nconst mat2 rotation_n1 = mat2(0.9998476, -0.0174524, 0.0174524, 0.9998476);\nconst mat2 rotation_n7_5 = mat2(0.9914448, -0.1305261, 0.1305261, 0.9914448);\nconst mat2 rotation_n10 = mat2(0.9848077, -0.1736481, 0.1736481, 0.9848077);\nconst mat2 rotation_n15 = mat2(0.9659258, -0.258819, 0.258819, 0.9659258);\nconst mat2 rotation_n20 = mat2(0.9396926, -0.342020, 0.342020, 0.9396926);\nconst mat2 rotation_n25 = mat2(0.9063077, -0.422618, 0.422618, 0.9063077);\nconst mat2 rotation_n30 = mat2(0.8660254, -0.5, 0.5, 0.8660254);\nconst mat2 rotation_n36 = mat2(0.8090169, -0.5877852, 0.5877852, 0.8090169);\nconst mat2 rotation_n45 = mat2(0.7071067, -0.7071067, 0.7071067, 0.7071067);\nconst mat2 rotation_n60 = mat2(0.5, -0.8660254, 0.8660254, 0.5);\nconst mat2 rotation_n90 = mat2(0.0, -1.0, 1.0, 0.0);\nconst mat2 rotation_n93 = mat2(-0.0523359, -0.9986295, 0.9986295, -0.0523359);\nconst mat2 rotation_n120 = mat2(-0.5, -0.8660254, 0.8660254, -0.5);\nconst mat2 rotation_n145 = mat2(-0.8191520, -0.5735764, 0.5735764, -0.8191520);\nconst mat2 rotation_n180 = mat2(-1.0, -0.0, 0.0, -1.0);\n\nfloat getGrassShade(vec2 pos)\n{\n    pos.x += 4.0 * fbm(pos);\n    float x = 0.99 * fbm(pos * vec2(1.0, 0.8) * 0.3);\n    x = x * x;\n    x = x * (2.0 - x);\n    return x;\n}\n\nvec3 getRiverMask(float x) // (width, depth, center-z)\n{\n    float mask = smoothstep(1.0, 10.0, abs(x));\n\n    float width = 3.2;\n    width += mask * 0.8 * sin(0.2 * x);\n    width += mask * 0.2 * sin(2.0 * x);\n\n    float offset = 0.0;\n    offset += 8.0 * sin(0.07 * x + PI05);\n    offset += mask * 0.3 * sin(0.5 * x);\n\n    float depth = 1.6;\n    depth -= 0.3 * (1.0 + sin(0.2 * x));\n    depth -= 0.02 * (2.0 + sin(3.0 * x) + sin(4.0 * x));\n\n    return vec3(width, depth, 42.0 + offset);\n}\n\nvec3 getPathwayMask(float z) //(center-x, depth, width)\n{\n    const float z0 = 10.0; // entrance segment start\n    const float z1 = 40.0; // bridge segment end\n    const float z2 = 50.0; // bridge\n    const float z3 = 100.0; // bridge segment start\n    const float depth1 = 0.1;\n\n    float center = 6.0 * (sin(z * 0.138 + 0.97) - 1.0);\n\n    center *= smoothstep(z2, z1, z) + smoothstep(z2, z3, z);\n    center *= smoothstep(0.0, z0, z);\n    float width = 1.0 + 0.1 * (sin(z * 2.0) + 0.5 * sin(z * 5.0));\n    width = z < 0.0 ? 0.0 : width;\n\n    float depth = depth1;\n\n    return vec3(center, 0.1, width);\n}\n\nfloat getGroundBaseHeight(vec3 pos)\n{\n    const float h1 = 0.5; // base ground height\n    const float r1 = 6.0; // hill inner flat radius\n    const float r2 = 45.0; // hill outer radius\n\n    float r = length(pos.xz);\n\n    return mix(h1, HILL_HEIGHT, pow(smoothstep(r2, r1, r), 0.8));\n}\n\nfloat getGroundHeight(vec3 pos, float baseHeight)\n{\n    const float h1 = 0.5; // bumps height\n    const float r1 = 30.0; // hill bumps start radius 1\n    const float r2 = 40.0; // hill bumps start radius 2\n    const float s1 = 5.0; // bumps size\n\n    vec3 pos1 = pos;\n    pos1 /= s1;\n    pos1.xz *= mat2(0.93, 0.34, -0.34, 0.93);\n\n    float bump = 1.0 +\n        0.7 * (sin(1.2 * pos1.x) + sin(1.5 * pos1.z)) +\n        0.3 * (sin(2.7 * pos1.x) + sin(3.5 * pos1.z));\n\n    vec3 riverMask = getRiverMask(pos.x);\n\n    float d1 = length(pos.xz);\n    float d2 = abs(pos.z - riverMask.z);\n    bump *= smoothstep(2.0, 8.0, d2); // flatten river banks\n    bump *= smoothstep(r1, r2, d1); // flatten hill center\n    baseHeight += bump * h1;\n\n    // river\n    baseHeight -= riverMask.y * smoothstep(1.0, 0.0, abs(pos.z - riverMask.z) / riverMask.x);\n\n    // well\n    baseHeight -= length(pos.xz - WELL_POSITION.xz) < 0.6 ? 1.6 : 0.0;\n\n    return baseHeight;\n}\n\nfloat getGroundHeight(vec3 pos)\n{\n    return getGroundHeight(pos, getGroundBaseHeight(pos));\n}\n\nvec3 getWindForce(vec3 pos, float time)\n{\n    float phase = -sin(pos.x * 0.2) - pos.z; // phase direction\n    float an = 1.0; // force direction\n\n    phase += 0.2 * (sin(2.0 * pos.x + time) + sin(3.0 * pos.z + time)); // noise\n\n    phase = sin(1.5 * time + phase);\n    an += phase; // change direction\n\n    float stength = 0.1 + 2.0 * map11_01(phase);\n\n    stength *= 0.6 + 0.4 * sin(0.2 * pos.z + 0.5 * time); // pulse\n\n    return stength * vec3(cos(an), 0.0, sin(an));\n}\n\n\n// --- Moomin ---\n\nvec3 sdEye(vec3 pos, float side, vec2 eyesDirection, float lookDistance, float time)\n{\n    float bounds = sdBoxApprox(pos, vec3(0.05));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    const float s1 = 0.038; // eyeball size\n    const float s2 = s1 * 0.45; // pupil size\n    const float s3 = s1 + 0.002; // eye lids size\n    const float y1 = 0.6 * s3; // eye lids opening\n\n    const float eyelidsOffset = 0.0;\n\n    float blink = smoothstep(0.99, 1.0, max(sin(time * 0.25), sin(time * 0.5)));\n\n    float eyesOpen = 0.8 * (1.0 - blink);\n\n    vec3 pos1 = pos;\n\n    float d1 = sdSphere(pos1, s3); // eyelids\n\n    vec3 pos2 = pos1;\n    pos2.y -= y1; // opening start\n    pos2.yz *= rotation(eyelidsOffset);\n\n    vec3 pos3 = pos2;\n    pos3.yz *= rotation(PI05 - eyesOpen * (PI05 + eyelidsOffset));\n    float d2 = smax(d1, pos3.y, eyesOpen * 0.02); // upper eyelid\n\n    pos3 = pos2;\n    pos3.yz *= rotation(-PI05 + eyesOpen * (PI05 - eyelidsOffset));\n    float d3 = smax(d1, pos3.y, eyesOpen * 0.02); // lower eyelid\n\n    d1 = min(d2, d3);\n\n    float edge = 0.5 * (sign(pos2.z) + 3.0);\n    vec3 dm1 = vec3(d1, MATERIAL_SKIN, edge);\n\n    pos2 = pos1;\n    d1 = sdSphere(pos2, s1); // eyeball\n\n    pos2.xy *= rotation(lookDistance - side * eyesDirection.x);\n    pos2.yz *= rotation(eyesDirection.y);\n\n    pos2.y -= s1;\n    d2 = sdSphere(pos2, s2); // pupil\n\n    vec3 dm2 = vec3(d1, d2 > 0.0 ? MATERIAL_EYE : MATERIAL_PUPIL, 0.0);\n    dm1 = minx(dm1, dm2);\n\n    return dm1;\n}\n\nvec3 sdEar(vec3 pos)\n{\n    float bounds = sdBoxApprox(pos, vec3(0.055), vec3(0.0, 1.0, -0.5));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    float d1, d2;\n\n    vec3 pos1 = pos;\n    pos1.y += 0.1;\n    d1 = sdEllipsoid(pos1, vec3(0.05, 0.2, 0.06));\n\n    pos1.y -= 0.11;\n    pos1.z += 0.18;\n    d2 = sdSphere(pos1, 0.2);\n    d1 = smax(d1, d2, 0.02);\n\n    pos1 = pos;\n    pos1.z -= 0.02;\n    pos1.y -= 0.04;\n    d2 = sdEllipsoid(pos1, vec3(0.02, 0.06, 0.02));\n    d1 = smax(d1, -d2, 0.02);\n\n    d1 = smax(d1, -pos.y - 0.05, 0.1);\n\n    float hue = d2 < 0.001 ? 1.0 : 0.0;\n    float edge = d2 < 0.001 ? 2.0 : 1.0;\n\n    return vec3(d1, MATERIAL_SKIN, edge + 0.5 * hue);\n}\n\nvec3 sdHead(vec3 pos, vec2 eyesDirection, float lookDistance, float time)\n{\n    const float eyebrowsHeight = 0.0;\n    const float mouthHeight = 0.0;\n    const float mouthOpen = 0.0;\n\n    float bounds = sdBoxApprox(pos, vec3(0.8, 0.25, 0.3), vec3(0.0, -0.2, 0.5));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 pos1, pos2;\n    float d1, d2, d3;\n\n    pos.z -= 0.05;\n    pos.yz *= rotation_60;\n\n    pos1 = pos;\n    pos1.xz *= rotation_90;\n    pos1.xy *= rotation_n90;\n    d1 = sdArc(pos1, 0.18, -0.4, 0.14, -0.11); // head arc\n    pos1.y -= 0.02;\n    d2 = sdSphere(pos1, 0.144);\n    d1 = smin(d1, d2, 0.01); // smooth arc\n\n    pos1 = pos;\n    float rcurve = 0.3;\n    pos1 -= vec3(0.0, 0.22 - rcurve, 0.07);\n    d2 = sdCircle(pos1.xy, rcurve); // flatten head arc top\n    d2 = length(vec2(d2, pos1.z)) - 0.055;\n\n    d1 = smax(d1, -d2, 0.22);\n\n    float merge = smoothstep(0.15, -0.05, pos1.z) * 0.15 + 0.0005;\n\n    // eyes\n    vec3 eyesPos = pos;\n    float eyeSide = sign(eyesPos.x);\n    eyesPos.x = abs(eyesPos.x);\n    eyesPos -= vec3(0.053, 0.085, 0.081);\n    eyesPos.xy *= rotation_n15;\n\n    pos1 = eyesPos;\n    pos1 -= vec3(0.0, 0.02, -0.005);\n    d2 = sdSphere(pos1, 0.035); // eyes socket\n    d1 = smax(d1, -d2, 0.04);\n\n    // eyes top outline group\n    pos1 = eyesPos;\n    pos1 -= vec3(0.004, 0.03, -0.015);\n    d2 = sdSphere(pos1, 0.025);\n\n    float edge = d2 < 0.0 ? 3.0 : 0.0; // eyes top outline\n\n    // eyebrows\n    pos1 = pos;\n    pos1.x = abs(pos1.x);\n    pos1.yz *= rotation(0.15 - eyebrowsHeight * 0.35);\n    pos1.xy *= rotation_n30;\n\n    pos2 = pos1;\n    pos2.z += 0.025;\n    d2 = sdCircle(pos2.xz, 0.025); // eyebrow size\n    d2 = max(d2, -pos2.y);\n\n    pos2 = pos1;\n    pos2.z -= 0.05;\n    pos2.x += 0.03; // eyebrow angle\n    d3 = sdCircle(pos2.xz, 0.08); // eyebrow curve\n    d3 = max(d3, -pos2.y);\n\n    edge = d2 > 0.0 ? edge :\n           d3 > 0.0 ? 1.0 : 3.0;\n\n    vec3 dm1 = vec3(d1, MATERIAL_SKIN, edge);\n\n    // fever hue\n    pos1 = pos;\n    pos1 -= vec3(0.0, 0.155, 0.11);\n    d1 = sdEllipsoid(pos1, 0.08 * vec3(1.0, 0.5, 0.5));\n    dm1.z += 0.99 * smoothstep(0.0, -0.04, d1);// smoothstep(-0.0, -0.1, d1);\n\n    pos1 = eyesPos;\n    vec3 dm2 = sdEye(pos1, eyeSide, eyesDirection, lookDistance, time);\n    dm1 = smin(dm1, dm2, 0.04);\n\n    pos1 = pos;\n    pos1.yz *= rotation_n45;\n    pos1.x = abs(pos1.x);\n    pos1.xy *= rotation_n15;\n    pos1 -= vec3(0.04, 0.09, -0.01);\n    pos1.xz *= rotation_n15;\n    pos1.y -= 0.02;\n    dm2 = sdEar(pos1);\n    dm1 = smin(dm1, dm2, 0.02);\n\n    // mouth\n    pos1 = pos;\n    pos1 += vec3(0.0, 0.06 + mouthHeight, -0.25 + mouthHeight);\n    d1 = sdEllipsoid(pos1, vec3(0.03, 0.02, 0.015) * clamp(mouthOpen, 0.001, 4.0));\n    dm1.xyz = maxx(dm1, vec3(-d1, MATERIAL_MOUTH, 0.0));\n\n\n    return dm1;\n}\n\n\nvec3 sdArm(vec3 pos)\n{\n    float bounds = sdBoxApprox(pos + vec3(0.0, -0.02, 0.05), vec3(0.1, 0.07, 0.15));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n    pos1.xz *= rotation_90;\n    pos1.xy *= rotation_60;\n    float d1 = sdArc(pos1, 0.2, -0.6, 0.04, -0.1);\n\n    // fingers\n    pos1 = pos;\n    pos1.z -= 0.04;\n\n    pos1.x = abs(pos1.x);\n    pos1.yz *= rotation_60;\n    pos1 += vec3(-0.008, 0.008, -0.005);\n\n    vec3 pos2 = pos1;\n    pos2.z = stretchAxis(pos2.z, 0.03);\n    float d2 = sdSphere(pos2, 0.008);\n\n    pos2 = pos1;\n    pos2 += vec3(-0.019, 0.008, 0.005);\n    pos2.z = stretchAxis(pos2.z, 0.03);\n    float d3 = sdSphere(pos2, 0.008);\n    d2 = min(d2, d3);\n\n    // thumb\n    pos2 = pos;\n    pos2.x += 0.037;\n    pos2.xy *= rotation_45;\n    pos2.xz *= rotation_n30;\n    pos2.x = stretchAxis(pos2.x, 0.04);\n    d3 = sdSphere(pos2, 0.009);\n    d2 = min(d2, d3);\n    d1 = smin(d1, d2, 0.015);\n\n    return vec3(d1, MATERIAL_SKIN, 0.0);\n}\n\nvec3 sdLeg(vec3 pos)\n{\n    float bounds = sdBoxApprox(pos, vec3(0.1));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n    pos1.xy *= rotation_n7_5;\n    vec3 pos2 = pos1;\n    pos2.yz *= rotation_30;\n    pos2.y = stretchAxis(pos2.y, 0.14);\n    float d1 = sdSphere(pos2, 0.06);\n\n    pos2 = pos1;\n    pos2.y += 0.13;\n    pos2.z -= 0.03;\n    float d2 = sdSphere(pos2, 0.06);\n    d1 = smin(d1, d2, 0.05);\n\n    pos1 = pos;\n    pos1.y += 0.11;\n    d1 = max(d1, -pos1.y);\n\n    return vec3(d1, MATERIAL_SKIN, 0.0);\n}\n\nvec3 sdTail(vec3 pos)\n{\n    float bounds = sdBoxApprox(pos + vec3(0.0, 0.2, 0.4), vec3(0.01, 0.15, 0.2));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n    pos1.y += 0.31;\n    pos1.z += 0.5;\n\n    pos1 = pos1.yzx;\n    float d1 = sdArc(pos1, 0.4, 0.7, 0.01, -0.03);\n\n    pos1.y = -pos1.y;\n    float d2 = sdArc(pos1, 0.1, 0.6, 0.04, 0.4);\n    d1 = smin(d1, d2, 0.02);\n\n    return vec3(d1, MATERIAL_SKIN, 0.0);\n}\n\nvec3 sdBody(vec3 pos)\n{\n    float bounds = sdBoxApprox(pos - vec3z(-0.1), vec3(0.25, 0.3, 0.6));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    // body\n    vec3 pos1 = pos;\n    pos1 += vec3(0.0, 0.05, 0.03);\n    pos1.xz *= rotation_90;\n    pos1.xy *= rotation_n45;\n    vec3 d1 = vec3(sdArc(pos1, 0.35, -0.5, 0.2, 0.25), MATERIAL_SKIN, 0.0);\n\n    // arms\n    pos1 = pos;\n    pos1.x = abs(pos1.x);\n    pos1 -= vec3(0.13, 0.0, 0.3);\n    pos1.xz *= rotation_n7_5;\n    vec3 d2 = sdArm(pos1);\n    d1 = smin(d1, d2, 0.05);\n\n    // legs\n    pos1 = pos;\n    pos1.x = abs(pos1.x);\n    pos1 -= vec3(0.08, -0.25, -0.15);\n    d2 = sdLeg(pos1);\n    d1 = smin(d1, d2, 0.05);\n\n    pos1 = pos;\n    d2 = sdTail(pos1);\n    d1 = smin(d1, d2, 0.05);\n\n    return d1;\n}\n\nvec3 sdScarf(vec3 pos)\n{\n    vec3 pos1 = pos;\n    float d1 = sdCircle(pos1.xz, 0.15);\n    d1 = length(vec2(d1, stretchAxis(pos1.y, 0.08)));\n\n    pos1 = pos;\n    pos1.xz *= rotation_60;\n    pos1.z -= 0.06 * sin(10.0 * pos1.y + 1.7);\n    pos1 -= vec3(0.0, -0.17, -0.21);\n    float d2 = sdLine(pos1.yz, 0.2);\n    d2 = length(vec2(d2, stretchAxis(pos1.x, 0.1)));\n    d1 = smin(d1, d2, 0.01);\n\n    // bumps\n    pos1 *= 100.0;\n    d1 -= 0.015 + 0.005 * (sin(pos1.x) * sin(pos1.y) * sin(pos1.z));\n\n    float hue = pos.y < -0.25 ? 0.0 : 0.99;\n    return vec3(d1, MATERIAL_SCARF + hue, 0.0);\n}\n\nvec3 sdMoomin(vec3 pos, vec3 lookOffset, float time)\n{\n    float bounds = sdBoxApprox(pos - vec3(0.0, 0.6, -0.1), vec3(0.25, 0.6, 0.6));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n\n    pos1.y -= 0.65;\n    pos1.z += 0.05;\n    vec3 d1 = sdBody(pos1);\n\n    pos1 = pos;\n    pos1.y -= 0.95;\n\n    vec2 an = vec2(-0.6 * (atan(lookOffset.x, lookOffset.z) - 1.0),\n                   -atan(lookOffset.y, length(lookOffset.xz)) + 0.2);\n\n    an.x = an.x * smoothstep(0.7, 0.4, abs(an.x));\n\n    pos1.xz *= rotation(clamp(an.x, -0.8, 0.8));\n    pos1.yz *= rotation(clamp(an.y, -2.0, 0.0));\n\n    vec2 eyesDirection = vec2(-0.3 * an.x, 0.1 * an.y);\n    float lookDistance = clamp(0.5 - 0.5 * length(state.origin - vec3y1), 0.0, 0.2);\n\n    vec3 d2 = sdHead(pos1, eyesDirection, lookDistance, time);\n    float merge = 0.1 * clamp(1.0 - pos1.z / 0.1, 0.0, 1.0); // smooth merge only the neck area\n    d1 = smin(d1, d2, 0.001 + merge);\n\n    pos1 = pos;\n    pos1.y -= 0.78;\n    pos1.yz *= rotation_20;\n    d2 = sdScarf(pos1);\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\n// --- House ---\n\nfloat sdRoofBounds(vec2 pos)\n{\n    const float r = 4.2;\n    const float h = 6.0;\n    const float slope1 = r / h;\n    const float slope2 = sqrt(1.0 + slope1 * slope1);\n\n    vec2 pos1 = pos;\n    pos1.y -= h - 0.02;\n    float d = pos1.y > 0.0 ? length(pos1) : ((pos1.x + slope1 * pos1.y) / slope2);\n    d = max(d, -pos.y);\n\n    return d;\n}\n\nvec3 sdRoof(vec3 pos)\n{\n    const float r = 4.2;\n    const float h = 6.0;\n    const float seed = 0.3;\n    const float h2 = 0.7; // relative ceiling height\n\n    float bounds = sdBoxApprox(pos, vec3(r, h * 0.5, r) * 1.1, vec3y(0.8));\n    if (bounds > BOUNDS_MARGIN_LARGE)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec2 p = vec2(length(pos.xz), pos.y);\n    vec2 a = vec2(0.0, h);\n    vec2 b = vec2(r, 0.0);\n\n    float t = lineIntersection(p, a, b);\n    vec2 c = a + clamp(t, 0.0, 1.0) * (b - a); // closest point\n    vec3 d1 = vec3(length(p - c), MATERIAL_TILE, 1.0);\n\n    // top ceiling\n    vec3 d2 = vec3(length(vec2(max(0.0, p.x - (1.0 - h2) * r + 0.05), p.y - h2 * h)) - 0.02, MATERIAL_PAINTED_WOOD, 0.0);\n    d1 = minx(d1, d2);\n\n    if (d1.x - 0.7 > BOUNDS_MARGIN)\n    {\n        return vec3(d1.x - 0.7, 0.0, 0.0);\n    }\n\n    // side ceiling\n    d2 = vec3(length(p - c + 0.01) - 0.01, MATERIAL_PAINTED_WOOD, 0.0);\n    d2.x = max(d2.x, -pos.y + 0.5);\n    d1 = minx(d1, d2);\n\n    float rows = 12.0;\n    float columnWidth = 0.6;\n\n    vec2 slope = (length(b - a) / rows) * normalize(vec2(r, -h)); // tile base direction\n\n    float an = atan(pos.z, pos.x);\n\n    float overlap = 1.0; // rows overlap\n    float row = clamp(t, 0.0, 1.0) * rows;\n\n    // individual tiles\n    for (float row1 = max(row - overlap, 0.0); row1 <= rows; row1 += 1.0)\n    {\n        float r1 = r * floor(row1 + 1.0) / rows; // tiles row radius\n        float columns1 = round(PI2 * r1 / columnWidth); // number of columns at current row\n        float column1 = columns1 * (an + PI * hash(floor(row1) + seed)) / PI2; // tile column\n\n        float h1 = hash(vec2(floor(row1), mod(floor(column1) + columns1, columns1)) + seed); // row+column hash\n\n        vec2 slope1 = slope * (1.2 - pow2((fract(column1) - 0.5) * 2.0)); // tile length from current slice\n        slope1 *= rotation(-0.1 * h1); // tile direction\n\n        vec2 c1 = a + (floor(row1) / rows) * (b - a); // tile base position\n        float t1 = lineIntersection(p, c1, c1 + slope1);\n        t1 = clamp(t1, 0.0, 1.0);\n        float m1 = h1 * sqrt(t1); // material varience\n        vec2 c2 = c1 + t1 * slope1; // closest point on tile\n\n        float edge = floor(h1 * 3.0); // material edge group variation\n        edge = t1 > 0.1 ? edge : 0.0; // exclude top edge\n\n        d2 = vec3(length(p - c2), MATERIAL_TILE + 0.99 * m1, edge);\n        d1 = minx(d1, d2);\n    }\n\n    d1.x = d1.x < 1.0 ? d1.x * 0.5 : d1.x; // compansate approximation\n    d1.x -= 0.01;\n\n    return d1;\n}\n\nvec3 sdTiles(vec3 pos, vec3 tileSize, vec2 count, float seed)\n{\n    const float boundsDepth = 0.2;\n\n    float h = tileSize.y;\n    float w = tileSize.x;\n    float depth = tileSize.z;\n    float bevel = 0.5 * tileSize.z;\n    float ext = 0.3 * h; // tile overlap\n\n    vec2 size = vec2(count.x * w, count.y * h + ext);\n    pos.y += size.y;\n\n    vec3 bounds = vec3(sdBoxApprox(pos - vec3y(size.y * 0.5), vec3(size * 0.5, boundsDepth)), 0.0, 0.0);\n    if (bounds.x > BOUNDS_MARGIN)\n    {\n        return bounds;\n    }\n\n    bounds.y = MATERIAL_TILE;\n\n    float cellsBounds = sdBoxApprox(pos - vec3y((size.y + ext) * 0.5), vec3(size.x * 0.5, (size.y - ext) * 0.5, boundsDepth));\n\n    float rows = count.y;\n\n    pos.y -= ext;\n    float row = pos.y / h;\n    row = clamp(row, 0.0, rows - 1.0);\n\n    // base\n    float d = sdRectangleApprox(pos.xy - vec2y((rows + 1.0) * h * 0.5), vec2(size.x, (rows - 1.0) * h) * 0.5 + 0.001); // exclude last row\n    d = max(0.0, d); // fill\n    d = length(vec2(d, stretchAxis(pos.z + depth * 0.5, depth)));\n    vec3 d1 = vec3(d, MATERIAL_TILE, 1.0);\n\n    pos.x += mod(count.x, 2.0) > 0.0 ? 0.5 * w : 0.0; // middle tile offset\n\n    // overlapping tiles\n    for (int i = 0; i < 2; i++)\n    {\n        float row1 = row + float(i);\n        float row2 = row1;\n        row1 = clamp(row1, 0.0, rows - 1.0);\n        vec3 pos1 = pos;\n        pos1.xy -= vec2(w, h) * 0.5;\n\n        pos1.x += row1 >= 1.0 ? w * hash(floor(row1) + seed) : 0.0; // exclude first row offset\n\n        float column1 = pos1.x / w + 0.5;\n\n        pos1.x -= floor(column1) * w;\n        pos1.y -= floor(row1) * h;\n\n        // cell bounds\n        float cellBounds = sdRectangle(pos1.xy, 0.55 * vec2(w, h));\n        cellBounds = length(vec2(cellBounds, stretchAxis(pos1.z, boundsDepth)));\n        cellBounds = max(cellBounds, cellsBounds); // clip bounds at the plane edges\n        cellBounds = i > 0 ? max(cellBounds, MAX_DIST) : cellBounds; // remove bounds for overlapping rows\n\n        // tile\n        float h1 = hash(vec2(floor(row1), floor(column1)) + seed);\n        pos1.y -= h * 0.5;\n        pos1.yz *= rotationApprox(-0.05 - 0.1 * h1); // rotate\n\n        float d = sdEllipse(pos1.xy, vec2(w * 0.5, h + ext) - bevel);\n        d = max(pos1.y, d); // clip top part\n        d = max(0.0, d); // fill shape\n        d = length(vec2(d, stretchAxis(pos1.z + 0.5 * depth, depth - 2.0 * bevel))); // thickness\n        d -= bevel;\n\n        float y = h1 * (1.0 - fract(row2) + float(i)) * h / (h + ext);\n        float edge = floor(h1 * 3.0); // material edge group variation\n        edge = y > 0.1 ? edge : 0.0; // exclude top edge\n\n        vec3 d2 = vec3(d, MATERIAL_TILE + 0.99 * y, edge);\n        d2 = maxx(d2, bounds);\n\n        d1 = minx(d1, d2);\n    }\n\n    return d1;\n}\n\nvec3 sdLightningRod(vec3 pos)\n{\n    float bounds = sdBoxApprox(pos, vec3(0.45, 2.0, 0.45), vec3y(0.9));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec2 p = vec2(length(pos.xz), pos.y);\n\n    float d1 = sdLine(p, vec2(0.4, 0.0), vec2(0.0, 1.3)) - 0.1; // bottom cone\n\n    float d2 = sdLine(p, vec2(0.0, 0.7), vec2(0.25, 2.0)); // middle cone\n    d1 = smin(d1, d2, 0.2);\n\n    d2 = sdLine(p, vec2(0.25, 2.0), vec2(0.4, 2.15)); // top cone base\n    d1 = min(d1, d2);\n\n    d2 = sdLine(p, vec2(0.4, 2.15), vec2(0.0, 3.5)); // top cone\n    d1 = min(d1, d2);\n\n    d2 = sdCircle(p - vec2(0.0, 1.3), 0.3); // sphere\n    d1 = smin(d1, d2, 0.1);\n\n    return vec3(d1, MATERIAL_METAL1, 0.0);\n}\n\nvec3 sdRoundBricks(vec3 pos, vec3 size, vec3 offset, float bevel, float rows, float columns, float seed, float material, float materialBias)\n{\n    float r = columns * size.x / PI2;\n\n    float bounds = sdBoxApprox(pos, vec3(r + 0.5 * size.z + offset.z, 0.5 * rows * size.y, r + 0.5 * size.z + offset.z), vec3y1);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    pos.y -= 0.5 * size.y;\n\n    vec3 pos1 = vec3(atan(pos.x, pos.z) / PI2 * columns * size.x, pos.y, length(pos.xz)); // radial coordinates\n\n    float row = floor(pos1.y / size.y + 0.5);\n    row = clamp(row, 0.0, rows - 1.0);\n    pos1.y -= row * size.y;\n    pos1.z -= r;\n\n    float h1 = hash(row + rows + seed);\n    pos1.x -= 0.5 * size.x * mod(row, 2.0); // center\n    pos1.x -= offset.x * (2.0 * h1 - 1.0);\n\n    float column = floor(pos1.x / size.x + 0.5);\n    column = clamp(column, -columns, columns);\n    pos1.x -= column * size.x;\n\n    column = mod(column, columns);\n\n    float h2 = hash(columns * row + column);\n    pos1.z += offset.z * (2.0 * h2 - 1.0);\n\n    float h3 = fract(h1 + h2);\n    float h4 = fract(h1 - h2);\n\n    float d1 = sdBox(pos1, size * 0.5, vec3(0.0), bevel);\n\n    // seal wall\n    float d2 = abs(length(pos.xz) - r) - 0.01;\n    d2 = max(d2, -pos.y);\n    d2 = max(d2, pos.y - (rows - 1.0) * size.y);\n    d1 = min(d1, d2);\n\n    float edge = floor(3.0 * h3);\n    return vec3(d1, material + materialBias * h4, edge);\n}\n\nvec3 sdChimney(vec3 pos)\n{\n    const vec3 size = vec3(0.4, 0.25, 0.15); // brick size\n    const vec3 offset = vec3(0.05, 0.0, 0.01);\n    const float bevel = 0.03;\n    const float rows = 18.0;\n    const float columns = 9.0;\n    const float seed = 0.0;\n\n    return sdRoundBricks(pos, size, offset, bevel, rows, columns, seed, MATERIAL_TILE, 1.0);\n}\n\nvec3 sdChimneyTop(vec3 pos)\n{\n    const float size1 = 0.4;\n    const float thickness1 = 0.01;\n    const float thickness2 = 0.02;\n    const float width1 = 0.2;\n    const float count1 = 7.0;\n\n    float bounds = sdBoxApprox(pos, vec3(0.7, 1.1, 0.7), vec3y(0.9));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec2 p = vec2(length(pos.xz), pos.y); // polar coordinates\n\n    // pipe\n    float d1 = sdLine(p, vec2(0.52, 0.0), vec2(0.0, 0.6)) - 0.1; // segment\n    float d2 = sdLine(p, vec2(0.3, 0.0), vec2(0.15, 1.5)) - 0.02; // segment\n    d1 = min(d1, d2);\n\n    // top part\n    vec3 pos1 = pos;\n    float index = 0.0;\n    pos1.xz = radialMod(pos1.xz, 5.0, index);\n\n    vec3 d = vec3(d1, MATERIAL_METAL1, 0.0);\n\n    pos1 = pos;\n    pos1.y -= 1.38;\n    pos1.xz = radialMod(pos1.xz, count1, index);\n    pos1.x -= 1.2 * size1;\n\n    float width = width1 * sqrt(smoothstep(0.1, -0.9 * size1, pos1.x));\n    float thickness = thickness1 + thickness2 * smoothstep(0.0, -size1, pos1.x);\n    d1 = sdCircle(pos1.xy, size1);\n    d1 = length(vec2(d1, stretchAxis(pos1.z, width)));\n    d1 = max(d1, pos1.x - 0.08);\n    d1 = max(d1, -pos1.y + 0.4 * size1);\n    d1 -= thickness;\n\n    d = minx(d, vec3(d1, MATERIAL_METAL3, 0.0));\n    return d;\n}\n\nvec3 sdBrickWall(vec3 pos, vec2 size)\n{\n    // closest point\n    vec3 c = vec3(clamp(pos.x, 0.0, size.x), clamp(pos.y, 0.0, size.y), 0.0);\n\n    float rows = round(size.y / 0.25);\n    float columns = size.x / 0.5; // clipped by offset, so no need to round\n\n    float row = (c.y / size.y) * rows;\n    float h1 = hash(floor(row)); // row hash\n    float column = (c.x / size.x) * columns + mod(floor(row), 2.0) * 0.5 + h1 * 0.25;\n\n    float h2 = hash(floor(vec2(row, column))); // row+column hash\n\n    float bump = (0.5 - abs(fract(row) - 0.5)) * (0.5 - abs(fract(column) - 0.5)); // bump\n    bump = clamp(bump, 0.0, 0.005); // clip bump\n    bump *= 4.0 * h2; // bump variation\n\n    float d = length(pos - c) - bump;\n    float edge = floor(h2 * 3.0); // material edge group variation\n    return vec3(d, MATERIAL_TILE + 0.99 * h2, edge);\n}\n\nvec3 sdMoominWindow(vec3 pos, float angle)\n{\n    // quater size\n    const float w = 0.3;\n    const float h = 0.4;\n\n    // window\n    const float depth1 = 0.06;\n    const float thickness1 = 0.08;\n    const float bevel1 = 0.01;\n    // divider\n    const float depth2 = 0.04;\n    const float thickness2 = 0.08;\n    const float bevel2 = 0.01;\n    // frame\n    const float depth3 = 0.1;\n    const float thickness3 = 0.1;\n    const float bevel3 = 0.02;\n    // handle\n    const float r4 = 0.07;\n    const float thickness4 = 0.005;\n    const float width4 = 0.015;\n\n    const float segmentOffset = 0.25 * (h - w);\n    const vec3 baseSize = vec3(0.45, 0.06, 0.08);\n\n    float bounds = sdBoxApprox(pos, vec3(1.0, 0.6, 0.6), vec3x(0.5));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    float d1, d2, d3;\n    vec3 pos1;\n    vec2 p;\n\n    // frame\n    pos1 = pos;\n    pos1.z = stretchAxis(pos1.z, depth3 - 2.0 * bevel3);\n    p = pos1.xy; // 2d coordinates\n\n    d1 = sdRoundedRectangle(p, vec2(w, h) + thickness3 - bevel3, vec4(w + thickness3 - bevel3, 0.0, w + thickness3 - bevel3, 0.0));\n    float t = thickness3 * 0.5 - bevel3;\n\n    d1 = abs(d1 + t) - t; // split into 2 borders\n    d1 = max(0.0, d1); // fill shape\n\n    d1 = length(vec2(d1, pos1.z)); // convert to 3d distance\n    d1 -= bevel3;\n    vec3 d = vec3(d1, MATERIAL_PAINTED_WOOD, 1.0);\n\n    // frame base\n    d1 = sdBox(pos + vec3y(h + baseSize.y - 0.001), baseSize - bevel3);\n    d1 -= bevel3;\n    d = minx(d, vec3(d1, MATERIAL_PAINTED_WOOD, 2.0));\n\n    // window\n    pos1 = pos;\n\n    // rotation\n    pos1 -= vec3(w, 0.0, 0.5 * depth1);\n    pos1.xz *= rotation(angle);\n    pos1 += vec3(w, 0.0, 0.5 * depth1);\n\n    p = pos1.xy; // 2d coordinates\n\n    d1 = sdRoundedRectangle(p, vec2(w, h) - bevel1, vec4(w - bevel1, 0.0, w - bevel1, 0.0));\n    t = thickness1 * 0.5 - bevel1;\n    d1 = abs(d1 + t) - t; // split into 2 borders\n    d1 = max(0.0, d1); // fill shape\n    d1 = length(vec2(d1, stretchAxis(pos1.z, depth1 - 2.0 * bevel1))); // convert to 3d distance\n    d1 -= bevel1;\n\n    vec3 d4 = vec3(d1, MATERIAL_WOOD3, 2.0);\n    bool isVertical = p.y > -h + thickness1 + 0.001;\n    d4.yz += 0.99 * fract(isVertical ? (vec2(0.1, 0.01) * vec2(pos1.x + pos1.z, pos1.y) + 0.5) : (vec2(0.01, 0.1) * vec2(pos1.x, pos1.y + pos1.z) + 0.5)); // uv\n    d = minx(d, d4);\n\n    // dividers\n    d1 = length(vec2(max(abs(p.x) - w + thickness2 - bevel2, 0.0), stretchAxis(p.y + segmentOffset, thickness2 - 2.0 * bevel2))); // horizontal segment\n    d1 = max(0.0, d1); // fill shape\n\n    d2 = length(vec2(max(abs(p.y) - h + thickness2 - bevel2, 0.0), stretchAxis(p.x, thickness2 * 0.5 - 2.0 * bevel2))); // vertical segment\n    d2 = max(0.0, d2); // fill shape\n    d1 = min(d1, d2);\n    d1 = length(vec2(d1, stretchAxis(pos1.z, depth2 - 2.0 * bevel2))); // convert to 3d distance\n    d1 -= bevel2;\n    d4 = vec3(d1, MATERIAL_WOOD3, 3.0);\n    isVertical = abs(p.y + segmentOffset) > 0.5 * thickness2 + 0.001;\n    d4.yz += 0.99 * fract(isVertical ? (vec2(0.1, 0.01) * vec2(pos1.x + pos1.z, pos1.y)) + 0.5 : (vec2(0.01, 0.1) * vec2(pos1.x, pos1.y + pos1.z)) + 0.5); // uv\n    d = minx(d, d4);\n\n    // handle\n    vec3 pos2 = pos1;\n    pos2.x += 0.5 * w + 1.5 * thickness1 - bevel1;\n    pos2.y += segmentOffset;\n    d1 = sdCircle(pos2.yz, r4);\n    d1 = length(vec2(d1, stretchAxis(pos2.x, width4)));\n    d1 -= thickness4;\n    d1 = max(d1, pos2.z);\n    d4 = vec3(d1, MATERIAL_METAL2, 3.0);\n    d = minx(d, d4);\n\n    return d;\n}\n\nvec2 sdMoominWindowGlass(vec3 pos, float angle)\n{\n    // quater size\n    const float w = 0.3;\n    const float h = 0.4;\n\n    const float depth = 0.06;\n    const float thickness = 0.01;\n\n    float bounds = sdBoxApprox(pos, vec3(1.0, 0.6, 0.6), vec3x(0.5));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec2(bounds, 0.0);\n    }\n\n    float d1, d2, d3;\n    vec3 pos1;\n    vec2 p;\n\n    // window\n    pos1 = pos;\n\n    // rotation\n    pos1 -= vec3(w, 0.0, 0.5 * depth);\n    pos1.xz *= rotation(angle);\n    pos1 += vec3(w, 0.0, 0.5 * depth);\n\n    p = pos1.xy; // 2d coordinates\n\n    d1 = sdRoundedRectangle(p, vec2(w, h) - depth, vec4(w, 0.0, w, 0.0));\n\n    d1 = max(0.0, d1); // fill shape\n    d1 = length(vec2(d1, stretchAxis(pos1.z, thickness))); // convert to 3d distance\n\n    return vec2(d1, MATERIAL_WINDOW_GLASS);\n}\n\nfloat sdMoominRoomBounds(vec3 pos)\n{\n    const vec3 size = vec3(0.5, 1.0, 1.0);\n\n    float bounds = sdBoxApprox(pos, size, vec3(0.0, 0.0, 0.0));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return bounds;\n    }\n\n    vec3 pos1 = pos;\n\n    float d = abs(pos1.y) - size.y;\n    pos1.xz = abs(pos1.xz);\n    d = max(d, pos1.x - size.x);\n    d = max(d, pos1.z - size.z);\n    d = max(d, pos1.x + pos1.y - size.y); // slope\n\n    return d;\n}\n\nvec3 sdMoominRoom(vec3 pos)\n{\n    vec3 d1, d2, d3;\n\n    float bounds = sdBoxApprox(pos, vec3(1.0, 1.2, 1.0), vec3(0.0, 0.0, 0.5));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    float d = sdMoominRoomBounds(pos);\n\n    d = max(d, -d - 0.1); // exclude inner space\n    d = max(d, -pos.z);\n\n    // window opening\n    vec3 pos1 = pos;\n    pos1.z -= 1.0;\n    d = max(d, -sdSphere(pos1 - vec3y(0.3), 0.4));\n    d = max(d, -sdBox(pos1, vec3(0.4, 0.3, 0.4)));\n\n    d1 = vec3(d, MATERIAL_PAINTED_WOOD, 0.0);\n\n    // window\n    pos1 = pos;\n    pos1 -= vec3(0.0, 0.2, 1.0);\n    d2 = sdMoominWindow(pos1, -2.5);\n    d1 = minx(d1, d2);\n\n    // tiles\n    float seed = max(0.0, sign(pos.x));\n    pos1 = pos;\n    pos1.x = abs(pos1.x);\n    pos1 -= vec3(0.0, 1.0, 0.3);\n    pos1.xz *= rotation_n90;\n    pos1.yz *= rotation_n45;\n    d2 = sdTiles(pos1, vec3(0.5, 0.4, 0.03), vec2(3.0, 3.0), seed + 9.0);\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 sdRopeLadderSegment(vec3 pos, float count, float rope0, float rope1)\n{\n    const float h = 0.3;\n    const float w = 0.8;\n    const float r1 = 0.04; // step radius\n    const float r2 = 0.02; // rope radius\n\n    float bounds = sdBoxApprox(pos - vec3y(rope0), vec3(w, h * count + rope0 + rope1, r1 + r2 + r2), vec3y(-1.0));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    float d;\n\n    float index = clamp((pos.y + h) / (2.0 * h), -count + 1.0, 0.0);\n    float an = 0.2 * (0.5 - hash(floor(index))); // angle\n\n    vec3 pos1 = pos;\n    pos1.y -= floor(index) * 2.0 * h;\n\n    // wood\n    pos1.xy *= rotationApprox(an);\n    d = sdCircle(pos1.zy, r1);\n    d = max(d, 0.0);\n    d = length(vec2(d, stretchAxis(pos1.x, w))); // convert to 3d distance\n    vec3 d1 = vec3(d, MATERIAL_WOOD3, 1.0);\n    d1.yz += vec2(0.01, 0.1) * vec2(pos1.x, pos1.y + pos1.z) + 0.5; // uv\n\n    // rope loops\n    pos1.x = abs(pos1.x) - w * 0.5 + 0.1 + 0.2 * abs(an); // mirror 1\n    float edge = max(0.0, sign(pos1.x)); // separate loops\n    float index2 = sign(pos1.x);\n    pos1.x = abs(pos1.x) - 0.014; // mirror 2\n    pos1.y = -pos1.y;\n    pos1.xy *= rotation_7_5;\n    d = sdCircle(pos1.zy, r1 + r2 * 0.5); // rope size\n    d = length(vec2(d, pos1.x)); // convert to 3d distance\n    d -= r2; // rope thickness\n\n    vec3 d2 = vec3(d, MATERIAL_ROPE, 1.0 + edge);\n    d2.y += 0.99 * fract(sqrt(abs(sin(100.0 * (pos1.x + pos1.y) + index2)))); // uv\n    d1 = minx(d1, d2);\n\n    // rope\n    pos1 = pos;\n    pos1.x = abs(pos1.x) - w * 0.5 + 0.1; // mirror\n    pos1.z += r1 - r2 * 0.5;\n    d = length(pos1.xz);\n    d = max(d, max(pos1.y - rope0 * 2.0 * h, -pos1.y - (count - 1.0 + rope1) * 2.0 * h)); // rope length\n    d -= r2; // thickness\n\n    d2 = vec3(d, MATERIAL_ROPE, 3.0);\n    d2.y += 0.99 * fract(sqrt(abs(sin(100.0 * (pos1.x + pos1.y))))); // uv\n\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 sdRopeLadder(vec3 pos)\n{\n    float bounds = sdBoxApprox(pos, vec3(0.5, 1.2, 1.0), vec3z1);\n    bounds = min(bounds, sdBoxApprox(pos - vec3z(1.8), vec3(0.5, 6.0, 0.2), vec3y(-1.0)));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n    pos1 -= vec3(0.0, -0.52, 1.15);\n    pos1.yz *= rotation_n36;\n    vec3 d1 = sdRopeLadderSegment(pos1, 3.0, 0.4, 0.0); // segment 1\n\n    pos1 = pos;\n    pos1 -= vec3(0.0, -1.57, 0.71) + vec3(0.0, -0.52, 1.15);\n    vec3 d2 = sdRopeLadderSegment(pos1, 14.0, 1.0, 0.6); // segment 2\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 sdOuterWalls(vec3 pos)\n{\n    const vec3 size = vec3(0.5, 3.0, 0.06); // tile size\n    const vec3 offset = vec3(0.0, 0.4, 0.3); // tile offset\n    const float r = 4.0 - 0.5 * size.z;\n    const float h = HOUSE_HEIGHT;\n    const float seed = 0.0;\n\n    float bounds = sdBoxApprox(pos, vec3(r + size.z, 0.5 * h, r + size.z), vec3y1);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    float columns = round(PI2 * r / size.x);\n    float an = atan(pos.x, pos.z);\n\n    vec3 pos1 = vec3(an / PI2 * columns * size.x, pos.y, length(pos.xz)); // radial coordinates\n\n    float column = floor(pos1.x / size.x);\n    pos1.x -= (column + 0.5) * size.x;\n    pos1.z -= r;\n\n    float h1 = hash(column - columns + seed);\n\n    pos1.y -= size.y * 0.5 * mod(column, 2.0); // center\n    pos1.y -= size.y * offset.y * h1;\n\n    float row = floor(pos1.y / size.y + 0.5);\n    pos1.y -= row * size.y;\n\n    float h2 = hash(columns * row + column + seed);\n    float h3 = hash(columns * row + column + seed + 1000.0);\n    float h4 = hash(columns * row + column + seed + 2000.0);\n\n    pos1.z += size.z * offset.z * h2;\n    float d = sdBox(pos1, size * 0.5); // tile\n\n    float edge = floor(3.0 * h3);\n    vec3 d1 = vec3(d, MATERIAL_OUTER_WALL + 0.99 * h4, edge);\n\n    // inner wall\n    d = length(pos.xz) - r + size.z;\n    d = abs(d) - 0.5 * size.z;\n    d = max(0.0, d);\n\n    vec3 d2 = vec3(d, MATERIAL_INNER_WALL + 0.99 * fract(60.0 * (an + PI) / PI2), 0.0);\n    d1 = minx(d1, d2);\n\n    d1.x = max(d1.x, -pos.y);\n    d1.x = max(d1.x, pos.y - h);\n\n    return d1;\n}\n\nfloat sdRectangleFrame(vec3 pos, vec3 size, vec2 thickness, float bevel)\n{\n    float d = sdRectangle(pos.xy, 0.5 * size.xy - bevel, thickness);\n    return length(vec2(d, stretchAxis(pos.z, size.z - 2.0 * bevel))) - bevel;\n}\n\nvec3 sdWindow(vec3 pos, float type)\n{\n    vec3 d = vec3(MAX_DIST, 0.0, 0.0);\n    float d1, d2, d3;\n\n    const float w = 1.0;\n    const float h = 1.4;\n\n    vec3 boundsSize = vec3(w, h, 0.2);\n    boundsSize.x += type >= 3.0 ? 0.6 * w : 0.0;\n    boundsSize.z += type >= 4.0 ? 0.6 * w : 0.0;\n\n    float bounds = sdBoxApprox(pos, boundsSize);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    // window\n    const float depth1 = 0.06;\n    const float thickness1 = 0.1;\n    const float bevel1 = 0.01;\n    // divider\n    const float depth2 = 0.04;\n    const float thickness2 = 0.06;\n    const float bevel2 = 0.01;\n    // frame horizontal segment\n    const float depth3 = 0.2;\n    const float thickness3 = 0.06;\n    const float bevel3 = 0.01;\n    const float ext3 = 0.04;\n    // frame vertical segment\n    const float depth4 = 0.15;\n    const float thickness4 = 0.04; // vertical\n    const float bevel4 = 0.01;\n    // adornment\n    const float depth5 = 0.25;\n    const float depth6 = 0.05;\n\n    const vec3 baseSize = vec3(w + 0.3, 0.2, 0.25);\n\n    vec3 pos1 = pos; // wide window (type 3)\n    pos1.x = abs(pos.x) - 0.5 * w - thickness4;\n\n    vec3 pos2 = pos; // bay window (type 4)\n    pos2.z -= w * 0.55;\n    pos2.x = abs(pos2.x);\n    pos2.xz *= rotation_n20;\n    pos2.x = abs(pos2.x - 0.5 * w) - 0.5 * w;\n    pos2.xz *= rotation_n20;\n\n    pos = type >= 3.0 ? pos1 : pos;\n    pos = type >= 4.0 ? pos2 : pos;\n\n    pos1 = pos;\n\n    // window\n    pos1 = pos;\n    float index = max(0.0, sign(pos1.x));\n    pos1.x = abs(pos1.x) - 0.25 * w;\n\n    d1 = sdRectangleFrame(pos1, vec3(0.5 * w, h, depth1), vec2(thickness1 * 0.5), bevel1);\n    d = minx(d, vec3(d1, MATERIAL_WOOD3, 2.0 + index));\n\n    // dividers\n    pos1.y = abs(pos1.y) - h / 6.0; // mirror\n    d1 = sdBox(pos1, vec3(w / 4.0, 0.5 * thickness2, 0.5 * depth2) - bevel2);\n    d1 -= bevel2;\n    d = minx(d, vec3(d1, MATERIAL_WOOD3, 4.0));\n\n    bool isVertical = abs(pos1.x) > 0.25 * w - thickness2 - bevel2;\n    d.yz += 0.99 * fract(isVertical ? (vec2(0.1, 0.01) * vec2(pos.x, pos.y + pos.z) + 0.5) : (vec2(0.01, 0.1) * vec2(pos.x + pos.y, pos.z) + 0.5)); // uv\n\n    // frame\n    pos1 = pos;\n    pos1.y = abs(pos1.y) - 0.5 * h - thickness3;\n    d1 = sdBox(pos1, vec3(w * 0.5 + 2.0 * thickness4 + ext3, thickness3, depth3) - bevel3); // horizontal\n    d1 -= bevel3;\n    d = minx(d, vec3(d1, MATERIAL_PAINTED_WOOD, 5.0));\n\n    pos1 = pos;\n    pos1.x = abs(pos1.x) - 0.5 * w - thickness4;\n    d1 = sdBox(pos1, vec3(thickness4, 0.5 * h, depth4) - bevel3); // vertical\n    d1 -= bevel3;\n    d = minx(d, vec3(d1, MATERIAL_PAINTED_WOOD, 6.0));\n\n    // adornment\n    pos1 = pos;\n    pos1.x = abs(pos1.x) - 0.25 * w; // mirror\n    pos1.y -= 0.5 * h + 2.0 * thickness3; // base height\n\n    // pointed pediment\n    pos2 = pos1;\n    pos2.z = stretchAxis(pos2.z, depth5);\n    float h2 = 0.3 * w;\n    pos2.y -= h2;\n    pos2.xy *= rotation_n45;\n    d1 = sdBox(pos2, vec3(w * 0.5, thickness4, depth6) - bevel4);\n    d2 = sdBoxApprox(pos2 + vec3(0.0, h2, 0.0), vec3(w * 0.5, h2, 0.0));\n    d1 = min(d1, d2);\n    d1 -= bevel3;\n\n    // segmental pediment\n    pos2 = pos1;\n    pos2.z = stretchAxis(pos2.z, depth5);\n    pos2.x += w * 0.25;\n    d2 = sdCircle(pos2.xy, w * 0.5);\n    d3 = d2;\n    d2 = max(d2, 0.0);\n    d2 = length(vec2(d2, pos2.z));\n\n    d3 -= thickness4;\n    d3 = abs(d3) - thickness4 + bevel4;\n    d3 = max(d3, 0.0);\n    d3 = length(vec2(d3, stretchAxis(pos2.z, depth6)));\n    d2 = min(d2, d3);\n    d2 -= bevel4;\n\n    d1 = type < 1.0 ? d1 :\n        (type < 2.0 ? d2 : MAX_DIST); // select type\n\n    d1 = max(d1, -pos1.z + 0.01);\n\n    d1 = max(d1, -pos1.y);\n    d = minx(d, vec3(d1, MATERIAL_PAINTED_WOOD, 7.0));\n\n    return d;\n}\n\nfloat sdWindowsBounds(vec3 pos)\n{\n    const float floorHeight = HOUSE_HEIGHT / 3.0;\n\n    float bounds = sdBoxApprox(pos, vec3(4.5, 6.2, 4.5), vec3y1);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return bounds;\n    }\n\n    vec3 pos1 = pos;\n    float row = clamp(floor(pos1.y / floorHeight), 0.0, 2.0);\n    pos1.y += 0.1;\n    pos1.y -= (row + 0.5) * floorHeight;\n\n    float column = 0.0;\n    pos1.xz *= rotation_30;\n    pos1.xz = radialMod(pos1.xz, 6.0, column);\n    pos1.xz *= rotation_n90;\n\n    bool isWideWindow = row == 0.0 && column == 0.0;\n    bool isBayWindow = row == 1.0 && column == -1.0;\n\n    vec3 pos2 = pos1;\n    pos2.xz *= rotation_n7_5;\n    pos1 = isBayWindow ? pos2 : pos1; // shift bay window\n\n    pos1.z -= 4.0;\n    float w = 0.5;\n    w += isWideWindow ? 0.5 : 0.0; // wide window\n    w += isBayWindow ? 0.8 : 0.0; // bay window\n    float d1 = sdBoxApprox(pos1, vec3(w, 0.75, 0.4));\n    d1 -= 0.03;\n\n    // mask\n    pos1 = pos;\n    pos1.z = abs(pos1.z); // front and back windows\n    pos1 -= vec3(0.0, 2.4, 4.0);\n    float d2 = -sdBoxApprox(pos1, vec3(0.7, 1.2, 0.2));\n    d1 = max(d1, d2);\n\n    return d1;\n}\n\nvec3 sdFrontWindowDecoration(vec3 pos)\n{\n    const float s1 = 0.21; // top diamond size\n    const float s2 = 0.14; // middle shpere radius\n    const float h2 = 0.12; // middle shpere height\n    const float s3 = 0.04; // base thickness\n    const float r3 = 0.02; // base corner radius\n    const float w3 = 0.3; // base depth\n    const float h3 = 0.1; // base height\n    const float width4 = 0.1; // pendiment wings\n    const float length4 = 0.7;\n    const float thickness4 = 0.03;\n    const float depth4 = 0.4;\n    const float bevel4 = 0.01;\n    const float curve4 = 0.25;\n    const float gap4 = 0.2;\n    const float r5 = 1.5; // pendiment surface size\n    const float h5 = 0.55;\n    const float thickness5 = 0.2;\n    const float bevel5 = 0.01;\n    const float r6 = 1.8; // pendiment surface cut radius\n\n    float bounds = sdBoxApprox(pos, vec3(1.0, 0.5, 0.3), vec3y(-0.3));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    float d1, d2, d3;\n\n    vec3 pos1 = pos;\n    pos1.z -= 0.3;\n    pos1.y -= 0.28;\n\n    vec3 pos2 = pos1;\n\n    // top diamond\n    pos2 = abs(pos2);\n    pos2.y -= s1;\n    pos2.xz *= rotation_n45;\n    pos2.zy *= rotation_25;\n\n    d1 = pos2.z;\n\n    // middle sphere\n    pos2 = pos1;\n    pos2.y += 1.3 * s1;\n    d2 = sdEllipsoid(pos2, vec3(s2, h2, s2));\n    d1 = smin(d1, d2, 0.04);\n\n    // base\n    pos2.y += h2;\n    vec3 pos3 = pos2;\n    pos3.z += s3 + w3 - r3;\n    d2 = sdRectangle(pos3.yz, vec2(h3, w3));\n    d2 -= r3;\n    d2 = length(vec2(d2, pos3.x));\n    d2 -= s3;\n    d2 = max(d2, pos3.y);\n    d2 = max(d2, -pos3.z);\n\n    d1 = smin(d1, d2, 0.05);\n\n    // pediment wings\n    pos1 = pos;\n    pos1.y -= thickness4 * 0.5;\n    pos1.x = abs(pos1.x);\n    pos1.x -= gap4;\n    d2 = abs(pos1.y + curve4 * smoothstep(0.0, length4, pos1.x));\n    d2 -= thickness4;\n    d2 = max(0.0, d2);\n    d2 = length(vec2(d2, stretchAxis(pos1.z, depth4)));\n    d2 = max(d2, -pos1.x);\n    d2 = max(d2, pos1.x - length4);\n    d2 -= bevel4;\n\n    d1 = min(d1, d2);\n\n    // pendiment surface\n    pos1 = pos;\n    pos1.y += r5;\n    d2 = sdCircle(pos1.xy, r5);\n    d2 = max(0.0, d2); // fill\n    pos1.y -= r5 - h5;\n    d2 = max(d2, -pos1.y); // cut bottom part\n\n    pos2 = pos1;\n    pos2.x = abs(pos2.x);\n    pos2.x -= 0.95;\n    d3 = sdCircle(pos2.xy, 0.2 * r6);\n    d2 = max(d2, -d3); // cut side circles\n\n    d2 = length(vec2(d2, stretchAxis(pos1.z, thickness5)));\n    d2 -= bevel5;\n    d1 = min(d1, d2);\n\n    return vec3(d1, MATERIAL_PAINTED_WOOD, 0.0);\n}\n\nvec3 sdBayWindowTiles(vec3 pos)\n{\n    const vec3 tileSize = vec3(0.5, 0.5, 0.03);\n\n    vec3 pos1 = pos;\n    pos1.y -= 1.62;\n\n    float bounds = sdBoxApprox(pos1, vec3(1.8, 0.8, 1.3), vec3y(-1.0));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    pos1.z -= 0.05;\n    pos1.z += pow2(abs(pos.x) * 0.67);\n    pos1.yz *= rotation_n45;\n\n    float d = sdBox(pos1, vec3(1.5, 0.55, 0.08), vec3(0.0, -1.0, -1.0), 0.0);\n    vec3 d1 = vec3(d, MATERIAL_PAINTED_WOOD, 0.0);\n\n    vec3 d2 = sdTiles(pos1 - vec3z(tileSize.z), tileSize, vec2(7.0, 3.0), 4.0);\n    d2.x *= 0.8; // approximation\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 sdBayWindowSupport(vec3 pos)\n{\n    // base\n    const float bevel1 = 0.01;\n\n    // support\n    const float bevel2 = 0.01;\n    const float gap2 = 0.3;\n    const float offset2 = 0.2;\n    const vec3 size2 = vec3(0.12, 0.6, 0.08);\n\n    float bounds = sdBoxApprox(pos, vec3(1.2, 1.4, 0.8), vec3y(-0.2));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n    pos1.y += 0.1;\n    pos1.y = abs(pos1.y);\n    pos1.y -= 0.76;\n    pos1.z -= 0.11;\n    float d = sdBox(pos1, vec3(1.05, 0.06, 0.25) - bevel1);\n    d -= bevel1;\n    vec3 d1 = vec3(d, MATERIAL_PAINTED_WOOD, 5.0);\n\n    pos1 = pos;\n\n    pos1.y += 1.15;\n\n    vec3 pos2 = pos1;\n    pos2.z -= 0.1;\n    pos2.z -= abs(pos.x) < gap2 * 0.5 ? offset2 : 0.0;\n    pos2.yz *= rotation_45;\n    pos2.x = abs(pos2.x) - gap2;\n    pos2.x = abs(pos2.x) - gap2;\n    d = sdBox(pos2, size2 - bevel2);\n    d -= bevel2;\n    d = max(d, -pos1.z);\n    d = max(d, pos1.y - 0.5 * size2.y);\n\n    vec3 d2 = vec3(d, MATERIAL_PAINTED_WOOD, 1.0);\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 sdWindows(vec3 pos)\n{\n    const float floorHeight = HOUSE_HEIGHT / 3.0;\n\n    float bounds = sdBoxApprox(pos, vec3(4.5, HOUSE_HEIGHT / 2.0, 4.5), vec3y1);\n    bounds = max(bounds, -sdBoxApprox(pos, vec3(2.8, 6.0, 2.8), vec3y1));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n\n    float row = clamp(floor(pos1.y / floorHeight), 0.0, 2.0);\n    pos1.y -= (row + 0.5) * floorHeight;\n\n    float column = 0.0;\n    pos1.xz *= rotation_30;\n    pos1.xz = radialMod(pos1.xz, 6.0, column);\n    pos1.xz *= rotation_n90;\n\n    bool isWideWindow = row == 0.0 && column == 0.0;\n    bool isBayWindow = row == 1.0 && column == -1.0;\n\n    vec3 pos2 = pos1;\n\n    vec3 pos3 = pos2;\n    pos3.xz *= rotation_n7_5;\n    pos2 = isBayWindow ? pos3 : pos2; // shift bay window\n\n    pos2.y += 0.1;\n    pos2.z -= 3.89;\n    float style = row;\n    style += isWideWindow ? 3.0 : 0.0;\n    style += row == 0.0 && column == -1.0 ? 2.0 : 0.0; // -1,0 doesn't have decoration\n    style += row == 1.0 && column == 1.0 ? 1.0 : 0.0; // 1,1 has entrance decoration\n    style += isBayWindow ? 3.0 : 0.0;\n\n    vec3 d1 = sdWindow(pos2, style);\n\n    // radial bounds\n    pos2 = pos1;\n    pos2.x = abs(pos2.x);\n    pos2.xz *= rotation_n30;\n    pos2.x -= 0.1;\n    d1.x = min(d1.x, -pos2.x);\n\n    pos2 = pos;\n    pos2.y -= 1.5 * floorHeight + 1.25;\n    pos2.z -= 3.9;\n    vec3 d2 = sdFrontWindowDecoration(pos2);\n\n    pos2 = pos;\n    pos2.y -= 1.5 * floorHeight;\n    pos2.xz *= rotation_n120;\n    pos2.xz *= rotation_n7_5;\n    pos2.z -= 3.9;\n    vec3 d3 = sdBayWindowTiles(pos2);\n    d2 = minx(d2, d3);\n\n    d3 = sdBayWindowSupport(pos2);\n    d2 = minx(d2, d3);\n\n    d2.x = max(d2.x, -length(pos.xz) + 3.9);\n    d1 = minx(d1, d2);\n\n    // mask\n    pos1 = pos;\n    pos1.z = abs(pos1.z); // front and back windows\n    pos1 -= vec3(0.0, 2.4, 4.0);\n    d2 = vec3(-sdBoxApprox(pos1, vec3(0.7, 1.3, 0.5)), 0.0, 0.0);\n    d1 = maxx(d1, d2);\n\n    return d1;\n}\n\nvec2 sdWindowsGlass(vec3 pos)\n{\n    const float floorHeight = HOUSE_HEIGHT / 3.0;\n\n    float bounds = sdBoxApprox(pos, vec3(4.5, HOUSE_HEIGHT / 2.0, 4.5), vec3y1);\n    bounds = max(bounds, -sdBoxApprox(pos, vec3(2.8, 6.0, 2.8), vec3y1));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec2(bounds, 0.0);\n    }\n\n    vec3 pos1 = pos;\n\n    float row = clamp(floor(pos1.y / floorHeight), 0.0, 2.0);\n    pos1.y += 0.1;\n    pos1.y -= (row + 0.5) * floorHeight;\n\n    float column = 0.0;\n    pos1.xz *= rotation_30;\n    pos1.xz = radialMod(pos1.xz, 6.0, column);\n    pos1.xz *= rotation_n90;\n\n    bool isWideWindow = row == 0.0 && column == 0.0;\n    bool isBayWindow = row == 1.0 && column == -1.0;\n\n    vec3 pos2 = pos1;\n\n    vec3 pos3 = pos2;\n    pos3.xz *= rotation_n7_5;\n    pos2 = isBayWindow ? pos3 : pos2; // shift bay window\n\n    pos2.z -= 3.89;\n\n    float w = 0.5;\n    w += isWideWindow ? 0.5 : 0.0;\n\n    pos3 = pos2; // bay window\n    pos3.x = abs(pos3.x);\n    pos3.xz *= rotation_n20;\n    pos3.x = abs(pos3.x - 0.65 * w) - 0.65 * w;\n    pos3.xz *= rotation_n20;\n    pos3.z -= 1.1 * w;\n    pos2 = isBayWindow ? pos3 : pos2;\n\n    float d1 = sdBoxApprox(pos2, vec3(w, 0.8, 0.005));\n\n    // radial bounds\n    pos2 = pos1;\n    pos2.x = abs(pos2.x);\n    pos2.xz *= rotation_n30;\n    pos2.x -= 0.1;\n    d1 = min(d1, -pos2.x);\n\n    // mask\n    pos1 = pos;\n    pos1.z = abs(pos1.z); // front and back windows\n    pos1 -= vec3(0.0, 2.4, 4.0);\n    float d2 = -sdBoxApprox(pos1, vec3(0.7, 1.3, 0.5));\n    d1 = max(d1, d2);\n\n    return vec2(d1, MATERIAL_WINDOW_GLASS);\n}\n\nvec3 sdHouseBase(vec3 pos)\n{\n    const float bevel = 0.2;\n    const float r0 = 4.0 + bevel;\n\n    const float r1 = 4.5 - bevel;\n    const float h1 = 0.6 - bevel;\n\n    const float r2 = 4.8 - bevel;\n    const float h2 = 0.4 - bevel;\n\n    float bounds = sdBoxApprox(pos, vec3(r2, h1, r2) + bevel);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec2 p = vec2(length(pos.xz), pos.y);\n    vec2 uv = vec2((atan(pos.z, pos.x) + PI) / PI2, 0.0);\n\n    // slope\n    vec2 p1 = vec2(r1, h1);\n    vec2 p2 = vec2(r2, h2);\n    float t = clamp(lineIntersection(p, p1, p2), 0.0, 1.0);\n    vec2 c1 = p1 + t * (p2 - p1); // closest point on slope\n\n    // closest point\n    vec2 c2 = p.x > r1 ? (p.y > h2 ? c1 : vec2(r2, max(p.y, 0.0))) : vec2(max(p.x, r0), h1);\n\n    float d = length(p - c2);\n\n    uv.y = (c2.x + max(h2 - c2.y, 0.0)) / (r2 + h2);\n\n    vec2 v = d < 0.21 ? voronoi(uv * 10.0 * vec2(4.0, 1.0)) : vec2(0.0);\n\n    d -= bevel - 0.1 * v.x;\n\n    return vec3(d, MATERIAL_BASE_ROCK + 0.99 * v.x, 1.0);\n}\n\nvec3 sdPostBase(vec3 pos, vec2 size, float style) // 1 - mirror, 2 - 90 degrees, 3 - both\n{\n    // half size\n    const float bevel = 0.01;\n\n    const vec2 thickness = vec2(0.04, 0.08);\n    const float depth = 0.02;\n\n    float bounds = sdBoxApprox(pos, size.xyx);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    float d1 = sdBox(pos, size.xyx - bevel);\n    d1 -= bevel;\n\n    vec3 d = vec3(d1, MATERIAL_PAINTED_WOOD, 1.0);\n\n    vec3 pos1 = pos;\n    pos1.xz = style == 1.0 || style == 3.0 ? abs(pos1.xz) : pos1.xz; // mirror\n    pos1.xz = style >= 2.0 && pos1.z < pos1.x ? pos1.zx : pos1.xz; // 90 degree mirror\n\n    d1 = sdBox(pos1 - vec3z(size.x), vec3(size - thickness, depth));\n    d = maxx(d, vec3(-d1, MATERIAL_PAINTED_WOOD, 2.0));\n\n    return d;\n}\n\nvec3 sdPost(vec3 pos, vec2 size)\n{\n    const float curve = 1.5;\n    const float skew = 0.07;\n    const float bevel = 0.02;\n\n    vec2 p = vec2(length(pos.xz), pos.y);\n\n    float r = size.x;\n    float h = size.y;\n\n    float bounds = sdBoxApprox(pos, size.xyx);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec2 p1 = p;\n    p1.y = abs(p1.y); // mirror\n\n    vec2 p2 = p1;\n    p2.y -= h - bevel;\n    float d1 = p2.y <= 0.0 ? length(p2) - r + bevel : length(vec2(max(p2.x - r + bevel, 0.0), p2.y)); // bottom half of a sphere\n    d1 -= bevel;\n\n    // slice of a large sphere\n    float h1 = h - r;\n    float r1 = curve * (r * r + h1 * h1) / (2.0 * r); // larger sphere radius\n    float d2 = length(p + vec2(r1 - 1.0 * r, skew * h)) - r1;\n    d2 = max(d2, p1.y - h + r); // clip sphere\n    d1 = smin(d1, d2, 0.05);\n\n    return vec3(d1, MATERIAL_PAINTED_WOOD, 1.0);\n}\n\nvec3 sdPostCap(vec3 pos, float r)\n{\n    const float bevel = 0.03;\n    const float petals = 5.0;\n\n    vec2 p = vec2(length(pos.xz), pos.y);\n\n    float bounds = sdBoxApprox(pos, vec3(r, 1.5 * r, r), vec3y1);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    // base\n    vec2 p1 = p;\n    float d1 = length(p1 - vec2y(r)) - r;\n\n    // petals\n    vec2 p2 = p;\n    float an = atan(pos.z, pos.x);\n    float offset1 = 1.0 - pow2(2.0 * (mod(petals * an / PI2, 1.0) - 0.5)); // petals offset\n    float r1 = r * (1.0 + 0.4 * offset1 * smoothstep(0.0, r, p.x)); // petals radius\n\n    p2.y -= 3.2 * r - r1;\n    float d2 = p2.y > 0.0 ? (length(p2) - r1 + bevel) : length(vec2(max(p2.x - r1 + bevel, 0.0), p2.y)); // top half of a sphere\n    d2 -= bevel;\n    d1 = min(d1, d2);\n\n    return vec3(d1, MATERIAL_PAINTED_WOOD, 2.0);\n}\n\n// corbel\nvec3 sdPoleSupport(vec3 pos, float gap, float style) // 1 - mirror, 2 - 90 degrees, 3 - both\n{\n    const float h = 0.21;\n    const float w = 0.4;\n    const float depth = 0.15;\n    const float bevel = 0.02;\n\n    pos.y += 2.0 * h;\n\n    pos.xz = -pos.xz;\n    pos.xz = style == 1.0 || style == 3.0 ? abs(pos.xz) : pos.xz; // mirror\n    pos.xz = style >= 2.0 && pos.x < pos.z ? pos.zx : pos.xz; // 90 degree mirror\n\n    pos.x -= gap;\n\n    float bounds = sdBoxApprox(pos - vec3(w, h, 0.0), vec3(w, h, depth));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    float d1 = sdRectangleApprox(pos.xy - vec2(w, h), vec2(w - bevel, h - bevel));\n    float d2 = sdEllipse(pos.xy - vec2x(2.0 * w), vec2(2.0 * w + bevel, 2.0 * h + bevel));\n    d1 = max(d1, -d2);\n    d1 = max(0.0, d1);\n    d1 = length(vec2(d1, stretchAxis(pos.z, depth)));\n    d1 -= bevel;\n\n    return vec3(d1, MATERIAL_PAINTED_WOOD, 0.0);\n}\n\nvec3 sdPorchDoorHandle(vec3 pos)\n{\n    const vec2 size = vec2(0.045, 0.07); // door handle base size\n    const float r = 0.015; // door handle radius\n    const float width = 0.18; // door handle length\n    const float depth = 0.15; // door handle depth\n    const float bevel = 0.005;\n\n    float bounds = sdBoxApprox(pos, vec3(depth, size.x, 2.0 * size.x), vec3x(0.5));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 100.0, 0.0);\n    }\n\n    // handle base\n    vec3 pos1 = pos;\n    float d1 = sdCircle(pos1.xy, size.x - bevel);\n    d1 = max(0.0, d1);\n    d1 = length(vec2(d1, stretchAxis(pos.z, size.y - 2.0 * bevel)));\n    d1 -= bevel;\n    vec3 d = vec3(d1, MATERIAL_METAL4, 7.0);\n\n     // handle\n    pos1 = pos;\n    pos1 -= vec3(width * 0.5, 0.0, depth * 0.5);\n    pos1.x += 0.5 * width;\n    pos1.z = -pos1.z;\n    pos1.xz = pos1.x > pos1.z ? pos1.xz : pos1.zx;\n    d1 = length(pos1.xz - vec2(clamp(pos1.x, 0.0, width), 0.0));\n    d1 = length(vec2(d1, pos1.y));\n    d1 -= r;\n\n    d = minx(d, vec3(d1, MATERIAL_METAL4, 8.0));\n    return d;\n}\n\nfloat sdPorchDoorBounds(vec3 pos)\n{\n    // half size\n    const float w = 0.7;\n    const float h = 1.1;\n    const float depth = 0.25;\n\n    float bounds = sdBoxApprox(pos, vec3(w, h, depth));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return bounds;\n    }\n\n    float d = sdRoundedRectangle(pos.xy, vec2(w, h), vec4(w, 0.0, w, 0.0));\n    d = max(0.0, d); // fill\n    d = length(vec2(d, stretchAxis(pos.z, depth)));\n    d -= 0.01;\n\n    return d;\n}\n\nvec3 sdPorchDoor(vec3 pos)\n{\n    // half size\n    const float w = 0.7;\n    const float h = 1.1;\n    const float width1 = 0.08; // door frame width\n    const float depth1 = 0.04; // door frame depth\n    const float width2 = (w - width1) / 4.0; // bars width\n    const float depth2 = 0.03; // bars depth\n    const float width31 = 0.015; // window dividers\n    const float width32 = 0.035; // window frame width\n    const float depth3 = 0.035; // window frame depth\n    const float width4 = 0.05; // lintel width\n    const float depth4 = 0.25; // lintel depth\n    const float r1 = 0.5 * w; // window radius\n    const float r2 = 0.2 * w; // window dividers size\n    const float bevel = 0.01;\n\n    float bounds = sdBoxApprox(pos, vec3(w + depth4, h + depth4, 0.2));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 pos1;\n    float d1, d2, d3, d4;\n\n    pos.z = abs(pos.z); // mirror\n\n    // base shape\n    float baseShape = sdRoundedRectangle(pos.xy, vec2(w, h) - bevel, vec4(w - bevel, 0.0, w - bevel, 0.0));\n\n    // window opening\n    pos1 = pos;\n    pos1.y -= h - w;\n    float windowOpening = sdCircle(pos1.xy, r1);\n\n    // window\n    pos1.xy = abs(pos1.xy); // mirror\n    pos1.xy = pos1.x < pos1.y ? pos1.yx : pos1.xy; // mirror 90 degrees\n\n    // window dividers\n    d1 = abs(r2 - pos1.x - pos1.y) * 0.7071067; // diagonal distance\n    d1 = pos1.x > r2 ? min(pos1.y, d1) : d1; // perpendicular distance\n    d1 = max(d1, windowOpening); // clip\n    d1 -= width31 - bevel; // add thickness\n    d1 = max(0.0, d1); // fill\n\n    // window perimeter\n    d2 = windowOpening;\n    d2 = abs(d2) - width32 + bevel; // add thickness;\n    d2 = max(0.0, d2); // fill\n    d1 = min(d1, d2);\n\n    d1 = length(vec2(d1, stretchAxis(pos1.z, depth3 - 2.0 * bevel)));\n    d1 -= bevel;\n\n    vec3 d = vec3(d1, MATERIAL_PAINTED_WOOD, 1.0);\n\n    // vertical bars\n    pos1 = pos;\n    float column = floor(pos1.x / width2 + 0.5);\n    pos1.x -= column * width2;\n    d1 = abs(pos1.x) - 0.5 * (width2 - bevel);\n    d1 = max(0.0, d1);\n    d1 = length(vec2(d1, stretchAxis(pos1.z, depth2 - 2.0 * bevel)));\n    d1 -= bevel;\n\n    d2 = max(baseShape + 0.5 * width1 - bevel, -windowOpening); // window opening\n    d2 = max(0.0, d2); // fill\n    d1 = max(d1, d2); // intersection\n\n    d = minx(d, vec3(d1, MATERIAL_PAINTED_WOOD, 2.0 + mod(column, 2.0)));\n\n    // door frame\n    d1 = baseShape;\n    d1 += width1 - bevel;\n    d1 = abs(d1) - width1 + bevel;\n    d1 = max(0.0, d1);\n\n    // door frame horizontal bar\n    d2 = sdRectangle(pos.xy + vec2y(0.5 * w - width1), vec2(w - bevel, width1 - bevel));\n    d2 = max(0.0, d2);\n    d1 = min(d1, d2);\n\n    d1 = length(vec2(d1, stretchAxis(pos.z, depth1 - 2.0 * bevel)));\n    d1 -= bevel;\n\n    d = minx(d, vec3(d1, MATERIAL_PAINTED_WOOD, 5.0));\n\n    // lintel\n    d1 = baseShape;\n    d1 -= width4 + bevel;\n    d1 = abs(d1) - width4 + bevel;\n    d1 = max(0.0, d1);\n    d1 = length(vec2(d1, stretchAxis(pos.z, depth4 - 2.0 * bevel)));\n    d1 -= bevel;\n    d1 = max(d1, -pos.y - h + 0.01);\n    d = minx(d, vec3(d1, MATERIAL_PAINTED_WOOD, 6.0));\n\n    // door handle\n    pos1 = pos;\n    pos1.xy += vec2(w - width1 * 1.3, 0.5 * w - width1);\n    d = minx(d, sdPorchDoorHandle(pos1));\n\n    return d;\n}\n\nvec2 sdPorchDoorGlass(vec3 pos)\n{\n    float bounds = sdBoxApprox(pos, vec3(0.4, 0.4, 0.05));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec2(bounds, 0.0);\n    }\n\n    float d = sdCircle(pos.xy, 0.35);\n    d = max(0.0, d);\n    d = length(vec2(d, stretchAxis(pos.z, 0.01)));\n\n    float m = pos.x * pos.y > 0.0 ? MATERIAL_DOOR_GLASS1 : MATERIAL_DOOR_GLASS2;\n    m = abs(pos.x) + abs(pos.y) > 0.12 ? m : MATERIAL_DOOR_GLASS3;\n\n    return vec2(d, m);\n}\n\nfloat sdFenceRails(vec3 pos, float gridSize)\n{\n    const float width = 0.15;\n    const float depth = 0.1;\n    const float bevel = 0.02;\n\n    pos.z = stretchAxis(pos.z + gridSize, 2.0 * gridSize) - 1.5 * gridSize; // length\n    pos.xz = pos.z < pos.x ? pos.zx : pos.xz; // mirror 90 degrees\n\n    float bounds = sdBoxApprox(pos, vec3(5.5 * gridSize, depth, width));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return bounds;\n    }\n\n    float d = sdRectangle(pos.xz, vec2(5.5 * gridSize, width) - bevel);\n    d = max(0.0, d); // fill\n    d = length(vec2(d, stretchAxis(pos.y, depth - bevel * 2.0))); // depth\n    d -= bevel;\n\n    return d;\n}\n\nvec3 sdPorchFloor(vec3 pos, float gridSize)\n{\n    const float thickness = 0.02; // floor thickness\n    const float height = 0.6; // base height\n    const float bevel = 0.02;\n    const float baseGridSize = 0.7;\n\n    float bounds = sdBoxApprox(pos, vec3(gridSize * 7.5, height * 0.5, gridSize * 4.0), vec3(0.0, 1.0, -1.0));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    // bars\n    vec3 pos1 = pos;\n    pos1.y -= height - thickness;\n    pos1.z += 4.0 * gridSize;\n    float index = floor(pos1.x / gridSize + 0.5);\n    index = clamp(index, -7.0, 7.0);\n    pos1.x -= index * gridSize;\n    float d = sdRectangle(pos1.xz, gridSize * vec2(0.5, 4.0) - bevel);\n    d = max(0.0, d);\n    d = length(vec2(d, stretchAxis(pos1.y, 2.0 * thickness - bevel * 2.0)));\n    d -= bevel;\n    vec3 d1 = vec3(d, MATERIAL_WOOD4, 1.0 + mod(index, 2.0));\n    d1.yz += 0.99 * fract(vec2(0.1, 0.01) * pos.xz + 0.1 * index); // uv\n\n    // base\n    pos1 = pos;\n    pos1.z += 4.0 * gridSize;\n    float gridSize1 = gridSize * baseGridSize;\n    vec2 index1 = floor(pos1.xz / gridSize1 + 0.5);\n    index1 = clamp(index1, vec2(-10.0, -5.0), vec2(10.0, 5.0));\n    pos1.xz -= index1 * gridSize1;\n\n    d = sdRectangle(pos1.xz, gridSize1 * vec2(0.5) - bevel);\n    d = max(0.0, d); // fill\n    d = length(vec2(d, stretchAxis(pos1.y - (height - 2.0 * thickness) * 0.5, height - 2.0 * thickness - bevel * 2.0))); // height\n    d -= bevel;\n    vec3 d2 = vec3(d, MATERIAL_WOOD4, 4.0 + mod(index1.x, 2.0) + mod(index1.y, 2.0));\n    d2.yz += 0.99 * fract(vec2(0.1, 0.01) * vec2(pos.x + pos.z, pos.y) + 0.1 * index1); // uv\n\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 sdPorchStairs(vec3 pos, float gridSize)\n{\n    const float thickness = 0.02; // floor thickness\n    const float height = 0.2; // step height\n    const float depth = 0.4; // step depth\n    const float ext = 0.05; // step extension\n    const float bevel = 0.02;\n    const float baseGridSize = 0.7;\n\n    float gridSize1 = gridSize * baseGridSize;\n\n    pos.z += ext;\n\n    vec3 pos1 = pos;\n    pos1 -= vec3(0.0, height, depth);\n    float bounds = sdBoxApprox(pos1, vec3(gridSize1 * 2.5, height, depth) + ext);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    // top step\n    pos1 = pos;\n\n    float index = floor(pos1.x / gridSize1 + 0.5);\n    index = clamp(index, -2.0, 2.0);\n\n    pos1 -= vec3(index * gridSize1, height - thickness, 0.5 * depth);\n    float d = sdBox(pos1, vec3(gridSize1 * 0.5, height - thickness, depth * 0.5) - bevel);\n    d -= bevel;\n    vec3 d1 = vec3(d, MATERIAL_WOOD4, 1.0 + mod(index, 2.0));\n    d1.yz += 0.99 * fract(vec2(0.1, 0.01) * vec2(pos.x + pos.z, pos.y) + 0.1 * index); // uv\n\n    pos1 = pos;\n    pos1 -= vec3(0.0, 2.0 * height - thickness, 0.5 * depth + 0.5 * ext);\n    d = sdBox(pos1, vec3(gridSize1 * 2.5 + ext, thickness, (depth + ext) * 0.5) - bevel);\n    d -= bevel;\n    vec3 d2 = vec3(d, MATERIAL_WOOD4, 4.0);\n    d2.yz += 0.99 * fract(0.5 + vec2(0.01, 0.1) * pos.xz); // uv\n    d1 = minx(d1, d2);\n\n    // bottom step\n    pos1 = pos;\n    pos1 -= vec3(index * gridSize1, height * 0.5 - thickness, 1.5 * depth);\n    d = sdBox(pos1, vec3(gridSize1 * 0.5, height * 0.5 - thickness, depth * 0.5) - bevel);\n    d -= bevel;\n    d2 = vec3(d, MATERIAL_WOOD4, 3.0 + mod(index, 2.0));\n    d2.yz += 0.99 * fract(vec2(0.1, 0.01) * vec2(pos.x + pos.z, pos.y) + 0.1 * index); // uv\n    d1 = minx(d1, d2);\n\n    pos1 = pos;\n    pos1 -= vec3(0.0, height - thickness, 1.5 * depth + 0.5 * ext);\n    d = sdBox(pos1, vec3(gridSize1 * 2.5 + ext, thickness, (depth + ext) * 0.5) - bevel);\n    d -= bevel;\n    d2 = vec3(d, MATERIAL_WOOD4, 4.0);\n    d2.yz += 0.99 * fract(0.5 + vec2(0.01, 0.1) * pos.xz); // uv\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 sdPorchChair(vec3 pos)\n{\n    // seat\n    const float w1 = 0.25;\n    const float thickness1 = 0.04;\n\n     // back\n    const float h2 = 0.35;\n    const float thickness2 = 0.01;\n\n    const float h3 = 0.2; // legs length (half)\n    const float r3 = 0.025; // legs radius\n    const float bevel = 0.015;\n\n    float bounds = sdBoxApprox(pos, vec3(w1, h2 + h3, w1), vec3y1);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 d = vec3(MAX_DIST, 0.0, 0.0);\n\n    pos.x = abs(pos.x);\n\n    vec3 pos1 = pos;\n    pos1.y -= 2.0 * h3;\n    pos1.z -= w1;\n\n    // back\n    vec3 pos2 = pos1;\n    pos2.yz *= rotation_7_5;\n    pos2 -= vec3(0.0, h2 * 0.8, -2.0 * thickness1);\n\n    float d1 = sdEllipse(pos2.xy, vec2(w1, h2) - bevel);\n    d1 = max(0.0, d1); // fill\n    d1 = length(vec2(d1, stretchAxis(pos2.z, thickness2 - 2.0 * bevel))); // add thickness\n\n    pos2.x -= w1 * 0.4;\n    float d2 = sdEllipse(pos2.xy, vec2(w1 * 0.3, h2 * 0.6) + bevel); // opening\n    d2 = max(d2, abs(pos2.z) - 2.0 * (thickness2 + 2.0 * bevel)); // add thickness\n    d2 = d2 < 1.0 ? d2 * 0.5 : d2; // compansate approximation\n\n    d1 = max(d1, -d2); // clip openings\n    d1 = max(d1, -pos1.y + thickness1); // clip bottom part\n    d1 -= bevel;\n\n    d = minx(d, vec3(d1, MATERIAL_PAINTED_WOOD, 1.0));\n\n    // seat\n    pos2 = pos1;\n    pos2.z += w1;\n\n    d1 = sdCircle(pos2.xz, w1 - bevel);\n    d1 = max(0.0, d1); // fill\n    d1 = length(vec2(d1, stretchAxis(pos2.y, thickness1 - 2.0 * bevel))); // add thickness\n    d1 -= bevel;\n\n    d = minx(d, vec3(d1, MATERIAL_PAINTED_WOOD, 2.0));\n\n    // legs\n    pos2.z = abs(pos2.z);\n    pos2.xz -= vec2(0.5 * w1);\n    pos2.xz *= rotation_n45;\n    pos2.yz *= rotation_n10;\n    d1 = sdCircle(pos2.xz, r3);\n    d1 = max(d1, abs(pos2.y + h3) - h3); // clip legs\n\n    d = minx(d, vec3(d1, MATERIAL_PAINTED_WOOD, 3.0));\n\n    return d;\n}\n\nvec3 sdPorchTable(vec3 pos)\n{\n    const float r1 = 0.55; // table radius\n    const float h = 0.7; // height\n    const float thickness1 = 0.04; // top thickness\n    const float r2 = 0.08; // base radius\n    const float r3 = 0.2; // legs curve radius\n    const float w3 = 0.05; // legs width (half)\n    const float thickness3 = 0.06; // legs thickness\n    const float bevel = 0.02;\n\n    float bounds = sdBoxApprox(pos, vec3(r1, h * 0.5, r1), vec3y1);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 d = vec3(MAX_DIST, 0.0, 0.0);\n\n    // top\n    vec3 pos1 = pos;\n    pos1.y -= h - thickness1 * 0.5;\n    float d1 = sdCircle(pos1.xz, r1 - bevel);\n    d1 = max(0.0, d1);\n    d1 = length(vec2(d1, stretchAxis(pos1.y, thickness1 - 2.0 * bevel))); // add thickness\n    d1 -= bevel;\n    d = minx(d, vec3(d1, MATERIAL_PAINTED_WOOD, 1.0));\n\n    // base\n    vec2 p = vec2(length(pos.xz), pos.y);\n    p.y -= h - thickness1;\n    d1 = sdCircle(p, r2); // top part\n    d1 = max(d1, p.y);\n\n    p.y = pos.y - r3 + w3;\n    float d2 = sdEllipse(p, vec2(r2, h - r2 - r3 + w3)); // center part\n    d2 = max(d2, -p.y);\n    d1 = smin(d1, d2, 0.1);\n\n    d = minx(d, vec3(d1, MATERIAL_PAINTED_WOOD, 2.0));\n\n    // legs\n    pos1 = pos;\n    pos1.zx = abs(pos1.zx);\n    pos1.xz = pos1.x < pos1.z ? pos1.zx : pos1.xz;\n    pos1.x -= r2 * 0.5;\n    d1 = sdCircle(pos1.xy, r3);\n    d1 = max(0.0, abs(d1) - w3 + bevel); // duplicate edge\n    d1 = max(d1, -pos1.y); // clip bottom half\n    pos1.x -= r3 + 0.5 * w3;\n    d2 = sdRectangle(pos1.xy, w3 * vec2(1.5, 0.5) - bevel);\n    d1 = smin(d1, d2, 0.1);\n    d1 = max(d1, 0.0); // fill\n    d1 = max(d1, -pos1.y); // flatten bottom part\n\n    d1 = length(vec2(d1, stretchAxis(pos1.z, thickness3 - 2.0 * bevel))); // add thickness\n    d1 -= bevel;\n\n    d = minx(d, vec3(d1, MATERIAL_PAINTED_WOOD, 3.0));\n    return d;\n}\n\nvec3 sdJarJuice(vec3 pos)\n{\n    const float r = 0.075;\n    const float h = 0.3;\n    const float thickness1 = 0.005;\n    // base\n    const float thickness2 = 0.01;\n    const float f = 0.6; // fill\n\n    float bounds = sdBoxApprox(pos, vec3(1.3 * r, 0.6 * h, 1.3 * r), vec3y(0.8));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n    pos1.y -= 0.5 * h + thickness1 + 2.0 * thickness2;\n\n    float d = sdCircle(pos1.xz, r + 0.017 * sin(3.0 + 18.5 * pos1.y));\n    d = max(0.0, d);\n    d = length(vec2(d, stretchAxis(pos1.y + 0.5 * (1.0 - f) * h, f * h)));\n\n    d *= 0.9; // approximation\n\n    return vec3(d, MATERIAL_JUICE, 0.0);\n}\n\nvec2 sdJarGlass(vec3 pos)\n{\n    // body\n    const float r1 = 0.075;\n    const float h1 = 0.3;\n    const float thickness1 = 0.005;\n    const float base = 0.02;\n    // base\n    const float thickness2 = 0.01;\n    // spout\n    const float h3 = 0.06;\n    const float w3 = 0.05;\n    const float depth3 = 0.01;\n    // handle\n    const float r4 = 0.08;\n\n    float bounds = sdBoxApprox(pos, vec3(1.9 * r1, 0.6 * h1, 1.3 * r1), vec3(0.3, 0.8, 0.0));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec2(bounds, MATERIAL_GLASS1);\n    }\n\n    vec3 pos1 = pos;\n\n    pos1.y -= thickness1 + 2.0 * thickness2;\n\n    // base\n    float d1 = sdCircle(pos1.xz, r1);\n    d1 = max(0.0, d1);\n    d1 = length(vec2(d1, pos1.y + thickness1)) - 2.0 * thickness2;\n    vec2 d = vec2(d1, MATERIAL_GLASS1);\n\n    // body\n    pos1.y -= 0.5 * h1;\n    float spout = pos1.x < 0.0 ? depth3 * smoothstep(w3, 0.0, abs(pos1.z)) * smoothstep(-h1, 0.0, pos1.y - 0.5 * h1) : 0.0;\n    d1 = sdCircle(pos1.xz, r1 + thickness1 + 0.017 * sin(3.0 + 18.5 * pos1.y) + spout);\n    float d2 = d1;\n\n    float m = d1 > 0.0 ? MATERIAL_GLASS1 : MATERIAL_GLASS2; // add outline beween inner and outer surfaces\n    d1 = length(vec2(d1, stretchAxis(pos1.y, h1)));\n    d1 -= thickness1;\n    d1 *= 0.8; // approximation\n    d = minx(d, vec2(d1, m));\n\n    // handle\n    d2 = max(0.0, -d2);\n    d2 = length(vec2(d2, stretchAxis(pos1.y, h1)));\n    pos1.x -= 0.04;\n    pos1.y -= 0.04;\n    d1 = sdCircle(pos1.xy, r4 * (1.0 + 0.5 * smoothstep(-1.0, 1.0, (pos1.x - pos1.y) / r4)));\n    d1 = length(vec2(d1, stretchAxis(pos1.z, 0.01))) - 0.01;\n    d1 = max(d1, d2);\n    d = minx(d, vec2(d1, MATERIAL_GLASS2));\n\n    return d;\n}\n\nvec3 sdGlassCupJuice(vec3 pos, float fill)\n{\n    const float r1 = 0.04;\n    const float r2 = 0.05;\n    const float h1 = 0.12;\n    const float thickness1 = 0.002;\n\n    // base\n    const float thickness2 = 0.01;\n\n    float bounds = sdBoxApprox(pos, 1.3 * vec3(r2, 0.5 * h1, r2), vec3y1);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n    pos1.y -= thickness2;\n\n    float d2 = sdCircle(pos1.xz, r1 + (r2 - r1) * smoothstep(0.0, h1, pos1.y) - thickness1);\n    d2 = max(0.0, d2);\n    d2 = length(vec2(d2, stretchAxis(pos1.y - 0.5 * fill * h1, fill * h1)));\n    d2 *= 0.9; // approximation\n\n    return vec3(d2, MATERIAL_JUICE, 0.0);\n}\n\nvec2 sdGlassCup(vec3 pos)\n{\n    const float r1 = 0.04;\n    const float r2 = 0.05;\n    const float h1 = 0.12;\n    const float thickness1 = 0.002;\n\n    // base\n    const float thickness2 = 0.01;\n\n    float bounds = sdBoxApprox(pos, 1.3 * vec3(r2, 0.5 * h1, r2), vec3y1);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec2(bounds, MATERIAL_GLASS3);\n    }\n\n    vec3 pos1 = pos;\n    pos1.y -= thickness2;\n    float d1 = sdCircle(pos1.xz, r1 - thickness2 + thickness1);\n    d1 = max(0.0, d1);\n    d1 = length(vec2(d1, pos1.y));\n    d1 -= thickness2;\n    vec2 d = vec2(d1, MATERIAL_GLASS3);\n\n    d1 = sdCircle(pos1.xz, r1 + (r2 - r1) * smoothstep(0.0, h1, pos1.y));\n    float m = d1 > 0.0 ? MATERIAL_GLASS3 : MATERIAL_GLASS4;\n    d1 = length(vec2(d1, stretchAxis(pos1.y - 0.5 * h1, h1)));\n    d1 -= thickness1;\n    d = minx(d, vec2(d1, m));\n\n    return d;\n}\n\nvec3 sdCake(vec3 pos)\n{\n    // cake\n    const float r1 = 0.13;\n    const float h1 = 0.06;\n\n    // frosting\n    const float h2 = 0.02;\n    const float bevel2 = 0.005;\n\n    // plate\n    const float r3 = 0.1;\n    const float curve3 = 0.3;\n    const float thickness3 = 0.002;\n\n    float bounds = sdBoxApprox(pos, vec3(r3, 0.5 * (h1 + h2), r3), vec3y1);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    // cake\n    vec3 pos1 = pos;\n    pos1.y -= 0.5 * h1 + 0.02 * curve3;\n    pos1.z -= 0.5 * r1;\n    pos1.x = abs(pos1.x);\n    pos1.xz *= rotation_15;\n    pos1.xz *= rotation_7_5;\n    float d1 = sdCircle(pos1.xz, r1);\n    float d2 = d1;\n    d1 = max(0.0, d1);\n    d1 = length(vec2(d1, stretchAxis(pos1.y, h1)));\n    d1 = max(d1, pos1.x);\n    vec3 d = vec3(d1, MATERIAL_CAKE1, 0.0);\n\n    // frosting\n    pos1.y -= 0.5 * h1;\n    d1 = d2;\n    d1 = max(0.0, d1);\n    float drop = pos1.y < 0.0 ? 0.5 * (2.0 + cos(200.0 * pos.x) + cos(200.0 * pos.z)) : 0.0;\n    d1 = length(vec2(d1, stretchAxis(pos1.y, h2 * (0.1 + 0.9 * drop))));\n    d1 = max(d1, pos1.x + 0.8 * bevel2);\n    d1 -= bevel2;\n    d = minx(d, vec3(d1, MATERIAL_CAKE2, 0.0));\n\n    // plate\n    pos1 = pos;\n    pos1.y -= curve3 - thickness3;\n    d1 = sdSphere(pos1, curve3);\n    d1 = abs(d1) - thickness3;\n    d1 = max(d1, pos1.y);\n    d2 = sdCircle(pos1.xz, r3);\n    d2 = max(0.0, d2);\n    d1 = max(d1, d2);\n    d1 = max(d1, -pos1.y - curve3 + thickness3);\n\n    d = minx(d, vec3(d1, MATERIAL_PORCELIN, 0.0));\n\n    return d;\n}\n\nvec3 sdPorchTableAndChairs(vec3 pos)\n{\n    float bounds = sdBoxApprox(pos, vec3(0.8, 0.5, 0.8), vec3y1);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    // table\n    vec3 pos1 = pos;\n    pos1.xz *= rotation_n15;\n    vec3 d1 = sdPorchTable(pos1);\n\n    // chairs\n    pos1 = pos;\n    pos1.xz *= rotation_n60;\n    pos1.xz = pos1.x < pos1.z ? pos1.xz : pos1.zx; // mirror 90 degrees\n    pos1 -= vec3(-0.1, 0.0, 0.6);\n    pos1.xz *= rotation_7_5;\n    vec3 d2 = sdPorchChair(pos1);\n    d1 = minx(d1, d2);\n\n#ifdef RENDER_CAKE\n    // jar\n    pos1 = pos;\n    pos1 -= vec3(-0.2, 0.7, -0.2);\n    pos1.xz *= rotation_180;\n    pos1.xz *= rotation_n10;\n    d2 = sdJarJuice(pos1);\n    d1 = minx(d1, d2);\n\n    // cups\n    pos1 = pos;\n    pos1.xz *= rotation_n90;\n    pos1.xz *= rotation_n7_5;\n    float fill = pos1.x > 0.0 ? 0.3 : 0.7;\n    pos1.x = abs(pos1.x);\n    pos1 -= vec3(0.25, 0.7, 0.2);\n    d2 = sdGlassCupJuice(pos1, fill);\n    d1 = minx(d1, d2);\n\n    // cakes\n    pos1 = pos;\n    pos1 -= vec3(0.22, 0.7, -0.12);\n    pos1.xz *= rotation_60;\n    float index = sign(pos1.x);\n    pos1.x = abs(pos1.x);\n    pos1.x -= 0.32;\n    pos1.xz = index > 0.0 ? (pos1.xz * rotation_60) : (pos1.xz * rotation_180);\n    d2 = sdCake(pos1);\n    d1 = minx(d1, d2);\n#endif\n\n    return d1;\n}\n\nvec3 sdPorchCeiling(vec3 pos, float gridSize)\n{\n    const float h1 = 0.25; // base layer 1\n    const float w1 = 0.3;  // base layer 1\n    const float thickness1 = 0.1; // base layer 1\n    const float h2 = 0.15;  // base layer 2\n    const float w2 = 0.4;  // base layer 2\n    const float thickness2 = 0.1; // base layer 2\n    const float bevel = 0.02;\n\n    pos.z += 6.0 * gridSize;\n\n    vec2 size = vec2(7.0, 5.5) * gridSize;\n    float bounds = sdBoxApprox(pos, vec3(size.x + w2, (h1 + h2) * 0.5, size.y + w2), vec3y1);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 d = vec3(MAX_DIST, 0.0, 0.0);\n\n    // bottom section\n    vec3 pos1 = pos;\n    pos1.y -= 0.5 * h1;\n    float d1 = sdRectangle(pos1.xz, size + w1 * 0.5 - bevel, vec2(w1));\n    d1 = max(d1, -pos1.z - 2.0 * gridSize); // clip back size\n    d1 = length(vec2(d1, stretchAxis(pos1.y, h1 - 2.0 * bevel)));\n    d1 -= bevel;\n    d = minx(d, vec3(d1, MATERIAL_PAINTED_WOOD, 1.0));\n\n    // top section\n    pos1.y -= 0.5 * (h1 + h2);\n    d1 = sdRectangle(pos1.xz, size + 0.5 * w2 - bevel, vec2(w2));\n    d1 = max(d1, -pos1.z - 2.0 * gridSize); // clip back size\n    d1 = length(vec2(d1, stretchAxis(pos1.y, h2 - 2.0 * bevel)));\n    d1 -= bevel;\n    d = minx(d, vec3(d1, MATERIAL_PAINTED_WOOD, 2.0));\n\n    return d;\n}\n\nvec3 sdPorchRoof(vec3 pos)\n{\n    const float thickness1 = 0.1; // base\n    const float bevel = 0.02;\n    const vec3 tileSize = vec3(0.5, 0.5, 0.03);\n\n    pos -= vec3(0.0, 3.8, -1.9);\n    vec2 size = vec2(8.0, 6.0);\n\n    float bounds = sdBoxApprox(pos, vec3(4.0, 2.2, 2.1), vec3(0.0, -0.7, 0.0));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 d1 = vec3(MAX_DIST, 0.0, 0.0);\n\n    // side tiles\n    vec3 pos1 = pos;\n    float index = sign(pos1.x);\n    pos1.x = abs(pos1.x); // mirror side tiles\n\n    pos1.zx *= rotation_90;\n    pos1.yz *= rotation_n45;\n\n    float columns = floor(0.5 * size.y / tileSize.x) + 2.0;\n    float rows = floor(0.5 * size.x / tileSize.y) + 2.0;\n    pos1.y -= 0.25;\n\n    // base\n    float d = sdBox(pos1, vec3(vec2(columns, rows) * tileSize.xy, thickness1) * 0.5, vec3(0.0, -1.0, -1.0), bevel);\n    d1 = minx(d1, vec3(d, MATERIAL_PAINTED_WOOD, 1.0 + index));\n\n    // tile\n    d1 = minx(d1, sdTiles(pos1 - vec3z(tileSize.z), tileSize, vec2(columns, rows), index + 17.0));\n\n    // clip\n    pos1 = pos;\n    pos1.yz *= rotation_60;\n    d1.x = max(d1.x, pos1.y);\n\n    // front tiles\n\n    pos1 = pos;\n    pos1.yz *= rotation_n30;\n\n    columns = floor(0.5 * size.x / tileSize.x) + 5.0;\n    rows = floor(0.5 * size.y / tileSize.y) + 2.0;\n    pos1.y -= 0.1;\n\n    // base\n    d = sdBox(pos1, vec3(vec2(columns, rows) * tileSize.xy, thickness1) * 0.5, vec3(0.0, -1.0, -1.0), bevel);\n    vec3 d2 = vec3(d, MATERIAL_PAINTED_WOOD, 1.0 + index);\n\n    // tile\n    d2 = minx(d2, sdTiles(pos1 - vec3z(tileSize.z), tileSize, vec2(columns, rows), 0.0));\n\n    // clip\n    pos1 = pos;\n    pos1.x = abs(pos1.x);\n    pos1.xy *= rotation_n45;\n    d2.x = max(d2.x, pos1.y);\n\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 sdFlower(vec3 pos, float h1)\n{\n    // petals\n    const float height1 = 0.06;\n    const float curve1 = -0.5;\n    const float thickness1 = 0.03;\n    const float taper1 = 0.5;\n\n    // anther\n    const float height2 = 0.06;\n    const float curve2 = 0.6;\n    const float thickness2 = 0.004;\n    const float taper2 = 0.4;\n\n    // stem\n    const float size3 = 0.2;\n    const float thickness3 = 0.005;\n\n    // leaves\n    const float size4 = 0.15;\n    const float thickness4 = 0.005;\n    const float width4 = 0.05;\n    const float crease4 = 0.004;\n\n    const vec2 gridSize = vec2(1.3);\n    vec2 index2 = floor(pos.xz / gridSize + 0.5);\n\n    float bounds = sdBoxApprox(pos, vec3(0.15, 0.2, 0.15), vec3y(-0.5));\n    if (bounds > 0.1)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    pos.xz *= rotation(hash(index2) * PI);\n    pos.x += 0.08;\n\n    // petals\n    vec3 pos1 = pos;\n    pos1.xy *= rotation_45;\n\n    vec3 pos2 = pos1;\n    float index = 0.0;\n    pos2.xz = radialMod(pos2.xz, 7.0, index);\n    pos2.x -= 0.02;\n    pos2.y += 0.02;\n\n    vec3 pos3 = pos2;\n    pos3.xy *= rotation_n45;\n    float d1 = sdArc(pos3, height1, curve1, thickness1, taper1);\n    vec3 d = vec3(d1, MATERIAL_FLOWER1, h1);\n\n    // anthers\n    pos3 = pos2;\n    pos3.xy -= vec2(0.01, 0.065);\n    pos3.xy *= rotation_n30;\n    pos3.y = -pos3.y;\n    d1 = sdArc(pos3, height2, curve2, thickness2, taper2);\n    d = minx(d, vec3(d1, MATERIAL_FLOWER2, h1));\n\n    // stem\n    pos2 = pos1;\n    pos2.y += height1;\n    pos2.x += size3;\n\n    d1 = sdCircle(pos2.xy, size3);\n    d1 = length(vec2(d1, pos2.z));\n    d1 = max(d1, -pos2.x);\n    d1 = max(d1, pos2.y);\n    d1 -= thickness3;\n\n    d = smin(d, vec3(d1, MATERIAL_STEM, 0.0), 0.04);\n\n    // leaves\n    pos2 = pos;\n    pos2.xy += size3 * vec2(-0.5, 0.7);\n    pos2.y += size4;\n\n    pos2.xz = radialMod(pos2.xz, 3.0, index);\n    pos2.x -= 0.9 * size4;\n    pos2.y -= crease4 * sqrt(clamp(abs(pos2.z) / 0.05, 0.0, 1.0));\n    float width = width4 * pow(smoothstep(0.0, -0.9 * size4, pos2.x), 0.4);\n    float thickness = 0.001 + thickness4 * smoothstep(0.0, -size4, pos2.x);\n    d1 = sdCircle(pos2.xy, size4);\n    d1 = length(vec2(d1, stretchAxis(pos2.z, width)));\n    d1 = max(d1, pos2.x);\n    d1 = max(d1, -pos2.y + 0.4 * size4);\n    d1 -= thickness;\n\n    d = minx(d, vec3(d1, MATERIAL_STEM, 0.0));\n\n    return d;\n}\n\nvec3 sdPorchFlowers(vec3 pos, float seed, float time)\n{\n    const vec2 gridSize = vec2(0.3, 0.2);\n    const float r = 0.6;\n    const float seed1 = 1.0;\n\n    pos.y -= 0.35;\n\n    float bounds = sdBoxApprox(pos, vec3(0.9, 0.2, 0.4), vec3y1);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 d1 = vec3(MAX_DIST, 0.0, 0.0);\n\n    vec3 pos1 = pos;\n    pos1 += vec3(0.67, -0.02, 0.27);\n\n    pos1.xz += pos1.y * 0.05 * vec2(sin(1.5 * pos1.x + time), sin(2.0 * pos1.z + 1.2 * time));\n\n    float s = 1.0;\n    for (int i = 0; i < 3; i++)\n    {\n        vec3 pos2 = pos1;\n        vec2 index = floor(pos2.xz / gridSize);\n        index = clamp(index, vec2(0.0), vec2(3.0, 1.0));\n        pos2.xz -= gridSize * (index + 0.5);\n\n        float h1 = hash(index + 10.0 * seed + 100.0 * float(i) + seed1);\n        float h2 = hash(index + 10.0 * seed + 100.0 * float(i) + seed1 + 1000.0);\n        pos2.xz *= rotation(h1 * PI2);\n\n        float s = 1.0 - 0.4 * h1;\n        pos2.y -= 0.3 * s;\n        pos2 /= s;\n        vec3 d2 = sdFlower(pos2, h2);\n        d2.x *= s;\n        d1 = minx(d1, d2);\n\n        pos1.xz -= 0.08;\n    }\n\n    return d1;\n}\n\nvec3 sdPorchFlowerPot(vec3 pos, float seed)\n{\n    const vec3 size = vec3(0.7, 0.2, 0.3);\n    const float thickness = 0.05;\n    const float bevel = 0.01;\n\n    // bricks\n    const float w = (size.x + size.z) / 20.0;\n    const float h = size.y / 1.5;\n\n    float bounds = sdBoxApprox(pos, size, vec3y1);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    pos.y -= size.y;\n\n    vec2 p = pos.xz;\n    float d1 = sdRectangle(p, size.xz - thickness);\n    float d2 = d1;\n    d1 = abs(d1) - thickness + bevel;\n    d1 = max(0.0, d1);\n    d1 = length(vec2(d1, stretchAxis(pos.y, 2.0 * (size.y - bevel))));\n    d1 -= bevel;\n\n    // uv.x clockwise mapping\n    float x = abs(pos.z) < abs(pos.x) - size.x + size.z ? // quater\n        (pos.x < 0.0 ? (3.0 * size.z - pos.z + 2.0 * size.x) : (size.z + pos.z)) : // z-axis mapping\n        (pos.z < 0.0 ? (3.0 * size.x + pos.x + 4.0 * size.z) : (size.x - pos.x + 2.0 * size.z)); // x-axis mapping\n    x /= 4.0 * (size.x + size.z);\n\n    float row = pos.y / h + 0.5;\n    row = min(row, 1.99);\n    float h1 = hash(seed + floor(row));\n    float column = x / w + h1;\n    float h2 = hash(seed + vec2(floor(row), floor(column)));\n    float h3 = hash(seed + 10.0 + vec2(floor(row), floor(column)));\n\n    d1 -= h3 * 0.01;\n    float edge = floor(h2 * 3.0);\n    vec3 d = vec3(d1, MATERIAL_BRICK + 0.6 * h2 + 0.4 * (1.0 - fract(row)), edge);\n\n    d2 = max(0.0, d2);\n    float bump = sin(5.0 * seed + 15.0 * pos.x + 12.0 * pos.z) + sin(10.0 * seed + 25.0 * pos.x - 12.0 * pos.z);\n    d2 = length(vec2(d2, stretchAxis(pos.y - 0.1 + 0.01 * bump, 0.1)));\n    d = minx(d, vec3(d2, MATERIAL_SOIL, 0.0));\n\n    return d;\n}\n\nvec3 sdYardFlowerPot(vec3 pos, float seed, float time)\n{\n    // pot\n    const vec3 size1 = vec3(0.2, 0.1, 0.08); // brick size\n    const vec3 offset1 = vec3(0.05, 0.0, 0.005);\n    const float bevel1 = 0.015;\n    const float rows1 = 4.0;\n    const float columns1 = 20.0;\n    const float seed1 = 0.0;\n\n    // flowers\n    const vec2 gridSize2 = vec2(0.22);\n    const float r2 = 2.0;\n    const float seed2 = 0.0;\n\n    float bounds = sdBoxApprox(pos, vec3(0.8, 0.4, 0.8), vec3y(0.8));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n    pos1.y += size1.y;\n    vec3 d1 = sdRoundBricks(pos1, size1, offset1, bevel1, rows1, columns1, seed1, MATERIAL_BRICK, 1.0);\n\n    pos1 = pos;\n    pos1 += vec3(0.07, -0.2, 0.19);\n\n    pos1.xz += pos1.y * 0.05 * vec2(sin(1.5 * pos1.x + time), sin(2.0 * pos1.z + 1.2 * time));\n\n    float s = 1.0;\n    for (int i = 0; i < 3; i++)\n    {\n        vec3 pos2 = pos1;\n        vec2 index = floor(pos2.xz / gridSize2);\n\n        float an = atan(index.y, index.x);\n        index = round(min(length(index), r2) * vec2(cos(an), sin(an)));\n\n        pos2.xz -= gridSize2 * (index + 0.5);\n\n        float h1 = hash(index + 10.0 * seed + 100.0 * float(i) + seed2);\n        float h2 = hash(index + 10.0 * seed + 100.0 * float(i) + seed2 + 1000.0);\n        pos2.xz *= rotation(h1 * PI2);\n\n        float s = 1.0 - 0.4 * h1;\n        pos2.y -= 0.3 * s;\n        pos2 /= s;\n        vec3 d2 = sdFlower(pos2, h2);\n        d2.x *= s;\n        d1 = minx(d1, d2);\n\n        pos1.xz -= 0.05;\n        pos1.xz *= rotation_30;\n    }\n\n    pos1 = pos;\n    pos1.y -= (rows1 - 1.8) * size1.y;\n\n    float bump = sin(5.0 * seed + 15.0 * pos.x + 12.0 * pos.z) + sin(10.0 * seed + 25.0 * pos.x - 12.0 * pos.z);\n    float d = pos1.y - 0.01 * bump;\n    d = max(d, length(pos1.xz) - columns1 * size1.x / PI2);\n\n    vec3 d2 = vec3(d, MATERIAL_SOIL, 0.0);\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 sdPorch(vec3 pos, float time)\n{\n    const float gridSize = 0.45;\n    const vec3 pos0 = vec3(-0.5, 0.2, -2.6); // yard flowers\n\n    vec3 d1, d2;\n    vec3 pos1, pos2, pos3;\n    vec2 index;\n    float gridSize1, style;\n\n    float bounds = sdBoxApprox(pos, vec3(7.5 * gridSize + 0.5, 3.5, 5.5 * gridSize + 2.0), vec3(0.0, 1.0, -0.8));\n    pos1 = pos;\n    pos1.x = abs(pos1.x);\n    pos1 += vec3(-2.0, 0.0, -0.3) + pos0;\n    bounds = min(bounds, sdBoxApprox(pos1, vec3(0.8, 0.3, 0.8), vec3y1));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    d1 = vec3(MAX_DIST, MATERIAL_PAINTED_WOOD, 0.0);\n\n    pos1 = pos;\n    pos1.x = abs(pos1.x);\n    pos1 += vec3(0.0, -0.6, 5.5 * gridSize);\n\n    // fence posts\n    pos2 = pos1;\n    pos2.z += gridSize;\n    pos2.y -= 0.25;\n    index = floor(pos2.xz / gridSize + 0.5);\n    index = clamp(index, vec2(0.0), vec2(7.0, 6.0));\n    pos2.xz -= index * gridSize;\n    d2 = sdPost(pos2, vec2(0.1, 0.25));\n    d1 = minx(d1, d2);\n\n    // remove fence post at the opening\n    pos2 = pos1;\n    pos2.z -= gridSize * 5.0;\n    pos2.y -= 0.25;\n    d1.x = max(d1.x, -sdBoxApprox(pos2, vec3(gridSize * 1.5, 0.5, gridSize * 0.5)));\n\n    // support posts\n    pos2 = pos1;\n    pos2.x -= gridSize * 2.0;\n    gridSize1 = gridSize * 5.0;\n    index = floor(pos2.xz / gridSize1 + 0.5);\n    index = clamp(index, vec2(0.0), vec2(1.0));\n    pos2.xz -= index * gridSize1;\n    pos2.y -= 1.1;\n    d2 = sdPost(pos2, vec2(0.12, 0.5));\n    d1 = minx(d1, d2);\n    d2 = sdPostCap(pos2 - vec3y(0.48), 0.12);\n    d1 = minx(d1, d2);\n\n    // poles supports\n    pos3 = pos2;\n    pos3.y -= 1.3;\n    style = index.x > 0.0 && index.y > 0.0 ? 2.0 : 1.0;\n    pos3.xz = index.y <= 0.0 ? pos3.xz * rotation_90 : pos3.xz;\n    d2 = sdPoleSupport(pos3, 0.12, style);\n    d1 = minx(d1, d2);\n\n    // remove fence posts below support posts\n    pos2.y += 0.9;\n    d1.x = max(d1.x, -sdBoxApprox(pos2, vec3(0.2, 0.3, 0.2)));\n\n    // post base\n    pos2.y -= 1.0;\n    pos2.y = abs(pos2.y); // mirror\n    pos2.y -= 0.95;\n    style = index.x > 0.0 && index.y > 0.0 ? 2.0 : 1.0;\n    pos2.xz = index.y <= 0.0 ? pos2.xz * rotation_90 : pos2.xz;\n    d2 = sdPostBase(pos2, vec2(0.12, 0.25), style);\n    d1 = minx(d1, d2);\n\n    // remove fence posts\n    pos2 = pos1;\n    pos2 -= vec3(-gridSize * 0.5, 0.5, 0.0);\n    d1.x = max(d1.x, -sdBoxApprox(pos2, vec3(gridSize * 7.0, 2.0, gridSize * 4.5)));\n\n    // rails\n    pos2 = pos1;\n    pos2.xz -= gridSize * vec2(7.0, 3.5);\n    pos2.y -= 0.55;\n    d2 = vec3(sdFenceRails(pos2, gridSize), MATERIAL_PAINTED_WOOD, 0.0);\n    d1 = minx(d1, d2);\n\n    // floor\n    d2 = sdPorchFloor(pos, gridSize);\n    d1 = minx(d1, d2);\n\n    // stairs\n    d2 = sdPorchStairs(pos, gridSize);\n    d1 = minx(d1, d2);\n\n    // table and chairs\n    pos1 = pos;\n    pos1 -= vec3(2.0, 0.6, -1.3);\n    d2 = sdPorchTableAndChairs(pos1);\n    d1 = minx(d1, d2);\n\n    // ceiling\n    pos1 = pos;\n    pos1.y -= 3.0;\n    d2 = sdPorchCeiling(pos1, gridSize);\n    d1 = minx(d1, d2);\n\n    // roof\n    d2 = sdPorchRoof(pos1);\n    d1 = minx(d1, d2);\n\n    // flower pots\n    pos1 = pos;\n    pos1.z -= 0.3;\n    float seed = sign(pos1.x);\n    pos1.x = abs(pos1.x);\n    pos1.x -= gridSize * 4.5;\n    d2 = sdPorchFlowerPot(pos1, seed);\n    d1 = minx(d1, d2);\n\n    d2 = sdPorchFlowers(pos1, seed, time);\n    d1 = minx(d1, d2);\n\n    pos1 += pos0;\n    d2 = sdYardFlowerPot(pos1, seed, time);\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 sdEntrancePediment(vec3 pos)\n{\n    const float w1 = 0.9; // width\n    const float depth = 0.05;\n    const float n = 3.0;\n    const float bevel = 0.02;\n\n    float bounds = sdBoxApprox(pos, vec3(w1, w1 * 0.5, depth) + bevel, vec3y1);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 d, pos1, pos2;\n\n    float w = w1 / n;\n\n    pos1 = pos;\n    pos1.z += depth;\n    float index = floor(pos1.x / w);\n    index = clamp(index, -n - 1.0, n);\n    pos1.x -= (index + 0.5) * w;\n\n    float d1 = abs(pos1.x) - 0.5 * w + bevel; // vertical line\n    d1 = max(0.0, d1); // fill shape\n    d1 = length(vec2(d1, stretchAxis(pos1.z, 2.0 * (depth - bevel))));\n    d1 -= bevel;\n\n    pos1 = pos;\n    pos1.x = abs(pos1.x);\n    d1 = max(d1, -pos1.y); // clip bottom side\n\n    pos1.xy *= rotation_45;\n    pos1.x -= w1 * 0.7071067;\n\n    d1 = max(d1, pos1.x); // clip diagonal side\n\n    return vec3(d1, MATERIAL_PAINTED_WOOD, mod(index, 2.0) + 1.0);\n}\n\nvec3 sdEntrancePedimentDecoration(vec3 pos)\n{\n    const float s1 = 0.08; // center part radius\n    const float t1 = 0.1; // center part thickness\n    const float h1 = 0.25; // top part height\n    const float s2 = 0.15; // base radius\n    const float h2 = 0.1; // base height\n\n    float bounds = sdBoxApprox(pos, vec3(0.4, 0.45, 0.2), vec3y(-0.2));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    float d1, d2, d3;\n\n    vec3 pos1 = pos;\n\n    d1 = MAX_DIST;\n    pos1 = pos;\n    pos1.y += h1;\n\n    // center part\n    vec2 p1 = vec2(length(pos1.xz), pos1.y);\n    vec2 p2 = p1;\n\n    p2.x -= t1 * s1;\n    d1 = p2.x - s1 * pow(smoothstep(2.5 * h1, 0.0, p2.y), 0.7);\n    d1 = max(d1, p2.y - 2.0 * h1);\n    d1 = max(d1, -p2.y);\n\n    p2 = p1;\n    p2.y -= 1.985 * h1;\n    d2 = length(p2) - s1 * 0.3088;\n    d2 = max(d2, -p2.y + s1 * 0.045);\n    d1 = min(d1, d2);\n\n    d2 = min(d1, length(p1) - (1.0 + t1) * s1);\n    d1 = min(d1, d2);\n\n    // base\n    pos1 = pos;\n    pos1.y += 2.0 * h1 - 0.8 * h2;\n    d2 = sdEllipsoid(pos1, vec3(s2, h2, s2));\n    d1 = smin(d1, d2, 0.04);\n\n    // wings\n    vec3 pos2 = pos1;\n    pos2.x = abs(pos2.x);\n    pos2.x -= 0.85 * s2;\n    pos2.y -= 0.1 * h2;\n\n    vec3 pos3 = pos2;\n    pos3.xy *= rotation_n60;\n    d2 = sdArc(pos3, 0.4, -0.95, 0.085, 0.11);\n\n    pos3 = pos2;\n    pos3.x -= 0.029;\n    pos3.y -= 0.348;\n    pos3.xy *= rotation_30;\n    d3 = sdArc(pos3, 0.2, 0.8, 0.04, 0.1);\n    d2 = smin(d2, d3, 0.005);\n    d1 = smin(d1, d2, 0.02);\n\n    return vec3(d1, MATERIAL_PAINTED_WOOD, 0.0);\n}\n\nvec3 sdEntranceStairs(vec3 pos)\n{\n    const float w = 2.0; // steps width\n    const float h = 0.2; // step height\n    const float depth = 0.3; // step depth\n    const float ext = 1.5; // last step depth\n\n    vec3 d, d1, d2;\n\n    vec3 pos1 = pos;\n\n    pos1 += vec3(0.0, -h * 3.0, ext + depth * 3.0) * 0.5;\n    d = abs(pos1) - vec3(w, h * 3.0, depth * 3.0 + ext) * 0.5;\n    d1 = maxx(maxx(vec3(d.x, 0.0, 1.0), vec3(d.y, 0.0, 2.0)), vec3(d.z, 0.0, 3.0)); // cube with edge index\n\n    if (d1.x > BOUNDS_MARGIN)\n    {\n        return d1;\n    }\n\n    pos1 -= vec3(0.0, h * 1.5, depth * 1.5 + ext * 0.5);\n    d = abs(pos1) - vec3(w, h, depth * 2.0);\n    d2 = maxx(maxx(vec3(d.x, 0.0, 1.0), vec3(d.y, 0.0, 2.0)), vec3(d.z, 0.0, 3.0)); // cube with edge index\n    d2.x = -d2.x;\n    d1 = maxx(d1, d2); // cut middle step\n\n    pos1 -= vec3(0.0, -h, depth);\n    d = abs(pos1) - vec3(w, h, depth * 2.0);\n    d2 = maxx(maxx(vec3(d.x, 0.0, 1.0), vec3(d.y, 0.0, 2.0)), vec3(d.z, 0.0, 3.0)); // cube with edge index\n    d2.x = -d2.x;\n    d1 = maxx(d1, d2); // cut lower step\n\n    d1.y = MATERIAL_PAINTED_WOOD;\n\n    return d1;\n}\n\nfloat sdEntranceDoorBounds(vec3 pos)\n{\n    // half size\n    const float w = 0.55;\n    const float h = 1.1;\n    const float depth = 0.5;\n\n    pos.y -= h;\n\n    float bounds = sdBoxApprox(pos, vec3(w, h, depth));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return bounds;\n    }\n\n    float d = sdRoundedRectangle(pos.xy, vec2(w, h), vec4(w, 0.0, w, 0.0));\n    d = max(0.0, d); // fill\n    d = length(vec2(d, stretchAxis(pos.z, depth)));\n    d -= 0.05;\n\n    return d;\n}\n\nvec3 sdEntranceDoorHandle(vec3 pos)\n{\n    const vec3 size = vec3(0.038, 0.075, 0.03); // door handle base size\n    const float r = 0.015; // door handle radius\n    const float width = 0.18; // door handle length\n    const float depth = 0.15; // door handle depth\n    const float bevel = 0.005;\n\n    float bounds = sdBoxApprox(pos, vec3(0.15), vec3x(0.5));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 100.0, 0.0);\n    }\n\n    // handle base\n    vec3 pos1 = pos;\n    pos1.y += size.y * 0.5;\n    float d1 = sdBox(pos1, size, vec3(0.0), bevel);\n    d1 = max(0.0, d1);\n    d1 = length(vec2(d1, stretchAxis(pos.z, depth - 2.0 * bevel)));\n    d1 -= bevel;\n    vec3 d = vec3(d1, MATERIAL_METAL2, 7.0);\n\n    // handle\n    pos1 = pos;\n    pos1 -= vec3(width * 0.5, 0.0, depth * 0.5);\n    pos1.x += 0.5 * width;\n    pos1.z = -pos1.z;\n    pos1.xz = pos1.x > pos1.z ? pos1.xz : pos1.zx;\n    d1 = length(pos1.xz - vec2(clamp(pos1.x, 0.0, width), 0.0));\n    d1 = length(vec2(d1, pos1.y));\n    d1 -= r;\n\n    d = minx(d, vec3(d1, MATERIAL_METAL2, 8.0));\n    return d;\n}\n\nvec3 sdEntranceDoor(vec3 pos)\n{\n    const float w = 0.55; // door width (half)\n    const float h = 1.1; // door height (half)\n\n    const float thickness1 = 0.06; // outer frame thickness\n    const float depth1 = 0.2; // outer frame depth\n\n    const float thickness2 = 0.07; // inner frame thickness (half)\n    const float depth2 = 0.05; // inner frame depth\n\n    const float thickness3 = 0.14; // diagonal bars thickness (half)\n    const float offset3 = 0.04; // diagonal bars thickness (half)\n    const float depth3 = 0.04; // inner frame depth\n\n    const float bevel = 0.01;\n\n    vec3 pos1 = pos;\n    pos1.y -= h;\n\n    float bounds = sdBoxApprox(pos1, vec3(w, h, 0.1) + thickness1);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    // outer frame\n    float frameBounds = sdRoundedRectangle(pos1.xy, vec2(w, h), vec4(w, 0.0, w, 0.0));\n    float d = frameBounds;\n    d = abs(d - thickness1) - thickness1 + bevel;\n    d = max(d, -pos1.y - h + bevel);\n    d = max(0.0, d);\n    d = length(vec2(d, stretchAxis(pos1.z, depth1 - bevel * 2.0)));\n    d -= bevel;\n    vec3 d1 = vec3(d, MATERIAL_PAINTED_WOOD, 0.0);\n\n    // inner frame\n    d = frameBounds;\n    d = abs(d + thickness2) - thickness2 + bevel;\n    d = max(d, -pos1.y - h + bevel);\n    d = max(0.0, d);\n    d = length(vec2(d, stretchAxis(pos1.z, depth2 - 2.0 * bevel + 0.001))); // depth\n    d -= bevel;\n    vec3 d2 = vec3(d, MATERIAL_WOOD3, 1.0);\n    bool isVertical = pos1.y > -h + 2.0 * thickness2;\n    d2.yz += (isVertical ? vec2(0.1, 0.01) : vec2(0.01, 0.1)) * pos1.xy + 0.5;\n    d1 = minx(d1, d2);\n\n    // vertical bar\n    pos1 = pos;\n    d = max(0.0, abs(pos1.x) - thickness2 + bevel); // bar\n    d = max(d, abs(pos1.y - h) - h + thickness2 + bevel); // clip\n    d = length(vec2(d, stretchAxis(pos1.z, depth2 - 2.0 * bevel))); // depth\n    d -= bevel;\n    d2 = vec3(d, MATERIAL_WOOD3, 1.0);\n    d2.yz += 0.99 * fract(vec2(0.1, 0.01) * pos1.xy + 0.5); // uv\n    d1 = minx(d1, d2);\n\n    float offset = (2.0 * h - w - thickness2) / 4.0;\n    // horizontal bars\n    pos1 = pos;\n    pos1.y -= 2.0 * h - w;\n    pos1.y = abs(pos1.y + offset) - offset;\n    d = max(0.0, abs(pos1.y) - thickness2 + bevel); // bar\n    d = max(d, abs(pos1.x) - w + thickness2 + bevel); // clip\n    d = length(vec2(d, stretchAxis(pos1.z, depth2 - 2.0 * bevel))); // depth\n    d -= bevel;\n    d2 = vec3(d, MATERIAL_WOOD3, 1.0);\n    d2.yz += 0.99 * fract(vec2(0.01, 0.1) * pos1.xy + 0.5); // uv\n    d1 = minx(d1, d2);\n\n    // diagonal bars\n    pos1 = pos;\n    pos1.y -= 2.0 * h - w;\n    pos1.xy = abs(pos1.xy); // mirror\n    pos1.y -= 2.0 * offset;\n    pos1.xy = abs(pos1.xy); // mirror\n\n    pos1.xy *= rotation_30;\n    pos1.x += offset3;\n    float index = floor(pos1.x / thickness3 + 0.5);\n    pos1.x -= thickness3 * index; // repeat\n\n    d = max(0.0, abs(pos1.x) - thickness3 * 0.5 + bevel); // bar\n    d = length(vec2(d, stretchAxis(pos1.z, depth3 - bevel * 2.0))); // thickness\n    d -= bevel;\n\n    float d3 = frameBounds + thickness2 * 0.5;\n    d3 = max(0.0, d3);\n    d = max(d, d3); // clip\n\n    d2 = vec3(d, MATERIAL_WOOD3, mod(index, 2.0) + 3.0);\n    d2.yz += 0.99 * fract(vec2(0.1, 0.01) * pos1.xy + 0.5); // uv\n    d1 = minx(d1, d2);\n\n    // door handle\n    pos1 = pos;\n    pos1.z = abs(pos1.z);\n    pos1.y -= h - 0.5 * (w - thickness2);\n    pos1.x += w - thickness2;\n    d2 = sdEntranceDoorHandle(pos1);\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 sdEntranceRoof(vec3 pos)\n{\n    const vec3 tileSize = vec3(0.5, 0.5, 0.03);\n\n    pos -= vec3(0.0, 3.95, -1.6);\n\n    float bounds = sdBoxApprox(pos, vec3(1.3, 0.6, 1.3), vec3y(-0.8));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    float index = sign(pos.x);\n    pos.x = abs(pos.x);\n    pos.xz *= rotation_n90;\n    pos.yz *= rotation_n45;\n    pos.y -= 0.08;\n\n    vec3 d1 = vec3(sdBox(pos, vec3(1.0, 0.7, 0.04), vec3(0.0, -1.0, 0.0), 0.02), MATERIAL_PAINTED_WOOD, 0.0);\n    pos.z -= 0.08;\n\n    vec3 d2 = sdTiles(pos, tileSize, vec2(4.0, 3.0), index);\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 sdEntrance(vec3 pos)\n{\n    const float w = 0.8; // width\n    const vec3 tileSize = vec3(0.5, 0.5, 0.03);\n\n    float bounds = sdBoxApprox(pos, vec3(1.2, 2.4, 1.4), vec3(0.0, 1.0, -1.0));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 d1, d2, pos1, pos2;\n\n    // steps\n    d1 = sdEntranceStairs(pos);\n\n    // bottom posts base\n    pos1 = pos;\n    pos1.x = abs(pos.x);\n    pos1 -= vec3(w, 0.8, -0.8);\n    d2 = sdPostBase(pos1, vec2(0.12, 0.2), 3.0);\n    d1 = minx(d1, d2);\n\n    // posts\n    pos1.y -= 0.78;\n    d2 = sdPost(pos1, vec2(0.12, 0.58));\n    d2.z = 2.0;\n    d1 = minx(d1, d2);\n\n    // caps\n    pos1.y -= 0.56;\n    d2 = sdPostCap(pos1, 0.12);\n    d1 = minx(d1, d2);\n\n    // top posts base\n    pos2 = pos1;\n    pos2.y -= 0.57;\n    d2 = sdPostBase(pos2, vec2(0.12, 0.22), 2.0);\n    d1 = minx(d1, d2);\n    pos2.y -= 0.22;\n\n    // front arcs\n    d2 = sdPoleSupport(pos2, 0.12, 2.0);\n    d1 = minx(d1, d2);\n\n    // back arcs\n    pos2.z += 2.0 * w;\n    pos2.xz *= rotation_n90;\n    d2 = sdPoleSupport(pos2, 0.12, 0.0);\n    d1 = minx(d1, d2);\n\n    // roof base\n    pos1 = pos;\n    pos1 -= vec3(0.0, 2.95, -1.65);\n    float d = sdRectangleFrame(pos1.xzy, vec3(1.85, 2.0, 0.05), vec2(0.2), 0.02);\n    d1 = minx(d1, vec3(d, MATERIAL_PAINTED_WOOD, 0.0));\n\n    // roof\n    pos1 = pos;\n    pos1 -= vec3(0.0, 2.98, -0.75);\n    d2 = sdEntrancePediment(pos1);\n    d1 = minx(d1, d2);\n\n    pos1.y -= 1.52;\n    pos1.z += 0.05;\n    d2 = sdEntrancePedimentDecoration(pos1);\n    d1 = minx(d1, d2);\n\n    // tiles\n    d2 = sdEntranceRoof(pos);\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 sdFloor(vec3 pos, float thickness, float seed)\n{\n    const float r = 3.95; // radius\n    const float w = 2.0; // floor tile width\n    const float h = 0.4; // floor tile length\n    const float columns = ceil(r / w + 1.0);\n    const float rows = ceil(r / h);\n\n    pos.y += 2.0 * thickness;\n\n    float bounds = sdBoxApprox(pos, vec3(r, 2.0 * thickness, r));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    bounds = length(pos.xz) - r + 0.01;\n\n    vec3 d1 = vec3(MAX_DIST, 0.0, 0.0);\n\n    // floor\n    vec2 p = pos.xz;\n    float row = p.y / h + 0.5;\n    float h1 = hash(seed + floor(row));\n    p.x -= h1 * w; // column offset\n    float column = p.x / w + 0.5;\n    row = clamp(row, -rows, rows);\n    column = clamp(column, -columns, columns);\n\n    p.x -= floor(column) * w;\n    p.y -= floor(row) * h;\n\n    float h2 = hash(seed + vec2(floor(row), floor(column)));\n    float d = sdRectangleApprox(p, vec2(w, h) * 0.5); // floor tile\n    d = max(0.0, d); // fill shape\n    d = max(d, abs(pos.y - thickness) - thickness); // thickness\n    d = max(d, bounds); // clip\n    float edge = mod((h2 + h1) * 10.0, 4.0);\n    d1 = vec3(d, MATERIAL_WOOD3, edge);\n    d1.yz += 0.99 * fract(vec2(0.01, 0.1) * pos.xz + 0.5 + 0.1 * h1);\n\n    // ceiling\n    p = pos.xz;\n    d = sdRectangleApprox(p, vec2(r));\n    d = max(0.0, d); // file shape\n    d = max(d, abs(pos.y + thickness) - thickness); // thickness\n    d = max(d, bounds); // clip\n    vec3 d2 = vec3(d, MATERIAL_PAINTED_WOOD, 0.0);\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 sdFloors(vec3 pos)\n{\n    const float h = 14.0 / 3.0; // height\n    const float thickness = 0.2; // thickness (half)\n\n    float bounds = sdBoxApprox(pos, vec3(4.0, 10.0, 4.0), vec3y1);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    pos.y -= 0.6;\n    float index = floor(pos.y / h + 0.5);\n    index = clamp(index, 0.0, 3.0);\n\n    float offset = index > 2.0 ? 0.04 : 0.0;\n    pos.y += offset;\n    pos.y -= index * h;\n\n    return sdFloor(pos, thickness + offset, floor(index) * 10.0);\n}\n\nvec3 sdWoodShadePile(vec3 pos, float r1, float r2, float depth1, float depth2, vec2 gridSize, vec2 count, float offset1, float offset2)\n{\n    const float bevel = 0.001;\n    const float curve = 0.06;\n\n    float bounds = sdBoxApprox(pos, vec3(1.0, 0.7, 0.5));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec2 p = pos.xy;\n\n    p += 0.5 * count * gridSize; // center\n\n    vec2 index, p1;\n    float h1, h2, r, d;\n\n    offset1 *= 0.25;\n\n    index = floor(p / gridSize + 0.5);\n    index.x += offset2;\n    index.y = round(min(index.y, count.y - curve * (count.x - index.x - offset1) * (count.x - index.x - offset1)));\n    index = clamp(index, vec2(0.0), count);\n\n    p1 = p - index * gridSize;\n    h1 = hash(index + 2.0);\n    h2 = hash(index + 102.0);\n    r = r1 - h1 * r2; // radius variance\n    p1 += (vec2(h1, h2) - 0.5) * 0.01; // position offset\n    d = length(p1) - r + bevel; // circle\n    d = max(0.0, d); // fill shape;\n    d = min(d, gridSize.x); // cell bounds\n    d = length(vec2(d, stretchAxis(pos.z - 0.8 * h2 * depth2, depth1 + h2 * depth2))); // convert to 3d length\n    d -= bevel;\n\n    float edge = 1.0 + mod(index.x, 2.0) + 2.0 * mod(index.y, 2.0);\n    vec3 d1 = vec3(d, MATERIAL_WOOD4, edge);\n    d1.yz += 0.99 * fract(vec2(0.1, 0.01) * vec2(pos.x + pos.y, pos.z) + 0.1 * index + h1); // uv\n\n    return d1;\n}\n\nvec3 sdWoodShadePile(vec3 pos, vec2 count)\n{\n    const float r1 = 0.06;\n    const float r2 = 0.01; // radius variance\n    const float depth1 = 0.7;\n    const float depth2 = 0.05; // depth variance\n    const vec2 gridSize = vec2(0.12, 0.18);\n\n    float bounds = sdBoxApprox(pos, vec3(0.5 * (count + 1.0) * gridSize, depth1 + depth2));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 d1, d2;\n\n    d1 = sdWoodShadePile(pos, r1, r2, depth1, depth2, gridSize, count, 0.0, 0.0);\n\n    d2 = sdWoodShadePile(pos, r1, r2, depth1, depth2, gridSize, count, 0.0, 1.0);\n    d1 = minx(d1, d2);\n\n    pos = vec3(pos.xy + 0.5 * gridSize, pos.z);\n    d2 = sdWoodShadePile(pos, r1, r2, depth1, depth2, gridSize, count, 1.0, 0.0);\n    d2.z += 3.0; // edge offset\n    d1 = minx(d1, d2);\n\n    d2 = sdWoodShadePile(pos, r1, r2, depth1, depth2, gridSize, count, 1.0, 1.0);\n    d2.z += 3.0; // edge offset\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 sdWoodShadeSide(vec3 pos)\n{\n    const float r1 = 0.06;\n    const float r2 = 0.01; // radius variance\n    const float len1 = 0.8;\n    const float len2 = 0.3; // length variance\n    const float bevel = 0.01;\n    const float w1 = 0.28; // gap\n    const float w2 = 0.05; // gap variance\n\n    float bounds = sdBoxApprox(pos + vec3z(w1), vec3(0.5 * len1, 0.5 * len1, 3.0 * w1), vec3(0.0, 1.0, 1.0));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    float index = floor(pos.z / w1 + 0.5);\n    index = clamp(index, 0.0, 5.0);\n    pos.z -= index * w1;\n\n    float h1 = hash(index);\n    float h2 = hash(index + 10.0);\n    float h3 = hash(index + 20.0);\n\n    pos.z += h1 * w2;\n    pos.yz *= rotationApprox((h2 - 0.5) * 0.3);\n    pos.xy *= rotation_n30;\n    pos.x -= 0.5 * h3 * len2;\n    pos.y += h3 * len2;\n\n    vec2 p1 = pos.xz;\n    float r = r1 - h3 * r2;\n    float d = length(p1) - r + bevel; // circle\n    d = max(0.0, d); // fill shape\n    d = length(vec2(d, pos.y - clamp(pos.y, 0.0, len1)));\n    d -= bevel;\n\n    vec3 d1 = vec3(d, MATERIAL_WOOD4, 0.0);\n    d1.yz += 0.99 * fract(vec2(0.1, 0.01) * vec2(pos.x + pos.z, pos.y) + 0.1 * index + h1); // uv\n    return d1;\n}\n\nvec3 sdWoodShadeWalls(vec3 pos)\n{\n    // lower panel (half)\n    const float w1 = 0.1;\n    const float h1 = 0.9;\n    const float depth1 = 0.04;\n\n    // separator (half)\n    const float w2 = 0.05;\n    const float h2 = w2;\n\n    // upper panel (half)\n    const float w3 = 0.05;\n    const float h3 = 0.3;\n    const float depth3 = 0.02;\n\n    // corners (half)\n    const float w4 = 0.1;\n\n    // top support (half)\n    const float w5 = 0.07;\n    const float h5 = w5;\n\n    const float bevel = 0.01;\n\n    vec3 pos1, pos2, pos3;\n\n    float bounds = sdBoxApprox(pos, vec3(1.3), vec3(0.0, 1.0, 1.0));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    pos1 = pos;\n    pos1.x = -abs(pos1.x);\n    pos1.x += w1 * 12.0;\n    pos1.xz = pos1.x < pos1.z ? pos1.zx : pos1.xz;\n\n    // lower panels\n    pos2 = pos1;\n    float index = floor(pos2.x / (w1 * 2.0) + 0.5);\n    index = min(index, 9.0);\n    pos2.x -= index * w1 * 2.0;\n    float d = sdBox(pos2, vec3(w1, h1, depth1), vec3y1, bevel);\n    vec3 d1 = vec3(d, MATERIAL_WOOD3, 1.0 + mod(index, 2.0));\n    d1.yz += 0.99 * fract(vec2(0.1, 0.01) * vec2(pos.x + pos.z, pos.y) + 0.1 * index + 0.5); // uv\n\n    // separators\n    pos2 = pos1;\n    pos2.y -= h1 * 2.0;\n    d = sdBox(pos2, vec3(w1 * 20.0, h2, w2), vec3y1, bevel);\n    vec3 d2 = vec3(d, MATERIAL_WOOD3, 3.0);\n    d2.yz += 0.99 * fract(vec2(0.01, 0.1) * vec2(pos.x + pos.z, pos.y) + 0.5); // uv\n    d1 = minx(d1, d2);\n\n    // upper panels\n    index = floor(pos2.x / (w1 * 4.0) + 0.5);\n    index = min(index, 4.0);\n    pos2.x -= index * w1 * 4.0;\n    pos2.y -= h2 * 2.0;\n    d = sdBox(pos2, vec3(w3, h3, depth3), vec3y1, bevel);\n    d2 = vec3(d, MATERIAL_WOOD3, 4.0 + mod(index, 2.0));\n    d2.yz += 0.99 * fract(vec2(0.1, 0.01) * vec2(pos.x + pos.z, pos.y) + 0.1 * index + 0.5); // uv\n    d1 = minx(d1, d2);\n\n    // corners\n    pos1 = pos;\n    pos1.z -= w1 * 10.0;\n    pos1.xz = abs(pos1.xz);\n    pos1.z -= w1 * 10.0;\n    pos1.x -= w1 * 12.0;\n    d = sdBox(pos1, vec3(w4, h1 + h2 + h3 + h5, w4) + 0.001, vec3y1, bevel);\n    d2 = vec3(d, MATERIAL_WOOD3, 6.0);\n    d2.yz += 0.99 * fract(vec2(0.1, 0.01) * vec2(pos.x + pos.z, pos.y) + 0.5); // uv\n    d1 = minx(d1, d2);\n\n    // top\n    pos2 = pos1;\n    pos2.xz = pos2.x < pos2.z ? pos2.zx : pos2.xz;\n    pos2.y -= (h1 + h2 + h3) * 2.0;\n    d = sdBox(pos2, vec3(w5, h5, w1 * 20.0), vec3y1, bevel);\n    d2 = vec3(d, MATERIAL_WOOD3, 7.0);\n    d2.yz += 0.99 * fract(vec2(0.01, 0.1) * vec2(pos.x + pos.z, pos.y) + 0.5); // uv\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 sdWoodShadeRoof(vec3 pos)\n{\n    // base (half)\n    const float w1 = 0.05;\n    const float h1 = 1.0;\n    const float thickness1 = 0.1;\n\n    // tiles\n    const float w2 = 0.14;\n    const float h2 = 1.15; // length\n    const float thickness2 = 0.02;\n\n    const float bevel = 0.01;\n\n    pos.y -= 2.64;\n    pos.z -= 1.0;\n\n    float bounds = sdBoxApprox(pos, vec3(1.8, 1.0, 1.4), vec3y(0.4));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n    pos1.x = abs(pos1.x);\n    pos1.x -= 1.3;\n    pos1.xy *= rotation_45;\n\n    // bars\n    vec3 pos2 = pos1;\n    float index = sign(pos2.z);\n    pos2.z = abs(pos2.z);\n    pos2.z -= 1.0;\n    float d = sdBox(pos2, vec3(w1, h1, thickness1), vec3(-1.0, 1.0, 0.0), bevel);\n    d = max(d, -pos.y);\n    vec3 d1 = vec3(d, MATERIAL_WOOD3, 1.0);\n    d1.yz += 0.99 * fract(vec2(0.1, 0.01) * vec2(pos2.x + pos2.z, pos2.y) + 0.5); // uv\n\n    // tiles base\n    pos2 = pos1;\n    pos2.y += thickness2;\n    index = floor(pos2.z / (w2 * 2.0) + 0.5);\n    index = clamp(index, -4.0, 4.0);\n    pos2.z -= index * w2 * 2.0;\n    pos2.y += h2 - h1;\n    d = sdBox(pos2, vec3(thickness2, h2, w2), vec3(1.0, 1.0, 0.0), bevel);\n    vec3 d2 = vec3(d, MATERIAL_WOOD3, 2.0 + mod(index, 2.0));\n    d2.yz += 0.99 * fract(vec2(0.1, 0.01) * vec2(pos2.x + pos2.z, pos2.y) + 0.1 * index + 0.5); // uv\n    d1 = minx(d1, d2);\n\n    // tiles\n    float seed = sign(pos.x) + 2.0;\n    pos2 = pos1;\n    pos2.xz *= rotation_n90;\n    pos2.y -= 1.9;\n    pos2.z -= 0.06;\n    d2 = sdTiles(pos2, vec3(0.5, 0.4, 0.03), vec2(5.0, 6.0), seed);\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 sdWoodShade(vec3 pos)\n{\n    const vec2 pileCount = vec2(11.0, 7.0);\n\n    float bounds = sdBoxApprox(pos - vec3z1, vec3(1.8, 2.1, 1.4), vec3y1);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 d1 = sdWoodShadeWalls(pos);\n\n    vec3 pos1 = pos;\n\n    vec3 d2 = sdWoodShadeRoof(pos1);\n    d1 = minx(d1, d2);\n\n    pos1 = pos;\n    pos1.x -= 0.15;\n    pos1.z -= 1.5;\n    pos1.xz = vec2(-pos1.z, pos1.x);\n    bool leftPile = pos1.z < 0.0;\n    pos1.y -= leftPile ? 0.6 : 0.8;\n    pos1.z = abs(pos1.z);\n    pos1.xz = leftPile ? pos1.zx : pos1.xz;\n    pos1.x -= 0.7;\n    pos1.z -= 0.6;\n    pos1.z *= -1.0;\n    d2 = sdWoodShadePile(pos1, leftPile ? pileCount - 2.0 : pileCount);\n    d1 = minx(d1, d2);\n\n    pos1 = pos;\n    pos1.x += 1.68;\n    pos1.z -= 0.4;\n    d2 = sdWoodShadeSide(pos1);\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 sdKitchenDoor(vec3 pos)\n{\n    // bars (half)\n    const float w1 = 0.09;\n    const float h1 = 1.0;\n    const float thickness1 = 0.03;\n\n    // frame\n    const float w2 = 0.05;\n    const float thickness2 = 0.15;\n\n    // lintel\n    const float h3 = 0.1;\n    const float thickness3 = 0.2;\n\n    // handle\n    const float w5 = 0.04;\n    const float h5 = 0.12;\n    const float depth5 = 0.07;\n    const float thickness5 = 0.015;\n\n    float bevel5 = 0.01;\n\n    const float bevel = 0.01;\n\n    float bounds = sdBoxApprox(pos, vec3(w1 * 6.0 + 2.0 * w2, h1 + h3, thickness3) + 0.1, vec3y1);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n    float index = floor(pos1.x / (w1 * 2.0));\n    index = clamp(index, -3.0, 2.0);\n    pos1.x -= (index + 0.5) * w1 * 2.0;\n\n    float d = sdBox(pos1, vec3(w1, h1, thickness1), vec3y1, bevel);\n\n    vec3 d1 = vec3(d, MATERIAL_WOOD3, 1.0 + mod(index, 2.0));\n    d1.yz += 0.99 * fract(vec2(0.1, 0.01) * pos.xy + 0.1 * index); // uv\n\n    // frame\n    pos1 = pos;\n    pos1.x = abs(pos1.x);\n    pos1.x -= 6.0 * w1;\n    d = sdBox(pos1, vec3(w2, h1, thickness2), vec3(1.0, 1.0, 0.0), bevel);\n    vec3 d2 = vec3(d, MATERIAL_WOOD3, 1.0);\n    d2.yz += 0.99 * fract(vec2(0.1, 0.01) * vec2(pos.x + pos.z, pos.y)); // uv\n    d1 = minx(d1, d2);\n\n    // lintel\n    pos1 = pos;\n    pos1.y -= h1 * 2.0;\n    d = sdBox(pos1, vec3(6.0 * w1 + 2.0 * w2, h3, thickness3), vec3y1, bevel);\n    d2 = vec3(d, MATERIAL_WOOD3, 2.0);\n    d2.yz += 0.99 * fract(vec2(0.01, 0.1) * vec2(pos.x, pos.y + pos.z) + 0.5); // uv\n    d1 = minx(d1, d2);\n\n    // handle\n    pos1 = pos;\n    pos1.x -= w1 * 5.0;\n    pos1.y -= 0.9;\n    d = sdEllipse(pos1.yz, vec2(h5, depth5));\n    d = abs(d) - thickness5 * 0.5 + bevel5;\n    d = max(0.0, d);\n    d = length(vec2(d, stretchAxis(pos1.x, w5 - 2.0 * bevel5)));\n    d -= bevel5;\n    d2 = vec3(d, MATERIAL_METAL2, 4.0);\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 sdKitchenStairs(vec3 pos)\n{\n    const float w = 1.4; // steps width\n    const float h = 0.3; // step height\n    const float depth = 0.4; // bottom step depth\n    const float ext = 1.0; // top step depth\n\n    vec3 d, d1, d2;\n\n    vec3 pos1 = pos;\n\n    pos1 += vec3(0.0, -h * 2.0, ext + depth) * 0.5;\n    d = abs(pos1) - vec3(w, h * 2.0, ext + depth) * 0.5;\n    d1 = maxx(maxx(vec3(d.x, 0.0, 1.0), vec3(d.y, 0.0, 2.0)), vec3(d.z, 0.0, 3.0)); // cube with edge index\n\n    if (d1.x > BOUNDS_MARGIN)\n    {\n        return d1;\n    }\n\n    pos1 = pos;\n    pos1 += vec3(0.0, -h * 4.0, 0.0) * 0.5;\n    d = abs(pos1) - vec3(w + 0.1, h * 2.0, depth * 2.0) * 0.5;\n    d2 = maxx(maxx(vec3(d.x, 0.0, 1.0), vec3(d.y, 0.0, 2.0)), vec3(d.z, 0.0, 3.0)); // cube with edge index\n    d2.x = -d2.x;\n    d1 = maxx(d1, d2); // cut middle step\n\n    d1.y = MATERIAL_BASE_ROCK;\n\n    return d1;\n}\n\nvec3 sdBasementDoor(vec3 pos)\n{\n    // bars\n    const float w1 = 0.1;\n    const float h1 = 0.6;\n    const float n1 = 2.0; // count\n    const float thickness1 = 0.01;\n\n    // frame\n    const float w2 = 0.06;\n    const float thickness2 = 0.11;\n    const float bevel2 = 0.03;\n\n    // lintel\n    const float h3 = 0.08;\n    const float thickness3 = 0.12;\n    const float bevel3 = 0.03;\n\n    // handle\n    const float r4 = 0.08;\n    const float thickness4 = 0.012;\n    const float r5 = 0.05;\n\n    pos.y -= h1;\n\n    float bounds = sdBoxApprox(pos, vec3(n1 * w1 + 2.0 * w2, h1 + h3, 0.2) + 0.1);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    // door\n    vec3 pos1 = pos;\n    float index = floor(pos1.x / (2.0 * w1));\n    index = clamp(index, -n1, n1 - 1.0);\n    pos1.x -= (index * 2.0 + 1.0) * w1;\n    float d = sdBox(pos1, vec3(w1, h1, thickness1));\n    vec3 d1 = vec3(d, MATERIAL_WOOD3, 1.0 + mod(index, 2.0));\n    d1.yz += 0.99 * fract(vec2(0.1, 0.01) * vec2(pos.x + pos.z, pos.y) + 0.1 * index + 0.5); // uv\n\n    // frame\n    pos1 = pos;\n    pos1.x = abs(pos1.x);\n    pos1.x -= n1 * 2.0 * w1;\n    d = sdBox(pos1, vec3(w2, h1 + h3, thickness2), vec3x1, bevel2);\n    vec3 d2 = vec3(d, MATERIAL_WOOD3, 3.0);\n    d2.yz += 0.99 * fract(vec2(0.1, 0.01) * vec2(pos.x + pos.z, pos.y) + 0.1 + 0.5); // uv\n    d1 = minx(d1, d2);\n\n    // lintel\n    pos1 = pos;\n    pos1.y -= h1;\n    d = sdBox(pos1, vec3(w1 * 2.0 * n1 + 2.0 * w2, h3, thickness3), vec3y1, bevel3);\n    d2 = vec3(d, MATERIAL_WOOD3, 5.0);\n    d2.yz += 0.99 * fract(vec2(0.01, 0.1) * vec2(pos.x, pos.y + pos.z) + 0.1 + 0.5); // uv\n    d1 = minx(d1, d2);\n\n    // handle\n    pos1 = pos;\n    pos1.x += (2.0 * n1 - 1.0) * w1;\n    pos1.z -= thickness1 + thickness4;\n    d = sdCircle(pos1.xy, r4 - thickness4);\n    d = length(vec2(d, pos1.z));\n    d -= thickness4;\n    d2 = vec3(d, MATERIAL_METAL2, 1.0);\n    d1 = minx(d1, d2);\n\n    pos1 = pos;\n    pos1.y -= r4;\n    pos1.x += (2.0 * n1 - 1.0) * w1;\n    pos1.z -= thickness1 - thickness4;\n    d = sdCircle(pos1.yz, r5 - thickness4);\n    d = length(vec2(d, pos1.x));\n    d -= thickness4;\n    d2 = vec3(d, MATERIAL_METAL2, 2.0);\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 sdBasement(vec3 pos)\n{\n    // brick walls\n    const vec3 size = vec3(1.2, 0.7, 1.3);\n    const float s = 2.5; // scale\n    const float bevel = 0.3;\n\n    // roof tiles\n    const float w1 = 0.2;\n    const float n1 = 3.0; // (count - 1) / 2\n    const float ext1 = 0.3; // extrude\n    const float thickness1 = 0.03;\n    const float bevel1 = 0.01;\n\n    // roof base wood bars\n    const float w2 = 0.15;\n    const float ext2 = -0.1; // extrude\n    const float n2 = 3.0;\n    const float thickness2 = 0.02;\n\n    pos.y -= size.y;\n\n    float bounds = sdBoxApprox(pos, vec3(size.x + ext1, size.y * 2.8, size.z) + 0.1);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    float d = sdBox(pos + vec3y(0.2), size - bevel + vec3y(0.2));\n    vec2 uv;\n    uv.x = pos.z > 0.0 ? (size.x - pos.x) : (3.0 * size.x + pos.x);\n    uv.x += size.z - pos.z;\n    uv.x /= 4.0 * size.x + 2.0 * size.z;\n    uv.y = (size.y + pos.y) / (2.0 * size.y);\n\n    vec2 v = d < 0.35 ? voronoi(uv * s * vec2(6.0, 1.0)) : vec2(0.0);\n\n    d -= bevel - 0.02 * v.x;\n\n    vec3 d1 = vec3(d, MATERIAL_BASE_ROCK + 0.5 * v.x + 0.1 * v.y, 2.0);\n\n    // roof\n    vec3 pos1 = pos;\n    pos1.x -= size.x + ext2;\n    pos1.y -= 2.0 * size.y + 0.5 * (size.x + ext2);\n    pos1.xy *= rotation_30;\n    float index = floor(pos1.z / (2.0 * w1) + 0.5);\n    index = clamp(index, -n1, n1);\n\n    pos1.z -= index * 2.0 * w1;\n\n    d = sdBox(pos1, vec3((size.x + 2.0 * ext2) / 0.866 + ext1, thickness1, w1), vec3(-1.0, 1.0, 0.0), bevel1);\n\n    vec3 d2 = vec3(d, MATERIAL_WOOD3, 1.0 + mod(index, 2.0));\n    d2.yz += 0.99 * fract(vec2(0.01, 0.1) * pos1.xz + 0.1 * index + 0.5); // uv\n    d1 = minx(d1, d2);\n\n    // roof base\n    pos1 = pos;\n    pos1.y -= size.y - 0.2;\n    index = floor(pos1.x / (2.0 * w2) + 0.5);\n    index = clamp(index, -n2, n2);\n\n    pos1.x -= index * 2.0 * w2;\n    d = sdBox(pos1, vec3(w2, size.x * 0.7, size.z + ext2), vec3y1, bevel1);\n\n    pos1 = pos;\n    pos1.y -= size.y + 0.5 * size.x;\n    pos1.xy *= rotation_30;\n    d = max(d, pos1.y);\n\n    d2 = vec3(d, MATERIAL_WOOD3, 3.0 + mod(index, 2.0));\n    d2.yz += 0.99 * fract(vec2(0.1, 0.01) * vec2(pos.x + pos.z, pos.y) + 0.1 * index + 0.5); // uv\n    d1 = minx(d1, d2);\n\n    // door\n    pos1 = pos;\n    pos1.x += 0.35;\n    pos1.z -= size.z + ext2;\n    pos1.y += size.y;\n    d1.x = max(d1.x, -sdBoxApprox(pos1 + vec3y(0.1), vec3(0.45, 0.7, 0.3), vec3y1));\n\n    d2 = sdBasementDoor(pos1);\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 sdWell(vec3 pos)\n{\n    // wall\n    const vec3 size1 = vec3(0.4, 0.25, 0.3); // brick size\n    const vec3 offset1 = vec3(0.05, 0.0, 0.01);\n    const float bevel1 = 0.06;\n    const float rows1 = 10.0;\n    const float columns1 = 10.0;\n\n    // support\n    const vec3 size2 = vec3(0.18, 0.35, 0.18);\n    const float bevel2 = 0.03;\n\n    // rod\n    const float curve3 = 3.0; // curve\n    const float thickness3 = 0.1;\n    const float width3 = 0.49;\n    const float height3 = 0.05;\n\n    // axis\n    const float thickness4 = 0.015;\n    const float length4 = 0.85;\n    const float r4 = 0.15; // rotation radius\n    const float skew4 = 0.05;\n    const float offset4 = 0.03;\n\n    // handle\n    const float thickness5 = 0.025;\n    const float length5 = 0.2;\n\n    // bolts\n    const float thickness6 = 0.01;\n    const float offset6 = 0.1;\n\n    // rope\n    const float thickness7 = 0.02;\n    const float count7 = 5.0;\n    const float skew7 = 0.1;\n    const float curve7 = 0.1;\n\n    float bounds = sdBoxApprox(pos + vec3y(0.5), vec3(0.8, 1.7, 0.8));\n    bounds = min(bounds, sdBoxApprox(pos + vec3(0.0, -0.7, -1.0), vec3(0.15, 0.15, 0.4)));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    // wall\n    vec3 pos1 = pos;\n    pos1.y += 2.0;\n    pos1.xz *= rotation_15;\n    vec3 d1 = sdRoundBricks(pos1, size1, offset1, bevel1, rows1, columns1, 0.0, MATERIAL_BASE_ROCK, 0.3);\n    d1.y += 0.3; // material shade\n\n    // support\n    pos1 = pos;\n    pos1.y -= 0.65;\n\n    vec3 pos2 = pos1;\n    pos2.z = abs(pos2.z);\n    pos2.z -= 0.62;\n    float d = sdRoundedRectangle(pos2.xy, size2.xy - bevel2, vec4(size2.x - bevel2, 0.0, size2.x - bevel2, 0.0));\n    d = max(0.0, d);\n    d = length(vec2(d, stretchAxis(pos2.z, size2.z - bevel2)));\n    d -= bevel2;\n    vec3 d2 = vec3(d, MATERIAL_WOOD4, 0.0);\n    d2.yz += fract(vec2(0.1, 0.01) * vec2(pos2.x + pos2.z, pos2.y) + 0.5); // uv\n    d1 = minx(d1, d2);\n\n    // rod\n    pos2 = pos1;\n    pos2.y -= height3;\n\n    vec3 pos3 = pos2;\n    d = sdCircle(pos3.xy, curve3 + thickness3);\n    d = length(vec2(d, pos3.z));\n    d -= curve3;\n    d = max(-d, sdCircle(pos3.xy, 2.0 * thickness3));\n    d = max(d, abs(pos3.z) - width3);\n    d2 = vec3(d, MATERIAL_WOOD4, 0.0);\n    d2.yz += fract(vec2(0.1, 0.01) * vec2(pos3.x + pos3.y, pos3.z) + 0.5); // uv\n    d1 = minx(d1, d2);\n\n    // axis\n    pos3 = pos2;\n    pos3.z -= offset4;\n    d = sdLine(pos3.zy, vec2(-length4, 0.0), vec2(length4, 0.0));\n    d = min(d, sdLine(pos3.zy, vec2(length4, 0.0), vec2(length4 + skew4, -r4)));\n    d = min(d, sdLine(pos3.zy, vec2(length4 + skew4, -r4), vec2(length4 + skew4 + 2.0 * thickness4 + thickness5 + 2.0 * length5, -r4)));\n    d = length(vec2(d, pos3.x));\n    d -= thickness4;\n    d2 = vec3(d, MATERIAL_METAL3, 1.0);\n    d1 = minx(d1, d2);\n\n    // handle\n    pos3 = pos2;\n    pos3.z -= offset4 + length4 + skew4 + thickness4 + thickness5 + length5;\n    pos3.y += r4;\n    d = sdCircle(pos3.xy, thickness5);\n    d = max(d, abs(pos3.z) - length5);\n    d2 = vec3(d, MATERIAL_WOOD4, 0.0);\n    d2.yz += fract(vec2(0.01, 0.1) * vec2(pos3.x + pos3.z, pos3.y) + 0.5); // uv\n    d1 = minx(d1, d2);\n\n    // bolts\n    pos3 = pos2;\n    pos3.z += length4 - offset6;\n    d = sdCircle(pos3.xy, 3.0 * thickness4);\n    d = max(d, abs(pos3.z) - thickness6);\n    d2 = vec3(d, MATERIAL_METAL3, 2.0);\n    d1 = minx(d1, d2);\n\n    pos3.z += 2.5 * thickness6;\n    d = sdCircle(pos3.xy, 2.5 * thickness4);\n    d = max(d, abs(pos3.z) - thickness6);\n    d2 = vec3(d, MATERIAL_METAL3, 3.0);\n    d1 = minx(d1, d2);\n\n    // rope loops\n    pos3 = pos2;\n    pos3.z -= skew7 * (pos3.x + pos3.y);\n    float index = floor(pos3.z / (2.0 * thickness7) + 0.5);\n    index = clamp(index, -count7, count7);\n    pos3.z -= index * 2.0 * thickness7;\n    d = sdCircle(pos3.xy, (0.9 + curve7 * pow2(index / count7)) * thickness3 + thickness7);\n    d = length(vec2(d, pos3.z));\n    d -= thickness7;\n    d2 = vec3(d, MATERIAL_ROPE, 1.0 + mod(index, 2.0));\n    d2.y += 0.99 * fract(sqrt(abs(sin(10.0 * atan(pos3.x, pos3.y) + 100.0 * pos3.z)))); // uv\n    d1 = minx(d1, d2);\n\n    // rope line\n    pos3 = pos2;\n    d = length(pos3.xz) - thickness7;\n    d = max(d, pos3.y);\n    d2 = vec3(d, MATERIAL_ROPE, 0.0);\n    d2.y += 0.99 * fract(sqrt(abs(sin(100.0 * (pos3.x + pos3.y))))); // uv\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec2 sdWellWater(vec3 pos, float time)\n{\n    const float height = 0.005; // ripple height\n    const float count = 20.0; // ripples count\n\n    pos -= WELL_POSITION;\n    pos.y -= HILL_HEIGHT;\n\n    pos.y += 0.75;\n\n    float bounds = sdBoxApprox(pos, vec3(1.0, 0.1, 1.0));\n    bounds = max(0.0, bounds);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec2(bounds, 0.0);\n    }\n\n    float r = length(pos.xz);\n    pos.y += height * pow2(max(0.8 - r, 0.0)) * sin(count * r - time);\n    float d = max(pos.y, bounds);\n\n    return vec2(d, MATERIAL_WATER);\n}\n\nvec3 sdHouse(vec3 pos, float time)\n{\n    vec3 d1, d2, d3;\n    vec3 pos1, pos2, pos3;\n\n    float bounds = sdBoxApprox(pos, vec3(5.0, HOUSE_HEIGHT / 2.0 + 5.0, 5.0), vec3y1);\n    bounds = min(bounds, sdBoxApprox(pos - vec3z(4.5), vec3(2.0, 2.5, 2.0), vec3(0.0, 1.0, 0.0))); // entrance\n    bounds = min(bounds, sdBoxApprox(pos - vec3(4.5, 0.0, -0.4), vec3(2.6, 3.5, 3.7), vec3(0.0, 1.0, 0.0))); // porch\n    bounds = min(bounds, sdBoxApprox(pos + vec3z(5.0), vec3(2.0, 2.0, 2.0), vec3(0.0, 1.0, 0.0))); // wood shade\n    bounds = min(bounds, sdBoxApprox(pos + vec3x(4.5), vec3(2.0), vec3(0.0, 1.0, 0.0))); // basement\n    bounds = min(bounds, sdBoxApprox(pos - WELL_POSITION + vec3y(2.0), vec3(1.1, 4.0, 1.1))); // well\n    bounds = min(bounds, sdBoxApprox(pos - vec3(9.0, 0.0, -0.5), vec3(1.0, 0.4, 3.5))); // yard flowers\n    if (bounds > BOUNDS_MARGIN_LARGE)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    d1 = vec3(MAX_DIST, 0.0, 0.0);\n    vec2 p = vec2(length(pos.xz), pos.y);\n    float wallsBounds = p.x - 3.92;\n\n    // roof\n    float roofBounds = sdRoofBounds(p - vec2y(HOUSE_HEIGHT - 0.2));\n    roofBounds = min(roofBounds, pos.y - HOUSE_HEIGHT);\n\n    pos1 = pos - vec3y(HOUSE_HEIGHT - 0.2);\n    d1 = sdRoof(pos1);\n\n    // lightning rod\n    d2 = sdLightningRod(pos1 - vec3y(5.6));\n    d1 = minx(d1, d2);\n\n    pos2 = pos1 + vec3x(3.3);\n    d2 = sdChimney(pos2);\n    d1 = minx(d1, d2);\n\n    d2 = sdChimneyTop(pos2 - vec3y(4.5));\n    d1 = minx(d1, d2);\n\n    // walls\n    d2 = sdOuterWalls(pos);\n    d1 = minx(d1, d2);\n\n#ifdef RENDER_HOUSE_DETAILS\n    // windows openings\n    d1.x = max(d1.x, -sdWindowsBounds(pos));\n    d2 = sdWindows(pos);\n    d1 = minx(d1, d2);\n\n    // Moomin room\n    pos2 = pos1;\n    pos2.xz *= rotation_n60;\n    pos2 -= vec3(0.0, 1.3, 2.6);\n\n    d1.x = max(d1.x, -sdMoominRoomBounds(pos2) - 0.05);\n\n    d2 = sdMoominRoom(pos2);\n    d2.x = max(d2.x, -roofBounds - 0.03);\n    d1 = minx(d1, d2);\n\n    d2 = sdMoomin(pos2 + vec3(0.0, 0.835, -0.8), state.origin - vec3(2.95, 25.15, 1.65), time);\n    d1 = minx(d1, d2);\n\n    // ladder\n    d2 = sdRopeLadder(pos2);\n    d1 = minx(d1, d2);\n\n    // house base\n    pos1 = pos;\n    pos1.xz *= rotation_180;\n    d2 = sdHouseBase(pos1);\n    d1 = minx(d1, d2);\n\n    // porch door\n    pos1 = pos;\n    pos1.xz *= rotation_n93;\n    pos1.z -= 3.9;\n    pos1.y -= 1.7;\n    d1.x = max(d1.x, -sdPorchDoorBounds(pos1));\n    d2 = sdPorchDoor(pos1 + vec3y(0.001));\n    d1 = minx(d1, d2);\n\n    // porch\n    pos1 = pos;\n    pos1.xz *= rotation_n93;\n    pos1.z -= 6.2;\n    d2 = sdPorch(pos1, time);\n    d2.x = max(d2.x, -wallsBounds);\n    d1 = minx(d1, d2);\n\n    // entrance door\n    pos1 = pos;\n    pos1.z -= 6.22;\n    pos1 -= vec3(0.0, 0.599, -2.3);\n    d1.x = max(d1.x, -sdEntranceDoorBounds(pos1));\n    d2 = sdEntranceDoor(pos1);\n    d1 = minx(d1, d2);\n\n    // entrance\n    pos1 = pos;\n    pos1.z -= 6.22;\n    d2 = sdEntrance(pos1);\n    d2.x = max(d2.x, -wallsBounds);\n    d1 = minx(d1, d2);\n\n    // wood shade\n    pos1 = pos;\n    pos1.xz *= rotation_180;\n    pos1.z -= 4.5;\n    d2 = sdWoodShade(pos1);\n    d1 = minx(d1, d2);\n\n    // kitchen door\n    pos1 = pos;\n    pos1.xz *= rotation_145;\n    pos1.z -= 3.92;\n    pos1.y -= 0.6;\n    d1.x = max(d1.x, -sdBoxApprox(pos1, vec3(0.6, 1.0, 0.4), vec3y1));\n    d2 = sdKitchenDoor(pos1);\n    d1 = minx(d1, d2);\n\n    // kitchen stairs\n    pos1 = pos;\n    pos1.xz *= rotation_145;\n    pos1.z -= 5.25;\n    d2 = sdKitchenStairs(pos1 - vec3y(0.001));\n    d1 = minx(d1, d2);\n\n    // basement\n    pos1 = pos;\n    pos1.xz *= rotation_90;\n    pos1.z -= 5.0;\n    pos1.xz *= rotation_n90;\n\n    d2 = sdBasement(pos1);\n    d2.x = max(d2.x, -wallsBounds);\n    d1 = minx(d1, d2);\n\n    // inner floors\n    d2 = sdFloors(pos);\n    d2.x = max(d2.x, roofBounds);\n    d1 = minx(d1, d2);\n\n    // well\n    pos1 = pos;\n    pos1 -= WELL_POSITION;\n    pos1.xz *= rotation_n145;\n    d2 = sdWell(pos1);\n    d1 = minx(d1, d2);\n#endif\n\n    return d1;\n}\n\nvec3 sdBridgeSegment(vec3 pos, float r, float r1, float n1, float n2, float dir)\n{\n    const float w = 1.5;\n    const float bevel = 0.03;\n\n    float w1 = 2.0 * r / r1;\n\n    // center segment\n    vec3 pos2 = pos;\n\n    float an = atan(pos2.x, dir * pos2.y);\n    float index = floor(an / w1 + 0.5);\n    index = clamp(index, n1, n2);\n    an -= index * w1;\n\n    pos2.xy = length(pos2.xy) * vec2(sin(an), cos(an));\n    pos2.y -= r1;\n\n    vec2 p = pos2.xy;\n    float r0 = length(p);\n    float d1 = sdCircle(p, r - bevel);\n    float d2 = sdRectangle(p + dir * vec2y(r1 + 0.5 * bevel), vec2(r1 - bevel));\n    d1 = max(d1, d2);\n    d1 = max(0.0, d1);\n    d1 = length(vec2(d1, stretchAxis(pos2.z, w - bevel * 2.0)));\n    d1 -= bevel;\n\n    vec3 d = vec3(d1, MATERIAL_WOOD3, 1.0 + mod(index, 2.0));\n    d.yz += mod(vec2(0.3 * (r0 + index), 0.003 * pos.z + w), 1.0); // uv stretch\n    return d;\n}\n\nvec3 sdBridgeHandrails(vec3 pos, float r, float h)\n{\n    const float r1 = 0.06;\n    const float r2 = 0.05;\n    const float w = 0.2; // poles angle\n\n    float an = atan(pos.x, pos.y);\n    float r0 = length(pos.xy);\n    float index = floor(an / w + 0.5);\n\n    vec3 pos1 = pos;\n    float d = sdCircle(pos1.xy, r + h);\n    d = abs(d);\n    d = max(0.0, d);\n    d = length(vec2(d, pos1.z));\n    d -= r1;\n\n    // rail\n    pos1.x = abs(pos1.x);\n    pos1.xy *= rotation_n30;\n    d = max(d, pos1.x);\n    vec3 d1 = vec3(d, MATERIAL_WOOD3, 3.0);\n    d1.yz += mod(0.5 * vec2(0.1 * (an + PI), r0), 1.0); // uv stretch\n\n    // poles\n\n    pos1 = pos;\n    index = clamp(index, -2.0, 2.0);\n    float an2 = index * w;\n\n    vec3 c = vec3(clamp(r0, r - 0.1, r + h) * vec2(sin(an2), cos(an2)), 0.0); // center\n    d = length(pos1 - c) - r2; // circle\n\n    vec3 d2 = vec3(d, MATERIAL_WOOD3, 2.0);\n    d2.yz += mod(vec2(an + index, 0.01 * r0), 1.0); // uv stretch\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 sdBridgeSupportRail(vec3 pos, float r, float startAngle, float endAngle, float dir, float side)\n{\n    const float w = 0.15;\n    const float h = 0.07;\n    const float bevel = 0.02;\n\n    r -= dir * h;\n\n    float an = atan(pos.y, pos.x);\n    float r0 = length(pos.xy);\n\n    vec3 pos1 = pos;\n    float d = sdCircle(pos1.xy, r);\n    d = abs(d) - h; // duplicate circle\n    d = max(0.0, d); // fill shape\n    d = length(vec2(d, stretchAxis(pos1.z, 2.0 * (w - bevel)))); // convert to 3d distance\n    d -= bevel;\n\n    d = max(d, -dir * pos1.y); // remove half\n\n    pos1 = pos;\n    pos1.xy *= rotation(-dir * startAngle);\n    d = max(d, -pos1.x); // cut start\n\n    pos1 = pos;\n    pos1.xy *= rotation(-dir * endAngle);\n    d = max(d, pos1.x); // cut end\n\n    vec3 d1 = vec3(d, MATERIAL_WOOD3, 5.0);\n    d1.yz += mod(0.2 * vec2(0.1 * an, (r0 + pos.z)), 1.0); // uv stretch\n\n    return d1;\n}\n\nvec3 sdBridgePosts(vec3 pos, float r, float w)\n{\n    const float r1 = 0.13;\n    const float h = 1.0;\n    vec2 gridSize = vec2(1.3, w);\n\n    float bounds = sdBoxApprox(pos, vec3(r, 1.5, w), vec3y1);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n    pos1.z += 0.5 * gridSize.y;\n    vec2 index = floor(pos1.xz / gridSize + 0.5);\n    index = clamp(index, vec2(-1.0, 0.0), vec2(1.0, 1.0));\n    pos1.xz -= index * gridSize;\n\n    vec3 pos2 = pos1;\n    float h1 = hash(index);\n    float an = 0.25 * (h1 - 0.5);\n    pos2.xy *= rotation(an);\n\n    float d1 = length(pos2.xz) - r1;\n    d1 = max(0.0, d1);\n\n    // bounds\n    float d2 = -sdRectangleApprox(pos1.xz, gridSize * 0.5 + 0.3);\n    float d3 = sdRectangleApprox(pos.xz, gridSize * vec2(1.5, 1.0));\n    d2 = max(d2, d3);\n    d1 = min(d1, d2);\n\n    pos1 = pos;\n    d2 = length(pos1.xy) - r;\n    d1 = max(d1, d2);\n\n    float an0 = atan(pos2.x, pos2.z);\n\n    vec3 d = vec3(d1, MATERIAL_WOOD3, 1.0);\n    d.yz += mod(0.02 * vec2(0.5 * pos2.y, an0), 1.0); // uv stretch\n    return d;\n}\n\nvec3 sdBridge(vec3 pos)\n{\n    // tile\n    const float r = 0.15;\n    const float w = 1.0;\n\n    // center curve\n    const float r1 = 2.5;\n    const float n1 = 5.0; // count\n    const float w1 = 2.0 * r / r1;\n\n    // side curve\n    const float r2 = 3.5;\n    const float n2 = 7.0; // count\n    const float start2 = 2.0; // start index\n    const float w2 = 2.0 * r / r2;\n    const vec2 offset2 = vec2(r1 * sin(n1 * w1) + r2 * sin(n2 * w2), r1 * cos(n1 * w1) + r2 * cos(n2 * w2));\n\n    // handrails\n    const float h3 = 0.6;\n    const float r3 = r1 * 1.2;\n\n    const float h = r1 * (1.0 - cos(n1 * w1)) + r2 * (1.0 - cos(n2 * w2));\n\n    float bounds = sdBoxApprox(pos, vec3(3.0, 1.6, 1.0));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n    pos1.y += r1 - h;\n\n    // center segment\n    vec3 pos2 = pos1;\n    float side = sign(pos2.x);\n    pos2.x = abs(pos2.x);\n    vec3 d1 = sdBridgeSegment(pos2, r, r1, 0.0, n1, 1.0);\n\n    // center segment support\n    pos2.z = abs(pos2.z);\n    pos2.z -= 0.5 * w;\n    vec3 d2 = sdBridgeSupportRail(pos2, r1 - r, 0.0, n1 * w1, 1.0, side);\n    d1 = minx(d1, d2);\n\n    // side segment\n    pos2 = pos1;\n    pos2.x = abs(pos2.x);\n    pos2.xy -= offset2;\n    d2 = sdBridgeSegment(pos2, r, r2, -n2 + 1.0, -start2, -1.0);\n    d2.z += 2.0; // edge offset\n    d1 = minx(d1, d2);\n\n    // side segment support\n    pos2.z = abs(pos2.z);\n    pos2.z -= 0.5 * w;\n    d2 = sdBridgeSupportRail(pos2, r2 + r, -n2 * w2, -start2 * w2, -1.0, side);\n    d1 = minx(d1, d2);\n\n    // handrails\n    pos2 = pos;\n    pos2.y += r3 - h;\n    pos2.z -= 0.6 * w;\n    d2 = sdBridgeHandrails(pos2, r3, h3);\n    d1 = minx(d1, d2);\n\n    // posts\n    pos2 = pos;\n    pos2.y += r1 - h + 0.2;\n    d2 = sdBridgePosts(pos2, r1, w);\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 sdMailboxPost(vec3 pos)\n{\n    // post\n    const float h = 1.8;\n    const float r = 0.04;\n\n    // mailbox\n    const float w1 = 0.15;\n    const float h1 = 0.23;\n    const float depth1 = 0.06;\n    const float thickness1 = 0.01;\n\n    // opening\n    const float w2 = w1 - 0.03;\n    const float h2 = 0.02;\n    const float offset2 = 0.01;\n\n    // top\n    const float w3 = w1 + 0.015;\n    const float h3 = depth1 * 1.4142 + 0.02;\n    const float thickness3 = 0.015;\n\n    // arrow tail\n    const float w4 = 0.15;\n    const float h4 = 0.04;\n    const float offset4 = 0.18;\n    const float thickness4 = 0.01;\n\n    // arrow head\n    const float w5 = 0.06;\n\n    const float bevel = 0.005;\n\n    float bounds = sdBoxApprox(pos, vec3(w1, h, w1) * 0.5 + 0.2, vec3y1);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n    pos1.z += depth1 + r;\n    pos1.y -= 0.6 * h;\n\n    // mailbox\n    float d = sdBox(pos1, vec3(w1, h1, depth1) - bevel) - bevel;\n    d = max(d, -d - thickness1); // hollow\n    float shade = -0.4 * pos1.y / h1;\n    vec3 d1 = vec3(d, MATERIAL_OUTER_WALL + clamp(shade, 0.0, 0.99), 1.0);\n\n    // opening\n    vec3 pos2 = pos1;\n    pos2.y -= offset2;\n    pos2.z += depth1;\n    d = sdBox(pos2, vec3(w2, h2, thickness1 + 0.01));\n    vec3 d2 = vec3(-d, MATERIAL_OUTER_WALL, 2.0);\n    d1 = maxx(d1, d2);\n\n    // roof\n    pos2 = pos1;\n    pos2.y -= h1;\n    pos2.yz *= rotation_n45;\n    pos2.y += depth1;\n\n    d1.x = max(d1.x, pos2.y); // cut top\n\n    pos2.z -= 0.025;\n    d = sdBox(pos2, vec3(w3, thickness3 * 0.5, h3), vec3(0.0, 1.0, -1.0), bevel);\n    shade = 0.25 * pos2.z / h3;\n    d2 = vec3(d, MATERIAL_TILE + clamp(shade, 0.0, 0.99), 0.0);\n    d1 = minx(d1, d2);\n\n    // arrow tail\n    pos2 = pos1;\n    pos2.y -= h1 + offset4;\n    pos2.z -= depth1 - thickness4;\n    vec3 pos3 = pos2;\n    pos3.x += w5 * 0.6;\n    d = sdRectangle(pos3.xy, vec2(w4, h4) - bevel);\n\n    // arrow head\n    pos3 = pos2;\n    pos3.x -= w4 - 0.1 * w5;\n    pos3.xy *= rotation_30;\n    d = min(d, sdTriangle(pos3.xy, w5));\n\n    d = max(0.0, d);\n    d = length(vec2(d, stretchAxis(pos3.z, thickness4)));\n    d -= bevel;\n    d2 = vec3(d, MATERIAL_TILE, 1.0);\n    d1 = minx(d1, d2);\n\n    // post\n    pos1 = pos;\n    pos1.y -= 0.5 * h;\n    d = length(pos1.xz) - r + bevel;\n    d = max(0.0, d);\n    d = length(vec2(d, stretchAxis(pos1.y, h)));\n    d -= bevel;\n    d2 = vec3(d, MATERIAL_WOOD3, 1.0);\n    d2.yz += 0.99 * fract(vec2(0.5) + vec2(0.1, 0.01) * vec2(pos1.x + pos1.z, pos1.y)); // uv\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nfloat getRiverJuiceMask(vec3 pos, float time)\n{\n    vec2 p = pos.xz;\n    p -= HAT_POSITION.xz + vec2(0.85, 0.15);\n\n    float bounds = sdRectangleApprox(p - vec2x1, vec2(3.0, 1.5));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return 0.0;\n    }\n\n    p *= 2.0;\n    float a = smoothstep(-2.0, 3.0, p.x);\n    p.x -= a * 6.0 * fbm(p - vec2x(time)); // stretch\n    p.y *= 3.0 - 2.0 * a; // taper\n\n    float d = length(p);\n\n    return d < 2.0 ? 1.0 : 0.0;\n}\n\nvec3 sdHat(vec3 pos)\n{\n    const float h1 = 0.30; // height\n    const float h2 = 0.01; // raised edge height\n    const float w1 = 0.06; // ribbon width\n    const float r1 = 0.16; // top radius\n    const float r2 = 0.13; // center radius\n    const float r3 = 0.17; // base radius\n    const float r4 = 0.19; // edge radius\n    const float thickness1 = 0.005; // thickness\n    const float thickness2 = 0.008; // ribbon thickness\n\n    float bounds = sdBoxApprox(pos, vec3(r4, 0.5 * h1, r4), vec3y1);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec2 pos1 = vec2(length(pos.xz), pos.y);\n\n    float d1 = sdLine(pos1, vec2(0.0, h1), vec2(r1, h1)); // top\n    float d2 = sdLine(pos1, vec2(r1, h1), vec2(r2, w1)); // side\n    d1 = min(d1, d2);\n\n    d2 = sdLine(pos1, vec2(r2, w1), vec2(r2, 0.0)); // bottom\n    d1 = min(d1, d2);\n\n    d2 = sdLine(pos1, vec2(r2, 0.0), vec2(r3, 0.0)); // bottom\n    d1 = min(d1, d2);\n\n    d2 = sdLine(pos1, vec2(r3, 0.0), vec2(r4, h2)); // edge\n    d1 = min(d1, d2);\n\n    d1 -= thickness1;\n\n    vec3 d = vec3(d1, MATERIAL_HAT, 0.0);\n\n    d1 = sdLine(pos1,\n    vec2(r2 + thickness1, thickness1 + w1),\n    vec2(r2 + thickness1, thickness1)); // ribbon\n    d1 -= thickness2;\n\n    d = minx(d, vec3(d1, MATERIAL_HAT_RIBBON, 0.0));\n\n    return d;\n}\n\nvec3 sdRock(vec3 pos, float size, float h1, float h2)\n{\n    float bounds = sdBoxApprox(pos, vec3(1.5 * size));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    float phase = PI * h2;\n\n    vec3 pos1 = pos;\n    pos1.x += 0.02 * (sin(15.0 * pos.x + phase) + sin(10.0 * pos.z + phase));\n    pos1.y += 0.01 * (sin(13.0 * pos.x + phase) + sin(18.0 * pos.z + phase));\n    pos1.z += 0.02 * (sin(10.0 * pos.x + phase) + sin(15.0 * pos.z + phase));\n    pos1.y += 0.4 * size;\n\n    pos1 /= size;\n    float d = sdSphere(pos1, 1.0);\n    d *= size;\n\n    return vec3(d, MATERIAL_PATHWAY_ROCK, 0.0);\n}\n\nvec3 sdRocks(vec3 pos, bool simplified)\n{\n    const float gridSize = 1.3;\n    const float size = 0.4; // rock size\n    const float margin1 = 10.0; // river banks\n    const float p1 = 0.8; // groups density\n    const float p2 = 0.3; // groups size\n    const float p3 = 0.6; // pathway scatter probability\n    const float p4 = 0.8; // river groups density\n    const float riverWidth = 2.0;\n    const float riverDepth = 1.9;\n    const float banksWidth = 1.0;\n    const float seed = 3.0;\n    const vec2[] offsets = vec2[2](vec2(0.0), gridSize * vec2(0.5, 0.25));\n\n    float bounds = pos.y - size;\n\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 d1 = vec3(MAX_DIST, 0.0, 0.0);\n\n    for (int i = 0; i < 2; i++)\n    {\n        vec3 pos1 = pos;\n        vec2 offset = offsets[i];\n\n        vec4 c = hexCoordinates(pos1.xz - offset, gridSize);\n        vec2 index = c.zw;\n\n        float h1 = hash(index + seed + 0.5 * float(i));\n        float h2 = hash(index + vec2(100.0) + seed + 0.5 * float(i));\n\n        vec2 center = pos1.xz - c.xy;\n        pos1.xz -= center.xy;\n\n        vec3 riverMask = getRiverMask(center.x);\n        float riverDist = abs(center.y - riverMask.z);\n        vec3 pathwayMask = getPathwayMask(center.y);\n        float pathwayDist = abs(center.x - pathwayMask.x) / pathwayMask.z;\n\n        float p = p1 + h1 * h2; // grass\n        p = fbm(index * gridSize * 0.2 + seed) < p2 ? p : 0.0; // mask grass\n        p += h1 < p3 && pathwayDist < 2.5 && center.y > 0.0 ? 1.0 : 0.0; // add pathway rocks\n        p = pathwayDist > 0.87 ? p : 0.0; // mask pathway center\n        p += h2 < p4 && riverDist < 0.5 * riverMask.x ? 1.0 : 0.0; // add more river rocks\n        p = abs(riverDist - 0.5 * riverMask.x) > 0.4 ? p : 0.0; // mask river banks\n\n        if (p < 1.0)\n        {\n            continue;\n        }\n\n        pos1.xz -= 0.5 * map01_11(vec2(h1, h2));\n\n        float size1 = size * (1.0 - 0.5 * h2);\n\n        if (simplified)\n        {\n            vec3 d2 = vec3(sdSphere(pos1, size1 + 0.08), 100.0, 0.0);\n            d1 = minx(d1, d2);\n            continue;\n        }\n\n        vec3 d2 = sdRock(pos1, size1, h1, h2);\n        d1 = minx(d1, d2);\n    }\n\n    return d1;\n}\n\nvec3 sdPathway(vec3 pos)\n{\n    const float z1 = 5.5; // entrance\n    const float z2 = 8.0; // entrance\n    const float z3 = 40.0; // bridge exit\n    const float z4 = 50.0; // bridge exit\n    const float z5 = 50.0; // bridge entrance\n    const float z6 = 60.0; // bridge entrance\n\n    const float depth1 = 0.04; // base\n    const float depth2 = 0.05; // bump\n    const float bevel = 0.3;\n\n    pos.y -= getGroundHeight(pos);\n\n    float bounds = sdRectangleApprox(pos.xy + vec2x(8.0), vec2(10.0, 0.2));\n    bounds = max(bounds, -pos.z);\n\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n\n    float mask1 = smoothstep(z2, z1, pos1.z) + // entrance path\n            smoothstep(z3, z4, pos1.z) * smoothstep(z6, z5, pos1.z); // bridge path\n\n    pos1.y -= 0.1 * mask1;\n\n    vec3 mask = getPathwayMask(pos1.z);\n    float width = mask.z;\n    float center = mask.x;\n\n    float depth = depth1 + (1.0 - mask1) * depth2 * (sin(pos1.z * 3.0) + sin(pos1.z + pos1.x * 5.0) + 2.0) / 4.0;\n\n    pos1.x -= center;\n    pos1.y += depth;\n    float d = sdRectangle(pos1.xy - vec2y(0.5), vec2(width, depth + 0.5) - bevel);\n    d = max(0.0, d);\n    d -= bevel;\n\n    d = max(d, -pos.z);\n\n    return vec3(d, MATERIAL_PATHWAY, 0.0);\n}\n\nvec3 sdPathwayEdges(vec3 pos)\n{\n    const float width1 = 1.0;\n    const float width2 = 1.2;\n    const float thickness1 = 0.05;\n    const float thickness2 = 0.15;\n    const float r1 = 50.0; // river position\n    const float r2 = 2.0; // river width\n\n    float h = getGroundHeight(pos);\n    float bounds = pos.y - h - thickness2;\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 mask1 = getPathwayMask(pos.z);\n    float d1 = abs(pos.x - mask1.x);\n\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    float width = mask1.z;\n\n    float curvePos = 0.2 * pos.z;\n    float thickness = mix(thickness1, thickness2, 0.5 + 0.5 * abs(sin(23.0 * curvePos) + cos(17.0 * curvePos)));\n\n    float mask2 = smoothstep(r1 - 3.0, r1 - 2.0, pos.z) - smoothstep(r1 + 2.0, r1 + 3.0, pos.z); // bridge mask\n    mask2 += smoothstep(7.0, 5.0, pos.z); // entrance mask\n\n    thickness = mix(thickness, thickness2, mask2);\n    pos.y += 0.5 * mask2;\n\n    pos.y -= 0.05;\n    pos.y += 0.8 * thickness;\n\n    d1 = length(vec2(abs(d1 - width), pos.y - h)) - thickness;\n\n    float d2 = abs(pos.z - r1) - r2;\n    d1 = smax(d1, -d2, 0.2);\n\n    return vec3(d1, MATERIAL_GRASS, 0.0);\n}\n\nvec3 sdGround(vec3 pos)\n{\n    float h = getGroundBaseHeight(pos);\n\n    float bounds = pos.y - h;\n    if (bounds > 1.5)\n    {\n        return vec3(bounds, MATERIAL_GRASS, 0.0);\n    }\n\n    h = getGroundHeight(pos, h);\n    vec3 riverMask = getRiverMask(pos.x);\n\n    float d1 = pos.y - h;\n\n    float d2 = length(pos.xz - WELL_POSITION.xz) - 0.7; // well\n\n    d2 = max(d2, -pos.y + HILL_HEIGHT - 2.0);\n    d1 = max(d1, -d2);\n\n    if (pos.y < 0.1 && abs(pos.z - riverMask.z) < riverMask.x || d2 < 0.0)\n    {\n        return vec3(d1, MATERIAL_RIVERBED, 0.0);\n    }\n\n    return vec3(d1, MATERIAL_GRASS, 0.0);\n}\n\nvec3 sdRiverBanks(vec3 pos)\n{\n    const float thickness1 = 0.1;\n    const float thickness2 = 0.2;\n    const float riverWidth = 2.0;\n    const float rocksGap = 0.7;\n    const float rocksSize = 0.3;\n    const float rocksDensity = 0.6;\n    const float seed = 100.0;\n\n    float bounds = pos.y - 0.2;\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n    pos1.y += 0.05;\n    float curvePos = pos1.x * 0.4;\n    float thickness = mix(thickness1, thickness2, 0.5 * abs(sin(13.0 * curvePos) + cos(7.0 * curvePos)));\n\n    vec3 riverMask = getRiverMask(pos1.x);\n    float dist = abs(riverMask.z - pos1.z) - 0.38 * riverMask.x -0.9 + thickness;\n\n    vec3 pos2 = pos1;\n    pos2.y += 0.7 * thickness - 0.15;\n    float d = length(vec2(dist, pos2.y)) - thickness;\n\n    return vec3(d, MATERIAL_GRASS, 1.0); // grass material with group 0 doesn't cast shadow\n}\n\nvec3 sdRiverBanksRocks(vec3 pos)\n{\n    const float riverWidth = 2.0;\n    const float gap = 1.2;\n    const float size1 = 0.4;\n    const float size2 = 0.6;\n    const float p0 = 0.5; // group size\n    const float p1 = 0.5; // group gap\n    const float p2 = 0.7; // density\n    const float seed = 3.0;\n\n    vec3 pos1 = pos;\n\n    vec3 riverMask = getRiverMask(pos1.x);\n    pos1.z -= riverMask.z;\n    pos1.z -= sign(pos1.z) * riverMask.x * 0.5;\n\n    float bounds = sdCircle(pos1.yz, 0.8);\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 d1 = vec3(MAX_DIST, 0.0, 0.0);\n\n    for (int i = 0; i < 2; i++)\n    {\n        pos1 = pos;\n\n        float offset = float(i) * gap * 0.5;\n        pos1.x -= offset;\n\n        float index = floor(pos1.x / gap + 0.5);\n        index = sign(index + 0.01) * max(2.0, abs(index)); // mask bridge\n\n        riverMask = getRiverMask(index * gap + offset);\n\n        pos1.x -= index * gap;\n        pos1.z -= riverMask.z;\n\n        index += 1000.0 * sign(pos1.z) + float(i) * 2000.0;\n\n        float h1 = fbm(vec2((index + 0.5 * float(i)), 0.0) / p0 + seed);\n\n        index += float(i) * 2000.0;\n        float h2 = hash(index + seed);\n        float h3 = hash(index + 100.0 + seed);\n\n        if (h1 > p1 || h2 > p2)\n        {\n            continue;\n        }\n\n        float size = mix(size1, size2, h2);\n\n        pos1.z = abs(pos1.z);\n        pos1.z -= 0.5 * riverMask.x;\n\n        pos1.yz += 0.8 * size - vec2(0.4, 0.5);\n\n        vec3 d2 = sdRock(pos1, size, h2, h3);\n        d1 = minx(d1, d2);\n    }\n\n    return d1;\n}\n\nvec2 sdRiverWater(vec3 pos, float time)\n{\n    const float h1 = 0.01; // ripple height\n    const float h2 = 0.01; // rocks ripple height\n    const float h3 = 0.02; // bridge ripple height\n\n    float bounds = pos.y - h1;\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec2(bounds, MATERIAL_WATER);\n    }\n\n    vec3 riverMask = getRiverMask(pos.x);\n    float d = abs(pos.z - riverMask.z) - riverMask.x;\n\n    d = max(0.0, d);\n    if (d > BOUNDS_MARGIN)\n    {\n        return vec2(d, MATERIAL_WATER);\n    }\n\n    float d2 = sdRiverBanksRocks(pos).x;\n\n    vec3 pos1 = pos;\n    pos1.y += 1.35;\n    pos1.z -= 50.0;\n    pos1.xz *= rotation_n90;\n    float d3 = sdBridgePosts(pos1, 2.5, 1.0).x;\n\n    float h = 0.0;\n    h += h1 * sin(5.0 * pos.x - 4.0 * time);\n    h += h2 * smoothstep(0.2, 0.0, d2) * (sin(40.0 * d2 - 2.0 * time));\n    h += h3 * smoothstep(0.1, 0.0, d3) * (sin(40.0 * d3 - 2.0 * time + PI05));\n\n    d = max(pos.y + h, d);\n\n    return vec2(d, MATERIAL_WATER);// + ref);\n}\n\nvec3 sdGrass(vec3 pos, float time)\n{\n    const vec2 gridSize1 = vec2(0.05);\n    const vec2 gridSize2 = vec2(0.15);\n    const float h1 = 0.08;\n    const float h2 = 0.15;\n    const float h3 = 0.03;\n    const float r1 = 0.005;\n    const float r2 = 0.015;\n    const float rocksMargin = 0.0;\n    const vec2[] offsets = vec2[](vec2(0.0), vec2(0.2, 0.8), vec2(0.7, 0.3));\n\n    float bounds = pos.y - h1 - 2.0 * h3;\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    float viewDist = length(state.origin - pos);\n\n    float d1 = pos.y;\n    vec2 rootPos = pos.xz;\n\n    float rocksDist = sdRocks(vec3(pos.xz, 0.0).xzy, true).x - rocksMargin;\n    float rocksMask1 = smoothstep(-0.1, 0.0, rocksDist);\n\n    vec3 riverMask1 = getRiverMask(pos.x);\n    float riverMask2 = smoothstep(0.75, 0.8, abs(pos.z - riverMask1.z) - 0.38 * riverMask1.x);\n\n    vec3 pathwayMask1 = getPathwayMask(pos.z);\n    float pathwayDist = abs(pathwayMask1.x - pos.x) - pathwayMask1.z;\n    float pathwayMask2 = smoothstep(0.0, 0.1, pathwayDist);\n    pathwayMask2 = pos.z < 0.0 ? 1.0 : pathwayMask2;\n\n    float wellMask = smoothstep(0.8, 0.85, length(pos.xz - WELL_POSITION.xz));\n\n    float mask = rocksMask1 * riverMask2 * pathwayMask2 * wellMask;\n\n    if (mask < 0.01)\n    {\n        return vec3(MAX_DIST, 0.0, 0.0);\n    }\n\n    if (viewDist > 100.0)\n    {\n        d1 = pos.y - 0.5 * (h1 + h2);\n    }\n    else\n    {\n        pos.xz += 0.1 * vec2(sin(4.0 * pos.z), sin(4.0 * pos.x)); // wrap grid\n        vec3 windForce = getWindForce(pos, time) * rocksMask1;\n\n        for (int i = 0; i < 3; i++)\n        {\n            float j = float(i);\n\n            vec3 pos1 = pos;\n            vec2 gridSize = mix(gridSize1, gridSize2, j / 2.0);\n            pos1.xz += offsets[i] * gridSize;\n\n            float h = mix(h1, h2, map11_01(0.5 * (sin(7.1 * pos1.x + 1.8 * j) + sin(9.3 * pos1.z + 1.5 * j))));\n            h += j * h3;\n            h *= mask;\n\n            vec3 dir = vec3y1;\n            dir += windForce * (j * 0.5 + 1.0);\n            dir.y = max(0.0, dir.y);\n            dir = normalize(dir);\n            dir *= h;\n\n            float y = clamp(pos1.y / dir.y, 0.0, 1.0);\n\n            pos1.xz -= 0.2 * dir.xz * pow(y, 2.0); // curve\n\n            vec2 gridOffset = y * dir.xz; // offset grid index based on the direction relative to the queried position height\n            vec2 index = floor((pos1.xz - gridOffset) / gridSize + 0.5);\n            vec3 pos2 = pos1;\n\n            float h1 = hash(index);\n            float h2 = fract(h1 * h1);\n\n            pos2.xz -= index * gridSize;\n            pos2.xz += 0.3 * gridSize * map01_11(vec2(h1, h2)); // jitter\n\n            float r = mix(r2, r1, y);\n            float d2 = sdCapsule(pos2, vec3(0.0), dir, r);\n\n            rootPos = d2 < d1 ? index * gridSize : rootPos;\n            d1 = min(d1, d2);\n        }\n    }\n\n    vec3 d = vec3(d1, MATERIAL_GRASS, 0.0);\n    d.yz += fract(rootPos / 1000.0 + 0.5); // serialize root position\n    return d;\n}\n\nvec3 sdGrassFlower(vec3 pos, float hue, float scale, vec3 dir)\n{\n    const float size1 = 0.02; // petals\n    const float thickness1 = 0.002;\n    const float size2 = 0.03; // base\n    const float size3 = 0.02; // disk\n    const float size4 = 0.2; // stem\n    const float thickness4 = 0.004;\n\n    pos /= scale;\n\n    float bounds = sdBoxApprox(pos, vec3(0.07, 0.1, 0.07), vec3y1) * scale;\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    pos.zy *= rotation(atan(-dir.z, dir.y));\n    pos.xy *= rotation(atan(-dir.x, dir.y));\n\n    pos.y -= 0.8 * size4;\n\n    // petals\n    vec3 pos1 = pos;\n    pos1.xy *= rotation_n30;\n\n    float index = 0.0;\n    vec3 pos2 = pos1;\n    pos2.xz = radialMod(pos2.xz, 5.0, index);\n    pos2.x -= 1.5 * size1;\n    pos2.xy *= rotation_30;\n    float d = sdCircle(pos2.xz, size1);\n    d = max(0.0, d);\n    d = length(vec2(d, pos2.y));\n    d -= thickness1;\n    vec3 d1 = vec3(d, MATERIAL_GRASS_FLOWER1, hue);\n\n    // base\n    pos2 = pos1;\n    pos2.y -= 0.4 * size2;\n    d = sdSphere(pos2, size2);\n    d = max(d, pos2.y + 0.68 * size2);\n    vec3 d2 = vec3(d, MATERIAL_GRASS, 0.8);\n    d1 = smin(d1, d2, 0.01);\n\n    // stem\n    pos2 = pos;\n    pos2.x -= 0.73 * size4;\n    pos2.y += 0.7 * size4;\n    d = sdCircle(pos2.xy, size4);\n    d = length(vec2(d, pos2.z));\n    d = max(d, pos2.x);\n    d = max(d, pos1.y + 0.1 * size4);\n    d = max(d, -pos2.y);\n    d -= thickness4;\n    d2 = vec3(d, MATERIAL_GRASS, 0.5);\n    d1 = smin(d1, d2, 0.01);\n\n    // disk\n    pos2 = pos1;\n    pos2.y += size3;\n    d = sdSphere(pos2, size3);\n    d = max(d, -pos2.y + 0.5 * size3);\n    d2 = vec3(d, MATERIAL_GRASS_FLOWER2, 0.0);\n    d1 = minx(d1, d2);\n\n    d1.x *= scale;\n    return d1;\n}\n\nvec3 sdGrassFlowers(vec3 pos, float time)\n{\n    const vec2 gridSize = vec2(0.5);\n    const float p1 = 1.8; // groups density\n    const float p2 = 0.4; // groups size\n    const float seed = 1.0;\n\n    float bounds = pos.y - 0.2;\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    float viewDist = length(state.origin - pos);\n    if (viewDist > 80.0)\n    {\n        return vec3(MAX_DIST, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n\n    float h = 0.35 + 0.05 * (sin(pos.x) + sin(pos.z)); // height\n\n    vec3 dir = vec3y1;\n    dir += 0.3 * getWindForce(pos, time + 0.2);\n    dir.y = max(0.0, dir.y);\n    dir = normalize(dir);\n    dir *= h / dir.y;\n\n    float y = clamp(pos1.y / dir.y, 0.0, 1.0);\n\n    vec2 index = floor((pos1.xz - y * dir.xz) / gridSize + 0.5);\n\n    vec3 center = vec3(index * gridSize, pos1.y).xzy;\n    \n    vec3 pos2 = pos1;\n    pos2.xz -= index * gridSize;\n\n    vec3 riverMask = getRiverMask(center.x);\n    float riverDist = abs(center.z - riverMask.z) - riverMask.x;\n\n    vec3 pathwayMask = getPathwayMask(center.z);\n    float pathwayDist = abs(center.x - pathwayMask.x) - pathwayMask.z - 0.05;\n\n    float rockDist = MAX_DIST;\n#ifdef RENDER_ROCKS\n    rockDist = sdRocks(center, false).x - 0.04;\n#endif\n\n    float wellDist = length(center.xz - WELL_POSITION.xz) - 0.6;\n\n    float p = fbm(index / p1 + 100.0 * seed);\n    if (p > p2 || riverDist < 0.1 || pathwayDist < 0.1 || rockDist < 0.1 || wellDist < 0.1)\n    {\n        return vec3(MAX_DIST, 0.0, 0.0);\n    }\n\n    pos2.xz -= 0.1 * y * dir.xz; // skew\n\n    float h1 = hash(index + seed);\n    float h2 = hash(index + seed + 1000.0);\n    float h3 = fract(h1 + h2);\n    float h4 = fract(h1 - h2);\n\n    pos2.xz -= (0.5 * gridSize - 0.1) * map01_11(vec2(h1, h2)); // jitter\n    pos2.xz *= rotation(h3 * PI2);\n\n    float hue = h1 < 0.7 ? 0.0 : 0.99;\n    float scale = 1.0 + 0.3 * h4;\n\n    vec3 d1 = sdGrassFlower(pos2, hue, scale, dir);\n    \n    return d1;\n}\n\nvec3 sdFlowers(vec3 pos, float time)\n{\n    const vec2 gridSize = vec2(0.25);\n    const vec2 gridBounds = vec2(1.0, 2.0);\n    const float r = 0.6;\n\n    float bounds = sdBoxApprox(pos, vec3(r + 0.2));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 d1 = vec3(MAX_DIST, 0.0, 0.0);\n\n    vec3 pos1 = pos;\n    float s = 1.0;\n    for (int i = 0; i < 2; i++)\n    {\n        vec3 pos2 = pos1;\n        vec2 index = floor(pos2.xz / gridSize);\n        index = clamp(index, -gridBounds, gridBounds);\n        pos2.xz -= gridSize * (index + 0.5);\n\n        float h1 = hash(index + 1000.0 * float(i));\n        float h2 = hash(index + 100.0 + 1000.0 * float(i));\n        pos2.xz *= rotation(h1 * PI2);\n\n        float s = 1.0 - 0.4 * h1;\n        pos2.y -= 0.3 * s;\n        pos2 /= s;\n        vec3 d2 = sdFlower(pos2, h2);\n        d2.x *= s;\n        d1 = minx(d1, d2);\n\n        pos1.xz *= rotation_7_5;\n        pos1.xz += 0.1;\n    }\n\n    return d1;\n}\n\nfloat sdLeaf(vec2 p, float size)\n{\n    p /= size;\n\n    float offset = 0.5 * smoothstep(0.0, 1.0, pow(abs(p.x), 0.7));\n    vec2 p1 = p;\n    p1.y -= offset;\n    float d1 = length(p1) - 1.0;\n\n    p1 = p;\n    p1.x = abs(p1.x);\n    p1 *= rotation_n7_5;\n    float d2 = p1.x;\n    d2 = max(d2, p1.y - 1.8);\n\n    d1 = min(d1, d2);\n\n    d1 *= size;\n    return d1;\n}\n\nvec3 sdMountains(vec3 pos)\n{\n    const float scale = 200.0;\n\n    const float f = 2.0;\n    const float r1 = 2.0;\n    const float h1 = 1.6;\n    const float thickness1 = 0.8;\n    const float count1  = 4.0;\n    const float offset1 = -1.4;\n\n    const float r2 = 3.0;\n    const float h2 = 2.0;\n    const float thickness2 = 1.0;\n    const float variation2 = 0.3;\n    const float count2  = 3.0;\n    const float offset2 = 3.6;\n\n    const float bumps = 0.2;\n    const float details = 2.5;\n    const float seed = 0.0;\n\n    pos /= scale;\n\n    vec3 pos1 = pos;\n\n    float r = length(pos1.xz);\n\n    float bounds = (abs(r - 3.0) - 2.0) * scale;\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    pos1.y -= bumps * fbm(pos1 * details + seed) - 0.1;\n    pos1.y += thickness1;\n\n    float an = atan(pos1.z, pos1.x);\n\n    float d1 = sdCircle(pos1.xz, r1);\n    float h = pow(map11_01(sin(count1 * an + offset1)), 0.8) * h1;\n    d1 = length(vec2(d1, stretchAxis(pos1.y, h)));\n    d1 -= thickness1;\n\n    float mask = smoothstep(0.0, 1.0, abs(an + PI05)); // front valley mask\n\n    float d2 = sdCircle(pos1.xz, r2);\n    h = pow(map11_01(sin(count2 * an + PI + offset2)) + 0.05, 0.3) * h2;\n    h *= 1.0 + variation2 * sin((count2 - 1.0) * an); // variation\n    h *= mask;\n    d2 = length(vec2(d2, stretchAxis(pos1.y, h)));\n    d2 -= thickness2 * mask;\n\n    d1 = min(d1, d2);\n\n    d1 = smin(d1, pos.y + 0.1, 0.8);\n    d1 = max(d1, -pos.y);\n    d1 = max(d1, r - r2 - 2.0 * thickness2);\n\n    return vec3(d1 * scale, MATERIAL_MOUNTAIN, 0.0);\n}\n\nvec3 sdTreeBranches(vec3 pos, float count, float size)\n{\n    const float size1 = 0.5;\n    const float thickness1 = 0.01;\n    const float width1 = 0.9;\n    const float curve1 = 1.0;\n\n    pos /= size;\n\n    float bounds = sdBoxApprox(pos, vec3(0.8, 0.3, 0.8), vec3y(-0.9)) * size;\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n    float index;\n\n    pos1.xz = radialMod(pos1.xz, count, index);\n\n    pos1.x = -pos1.x + size1;\n\n    pos1.xy *= rotation_n30;\n    float an = atan(pos1.y, pos1.x);\n    an = clamp(an, -curve1, curve1 * 0.4);\n    float width = width1 * (an + curve1) / (2.0 * curve1);\n    float thickness = thickness1 / size;\n\n    float d1 = length(pos1.xy - size1 * vec2(cos(an), sin(an)));\n    d1 = length(vec2(d1, stretchAxis(pos1.z, width)));\n    d1 -= thickness;\n\n    vec3 d = vec3(d1, MATERIAL_TREE_BRANCH, 0.0);\n\n    d.x *= size;\n\n    return d;\n}\n\nvec3 sdTree(vec3 pos, float size, float time)\n{\n    const float thickness1 = 0.07; // bark\n\n    pos /= size;\n\n    float bounds = sdBoxApprox(pos, vec3(1.6), vec3y(0.9)) * size;\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n\n    time *= 0.5;\n    pos1.y += 0.05 * (sin(3.0 * pos1.x + time) + sin(2.0 * pos1.z + time));\n    pos1.x += 0.05 * sin(0.7 * time) * pow(max(pos1.y, 0.0), 1.5);\n    pos1.z += 0.05 * sin(time) * pow(max(pos1.y, 0.0), 1.5);\n\n    vec3 pos2 = pos1;\n    pos2.y -= 2.9;\n    float d = sdCircle(pos2.xz, max(0.0, -thickness1 * pos2.y));\n    d = max(0.0, d);\n    d = max(d, pos2.y);\n\n    vec3 d1 = vec3(d, MATERIAL_TREE_BARK, 0.0);\n\n    for (int i = 0; i < 4; i++)\n    {\n        float index = float(i);\n        vec3 pos2 = pos1;\n        pos2.y -= 2.4 + index * 0.2;\n        vec3 d2 = sdTreeBranches(pos2, 8.0 - index, 3.5 - 0.6 * pow(index, 1.2));\n        d1 = minx(d1, d2);\n    }\n\n    d1.x *= size;\n\n    return d1;\n}\n\nvec3 sdTrees(vec3 pos, float time)\n{\n    const float gridSize = 8.0;\n    const float r1 = 50.0;\n    const float scale = 3.0;\n    const float seed = 2.0;\n\n    float bounds = max(pos.y - 10.0, -(length(pos.xz) - 10.0));\n    if (bounds > 10.0)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n\n    vec4 c = hexCoordinates(pos1.xz, gridSize);\n\n    vec2 index = c.zw;\n    vec3 center = pos1 - vec3(c.xy, pos1.y).xzy;\n\n    pos1 -= center;\n    pos1.y -= getGroundHeight(center);\n\n    float bounds2 = -sdHexApprox(pos1.xz, 1.3 * gridSize);\n\n    if (abs(center.x) < 32.0 || abs(center.z - 40.0) < 15.0)\n    {\n        return vec3(bounds2, 0.0, 0.0);\n    }\n\n    float mask = fbm(0.2 * index + seed);\n    if (mask > 0.35)\n    {\n        return vec3(bounds2, 0.0, 0.0);\n    }\n\n    float h1 = map01_11(hash(index + 100.0 + seed));\n    float h2 = map01_11(hash(index + 200.0 + seed));\n    float h3 = map01_11(hash(index + 300.0 + seed));\n\n    pos1.xz += (1.5 - h3) * vec2(h1, h2);\n\n    pos1.xy *= rotation(0.2 * h1);\n    pos1.xz *= rotation(PI2 * h2);\n\n    vec3 d1 = sdTree(pos1, scale + h3, time + 10.0 * h3);\n\n    d1.x = min(d1.x, bounds2);\n\n    return d1;\n}\n\nvec3 sdClouds(vec3 pos, float time)\n{\n    const float gridSize = 160.0;\n    const vec3 size = 50.0 * vec3(1.0, 0.5, 1.0);\n    const float speed1 = 5.0;\n    const float speed2 = 8.0;\n    float seed = 26.0;\n\n    pos.y -= 100.0;\n\n    float bounds = -pos.y - 2.0 * size.y;\n    if (bounds > 1.0)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    float bump = 15.0 * map01_11(fbm(0.05 * vec3(1.0, 1.0, 0.5)  * pos));\n\n    float d1 = MAX_DIST;\n\n    for (int i = 0; i < 2; i++)\n    {\n        float j = float(i);\n\n        vec3 pos1 = pos;\n\n        pos1.y -= size.y * j;\n        pos1.z -= time * mix(speed1, speed2, j);\n        pos1.xz += 0.5 * gridSize * j;\n\n        float gridSize1 = gridSize * (1.0 + 0.5 * j);\n        vec2 index = floor(pos1.xz / gridSize1 + 0.5);\n\n        pos1.xz -= index * gridSize1;\n\n        bounds = sdRectangleApprox(pos1.xz, 0.6 * vec2(gridSize1));\n\n        float h1 = hash(index + seed);\n        float h2 = hash(index + 1000.0 + seed);\n        float h3 = fract(h1 + h2);\n\n        float size1 = 1.0 - 0.7 * h3;\n        vec3 size2 = size * size1;\n        pos1.xz -= (0.4 * vec2(gridSize) - size2.xz) * map01_11(vec2(h1, h2));\n\n        float d2 = sdEllipsoid(pos1, size2);\n        d2 -= bump * size1;\n        d2 = min(d2, -bounds);\n\n        d1 = min(d1, d2);\n    }\n\n    d1 = max(d1, abs(pos.y) - 2.0 * size.y);\n    d1 = max(d1, length(pos - state.origin) - MAX_DIST + 50.0);\n\n    return vec3(d1, MATERIAL_CLOUD, 0.0);\n}\n\nvec3 sdBackground(vec3 pos, float time)\n{\n    vec3 d1 = vec3(MAX_DIST, MATERIAL_SKY, 0.0);\n    vec3 d2, pos1;\n\n#ifdef RENDER_MOUNTAINS\n    pos1 = pos;\n    pos1.xz -= state.origin.xz;\n    d2 = sdMountains(pos1);\n    d1 = minx(d1, d2);\n#endif\n\n#ifdef RENDER_GROUND\n    d2 = sdGround(pos);\n    d1 = minx(d1, d2);\n\n    d2 = sdPathway(pos);\n    d1 = maxx(d1, vec3(-d2.x, d2.yz));\n#endif\n\n#ifdef RENDER_CLOUDS\n    d2 = sdClouds(pos, time);\n    d1 = minx(d1, d2);\n#endif\n\n    return d1;\n}\n\nvec3 map(vec3 pos, float time, bool shadowPass)\n{\n    vec3 d1, d2;\n    vec3 pos1, pos2;\n\n    d1 = vec3(MAX_DIST, 0.0, 0.0);\n\n    float time1 = time;\n\n    pos1 = pos;\n    pos1.y -= getGroundHeight(pos);\n\n    if (!shadowPass)\n    {\n#ifdef RENDER_GROUND\n    d2 = sdGround(pos);\n    d1 = minx(d1, d2);\n\n    d2 = sdPathway(pos);\n    d1 = maxx(d1, vec3(-d2.x, d2.yz));\n#endif\n\n#ifdef RENDER_GRASS\n    d2 = sdGrass(pos1, time);\n    d1 = minx(d1, d2);\n#endif\n\n#ifdef RENDER_FLOWERS\n    d2 = sdGrassFlowers(pos1, time);\n    d1 = minx(d1, d2);\n#endif\n    }\n\n#ifdef RENDER_GROUND\n    d2 = sdRiverBanks(pos);\n    d1 = smin(d1, d2, 0.1);\n\n    d2 = sdPathwayEdges(pos);\n    d1 = smin(d1, d2, 0.1);\n#endif\n\n#ifdef RENDER_ROCKS\n    d2 = sdRocks(pos1, false);\n    d1 = minx(d1, d2);\n\n    d2 = sdRiverBanksRocks(pos);\n    d1 = minx(d1, d2);\n#endif\n\n#ifdef RENDER_TREES\n    d2 = sdTrees(pos, time);\n    d1 = minx(d1, d2);\n#endif\n\n    pos1 = pos;\n    pos1.y -= HILL_HEIGHT;\n\n#ifdef RENDER_HOUSE\n    d2 = sdHouse(pos1, time);\n    d1 = minx(d1, d2);\n#endif\n\n    pos1 = pos;\n    pos1.y -= 0.4;\n    pos1.z -= 50.0;\n    pos1.xz *= rotation_n90;\n\n#ifdef RENDER_BRIDGE\n    d2 = sdBridge(pos1);\n    d1 = minx(d1, d2);\n\n    pos1.x -= 3.3;\n    pos1.z -= 0.8;\n    d2 = sdMailboxPost(pos1);\n    d1 = minx(d1, d2);\n#endif\n\n    pos1 = pos;\n    pos1 -= HAT_POSITION;\n    pos1.xy *= rotation_n90;\n    d2 = sdHat(pos1);\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\n// objects that are expected to be visible in a reflection\nvec3 mapReflection(vec3 pos, float time)\n{\n    vec3 d1, d2;\n    vec3 pos1, pos2;\n\n    d1 = vec3(MAX_DIST, 0.0, 0.0);\n\n#ifdef RENDER_GROUND\n    pos1 = pos;\n\n    d2 = sdGround(pos);\n    d1 = minx(d1, d2);\n\n    d2 = sdRiverBanks(pos);\n    d1 = minx(d1, d2);\n#endif\n\n#ifdef RENDER_BRIDGE\n    pos1 = pos;\n    pos1.y -= 0.4;\n    pos1.z -= 50.0;\n    pos1.xz *= rotation_n90;\n    d2 = sdBridge(pos1);\n    d1 = minx(d1, d2);\n\n    pos1.x -= 3.3;\n    pos1.z -= 0.8;\n    d2 = sdMailboxPost(pos1);\n    d1 = minx(d1, d2);\n#endif\n\n#ifdef RENDER_ROCKS\n    d2 = sdRiverBanksRocks(pos);\n    d1 = minx(d1, d2);\n#endif\n\n    pos1 = pos;\n    pos1 -= HAT_POSITION;\n    pos1.xy *= rotation_n90;\n    d2 = sdHat(pos1);\n    d1 = minx(d1, d2);\n\n#ifdef RENDER_HOUSE_DETAILS\n    // well\n    pos1 = pos;\n    pos1 -= WELL_POSITION;\n    pos1.y -= HILL_HEIGHT;\n    pos1.xz *= rotation_n145;\n    d2 = sdWell(pos1);\n    d1 = minx(d1, d2);\n#endif\n\n    return d1;\n}\n\n// transparent objects\nvec2 mapTransparent(vec3 pos, float time)\n{\n    vec2 d1 = vec2(MAX_DIST, 0.0);\n    vec2 d2 = d1;\n\n    vec3 pos1, pos2;\n\n#ifdef RENDER_HOUSE\n    pos1 = pos;\n    pos1.y -= HILL_HEIGHT;\n\n    pos2 = pos1;\n    pos2.xz *= rotation_n93;\n    pos2.z -= 3.9;\n    pos2.y -= 2.1;\n    d2 = sdPorchDoorGlass(pos2);\n    d1 = minx(d1, d2);\n\n    pos2 = pos1;\n    d2 = sdWindowsGlass(pos2);\n    d1 = minx(d1, d2);\n\n    pos2 = pos1;\n    pos2 -= vec3y(HOUSE_HEIGHT - 0.2);\n    pos2.xz *= rotation_n60;\n    pos2 -= vec3(0.0, 1.5, 3.6);\n    d2 = sdMoominWindowGlass(pos2, -2.5);\n    d1 = minx(d1, d2);\n#endif\n\n    d2 = sdWellWater(pos, time);\n    d1 = minx(d1, d2);\n\n    d2 = sdRiverWater(pos, time);\n    d1 = minx(d1, d2);\n\n#ifdef RENDER_CAKE\n    pos1 = pos;\n    pos1.y -= HILL_HEIGHT;\n    pos1.xz *= rotation_n93;\n    pos1 -= vec3(2.0, 0.6, 4.9);\n\n    pos2 = pos1;\n    pos2 -= vec3(-0.2, 0.7, -0.2);\n    pos2.xz *= rotation_180;\n    pos2.xz *= rotation_n10;\n    d2 = sdJarGlass(pos2);\n    d1 = minx(d1, d2);\n\n    pos2 = pos1;\n    pos2.xz *= rotation_n90;\n    pos2.xz *= rotation_n7_5;\n    pos2.x = abs(pos2.x);\n    pos2 -= vec3(0.25, 0.7, 0.2);\n    d2 = sdGlassCup(pos2);\n    d1 = minx(d1, d2);\n#endif\n\n    return d1;\n}\n\n// object that affect walk navigation\nfloat mapCollision(vec3 pos, float time)\n{\n    const float floorHeight = 4.65;\n    const float ladderStepHeight = 0.5;\n\n    float d1 = MAX_DIST;\n    float d2, d3;\n    float r = 0.0;\n    vec3 pos1 = pos;\n    vec3 pos2, pos3, pos4;\n\n#ifdef RENDER_HOUSE\n    pos1 = pos;\n    pos1.y -= HILL_HEIGHT;\n\n    // house floors\n    pos2 = pos1;\n    pos2.y -= 0.5;\n    float index = floor(pos2.y / floorHeight + 0.5);\n    index = clamp(index, 0.0, 3.0);\n    pos2.y -= index * floorHeight;\n    r = sdCircle(pos2.xz, index < 3.0 ? 4.0 : 3.8);\n    d2 = r;\n    d2 = max(0.0, d2);\n    d2 = length(vec2(d2, stretchAxis(pos2.y, 0.2)));\n    d1 = min(d1, d2);\n\n    // house roof\n    pos2 = pos1;\n    pos2.y -= HOUSE_HEIGHT - 0.6;\n    vec2 p1 = vec2(length(pos2.xz), pos2.y);\n    d2 = sdLine(p1, 4.5, 6.3);\n    d2 -= 0.1;\n\n    pos2.xz *= rotation_n60;\n    pos2.y -= 2.0;\n    d3 = sdBoxApprox(pos2, vec3(0.6, 1.0, 3.0), vec3z1); // window opening\n    d2 = max(d2, -d3);\n\n    d1 = min(d1, d2);\n#endif\n\n#ifdef RENDER_HOUSE_DETAILS\n    // porch roof\n    pos2 = pos1;\n    pos2.xz *= rotation_n93;\n    pos2.y -= 6.8;\n    pos2.z -= 4.4;\n\n    pos3 = pos2;\n    pos3.x = abs(pos3.x);\n    pos3.xy *= rotation_n45;\n    d2 = sdBoxApprox(pos3, vec3(5.0, 0.1, 2.0));\n\n    pos4 = pos2;\n    pos4.yz *= rotation_n30;\n    d2 = max(d2, pos4.z);\n\n    d3 = sdBoxApprox(pos4, vec3(4.0, 4.0, 0.1), -vec3z1);\n    d3 = max(d3, pos3.y);\n    d2 = min(d2, d3);\n\n    d2 = max(d2, -r);\n    d1 = min(d1, d2);\n\n    // ladder steps\n    pos2 = pos1;\n    pos2.xz *= rotation_n60;\n    pos2.z -= 4.6;\n    index = floor(pos2.y / ladderStepHeight + 0.5);\n    index = clamp(index, 9.0, 27.0);\n    pos2.y -= index * ladderStepHeight;\n    d2 = sdBoxApprox(pos2, vec3(0.5, 0.1, 0.3));\n    d1 = min(d1, d2);\n\n    // entrance stairs\n    pos1 = pos;\n    pos1.y -= HILL_HEIGHT;\n    pos1.z -= 6.2;\n    d2 = sdEntranceStairs(pos1).x;\n    d1 = min(d1, d2);\n\n    // kitchen stairs\n    pos1 = pos;\n    pos1.y -= HILL_HEIGHT;\n    pos1.xz *= rotation_145;\n    pos1.z -= 5.25;\n    d2 = sdKitchenStairs(pos1).x;\n    d1 = min(d1, d2);\n\n    // porch\n    pos1 = pos;\n    pos1.y -= HILL_HEIGHT;\n    pos1.xz *= rotation_n93;\n    pos1.z -= 4.3;\n    pos2 = pos1;\n    d2 = sdBoxApprox(pos2, vec3(3.3, 0.3, 2.0), vec3y1);\n    d1 = min(d1, d2);\n    pos2.y -= 0.05;\n    pos2.z -= 1.5;\n    d2 = sdBoxApprox(pos2, vec3(0.8, 0.15, 0.6), vec3z1);\n    d1 = min(d1, d2);\n    pos2.y -= 0.2;\n    d2 = sdBoxApprox(pos2, vec3(0.8, 0.15, 0.4), vec3z1);\n    d1 = min(d1, d2);\n\n    // porce steps\n    pos2 = pos1;\n    pos2.x += 3.0;\n    index = floor(pos2.y / ladderStepHeight + 0.5);\n    index = clamp(index, 0.0, 6.0);\n    pos2.y -= index * ladderStepHeight;\n    d2 = sdBoxApprox(pos2, vec3(0.3, 0.1, 1.5));\n    d1 = min(d1, d2);\n\n    // basement\n    pos1 = pos;\n    pos1.y -= HILL_HEIGHT;\n    pos1.x += 5.0;\n    d2 = sdBoxApprox(pos1, vec3(1.4), vec3y1);\n    pos1.y -= 2.1;\n    pos1.xy *= rotation_30;\n    d2 = max(d2, pos1.y);\n    d2 = max(d2, -r);\n    d1 = min(d1, d2);\n#endif\n\n#ifdef RENDER_BRIDGE\n    // bridge\n    pos1 = pos;\n    pos1.z -= 50.0;\n    pos1.y -= 0.4 + 0.95 * smoothstep(3.2, 0.0, pow(abs(pos1.z), 1.2));\n    d2 = sdBoxApprox(pos1, vec3(0.8, 0.1, 4.0));\n    d1 = min(d1, d2);\n#endif\n\n    return d1;\n}\n\n\n\nvec3 getNormalTransparent(vec3 pos, float time)\n{\n    vec3 n = vec3(0.0);\n\n    for (int i = 0; i < 4; i++)\n    {\n        vec3 d = 2.0 * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.0;\n        vec2 d1 = mapTransparent(pos + 0.05 * d, time);\n\n        n += d1.y > 0.0 ? d * d1.x : vec3(0.0);\n    }\n\n    return normalize(n);\n}\n\nvec3 castRay(vec3 ro, vec3 rd, float time, int maxSteps, bool shadowPass) // ray origin, ray direction\n{\n    float d = 0.0; // distance from ray origin\n    vec2 m = vec2(0.0); // material\n\n    float shadow = 1.0;\n\n    for (int i = 0; i < maxSteps; i++)\n    {\n        vec3 pos = ro + rd * d; // current position\n\n        vec3 d1 = map(pos, time, shadowPass); // distance from current position to the scene\n        marchSteps++;\n        m = d1.yz;\n\n        if (shadowPass)\n        {\n            if (materialCastsShadow(floor(d1.y)))\n            {\n                shadow = min(shadow, max(0.0, 40.0 * d1.x / d)); // soft shadow\n            }\n\n            d1.x = max(d1.x, 0.01);\n        }\n\n        d += d1.x;\n\n        if (d > MAX_DIST || abs(d1.x / (d + 1.0)) < SURF_DIST)\n        {\n            break;\n        }\n    }\n    \n    if (shadowPass)\n    {\n        return vec3(max(1.0 - shadow, 0.0), 0.0, 0.0);\n    }\n\n    if (d > MAX_DIST || m.x < 1.0)\n    {\n        m = vec2(MATERIAL_SKY, 0.0);\n        d = MAX_DIST;\n    }\n\n    return vec3(d, m);\n}\n\nvec3 castRayBackground(vec3 ro, vec3 rd, float time, int maxSteps, float maxDistance) // ray origin, ray direction\n{\n    float d = 0.0; // distance from ray origin\n    vec2 m = vec2(0.0); // material\n\n    int i;\n    for (i = 0; i < maxSteps; i++)\n    {\n        vec3 pos = ro + rd * d; // current position\n\n        vec3 dm = sdBackground(pos, time); // distance from current position to the scene\n        d += dm.x;\n        m = dm.yz;\n        marchSteps++;\n\n        if (d > maxDistance || abs(dm.x / (d + 1.0)) < SURF_DIST)\n        {\n            break;\n        }\n    }\n\n    if (d > maxDistance || m.x < 1.0)\n    {\n        m = vec2(MATERIAL_SKY, 0.0);\n        d = MAX_DIST;\n    }\n\n    return vec3(d, m);\n}\n\n\nvec3 castRayReflection(vec3 ro, vec3 rd, float time, int maxSteps) // ray origin, ray direction\n{\n    float d = 0.0; // distance from ray origin\n    vec2 m = vec2(0.0); // material\n\n    for (int i = 0; i < maxSteps; i++)\n    {\n        vec3 pos = ro + rd * d; // current position\n\n        vec3 d1 = mapReflection(pos, time); // distance from current position to the scene\n        d += d1.x;\n        m = d1.yz;\n\n        marchReflectionSteps++;\n\n        if (d > MAX_DIST || abs(d1.x / (d + 1.0)) < SURF_DIST)\n        {\n            break;\n        }\n    }\n\n    if (d > MAX_DIST || m.x < MATERIAL_EMPTY + 1.0)\n    {\n        m = vec2(MATERIAL_SKY, 0.0);\n        d = MAX_DIST;\n    }\n\n    return vec3(d, m);\n}\n\nvec2 castRayTransparent(vec3 ro, vec3 rd, float time, int maxSteps, float maxDistance)\n{\n    float d = 0.0;\n    float m = 0.0;\n\n    for (int i = 0; i < maxSteps; i++)\n    {\n        vec3 pos = ro + rd * d;\n\n        vec2 d1 = mapTransparent(pos, time);\n        d += d1.x;\n        m = d1.y;\n\n        marchTransparentSteps++;\n\n        if (d > maxDistance)\n        {\n            return vec2(MAX_DIST, 0.0);\n        }\n\n        if (abs(d1.x / (d + 1.0)) < SURF_DIST)\n        {\n            break;\n        }\n    }\n\n    return vec2(d, m);\n}\n\nfloat castRayCollision(vec3 ro, vec3 rd, float time, int maxSteps) // ray origin, ray direction\n{\n    float d = 0.0; // distance from ray origin\n\n    for (int i = 0; i < maxSteps; i++)\n    {\n        vec3 pos = ro + rd * d; // current position\n\n        float d1 = mapCollision(pos, time); // distance from current position to the scene\n        d += d1;\n\n        if (d > MAX_DIST || abs(d1 / (d + 1.0)) < SURF_DIST)\n        {\n            break;\n        }\n    }\n\n    return min(d, MAX_DIST);\n}\n\nfloat castShadowTransparent(vec3 ro, vec3 rd, float time)\n{\n    float result = 1.0;\n    float d = 0.01; // position\n\n    for (int i = 0; i < 50; i++)\n    {\n        vec3 pos = ro + d * rd;\n        vec2 d1 = mapTransparent(pos, time);\n\n        marchShadowSteps++;\n\n        if (!materialCastsShadow(floor(d1.y)))\n        {\n            d1.x += 0.01; // skip object\n        }\n        else\n        {\n            result = min(result, max(0.0, 40.0 * d1.x / d)); // soft shadow\n        }\n\n        d += max(d1.x, 0.01);\n\n        if (abs(d1.x) < (d * 0.001) || d > MAX_DIST)\n        {\n            break;\n        }\n    }\n\n    return clamp(1.0 - result, 0.0, 1.0);\n}\n\nvoid getViewAxis(in vec3 origin, in vec3 target, out vec3 viewOrigin, out vec3 viewX, out vec3 viewY, out vec3 viewZ)\n{\n    origin.y = max(origin.y, getGroundHeight(origin) + MIN_CAMERA_HEIGHT);\n\n    viewOrigin = origin;\n    viewZ = normalize(target - origin);\n    viewX = normalize(cross(viewZ, vec3(0.0, 1.0, 0.0)));\n    viewY = cross(viewX, viewZ);\n}\n\nbool isKeyDown(int key)\n{\n    return keyboardTexture((vec2(0.5) + vec2(float(key), 0.0))).x > 0.5;\n}\n\nbool isKeyPressed(int key)\n{\n    return keyboardTexture((vec2(0.5) + vec2(float(key), 1.0))).x > 0.5;\n}\n\nvec2 scaleMouseCoordinate(vec2 coord)\n{\n    vec2 uv = map01_11(coord / iResolution.xy);\n    uv *= state.renderScale;\n    return map11_01(uv) * iResolution.xy;\n}\n\nvec3 getPosition(vec2 fragCoord)\n{\n    vec4 t = inputTexture(fragCoord);\n\n    vec2 uv = map01_11(fragCoord / iResolution.xy);\n    uv.x *= iResolution.x / iResolution.y;\n\n    float depth = deserializeDepth(getDepthComponent(t));\n    vec3 rd = normalize(uv.x * state.viewX + uv.y * state.viewY + FIELD_OF_VIEW * state.viewZ * state.renderScale);\n\n    vec3 pos = state.viewOrigin + depth * rd; // point in scene\n\n    return pos;\n}\n\nvoid getFlyCoordinates(float time, out vec3 origin, out vec3 target)\n{\n    const float z0 = 10.0; // entrance segment start\n    const float z1 = 40.0; // bridge segment end\n    const float z2 = 50.0; // bridge\n    const float z3 = 100.0; // bridge segment start\n    const float depth1 = 0.1;\n\n    time *= smoothstep(0.0, 15.0, time); // slow start\n\n    float z = 62.0 * (1.0 - time * 0.04);\n\n    float center = 6.0 * (sin(z * 0.138 + 0.97) - 1.0);\n\n    center *= smoothstep(z2, z1, z) + smoothstep(z2, z3, z);\n    center *= smoothstep(0.0, z0, z);\n    float width = 1.0 + 0.1 * (sin(z * 2.0) + 0.5 * sin(z * 5.0));\n    width = z < 0.0 ? 0.0 : width;\n\n    float depth = depth1;\n\n    float offset = smoothstep(15.0, 30.0, z);\n    vec3 origin1 = vec3(center - offset, 10.0, z);\n    origin1.y = mix(max(getGroundHeight(origin1), 0.4), 1.5, smoothstep(3.4, 0.0, abs(z - z2)));\n    origin1.y += MOVE_CAMERA_HEIGHT;\n    vec3 target1 = vec3(0.0, 18.0, 0.0);\n\n    // phase 2\n    float an = -0.8 - 0.5 * time;\n    float r = 7.0 + 8.0 * map11_01(sin(-0.54 * time + 4.5));\n    float h = HILL_HEIGHT + 1.5 + 16.0 * map11_01(sin(0.18 * time + 0.77));\n    vec3 target2 = vec3(0.0, h, 0.0);\n    vec3 origin2 = vec3(r * cos(an), h, r * sin(an));\n\n    // phase 3\n    an = -2.4 - 0.15 * time;\n    r = 25.0 + 40.0 * map11_01(sin(-0.11 * time + 1.9));\n    h = HILL_HEIGHT + 11.0 + 0.3 * r * sin(0.07 * time + 0.6);\n    float h2 = HILL_HEIGHT + 10.0 + 0.1 * r * sin(0.07 * time + 4.3);\n\n    vec3 target3 = vec3(0.0, h2, 0.0);\n    vec3 origin3 = vec3(r * cos(an), h, r * sin(an));\n\n    // mix phases\n    float f12 = smoothstep(20.0, 23.0, time);\n    float f23 = smoothstep(36.0, 42.0, time);\n    origin = mix(origin1, mix(origin2, origin3, f23), f12);\n    target = mix(target1, mix(target2, target3, f23), f12);\n}\n\nvoid updateState(vec2 fragCoord, float delta, float time)\n{\n    bool toggleRenderModeAction = isKeyPressed(KEY_F1);\n    bool toggleNavigationModeAction = isKeyPressed(KEY_N);\n    bool resetViewAction = isKeyPressed(BUTTON_RIGHT) || isKeyPressed(KEY_R);\n    bool scaleUpRenderAction = isKeyPressed(KEY_KP_PLUS) || isKeyPressed(KEY_EQUALS);\n    bool scaleDownRenderAction = isKeyPressed(KEY_KP_MINUS) || isKeyPressed(KEY_MINUS);\n    bool zoomInAction = isKeyPressed(MOUSE_SCROLL_UP);\n    bool zoomOutAction = isKeyPressed(MOUSE_SCROLL_DOWN);\n    bool moveLeftAction = isKeyDown(KEY_A);\n    bool moveRightAction = isKeyDown(KEY_D);\n    bool moveForwardAction = isKeyDown(KEY_W);\n    bool moveBackwardAction = isKeyDown(KEY_S);\n    bool moveUpAction = isKeyDown(KEY_E);\n    bool moveDownAction = isKeyDown(KEY_C);\n    bool startDragAction = isKeyPressed(BUTTON_LEFT) || isKeyPressed(BUTTON_MIDDLE) || iMouse.w > 0.0;\n    bool dragAction = isKeyDown(BUTTON_LEFT) || isKeyDown(BUTTON_MIDDLE) || iMouse.z > 0.0;\n    bool dragZoomModifier = isKeyDown(KEY_CONTROL);\n    bool dragPanModifier = isKeyDown(KEY_SHIFT);\n    bool moveModifier = isKeyDown(KEY_SHIFT);\n\n    bool isMouseOverViewport = iMouse.x > 0.0 && iMouse.y > 0.0 && iMouse.x < iResolution.x && iMouse.y < iResolution.y;\n    bool moveAction = moveLeftAction || moveRightAction || moveForwardAction || moveBackwardAction;\n\n    if (iMouse.z > 0.0 || isKeyPressed(BUTTON_LEFT) || isKeyPressed(BUTTON_MIDDLE) || isKeyPressed(BUTTON_RIGHT))\n    {\n        state.focused = isMouseOverViewport;\n    }\n\n    state.focused = true; // override\n\n    float zoomOffset = 0.0;\n    vec3 panOffset = vec3(0.0);\n    vec2 swivelOffset = vec2(0.0);\n\n    bool isDragging = length(state.dragStartPosition) > 0.0;\n    bool isClicked = isDragging && !dragAction && (time - state.dragStartTime < CLICK_TIME && length(iMouse.xy - state.dragStartPosition) < 20.0);\n    if (isClicked)\n    {\n        state.clickCount = time - state.clickTime > 0.0 && time - state.clickTime < CLICK_TIME ? state.clickCount + 1.0 : 0.0;\n        state.clickTime = time;\n    }\n\n    if (state.focused)\n    {\n        if (toggleRenderModeAction)\n        {\n            state.nextRenderMode = mod(state.renderMode + 1.0, 8.0);\n            state.modeAnnotation = vec2(1.0, time);\n        }\n\n        if (toggleNavigationModeAction)\n        {\n            state.navigationMode = mod(state.navigationMode + 1.0, 2.0);\n            state.modeAnnotation = vec2(2.0, time);\n        }\n\n        if (scaleUpRenderAction)\n        {\n            state.nextRenderScale = clamp(state.renderScale * 1.1, 0.01, 1.0);\n            state.modeAnnotation = vec2(3.0, time);\n        }\n\n        if (scaleDownRenderAction)\n        {\n            state.nextRenderScale = clamp(state.renderScale / 1.1, 0.01, 1.0);\n            state.modeAnnotation = vec2(3.0, time);\n        }\n\n        if (resetViewAction)\n        {\n            resetState();\n            state.focused = true;\n        }\n\n        float moveSpeed = moveModifier ? MOVE_SPEED2 : MOVE_SPEED1;\n\n        if (moveLeftAction)\n        {\n            panOffset.x = delta * moveSpeed;\n        }\n\n        if (moveRightAction)\n        {\n            panOffset.x = -delta * moveSpeed;\n        }\n\n        if (moveForwardAction)\n        {\n            panOffset.z = -delta * moveSpeed;\n        }\n\n        if (moveBackwardAction)\n        {\n            panOffset.z = delta * moveSpeed;\n        }\n\n        if (moveUpAction)\n        {\n            panOffset.y = -delta * moveSpeed * 0.5;\n        }\n\n        if (moveDownAction)\n        {\n            panOffset.y = delta * moveSpeed * 0.5;\n        }\n    }\n\n    if (isMouseOverViewport)\n    {\n        if (zoomInAction)\n        {\n            zoomOffset = -ZOOM_SCROLL_SPEED;\n        }\n\n        if (zoomOutAction)\n        {\n            zoomOffset = ZOOM_SCROLL_SPEED;\n        }\n\n        if (startDragAction)\n        {\n            state.dragStartTime = time;\n            state.dragStartPosition = iMouse.xy;\n            state.dragLastPosition = iMouse.xy;\n            isDragging = true;\n        }\n    }\n\n    if (dragAction || moveAction)\n    {\n        state.targetAnnotation = vec4(0.0);\n        state.modeAnnotation = vec2(0.0);\n    }\n\n    if (!dragAction)\n    {\n        state.dragStartPosition = vec2(0.0);\n        state.dragLastPosition = vec2(0.0);\n        isDragging = false;\n    }\n\n    if (isDragging && dragAction)\n    {\n        vec2 dragOffset = (iMouse.xy - state.dragLastPosition) / iResolution.y;\n        state.dragLastPosition = iMouse.xy;\n\n        if (dragZoomModifier && !moveAction)\n        {\n            zoomOffset = -ZOOM_DRAG_SPEED * sign(dragOffset.y) * 2.0 * length(dragOffset);\n        }\n        else if (dragPanModifier && !moveAction)\n        {\n            panOffset = vec3(dragOffset.xy, 0.0);\n        }\n        else // swivel\n        {\n            swivelOffset = SWIVEL_SPEED * dragOffset.xy;\n        }\n    }\n\n    vec3 viewDirection = state.target - state.origin;\n    float viewDistance = length(viewDirection);\n\n    vec2 viewRotation = vec2(atan(viewDirection.z, viewDirection.x), atan(viewDirection.y, length(viewDirection.xz)));\n\n    if (state.navigationMode > 1.0) // fly mode (2)\n    {\n        if (isClicked)\n        {\n            time = 0.0;\n            state.navigationMode = 1.0;\n        }\n\n        vec3 origin;\n        vec3 target;\n        getFlyCoordinates(time, origin, target);\n        state.nextOrigin = origin;\n        state.nextTarget = target;\n    }\n    else if (state.navigationMode > 0.0) // walk mode (1)\n    {\n        vec3 origin = state.origin;\n\n        vec3 d1 = vec3(castRayCollision(origin, vec3y(-1.0), time, MAX_STEPS), 100.0, 0.0);\n\n        float targetHeight = MOVE_CAMERA_HEIGHT + max(getGroundHeight(state.origin), origin.y - d1.x);\n\n        vec3 moveZ = normalize(vec3(state.viewZ.xz, 0.0).xzy);\n        vec3 moveY = vec3y(1.0);\n        vec3 moveX = cross(moveZ, moveY);\n        vec3 targetOffset = panOffset.x * moveX + panOffset.z * moveZ;\n\n        viewRotation += swivelOffset.xy * 0.5;\n        viewRotation.y = clamp(viewRotation.y, -PI05 + 0.001, PI05 - 0.001);\n\n        vec3 target = origin + viewDistance * vec3(cos(viewRotation.x) * cos(viewRotation.y), sin(viewRotation.y), sin(viewRotation.x) * cos(viewRotation.y));\n\n        origin -= targetOffset;\n        target -= targetOffset;\n\n        targetHeight = clamp(targetHeight, origin.y - MOVE_GRAVITY * delta, origin.y + MOVE_COLLISION * delta);\n        target.y += targetHeight - origin.y;\n        origin.y = targetHeight;\n\n        // teleport\n        if (isClicked && state.clickCount > 0.0) // double click\n        {\n            vec3 clickPosition = getPosition(scaleMouseCoordinate(iMouse.xy));\n            float d1 = length(clickPosition - state.origin);\n\n            if (d1 < 300.0) // exclude mountains and sky\n            {\n                vec3 pos = clickPosition; // point in scene\n                pos.y += MOVE_CAMERA_HEIGHT;\n                target += pos - origin;\n                origin = pos;\n            }\n        }\n\n        state.nextOrigin = origin;\n        state.nextTarget = target;\n    }\n    else // inspection mode (0)\n    {\n        // zoom\n        viewDistance *= pow(2.0, zoomOffset);\n\n        // swivel\n        viewRotation.xy += swivelOffset;\n        viewRotation.y = clamp(viewRotation.y, -PI05 + 0.001, PI05 - 0.001);\n\n        // pan\n        vec3 panX = state.viewX;\n        vec3 panZ = normalize(vec3(state.viewZ.xz, 0.0).xzy);\n        vec3 panY = cross(panX, panZ);\n        vec3 targetOffset = viewDistance * (panOffset.x * panX + panOffset.y * panY + panOffset.z * panZ);\n\n        state.nextOrigin = state.target - targetOffset - viewDistance * vec3(cos(viewRotation.x) * cos(viewRotation.y), sin(viewRotation.y), sin(viewRotation.x) * cos(viewRotation.y));\n        state.nextTarget = state.target - targetOffset;\n\n        // re-center target\n        state.nextTargetOffset *= max(0.0, 1.0 - 0.5 * length(swivelOffset) - length(panOffset) - abs(zoomOffset) - length(panOffset));\n\n        if (isClicked)\n        {\n            vec3 clickPosition = getPosition(scaleMouseCoordinate(iMouse.xy));\n            float d1 = length(clickPosition - state.origin);\n\n            #ifdef RENDER_TRANSPARENCY\n                float d2 = castRayTransparent(state.origin, state.viewZ, time, MAX_STEPS, MAX_DIST).x;\n                d1 = min(d1, d2);\n            #endif\n\n            if (d1 < 100.0) // limit distance\n            {\n                vec3 target = clickPosition; // point in scene\n\n                state.nextTargetOffset += state.target - target;\n                state.nextTarget = target;\n                state.targetAnnotation = vec4(iMouse.xy, time, 1.0);\n\n                if (state.clickCount > 0.0) // double click\n                {\n                    state.nextTargetOffset = vec3(0.0);\n                    state.nextOrigin = target - 2.0 * normalize(viewDirection);\n                }\n            }\n        }\n    }\n\n    if (length(state.nextOrigin - state.origin) < 0.0001)\n    {\n        state.nextOrigin = state.origin;\n    }\n\n    if (length(state.nextTarget - state.target) < 0.0001)\n    {\n        state.nextTarget = state.target;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    deserializeState(iChannel0, iResolution.xy);\n\n    if (!state.initialized)\n    {\n        resetState();\n        state.initialized = true;\n        state.nextRenderMode = 0.0;\n        state.nextRenderScale = 1.0;\n        state.nextOrigin = INITIAL_ORIGIN;\n        state.nextTarget = INITIAL_TARGET;\n        state.nextTargetOffset = vec3(0.0);\n        state.navigationMode = 2.0;\n    }\n\n    state.origin = state.nextOrigin;\n    state.target = state.nextTarget;\n    state.targetOffset = state.nextTargetOffset;\n    state.renderMode = state.nextRenderMode;\n    state.renderScale = state.nextRenderScale;\n\n    vec3 origin = state.origin;\n    vec3 target = state.target + state.targetOffset;\n\n    float time = iTime;\n\n    vec2 uv = map01_11(fragCoord / iResolution.xy);\n\n    if (fragCoord.x < STATE_SIZE && fragCoord.y < 1.0) // state\n    {\n        float delta = iTimeDelta;\n\n        vec3 origin, rdx, rdy, rdz;\n        getViewAxis(state.origin, state.target + state.targetOffset, origin, rdx, rdy, rdz);\n\n        state.viewX = rdx;\n        state.viewY = rdy;\n        state.viewZ = rdz;\n        state.viewOrigin = origin;\n\n        updateState(fragCoord, delta, time);\n\n        fragColor = serializeState(int(floor(fragCoord.x)));\n    }\n    else if (abs(uv.x) < state.renderScale && abs(uv.y) < state.renderScale)\n    {\n        // ray direction\n        vec3 origin, rdx, rdy, rdz;\n        getViewAxis(state.origin, state.target + state.targetOffset, origin, rdx, rdy, rdz);\n\n        uv.x *= iResolution.x / iResolution.y;\n        vec3 rd = normalize(uv.x * rdx + uv.y * rdy + FIELD_OF_VIEW * rdz * state.renderScale);\n        \n        vec3 d1 = vec3(MAX_DIST, 0.0, 0.0);\n        float shadow = 0.0;\n\n        for (int i = 0; i < 2; i++)\n        {\n            bool shadowPass = i == 1;\n\n            vec3 d = castRay(\n                shadowPass ? (origin + d1.x * rd + 0.01 * SUN_DIRECTION) : origin,\n                shadowPass ? SUN_DIRECTION : rd,\n                time,\n                shadowPass ? MAX_SHADOW_STEPS : MAX_STEPS,\n                shadowPass);\n\n            shadow = d.x;\n            d1 = shadowPass ? d1 : d;\n        }\n\n        vec3 d2 = castRayBackground(origin, rd, time, MAX_STEPS, d1.x);\n        d1 = minx(d1, d2);\n        vec3 pos = origin + d1.x * rd; // point in scene\n\n        float tint = 0.0;\n\n        #ifdef RENDER_TRANSPARENCY\n            vec2 d3 = castRayTransparent(origin, rd, time, MAX_STEPS, d1.x);\n\n            if (d3.y > 0.0)\n            {\n                // transparent tint\n                tint = d3.y;\n\n                if (materialIsTransparentObject(tint))\n                {\n                    // override the underlaying object depth with transparent object depth\n                    // this affects the outline, but not always desired (for example in cases\n                    // where the underlaying objects material is using the position)\n                    d1.x = d3.x;\n                }\n\n                vec3 pos2 = origin + d3.x * rd; // transparent point in scene\n                vec3 n2 = getNormalTransparent(pos2, time); // transparent normal\n\n                // reflection\n                if (materialIsTransparentWithReflection(tint) && state.origin.y > 0.0)\n                {\n                    vec3 r = reflect(rd, n2);\n                    vec3 d4 = castRayReflection(pos2, r, time, MAX_STEPS);\n\n                    if (materialIsReflected(d4.y))\n                    {\n                        tint = floor(d4.y);\n                        d1.z += floor(d4.z);\n                    }\n\n                    float juiceMask = getRiverJuiceMask(pos2, time);\n                    tint = mix(tint, MATERIAL_JUICE, juiceMask);\n                    d1.z += juiceMask > 0.0 ? 1.0 : 0.0;\n                }\n                else if (materialIsTransparent(tint))\n                {\n                    vec3 r = reflect(rd, n2);\n                    //tint += dot(r, SUN_DIRECTION) > 0.8 ? 1.0 : 0.0; // sun reflection\n                    tint += sin(d3.x * (r.z + r.x + r.y)) > 0.95 ? 1.0 : 0.0; // simple reflection\n                }\n            }\n        #endif\n\n\n        #ifdef RENDER_TRANSPARENCY\n        #ifdef RENDER_TRANSPARENCY_SHADOW\n            shadow += 0.5 * castShadowTransparent(pos, SUN_DIRECTION, time);\n        #endif\n        #endif\n\n        shadow = d1.y > MATERIAL_SKY ? shadow : 0.0;\n        shadow = clamp(shadow, 0.0, 0.99);\n\n        if (state.renderMode == 1.0) // override uv with ray march steps count\n        {\n            int steps = marchSteps;\n            steps += marchTransparentSteps;\n            steps += marchReflectionSteps;\n            steps += marchShadowSteps;\n\n            d1.z = floor(d1.z) + min(0.99, 0.5 * (float(steps) / float(MAX_STEPS)));\n        }\n        else if (d1.y >= MATERIAL_GRASS && d1.y < MATERIAL_GRASS + 1.0)\n        {\n            vec2 rootPos = length(fract(d1.yz)) < 0.0001 ? (pos.xz + 500.0) : fract(d1.yz) * 1000.0; // deserialize root position\n            float h = (pos.y - getGroundHeight(pos)) / 0.2;\n            d1.y = MATERIAL_GRASS + 0.99 * getGrassShade(rootPos);\n            d1.z = 0.9 * clamp(h, 0.0, 1.0);\n        }\n\n        fragColor = vec4(serializeDepth(d1.x), d1.y, d1.z, tint + shadow);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// MIT License\n\n// Buffer B - Outline\n// Inputs: Buffer A\n\nvec3 getPosition(vec2 fragCoord)\n{\n    vec4 t = inputTexture(fragCoord);\n\n    vec2 uv = map01_11(fragCoord / iResolution.xy);\n    uv.x *= iResolution.x / iResolution.y;\n\n    float depth = deserializeDepth(getDepthComponent(t));\n    vec3 rd = normalize(uv.x * state.viewX + uv.y * state.viewY + FIELD_OF_VIEW * state.viewZ * state.renderScale);\n\n    vec3 pos = state.viewOrigin + depth * rd; // point in scene\n\n    return pos;\n}\n\nvec3 getNormal(vec2 fragCoord)\n{\n    vec3 pos = getPosition(fragCoord);\n    vec3 nx0 = pos - getPosition(fragCoord - vec2(1.0, 0.0));\n    vec3 ny0 = pos - getPosition(fragCoord - vec2(0.0, 1.0));\n    vec3 nx1 = pos - getPosition(fragCoord + vec2(1.0, 0.0));\n    vec3 ny1 = pos - getPosition(fragCoord + vec2(0.0, 1.0));\n    vec3 nx = length(nx0) < length(nx1) ? -nx0 : nx1;\n    vec3 ny = length(ny0) < length(ny1) ? -ny0 : ny1;\n    return normalize(cross(nx, ny));\n}\n\nvec2 getDepthGradient(vec2 coord)\n{\n    vec2 g = vec2(0.0);\n\n    for (int i = 0; i < 9; i++)\n    {\n        vec2 offset = vec2(float(i % 3), float(i / 3)) + vec2(-1.0);\n        float d = deserializeDepth(getDepthComponent(inputTexture(coord + offset))) / MAX_DIST;\n        g.x += d * offset.x * (2.0 - abs(offset.y));\n        g.y += d * offset.y * (2.0 - abs(offset.x));\n    }\n\n    return g;\n}\n\nfloat getOutline(vec2 coord)\n{\n    const int innerEdgeCount = 4;\n\n    float f, fx1, fx2, fy1, fy2;\n\n    float material = getMaterialIndexComponent(inputTexture(coord));\n\n    // depth gradient\n    f =   length(getDepthGradient(coord));\n    fx1 = length(getDepthGradient(coord - vec2x1));\n    fx2 = length(getDepthGradient(coord + vec2x1));\n    fy1 = length(getDepthGradient(coord - vec2y1));\n    fy2 = length(getDepthGradient(coord + vec2y1));\n\n    // perimeter outline based on depth\n    float result = f >= 0.1 ? 1.0 : 0.0;\n\n    // inner outline based on depth\n    result += 4.0 * f >= 1.05 * (fx1 + fx2 + fy1 + fy2 + 0.000005) ? 1.0 : 0.0;\n\n    // remove outline for the same material\n    result = materialHasInnerLines(material) ? result : 0.0;\n\n    vec4 t = inputTexture(coord);\n    vec4 tx1 = inputTexture(coord - vec2x1);\n    vec4 tx2 = inputTexture(coord + vec2x1);\n    vec4 ty1 = inputTexture(coord - vec2y1);\n    vec4 ty2 = inputTexture(coord + vec2y1);\n\n    // material difference\n    f = material;\n    fx1 = getMaterialIndexComponent(tx1);\n    fx2 = getMaterialIndexComponent(tx2);\n    fy1 = getMaterialIndexComponent(ty1);\n    fy2 = getMaterialIndexComponent(ty2);\n\n    // perimeter outline based on material difference\n    result += abs(f - fx1) + abs(f - fx2) + abs(f - fy1) + abs(f - fy2) > 0.0 ? 1.0 : 0.0;\n\n    // edge group\n    float edge = getEdgeGroupComponent(t);\n    f = edge;\n    fx1 = getEdgeGroupComponent(tx1);\n    fx2 = getEdgeGroupComponent(tx2);\n    fy1 = getEdgeGroupComponent(ty1);\n    fy2 = getEdgeGroupComponent(ty2);\n    result += f > 0.0 && ( // exclude edge group 0\n        fx1 > 0.0 && abs(f - fx1) > 0.0 || fx2 > 0.0 && abs(f - fx2) > 0.0 ||\n        fy1 > 0.0 && abs(f - fy1) > 0.0 || fy2 > 0.0 && abs(f - fy2) > 0.0) ? 1.0 : 0.0;\n\n    // tint difference\n    float tint = getTintIndexComponent(t);\n    f = tint;\n    fx1 = getTintIndexComponent(tx1);\n    fx2 = getTintIndexComponent(tx2);\n    fy1 = getTintIndexComponent(ty1);\n    fy2 = getTintIndexComponent(ty2);\n\n    // perimeter outline based on tint difference (excluding reflection on next slot)\n    result += abs(f - fx1) > 1.0 || abs(f - fx2) > 1.0 || abs(f - fy1) > 1.0 || abs(f - fy2) > 1.0 ? 1.0 : 0.0;\n\n    result = min(result, 1.0);\n\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 t = inputTexture(fragCoord);\n\n    if (fragCoord.x < STATE_SIZE && fragCoord.y < 1.0)\n    {\n        fragColor = t;\n        return;\n    }\n\n    deserializeState(iChannel0, iResolution.xy);\n\n    fragColor = setOutlineComponent(t, getOutline(fragCoord));\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// MIT License\n\n// Buffer C - Compose materials and outline\n// Inputs: Buffer B\n\nconst vec3 skyColor = vec3(0.64, 0.9, 1.0);\nconst vec3 fogColor = vec3(1.0, 0.96, 1.0);\nconst vec3 grassColor1 = vec3(0.84, 1.0, 0.52);\nconst vec3 grassColor2 = vec3(0.11, 0.72, 0.49);\nconst vec3 groundColor = vec3(0.68, 0.34, 0.02);\n\n#define colorScreen(color1, color2) (1.0 - (1.0 - (color1)) * (1.0 - (color2)))\n\nfloat getMaterialTextureMask(vec3 pos)\n{\n    pos.x += 10.0 * fbm(pos);\n    float x = 1.5 * fbm(pos * vec3(1.0, 0.8, 1.2) * 0.4);\n    x = x * x;\n    x = x * (3.0 - x);\n    return x;\n}\n\nvec3 getMaterialColor(float index, vec2 uv, vec3 pos, vec3 n)\n{\n    if (index < 1.0)\n    {\n        return vec3(1.0, 1.0, 0.0); // missing\n    }\n\n    if (index < MATERIAL_SKY + 1.0)\n    {\n        float sunMask = dot(normalize(SUN_DIRECTION), normalize(pos - state.origin));\n        const float f1 = 0.00012;\n        const float f2 = 0.1;\n        sunMask = max(0.0, (sunMask - 1.0 + f1) / f1) + // sun\n            0.1 * pow(max(0.0, (sunMask - 1.0 + f2) / f2), 4.0); // halo\n        return mix(skyColor, vec3(2.0), sunMask);\n    }\n\n    if (index < MATERIAL_GRASS + 1.0)\n    {\n        vec3 grassColor = mix(grassColor1, grassColor2, uv.x).rgb;\n        return mix(groundColor, grassColor, 0.8 + 0.2 * uv.y);\n    }\n\n    if (index < MATERIAL_GRASS_FLOWER1 + 1.0)\n    {\n        return mix(vec3(1.0), vec3(1.0, 0.99, 0.1), uv.y);\n    }\n\n    if (index < MATERIAL_GRASS_FLOWER2 + 1.0)\n    {\n        return vec3(1.0, 1.0, 0.1);\n    }\n\n    if (index < MATERIAL_MOUNTAIN + 1.0)\n    {\n        vec3 pos1 = pos;\n        pos1.xz -= state.origin.xz;\n        float t = getMaterialTextureMask(0.1 * pos1);\n\n        vec3 viewZ = normalize(state.origin - pos);\n        vec3 viewX = normalize(cross(viewZ, vec3(pos1.x, 0.0, pos1.z)));\n\n        float fresnel = dot(n, viewZ);\n        fresnel = pow(clamp(fresnel * 1.2, 0.0, 1.0), 4.0);\n\n        float sky = dot(n, cross(viewZ, viewX));\n        sky = pow(clamp(sky * 1.1, 0.0, 1.0), 8.0);\n\n        vec3 color = mix(vec3(0.19, 0.73, 0.6), vec3(0.89, 1.0, 0.81), 0.7 * fresnel + 0.3 * t);\n        color = mix(color, skyColor, 0.8 * sky + 0.2 * t);\n\n        return color;\n    }\n\n    if (index < MATERIAL_CLOUD + 1.0)\n    {\n        return 1.4 * vec3(1.0, 0.83, 1.0); // over saturate\n    }\n\n    if (index < MATERIAL_OUTER_WALL + 1.0)\n    {\n        pos.y *= 0.05;\n\n        vec3 color = mix(vec3(0.6, 0.82, 1.0), vec3(0.28, 0.63, 0.89), uv.x);\n\n        float textureMask = map01_11(getMaterialTextureMask(10.0 * pos + 10.0 * uv.xyx));\n        vec3 textureColor = 0.1 * textureMask * vec3(1.0, 0.8, 0.1);\n\n        color = colorScreen(color, textureColor);\n        return color;\n    }\n\n    if (index < MATERIAL_INNER_WALL + 1.0)\n    {\n        return uv.x < 0.5 ? vec3(0.92, 0.93, 0.75) : vec3(0.85, 0.87, 0.66);\n    }\n\n    if (index < MATERIAL_PAINTED_WOOD + 1.0)\n    {\n        pos *= 15.0;\n        float textureMask = getMaterialTextureMask(pos);\n        return mix(vec3(0.88, 0.94, 0.92), vec3(0.86, 0.92, 0.9), textureMask);\n    }\n\n    if (index < MATERIAL_WOOD1 + 1.0)\n    {\n        return mix(vec3(0.83, 0.72, 0.58), vec3(0.71, 0.63, 0.45), uv.x);\n    }\n\n    if (index < MATERIAL_WOOD2 + 1.0)\n    {\n        return vec3(0.83, 0.72, 0.58);\n    }\n\n    if (index < MATERIAL_WOOD3 + 1.0)\n    {\n        vec3 p = 400.0 * vec3(uv, 0.0);\n        float textureMask = getMaterialTextureMask(p);\n        vec3 color = mix(vec3(0.76, 0.65, 0.53), vec3(0.71, 0.57, 0.42), textureMask);\n        return color;\n    }\n\n    if (index < MATERIAL_WOOD4 + 1.0)\n    {\n        vec3 p = 400.0 * vec3(uv, 0.0);\n        float textureMask = getMaterialTextureMask(p);\n        vec3 color = mix(vec3(0.64, 0.57, 0.49), vec3(0.58, 0.48, 0.38), textureMask);\n        return color;\n    }\n\n    if (index < MATERIAL_TILE + 1.0)\n    {\n        float textureMask = getMaterialTextureMask(pos * 8.0);\n        textureMask = 0.15 * (2.0 * textureMask - 1.0);\n        return mix(vec3(0.9, 0.64, 0.56), vec3(0.75, 0.4, 0.34), uv.x + textureMask);\n    }\n\n    if (index < MATERIAL_BRICK + 1.0)\n    {\n        float textureMask = getMaterialTextureMask(pos * 20.0);\n        textureMask = 0.1 * (2.0 * textureMask - 1.0);\n        return mix(vec3(0.49, 0.27, 0.18), vec3(0.77, 0.58, 0.50), uv.x + textureMask);\n    }\n\n    if (index < MATERIAL_METAL1 + 1.0)\n    {\n        vec3 r = reflect(state.viewZ, n);\n        float f = dot(r, SUN_DIRECTION);\n        return mix(vec3(0.88, 0.94, 0.92), vec3(1.0), f < 0.8 ? 0.0 : 0.5);\n    }\n\n    if (index < MATERIAL_METAL2 + 1.0)\n    {\n        vec3 r = reflect(state.viewZ, n);\n        float f = dot(r, SUN_DIRECTION);\n        return mix(vec3(0.55, 0.34, 0.2), vec3(1.0), f < 0.8 ? 0.0 : 0.5);\n    }\n\n    if (index < MATERIAL_METAL3 + 1.0)\n    {\n        vec3 r = reflect(state.viewZ, n);\n        float f = dot(r, SUN_DIRECTION);\n        return mix(vec3(0.64, 0.72, 0.76), vec3(1.0), f < 0.8 ? 0.0 : 0.5);\n    }\n\n    if (index < MATERIAL_METAL4 + 1.0)\n    {\n        vec3 r = reflect(state.viewZ, n);\n        float f = dot(r, SUN_DIRECTION);\n        return mix(vec3(0.86, 0.8, 0.37), vec3(1.0), f < 0.8 ? 0.0 : 0.5);\n    }\n\n    if (index < MATERIAL_BASE_ROCK + 1.0)\n    {\n        float textureMask = getMaterialTextureMask(pos * 4.0);\n        textureMask = 0.08 * (2.0 * textureMask - 1.0);\n        return mix(vec3(0.82, 0.85, 0.89), vec3(0.47, 0.49, 0.51), uv.x + textureMask);\n    }\n\n    if (index < MATERIAL_ROPE + 1.0)\n    {\n        return mix(vec3(0.54, 0.38, 0.02), vec3(0.71, 0.6, 0.34), uv.x);\n    }\n\n    if (index < MATERIAL_RIVERBED + 1.0)\n    {\n        pos *= 1.5;\n        return mix(vec3(0.93, 0.91, 0.76), vec3(0.84, 0.8, 0.57), getMaterialTextureMask(pos));\n    }\n\n    if (index < MATERIAL_SOIL + 1.0)\n    {\n        pos *= 100.0;\n        float textureMask = getMaterialTextureMask(pos);\n        return mix(vec3(0.37, 0.21, 0.15), vec3(0.46, 0.3, 0.24), textureMask);\n    }\n\n    if (index < MATERIAL_PATHWAY + 1.0)\n    {\n        pos *= 4.0;\n        return mix(vec3(0.83, 0.78, 0.47), vec3(0.88, 0.83, 0.6), getMaterialTextureMask(pos));\n    }\n\n    if (index < MATERIAL_PATHWAY_ROCK + 1.0)\n    {\n        pos *= 7.0;\n        return mix(vec3(0.8, 0.87, 0.89), vec3(0.76, 0.75, 0.74), getMaterialTextureMask(pos));\n    }\n\n    if (index < MATERIAL_TREE_BRANCH + 1.0)\n    {\n        return vec3(0.46, 0.54, 0.4);\n    }\n\n    if (index < MATERIAL_TREE_BARK + 1.0)\n    {\n        return vec3(0.45, 0.35, 0.3);\n    }\n\n    if (index < MATERIAL_STEM + 1.0)\n    {\n        return vec3(0.6, 0.89, 0.32);\n    }\n\n    if (index < MATERIAL_FLOWER1 + 1.0)\n    {\n        return mix(vec3(1.0), vec3(1.0, 0.5, 1.0), uv.y);\n    }\n\n    if (index < MATERIAL_FLOWER2 + 1.0)\n    {\n        return vec3(1.0, 0.9, 0.1);\n    }\n\n    if (index < MATERIAL_HAT + 1.0)\n    {\n        return vec3(0.4, 0.3, 0.56);\n    }\n\n    if (index < MATERIAL_HAT_RIBBON + 1.0)\n    {\n        return vec3(0.78, 0.51, 0.94);\n    }\n\n    if (index < MATERIAL_SKIN + 1.0)\n    {\n        return mix(vec3(0.85, 0.98, 0.99), vec3(1.0, 0.86, 0.85), uv.y);\n    }\n\n    if (index < MATERIAL_EYE + 1.0)\n    {\n        return vec3(1.0);\n    }\n\n    if (index < MATERIAL_PUPIL + 1.0)\n    {\n        return vec3(0.16, 0.85, 1.0);\n    }\n\n    if (index < MATERIAL_MOUTH + 1.0)\n    {\n        return vec3(1.0, 0.8, 0.75);\n    }\n\n    if (index < MATERIAL_SCARF + 1.0)\n    {\n        return mix(vec3(0.28, 0.74, 0.28), vec3(0.86, 0.48, 0.2), uv.x);\n    }\n\n    if (index < MATERIAL_PORCELIN + 1.0)\n    {\n        return vec3(0.9, 0.95, 0.98);\n    }\n\n    if (index < MATERIAL_CAKE1 + 1.0)\n    {\n        return vec3(1.0, 0.99, 0.73);\n    }\n\n    if (index < MATERIAL_CAKE2 + 1.0)\n    {\n        return vec3(0.62, 0.31, 0.1);\n    }\n\n    if (index < MATERIAL_JUICE + 1.0)\n    {\n        return vec3(0.92, 0.22, 0.75);\n    }\n\n    return vec3(1.0, 1.0, 0.0); // missing\n}\n\nvec4 getMaterialTintColor(float index, vec3 pos, vec3 n)\n{\n    if (index < 1.0)\n    {\n        return vec4(0.0);\n    }\n\n    if (index < MATERIAL_WINDOW_GLASS)\n    {\n        return vec4(getMaterialColor(index, vec2(0.5), pos, n), 0.5);\n    }\n\n    if (index < MATERIAL_WINDOW_GLASS + 2.0)\n    {\n        float ref = index >= MATERIAL_WINDOW_GLASS + 1.0 ? 0.6 : 0.0; // reflection\n        return vec4(mix(vec3(0.6, 0.8, 0.84), vec3(1.0), ref), 0.5);\n    }\n\n    if (index < MATERIAL_DOOR_GLASS1 + 2.0)\n    {\n        float ref = index >= MATERIAL_DOOR_GLASS1 + 1.0 ? 0.6 : 0.0; // reflection\n        return vec4(mix(vec3(0.1, 0.5, 1.0), vec3(1.0), ref), 0.5);\n    }\n\n    if (index < MATERIAL_DOOR_GLASS2 + 2.0)\n    {\n        float ref = index >= MATERIAL_DOOR_GLASS2 + 1.0 ? 0.6 : 0.0; // reflection\n        return vec4(mix(vec3(1.0, 0.1, 0.0), vec3(1.0), ref), 0.5);\n    }\n\n    if (index < MATERIAL_DOOR_GLASS3 + 2.0)\n    {\n        float ref = index >= MATERIAL_DOOR_GLASS3 + 1.0 ? 0.6 : 0.0; // reflection\n        return vec4(mix(vec3(1.0, 0.8, 0.0), vec3(1.0), ref), 0.4);\n    }\n\n    if (index < MATERIAL_GLASS1 + 2.0)\n    {\n        float ref = index >= MATERIAL_GLASS1 + 1.0 ? 0.6 : 0.0; // reflection\n        return vec4(mix(vec3(0.6, 0.8, 0.84), vec3(1.0), ref), 0.5);\n    }\n\n    if (index < MATERIAL_GLASS2 + 2.0)\n    {\n        float ref = index >= MATERIAL_GLASS2 + 1.0 ? 0.6 : 0.0; // reflection\n        return vec4(mix(vec3(0.6, 0.8, 0.84), vec3(1.0), ref), 0.5);\n    }\n\n    if (index < MATERIAL_GLASS3 + 2.0)\n    {\n        float ref = index >= MATERIAL_GLASS3 + 1.0 ? 0.6 : 0.0; // reflection\n        return vec4(mix(vec3(0.6, 0.8, 0.84), vec3(1.0), ref), 0.5);\n    }\n\n    if (index < MATERIAL_GLASS4 + 2.0)\n    {\n        float ref = index >= MATERIAL_GLASS4 + 1.0 ? 0.6 : 0.0; // reflection\n        return vec4(mix(vec3(0.6, 0.8, 0.84), vec3(1.0), ref), 0.5);\n    }\n\n    if (index < MATERIAL_CLOUD + 2.0)\n    {\n        return vec4(1.3 * (n.y > -0.3 ? vec3(1.0, 1.0, 1.0) : vec3(1.0, 0.7, 0.8)), 0.6);\n    }\n\n    if (index < MATERIAL_WATER + 2.0)\n    {\n        return index < MATERIAL_WATER + 1.0 ?\n            vec4(0.57, 0.88, 1.0, 0.6) :\n            vec4(0.7, 0.7, 0.75, 0.5); // reflection\n    }\n\n    if (index < MATERIAL_JUICE + 2.0)\n    {\n        return vec4(0.92, 0.22, 0.75, 0.6);\n    }\n}\n\nvec2 getOutline(vec2 fragCoord)\n{\n    float f = 0.0;\n    float minDepth = 1.0;\n    float maxDepth = 0.0;\n    float minIndex1 = 100.0;\n    float maxIndex1 = 0.0;\n    float minIndex2 = 100.0;\n    float maxIndex2 = 0.0;\n\n    float outlineIndex1 = 0.0; // selected outline material index\n    float outlineIndex2 = 0.0; // selected outline tint index\n    float outlineDepth = MAX_DIST; // selected outline material distance\n\n    for (int i = 0; i < 9; i++)\n    {\n        vec2 offset = vec2(float(i % 3), float(i / 3)) + vec2(-1.0);\n        vec4 t = inputTexture(fragCoord + offset);\n\n        float depth = min(deserializeDepth(getDepthComponent(t)) / 200.0, 1.0); // MAX_DIST\n        minDepth = min(minDepth, depth);\n        maxDepth = max(maxDepth, depth);\n\n        float index1 = getMaterialIndexComponent(t);\n        minIndex1 = min(minIndex1, index1);\n        maxIndex1 = max(maxIndex1, index1);\n\n        float index2 = getTintIndexComponent(t);\n        minIndex2 = min(minIndex2, index2);\n        maxIndex2 = max(maxIndex2, index2);\n\n        outlineIndex1 = outlineDepth < depth ? outlineIndex1 : index1;\n        outlineIndex2 = outlineDepth < depth ? outlineIndex2 : index2;\n        outlineDepth = min(outlineDepth, depth);\n\n        bool isOutline = getOutlineComponent(t) > 0.0;\n        f += isOutline ? (3.0 - abs(offset.x) - abs(offset.y)) / 3.0 : 0.0;\n    }\n\n    float isEdge = (abs(maxDepth - minDepth) + abs(maxIndex1 - minIndex1) + abs(maxIndex2 - minIndex2)) * 150.0; // keep edge outlines\n\n    float depth1 = pow(1.0 - minDepth, 5.0); // fade inner outlines\n    depth1 = materialFadeInnerLines(maxIndex1) ? depth1 : 1.0;; // keep mountains inner lines\n    minDepth = materialFadeOutlines(minIndex1) && materialFadeOutlines(maxIndex1) ? 40.0 * minDepth : minDepth; // fade grass flowers outlines\n    float opacity = clamp(1.0 - minDepth * 0.5, 0.0, 1.0); // fade far outlines\n    return vec2(opacity * clamp(f / 3.0, 0.0, 1.0) * clamp(isEdge + depth1, 0.0, 1.0), outlineIndex1);\n}\n\nvec3 getPosition(vec2 coord, vec4 t)\n{\n    vec2 uv = map01_11(coord / iResolution.xy);\n    uv.x *= iResolution.x / iResolution.y;\n\n    float depth = deserializeDepth(getDepthComponent(t));\n    vec3 rd = normalize(uv.x * state.viewX + uv.y * state.viewY + FIELD_OF_VIEW * state.viewZ * state.renderScale);\n\n    vec3 pos = state.viewOrigin + depth * rd; // point in scene\n\n    return pos;\n}\n\nvec3 getPosition(vec2 coord)\n{\n    return getPosition(coord, inputTexture(coord));\n}\n\nvec3 getNormal(vec2 coord, vec4 t)\n{\n    vec3 pos = getPosition(coord, t);\n    vec3 nx0 = pos - getPosition(coord - vec2(1.0, 0.0));\n    vec3 ny0 = pos - getPosition(coord - vec2(0.0, 1.0));\n    vec3 nx1 = pos - getPosition(coord + vec2(1.0, 0.0));\n    vec3 ny1 = pos - getPosition(coord + vec2(0.0, 1.0));\n    vec3 nx = length(nx0) < length(nx1) ? -nx0 : nx1;\n    vec3 ny = length(ny0) < length(ny1) ? -ny0 : ny1;\n    return normalize(cross(nx, ny));\n}\n\nvec3 getDepthColor(float depth)\n{\n    const float depth1 = 0.5;\n    const float depth2 = 4.0;\n    depth = deserializeDepth(depth);\n    depth = log(depth + depth1) / log(depth1 + depth2);\n    return vec3(1.0 - depth);\n}\n\n// iq - shadertoy/ll2GD3\nvec3 getGroupColor(float group)\n{\n    return group > 0.0 ? vec3(0.7 + 0.3 * sin((group * 0.27 + vec3(0.66, 0.0, 0.33)) * PI2)) : vec3(0.9);\n}\n\nfloat getTargetMask(vec2 pos)\n{\n    const float thickness = 2.0;\n    const float opening = 5.0;\n    const float size = 15.0;\n\n    pos.xy = abs(pos.xy);\n    pos = vec2(max(pos.x, pos.y), min(pos.x, pos.y));\n\n    return ((pos.x > opening && pos.x < size && pos.x > thickness && pos.y < thickness)) ? 1.0 : 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 t = inputTexture(fragCoord);\n\n    if (fragCoord.x < STATE_SIZE && fragCoord.y < 1.0)\n    {\n        fragColor = t;\n        return;\n    }\n\n    deserializeState(iChannel0, iResolution.xy);\n\n    vec3 color;\n\n    if (state.renderMode > 6.0)\n    {\n        // uv\n        color = vec3(getMaterialUvComponent(t), 0.0);\n    }\n    else if (state.renderMode > 5.0)\n    {\n        // outline + edge group\n        color = getGroupColor(getEdgeGroupComponent(t)) * (1.0 - getOutlineComponent(t));\n    }\n    else if (state.renderMode > 4.0)\n    {\n        // outline\n        color = vec3(1.0 - getOutlineComponent(t));\n    }\n    else if (state.renderMode > 3.0)\n    {\n        // shadow\n        color = vec3(1.0 - getShadowComponent(t));\n    }\n    else if (state.renderMode > 2.0)\n    {\n        // depth\n        color = getDepthColor(getDepthComponent(t));\n    }\n    else if (state.renderMode > 1.0)\n    {\n        // normal\n        color = getNormal(fragCoord, t);\n    }\n    else if (state.renderMode > 0.0)\n    {\n        // steps\n        color = mix(vec3(getMaterialUvComponent(t).y), vec3(0.6, 0.9, 1.0), getOutlineComponent(t));\n    }\n    else\n    {\n        float materialIndex = getMaterialIndexComponent(t);\n        float tintIndex = getTintIndexComponent(t);\n        float depth = deserializeDepth(getDepthComponent(t));\n        vec2 uv = getMaterialUvComponent(t);\n        vec3 pos = getPosition(fragCoord, t);\n        vec3 n = getNormal(fragCoord, t);\n\n        color = getMaterialColor(materialIndex, uv, pos, n);\n\n        // mix with grass color for down facing surfaces\n        color = mix(color, color + groundColor - vec3(1.0), materialHasGroundBounceLight(materialIndex) ? 0.3 * smoothstep(-0.2, -0.6, dot(n, vec3(0.0, 1.0, 0.0))) : 0.0);\n\n        // outline\n        vec2 outline = getOutline(fragCoord);\n        vec3 outlineColor = getMaterialColor(outline.y, uv, pos, n);\n        outlineColor = min(outlineColor, 1.0); // clamp over staturated materials\n        outlineColor = vec3(pow(outlineColor.r, 4.0), pow(outlineColor.g, 4.0), pow(outlineColor.b, 4.0));\n        outlineColor = mix(outlineColor, vec3(0.28, 0.15, 0.04), 0.5);\n\n        color = mix(color, outlineColor, outline.x);\n\n        // shadow\n        bool isGround = abs(materialIndex - MATERIAL_GRASS) == 0.0;\n        float shadow = getShadowComponent(t);\n        shadow = isGround ? shadow : (1.0 - (1.0 - shadow) * smoothstep(0.1, 0.2, dot(SUN_DIRECTION, n)));\n\n        shadow = materialReceivesShadow(materialIndex) ? shadow : 0.0;\n        shadow *= 0.3;\n        color = mix(color, color + vec3(0.6, 0.1, 0.0) - vec3(1.0), shadow);\n\n        // tint\n        vec4 tintColor = getMaterialTintColor(tintIndex, pos, n);\n        color = mix(color, tintColor.rgb, tintColor.a);\n\n        // fog\n        float fog1 = 50.0 + 2.0 * max(pos.y, 0.0); // start\n        float fog2 = 200.0 + 10.0 * max(pos.y, 0.0); // end\n        float fog = min(pow(max(depth - fog1, 0.0) / (fog2 - fog1), 0.5), 1.0);\n        color = mix(color, fogColor, fog);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}