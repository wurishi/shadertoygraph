{"ver":"0.1","info":{"id":"dlsfzM","date":"1692759194","viewed":74,"name":"Irridescent Donut","username":"mehow_one","description":"Port of the collaboration between the Curiously Minded team and Sean Zellmer\nhttps://codepen.io/ilithya/pen/oNZaVao\n\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["torus","normals","irridescent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define u_resolution iResolution.xy\n#define u_time iTime\n\t\n// Pallete function by Inigo Quilez - iquilezles.org\n// a - brigthness, b - contrast, c - osc, d - phase\nvec3 palette(in vec3 t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) { return a + b*cos( 6.28318*(c*t+d) ); }\n\t\n// Got rotation functions from akella - twitter.com/akella\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c, \n\t\t\t\toc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           \n\t\t\t\toc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           \n\t\t\t\t0.0,\n                0.0,                                \n\t\t\t\t0.0,                                \n\t\t\t\t0.0,                                \n\t\t\t\t1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n\tmat4 m = rotationMatrix(axis, angle);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\n\n// Torus function by Inigo Quilez - iquilezles.org\n// p - position, t - size\nfloat sdTorus(vec3 p, vec2 t) {\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\t\nfloat scene(vec3 pos) {\n\tvec3 rotation = rotate(vec3(pos.x, pos.y, pos.z+1.5), vec3(1.), u_time*2.);\t\n\t\n\tvec3 wPos = rotation; // warp position\n\tconst float warpScale = 1.;\n\t\n\tvec2 size = vec2(2.0);\n\t\n\t// wPos.xy = mod(wPos.xy + size*0.5, size) - size*0.5; // multiple shapes\n\t\n\t// Cosine domain warp\n\twPos += warpScale * 0.10000 * cos( 4. * wPos.yzx + u_time);\n\t//wPos += warpScale * 0.05000 * cos(11. * wPos.yzx + u_time);\n\t//wPos += warpScale * 0.02500 * cos(17. * wPos.yzx + u_time);\n\t\n\trotation = wPos;\n\t\n\trotation = rotation.xzy;\n\t\n\tfloat r = 1.;\t\n\tfloat torus = sdTorus(rotation, vec2(r, r*0.6));\n\t\n\treturn .5 * torus;\n}\n\nconst int RAYMARCH_MAX_STEPS = 200;\nconst float RAYMARCH_MAX_DIST = 10.;\nconst float EPSILON = 0.00001;\n\n// hoisting for raymarch fn return val\t\nvec4 shade (vec3 pos, vec3 rayDir, float rayDepth);\n\t\nvec4 raymarch(vec3 rayDir, vec3 pos) {\n\t// Define the start state\n\t// reset to 0 steps\n\tfloat currentDist = 0.0; \n\tfloat rayDepth = 0.0;\n\tvec3 rayLength = vec3(0.0);\n\t\n\t// shooting the ray\n \tfor (int i=0; i < RAYMARCH_MAX_STEPS; i++) {\n     \t// steps traveled\n\t\tcurrentDist = scene(pos + rayDir * rayDepth);\n\t\trayDepth += currentDist;\n\t\t\n \t    if (currentDist < EPSILON) return shade(pos + rayDir * rayDepth, rayDir, rayDepth); // We're inside the scene - magic happens here\n \t\tif (rayDepth > RAYMARCH_MAX_DIST) return vec4(0, 0, 0, 1.); // We've gone too far\n\t}\n\t\n\treturn vec4(0, 0, 0, 1.);\n}\n\t\nvec3 getNormal (in vec3 pos, in float depth) {\n\tconst vec2 epsilon = vec2(0.0001, 0.);\n\tvec3 nor = vec3(\n\t\tscene(pos + epsilon.rgg) - scene(pos - epsilon.rgg), // x\n\t\tscene(pos + epsilon.grg) - scene(pos - epsilon.grg), // y\n\t\tscene(pos + epsilon.ggr) - scene(pos - epsilon.ggr) // z\n\t);\n\treturn normalize(nor);\n}\n\t\nfloat diffuse (in vec3 light, in vec3 nor) {\n\treturn clamp(0., 1., dot(nor, light));\n}\n\t\nvec3 baseColor (in vec3 pos, in vec3 nor, in vec3 rayDir, in float rayDepth) {\n\tvec3 color = vec3(0);\n\t\n\tfloat dNR = dot(nor, -rayDir);\n\t\n\tcolor = palette(vec3(dNR), vec3(0.5), vec3(0.5), vec3(1), vec3(0, 0.33, 0.67));\n\treturn color;\n}\n\t\nvec4 shade (vec3 pos, vec3 rayDir, float rayDepth) {\n\tvec3 nor = getNormal(pos, rayDepth);\n\t\n\tnor += 0.1 * sin(13. * nor + u_time);\n\tnor = normalize(nor);\n\t\n\tvec3 color = palette(\n\t\tnor,\n\t\tvec3(0.65, 0.95, 0.85), // brightness\n\t\tvec3(rayDepth) * 8., // contrast\n\t\tvec3(1), // osc\n\t\tvec3(0., 0.33, 0.67) // phase\n\t);\n\t\n\tvec3 lightPos = rotate(vec3(1.), vec3(0, 1, 0), 3.14 * u_time);\n\t\n\tfloat dif = 1.;\n\tcolor = dif * baseColor(pos, nor, rayDir, rayDepth);\n\tvec4 shapeColor = vec4(color, 1.0);\n\n\treturn shapeColor;\n}\n\t\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy - u_resolution * .5) / u_resolution.yy; \n\t\n\tvec3 camPos = vec3(0.0, 0.0, 5.0); // x, y, z axis\t\n\n\tvec3 rayDir = normalize(vec3(uv, -1.0)); // DOF\n\t\n    fragColor = vec4(raymarch(rayDir, camPos));\n}","name":"Image","description":"","type":"image"}]}