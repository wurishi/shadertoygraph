{"ver":"0.1","info":{"id":"XXjyzm","date":"1727112208","viewed":39,"name":"Array disk disorder jump","username":"shadertoyjiang","description":"mouse \nWhen the mouse is on the right, the small bead appears. The main purpose is to verify if it can be done. The small mistakes are due to typos, and it happens to be more interesting this way, so let it be","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["mouse","keyboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 20240923\n// When the mouse is on the right, the small bead appears.\n// There is an error in the shadow and I haven't found the cause of the problem yet\n\n#define MUL 2.       // MUL >= 0\n#define Shadow true  // or false\n\n#define time (iTime)\n#define TAU 6.2831853\n#define rot(t) mat2(cos(t), sin(t), -sin(t), cos(t))\nvec3 dir;\nvec4 clr;\nint obj;\nfloat ddd;\nfloat intersect(vec2 o, float r,vec2 dir){\n        vec2 c=vec2(0);\n        vec2 l = c - o;\n        float s = dot(l,dir); // dir.xz\n        float l2 = dot(l,l), r2=r*r;\n        if(s<0. && l2>r2)return -1.;\n        float m2 = l2 - s*s;\n        if(m2>r2)return -1.;\n        float q = sqrt(r2-m2),t;\n        if(l2>r2)t=s-q;\n        else     t=s+q;\n        return t;\n}\n\n//float rnd0(float seed){\n//        return fract(sin(seed*234.567+13.222)*143.219)-.5;\n//}\n\nfloat rnd(float seed){\n        return fract(1615.321*sin(123.456*\n        fract(sin(seed*234.567+13.322)*143.219)))-.5;\n}\n\nfloat keyboard(vec3 p){\n        float size=1. ;//\n        p*=size;\n        vec2 u = p.xz;\n        const float N=1.;\n        float M =float(MUL),\n              au =  atan(u.y, u.x)/TAU , \n              ru = length(u)*N,   \n              iy = round(ru),   \n              ofs = rnd(iy)*time,  \n              ix = round(au * iy*M + ofs);\n        \n        if( ix == round(-.5 * iy*M + ofs) )ix==round(.5 * iy*M + ofs); \n        \n\n        float a = (ix -ofs)/M/iy*TAU;\n        vec2 ni = vec2(-sin(a), cos(a));\n        if(iy>.1)ix=mod(ix,iy);\n        if(iy<.2)ix=0.;\n        \n        float nvg = step(0., dot(ni, dir.xz))*2.-1.;\n        float agl = .5/M/iy*TAU;\n        vec2 abn = rot(agl)*ni;\n        vec2 nrt  = rot(agl*nvg)*ni;\n        \n        float bord = 1e8;\n        float t = - dot(u, nrt) *length(dir)/dot(dir, vec3(nrt, 0).xzy);\n        if(t>0.)bord = min(bord, t); //=?\n        \n        // 求解与内外圆弧边界的距离 bord\n        float k = length(dir.xz);\n        k = length(dir)/(k*k);\n        vec2 nmz = normalize(dir.xz);\n        t = intersect(u, (iy + .5)/N, nmz)*k;  \n        if(t>0.)bord = min(bord, t);        \n        t = intersect(u, (iy - .5)/N, nmz)*k;  \n        if(t>0.)bord = min(bord, t);\n        bord = min(bord, .3) + .01*size;   \n        \n        // 求解各真实物面距离 dist\n        float d1,d2,d3,d4, dist = 1e8, w = .1, r =.1;\n        if(dot(u, ni)<0.)u = reflect(u, ni);\n        d1 = dot(u, abn)+w+r;\n        d2 = ru - (iy + .5-w-r)/N ;\n        d3 = (iy - .5+w+r)/N - ru ;\n        float h = 3.*rnd(iy+ix+7.)*clamp(1.5*sin(time*(1.+rnd(iy+ix+6.))),-1.,1.);\n        d4 = abs(p.y-h)-1.2;        \n        \n        clr = tan(vec4(rnd(iy+ix+3.1),rnd(iy+ix+7.9),rnd(iy+ix+5.5),1))+.7;        \n        dist = length(max(vec4(d1,d2,d3,d4),0.))-r;//2117\n        obj=0;\n        if(mod(ix+iy,3.)<.1 && iMouse.x>iResolution.x*.6){\n              float d5 = length(p - vec3(ni.y*iy, abs(-h)+1.6+.45, -ni.x*iy))-.4;       \n              if(d5<dist)obj=1, clr = vec4(2,.5,.2,1)*(vec4(rnd(iy+ix+3.13),rnd(iy+ix+17.94),rnd(iy+ix+19.53),1)+.7);                \n              dist=min(dist, d5);\n        }\n        ddd=dist;\n        return min(dist, bord)/size;//,p.y/size-3.7);\n}\n\n\nfloat map(vec3 p)\n{\n        float t = time; // 2.54\n        \n        //p.yz *=rot(t*.4);\n        //p.xz *=rot(t*.5);\n        //p.xy *=rot(t*.7);\n        return keyboard(p+vec3(0,5,0));\n}\n\n// iq\nfloat calcSoftshadow( in vec3 ro, in vec3 rd  )\n{\n\tfloat res = 1.0;\n    float t = .01;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    int technique=1;\n    float mint=.01,tmax=25., w=.5;\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        h=ddd;\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, h/(w*t) );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, d/(w*max(0.0,t-y)) );\n            ph = h;\n        }\n       \n        t += h*.5;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n\nvoid mainImage(out vec4 O, vec2 v)\n{        \n        O = vec4(0.4);\n        vec2 R = iResolution.xy,\n             u = 1. * (v+v+.1 - R) / R.y,       \n             m = 1. * (iMouse.xy*2. - R) / R.y; \n        vec3 o = vec3(0, 0, -9),                \n             r = normalize(vec3(u+vec2(0,-.3), 2)),        \n             e = vec3(0, 1e-3, 0),             \n             p,n,                                 \n             s = normalize(vec3(-1,2,-3));      \n        dir=r;\n        O += exp(-80.*abs( keyboard(vec3(u.x,0,u.y-.0)*5.) )); // backcolor\n        \n        float d,t,f,g,c ;\n        for(int i;i<256 && t < 25.;i++)\n        {\n                p = o + r * t;\n                d = map(p);\n                if(d<.01)\n                {\n                        n = normalize(vec3(map(p+e.yxx),map(p+e),map(p+e.xxy))-d);\n                        \n                        f = .5 + .5 * dot(n, s);\n                        g = max(dot(n,s),0.);\n                        c = 1. + pow(f, 200.)-f*.3; \n                        \n                        if(obj==1)O = vec4(c)*clr;\n                        else      O = vec4(c*g)*clr; // 亲\n                        \n                        \n                        //vec4 cclr=clr;int cobj=obj;\n                        vec3 rf;//=reflect(r,n);\n                        rf=normalize(s*100.-p);\n                        dir=rf;\n                        float shd=calcSoftshadow(p+rf*.01,rf);\n                        //clr=cclr;obj=cobj;\n                        \n                        if(Shadow==true  &&  iMouse.x>iResolution.x*.6 )   O   *= shd;\n                        return;\n                }\n                t += d  ;\n        }\n}\n \n\n\n\n\n/*\n        // 求解各真实物面距离 dist\n        float d1,d2,d3,d4, dist = 1e8, w = .1, r =.1;\n        if(dot(u, ni)<0.)u = reflect(u, ni);\n        d1 = dot(u, abn)+w+r;\n        d2 = ru - (iy + .5-w-r)/N ;\n        d3 = (iy - .5+w+r)/N - ru ;\n        d4 = abs(p.y-2.*rnd(iy+ix)*clamp(8.*sin(time*(1.+rnd(iy+ix+6.))),0.,1.))-1.6;        \n        clr = vec4(rnd(iy+ix+3.),rnd(iy+ix+2.),rnd(iy+ix+1.),1)+.7;        \n        dist = length(max(vec4(d1,d2,d3,d4),0.))-r;//2117\n        return min(dist, bord);\n}\n\n\nfloat map(vec3 p)\n{\n        float t = iTime;\n        \n        //p.yz *=rot(t*.4);\n        //p.xz *=rot(t*.5);\n        //p.xy *=rot(t*.7);\n        return keyboard(p+vec3(0,5,0));\n}\n\nvoid mainImage(out vec4 O, vec2 v)\n{        \n        O = vec4(0.4);\n        vec2 R = iResolution.xy,\n             u = 1. * (v+v+.1 - R) / R.y,       \n             m = 1. * (iMouse.xy*2. - R) / R.y; \n        vec3 o = vec3(0, 0, -9),                \n             r = normalize(vec3(u+vec2(0,-.5), 2)),        \n             e = vec3(0, 1e-3, 0),             \n             p,n,                                 \n             s = normalize(vec3(-1,2,-3));      \n        dir = r;\n        O += exp(-80.*abs( keyboard(vec3(u.x,0,u.y)*5.) )); // backcolor\n        \n        float d,t,f,g,c ;\n        for(int i;i<256 && t < 25.;i++)\n        {\n                p = o + r * t;\n                d = map(p);\n                if(d<.01)\n                {\n                        n = normalize(vec3(map(p+e.yxx),map(p+e),map(p+e.xxy))-d);\n                        f = .5 + .5 * dot(n, s);\n                        g = max(dot(n,s),0.);\n                        c = 1. + pow(f, 200.)-f*.3; \n                        O = vec4(c*g)*clr; // 亲\n                        return;\n                }\n                t += d  ;\n        }\n}\n\n\n\n\n//////////////////\n\n\n/*\n// 1929 20240923\n#define time iTime\n#define TAU 6.2831853\n#define rot(t) mat2(cos(t),sin(t),-sin(t),cos(t))\nvec3 dir;\nvec4 clr;\n\nfloat intersect(vec2 o, float r,vec2 dir){\n        vec2 c=vec2(0);\n        vec2 l = c - o;\n        float s = dot(l,dir); // dir.xz\n        float l2 = dot(l,l), r2=r*r;\n        if(s<0. && l2>r2)return -1.;\n        float m2 = l2 - s*s;\n        if(m2>r2)return -1.;\n        float q = sqrt(r2-m2),t;\n        if(l2>r2)t=s-q;\n        else     t=s+q;\n        return t;\n}\n\nfloat rnd(float seed){\n    //return 0.;\n        return //fract(65.321*sin(123.456*\n        fract(sin(seed*234.567+13.322)*143.219)-.5;//))-.5;\n}\n\n\nfloat keyboard(vec3 p){//return length(p)-5.;\n        vec2 u = p.xz;\n        const float N=1.;\n        float M = 3.;\n        float au = atan(u.y, u.x)/TAU; // 角\n        float ru = length(u)*N;  // 长度\n        float iy = round(ru);   // 取整\n        float ofs = rnd(iy)*time; // 错位\n        float ix = round(au * iy*M + ofs);\n        \n        if((ix == round(-.5 * iy*M + ofs)) )ix = round(.5 * iy*M + ofs);\n        if(iy==0.)ix = 0.;// round(au * iy *M+ ofs);\n        \n        //ix = float((int(ix)+int(iy)/2-1)%int(iy)-int(iy)/2+1);\n        //return length(vec3(au-ix,p.y,ru-iy))-.3;\n        \n        \n        // 求解行进到直线边界的距离 t\n        //vec2 ni = vec2(-iy,ix); // 体素中心处正向旋转向量\n        float a=(ix -ofs)/M/iy*TAU;\n        vec2 ni =vec2(-sin(a),cos(a));\n        if(iy>0.5)ix=mod(ix,iy);\n       // \n        //ix = round(au * iy*M );\n        \n        \n    // float iAgl = step(0., dot(ni, dir.xz))-.5; // 同向正转 0.5 格，反向负 0.5 格\n        //float Agl = (ix +iAgl-ofs)/M/iy*TAU;       // 边界所在角度\n        //vec2 nrt = vec2(-sin(Agl),cos(Agl));       // 边界的法向量\n        float fu=step(0.,  dot( vec3(ni,0).xzy, dir) )*2.-1.;//xxxxx\n        float Agl=(  .5   )/M/iy*TAU;\n        vec2 nrt=rot(Agl*fu)*ni;\n        \n        vec2 nnrr=rot(Agl)*ni;\n        \n        float dbox = 1e8;\n     float t =  -dot(u, nrt) *length(dir)/dot(dir, vec3(nrt.x,0,nrt.y));\n        if(t>=0.)dbox = min(dbox, t);\n        // 求解与内外圆弧边界的距离 t\n     \n     \n     \n     float xi=length(dir.xz);\n     vec2 nm=normalize(dir.xz);\n     \n     t = intersect(u, (iy + .5)/N, nm)/xi; t *= length(dir)/length(dir.xz)  ;\n        if(t>=0.)dbox = min(dbox, t);        \n     t = intersect(u, (iy - .5)/N, nm)/xi; t *= length(dir)/length(dir.xz)  ;\n        if(t>=0.)dbox = min(dbox, t);\n        dbox = min(dbox,.5)+.05 + .0; // 不画边界。\n        \n        \n        //return dbox;\n        \n        \n        // 求解各真实物面距离 \n        float d1,d2,d3,d4, dist = 1e8, w = .1, r =.1;\n        if(dot(u, ni)<0.)u = reflect(u, ni);\n        d1 = dot(u, nnrr)+w+r;\n        // \n        d2 = ru - (iy + .5-w-r)/N ;\n        d3 = (iy - .5+w+r)/N - ru ;\n        d4 = abs(p.y-rnd((iy)+(ix))*1.)-1.6;\n        vec4 ss=max(vec4(d1,d2,d3,d4),0.);\n        dist=length(ss)-r;\n        //dist = max(max(d1,d2), max(d3,d4))-r;\n        \n        \n        clr=vec4(  rnd(iy+ix+1.),  rnd(iy+ix+2.),  rnd(iy+ix+3.),1  )+.7;\n        \n        \n        return min(dist, dbox);\n}\n\nfloat map(vec3 p)\n{\n        float t = iTime;\n        \n        //p.yz *=rot(t*.4);\n        //p.xz *=rot(t*.5);\n        //p.xy *=rot(t*.7);\n        return keyboard(p+vec3(0,5,0));\n}\n\nvoid mainImage(out vec4 O, vec2 v)\n{\n        \n        O = vec4(0.4);\n        vec2 R = iResolution.xy,\n             u = 1. * (v+v+.1 - R) / R.y,      // 实际坐标\n             m = 1. * (iMouse.xy*2. - R) / R.y;// 实际鼠标\n        \n        \n        vec3 pp=vec3(u.x,0, u.y)*5.;\n        float dd=keyboard(pp);\n        O+=exp(-80.*abs(dd));\n        \n        \n       // return;\n        \n        \n        vec3 o = vec3(0, 0, -9),               // 眼睛坐标\n             r = normalize(vec3(u+vec2(0,-.7), 2)),        // 射线\n             e = vec3(0, 1e-3, 0),             // 微距\n             p,n,                                // 法向量\n             s = normalize(vec3(-1,2,-3));     // 太阳\n        dir = r;\n        float d,t,f,g,c,xi=1.;\n        //ctxt=false;\n        for(int i;i<256 && t < 25.;i++)\n        {\n                p = o + r * t;\n                d = map(p);\n                if(d<.01)\n                {\n                        O *= 0.;\n                        //ctxt=true;\n                        float a = map(p+e);\n                        //ctxt=false;\n                        n = normalize(vec3(map(p+e.yxx),a,map(p+e.xxy))-d);\n                        f = .5 + .5 * dot(n, s);\n                        g = max(dot(n,s),0.);\n                        c = 1. + pow(f, 200.)-f*.3; // 665.352.6.542.9958.8.63\n                        O += c*xi;\n                        O = vec4(c*g)*clr; return;\n                        //xi *=.3;\n                        //d =.2;\n                }\n                t += d ;\n        }\n        //O *= .5;\n}\n\n\n*/\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}