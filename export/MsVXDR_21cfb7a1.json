{"ver":"0.1","info":{"id":"MsVXDR","date":"1465074457","viewed":532,"name":"Emerald Fractal Temple","username":"mplanck","description":"Progressive pathtracing with a moving light per sample frame. Variant of a menger sponge. Uses multiple importance sampling. Still playing, but this seemed interesting. Needs reflection.","likes":11,"published":1,"flags":48,"usePreview":0,"tags":["fractal","pathtrace","menger","mis","emerald"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Final gather \n\n// CAVEATS:\n// MacBook Pro 15\" has blown out results\n\n// INPUTS\n\n// SPACEBAR := reset sampling\n\n// **************************************************************************\n// GLOBALS\n\nfloat g_frame = 0.;\n\nvoid setup_globals()\n{\n    g_frame = float(iFrame) - texture(iChannel1, vec2(0., 0.), -100.).r ;\n}\n\n// **************************************************************************\n// MAIN COLOR\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setup_globals();\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 scol = vec3(0.);\n    if (g_frame > .5)\n    {\n\t\tscol = texture( iChannel0, uv ).xyz;\n        scol /= g_frame;\n        scol = pow( scol, vec3(0.45) );\n    }\n    \n    fragColor = vec4(scol, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A is used to store persistent state in one pixel\n// red pixel = start frame\n\n// INPUTS\n\n// SPACEBAR := reset sampling\n\n// **************************************************************************\n// CONSTANTS\n\nconst float KEY_SPACE = 32.5/256.0;\n\nbool this_pixel_is_being_rendered(vec2 fragCoord, vec2 r)\n{\n    return (step(r.y-.2, fragCoord.y) * step(fragCoord.y, r.y+1.2) * \n            step(r.x-.2, fragCoord.x) * step(fragCoord.x, r.x+1.2)) > .5;\n}\n\nbool this_pixel_is_in_the_range(vec2 fragCoord, vec2 r0, vec2 r1)\n{\n    return (step(r0.y-.2, fragCoord.y) * step(fragCoord.y, r1.y+1.2) * \n            step(r0.x-.2, fragCoord.x) * step(fragCoord.x, r1.x+1.2)) > .5;\n}\n\n// **************************************************************************\n// MAIN COLOR\n\nvec3 process_inputs(vec2 fragCoord)\n{\n    \n\tvec3 resultingColor = vec3(0.);\n    \n    vec3 storedState = texture(iChannel0, vec2(0., 0.), -100.).rgb;\n\n    float initialFrame = storedState.r;\n\n    // space bar resets coloring and sampling to default\n    float pressSpace = texture( iChannel1, vec2(KEY_SPACE,0.25) ).x;\n    if (pressSpace > .5 || iFrame == 0) \n    { \n        initialFrame = float(iFrame);         \n    }\t\n\n    if (this_pixel_is_being_rendered(fragCoord, vec2(0., 0.)))\n    {        \n\t\tresultingColor = vec3(initialFrame, 0., 0.);\n    }\n                \n    return resultingColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\n    if (!this_pixel_is_in_the_range(fragCoord, vec2(0., 0.), vec2(1., 0.)))\n    {\n        discard;\n    }\n    \n    vec3 finalColor = process_inputs(fragCoord);\n    \n    fragColor = vec4(finalColor,1.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buffer B does the sampling and accumulation work \n\n// **************************************************************************\n// DEFINES\n\n#define DEBUG_LIGHT 0\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define INV_TWO_PI .159155\n#define PI_OVER_TWO 1.570796\n\n#define REALLY_SMALL_NUMBER 0.0001\n#define REALLY_BIG_NUMBER 1000000.\n\n#define FRACTAL_MATERIAL_ID 1.\n#define BACKDROP_MATERIAL_ID 2.\n#define LIGHT_MATERIAL_ID 3.\n\n// **************************************************************************\n// CONSTANTS\n\n\n// **************************************************************************\n// INLINE MACROS\n\n#define MATCHES_ID(id1, id2) (id1 > (id2 - .5)) && (id1 < (id2 + .5))\n\n// **************************************************************************\n// GLOBALS\n\nfloat g_frame        = 0.;\n\nvec4 g_light0 = vec4(0.,1., -2., .5);\nvec4 g_light1 = vec4(0.,3.5, -8., 1.);\n\n/*\nvec4 get_light(int idx)\n{\n    if (idx == 0) { return g_light0; }\n    return g_light1;\n}\n*/\n\n// move the light with each frame sample, essentially simulating a light\n// that is extruded along the path of movement\nvec4 get_light(int idx)\n{\n    if (idx == 0) { return vec4(0., 0.5, -7. + 10. * mod(.005 * g_frame, 1.), .8); }\n    return vec4(1. * sin(.05 * g_frame), 1. * cos(.05 * g_frame) + 3.3, -8., .5);\n}\n\n\n// **************************************************************************\n// MATH UTILITIES\n\n// Rotate the input point around the y-axis by the angle given as a cos(angle)\n// and sin(angle) argument.  There are many times where I want to reuse the\n// same angle on different points, so why do the heavy trig twice. Range of\n// outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\nvec3 rotate_yaxis( vec3 point, float cosa, float sina )\n{\n    return vec3(point.x * cosa  + point.z * sina,\n                point.y,\n                point.x * -sina + point.z * cosa);\n}\n\n// Rotate the input point around the x-axis by the angle given as a cos(angle)\n// and sin(angle) argument.  There are many times where  I want to reuse the\n// same angle on different points, so why do the  heavy trig twice. Range of\n// outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\nvec3 rotate_xaxis( vec3 point, float cosa, float sina )\n{\n    return vec3(point.x,\n                point.y * cosa - point.z * sina,\n                point.y * sina + point.z * cosa);\n}\n\n\n// --------------------------------------\n\nfloat dist_squared(vec3 v1, vec3 v2)\n{\n    return (v1.x - v2.x) * (v1.x - v2.x) + \n        (v1.y - v2.y) * (v1.y - v2.y) + \n        (v1.z - v2.z) * (v1.z - v2.z);\n}\n\nvec4 intersect_sphere(vec3 ro, vec3 rd, vec3 sphc, float sphr)\n{\n    if (dist_squared(ro,sphc) < sphr * sphr) \n    { \n        return vec4(-1., vec3(0.)); \n    }\n    \n    vec3 sphro = ro - sphc; \n    float a = dot(rd, rd);\n    float b = dot(sphro, rd);\n    float c = dot(sphro, sphro) - sphr * sphr;\n    float sign = mix(-1., 1., step(0., a));\n    float t = (-b + sign * sqrt(b*b - a*c))/a; \n    \n    vec3 n = normalize(ro + t * rd - sphc);\n    return vec4(step(0., t), n);    \n    \n}\n\nvec3 polar_to_cartesian(float sinTheta, \n                        float cosTheta, \n                        float sinPhi,\n                        float cosPhi)\n{\n    return vec3(sinTheta * cosPhi,\n                sinTheta * sinPhi,\n                cosTheta);\n}\n\n// --------------------------------------\n// from dave hoskins: https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash21(float p)\n{\n    vec3 p3 = fract(vec3(p) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// **************************************************************************\n// DISTANCE FIELDS\n\nfloat sphere_df( vec3 p, float r) \n{ \n    return length(p) - r; \n}\n\nfloat envsphere_df ( vec3 p, float r) \n{ \n    return r - length(p); \n}\n\nfloat roundbox_df ( vec3 p, vec3 b, float r ) \n{\n    return length(max(abs(p-vec3(0., .5*b.y, 0.))-.5*b,0.))-r; \n}\n\n// **************************************************************************\n// INFORMATION HOLDERS (aka DATA STRUCTURES)\n\nstruct RaySampleInfo\n{\n    vec3 origin;\n    vec3 direction;\n    vec2 imagePlaneUV;\n};\n\n#define INIT_RAY_INFO() RaySampleInfo(vec3(0.) /* origin */, vec3(0.) /* direction */, vec2(0.) /* imagePlaneUV */)\n\nstruct SurfaceInfo\n{\n    float id;\n    vec3 incomingRayDir;\n    vec3 point;\n    vec3 normal;\n    float incomingRayLength;\n    float rayDepth;\n    \n};\n#define INIT_SURFACE_INFO(incomingRayDir) SurfaceInfo(-1. /* id */, incomingRayDir /* incomingRayDir */, vec3(0.) /* point */, vec3(0.) /* normal */, 0. /* incomingRayLength */, 0. /* rayDepth */)\n\nstruct MaterialInfo\n{\n    float seed;\n    float specExponent;\n    float specIntensity;\n    vec3  baseColor;\n    vec3  emissive;\n};\n#define INIT_MATERIAL_INFO(seed) MaterialInfo(seed, 1. /* specExponent */, 1. /* specIntensity */, vec3(.8) /* baseColor */, vec3(0.) /* emissive */)\n\n// **************************************************************************\n// SETUP \n\nvoid setup_globals()\n{\n    \n    vec3 storedState = texture(iChannel1, vec2(0., 0.), -100.).rgb;\n    g_frame = float(iFrame) - storedState.r ;\n}\n\nRaySampleInfo setup_cameraRay(vec2 aaoffset)\n{\n    \n    vec3 origin = vec3(0.1, 1.9, 4.9);\n    vec3 cameraPointsAt = vec3(0., 2.9, 0.);\n\n    float invAspectRatio = iResolution.y / iResolution.x;\n    vec2 imagePlaneUV = (gl_FragCoord.xy + aaoffset) / iResolution.xy - .5;\n    imagePlaneUV.y *= invAspectRatio;\n\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( cameraPointsAt - origin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    vec3 direction = normalize( imagePlaneUV.x * ix + imagePlaneUV.y * iy + .9 * iz );\n\n    return RaySampleInfo(origin, direction, imagePlaneUV);\n\n}\n\n// **************************************************************************\n// MARCH\n\nvec2 union_obj(vec2 o1, vec2 o2)\n{\n    return (o1.x < o2.x) ? o1 : o2;\n}\n\nvec2 map(float depth, vec3 p)\n{\n    \n   // transcribed from https://www.shadertoy.com/view/lddXRM\n   \n    float s = 1.0;\n    \n   vec3 mp = .5 * p - vec3(0., -.5, -.5);\n   float dim = roundbox_df(mp,vec3(20.0),.1);\n   vec3 res = vec3( dim, 1.0, 0.0 );\n       \n   for( int i=0; i<7; i++ )\n   {\n      vec3 a = mod( mp*s, 2.0 )-1.0;\n      vec3 r = abs(1. - 4.0*abs(a));\n\n      float dima = max(r.x,r.y);\n      float dimb = max(r.y,r.z);\n      float dimc = max(r.z,r.x);\n       \n      s *= 2.;\n      float dimf = (min(dima,min(dimb,dimc))-1.0)/s;\n\n      if( dimf>dim )\n      {\n          dim = dimf;\n          res = vec3( dim, 0.2*dima*dimb*dimc, (1.0+float(i))/2.0 );\n      }\n   }\n\n    float df = res.x;\n\n    vec2 resultObj = vec2(df, FRACTAL_MATERIAL_ID);\n    \n    float backdropDF = envsphere_df(p, 30.);\n    vec2 backdropObjs = vec2(backdropDF, BACKDROP_MATERIAL_ID);    \n    resultObj = union_obj(resultObj, backdropObjs);\n\n#if DEBUG_LIGHT\n\tfloat lightDF = 10.;\n    for (int lidx = 0; lidx < 2; ++lidx)\n    {\n        vec4 l = get_light(lidx);\n        lightDF = min(lightDF, sphere_df(p - l.xyz, l.w));\n    }\n    \n    vec2 lightObjs = vec2(lightDF, LIGHT_MATERIAL_ID);  \n    resultObj = union_obj(resultObj, lightObjs);\n#endif\n    return resultObj;\n}\n\nvec3 calc_normal(vec3 p)\n{\n \n    vec3 epsilon = vec3(0.001, 0., 0.);\n    \n    vec3 n = vec3(map(1., p + epsilon.xyy).x - map(1., p - epsilon.xyy).x,\n                  map(1., p + epsilon.yxy).x - map(1., p - epsilon.yxy).x,\n                  map(1., p + epsilon.yyx).x - map(1., p - epsilon.yyx).x);\n    \n    return normalize(n);\n}\n\nSurfaceInfo dist_march(float depth, vec3 ro, vec3 rd)\n{\n    SurfaceInfo surface = INIT_SURFACE_INFO(rd); \n    \n    float t = 0.;\n    vec3 p = ro;    \n    vec2 obj = vec2(0.);\n    float d = REALLY_BIG_NUMBER;\n    \n    for (int i = 0; i < 256; i++)\n    {\n        obj = map(depth, p);\n        d = obj.x;\n        \n        t += d;\n        p += rd * d;\n        \n        if (d < .001) { break; }\n        obj.y = 0.;\n        \n    }\n\n    surface.id = obj.y;        \n    surface.point = p;\n    surface.normal = calc_normal(surface.point);\n    surface.incomingRayLength = t;\n    surface.rayDepth = depth;\n    \n    return surface;\n}\n\nvoid calc_binormals(vec3 normal,\n                    out vec3 tangent,\n                    out vec3 binormal)\n{\n    if (abs(normal.x) > abs(normal.y))\n    {\n        tangent = normalize(vec3(-normal.z, 0., normal.x));\n    }\n    else\n    {\n        tangent = normalize(vec3(0., normal.z, -normal.y));\n    }\n    \n    binormal = cross(normal, tangent);\n}\n \nvec3 uniform_sample_cone(vec2 u12, \n                         float cosThetaMax, \n                         vec3 xbasis, vec3 ybasis, vec3 zbasis)\n{\n    float cosTheta = (1. - u12.x) + u12.x * cosThetaMax;\n    float sinTheta = sqrt(1. - cosTheta * cosTheta);\n    float phi = u12.y * TWO_PI;\n    vec3 sample_cone = polar_to_cartesian(sinTheta, cosTheta, sin(phi), cos(phi));\n    return sample_cone.x * xbasis + sample_cone.y * ybasis + sample_cone.z * zbasis;\n}\n             \nvec3 brdf(vec3 wi, \n          vec3 wo, \n          vec3 n,\n          MaterialInfo material)\n{\n    \n    float cosThetaN_Wi = abs(dot(n, wi));\n    float cosThetaN_Wo = abs(dot(n, wo));\n    vec3 wh = normalize(wi + wo);\n    float cosThetaN_Wh = abs(dot(n, wh));   \n    \n    // Compute geometric term of blinn microfacet      \n    float cosThetaWo_Wh = abs(dot(wo, wh));\n    float G = min(1., min((2. * cosThetaN_Wh * cosThetaN_Wo / cosThetaWo_Wh),\n                           (2. * cosThetaN_Wh * cosThetaN_Wi / cosThetaWo_Wh)));\n    \n    // Compute distribution term\n    float D = (material.specExponent+2.) * INV_TWO_PI * pow(max(0., cosThetaN_Wh), material.specExponent);\n    \n    // assume no fresnel\n    float F = 1.;\n    \n    return material.baseColor * D * G * F / (4. * cosThetaN_Wi * cosThetaN_Wo);\n}\n \n\nvec3 light_emission(vec3 p, vec3 lp, vec3 ln)\n{\n    return 9. * vec3(1., .95, .92) / dist_squared(p, lp);\n}\n\nfloat calc_visibility( vec3 ro, vec3 rd, float ray_extent )\n{\n    \n    SurfaceInfo surface = dist_march(1., ro, rd);\n    return step(ray_extent, surface.incomingRayLength);\n    \n}\n\nfloat light_pdf( vec4 light,\n                SurfaceInfo surface )\n{\n    \n    float sinThetaMax2 = light.w * light.w / dist_squared(light.xyz, surface.point);\n    float cosThetaMax = sqrt(max(0., 1. - sinThetaMax2));\n    return 1. / (TWO_PI * (1. - cosThetaMax));\n    \n}\n\nvec3 sample_light( SurfaceInfo surface,\n                   MaterialInfo material,\n                   vec4 light,\n                 out float pdf )\n{\n    vec2 u12 = hash21(material.seed);\n    \n    vec3 tangent = vec3(0.), binormal = vec3(0.);\n    vec3 ldir = normalize(light.xyz - surface.point);\n    calc_binormals(ldir, tangent, binormal);\n    \n    float sinThetaMax2 = light.w * light.w / dist_squared(light.xyz, surface.point);\n    float cosThetaMax = sqrt(max(0., 1. - sinThetaMax2));\n    vec3 light_sample = uniform_sample_cone(u12, cosThetaMax, tangent, binormal, ldir);\n    \n    pdf = -1.;\n    if (dot(light_sample, surface.normal) > 0.)\n    {\n        pdf = 1. / (TWO_PI * (1. - cosThetaMax));\n    }\n    \n    return light_sample;\n    \n}\n \nfloat brdf_pdf( vec3 wi, vec3 wo, \n                SurfaceInfo surface, \n                MaterialInfo material )\n{\n    vec3 wh = normalize(wi + wo);    \n    float cosTheta = abs(dot(wh, surface.normal));\n        \n    float pdf = -1.;\n    if (dot(wo, wh) > 0.)\n    {\n        pdf = ((material.specExponent + 1.) * pow(max(0., cosTheta), material.specExponent))/(TWO_PI * 4. * dot(wo, wh));\n    }\n    \n    return pdf;\n}\n\n\nvec3 sample_brdf( SurfaceInfo surface,\n                 MaterialInfo material,\n                out float pdf)\n{\n           \n    vec2 u12 = hash21(material.seed);\n    \n    float cosTheta = pow(max(0., u12.x), 1./(material.specExponent+1.));\n    float sinTheta = sqrt(max(0., 1. - cosTheta * cosTheta));\n    float phi = u12.y * TWO_PI;\n    \n    vec3 whLocal = polar_to_cartesian(sinTheta, cosTheta, sin(phi), cos(phi));\n\n    vec3 tangent = vec3(0.), binormal = vec3(0.);\n    calc_binormals(surface.normal, tangent, binormal);\n    \n    vec3 wh = whLocal.x * tangent + whLocal.y * binormal + whLocal.z * surface.normal;\n    \n    vec3 wo = -surface.incomingRayDir;    \n    if (dot(wo, wh) < 0.)\n    {\n       wh *= -1.;\n    }\n            \n    vec3 wi = reflect(surface.incomingRayDir, wh);\n    \n    pdf = ((material.specExponent + 1.) * pow(clamp(abs(dot(wh, surface.normal)),0.,1.), material.specExponent))/(TWO_PI * 4. * dot(wo, wh));\n    return wi;\n}    \n\nfloat power_heuristic(float nf, \n                      float fPdf, \n                      float ng, \n                      float gPdf)\n{\n    float f = nf * fPdf;\n    float g = ng * gPdf;\n    return (f*f)/(f*f + g*g);\n}\n\nvec3 integrate_lighting( SurfaceInfo surface,\n                       MaterialInfo material,\n                       vec3 wi)\n{\n    vec3 lcol = vec3(0.);\n       \n    for (int lidx = 0; lidx < 2; ++lidx)\n    {\n        vec4 light = get_light(lidx); \n                \n            // sample light        \n            float lpdf = -1.;\n            vec3 lightSample = sample_light(surface, material, light, lpdf);\n\n            \n            if (lpdf > 0.)\n            {\n                vec4 r = intersect_sphere(surface.point, lightSample, light.xyz, light.w);\n                if (r.x > .0)\n                {\n                    float bpdf = brdf_pdf(wi, lightSample, surface, material);\n                    float misWeight = power_heuristic(1., lpdf, 1., bpdf);\n\n                    float visibility = calc_visibility( surface.point + lightSample * .01, lightSample, r.x);\n                    vec3 le = light_emission(surface.point, surface.point + lightSample * r.x, r.yzw);\n                    // specular\n                    lcol += material.specIntensity * visibility * brdf(wi, lightSample, surface.normal, material) * \n                                le * abs(dot(lightSample, surface.normal)) *\n                                (misWeight/lpdf);\n\n                    // diffuse - cheated lambertian\n                    // reuse visibility\n                    lcol += material.baseColor * visibility * abs(dot(surface.normal, lightSample)) * le * INV_TWO_PI;\n\n\n                }\n            }        \n\n            \n            // sample brdf        \n            float bpdf = -1.;\n            vec3 brdfSample = sample_brdf(surface, material, bpdf);\n            if (bpdf > 0.)\n            {              \n                vec4 r = intersect_sphere(surface.point, brdfSample, light.xyz, light.w);\n                if (r.x > 0.)\n                {               \n\n                    float lpdf = light_pdf(light, surface);\n                    float misWeight = power_heuristic(1., bpdf, 1., lpdf);\n\n                    float visibility = calc_visibility( surface.point + brdfSample * .01, brdfSample, r.x);\n\n                    // specular\n                    lcol += material.specIntensity * visibility * brdf(wi, brdfSample, surface.normal, material) *\n                        light_emission(surface.point, surface.point + brdfSample * r.x, r.yxw) *\n                        abs(dot(brdfSample, surface.normal)) *\n                        (misWeight/bpdf);\n\n                    // diffuse sampling is ignored for brdf sampling since\n                    // light sampling dominates in importance with such a broad lobe\n                }\n            }\n    }\n    \n    lcol += material.emissive;\n\tfloat fog = exp(-.15 * surface.incomingRayLength);\n    lcol = mix(.02 * vec3(.2, .2, .6), lcol, pow(fog, 2.));\n           \n    \n    return lcol;\n}\n\nvec3 calc_pixelColor( float seed )\n{\n        \n    vec3 pcol = vec3(0.);    \n\n    // super hacky AA kernel\n    RaySampleInfo currSample = setup_cameraRay( sin(.128 * seed) * vec2(.7 * cos(.127 * seed), .7 * sin(.127 * seed)) );\n    \n    \n    for (float depth = 0.; depth < 1.; depth+=1.)\n    {\n        SurfaceInfo surface = dist_march(depth,\n                                         currSample.origin, \n                                         currSample.direction);\n        \n        MaterialInfo material = INIT_MATERIAL_INFO(seed);\n        float roughness = 1.;\n\n        if (surface.id < .5)\n        {\n            break;\n        }        \n        else if (MATCHES_ID(surface.id, FRACTAL_MATERIAL_ID))\n        {\n            roughness = .3;\n            material.baseColor = vec3(.1, .6, .1) + .1 * abs(surface.normal);\n        }\n        else if (MATCHES_ID(surface.id, BACKDROP_MATERIAL_ID))\n        {\n            roughness = 1.;\n            material.baseColor = vec3(.0);\n        }\n        else if (MATCHES_ID(surface.id, LIGHT_MATERIAL_ID))\n        {\n            roughness = 0.;\n            material.baseColor = vec3(.0);\n            material.emissive = 500. * vec3(1., .98, .95);\n        }\n                          \n         \n        else\n        {\n            break;\n        }\n        \n        material.specExponent = floor(max(1., (1. - pow(roughness, .15)) * 40000.));    \n        material.specIntensity = 10.;\n        \n        pcol += integrate_lighting(surface, material, -surface.incomingRayDir);\n        \n        currSample.direction = reflect(surface.incomingRayDir, surface.normal);\n        currSample.origin = surface.point + .01 * currSample.direction;\n        \n    }\n    \n    return pcol;   \n}\n\n// **************************************************************************\n// MAIN COLOR\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    setup_globals();\n    vec2 uv = fragCoord.xy / iResolution.xy;        \n        \n    // ----------------------------------\n    // SAMPLING \n    \n    float seed = g_frame + hash12( uv );\n    //float seed = float(floor(float(g_frame)/10.));\n    \n    vec3 currPixelColor = calc_pixelColor( seed );    \n\n    // ----------------------------------\n    // ACCUMULATE \n\n    vec3 finalColor = vec3(0.);\n    \n    if (g_frame > .5)\n    {\n        finalColor = texture(iChannel0, uv).rgb;\n    }\n    \n    finalColor += currPixelColor;\n    \n    fragColor = vec4(finalColor,1.0);\n}","name":"Buf B","description":"","type":"buffer"}]}