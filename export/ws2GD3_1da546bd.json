{"ver":"0.1","info":{"id":"ws2GD3","date":"1550180843","viewed":201,"name":"Moment Factory SDF","username":"fractalteapot","description":"Quick ray tracing experiment with a signed distance function of the Moment Factory logo.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float PI = 3.14159265359, ASP = 2.36550308, WW = 0.039930556, LH = 0.451595072, RM = 0.506145483, RN = 0.436, SA = 0.25, SR = 0.35, SY = 0.36;\nconst int MAX_MARCHING_STEPS = 128;\nconst float MIN_DIST = 3.2, MAX_DIST = 5.5, EPSILON = 0.0001;\nconst float ANI_DUR = 20.0, SLIDE_DUR = 2.0, FADE_DUR = 5.0;\n\n#define ADD(z) x = min(x, z)\n#define SADD(z, k) x = smoothAdd(x, z, k)\n#define SUB(z) x = max(-z, x)\n#define ZERO (min(iFrame,0))\n\nfloat smoothAdd( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat plane(vec3 p){\n\treturn p.z - 0.1;\n}\nfloat box( vec3 p, vec3 b ){\n    vec3 d = abs(p) - b/2.0;\n    return length(max(d, 0.0))+ min(max(d.x,max(d.y,d.z)),0.0);\n}\nfloat box( vec3 p, vec2 o, vec3 b ){\n\tp -= b/2.0 * vec3(o,0.0);\n    return box(p, b);\n}\nfloat box( vec3 p, float a, vec2 o, vec3 b ){\n\tp.xy -= 0.5*b.xy;\n    vec2 t = vec2(sin(a), cos(a));\n\tp.xy += b.xy*o/2.0; p.xy = mat2(t.y, t.x, -t.x, t.y) * p.xy; p.xy -= b.xy*o/2.0;\n    return box(p, b);\n}\nfloat sheer(vec3 p, float a, vec2 o, vec3 b ) {\n\tp.xy -= 0.5*b.xy;\n\tp.xy += b.xy*o/2.0; p.x += a*p.y;p.xy -= b.xy*o/2.0; \n\treturn box(p, b);\n}\nvec4 opElong( in vec3 p, in vec3 h ){\n    return vec4( p-clamp(p,-h,h), 0.0 );\n}\nfloat cylin( vec3 p, vec2 h ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat time;\nvec3 anim(float offset) {\n\treturn vec3(0.0,0.5*(1.0-smoothstep(0.0, 1.0, time-offset)),0.0) + vec3(0.0,0.0,0.2*smoothstep(ANI_DUR-SLIDE_DUR-FADE_DUR, ANI_DUR-SLIDE_DUR, time-offset));\n}\n\nfloat map(vec3 p) {    \n\n\tvec2 u = vec2(1.0,-1.0);\n\t\n    float cnvs = iResolution.x/iResolution.y, w = WW*cnvs, ln = LH*cnvs/ASP;\n\n\tp.x += w * 12.5;\n\tp.y += w * 6.0;    \n\n\tfloat h = 0.2;\n\tfloat hh = h/2.0;\n\t\n\tfloat t = 1., dt = SLIDE_DUR/6.0;\n\t\n\tfloat x = 1e10;\n\t\n\t/*M*/\n    ADD(box(p-vec3(0.0,ln+w,hh)+anim(t), u.xx, vec3(w, ln, h)));\n    ADD(box(p-vec3(3.0*w, 1.35*ln+w,hh)+anim(t), RM, u.xy, vec3(w, ln*.65, h)));\n    ADD(box(p-vec3(0.0, 1.35*ln+w,hh)+anim(t), -RM, u.yy, vec3(w, ln*.65, h)));\n\tADD(box(p-vec3(1.66*w, ln+w*2.56,hh)+anim(t), u.xx, vec3(w*0.68, ln*0.2, h)));\n    ADD(box(p-vec3(3.0*w, ln+w,hh)+anim(t), u.xx, vec3(w, ln, h)));\n\tt+=dt;\n\t/*O*/\n \t{vec4 e = opElong( p - vec3(6.5*w, 1.5*ln+w,hh)+anim(t), vec3(0.009,w,0.) );\n    ADD(e.w+cylin( e.yzx, vec2(0.1,0.5*h)));} \n\tSUB(box(p-vec3(6.05*w, 1.2*ln+w,hh)+anim(t), u.xx, vec3(w, ln*.6, h*2.0)));\n\tt+=dt;\n\t/*M*/\n\tADD(box(p-vec3(9.1*w,ln+w,hh)+anim(t), u.xx, vec3(w, ln, h)));\n    ADD(box(p-vec3(12.1*w, 1.35*ln+w,hh)+anim(t), RM, u.xy, vec3(w, ln*.65, h)));\n    ADD(box(p-vec3(9.1*w, 1.35*ln+w,hh)+anim(t), -RM, u.yy, vec3(w, ln*.65, h)));\n    ADD(box(p-vec3(12.1*w, ln+w,hh)+anim(t), u.xx, vec3(w, ln, h)));\n\tADD(box(p-vec3(10.76*w, ln+w*2.56,hh)+anim(t), u.xx, vec3(w*0.68, ln*0.2, h)));\n\tt+=dt;\n\t/*E*/\n\tADD(box(p-vec3(14.1*w,ln+w,hh)+anim(t), u.xx, vec3(w, ln, h)));\n\tADD(box(p-vec3(14.*w,ln+w,hh)+anim(t), PI/2.0, u.yx, vec3(w, ln*.43, h)));\n\tADD(box(p-vec3(14.*w,2.0*ln,hh)+anim(t), PI/2.0, u.yx, vec3(w, ln*.43, h)));\n\tADD(box(p-vec3(14.*w,2.0*ln-w*1.8,hh)+anim(t), PI/2.0, u.yx, vec3(w, ln*.35, h)));\n\tt+=dt;\n\t/*N*/\n\tADD(box(p-vec3(18.*w,ln+w,hh)+anim(t), u.xx, vec3(w, ln, h)));\n\tADD(box(p-vec3(20.15*w,ln+w,hh)+anim(t), u.xx, vec3(w, ln, h)));\n\tADD(box(p-vec3(18.*w, ln+w,hh)+anim(t), -RN, u.yy, vec3(w, ln, h)));\n\tt+=dt;\n\t/*T*/\n\tADD(box(p-vec3(22.95*w,ln+w,hh)+anim(t), u.xx, vec3(w, ln, h)));\n\tADD(box(p-vec3(21.1*w,2.0*ln+w*0.1,hh)+anim(t), PI/2.0, u.yx, vec3(w*0.9, ln*.6, h)));\n\n\t/*MASK*/\n\tSUB(box(p-vec3(-w*2.0,ln+w,0.0), u.xy, vec3(2.0,1.0,1.0)));\n\t\n\tfloat ln1 = x; x = 1e10;\n\tdt = SLIDE_DUR/7.0;\n\t\n\t/*F*/\n\tADD(box(p-vec3(0.0,0.0,hh)+anim(t)*vec3(1.0,-1.0,1.0), u.xx, vec3(w, ln, h)));\n\tADD(box(p-vec3(0.0,1.0*ln-0.9*w,hh)+anim(t)*vec3(1.0,-1.0,1.0), PI/2.0, u.yx, vec3(w*0.9, ln*.41, h)));\n\tADD(box(p-vec3(0.0,1.0*ln-w*2.9,hh)+anim(t)*vec3(1.0,-1.0,1.0), PI/2.0, u.yx, vec3(w*.85, ln*.38, h)));\n\tt-=dt;\n\t/*A*/\n\tADD(sheer(p-vec3(3.1*w,0.0,hh)+anim(t)*vec3(1.0,-1.0,1.0), -SA, u.xx, vec3(w, ln, h)));\n\tADD(sheer(p-vec3(5.65*w,0.0,hh)+anim(t)*vec3(1.0,-1.0,1.0), SA, u.xx, vec3(w, ln, h)));\n\tt-=dt;\n\t/*C*/\n\t{vec4 e = opElong( p - vec3(8.7*w, ln*0.5,hh)+anim(t)*vec3(1.0,-1.0,1.0), vec3(0.009,w,0.) );\n    ADD(e.w+cylin( e.yzx, vec2(0.1,0.5*h) ) );}\n\tSUB(box(p-vec3(8.2*w, 0.95*w,hh)+anim(t)*vec3(1.0,-1.0,1.0), u.xx, vec3(w, ln*.6, h*2.0)));\n\tSUB(box(p-vec3(8.4*w, 1.55*w,hh)+anim(t)*vec3(1.0,-1.0,1.0), u.xx, vec3(w*2.6, ln*.35, h*2.0)));\n\tt-=dt;\n\t/*T*/\n\tADD(box(p-vec3(11.8*w,0.0,hh)+anim(t)*vec3(1.0,-1.0,1.0), u.xx, vec3(w, ln, h)));\n\tADD(box(p-vec3(9.9*w,ln-w*0.9,hh)+anim(t)*vec3(1.0,-1.0,1.0), PI/2.0, u.yx, vec3(w*0.9, ln*.6, h)));\n\tt-=dt;\n\t/*O*/\n\t{vec4 e = opElong( p - vec3(15.85*w, ln*0.5,hh)+anim(t)*vec3(1.0,-1.0,1.0), vec3(0.009,w,0.) );\n    ADD(e.w+cylin( e.yzx, vec2(0.1,0.5*h) ) );} \n\tSUB(box(p-vec3(15.4*w, 0.2*ln,hh)+anim(t)*vec3(1.0,-1.0,1.0), u.xx, vec3(w, ln*.6, h*2.0)));\n\tt-=dt;\n\t/*R*/\n\t{vec4 e = opElong( p - vec3(19.7*w, ln*0.68,hh)+anim(t)*vec3(1.0,-1.0,1.0), vec3(0.02,0.009,0.));\n    ADD(e.w+cylin(e.yzx, vec2(0.1,0.5*h)));} \n\tADD(box(p-vec3(18.35*w,0.0,hh)+anim(t)*vec3(1.0,-1.0,1.0), u.xx, vec3(w, ln, h)));\n\tSUB(box(p-vec3(17.35*w,0.0,hh)+anim(t)*vec3(1.0,-1.0,1.0), u.xx, vec3(w, ln, 2.0*h)));\n\tADD(sheer(p-vec3(20.5*w,0.0,hh)+anim(t)*vec3(1.0,-1.0,1.0), SR, u.xx, vec3(w, ln, h)));\n\tSUB(box(p-vec3(19.35*w,2.5*w,hh)+anim(t)*vec3(1.0,-1.0,1.0), u.xx, vec3(w, ln*.28, h*2.0)));\n\tt-=dt;\n\t/*Y*/\n\tADD(sheer(p-vec3(22.95*w,.4*ln,hh)+anim(t)*vec3(1.0,-1.0,1.0), SY, u.xx, vec3(w*0.9, ln*0.6, h)));\n\tADD(sheer(p-vec3(23.05*w,.4*ln,hh)+anim(t)*vec3(1.0,-1.0,1.0), -SY, u.xx, vec3(w*0.9, ln*0.6, h)));\n\tADD(box(p-vec3(22.98*w,0.0,hh)+anim(t)*vec3(1.0,-1.0,1.0), u.xx, vec3(w*.95, ln*.5, h)));\n\t/*MASK*/\n\tSUB(box(p-vec3(-w*2.0,ln,0.0), u.xx, vec3(2.0,1.0,1.0)));\n\t\n\tADD(ln1);\n\t\n\tSADD(plane(p), 0.025);\n\n\tx = min(x,x);\n    return x;\n}\n\nvec3 hit;\nfloat march(vec3 rayPos, vec3 marchingDiboxion, float start, float end) {\n    hit = vec3(1e9);\n\tfloat depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n\t\thit = rayPos + depth * marchingDiboxion;\n        float dist = map(hit);\n        if (dist < EPSILON) return depth;\n        depth += dist;\n        if (depth >= end) return end;\n    }\n    return end;\n}\n            \nvec3 rayDiboxion(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 calcNormal( vec3 pos ){\n    // From IQ - 'inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times'\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ ) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e);\n    }\n    return normalize(n); \n}\n\nvec3 phong(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 rayPos) {\n    vec3 lPos = vec3(-sin(iTime*.25),0.5*cos(iTime*.25), 2.0);\n    vec3 lInt = vec3(0.4, 0.4, 0.4);\n\tvec3 N = calcNormal(p), L = normalize(lPos - p), V = normalize(rayPos - p), R = normalize(reflect(-L, N));\n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    if (dotLN < 0.0) return k_a + vec3(0.0, 0.0, 0.0);\n    if (dotRV < 0.0) return k_a + lInt * (k_d * dotLN);\n    return k_a + lInt * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nmat3 viewMatrix(vec3 rayPos, vec3 center, vec3 up) {\n    // Based on gluLookAt\n    vec3 f = normalize(center - rayPos);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\ttime = fract(iTime / ANI_DUR) * ANI_DUR;\n\tvec3 rayDir = rayDiboxion(45.0, iResolution.xy, fragCoord);\n\tfloat a = 1.2*smoothstep(4.0, 10.0, iTime);\n    vec3 rayPos = vec3(a*sin(iTime*0.5), a*cos(iTime*0.5), 4.0);\n    \n    vec3 worldDir = viewMatrix(rayPos, vec3(0.0), vec3(0.0, 1.0, 0.0)) * rayDir;\n    \n    float dist = march(rayPos, worldDir, MIN_DIST, MAX_DIST);\n    \n\tvec3 K_a = vec3(0.6) - smoothstep(0.18,0.2,hit.z)*0.5 + smoothstep(0.2,0.0,hit.z)*0.2;\n\tvec3 K_d = vec3(0.5,0.42,0.4);\n    vec3 K_s = vec3(1.0, 0.9, 0.8);\n    float shininess = 10.0;\n\t\n\tvec3 color;\n\t\n    if (dist > MAX_DIST - EPSILON) {\n        color = K_a;\n    } else {\n\t\tvec3 p = rayPos + dist * worldDir;    \n\t\tcolor = clamp(phong(K_a, K_d, K_s, shininess, p, rayPos) - 0.5 * smoothstep(3.0, 0.0, iTime), 0.0, 1.0);\n\t}\n\t\n\tvec2 uv = fragCoord / iResolution.xy;\n\tfloat v = 1.0*smoothstep(0.4, 1.0, distance(uv, vec2(0.5)));\n\tcolor -= v*v;\n\tfragColor = vec4(clamp(color, 0.0, 1.0),1.0);\n\t\n}","name":"Image","description":"","type":"image"}]}