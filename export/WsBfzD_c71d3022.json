{"ver":"0.1","info":{"id":"WsBfzD","date":"1589565481","viewed":100,"name":"Mickey repeat","username":"katila4","description":"learning","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 ORIG_COLOR = vec3(0.525,0.191,0.283);\nfloat TOTAL_PLAY_TIME = 2.95;\n\nvec4 STEPS = vec4(2.0, 1.0, 2.0, 1.0);\n\n// 4.0 - total steps count, 2.95 - total play time\nfloat SINGLE_PLAY_TIME = 2.95 / 4.0;\n\nfloat EaseOut(float x)\n{\n\treturn 1.0 - pow(1.0 - x, 3.0);   \n}\n\nvec3 Invert(vec3 color, float v)\n{\n    vec3 c = mix(color, vec3(1.0) - color, v);\n    return c;\n}\n\nvec3 Mult(vec3 color, vec3 origColor, float v)\n{\n    vec3 c = mix(color, Invert(origColor, 1.0), v);\n    return c;\n}\n\nvec2 Rotate(in vec2 p, float a, in vec2 c)\n{\n    vec2 res = p;\n    \n    float sn = sin(a);\n    float cs = cos(a);\n    \n    res -= c;\n    \n    float x = res.x * cs - res.y * sn;\n    float y = res.x * sn + res.y * cs;\n    \n    res = vec2(x, y) + c;\n    \n    return res;\n}\n\nfloat Circle(in vec2 st, in vec2 c, in float r){\n    vec2 dist = st - c;\n\treturn float(1.0 - step(r, dot(dist, dist) * 2.0));\n}\n\nfloat Border1(vec2 st, float v, float r)\n{\n    st = Rotate(st, r, vec2(0.5));\n    \n    vec2 b1 = st - vec2(v);\n    vec2 b2 = st + vec2(v);\n    \n    return float(b1.x < st.y &&\n                 b2.x > st.y);\n}\n\nfloat GetTime()\n{\n    return iTime;\n}\n\nfloat GetTotalTime()\n{\n    return mod(GetTime(), TOTAL_PLAY_TIME) / TOTAL_PLAY_TIME;\n}\n\nfloat GetSingleTime(in int step)\n{\n    float t = GetTotalTime();\n    float tt = (t * TOTAL_PLAY_TIME - SINGLE_PLAY_TIME * float(step)) / SINGLE_PLAY_TIME;\n    tt = clamp(tt, 0.0, 1.0);\n    \n    tt = EaseOut(tt);\n    \n    return tt;\n}\n\nvec3 Modify(in vec3 color, in vec2 st, in int type, in int stp) {\n    vec3 c = color;\n    float ft = float(type);\n    float fstp = float(stp);\n    c = mix(c, Invert(c, Circle(st, vec2(0.5), GetSingleTime(stp))), step(1.0, ft) * (1.0 - step(2.0, ft)));\n    c = mix(c, Invert(c, Border1(st, GetSingleTime(stp), 0.0)), step(2.0, ft) * (1.0 - step(3.0, ft)));\n    return c;\n}\n\nvec3 Picture(in vec3 color, in vec3 origColor, in vec2 st) \n{\n    float offsetY = 0.004;\n    float offsetY2 = -0.030;\n    color = Mult(color, origColor, Circle(st, vec2(0.75, 0.72 - offsetY + offsetY2), 0.063));\n    color = Mult(color, origColor, Circle(st, vec2(0.25, 0.72 - offsetY + offsetY2), 0.063));\n    color = Mult(color, origColor, Circle(st, vec2(0.5, 0.41 - offsetY), 0.134)); \n    return color;\n}\n\nvec2 Repeat(in vec2 st, in int row, in int column) \n{\n    float rowC = 1.0 / float(row);\n    float columnC = 1.0 / float(column);\n    vec2 stOrig = st;\n    \n    st.x -= floor((st.x) / rowC) * rowC;\n    st.y -= floor((st.y) / columnC) * columnC;\n\n    st.x = mod(st.x, 1.0);\n    st.y = mod(st.y, 1.0);\n    \n    st.x *= float(row);\n    st.y *= float(column);\n    \n    return st;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x -= 0.25;\n    st.x *= iResolution.x / iResolution.y;\n    \n    vec2 stOrig = st;\n    \n    vec3 origColor = ORIG_COLOR;\n    \n    vec3 color = origColor;\n    int gridCount = 10;\n    st = Repeat(st, gridCount, gridCount);\n    color = Picture(color, color, st);\n    \n    for (int i = 0; i < int(4.0); ++i)\n    {\n        color = Modify(color, st, int(STEPS[i]), i);\n    }\n    \n    vec3 c = Picture(vec3(0.0), vec3(0.0), stOrig);\n    for (int i = 0; i < int(4.0); ++i)\n    {\n        c = Modify(c, stOrig, int(STEPS[i]), i);\n    }\n    \n    color = mix(origColor, color, c);\n    color = mix(origColor, color, step(0.0, stOrig.x));\n    color = mix(color, origColor, step(1.0, stOrig.x));\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}