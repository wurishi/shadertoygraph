{"ver":"0.1","info":{"id":"wtlXDl","date":"1565977902","viewed":357,"name":"spectrum ocean + linear wave pde","username":"cdyk","description":"Experiment with blending in linear wave pde to let objects interact with a spectrum-based ocean. Not fully realistic yet, but interesting. :-) Needs minimum 280 pixels of height to run, waves will slow down when running < 60fps.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["spectrum","ocean","dft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Important: Viewport must be at least 280 pixels high.\n//\n// A small experiment with using the linear wave pde around an object in a\n// spectrum based ocean (produced by discrete Fourier-transform), to allow\n// the object to interact with the water.\n// \n// Definitely not fully realistic, the boundary-conditions are just a hack,\n// but I found the result interesting at least. :-)\n//\n// Buffer A runs a ocean spectrum + 2 discrete fourier transforms + an\n// inverse adjustment for XY-displacement (I want to sample over a regular\n// grid and without XY-displacement the waves are just cosines and not\n// trochoids).\n//\n// Buffer B runs a stencil of the 2D linear wave equation for an area\n// around the cylinder. The wave height of the PDE is blended radially\n// into the PDE. The inner boundary condition is just exaggerated wave\n// height from the DFT-ocean (to give the illusion of out-flow and\n// backwater).\n//\n// Image-shader does raycasting + shading.\n//\n//\n// Uncomment this turn of wave-equation around cylinder:\n//#define NO_BLEND\n\n// Buffer A - DFT waves\n// =====================\n//\n// Uncomment to view Buffer A, the dFT wave code\n//#define VIEW_BUFFER_A\n//\n// Contains four squares. Lower squares are padded (i.e. (N+2)x(N+2) so\n// they can be directly sampled with interpolation.\n//\n// - Upper left, N x N:\n//   R, G: Result of horizontal DFT-pass for wave height.\n//   B, A: Frequency-space representation (amplitude-phase).\n//\n// - Upper right: N x N:\n//   R, G: Result of horizontal DFT-pass for wave X-displacement.\n//   B, A: Result of horizontal DFT-pass for wave Y-displacement.\n//\n// - Lower left (N+2) x (N+2):\n//   - R: Real part of result of vertical DFT-pass for wave height.\n//   - G: Imaginary part of result of vertical DFT-pass for wave X-displacement\n//   - B: Imaginary part of result of vertical DFT-pass for wave Y-displacement\n//   - A: Unused.\n// - Lower right (N+2) x (N+2):\n//   - Data of lower left inversely warped according to X,Y-displacement, makes\n//     the waves trochoids instead of cosine-curves.\n//\n// Buffer B - Linear wave equation\n// ===============================\n//\n// Uncomment to view Buffer B, the linear wave PDE\n// #define VIEW_BUFFER_B\n//\n// Channels:\n//   R: Wave height at timestep i\n//   G: Wave height at timestep i-1\n//   B: Partial derivative of wave height along X\n//   A: Partial derivative of wave height along Y\n//\n// Discretized linear wave equation. Boundary condition around the cylinder\n// is twice the wave height from the DFT to exaggerate the rebound and\n// backwater. The boundary condition of the outer boundary is gradually\n// imposed by blending increasingly with increased radius (normalized radius^5).\n\n\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n\nfloat intersectPlane(out vec3 normal,\n                     in Ray r,\n                     in vec3 n,\n                     float d)\n{\n    normal = n;\n    return (d - dot(r.o, n))/dot(r.d, n);\n}\n\nfloat intersectCylinder(out vec3 normal,\n                        in Ray r,\n                        in vec3 o,\n                        float hl,\n                        float r2)\n{\n    vec2 g = r.o.xy - o.xy;\n\n    float a = dot(r.d.xy, r.d.xy);\n    float b = 2.0*dot(g.xy, r.d.xy);\n    float c = dot(g.xy, g.xy) - r2;\n    \n    float disc = b*b - 4.0*a*c;\n    if(disc < 0.0) return -1.0;\n\n    \n    float d = sqrt(disc);\n    float t0 = (-b - d)/(2.0*a);\n    float t1 = (-b + d)/(2.0*a);\n\n    float rcp = 1.0/r.d.z;\n    float aa = rcp*(o - r.o).z;\n    float ta = aa - abs(rcp)*hl;\n    float tb = aa + abs(rcp)*hl;\n\n    // cylinder is between near and far cap\n    if(ta <= t0 && t0 <= tb) {\n        vec2 w = g + t0*r.d.xy;\n\t    normal = normalize(vec3(w,0));\n        return t0;\n    }\n            \n    // near cap is inside infinite cylinder\n    if(t0 < ta && ta < t1) {\n     \tnormal = vec3(0,0,-sign(r.d.z));\n        return ta;\n    }\n\n    return -1.0;\n}\n\nvec2 samplePos(in vec2 worldPos)\n{\n    vec2 tilenorm = (1.0/float(L))*mod(worldPos, float(L));\n    \n\treturn (float(N)/iResolution.xy)*tilenorm;\n}\n\n\nfloat oceanHeight_(in vec2 p_w)\n{\n    p_w -= vec2(L/2.0);\n    vec2 o = vec2(Nf + 2.0 + 1.0, 1.0)/iResolution.xy;\n    vec2 s = Nf/iResolution.xy;\n\n\tvec2 p_u = fract((1.0/L)*p_w);\n    vec2 p_n = Nf*p_u;\n\n    vec2 p_i = floor(p_n);\n    vec2 p_f = fract(p_n);\n\n    return texture(iChannel0, (Nf/iResolution.xy)*p_u + o).x;\n}\n\n\nvec3 oceanNormal_(in vec2 p_w, float factor)\n{\n    p_w -= vec2(L/2.0);\n    vec2 o = vec2(Nf + 2.0 + 1.0, 1.0)/iResolution.xy;\n    vec2 s = Nf/iResolution.xy;\n\n\tvec2 p_u = fract((1.0/L)*p_w);\n    vec2 p_n = Nf*p_u;\n\n    vec2 p_i = floor(p_n);\n    vec2 p_f = fract(p_n);\n\n    float v00 = texture(iChannel0, (1.0/iResolution.xy)*(p_i + 0.5*p_f + vec2(0.0, 0.0) ) + o).x;\n    float v10 = texture(iChannel0, (1.0/iResolution.xy)*(p_i + 0.5*p_f + vec2(0.5, 0.0) ) + o).x;\n    float dx = v10 - v00;\n    float v01 = texture(iChannel0, (1.0/iResolution.xy)*(p_i + 0.5*p_f + vec2(0.0, 0.5) ) + o).x;\n    float dy = v01 - v00;\n    \n\tfloat dw = 0.5*float(L)/float(N);\n    return cross(vec3(dw, 0, factor*dx),\n                 vec3(0, dw, factor*dy));\n}\n\n\nfloat oceanHeight(in vec2 p_w)\n{\n    float h = amplitude0*oceanHeight_(p_w);\n#if defined(NO_BLEND)\n    float fade = 1.0;\n#else\n    float fade = getFade(p_w);\n#endif\n    if(fade < 1.0) {\n        \n\n        vec2 p_uv = ((p_w*MIN_WINDOW_HEIGHTf)/(PDE_SCALE*cylinderRadius) + 0.5*MIN_WINDOW_HEIGHTf)/iResolution.xy;\n        \n        float hh = texture(iChannel1, p_uv).y;\n        h = hh;\n    }\n    return h;\n}\n\n\nvec3 oceanNormal(in vec2 p_w)\n{\n    float c0 = cos(0.11);\n    float s0 = sin(0.11);\n\tfloat c1 = cos(0.33);\n    float s1 = sin(0.33);\n\tfloat c2 = cos(0.23);\n    float s2 = sin(0.23);\n    \n    vec3 n = oceanNormal_(p_w, amplitude0);\n    n += oceanNormal_(4.0*mat2(c0, s0, -s0, c0)*p_w, amplitude1);\n    n += oceanNormal_(7.0*mat2(c1, s1, -s1, c1)*p_w, amplitude2);\n    n += oceanNormal_(13.0*mat2(c2, s2, -s2, c2)*p_w, amplitude3);\n\n#if defined(NO_BLEND)\n    float fade = 1.0;\n#else\n    float fade = getFade(p_w);\n#endif\n    if(fade < 1.0) {        \n\n        vec2 p_uv = ((p_w*MIN_WINDOW_HEIGHTf)/(PDE_SCALE*cylinderRadius) + 0.5*MIN_WINDOW_HEIGHTf)/iResolution.xy;\n\n        float dx = PDE_SCALE*cylinderRadius/iResolution.y;\n        vec2 dz = texture(iChannel1, p_uv).zw;\n\n        vec3 nn = cross(vec3(dx*dx, 0, sign(dz.x)*dz.x*dz.x),\n                        vec3(0, dx*dx, sign(dz.y)*dz.y*dz.y));\n\t    nn += 0.0025*oceanNormal_(13.0*mat2(c2, s2, -s2, c2)*p_w, amplitude3);\n        n = mix(nn, n, fade);\n    }\n\treturn normalize(n);\n}\n\nfloat castOcean(out vec3 n, in Ray r, in float t, in float t_end)\n{\n    vec3 p = r.o + t*r.d;\n    float h = oceanHeight(p.xy);\n    if(p.z < h) {\n        return -1.0;\n    }\n    \n    for(int i=0; i<2000 && t < t_end; i++) {\n\n        float dt =  0.001*t;\n        float tt = t + dt;\n        vec3 pp = r.o + tt*r.d;\n        float hh = oceanHeight(pp.xy);\n        if(pp.z < hh) {\n            \n            float f = (h - p.z)/((h -p.z) - (hh - pp.z));\n            \n            tt = t + f*dt;\n            p = r.o + tt*r.d;\n            n = oceanNormal(p.xy);\n            return tt;\n        }\n        h = hh;\n        t = tt;\n        p = pp;\n    }\n    return t;\n}\n\nfloat castShadowRay(in Ray r)\n{\n    float t = 1e37;\n    vec3 nn;\n    float tt;\n\ttt = intersectCylinder(nn, r, vec3(0,0,0), 20.0, cylinderRadius*cylinderRadius);\n    if(0.0 < tt && tt < t) {\n        return 0.0;\n    }\n    return 1.0;\n}\n\nfloat castRay(out vec3 n, out int id, in Ray r)\n{\n    float t = 1e37;\n    vec3 nn;\n    float tt;\n    id = 0;\n\ttt = intersectCylinder(nn, r, vec3(0,0,0), 20.0, cylinderRadius*cylinderRadius);\n    if(0.0 < tt && tt < t) {\n        id = 1;\n        t = tt;\n        n = nn;\n    }\n    \n    tt = intersectPlane(nn, r, vec3(0,0,1), 10.0);\n    if(0.0 < tt && tt < t) {\n        float t_end = intersectPlane(nn, r, vec3(0,0,-1), 10.0);\n        nn = vec3(0,1,0);\n        tt = castOcean(nn, r, tt, t_end);\n        if(0.0 < tt && tt < t) {\n            id = 2;\n    \t    t = tt;\n        \tn = nn;\n\t    }\n    }\n    return t < 1e37 ? t : -1.0;\n}\n\nvec3 skyColor(in vec3 dir, in vec3 sun_dir)\n{\n    const vec3 sun_col = vec3(1,0.9,0.64);\n    \n    float sun_cos = max(0.0, dot(dir, sun_dir));\n    \n    vec3 c;\n    \n    c += 7.0*(1.0-smoothstep(cos(0.01), cos(0.04), sun_cos))*sun_col;\n    c += 3.0*pow(sun_cos, 500.0)*sun_col;\n    c += 1.0*pow(sun_cos, 30.0)*sun_col;\n    //c += 0.2*pow(sun_cos, 3.0)*sun_col;\n    c += 1.0*mix(vec3(0.4, 0.5, 0.67), vec3(0.06, 0.1, 0.7), max(0.0, dir.z));\n    \n    return c;\n}\n\nfloat fresnel(in float theta, in float F_0)\n{\n    return F_0 + (1.0-F_0)*pow(1.0-max(0.0, theta), 5.0);\n}\n\nvec3 colorize(float x)\n{\n    if(0.0 <= x) {\n        return vec3(x,\n                    max(0.0,1.0-x)+max(0.0,(x-1.0)),\n                    x-2.0);\n    }\n    else {\n        return vec3(-x-1.0,\n                    max(0.0, 1.0 + x),\n                    -x);\n    }\n}\n\nvec3 ind(vec2 p, vec3 n, vec3 sun_dir)\n{\n    float c0 = cos(0.3);\n    float s0 = sin(0.3);\n    vec3 m1 = oceanNormal(p);\n    vec3 m2 = oceanNormal(1.2*mat2(c0,s0,-s0,c0)*p);\n    vec3 m3 = oceanNormal(1.1*mat2(c0,-s0,s0,c0)*p);\n\n    float d1 = max(0.0, dot(n,m1));\n    float d2 = max(0.0, dot(n,m2));\n    float d3 = max(0.0, dot(n,m3));\n    float d = d1 + d2 + d3;\n    float g = smoothstep(0.0,0.1, d);\n\treturn g*vec3(0.1, 0.12, 0.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if defined(VIEW_BUFFER_A)\n    vec2 uv = fragCoord/iResolution.xy;\n    if(fragCoord.y < float(N+2) && fragCoord.x < float(2*(N + 2))) {\n        fragColor = vec4(0.1*colorize(texture(iChannel0, uv).x), 0);\n    }\n    else if(fragCoord.y < float(N + N+2) && fragCoord.x < float(2*N)) {\n        float t = texture(iChannel0, uv).x;\n        fragColor = vec4(t, 0, -t, 0);\n    }\n    else {\n     \tfragColor = vec4(0);   \n    }\n    \n#elif defined(VIEW_BUFFER_B)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 t = texture(iChannel1, uv);\n    if(t.z == 0.0 && t.w == 0.0) {\n        fragColor = vec4(0.0);\n    }\n    else {\n        fragColor = vec4(colorize(t.x),0);\n    }\n#else\n    float c0 = cos(-0.51);\n    float s0 = sin(-0.51);\n    \n    vec2 q = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\n    mat3 R0 = mat3(1.0, 0.0, 0.0,\n\t\t           0.0,  c0,  s0,\n        \t       0.0, -s0,  c0);\n    \n    Ray r;\n    r.d.x = q.x;\n    r.d.y = 1.0;\n    r.d.z = q.y;\n    r.d = normalize(R0*r.d);\n\n    r.o = R0*vec3(0,-50,0);\n\n    vec3 n;\n    int id;\n    float t = castRay(n, id, r);\n    if(0.0 < t) {\n        const float F_0_water = 0.005;\n        vec3 eye_dir = -r.d;\n        vec3 eye_ref = reflect(-eye_dir, n);\n        vec3 sun_dir = normalize(vec3(-1, 1.5, 1));\n        vec3 sun_hlf = normalize(sun_dir + eye_dir);\n        vec3 sun_col = vec3(1,0.95,0.8);\n        vec3 sky_col = vec3(0.2, 0.3, 0.4);\n        vec3 p_h = r.o + t*r.d;\n        \n        float sun_diff;\n        float sun_spec;\n        \n        float reflectivity;\n        vec3 mat = vec3(0.2);\n        vec3 c = vec3(0);\n        if(id == 2) {\n            mat = vec3(0.0, 0.1, 0.2);\n            reflectivity = fresnel(dot(eye_dir, n), F_0_water);\n            sun_spec = 1.0*reflectivity*pow(max(0.0,1.01*dot(sun_hlf, n)), 35.0);\n            sun_diff = 0.0;\n        }\n        else {\n            reflectivity = 0.1*n.z + 0.05*fresnel(dot(eye_dir, n), F_0_water);\n            sun_diff = 0.01;\n            if(n.z == 0.0) {\n                float h_o = oceanHeight(p_h.xy);\n                float d = max(1.0, p_h.z - 0.25*h_o + 10.0);\n                float f = clamp(0.006*(p_h.z - h_o), 0.0, 1.0);\n                float r = 8.0*pow(1.0/d, 2.0);\n                vec2 s_p = d*n.xy;\n                reflectivity += f*(1.0 - max(0.0, dot(-n, sun_dir)));\n                c += r*ind(s_p, n, sun_dir);\n            }\n        }\n\n        c += reflectivity*skyColor(eye_ref, sun_dir);\n        c += sun_diff*skyColor(n, sun_dir);\n        \n        c += 0.01*vec3(sun_diff);\n        fragColor = vec4(pow(2.7*c, vec3(0.4545)), 1.0);\n    }\n    else {\n        fragColor = vec4(0.5, 0.75, 1.0, 1.0);\n    }\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"int wang_hash(int seed)\n{\n  seed = (seed ^ 61) ^ (seed >> 16);\n  seed *= 9;\n  seed = seed ^ (seed >> 4);\n  seed *= 0x27d4eb2d;\n  seed = seed ^ (seed >> 15);\n  return seed & 0x7fffffff;\n}\n\n\n\nfloat spectrum(in ivec2 ij_c)\n{\n    vec2 Kappa = (2.0*M_PI/L)*vec2(ij_c);\n    float kappa = length(Kappa);\n    float theta = atan(Kappa.y, Kappa.x);\n    float omega = sqrt(g*kappa);\n\tfloat omega_p = 0.855*g/U_10;\n\n\t// Pierson-Moskowitch spectrum\n\tfloat o5 = omega*omega*omega*omega*omega;\n\tfloat opo = omega_p/omega;\n\tfloat opo4 = opo*opo*opo*opo;\n\tfloat S = ((0.0081*g*g)/o5)*exp( (-5.0/4.0)*opo4 );\n\n\t// Longuet-Higgins directional spreading func\n\tfloat mu = omega < omega_p ? 5.0 : -2.5;\n\tfloat s = 11.5*pow( (g/(omega_p*U_10)), 2.5 ) * pow(omega/omega_p, mu);\n\tfloat N = pow(s*s + 0.5*s + 1.0/80.0, 1.0/4.0);\n\tfloat D = N * pow(cos(0.5*theta), 2.0*s);\n\n\t// Change-of-variables factor\n\tfloat change = (1.0/(2.0*kappa))*sqrt(g/kappa);\n\n    if(ij_c.x == 0 && ij_c.y == 0) {\n        return 0.0;\n    }\n    else {\n\t\treturn change*S*D;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 w = vec2(1)/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    int i = int(fragCoord.x);\n    int j = int(fragCoord.y);\n    \n\n\n    vec4 t;\n\n    if(j < N+2) {\n\n        if(i < N+2) {\n    \t    t = vec4(0);\n            int ii = i;// % N;\n            if(N <=i) i -= N; \n\t        for(int k=0; k<N; k++) {\n        \t    float theta = (2.0*M_PI/float(N))*float(k*j);\n\n    \t        vec2 c = texture(iChannel0, w*(vec2(ii, k + N + 2)+vec2(0.5))).xy;\n\t            vec4 s = texture(iChannel0, w*(vec2(ii + N, k + N + 2)+vec2(0.5)));\n\n            \tt.x += -complexMul(c, vec2(cos(theta), sin(theta))).x;\n        \t    t.y += complexMul(s.xy, vec2(cos(theta), sin(theta))).y;\n    \t        t.z += complexMul(s.zw, vec2(cos(theta), sin(theta))).y;\n\t        }\n        }\n        \n        else if (i < 2*(N + 2)) {\n            vec2 ww = vec2(N)/iResolution.xy;\n            int ii = i - (N+2);\n            int jj = j;\n\n            vec2 o_ = (1.0/float(N))*(vec2(ii,jj) + vec2(0.5));\n            vec2 t_ = o_;\n            for(int i=0; i<3; i++) {\n\t           \tvec2 d_ = (float(1.0)/float(L))*texture(iChannel0, ww*t_).yz;\n                vec2 z_ = t_ + d_;\n                t_ -= z_ - o_;\n                \n                t_ = fract(t_);\n            }\n            \n            \n           \tt = texture(iChannel0, ww*t_);\n        }\n    }\n\n    else if(j < N+2+N) {\n        int ii = i;\n        int jj = j - (N + 2);\n   \n        if(i < N) {\n            t = texture(iChannel0, uv);\n\n            // Manage spectrum\n            ivec2 ij = ivec2(ii <= N / 2 ? ii : ii - N,\n                             jj <= N / 2 ? jj : jj - N);\n            vec2 K = (2.0*M_PI/L)*vec2(ij);  // K: wave vector\n            float k = length(K);             // k: wave number\n            float o = sqrt(g*k);             // omega: angular velocity\n            if(iFrame == 0) {\n                // Initialize spectrum\n                float E = spectrum(ij);\n\n                float p = (6.28318530718 / float(0x7fffffff))*float(wang_hash(int(65521*i + j)));\n\n                \n                t.zw = vec2(E, p);\n            }\n            else {\n                // Disperse waves\n                t.zw = texture(iChannel0, uv).zw;\n                vec2 kn = (1.0/k)*K;\n                \n                // Run ocean waves slower if framerate is\n                // less than 60fps to aboid dFT waves out-\n                // running PDE waves.\n                float dt = min(1.0/60.0, iTimeDelta);\n                t.w = mod(t.w + 1.0*o * dt, 2.0*M_PI);\n            }\n\n            t.xy = vec2(0);\n            for(int k=0; k<N; k++) {\n                vec2 v = texture(iChannel0, w*(vec2(k, j)+vec2(0.5))).zw;\n                float theta = (2.0*M_PI/float(N))*float(k*ii);\n                t.xy += v.x*vec2(cos(theta+v.y), sin(theta+v.y));\n            }\n        }\n        else if(i < 2*N) {\n            int ii = i - N;\n            int jj = j - (N + 2);\n            \n            t = vec4(0);\n            for(int k=0; k<N; k++) {\n\n                ivec2 ij = ivec2(k  <= N / 2 ? k  : k  - N,\n\t                             jj <= N / 2 ? jj : jj - N);\n\t            vec2 K = (2.0*M_PI/L)*vec2(ij);\n                \n                vec2 v = texture(iChannel0, w*(vec2(k, j)+vec2(0.5))).zw;\n                float theta = (2.0*M_PI/float(N))*float(k*ii);\n                vec2 q = v.x*vec2(cos(theta+v.y), sin(theta+v.y));\n                t.xy += kScale*K.x*q;\n                t.zw += kScale*K.y*q;\n            }\n        }\n    }\n\n    fragColor = t;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define M_PI 3.1415926535897932384626433832795\n#define PDE_SCALE 16.0\n#define MIN_WINDOW_HEIGHT 280\n#define MIN_WINDOW_HEIGHTf float(MIN_WINDOW_HEIGHT)\n\nconst int N = 128;\nconst float Nf = float(N);\nconst float L = 128.0;\nconst float U_10 = 6.0;\nconst float g = 9.80665; // gravity of earth\n\nconst float amplitude0 = 0.2;\nconst float amplitude1 = 0.1;\nconst float amplitude2 = 0.05;\nconst float amplitude3 = 0.025;\nconst float kScale = 0.8;\n\nconst float cylinderRadius = 5.0;\n\nfloat getFade(vec2 p_w)\n{\n    return pow(2.0*length(p_w)/(PDE_SCALE*cylinderRadius), 5.0);\n}\n\nvec2 complexMul(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nfloat oceanHeight(in vec2 p_w)\n{\n    p_w -= vec2(L/2.0);\n    vec2 o = vec2(Nf + 2.0 + 1.0, 1.0)/iResolution.xy;\n    vec2 s = Nf/iResolution.xy;\n\n\tvec2 p_u = fract((1.0/L)*p_w);\n    vec2 p_n = Nf*p_u;\n\n    vec2 p_i = floor(p_n);\n    vec2 p_f = fract(p_n);\n\n    return texture(iChannel0, (Nf/iResolution.xy)*p_u + o).x;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p_w = PDE_SCALE*cylinderRadius*(fragCoord - 0.5*MIN_WINDOW_HEIGHTf)/MIN_WINDOW_HEIGHTf;\n\n    \n    float h = amplitude0*oceanHeight(p_w);\n\n    \n    bool boundary = length(p_w) < 0.9*cylinderRadius;\n    float fade = getFade(p_w);\n    \n    vec4 v = texture(iChannel1, uv);\n    if(iFrame < 4 || 1.0 <= fade) {\n        v = vec4(h, h, 0, 0);\n    }\n    // Throttle PDE down to 60 fps if shader is running fasster\n    else if(floor((iTime-iTimeDelta)*60.0) != floor((iTime)*60.0)) {\n        if(boundary) {\n            \n\t\t   \tfloat hh = 0.2*amplitude0*oceanHeight(13.0*p_w);\n\n            float b = 2.0*h + hh +\n                      0.15*sin(5.0*h + 7.0*p_w.x) +\n                      0.1*sin(7.0*v.w);\n            \n        \tv.y = b;\n        \tv.x = b;\n            v.z = 0.0;\n            v.w += max(1.0/60.0, iTimeDelta);\n\t    }\n        else {\n            float c = 0.3;\n\n\n\n            vec2 uv_p = (fragCoord+vec2(1))/iResolution.xy;\n            vec2 uv_m = (fragCoord-vec2(1))/iResolution.xy;\n\n            vec2 d11 = texture(iChannel1, uv).rg;\n\n            vec2 d01 = texture(iChannel1, vec2(uv_m.x, uv.y)).rg;\n            vec2 d21 = texture(iChannel1, vec2(uv_p.x, uv.y)).rg;\n\n            vec2 d10 = texture(iChannel1, vec2(uv.x, uv_m.y)).rg;\n            vec2 d12 = texture(iChannel1, vec2(uv.x, uv_p.y)).rg;\n\n            float um_00 = d11.g;\n            float u_00 = d11.r;\n            float u_m0 = d01.r;\n            float u_p0 = d21.r;\n            float u_0m = d10.r;\n            float u_0p = d12.r;\n\n            float un_00 = 2.0*u_00 - um_00\n                        + c*c*( u_m0 - 2.0*u_00 + u_p0)\n                        + c*c*( u_0m - 2.0*u_00 + u_0p);\n\n            // dampening\n            float d = 0.01;\n            un_00 = (1.0-d)*un_00 + (d/4.0)*(d01.x+d21.x+d10.x+d12.x);\n\n            vec2 m = abs(2.0*uv-vec2(1.0));\n            un_00 = mix(un_00, h, fade);\n            \n            float s = 0.25*iResolution.y/MIN_WINDOW_HEIGHTf;\n\n            v = vec4(un_00, u_00, s*(d21.x-d01.x), s*(d12.x-d10.x) );\n        }\n    }\n    \n    \n    fragColor = v;\n}","name":"Buffer B","description":"","type":"buffer"}]}