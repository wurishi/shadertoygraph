{"ver":"0.1","info":{"id":"4s33WB","date":"1451934422","viewed":1872,"name":"ShaderPaint","username":"kig","description":"Tiny drawing program using multipass. (Update: separate UI state from drawing layers, stamping brushes)","likes":27,"published":1,"flags":48,"usePreview":0,"tags":["2d","drawing","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Set Buf C iChannel1 to the brush texture you'd like to use.\n\n// Space toggles controls on/off.\n\n// Clear to white with c, fill to color with f, toggle color picking mode with i\n\n// In-stroke blend with soft brushes looks bad. Dunno what would be the right way.\n\n\nvec4 layerBlend( vec4 src, vec4 dst )\n{\n    return vec4(\n        src.rgb * src.a + dst.rgb * (1.0-src.a),\n        src.a + (1.0-src.a)*dst.a\n   \t);\n}\n\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nbool drawControls(vec4 brushSettings, vec4 currentColor, out vec4 fragColor, in vec2 fragCoord) {\n    float radius = 1.0 + pow(brushSettings.x, 2.0) * 100.0;\n    float hardness = brushSettings.y;\n    float opacity = 1.0-brushSettings.z;\n\n    if (fragCoord.x < 100.0 && fragCoord.y < 120.0 && fragCoord.y > 100.0) {\n        vec3 hsv = vec3(fragCoord.x/100.0, 1.0, 1.0);\n        fragColor = vec4(hsv2rgb(hsv), 1.0);\n        if (length(hsv.x - currentColor.x) < 2.0/200.0) {\n            fragColor = vec4(0.0);\n        }\n        return true;\n    }\n    if (fragCoord.x < 100.0 && fragCoord.y < 100.0) {\n        vec3 hsv = vec3(currentColor.x, fragCoord.x/100.0, fragCoord.y/100.0);\n        fragColor = vec4(hsv2rgb(hsv), 1.0);\n        if (abs(length(hsv.yz - currentColor.yz) - 0.03) < 1.0/200.0) {\n            fragColor = vec4(1.0);\n        }\n        return true;\n    }\n    if (fragCoord.x < 150.0 && fragCoord.y < 20.0) {\n        fragColor = vec4(hsv2rgb(currentColor.xyz), 1.0);\n        return true;\n    }\n    if (fragCoord.x < 300.0 && fragCoord.y < 20.0) {\n        float v = (fragCoord.x - 200.0) / 100.0;\n        float c = v < fragCoord.y / 20.0 ? 1.0 : 0.0;\n        fragColor = vec4(c,c,c, 1.0);\n        if (abs(brushSettings.x - v) < 0.01) {\n            fragColor.rgb = vec3(1.0, 0.0, 0.0);\n        }\n        return true;\n    }\n    if (fragCoord.x < 340.0 && fragCoord.y < 20.0) {\n        float v = (fragCoord.x - 300.0) / 40.0;\n        float c = v < fragCoord.y / 20.0 ? 1.0 : 0.0;\n        fragColor = vec4(c,c,c, 1.0);\n        if (abs(brushSettings.y - v) < 0.02) {\n            fragColor.rgb = vec3(1.0, 0.0, 0.0);\n        }\n        return true;\n    }\n    if (fragCoord.x < 380.0 && fragCoord.y < 20.0) {\n        float v = (fragCoord.x - 340.0) / 40.0;\n        float c = v < fragCoord.y / 20.0 ? 1.0 : 0.0;\n        fragColor = vec4(c,c,c, 1.0);\n        fragColor.rgb = vec3((1.0-v) * c + 1.0 * v);\n        if (abs(brushSettings.z - v) < 0.02) {\n            fragColor.rgb = vec3(1.0, 0.0, 0.0);\n        }\n        return true;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec4 brushSettings = texture(iChannel0, vec2(3.5/iResolution.x, 0.0));\n    bool showControls = brushSettings.w < 1.0;\n    vec4 currentColor = texture(iChannel0, vec2(2.5/iResolution.x, 0.0));\n\n    if (showControls && drawControls(brushSettings, currentColor, fragColor, fragCoord)) {\n        return;\n    }\n\n\n    vec4 stroke = texture(iChannel2,fragCoord / iResolution.xy);\n    vec4 layer = texture(iChannel1,fragCoord / iResolution.xy);\n    if (iMouse.z > 0.0) {\n\t\tfragColor = layerBlend(stroke, layer);\n    } else {\n        fragColor = layer;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// UI state layer\n\n// Maintains the UI state variables.\n\n#define COLOR_PICK_TOGGLE (kbToggle(73))\n#define CLEAR_PRESSED (kb(67))\n#define FILL_PRESSED (kb(70))\n#define CONTROLS_TOGGLE (!kbToggle(32))\n\nconst vec2 DataBlock = vec2(6.0, 1.0);\n\nconst vec2 BrushStrokePoints = vec2(5.0, 0.0);\nconst vec2 BrushStrokeStatus = vec2(4.0, 0.0);\nconst vec2 BrushSettings = vec2(3.0, 0.0);\nconst vec2 CurrentColor = vec2(2.0, 0.0);\nconst vec2 StrokeDerivative = vec2(1.0, 0.0);\nconst vec2 LastMouse = vec2(0.0, 0.0);\n\nconst float BrushStrokeActive = 1.0;\nconst float BrushStrokeEnded = 2.0;\n\nvec4 read(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nbool inDataBlock(vec2 fragCoord) { return fragCoord.x < DataBlock.x && fragCoord.y < DataBlock.y; }\n\nbool kb(int key) { return texture(iChannel2, vec2((float(key)+0.5)/256.0, 0.5/3.0)).x > 0.0; }\nbool kbToggle(int key) { return texture(iChannel2, vec2((float(key)+0.5)/256.0, 2.5/3.0)).x > 0.0; }\n\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = floor(fragCoord);\n    if (!inDataBlock(fragCoord)) {\n        discard;\n    }\n\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n\n    vec4 brushSettings = read(BrushSettings);\n    float radius = 1.0 + pow(brushSettings.x, 2.0) * 100.0;\n    float hardness = brushSettings.y;\n    float opacity = 1.0-brushSettings.z;\n\n    bool showControls = CONTROLS_TOGGLE;\n    \n    vec4 currentColorHSV = read(CurrentColor);\n    vec4 currentColor;\n    currentColor.rgb = hsv2rgb(currentColorHSV.rgb);\n    currentColor.a = opacity;\n\n\n    // Update program state.\n\n    if (fragCoord == LastMouse) {\n        fragColor.rgb = iMouse.xyz;\n\n    } else if (fragCoord == CurrentColor) {\n\n        // pick\n        if (COLOR_PICK_TOGGLE) {\n            vec3 rgb = texture(iChannel3, iMouse.xy/iResolution.xy).rgb;\n            fragColor = vec4(rgb2hsv(rgb), currentColorHSV.a);\n\n        } else if (showControls && iMouse.x < 100.0 && iMouse.y < 120.0 && iMouse.y > 100.0 && iMouse.z > 0.0) {\n            currentColorHSV.x = iMouse.x / 100.0;                \n            fragColor = currentColorHSV;\n\n        } else if (showControls && iMouse.x < 100.0 && iMouse.y < 100.0 && iMouse.z > 0.0) {\n            currentColorHSV.yz = iMouse.xy / 100.0;                \n            fragColor = currentColorHSV;\n\n        }\n\n    } else if (fragCoord == BrushSettings) {\n\n        fragColor.w = float(!showControls);\n        if (showControls && iMouse.x < 300.0 && iMouse.x > 200.0 && iMouse.y < 20.0 && iMouse.z > 0.0) {\n            fragColor.x = (iMouse.x-200.0)/100.0;\n        } else if (showControls && iMouse.x < 340.0 && iMouse.x > 300.0 && iMouse.y < 20.0 && iMouse.z > 0.0) {\n            fragColor.y = (iMouse.x-300.0) / 40.0;\n        } else if (showControls && iMouse.x < 380.0 && iMouse.x > 340.0 && iMouse.y < 20.0 && iMouse.z > 0.0) {\n            fragColor.z = (iMouse.x-340.0) / 40.0;\n        }\n    } else if (fragCoord == BrushStrokeStatus) {\n\n\n        // Deal with keyboard draw controls.\n        fragColor.yz = vec2(0.0);\n\n        // clear\n        if (CLEAR_PRESSED) {\n            fragColor.y = 1.0;\n            return;\n\n            // fill\n        }\n        if (FILL_PRESSED) {\n            fragColor.z = 1.0;\n            return;\n        }\n\n        fragColor.x = iMouse.z > 0.0 ? fragColor.x : BrushStrokeEnded;\n\n        // Ok, let's draw!\n        vec4 lastMouse = read(LastMouse);\n\n        bool mouseOnControls = showControls && (\n            (iMouse.x < 100.0 && iMouse.y < 120.0)\n            || (iMouse.x < 380.0 && iMouse.y < 20.0)\n        );\n        bool moved = !(lastMouse.xy == iMouse.xy);\n\n        if (lastMouse.z <= 1.0) {\n            lastMouse.xy = iMouse.xy;\n            moved = true;\n        }\n        if (moved && iMouse.z > 0.0 && !mouseOnControls) {\n            fragColor.x = BrushStrokeActive;\n        }\n\n\n    } else if (fragCoord == BrushStrokePoints) {\n        vec4 lastMouse = read(LastMouse);\n        \n        if (lastMouse.z <= 1.0) fragColor.zw = iMouse.xy;\n\n        vec2 strokeDirection = iMouse.xy - fragColor.zw;\n        float strokeLength = length(strokeDirection);\n        float stampSeparation = radius * 0.5;\n        float stampCount = floor(strokeLength / stampSeparation);\n        vec2 lastStamp = fragColor.zw + normalize(strokeDirection) * stampCount * stampSeparation;\n\n        if (stampCount == 0.0) lastStamp = fragColor.zw;\n\n        fragColor.xy = fragColor.zw;\n        fragColor.zw = lastStamp;\n    }\n\n    // color picking mode\n    // if (COLOR_PICK_TOGGLE) {\n    //    return;\n    //}\n\n\n    \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Draw layer - used to hold the finished brushstrokes.\n\n// When a brushstroke is finished, composites the stroke layer\n// on top of the current draw layer.\n\nvec4 layerBlend( vec4 src, vec4 dst )\n{\n    vec4 c = vec4(\n        src.rgb * src.a + dst.rgb * dst.a * (1.0-src.a),\n        src.a + (1.0-src.a)*dst.a\n   \t);\n    c.rgb /= c.a;\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iTime <= 0.1) {\n        fragColor = vec4(1.0);\n        return;\n    }\n    \n    vec4 stroke = texture(iChannel2, fragCoord / iResolution.xy);\n    vec4 layer = texture(iChannel1, fragCoord / iResolution.xy);\n    if (iMouse.z >= 0.0) {\n        fragColor = layer;\n    } else {\n        fragColor = layerBlend(stroke, layer);\n    }\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Stroke layer - the current brush stroke is drawn here.\n\n// When a brush stroke is finished, clears the layer.\n\nconst vec2 BrushStrokePoints = vec2(5.0, 0.0);\nconst vec2 BrushStrokeStatus = vec2(4.0, 0.0);\nconst vec2 BrushSettings = vec2(3.0, 0.0);\nconst vec2 CurrentColor = vec2(2.0, 0.0);\nconst vec2 StrokeDerivative = vec2(1.0, 0.0);\nconst vec2 LastMouse = vec2(0.0, 0.0);\n\nconst float BrushStrokeActive = 1.0;\nconst float BrushStrokeEnded = 2.0;\n\nvec4 read(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid strokeBlend(\n    vec4 src,\n    float srcA,\n    vec4 dst,\n    out vec4 color\n)\n{\n    color.a = src.a + (1.0-src.a)*dst.a;\n    color.rgb = src.rgb*src.a + dst.rgb*dst.a*(1.0-src.a);\n    color.rgb /= color.a;\n\n    if (color.a > srcA) {\n\t    color.a = max(dst.a, srcA);\n    }\n}\n\nvoid strokeBlendUniColor(vec4 src, float srcA, vec4 dst, out vec4 color)\n{\n    color.rgb = src.rgb;\n    color.a = dst.a + (1.0-dst.a)*src.a; // This can be done either way, I like adding to dst.\n    if (color.a > srcA) {\n\t    color.a = max(dst.a, srcA);\n    }\n}\n\nfloat lineSegDistance(vec2 a, vec2 b, vec2 c) {\n    vec2 ab = a-b;\n    vec2 ac = a-c;\n    \n    if (length(ab) == 0.0) {\n        return length(ac);\n    }\n    \n    float dist = abs((ab.x * ac.y - ab.y * ac.x) / length(ab));\n    \n    if (dot(ab, ac) < 0.0) {\n        return length(ac);\n    } else if (dot(b-a, b-c) < 0.0) {\n        return length(b-c);\n    }\n    \n    return dist;\n}\n\n/*\n// Quadratic bezier SDF from http://glslsandbox.com/e#5007.0\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\nvec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2)\n{\n\tfloat a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1);\n\tfloat f=b*d-a*a;\n\tvec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n\tvec2 gf=2.0*(b*d21+d*d10+a*d20);\n\tgf=vec2(gf.y,-gf.x);\n\tvec2 pp=-f*gf/dot(gf,gf);\n\tvec2 d0p=b0-pp;\n\tfloat ap=det(d0p,d20), bp=2.0*det(d10,d0p);\n\tfloat t=clamp((ap+bp)/(2.0*a+b+d), 0.0,1.0);\n\treturn mix(mix(b0,b1,t),mix(b1,b2,t),t);\n}\n\nfloat quadraticStrokeDistance(vec2 p0, vec2 p1, vec2 velocity, vec2 q) {\n    vec2 pV = p0 + length(p1-p0) * 0.5 * velocity;\n    return min(min(lineSegDistance(p0, p1, q), lineSegDistance(p0, pV, q)), lineSegDistance(pV, p1, q));\n\tif (length(p0-p1) < 2.0) {\n\t\treturn lineSegDistance(p0, p1, q);\n    }\n    return length(get_distance_vector(p0-q, pV-q, p1-q));\n}\n\nvec2 calculateStrokeDerivative() {\n    vec3 lastMouse = read(LastMouse).xyz;\n    vec2 lastDerivative = lastMouse.z > 0.0 ? read(StrokeDerivative).xy : normalize(iMouse.xy - lastMouse.xy);\n    return normalize(iMouse.xy - (lastMouse.xy + lastDerivative * 0.5 * length(iMouse.xy - lastMouse.xy)));\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = texture(iChannel2, fragCoord/iResolution.xy);\n\n    vec4 brushStrokeStatus = read(BrushStrokeStatus);\n    bool brushStrokeActive = (brushStrokeStatus.x == BrushStrokeActive);\n    bool brushStrokeEnded = (brushStrokeStatus.x == BrushStrokeEnded);\n    \n    vec4 currentColorHSV = read(CurrentColor);\n    vec4 currentColor;\n    currentColor.rgb = hsv2rgb(currentColorHSV.rgb);\n\n    // Deal with keyboard draw controls.\n    \n    // clear\n    if (brushStrokeStatus.y > 0.0) {\n        fragColor = vec4(1.0);\n        return;\n\n    // fill\n    }\n    if (brushStrokeStatus.z > 0.0) {\n        fragColor = vec4(currentColor.rgb, 1.0);\n        return;\n    }\n\n    if (brushStrokeEnded) {\n        fragColor = vec4(0.0);\n\n    } else if (brushStrokeActive) {\n\n\t    vec4 brushSettings = read(BrushSettings);\n        float radius = 1.0 + pow(brushSettings.x, 2.0) * 100.0;\n        float hardness = brushSettings.y;\n        float opacity = (1.0-brushSettings.z);// * (0.75+0.25*sin(3.0*iTime));\n        \n        currentColor.a = opacity;\n        \n        vec4 points = read(BrushStrokePoints);\n        vec2 lastPoint = points.xy;\n        vec2 currentPoint = points.zw;\n\n        // float d = quadraticStrokeDistance(lastPoint.xy, currentPoint.xy, calculateStrokeDerivative(), fragCoord) / radius;\n        // float d = lineSegDistance(lastPoint.xy, currentPoint.xy, fragCoord) / radius;\n        \n        /*\n        if (length(fragCoord - currentPoint) < 2.0) {\n            fragColor = vec4(1.0, 0.0, 0.5 + 0.5 * sin(4.0*iTime), 1.0);\n            return;\n        }\n        if (length(fragCoord - lastPoint) < 2.0) {\n            fragColor = vec4(0.0, 1.0, 0.5 + 0.5 * sin(4.0*iTime), 1.0);\n            return;\n        }\n        */\n        \n        vec2 strokeDirection = currentPoint - lastPoint;\n        float strokeLength = length(strokeDirection);\n        currentColor.a *= 1.0-pow(texture(iChannel1, 0.5+0.5*(fragCoord-currentPoint.xy)/radius).r, 1.0);\n        \n        if (strokeLength == 0.0 && fragColor.a == 0.0) {\n            float d = length(fragCoord - currentPoint) / radius;\n            if (d < 1.0) {\n                vec4 src = currentColor;\n                src.a *= smoothstep(1.0, hardness * max(0.1, 1.0 - (2.0 / (radius))), d);\n                vec4 dst = fragColor;\n                //src.rgb = vec3(0.5, 0.0, 0.0);\n                strokeBlendUniColor(src, opacity, dst, fragColor);\n            }\n        } else {\n            strokeDirection = normalize(strokeDirection);\n            float stampSeparation = radius * 0.5;\n            float stampCount = floor(strokeLength / stampSeparation + 0.5);\n\n            for (float i=1.0; i<200.0; i++) {\n                if (i > stampCount) {\n                    break;\n                }\n                float d = length(fragCoord - (lastPoint + strokeDirection*i*stampSeparation)) / radius;\n                if (d < 1.0) {\n                    vec4 src = currentColor;\n                    //src.rgb = vec3(0.0, 0.5, 0.0);\n                    src.a *= smoothstep(1.0, hardness * max(0.1, 1.0 - (2.0 / (radius))), d);\n                    vec4 dst = fragColor;\n                    strokeBlendUniColor(src, opacity, dst, fragColor);\n                }\n            }\n        }\n    }\n}","name":"Buf C","description":"","type":"buffer"}]}