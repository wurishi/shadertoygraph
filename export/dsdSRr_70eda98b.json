{"ver":"0.1","info":{"id":"dsdSRr","date":"1679339924","viewed":63,"name":"Rain Shader Test","username":"Shader_Noob2023","description":"Rain","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["rain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Just a practice from https://www.youtube.com/watch?v=52TMliAWocY&list=PLGmrMu-Iwbgs0H9va0DlopOGyYnlLmxhS&index=6\nvec2 Rain(vec2 uv, float t)\n{\n    \n    vec2 a = vec2(3., 1.);\n    vec2 st = uv*a;\n    \n    vec2 id = floor(st);\n    st.y = st.y + t*0.23;\n    \n    float noise = fract(sin(id.x*89.)*234.);\n    // float noiseX = sin(3*w)*pow(sin(w), 6.)*.45;\n    \n    st.y = st.y + noise; //randomiza os pontos\n    uv.y = uv.y + noise;\n    \n    \n    id = floor(st);\n    st = fract(st)-.5;\n    \n    t = t + fract(sin(id.x*32.+id.y*59.)*12.)*6.293; //randomiza os pontos\n    \n    float w = uv.y *10.;\n    \n    \n    float y = -sin(t+sin(t+sin(t)* 0.4))*0.41 ; //Define o movimento em Y\n    y = y - st.x*st.x*y*1.2*sin(t);\n    vec2 p1 = vec2(0., y); //Position\n    vec2 o1 = (st-p1)/a; //offset1\n    float d = length(o1);\n    \n    float m1 = smoothstep(0.09, .0, d); //define a primeira camada de pontos e o tamanho\n    \n    vec2 o2 = (fract(uv * a.x * vec2(1., 2.))-0.5) / vec2(1., 2.); //offset2\n    d = length(o2);\n    \n    float m2 = smoothstep(0.32*(.5-st.y), .0, d) //define a segunda camada de pontos e o tamanho\n    *smoothstep(-.1, .1, st.y-p1.y); //define a máscara para a trajetória do ponto\n    \n    /* if(st.x>.45 || st.y>.49){ //desenha linhas hozintais e verticais (just debbuging)\n        m1 =1.;\n    }  */ \n    \n    \n    return vec2(m1*o1*15.+m2*o2*10.-m1+m2*cos(-m1+m2));\n    //return vec2(m1+m2);\n    \n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float velocity = 2.; // define a velocidade\n    float t = iTime*velocity; //define a variável t como iTime e multiplica pelos segundos (trocar depois no Spark)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n   vec2 uvRain = vec2(uv.x*1.5, uv.y);\n    \n    float m1 = 1.0;\n    float m2 = 1.0;\n    vec2 RainDistort = Rain(uvRain*5.0, t)*.3;\n    RainDistort = RainDistort + Rain(uvRain *4.,t)*.4;\n   \n    vec4 color = texture(iChannel0, uv + RainDistort);\n    // vec3 color = vec3(RainDistort*2., 0.);\n    \n\t//vec3 color = vec3 (RainDistort, 0.);\n    // vec3 color = vec3 (RainDistort, 1.); \n    //fragColor = vec4 (color, 1.);\n    fragColor = color.rgba;\n}","name":"Image","description":"","type":"image"}]}