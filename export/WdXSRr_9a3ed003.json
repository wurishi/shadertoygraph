{"ver":"0.1","info":{"id":"WdXSRr","date":"1550399306","viewed":1709,"name":"ConwayCam","username":"Blokatt","description":"Wanted to see if I could use a live feed from my webcam to create cells in GoL.\nA single edge detection matrix wasn't quite cutting it, so I had to upgrade to Sobel, which seems to work well.\nNeeds good light and contrast to work.","likes":20,"published":3,"flags":34,"usePreview":0,"tags":["sobel","webcam","gameoflife","convolutionkernel","celluarautomata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    ConwayCam by @blokatt\n    17/02/19\n\n\tWEBCAM REQUIRED!\n\tFull resolution can be enabled in the 'Common' tab.\n\n\t○○○○○\n\t○○•○○ \n\t○○○•○\n\t○•••○\n\t○○○○○\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv *= RESOLUTION;\n\tfragColor = texture(iChannel0, uv + .5);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define RESOLUTION 0.5\n#define SOBEL_THICKNESS 0.75\n\nfloat luma(vec3 c){\n\treturn 0.2126 * c.r + 0.7152 * c.g + 0.0722 * c.b;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Cellular automata\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;   \n    \n    float alive = (round(texture(iChannel0, uv).r));     \n    vec2 derivative = vec2(dFdx(uv.x), dFdy(uv.y));    \n    vec4 pixel = vec4(derivative.x, derivative.y, 0., -derivative.y);\n    \n    float neighbours = round(\n        texture(iChannel0, uv - pixel.xz).r +\n        texture(iChannel0, uv - pixel.xy).r +\n        texture(iChannel0, uv - pixel.zy).r +\n        texture(iChannel0, uv + pixel.xw).r +\n        texture(iChannel0, uv + pixel.xz).r +\n        texture(iChannel0, uv + pixel.xy).r +\n        texture(iChannel0, uv + pixel.zy).r +       \n        texture(iChannel0, uv - pixel.xw).r\n    );    \n    \n    alive = min(1., float(!bool(alive) && (abs(3. - neighbours) < .001)) + (alive * float(neighbours >= 2. && neighbours <= 3.)));   \n    fragColor = vec4(vec3(alive), 1.0); \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Blur + image source\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy - (1. - RESOLUTION) / 2.) * (1. / RESOLUTION);\n    vec2 derivative = vec2(dFdx(uv.x), dFdy(uv.y));    \n    vec4 pixel = vec4(derivative.x, derivative.y, 0., -derivative.y);\n    \n\tfragColor = (\n        texture(iChannel0, uv - pixel.xz) * 2. +\n        texture(iChannel0, uv - pixel.xy) * 1.  +\n        texture(iChannel0, uv - pixel.zy) * 2. +\n        texture(iChannel0, uv + pixel.xw) * 1.  +\n        texture(iChannel0, uv + pixel.xz) * 2. +\n        texture(iChannel0, uv + pixel.xy) * 1.  +\n        texture(iChannel0, uv + pixel.zy) * 2. +       \n        texture(iChannel0, uv - pixel.xw) * 1.  +\n        texture(iChannel0, uv) * 4.) /  16.;     \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Sobel\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;       \n    vec2 derivative = vec2(dFdx(uv.x), dFdy(uv.y)) * SOBEL_THICKNESS;    \n    vec4 pixel = vec4(derivative.x, derivative.y, 0., -derivative.y);\n    \n    vec4 sumVertical =\n        texture(iChannel1, uv - pixel.xz) * -2. +\n        texture(iChannel1, uv - pixel.xy) * -1.  +\n        texture(iChannel1, uv - pixel.zy) * 0. +\n        texture(iChannel1, uv + pixel.xw) * 1.  +\n        texture(iChannel1, uv + pixel.xz) * 2. +\n        texture(iChannel1, uv + pixel.xy) * 1.  +\n        texture(iChannel1, uv + pixel.zy) * 0. +       \n        texture(iChannel1, uv - pixel.xw) * -1.  +\n        texture(iChannel1, uv) * 0.;\n    \n    vec4 sumHorizontal =\n        texture(iChannel1, uv - pixel.xz) * 0. +\n        texture(iChannel1, uv - pixel.xy) * -1.  +\n        texture(iChannel1, uv - pixel.zy) * -2. +\n        texture(iChannel1, uv + pixel.xw) * -1.  +\n        texture(iChannel1, uv + pixel.xz) * 0. +\n        texture(iChannel1, uv + pixel.xy) * 1.  +\n        texture(iChannel1, uv + pixel.zy) * 2. +       \n        texture(iChannel1, uv - pixel.xw) * 1.  +\n        texture(iChannel1, uv) * 0.;     \n              \n   \tfragColor = texture(iChannel0, uv) + step(.28, luma(sqrt(sumVertical * sumVertical + sumHorizontal * sumHorizontal).rgb));    \n}","name":"Buffer B","description":"","type":"buffer"}]}