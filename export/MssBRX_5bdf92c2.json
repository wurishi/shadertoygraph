{"ver":"0.1","info":{"id":"MssBRX","date":"1497358933","viewed":920,"name":"feedback gasket","username":"macbooktall","description":"change line 13 val to ~1.75 if you want to better visualize the gasket.\nrendered as a gif: http://i.imgur.com/l4vjgiL.gifv","likes":25,"published":3,"flags":32,"usePreview":0,"tags":["apollonian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 tex = texture(iChannel0, uv);\n    fragColor = 1.-min(vec4(.795), pow(tex, vec4(2.75)));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAXDIST 150.\n#define GIFLENGTH 3.\n\nstruct Ray {\n\tvec3 ro;\n    vec3 rd;\n};\n    \n// Apollonian gasket based on iq's https://www.shadertoy.com/view/4ds3zn\n    \nfloat gasket( vec3 p)\n{\n    const float radius = 2.075;\n\tfloat scale = 1.0;\n\n\tvec4 orb = vec4(1.0); \n\t\n\tfor( int i=0; i<8;i++ )\n\t{\n\t\tp = mod(p-1.,2.)-1.;\n\n\t\tfloat r2 = dot(p,p);\n\t\t\n    \tfloat k = radius/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\treturn 0.25*abs(length(p))/scale;\n}\n\nvec2 map(vec3 pos) {\n\n    return vec2(gasket(pos), 0.);\n}\n\nvec2 march(Ray ray) \n{\n    const int steps = 30;\n    const float prec = 0.006;\n    vec2 res = vec2(0.);\n    \n    for (int i = 0; i < steps; i++) \n    {        \n        vec2 s = map(ray.ro + ray.rd * res.x);\n        \n        if (res.x > MAXDIST || s.x < prec) \n        {\n        \tbreak;    \n        }\n        \n        res.x += s.x;\n        res.y = s.y;\n        \n    }\n   \n    return res;\n}\n\nvec3 calcNormal(vec3 pos) \n{\n\tconst vec3 eps = vec3(0.005, 0.0, 0.0);\n                          \n    return normalize(\n        vec3(map(pos + eps).x - map(pos - eps).x,\n             map(pos + eps.yxz).x - map(pos - eps.yxz).x,\n             map(pos + eps.yzx).x - map(pos - eps.yzx).x ) \n    );\n}\n\nvec3 render(Ray ray) \n{\n    vec3 col = vec3(0., 0., 0.);\n\tvec2 res = march(ray);\n    \n    if (res.x > MAXDIST) \n    {\n        return col;\n   \t}\n    \n    vec3 normal = calcNormal(ray.ro + ray.rd * res.x);\n    \n  \tcol = vec3(1.+dot(ray.rd,normal));\n    \n    col = mix(col, vec3(0.), clamp(res.x/1.725, 0., 1.));\n   \treturn col;\n}\n\nmat3 camera(in vec3 ro, in vec3 rd, float rot) \n{\n\tvec3 forward = normalize(rd - ro);\n    vec3 worldUp = vec3(sin(rot), cos(rot), 0.0);\n    vec3 x = normalize(cross(forward, worldUp));\n    vec3 y = normalize(cross(x, forward));\n    return mat3(x, y, forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 camPos = vec3(1. + sin(iTime*4.)*0.05, 0.5, -.95+ cos(iTime*4.)*0.05);\n    vec3 camDir = vec3(-.1, -0.1, .0);\n    mat3 cam = camera(camPos, camDir, sin(iTime*4.)*0.05);\n    vec3 rayDir = cam * normalize( vec3(uv, 1. + cos(iTime*4.)*0.0025) );\n    \n    Ray ray;\n    ray.ro = camPos;\n    ray.rd = rayDir;\n    \n    vec3 col = render(ray);\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// This buffer is the feedback loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915;\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    \n    // sample the last texture with uv's slightly scaled up\n    vec3 overlay = texture(iChannel1,offs).rgb;\n\n        // Additively blend the colors together\n    vec4 col = vec4(base + overlay*0.8975, 1.0);\n    \n    fragColor = col;\n}","name":"Buf B","description":"","type":"buffer"}]}