{"ver":"0.1","info":{"id":"McjfWd","date":"1725673419","viewed":27,"name":"OW_Shader Assignment 1b","username":"owalrath1008","description":"Using code Dr. Landon provided","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Noise from \"GLSL Noise Algorithms\", by patriciogonzalezvivo on GitHub\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//shadertoy at https://www.shadertoy.com/view/clKGDc\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noiseFront(vec3 p, float scale){\n    p *= scale; // Tweak for allowing scale of noise\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//https://iquilezles.org/articles/distfunctions/\n/*float opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}*/\n\n\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\n//background is https://www.shadertoy.com/view/dsVfWy\nconst float GRID_SIZE = 12.;\n\nconst vec3 COLOR_ACCENT_1 = vec3(0, 0, 0);\nconst vec3 COLOR_ACCENT_2 = vec3(.01, .2, .37);\nconst vec3 COLOR_DARK = vec3(.11, .08, .5);\n\nfloat hash2(vec2 p) {\n\treturn texture(iChannel0, p).x;\n}\n\nvec3 lerpColor(vec3 from, vec3 to, float progress) {\n    vec3 range = to - from;\n    return from + range * progress;\n}\n\nvec4 make_grid(vec2 uv) {\n    vec2 coord = floor(uv * GRID_SIZE);\n    vec2 cell_uv = fract(uv * GRID_SIZE);\n    return vec4(coord, cell_uv);\n}\n\n\nmat3 rotation3dX(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(\n    1.0, 0.0, 0.0,\n    0.0, c, s,\n    0.0, -s, c\n  );\n}\n\nmat3 rotation3dY(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(\n    c, 0.0, -s,\n    0.0, 1.0, 0.0,\n    s, 0.0, c\n  );\n}\n\nmat3 rotation3dZ(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(\n    c,    s, 0.0,\n    -s,     c, 0.0,\n    0.0, 0.0, 1.0\n  );\n}\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sdOctahedron( vec3 p, float s )\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized y pixel coordinates (from 0 to 1)    \n    // apply same scale to x pixels\n    vec2 uv = fragCoord/iResolution.yy;\n    vec2 Mouseuv = iMouse.xy/iResolution.yy;\n    \n    //subtracting 0.5 moves origin to middle of window\n    //however x is at a different scale, so we need to scale\n    //based on aspect ratio\n    uv.x = uv.x - 0.5*(iResolution.x/iResolution.y);\n    uv.y = uv.y - 0.5;\n    \n    Mouseuv.x = Mouseuv.x - 0.5*(iResolution.x/iResolution.y);\n    Mouseuv.y = Mouseuv.y - 0.5;\n\n    //set background color\n    float aa = 8. / iResolution.y;\n    vec4 grid = make_grid(uv - vec2(0., iTime * .1));\n    \n    // layer moving noise in four directions\n    float noise = 0.;\n    noise += texture(iChannel0, (uv - 13.) / 16. + iTime * .007).x;\n    noise += texture(iChannel0, (uv + 167.) / 16. - iTime * .01).x;\n    noise += texture(iChannel0, (uv + 31.) / 16. * vec2(-1., 1.) - iTime * .005).x;\n    noise += texture(iChannel0, (uv - 71.) / 16. * vec2(1., -1.) - iTime * .013).x;\n    noise /= 4.;\n    \n    float h = hash2(grid.xy / 100.);\n    vec2 st = grid.zw;\n    \n    // flip into quadrants\n    if (int(grid.x) % 2 == 0) {\n        st.x = 1. - st.x;\n    }\n    if (int(grid.y) % 2 == 0) {\n        st.x = 1. - st.x;\n    }\n    \n    // flip tile randomly\n    if (h > .5) {\n        st.x = 1. - st.x;\n    }\n    \n    // mirror over x = -y + 1\n    st = st.x + st.y < 1.\n        ? vec2(st.x, st.y)\n        : vec2(1. - st.y, 1. - st.x);\n    \n    // truchet distance\n    float d = h > .5 ? length(st) : 1. - length(st);\n    \n    float y = uv.y + .5;\n    // adjust the slope of the gradient so it isn't as overpowering\n    float y_fix = 1. - pow(1. - y, 2.);\n    float width = noise * .4 + .3;\n    vec3 col = lerpColor(\n        lerpColor(COLOR_DARK, COLOR_ACCENT_1, y),\n        lerpColor(COLOR_ACCENT_2, COLOR_DARK, y_fix),\n        smoothstep(width + aa, width - aa, d)\n    );\n    \n    vec3 srgb = pow(col, vec3(1. / 2.2));\n    //end of background generation\n   // vec3 col = vec3(noise(vec3(uv.x, uv.y, iTime), 100.0)*0.3);\n    \n    //distance along ray\n    float t = 0.0;\n    float tdx = 0.0;\n    float tdy = 0.0;\n    \n    //small distance to offset point\n    d = 0.0001f;\n    \n    mat3 rotY = rotation3dY(iTime);\n    \n    //position and size of the sdf sphere\n    vec3 spherePos = vec3(0.0,-0.2,10.0);\n    vec3 spherePos2 = vec3(0.0,0.05,10.0);\n    vec2 boxSize = vec2(0.1);\n    float sSize = 0.25;\n    \n    vec3 lightPos = vec3(Mouseuv, 0.0);\n    \n    \n    //starting point of ray and the direction it follows\n    vec3 pt = vec3(uv.x, uv.y, 0.0);\n    vec3 ptdx = vec3(uv.x+d, uv.y, 0.0);\n    vec3 ptdy = vec3(uv.x, uv.y+d, 0.0);\n    vec3 dir = normalize(vec3(0.0, 0.0, 1.0));\n     \n    //loop that allows us to keep moving along the ray \n    //until we hit the sphere or until we run out of \n    //loop iterations (and hit nothing)\n    for( int i = 0; i < 25; i++){\n    \n        //calc positions from view rays\n        vec3 pos = pt + dir * t;\n        vec3 posdx = ptdx + dir * tdx;\n        vec3 posdy = ptdy + dir * tdy;\n            \n        \n        //get distance from position to sphere\n        //subtract spherePos from pos allows us to \"move\"\n        // the position of the sphere in the world\n        //otherwise it is stuck at the world origin\n        float dist = opUnion(sdHexPrism(rotY*(pos-spherePos), boxSize),sdOctahedron(rotY*(pos-spherePos2), sSize));\n        float distdx = opUnion(sdHexPrism(rotY*(pos-spherePos), boxSize),sdOctahedron(rotY*(pos-spherePos2), sSize));\n        float distdy = opUnion(sdHexPrism(rotY*(pos-spherePos), boxSize),sdOctahedron(rotY*(pos-spherePos2), sSize));\n              \n        if(dist < 0.000001 && \n           distdx < 0.000001 && \n           distdy < 0.000001){ //point on ray is close enough\n                        //we'll call this a \"hit\"\n                        \n            vec3 normal = cross(\n                     normalize(posdx - pos), \n                     normalize(pos - posdy));\n                     \n            normal = normalize(pos - spherePos);\n                     \n                   \n           col = vec3(0.8)*dot(normal, normalize(lightPos - pos));        \n            // col = normal;  \n            \n           col += texture(iChannel0, uv).rgb*0.4;\n                        \n            //col = vec3(1.0);  //lets color this fragment\n                                // a \"sphere color\"\n                             \n            break;  //stop checking\n            \n        }\n        //update distance along ray if haven't hit yet\n        t += dist;\n        tdx += distdx;\n        tdy += distdy;\n    }\n\n    // Output to screen\n    col += vec3(noiseFront(vec3(uv.x, uv.y, iTime), 100.0)*0.1);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}