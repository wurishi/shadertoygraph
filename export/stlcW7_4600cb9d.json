{"ver":"0.1","info":{"id":"stlcW7","date":"1648138030","viewed":187,"name":"Magma Crystal","username":"Hyeve","description":"I wanna make more complex scenes but I can never seem to make them work well.. so while I work away at doing that, I'm going to (hopefully) start posting lots of simple, but beautiful, shapes and crystals I come up with.\n\nHope you like them! c: ","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","transparency","glass","crystal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DTR 0.0174532\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec2 uv;\nvec3 cp,cn,cr,ro,rd,ss,oc,cc,gl,vb;\nvec4 fc;\nfloat tt,cd,sd,io,oa,td;\nint es=0,ec;\n \n//shapes:\nfloat bx(vec3 p,vec3 s){vec3 q=abs(p)-s;return min(max(q.x,max(q.y,q.z)),0.)+length(max(q,0.));}\n\n//crystal - domain repetition with a rotated lattice\nvec3 latticeA(vec3 p, int iter)\n{\n\tfor(int i = 0; i < iter; i++)\n\t{\n        p.xy *= rot(45.*DTR);\n\t\tp.xz *= rot(45.*DTR);\n\t\tp=abs(p)-1.;\n        \n        //this reverse-rotation to bring the cubes back is actually \"wrong\",\n        //swap these two lines for the \"proper\" symmetric lattice\n\t\tp.xy *= rot(-45.*DTR);\n\t\tp.xz *= rot(-45.*DTR);\n\t}\n\treturn p;\n}\n\n//scene\nfloat mp(vec3 p)\n{\n//now with mouse control\nif(iMouse.z>0.){\n    p.yz*=rot(2.0*(iMouse.y/iResolution.y-0.5));\n    p.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));\n}\n\tvec3 pp = p;\t\n\tp.xz*=rot(tt*0.2);\n    p = latticeA(p, 5);\n    sd=bx(p,vec3(1.)) - 0.03;\n    float osc = cos(tt * 2.)*0.5+0.5;\n\tsd = mix(sd, length(pp) - 1., min(pow(sin(tt*0.5)*0.5+0.5, 3.) + osc*0.1,1.));\t\n\tsd=abs(sd)-0.001;\n\tif(sd<0.001)\n\t{\n\t\toc=vec3(1.,0,0.25);\n\t\tio=1.2;\n\t\toa=0.8-length(pp*0.1);\n\t\tss=vec3(0.);\n\t\tvb=vec3(0.,2.5,2.5);\n\t\tec=2;\t\n\t}\n\treturn sd;\n}\n\n//raymarching and normals\nvoid tr(){vb.x=0.;cd=0.;for(float i=0.;i<512.;i++){mp(ro+rd*cd);cd+=sd;td+=sd;if(sd<0.0001||cd>128.)break;}}\nvoid nm(){mat3 k=mat3(cp,cp,cp)-mat3(.001);cn=normalize(mp(cp)-vec3(mp(k[0]),mp(k[1]),mp(k[2])));}\n\n//pixel colouring\nvoid px()\n{\n  cc=vec3(1.,0.45,0.)+length(pow(abs(rd+vec3(0,0.5,0)),vec3(3)))*0.3+gl;\n  if(cd>128.){oa=1.;return;}\n  vec3 l=vec3(0.4,0.7,0.8);\n  float df=clamp(length(cn*l),0.,1.);\n  vec3 fr=pow(1.-df,3.)*mix(cc,vec3(0.4),0.5);\n  float sp=(1.-length(cross(cr,cn*l)))*0.2;\n  float ao=min(mp(cp+cn*0.3)-0.3,0.3)*0.5;\n  cc=mix((oc*(df+fr+ss)+fr+sp+ao+gl),oc,vb.x);\n}\n\n//basic setup and transparency loop\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n  tt=mod(iTime, 260.);\n  uv=vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\n  uv-=0.5;uv/=vec2(iResolution.y/iResolution.x,1);\n  ro=vec3(0,0,-15);rd=normalize(vec3(uv,1));\n  \n  for(int i=0;i<20;i++)\n  {\n\ttr();cp=ro+rd*cd;\n    nm();ro=cp-cn*0.01;\n    cr=refract(rd,cn,i%2==0?1./io:io);\n    if(length(cr)==0.&&es<=0){cr=reflect(rd,cn);es=ec;}\n    if(max(es,0)%3==0&&cd<128.)rd=cr;es--;\n\tif(vb.x>0.&&i%2==1)oa=pow(clamp(cd/vb.y,0.,1.),vb.z);\n\tpx();fc=fc+vec4(cc*oa,oa)*(1.-fc.a);\t\n\tif((fc.a>=1.||cd>128.))break;\n  }\n  \n  fragColor = fc/fc.a;\n}","name":"Image","description":"","type":"image"}]}