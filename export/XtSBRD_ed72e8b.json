{"ver":"0.1","info":{"id":"XtSBRD","date":"1514714055","viewed":114,"name":"Bokeh prototype 1","username":"q0x","description":"Simple implementation of shutter based Bokeh filter.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["bokeh","convolution","shutter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// free as beer license\n// demoscene name: q0x\n// AI scene name: square(ofTwo)\n// robertw89@googlemail.com\n\n#define uint32_t uint\n\n\n// rule 30\nuint32_t ca_rule30(uint32_t v) {\n\tuint32_t left = (v << 31) | (v >> 1);\n\tuint32_t center = v;\n\tuint32_t right = (v >> 31) | (v << 1);\n\n\t// the patern 0 0 0 1    1 1 1 0  is symetric by the left byte\n\t// like       0 0 0 1\n\t//            1 1 1 0\n\t// this explains the first XOR\n\treturn ~left ^ (~center & ~right);\n}\n\n// samples a simplified model of a shutter blade\nbool sampleShutterBladeVertical(vec2 p, float width) {\n    return p.x < width && p.x > -width;\n}\n\n// samples the shutter of the virtual camera\nfloat sampleShutter(vec2 p) {\n    float trigMagic = 0.70710678118; // trigonometric magic value\n    \n    float cos45 = trigMagic;\n    float sin45 = trigMagic;\n    float cosn45 = trigMagic;\n    float sinn45 = -trigMagic;\n    \n    mat2 matRot45 = mat2(cos45, -sin45, sin45, cos45); // rotation matrix of positive 45 degree rotation\n    mat2 matRotN45 = mat2(cosn45, -sinn45, sinn45, cosn45); // rotation matrix of negative 45 degree rotation\n    \n    float shutterWidth = 0.7;\n    \n    return (\n        sampleShutterBladeVertical(p, shutterWidth) &&\n        sampleShutterBladeVertical(matRot45 * p, shutterWidth) &&\n        sampleShutterBladeVertical(matRotN45 * p, shutterWidth)\n    ) ? 1.0 : 0.0;\n}\n\nfloat sampleSrc(vec2 v) {\n    bool hit = (v.x*v.x + v.y*v.y) < 0.03;\n    return hit ? 1.0 : 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tuint32_t x = uint32_t(fragCoord.x);\n    uint32_t y = uint32_t(fragCoord.y);\n    \n    uint32_t seed = (x << 5) ^ (x << 9) ^ x ^ (y << 9) ^ (y << 4) ^ y + x + y + 133763u;\n    \n    uint32_t rnd = seed; // running random value\n    rnd = ca_rule30(rnd);\n    rnd = ca_rule30(rnd);\n    /*\n    rnd = ca_rule30(rnd);\n    rnd = ca_rule30(rnd);\n    rnd = ca_rule30(rnd);\n    rnd = ca_rule30(rnd);\n    rnd = ca_rule30(rnd);\n    rnd = ca_rule30(rnd);\n    rnd = ca_rule30(rnd);\n    rnd = ca_rule30(rnd);\n    rnd = ca_rule30(rnd);\n    \n    rnd = ca_rule30(rnd);\n    rnd = ca_rule30(rnd);\n    rnd = ca_rule30(rnd);\n    rnd = ca_rule30(rnd);\n    rnd = ca_rule30(rnd);\n    rnd = ca_rule30(rnd);\n    rnd = ca_rule30(rnd);\n    \n    rnd = ca_rule30(rnd);\n    */\n    \n    float shutterSize = 0.5; // size of the shutter for the sampled pixel/texel\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    \n    float integral = 0.0;\n    \n    int samples = 600;\n    \n    for(int iSample=0;iSample < samples; iSample++) {\n    \tvec2 sampleSrcP = vec2((uv.x - 0.5) * 2.0, (uv.y - 0.5) * 2.0);\n        \n        // [0.0;1.0] based offset of the shutter\n        vec2 shutterP0Based;\n        shutterP0Based.x = float(rnd & uint32_t(0x1f)) / float(0x1f);\n        shutterP0Based.y = float((rnd >> 5) & uint32_t(0x1f)) / float(0x1f);\n        \n        // [-1;1] based offset of the shutter\n        vec2 shutterP1Based;\n        shutterP1Based.x = shutterP0Based.x * 2.0 - 1.0;\n        shutterP1Based.y = shutterP0Based.y * 2.0 - 1.0;\n        \n        vec2 sampleSrcPShutterBasedDelta;\n        sampleSrcPShutterBasedDelta.x = shutterP1Based.x * 0.15;\n        sampleSrcPShutterBasedDelta.y = shutterP1Based.y * 0.15;\n        \n        integral += (sampleSrc(sampleSrcP + sampleSrcPShutterBasedDelta) *4.0 * sampleShutter(shutterP1Based));\n        \n    \trnd = ca_rule30(rnd);\n    }\n\n    integral /= float(samples);\n    \n\tfragColor = vec4(integral,integral,integral,1.0);\n    float sample_ = sampleShutter((vec2((uv.x - 0.5) * 2.0, (uv.y - 0.5) * 2.0)));\n    //fragColor = vec4(sample_,sample_,sample_,1.0);\n}\n","name":"Image","description":"","type":"image"}]}