{"ver":"0.1","info":{"id":"MclBDs","date":"1731166213","viewed":85,"name":"Singularit√© multicolore","username":"Docteur_Raton","description":"Physics-based! (Except the rainbow.)","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Photon\n{\n    vec3 position;\n    vec3 velocity;\n    float squareAngularMomentum;\n    vec3 previousPosition;\n    vec4 color;\n};\n\nconst float accretionDiskRadius = 5.;\nconst float pi = acos(-1.);\nvec3 s = vec3(0., 1., -1.);\nconst float two_pi = 2. * pi;\n\nfloat dot2(vec3 p)\n{\n    return dot(p, p);\n}\n\nmat2 rot(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c, -s, s, c);\n}\n\nvec3 generateRainbowPalette(float t)\n// Adapted from https://iquilezles.org/articles/palettes/\n{\n    vec3 a = vec3(0.780, 0.780, 0.780);\n    vec3 b = vec3(0.220, 0.220, 0.220);\n    vec3 c = vec3(1.000, 1.000, 1.000);\n    vec3 d = vec3(0.000, 0.333, 0.667);\n\n    return a + b * cos(two_pi * (c * t + d));\n}\n\nPhoton photonMove(Photon photon)\n// Reference: https://rantonels.github.io/starless/\n{\n    photon.previousPosition = photon.position;\n    float timeStep = .1;\n    photon.position += photon.velocity * timeStep;\n    vec3 acceleration = -1.5 * photon.squareAngularMomentum\n        / pow(dot2(photon.position), 2.5) * photon.position;\n    photon.velocity += acceleration * timeStep;\n    \n    return photon;\n}\n\nvec4 photonInteractWithEventHorizon(Photon photon)\n{\n    return length(photon.position) < 1. ? s.xxxy : s.xxxx;\n}\n\nbool isInAccretionDisk(vec3 position)\n{\n    const float height = .25;\n    bool horizontal = length(position.xz) <= accretionDiskRadius;\n    bool vertical = abs(position.y) <= .5 * height;\n    \n    return horizontal && vertical;\n}\n\nvec4 photonInteractWithAccretionDisk(Photon photon)\n{\n    if (isInAccretionDisk(photon.previousPosition))\n        return s.xxxx;\n    if (!isInAccretionDisk(photon.position))\n        return s.xxxx;\n    vec3 p = photon.position;\n    vec3 normal = s.xyx;\n    p -= dot(p, normal) / dot(photon.velocity, normal) * photon.velocity;\n    float angle = atan(p.z, p.x);\n    vec4 res = s.xxxx;\n    res.rgb = generateRainbowPalette(angle / two_pi);\n    float r = length(p.xz);\n    float th = atan(p.z, p.x);\n    th = th + .75 * r;\n    p.x = r * cos(th);\n    p.z = r * sin(th);\n    res.a = 2. * texture(iChannel1, .01 * p.xz).r;\n    res.a *= pow(1.2 - r / accretionDiskRadius, .75); \n    \n    return res;\n}\n\nvec4 blendAlpha(vec4 above, vec4 below)\n// Reference: https://en.wikipedia.org/wiki/Alpha_compositing\n{\n    vec4 res = s.xxxx;\n    res.a = above.a + below.a * (1. - above.a);\n    if (res.a == 0.)\n        return s.xxxx;\n    res.rgb = (above.a * above.rgb + below.a * (1. - above.a) * below.rgb) / res.a;\n    \n    return res;\n}\n\nvec4 photonUpdateColor(Photon photon)\n{\n    photon.color = blendAlpha(photon.color, photonInteractWithEventHorizon(photon));\n    photon.color = blendAlpha(photon.color, photonInteractWithAccretionDisk(photon));\n    \n    return photon.color;\n}\n\nvec3 transformCamera(vec3 p)\n{\n    //p.xz *= rot((2. * iMouse.x - iResolution.x) / iResolution.x);\n    //p.yz *= rot((2. * iMouse.y - iResolution.y) / iResolution.y);\n    p.xz *= rot(-.5 * iTime);\n    p.yz *= rot(0.1);\n    \n    return p;\n}\n\nvec4 march(vec2 uv)\n{\n    vec3 position = vec3(0., 3., 10.);\n    vec3 velocity = .5 * normalize(vec3(uv, -1.));\n    position = transformCamera(position);\n    velocity = transformCamera(velocity);\n    float squareAngularMomentum = dot2(cross(position, velocity));\n    Photon photon = Photon(position, velocity, squareAngularMomentum, position, s.xxxx);\n    for (float i = 0.; i < 500.; ++i)\n    {\n        photon = photonMove(photon);\n        photon.color = photonUpdateColor(photon);\n    }\n    vec4 background = texture(iChannel0, 5. * photon.velocity.xy);\n    \n    return blendAlpha(photon.color, background);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    fragColor = march(uv);\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 1.2));\n}\n","name":"Image","description":"","type":"image"}]}