{"ver":"0.1","info":{"id":"3tfSD7","date":"1570370347","viewed":1301,"name":"The Beach","username":"Maurogik","description":"* This might be a slow compile (20s) if your browser is using ANGLE, just hang in there ;) *\nI started with some simple water rendering, but I got carried away.\nFun story, this used to take 150 seconds to compile on windows/ANGLE.\n","likes":37,"published":1,"flags":104,"usePreview":1,"tags":["water","ocean","beach"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MtjXzR","filepath":"https://soundcloud.com/sleepmusiconthebeach/power-sleep-relaxing-piano","previewfilepath":"https://soundcloud.com/sleepmusiconthebeach/power-sleep-relaxing-piano","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec4 colour = texture(iChannel0, uv);\n    \n    //Smoothstep tonemapping, because why not !\n    colour = smoothstep(-0.13, 1.35, colour);\n\n    colour.rgb = safePow(colour.rgb, vec3(1.0/2.2));\n    fragColor = colour;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define NON_CONST_ZERO (min(iFrame,0)) \n#define NON_CONST_ZERO_U uint(min(iFrame,0)) \n\n#define PI 3.141592\n\nconst vec2 oz = vec2(1.0, 0.0);\n\nconst float kGoldenRatio = 1.618;\nconst float kGoldenRatioConjugate = 0.618;\n\nconst float kPI         = 3.14159265359;\nconst float kTwoPI      = 2.0 * kPI;\n\nconst float kWaterIoR = 1.33;\n\n#define TAU (kTwoPI)\n#define PHI (sqrt(5) * 0.5 + 0.5)\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nfloat kIsotropicScatteringPhase = (1.0 / (4.0 * kPI));\n\nfloat roughFresnel(float f0, float cosA, float roughness)\n{\n    // Schlick approximation\n    return f0 + (1.0 - f0) * (pow(1.0 - cosA, 5.0)) * (1.0 - roughness);\n}\n\nfloat fresnel(float f0, float cosA)\n{\n    return roughFresnel(f0, cosA, 0.0);\n}\n\nfloat linearstep(float start, float end, float x)\n{\n    float range = end - start;\n    return saturate((x - start) / range);\n}\n\nfloat henyeyGreensteinPhase_schlick(float cosA, float g)\n{\n    float k = 1.55*g - 0.55*g*g*g;\n    float f = 1.0 - k * cosA;\n\treturn (1.0 - k * k) / (4.0 * kPI * f*f);\n}\n\nfloat henyeyGreensteinPhase(float cosA, float g)\n{\n    return henyeyGreensteinPhase_schlick(cosA, g);\n\t/*float g2 = g*g;\n    return 1.0 / (4.0 * kPI) *\n        ((1.0 - g2)/pow(1.0 + g2 - 2.0*g*cosA, 1.5));*/\n}\n\nfloat safePow(float v, float p)\n{\n    return pow(max(0.00001, v), p);\n}\n\nvec3 safePow(vec3 v, vec3 p)\n{\n    return pow(max(0.00001*oz.xxx, v), p);\n}\n\n\n//////////////////////////////////////////////////////////////\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n// SDF functions from mercury : http://mercury.sexy/hg_sdf/ //\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n//////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat fInfiniteCylinder(vec3 p, float r)\n{\n    float d = length(p.xz) - r;\n    return d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c)\n{\n    return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius)\n{\n    return length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a)\n{\n    p = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size)\n{\n    float halfsize = size * 0.5;\n    float c        = floor((p + halfsize) / size);\n    p              = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size)\n{\n    vec2 c = floor((p + size * 0.5) / size);\n    p      = mod(p + size * 0.5, size) - size * 0.5;\n    return c;\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size)\n{\n    vec3 c = floor((p + size * 0.5) / size);\n    p      = mod(p + size * 0.5, size) - size * 0.5;\n    return c;\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r)\n{\n    vec2 u = max(vec2(r - a, r - b), vec2(0));\n    return max(r, min(a, b)) - length(u);\n}\n\n// Similar to fOpUnionRound, but more lipschitz-y at acute angles\n// (and less so at 90 degrees). Useful when fudging around too much\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r)\n{\n    float e = max(r - abs(a - b), 0.0);\n    return min(a, b) - e * e * 0.25 / r;\n}\n\n////////////////////////////////////////////////////\n//////////// Intersectors/SDFs from IQ /////////////\n////////////////////////////////////////////////////\n\n// sphere of size ra centered at point ce\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\n//This is where the magic happens...\n//\n\n\n// I wonder what that does... try it ?\n#define BIRDS_EYE_VIEW 0\n\n\n// Material Ids\nconst uint kSandMatId = 0u;\nconst uint kWaterMatId = 1u;\nconst uint kFoamMatId = 2u;\nconst uint kRockMatId = 3u;\nconst uint kBirdsMatId = 4u;\n\n// Part Ids\nconst uint kIslandPartId = 1u;\nconst uint kWaterPartId = 1u << 1u;\nconst uint kFoamPartId = 1u << 2u;\nconst uint kWaveFoamPartId = 1u << 3u;\nconst uint kRockPartId = 1u << 4u;\nconst uint kBirdsPartId = 1u << 5u;\n\n// Constants\nconst float kWaterFbmScale = 0.25 * 0.05;\nconst float kWaterFbmAmount = 0.075;\nconst float kMaxDist = 600.;\nconst float kDistanceEpsilon = 0.0005;\nconst float kStepEpsilon = 0.001;\n\nconst vec3 kIslandSphereCenterWS = vec3(-775.0, -10000.0, 0.0);\nconst float kIslandSphereRadius = 10030.0;\n\nconst float kTimeScale = 1.0f;\n#if BIRDS_EYE_VIEW\nconst float kWalkRotationTimeScale = 8.0f;\n#else\nconst float kWalkRotationTimeScale = 1.0f;\n#endif\n\nconst float kCameraPlaneDist = 2.0;\n\n\n// Globals (ugly but convenient)\n\nfloat s_flare = 0.0;\nvec3 s_eyePosWS = oz.yyy;\nfloat s_pixelSpacingAtUnitLengthWS = 0.0001;\nfloat s_time = 0.0;\n\n\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n/////////////////////// Distance functions //////////////////////////\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n\n\n//The camera doesn't actually move around the island\n//The world spins instead\n//This allows us to not have to worry about making the wave direction match the island\n//They always come from the +x direction (in non-rotated WS)\nvec3 computeWalkRotatedPosWS(vec3 posWS, float time)\n{\n    //The rock noise gets weird if we rotate too much, so reset after a while\n#if BIRDS_EYE_VIEW    \n    float walkTime = mod(time , 2.0*158.0) * kWalkRotationTimeScale; \n#else\n    float walkTime = mod(time , 4.0*158.0) * kWalkRotationTimeScale; \n#endif    \n    vec3 islandCenteredPosWS = posWS - kIslandSphereCenterWS;\n    pR(islandCenteredPosWS.xz, -walkTime * 0.001);\n    posWS = islandCenteredPosWS + kIslandSphereCenterWS;\n    \n    return posWS;\n}\n\n//Main wave animation :\n// - 1 cylinder rotating around in space\n// - 1 cylinder to carve the wave out of the first one\n// - lots of magic number tweaking\nfloat fWave(vec3 pos, float waveProgress, float waveStrength, \n            out float crashDist, out float crashX)\n{\n    float waveBreakProgress = linearstep(0.25, 1.0, waveProgress);\n    float animationTime = (waveProgress - 0.5) * 2.0 * PI;\n\n    const float waveRadius = 1.0;\n    vec3 mainCylinderPos = pos + oz.yxy * 0.5 * waveRadius;\n    vec3 carvedCylinderPos = pos;\n    \n    pR(mainCylinderPos.xy, animationTime);\n\n    mainCylinderPos -= oz.yxy * 0.5 * waveRadius;\n\n    float waveDist = fInfiniteCylinder((mainCylinderPos).xzy, waveRadius);\n    \n    float size = (1.0 - waveBreakProgress*waveBreakProgress);\n    float carvedWaveDist = \n        fInfiniteCylinder((carvedCylinderPos - waveRadius*vec3(\n            -0.5 - waveBreakProgress*0.6, \n            0.95*size - waveBreakProgress*waveBreakProgress*size*4.0, \n            0.0)\n                  ).xzy, waveRadius*size);\n\n    waveDist = max(waveDist, -carvedWaveDist);\n    \n    //Extra cylinder to use to add foam\n    float crashRadius = \n        0.35*waveRadius*linearstep(0.7, 0.73, waveProgress)*\n        (linearstep(2.0, 0.8, waveStrength) + 2.0*linearstep(1.1, 0.9, waveStrength));\n    \n    vec3 crashCenter = -oz.xyy*waveRadius*1.2 \n        - oz.yxy*(crashRadius*0.4 + linearstep(1.3, 1.6, waveStrength));\n    \n    crashX = pos.x - crashCenter.x;\n    crashDist = fInfiniteCylinder((pos - crashCenter).xzy, crashRadius);\n    \n    return waveDist;\n}\n\n//Distance based roughness\n//Not really proper, but works well enough\nfloat computeWaterRoughness(vec3 eyeToPosWS)\n{\n    float scale = kWaterFbmScale;\n    float amount = kWaterFbmAmount;\n    \n    float distFromEye = dot(eyeToPosWS, eyeToPosWS);\n    float uvDiff = scale * (2.0/(kCameraPlaneDist))/iResolution.x * distFromEye;\n\n    float roughness = saturate(uvDiff*5.0*kWaterFbmAmount - 0.00);\n    \n    return clamp(roughness, 0.05, 0.5);\n}\n\nfloat smallWaveDisp(vec3 posWS, float time,\n                       float wavelength, float amplitude)\n{\n    float frequency  = 2.0 * kPI / wavelength;\n\n    float speed           = (30.0 / (frequency * frequency));\n    float phaseShift      = time * speed;\n    float posDotDirection = posWS.x;//hardcoded for (1.0, 0.0) directions\n\n    float wave = sin(posDotDirection * frequency + phaseShift);\n    wave = wave * 0.5 + 0.5;\n    wave = wave*wave * 2.0 - 1.0;\n    \n    return wave * amplitude;\n}\n\nfloat computeWaterFbm(vec3 posWS, vec3 originalPosWS, float time)\n{   \n    float totalDisp = 0.0;\n    float maxDisp = 0.0;\n    float amplitude = 0.5;\n    float wavelength = 2.0;\n    \n    vec3 vecToEye = originalPosWS - s_eyePosWS;\n    float sqDistFromEye = dot(vecToEye, vecToEye);\n#if BIRDS_EYE_VIEW    \n    uint numSteps = 3u + uint(3.1 * (1.0 - min(1.0, sqDistFromEye/(50.0*50.0))));\n#else\n    uint numSteps = 1u + uint(5.1 * (1.0 - min(1.0, sqDistFromEye/(50.0*50.0))));\n#endif\n    \n    float tempAmplitude = amplitude;\n    maxDisp += tempAmplitude; tempAmplitude *= 0.7;\n    maxDisp += tempAmplitude; tempAmplitude *= 0.7;\n    maxDisp += tempAmplitude; tempAmplitude *= 0.7;\n    maxDisp += tempAmplitude; tempAmplitude *= 0.7;\n    maxDisp += tempAmplitude; tempAmplitude *= 0.7;\n    maxDisp += tempAmplitude;\n    \n    float wind = time*0.1;\n\n    for(uint i = 0u; i < numSteps; ++i)\n    {\n        vec3 dPos = posWS;\n        dPos.x += 4.0*amplitude*cos(posWS.z * 0.5/wavelength + wind/(wavelength*wavelength));\n        float disp = smallWaveDisp(dPos, time, wavelength, amplitude);\n        \n        totalDisp += disp;\n        \n        pR(posWS.xz, kGoldenRatioConjugate * 2.0 * PI);\n        wavelength *= 0.7;\n        amplitude *= 0.7;\n    }\n    \n    return (totalDisp / maxDisp)*0.5;\n}\n\n////////////////////////\n\nfloat getPebbleDisp(vec3 posWS, vec3 originalPosWS, out float rocks)\n{\n    rocks = 0.0;\n\n    // Distance based mip selection, not proper, but good enough alternative to\n    // derivatives (which just break down in raymarching loops)    \n    vec3 eyeToPosWS = originalPosWS - s_eyePosWS;\n    vec3 eyeToPosDirWS = normalize(eyeToPosWS);\n    float distToEye = length(eyeToPosWS);\n    float distBetweenPixelsWS = s_pixelSpacingAtUnitLengthWS * distToEye;\n    float uvGrad = distBetweenPixelsWS * 0.4;\n    float pixelGrad = uvGrad * 0.5 * 512.0 / max(0.0001, abs(eyeToPosDirWS.y));\n    float lod = clamp(log2(pixelGrad) - 1.0, 0.00001, 8.0);\n    \n    \n    vec2 rocksUv = posWS.xz * 0.4;\n    rocks = textureLod(iChannel3, rocksUv, lod).r;\n\n    rocksUv = posWS.xz * 0.5;\n    pR(rocksUv, kPI * kGoldenRatioConjugate);\n    rocks = max(rocks, textureLod(iChannel3, rocksUv, lod).r); \n\n    \n    float lodOffset = max(0.0, 1.0 - pow(0.8, max(0.0, lod - 1.0)));\n    float rockThreshold = min(0.7, 1.0 - lodOffset);\n    \n    float rockStrength = rocks * saturate(1.1 - posWS.y*posWS.y);\n    rockStrength = max(0.0, rockStrength - rockThreshold)/(1.0 - rockThreshold);\n\n    return rockStrength;\n\n    return 0.0;\n}\n    \nfloat fIsland(vec3 posWS, vec3 originalPosWS, out vec3 vecToIslandCenter)\n{\n    vecToIslandCenter = posWS - kIslandSphereCenterWS;\n    \n    //Reduce precision issues getting the distance to this massive sphere\n    float precisionMult = 0.05;\n    \n    float islandDist = fSphere(\n        vecToIslandCenter*precisionMult, \n        kIslandSphereRadius*precisionMult)/precisionMult;\n    \n    float disp = sin(length(vecToIslandCenter.xz)*2.0) * 0.5;\n    disp += sin(length(vecToIslandCenter.xz)*0.3) * 2.0;\n    vecToIslandCenter += disp*oz.xxx*0.5;\n    \n    disp += sin((vecToIslandCenter.z + vecToIslandCenter.x)*0.5) * 0.75;\n    disp += sin((vecToIslandCenter.z - vecToIslandCenter.x)*0.2) * 2.0;\n    islandDist += disp*0.15 * saturate((posWS.y - 0.15) * 0.5);\n        \n    float unusedRocks;\n\tislandDist -= getPebbleDisp(posWS, originalPosWS, unusedRocks) * 0.06;\n    \n    return islandDist;\n}\n\nfloat fRockDisp(float rock, vec3 posDispWS, float radius, float fbm)\n{\n#if 0\n    return rock;\n#else    \n\n    rock += fbm*2.0*min(radius*0.45, (0.8 + abs(-0.5 + posDispWS.y * 0.5)));   \n    \n    return rock;\n#endif    \n}\n\n\nfloat fRock(vec3 posWS, vec3 posDispWS, float radius, float height,\n           inout float stream)\n{\n    //-1 is up stream, 1 is down stream\n    stream = max(stream, -normalize(posWS).x);\n    float rock = fCapsule(posWS, radius, height);\n    \n    return rock;\n}\n\nfloat rockFbm(vec3 posWS)\n{\n    float fbm = 0.0;\n    float seed = 0.1537;\n    vec3 uv = (posWS + oz.xyx * posWS.y*2.0) * 0.005 + oz.xxx*seed;\n    //vec2(posWS.x + posWS.z - posWS.y, posWS.y*8.0 + posWS.z - posWS.x)*0.001;\n    uv = fract(uv);\n    fbm += 1.000 * textureLod(iChannel1, uv * 1.0, 0.0).r;\n    fbm += 0.500 * textureLod(iChannel1, uv * 3.5, 0.0).r;\n    fbm += 0.250 * textureLod(iChannel1, uv * 12.0, 0.0).r;\n    fbm += 0.125 * textureLod(iChannel1, uv * 42.0, 0.0).r;\n    fbm /= 1.875;    \n\n    return fbm;\n}\n\nfloat fRocks(vec3 posWS, float islandDist, out float stream)\n{   \n    stream = -1.0;\n    \n    float cliffShift = textureLod(iChannel3, posWS.xz * 0.005, 0.0).r;\n    \n    vec3 shiftedPosWS = posWS;\n    shiftedPosWS += (cliffShift - 0.5) * 7.0 * vec3(1.0, 0.5, 1.0);\n    vec3 rocksPosWS = posWS - (cliffShift - 0.5) * 3.0 * oz.xyx - oz.yyx * 30.0;\n    \n    float rock1 = fRock(\n        rocksPosWS - oz.xyy * 15.0, posWS, 4.0, 3.0, stream);\n    \n    float rocks = rock1;\n    \n    if(rock1 < 20.0)\n    {\n        float fbm = rockFbm(posWS * 1.5);\n        \n        float rock2 = fRock(\n            rocksPosWS - oz.xyy * 15.0 - oz.xyx*9.0, posWS, 3.0, 3.0, stream);    \n\n        float rock3 = fRock(\n            rocksPosWS - oz.xyy * 10.0 + oz.xyy*3.0, posWS, 2.5, 2.0, stream);\n\n        rocks = min(rocks, rock2);\n        rocks = min(rocks, rock3);\n\n        rocks = fRockDisp(rocks, posWS, 3.0, fbm);\n    }\n    else\n    {\n        rocks -= 10.0;\n    }\n    \n    float cliff = \n        fTorus(shiftedPosWS - kIslandSphereCenterWS * oz.xyx - oz.yxy * 5.0,\n                7.0, 730.0);\n    \n    if(cliff < 10.0)\n    {\n        float cliffFbm = rockFbm(posWS * 0.5);\n        \n    \tcliff = fRockDisp(cliff, posWS - oz.yxy * 2.0, 5.0, cliffFbm);\n    }\n    rocks = min(rocks, cliff);\n    \n    float distantIsland = fSphere(shiftedPosWS - oz.xyy * 3600.0\n                           + oz.yyx * 1400.0, 3500.0);\n    distantIsland = max(distantIsland, shiftedPosWS.y - 20.0);\n    \n    if(distantIsland < 20.0)\n    {\n        float distFbm = rockFbm(posWS * 0.2)*2.0 - 1.0;\n\t\tdistantIsland -= distFbm * 15.0 * clamp((30.0 - posWS.y)/20.0, 0.5, 1.0);\n    }\n    rocks = min(rocks, distantIsland);\n  \n    return rocks;\n}\n\nfloat fFoamDisp(vec3 posWS, \n                float minDist,\n                float islandDist, \n                float rockFoamAmount,\n                float waveFoamAmount,\n                float underwaterCrashFoamAmount,\n                float waterFbm, float time,\n                out float outUnderWaterFoamAmount)\n{\n    waterFbm = clamp(waterFbm, -0.5, 0.5);\n#if 0\n    return kMaxDist;\n#else\n    float foamDist = kMaxDist;\n    float sphereRadius = 0.05;\n\n    outUnderWaterFoamAmount = linearstep(\n        0.50 - waveFoamAmount*3.0 - rockFoamAmount*3.0 - underwaterCrashFoamAmount*3.0,\n        0.55 - waveFoamAmount*0.25 - rockFoamAmount*0.25 - underwaterCrashFoamAmount * 0.25, \n        waterFbm);\n\toutUnderWaterFoamAmount *= outUnderWaterFoamAmount;\n    \n    \n    float foamAmount = linearstep(\n        0.50 - waveFoamAmount*1.5 - rockFoamAmount*1.5,\n        0.55 - waveFoamAmount*0.5 - rockFoamAmount*0.5, \n        waterFbm);\n    \n    \n    vec3 repPos = posWS - time * oz.yxx * sphereRadius * 0.0;\n    pMod2(repPos.xz, vec2(sphereRadius*1.5));\n    repPos.y = minDist;\n    foamDist = fSphere(repPos, sphereRadius);\n    \n    repPos = posWS + time * oz.xxx * sphereRadius * 0.0;\n    pR(repPos.xz, kGoldenRatioConjugate * 2.0 * PI);\n    pMod2(repPos.xz, vec2(sphereRadius*1.5));\n    repPos.y = minDist;    \n    foamDist = min(foamDist, fSphere(repPos, sphereRadius));\n    \n    //Add some bubbles t o the underwater foam too\n    float underwaterFoamDist = foamDist - 0.02;\n    outUnderWaterFoamAmount = saturate(\n        mix(outUnderWaterFoamAmount, max(0.0, -underwaterFoamDist)*10.0 + outUnderWaterFoamAmount,\n            outUnderWaterFoamAmount));\n    \n    float oneMinusFoamAmount = (1.0 - foamAmount);\n    oneMinusFoamAmount *= oneMinusFoamAmount;\n    \n    //Remove the buddles where we don't have foam\n    foamDist += linearstep(0.5 - oneMinusFoamAmount*2.0, \n                           0.55 - oneMinusFoamAmount*1.0, \n                           waterFbm) * sphereRadius*1.05;\n    \n    return -min(sphereRadius*2.0, -foamDist);\n#endif    \n}\n\n\nvec3 computeVecToBird(vec3 posWS, vec3 centerWS, float time)\n{\n#if BIRDS_EYE_VIEW\n    time *= 1.2;\n#endif    \n    posWS -= centerWS;\n    pR(posWS.xz, -time*0.4);\n    posWS.x += 15.0;\n    return posWS;\n}\n\nfloat fBird(vec3 posWS, vec3 centerWS, float time, out float wingTip)\n{\n    vec3 dToBirdWS = computeVecToBird(posWS, centerWS, time);\n    \n    float fCenter = length(dToBirdWS);\n\twingTip = 0.0;\n    \n    if(fCenter < 1.0)\n    {\n        float bank = sin(time*0.5);\n        float gliding = max(0.0, abs(bank)*abs(bank)*1.5 - 0.5);\n        pR(dToBirdWS.xy, bank*0.2*kPI); //roll\n\n        vec3 dWings = dToBirdWS - oz.yyx * 0.17;\n        dWings.x = abs(dWings.x) - 0.05;\n        dWings.z += dWings.x*dWings.x * 0.4;\n        pR(dWings.xy, sin(time*13.0)*0.12*kPI*gliding - 0.1); //flap\n\n        float bodyDist = sdRoundCone(dToBirdWS.xzy, 0.12, 0.01, 0.35);\n        float wingsDist = sdRoundCone(dWings.yxz, 0.08, 0.005, 0.6);\n\n        bodyDist = max(bodyDist, abs(dToBirdWS.y)-0.05); \n        wingsDist = max(wingsDist, abs(dWings.y)); \n\n        wingTip = saturate(dWings.x / 0.6);\n        \n        return fOpUnionRound(wingsDist, bodyDist, 0.05);\n    }\n    \n    return fCenter - 0.5;\n}\n\n\n#if BIRDS_EYE_VIEW\nconst vec3 kBird0CurveCenterWS = vec3(5.0, 7.0, -15.0);\nconst vec3 kBird1CurveCenterWS = vec3(-20.0, 10.0, -7.0);\nconst vec3 kBird2CurveCenterWS = vec3(20.0, 5.0, 00.0);\n#else\nconst vec3 kBird0CurveCenterWS = vec3(00.0, 7.0, -40.0);\nconst vec3 kBird1CurveCenterWS = vec3(00.0, 5.0, -20.0);\nconst vec3 kBird2CurveCenterWS = vec3(20.0, 12.0, 00.0);\n#endif\n\nfloat fBirds(vec3 posWS, out float wingTip)\n{\n    wingTip = 0.0;\n    \n    float time = s_time * kTimeScale;\n    float birdsDist = kMaxDist;\n    \n    float tempWingTip, tempBirdDist;\n    tempBirdDist = fBird(posWS, kBird0CurveCenterWS, time, tempWingTip);\n    wingTip = max(wingTip, tempWingTip);\n    birdsDist = min(birdsDist, tempBirdDist);\n    \n    tempBirdDist = fBird(posWS, kBird1CurveCenterWS, time * 1.3 - 23.0, tempWingTip);\n    wingTip = max(wingTip, tempWingTip);\n    birdsDist = min(birdsDist, tempBirdDist);\n    \n    tempBirdDist = fBird(posWS, kBird2CurveCenterWS, time + 14.0, tempWingTip);\n    wingTip = max(wingTip, tempWingTip);\n    birdsDist = min(birdsDist, tempBirdDist);\n    \n    return birdsDist;\n}\n\n#define MARCH_BIRDS 1\n\nfloat fBeachWaterDist(vec3 posWS, float time, float waterFbm)\n{\n    vec3 originalPosWS = posWS;\n    posWS = computeWalkRotatedPosWS(posWS, time);\n    \n    float waterDist = originalPosWS.y;\n    \n    time *= kTimeScale;\n    \n    vec3 vecToIslandCenter = posWS - kIslandSphereCenterWS;;\n    float waveStrength = 1.0 - ((length(vecToIslandCenter.xz) - 780.0) * 0.04);\n\n    \n    vec3 scrollPos = originalPosWS;\n    //Offset the wave a bit to make them look less straight\n    float subtleCurving = sin(posWS.z * 0.04) * 2.0 - 1.0;\n    scrollPos.x += (time)*2.0 + subtleCurving;\n    \n    float distBetweenWaves = 20.0;\n    \n    float waveCenterX = mod(scrollPos.x+2.0, distBetweenWaves);\n    float beachRecess = linearstep(distBetweenWaves*0.9, 4., waveCenterX);\n    float beachClimb = linearstep(0.5, 1., waveCenterX) \n        * beachRecess * beachRecess;\n\n    \n    waterDist -= linearstep(0.9, 1.3, waveStrength) * (beachClimb) * 0.2;  \n\tfloat waterDisp = waterFbm * kWaterFbmAmount;\n    waterDist -= waterDisp;\n                 \n\treturn waterDist;\n}\n\nfloat fSDF(vec3 posWS, uint partSelection,\n           out uint materialID, out float foamAmount, out float taaStrength)\n{\n    vec3 originalPosWS = posWS;\n    posWS = computeWalkRotatedPosWS(posWS, s_time);\n    \n    float time = s_time * kTimeScale;\n    \n \tfloat minDist = kMaxDist;\n    // --- Water plane --- //\n    float waterDist = originalPosWS.y;\n    \n    // --- Island --- //\n    vec3 vecToIslandCenter;\n    float islandDist = fIsland(posWS, originalPosWS, vecToIslandCenter);\n    \n    // --- Rocks --- //\n    float rocksStream = -1.0;\n    float rocksDist = fRocks(posWS, islandDist, rocksStream);\n    float rocksCloseness = linearstep(10.0, 0.5, rocksDist);\n    \n    float waveStrength = 1.0 - ((length(vecToIslandCenter.xz) - 780.0) * 0.04);\n    \n    float waveDist = kMaxDist;\n    float waveAnimProgress = 0.0;\n    float waveFoamAmount = 0.0;\n    float waveCrashDist = kMaxDist;\n    float waveCrashX = 0.0;\n    \n    if(waveStrength > 0.001 && waveStrength < 2.0)\n    {\n        vec3 scrollPos = originalPosWS;\n        //Offset the wave a bit to make them look less straight\n        float subtleCurving = sin(posWS.z * 0.04) * 2.0 - 1.0;\n        scrollPos.x += (time)*2.0 + subtleCurving;\n\n        float saturatedWaveStrength = saturate(waveStrength);\n        //expWaveProgress : start slow, crash fast.\n        float expRate = 200.0;\n        float expWaveProgress = \n            mix(saturatedWaveStrength, \n                (pow(max(0.0001, 1.0 + expRate), saturatedWaveStrength) - 1.0)/expRate, \n                linearstep(0.1, 0.7, saturatedWaveStrength));\n\n        float distBetweenWaves = 20.0;//32.0;\n        vec3 repeatPos = scrollPos;\n        float id = pMod1(repeatPos.x, distBetweenWaves);\n\n        \n\t\twaveDist = fWave(repeatPos, expWaveProgress, waveStrength, waveCrashDist, waveCrashX);\n\n        //When close to rocks, reduce wave, increase water height\n        waterDist -= linearstep(1.5, 0.15, waveDist) \n            * min(0.2, mix(rocksCloseness*1.0, rocksCloseness*0.2, max(0.0, rocksStream)));\n        float waveReduction = mix(rocksCloseness*0.1, rocksCloseness*0.5, max(0.0, rocksStream));\n        waveDist += waveReduction;\n        waveCrashDist += waveReduction * 0.5; \n        \n        waterDist = min(waterDist, waveDist);\n        waterDist = fOpUnionSoft(waterDist, waveDist, 0.25*(1.0 - expWaveProgress));       \n        \n        float waveCenterX = mod(scrollPos.x+2.0, distBetweenWaves);\n        float beachRecess = linearstep(distBetweenWaves*0.9, 4., waveCenterX);\n        float beachClimb = linearstep(0.5, 1., waveCenterX) \n            * beachRecess * beachRecess;\n        \n        waterDist -= linearstep(0.9, 1.3, waveStrength) * (beachClimb) * 0.2;\n        \n        waveAnimProgress = 0.5 + (repeatPos.x/distBetweenWaves);\n        \n        float postBreakage = min(1.0,(1.9 - waveStrength));\n        float foamClimb = linearstep(10.0, 0.0, waveCrashX) * linearstep(-0.5, 0.0, waveCrashX);\n        \n        waveFoamAmount = 1.0 * foamClimb * foamClimb * linearstep(0.89, 1.0, waveStrength);\n    }\n    \n\tfloat foamDist = kMaxDist;\n    float foamDisp = 0.0;\n    \n    float waterFbm = 0.0;\n    \n    if(waterDist < 2.0)\n    {\n        float waterDisp = 0.0;\n\n        float waveOffset = 0.0;\n        vec3 sinWavePos = posWS * 0.5;\n        waveOffset += cos((sinWavePos.x) * 0.5 + time * 0.5) * 2.0;\n        sinWavePos.x += waveOffset * 4.0;\n        pR(sinWavePos.xz, kGoldenRatioConjugate * 2.0 * PI);\n        waveOffset *= cos((sinWavePos.x) * 1.0 + time * 0.25);\n\n        waveOffset = waveOffset/2.0 * 0.5 + 0.5;\n        waveOffset *= waveOffset;\n\t\twaveOffset = waveOffset*2.0 - 1.0;\n        \n        waterDisp += waveOffset * 0.2 * (linearstep(1.0, 0.0, waveStrength));\n\n        waterFbm = computeWaterFbm(posWS, originalPosWS, time);\n        float waveInducedAmount = saturate(1.0 - waveDist*0.5);\n        waveInducedAmount *= 0.2 * waveInducedAmount * waveInducedAmount;\n\n        float rockInducedFbmAmount = rocksCloseness*rocksCloseness*rocksCloseness * 0.5;\n        waterFbm *= (linearstep(-0.1, 0.1, islandDist) + min(1.0, waveInducedAmount + rockInducedFbmAmount)*5.0);\n        waterDisp += waterFbm * kWaterFbmAmount;\n\n        waterDist -= waterDisp;\n        waveCrashDist -= waterFbm*0.3*(0.25 + linearstep(1.5, 1.0, waveStrength)\n                                       *linearstep(0.8, 1.0, waveStrength));\n        \n        // --- Foam --- //\n\n        float rockFoamAmount = 0.75 * linearstep(0.8, 1.0, rocksCloseness);\n        rockFoamAmount += 0.5 * linearstep(0.85, 1.00, rocksCloseness) * (rocksStream*0.5 + 0.5) \n            * linearstep(5.0, 1.0, waveDist);\n\n        float underwaterCrashFoamAmount = \n            linearstep(2.0, 0.0, waveCrashDist);\n        underwaterCrashFoamAmount *= 0.65*underwaterCrashFoamAmount*linearstep(0.90, 0.95, waveStrength);\n\n        foamDist = min(waterDist, waveCrashDist);\n        foamDisp = fFoamDisp(posWS, waterDist, islandDist, rockFoamAmount, \n                             waveFoamAmount, underwaterCrashFoamAmount, waterFbm, time, foamAmount);\n\n\n    }\n    \n    // --- Filters --- //\n    \n    if((partSelection & kWaveFoamPartId) == 0u)\n    {\n        waveCrashDist = kMaxDist;\n    }\n    \n    if((partSelection & kIslandPartId) == 0u)\n    {\n        islandDist = kMaxDist;        \n    }\n    \n    if((partSelection & kRockPartId) == 0u)\n    {\n        rocksDist = kMaxDist;\n    }\n    \n    // --- Birds --- //\n#if MARCH_BIRDS  \n    float birdsDist = kMaxDist;\n    if((partSelection & kBirdsPartId) != 0u)\n    {\n        float unusedWings;\n        birdsDist = fBirds(originalPosWS, unusedWings);\n    }\n#endif    \n    \n    if((partSelection & kWaterPartId) == 0u)\n    {\n        waterDist = kMaxDist;\n    }\n        \n    float waterFoamDist = waterDist + foamDisp;\n    float waveCrashFoamDist = waveCrashDist + foamDisp;\n    foamDist = min(waterFoamDist, waveCrashFoamDist);\n    \n    if((partSelection & kFoamPartId) == 0u\n      && (partSelection & kWaveFoamPartId) == 0u)\n    {\n        foamDist = kMaxDist;\n    }\n    \n    float waterAndFoamTaa = mix(\n        saturate(min(1.0, waveDist * 1.0) * min(1.0, abs(waveCrashX + 1.0) * 0.1)),\n        1.0, saturate(-waveStrength*4.0 + 4.0));\n    waterAndFoamTaa = 0.2 + 0.8*waterAndFoamTaa;\n    \n    // --- Materials --- //\n    if(minDist > waterDist)\n    {\n        minDist = waterDist;\n        materialID = kWaterMatId;\n        taaStrength = waterAndFoamTaa;\n    }\n    \n    if(minDist > foamDist)\n    {\n        minDist = foamDist;\n        materialID = kFoamMatId;\n        taaStrength = waterAndFoamTaa;\n    }\n    \n    if(minDist > islandDist)\n    {\n        minDist = islandDist;\n        materialID = kSandMatId;\n        taaStrength = waterAndFoamTaa;\n    }\n    \n    if(minDist > rocksDist)\n    {\n        minDist = rocksDist;\n        materialID = kRockMatId;\n        taaStrength = 1.0;\n    }\n    \n#if MARCH_BIRDS    \n    if(minDist > birdsDist)\n    {\n        minDist = birdsDist;\n        materialID = kBirdsMatId;\n        taaStrength = 0.0;\n    }    \n#endif\n    \n    return minDist;\n}\n\nfloat fSDF(vec3 p, uint partSelection, out uint materialID)\n{\n    float foamAmount = 0.0, taaStrength = 0.0;\n    return fSDF(p, partSelection, materialID, foamAmount, taaStrength);\n}\n\nfloat fSDF(vec3 p, out uint matId)\n{\n    float foamAmount = 0.0, taaStrength = 0.0;\n    return fSDF(p, 0xffffffffu, matId, foamAmount, taaStrength);\n}\n\nfloat fSDF(vec3 p)\n{\n    uint matId = 999u;\n    float foamAmount = 0.0, taaStrength = 0.0;\n    return fSDF(p, 0xffffffffu, matId, foamAmount, taaStrength);\n}\n\nvec3 computeNormalForPart(vec3 p, uint partSelect, float dt)\n{\n    //From IQ. https://iquilezles.org/articles/normalsSDF\n    //The loop prevents the silly compiler unrolling the code for fSDF 4 times\n    //Shaved 15s of the (ANGLE) compile times\n    vec3 normalWS = oz.yyy;\n    for( int i=NON_CONST_ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        uint unusedMatId;\n        normalWS += e*fSDF(p + e * dt, partSelect, unusedMatId);\n    }\n    return normalize(normalWS);\n    \n}\n\nvec3 computeWaterPlaneNormal(vec3 posWS, float dt)\n{\n    //Same as above, but only uses the distance for the displaced water plane. A bit simpler.\n    float time = s_time * kTimeScale;\n    \n    vec3 originalPosWS = posWS;\n    posWS = computeWalkRotatedPosWS(posWS, time);\n    \n    vec3 normalWS = oz.yyy;\n    for( int i=NON_CONST_ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        \n        vec3 posOffsetWS = posWS + e * dt;\n        float distToPlane = posOffsetWS.y;\n        distToPlane -= computeWaterFbm(posOffsetWS, originalPosWS, time) * kWaterFbmAmount;\n        \n        normalWS += e*distToPlane;\n    }\n    return normalize(normalWS);    \n}\n\nvec3 fixNormalBackfacingness(vec3 normalWS, vec3 rayDirWS)\n{\n    normalWS -= max(0.0, dot(normalWS, rayDirWS)) * rayDirWS;\n    return normalWS;\n}\n\nfloat computeWaterSpecularReflectance(vec3 rayDirWS, vec3 normalWS, float roughness)\n{\n    float rayDotNormal = max(0.001, dot(normalWS, -rayDirWS));\n    float f0Water = ((kWaterIoR - 1.0) * (kWaterIoR - 1.0)) / ((kWaterIoR + 1.0) * (kWaterIoR + 1.0));\n\n    return roughFresnel(f0Water, rayDotNormal, roughness);\n}\n\n#define ITER_SHADOW 32u\nfloat marchShadow(vec3 ro, vec3 rd)\n{\n \tfloat d;\n    float sd = 1.0;\n    \n    float transmittance = 1.0;\n    float t = 0.01;\n    \n    for(uint i = NON_CONST_ZERO_U; i < ITER_SHADOW; ++i)\n    {\n        vec3 posWS = ro + rd*t;\n        float foamAmount = 0.0, taaStrength = 0.0;\n        uint materialId = 999u;\n        d = fSDF(posWS, kFoamPartId | kWaveFoamPartId | kRockPartId, materialId, \n                 foamAmount, taaStrength);\n        d -= t * 0.001;\n        \n        float stepD = max(0.02+float(i)*0.05, abs(d));\n        \n        float stepTransmittance = 1.0;\n        if(materialId == kFoamMatId)\n        {\n            stepTransmittance = exp(-2.0*stepD*foamAmount);\n        }\n        else\n        {\n            stepTransmittance = 0.0;\n        }\n        \n        float coneWidth = max(0.05, t * 1.0/40.0);\n        stepTransmittance = mix(stepTransmittance, 1.0, saturate(d/coneWidth));\n        transmittance *= stepTransmittance;\n        \n        t += stepD;\n        \n        if(transmittance < 0.05)\n        {\n            break;\n        }\n    }\n      \n    return transmittance;\n}\n\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n/////////////////////////// Sun and Sky /////////////////////////////\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n\nconst vec3 kDirToSunWS = normalize(vec3(0.3, 0.02, 0.5));\nconst vec3 kSunColour = vec3(1.0, 0.25, 0.025) * 7.0;\n\nconst float kSunAngularRadius = 0.5/180.0*PI;\nconst float kSunAngularRadiusCos = cos(kSunAngularRadius);\n\nfloat sampleCloudNoise(vec2 cloudUV)\n{\n    vec3 cloudWind = -s_time * kTimeScale * 0.001 * oz.xxy;\n    vec3 cloudDetailWind = s_time * kTimeScale * 0.001 * oz.yxy;\n    vec3 uv = vec3(cloudUV * 2.0, 16.5/32.0);\n    return (  1.000*textureLod(iChannel1, uv*0.01 + cloudWind * 0.01, 0.0 ).r \n            + 0.500*textureLod(iChannel1, uv*0.03 + cloudWind * 0.50, 0.0 ).r\n            + 0.250*textureLod(iChannel1, uv*0.07 + cloudWind * 3.00, 0.0 ).r\n            + 0.125*textureLod(iChannel1, uv*0.25 + cloudDetailWind * 15.0, 0.0 ).r\n            ) * 0.75 - (0.3 * (1.0 - saturate(dot(cloudUV, cloudUV) / 7.0)));\n}\n\nvec3 computeSunColour(float rayDotSun, float roughness)\n{\n    float sqBlur = roughness;\n    float blur = roughness*roughness;\n    float sharpness = 1.0 - blur;\n    \n    float sun = linearstep(kSunAngularRadiusCos - 0.00025 - blur*0.5, kSunAngularRadiusCos + blur*0.25, rayDotSun);\n    vec3 sunColour = safePow(sun, 2.0 + sqBlur * 20.0) * sharpness * 100.0 * kSunColour;\n    return sunColour;\n}\n\n//The sky rendering has built-in roughness/bluring. \n//It's like an eyeballed mathematical blur integration for doing rough specular lighting\nvec3 computeSkyColour(vec3 rayDirWS, float roughness, bool doClouds, bool doSun, bool doFlares)\n{\n    float sqBlur = roughness;\n    float blur = roughness*roughness;\n    \n    float sharpness = (1.0 - blur);\n\n    float rayDotSun = dot(kDirToSunWS, rayDirWS);\n    float bloom = henyeyGreensteinPhase(rayDotSun, 0.65 - blur * 0.64)*0.65;\n    \n    vec3 sunColour = computeSunColour(rayDotSun, roughness);\n\n    sunColour *= doSun ? 1.0 : 0.0;\n    \n    vec3 sunAndBloom = sunColour + bloom * vec3(1.0, 0.6, 0.2) * min(1.0, 1.0 - rayDirWS.y) * 2.5;\n    \n    //Blend the top, middle and bottom colours\n    vec3 skyTopColour = vec3(0.05, 0.15, 0.5);\n    vec3 skyMidColour = vec3(0.05, 0.8, 1.0);\n    vec3 skyBottomColour = mix(vec3(1.0, 0.2, 0.1), vec3(1.0, 0.3, 0.05), saturate(rayDotSun+0.6));\n    \n    float midToTop = mix(min(0.5, pow(max(0.0001, rayDirWS.y), 0.8)), 0.1, blur*0.75);\n    float bottomToMid = saturate(mix(pow(max(0.0001, rayDirWS.y*1.5 + 0.15), 0.8), 0.5, blur*0.8));\n    vec3 skyColour = mix(skyMidColour, skyTopColour, midToTop);\n    skyColour = mix(skyBottomColour, skyColour, bottomToMid);\n    //Darken the sky at the top\n    skyColour *= mix(0.5 + 0.5*saturate(1.0 - rayDirWS.y), 1.0, blur);\n    \n    \n    if(doClouds)\n    {\n        vec2 cloudUV = rayDirWS.xz/max(0.0001, rayDirWS.y);\n\n        float cloudNoise = sampleCloudNoise(cloudUV);\n        \n        float cloudPhase = (0.2 + henyeyGreensteinPhase(rayDotSun, 0.8 - blur * 0.5)\n              + henyeyGreensteinPhase(rayDotSun, 0.4 - blur * 0.3)) * 4.0 * PI;\n        //High clouds\n        float highCloud = sampleCloudNoise(cloudUV*vec2(6.0, 1.5) + oz.xx*0.79);\n        highCloud = max(0.0, highCloud*highCloud - 0.05)*0.1;\n        vec3 highCloudColour = sharpness*sharpness*highCloud * kSunColour * cloudPhase;\n        \n        //Low clouds\n        float cloudSunTransmittance = linearstep(1.0 + blur*4.0, 0.4 - blur*4.0, \n                                                 sampleCloudNoise(cloudUV + kDirToSunWS.xz * 1.0));\n\t\tcloudSunTransmittance *= cloudSunTransmittance;\n        \n        float oneMinusTransmittance = saturate(1.0 - cloudNoise);\n        \n        float cloudNoiseStart = 0.6 - blur*4.0;\n        float cloudNoiseEnd = 0.8 + blur*4.0;\n        float cloud = smoothstep(cloudNoiseStart, cloudNoiseEnd, cloudNoise);\n        vec3 cloudColour = skyColour * 0.3;\n        vec3 cloudSun = cloudSunTransmittance * kSunColour * cloudPhase * oneMinusTransmittance;\n        cloudColour += cloudSun;\n        \n        cloudColour += highCloudColour*(1.0 - cloud);\n        cloud = (1.0 - (1.0 - cloud)*(1.0 - highCloud));\n        float atm = linearstep(0.0, 0.15 + blur * 0.5, rayDirWS.y);\n        cloud *= atm;\n        cloud *= sharpness;\n        \n        skyColour += sunAndBloom * max(1.0 - cloud*1.3, oneMinusTransmittance*cloudSunTransmittance);\n        \n        skyColour = mix(skyColour, cloudColour, 0.2*cloud);\n    }\n    else\n    {\n        skyColour += sunAndBloom;\n    }\n    \n    //Flare, completly made up math...\n    //Also, I render them directly in the sky for convenience.\n    //Because of that, they get occluded... sucks, but otherwise \n    //we would need to compute an extra sun occlusion per pixel (too expensive).\n    vec3 dSun = rayDirWS - kDirToSunWS;\n    float flare = abs(0.5 - fract(atan(length(dSun.xz), dSun.y)*2.0));\n    float flareEnd = 1.0 - s_flare;\n    float flareBloom = linearstep(0.995, 0.99995, rayDotSun);\n    flare = (max(0.0, flare - safePow(flareEnd, 1.0/4.0))*3.0\n        + flareBloom*flareBloom*flareBloom)*0.4*max(0.0, rayDotSun);\n    \n    flare = doFlares ? flare : 0.0;\n    \n\tskyColour += flare*flare*kSunColour*3.0;\n    \n    //Below the horizon, blend to a colour similar to what the ocean surface looks like.\n    //This is do allow falling back to a sky sample for refraction and still have things\n    //look okay\n    vec3 approximatedOceanColour = mix(skyBottomColour, skyMidColour*0.7, max(0.0001, -rayDirWS.y*0.7));\n    vec3 approximatedIslandColour = vec3(0.4, 0.25, 0.1) * \n        (kSunColour*kDirToSunWS.y + \n         mix(skyTopColour, skyBottomColour, 0.6)/4.0);\n    skyColour = mix(skyColour, approximatedOceanColour, \n                    min(0.4, smoothstep(-0.01 + blur * 0.5, -0.1 - blur*2.0, rayDirWS.y)));\n    \n\treturn skyColour;\n}\n\nvec3 computeSkyColour(vec3 rayDirWS, float blur)\n{\n    return computeSkyColour(rayDirWS, blur, true, true, false);\n}\n\nvec3 computeSkyColour(vec3 rayDirWS)\n{\n    return computeSkyColour(rayDirWS, 0.0, true, true, true);\n}\n\nvec3 computeSkyFadeColour(vec3 rayDirWS)\n{\n    return computeSkyColour(rayDirWS, 0.0, false, false, false);\n}\n\nvec3 computeAmbientColour()\n{\n    vec3 skyTopColour = vec3(0.005, 0.025, 1.0);\n    vec3 skyMidColour = vec3(0.1, 0.7, 0.9);\n    vec3 skyBottomColour = vec3(1.0, 0.3, 0.05);\n    return  skyTopColour*0.05 + skyMidColour*0.45 + skyBottomColour*0.5;\n}\n\nfloat computeSkyTransmittance(float dist, vec3 rayOriginWS, vec3 rayDirWS)\n{\n    vec3 hitPosWS = rayOriginWS + dist * rayDirWS;\n    float heightFog = 1.0 - exp(-hitPosWS.y*0.1);\n    float transmittance = exp(-dist * 0.006 * (1.0 - heightFog*0.9));\n    return min(1.0, transmittance + 0.07);\n}\n\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n//////////////// Underwater inscatter/transmittance /////////////////\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n\n\nvoid computeFoamInscatterTransmittance(vec3 rayDirWS, float stepDistance, float foamAmount,\n                                       float hgPhase, float msPhase, vec3 ambient, float shadow,\n                                       out vec3 foamInscatter, out float foamTransmittance)\n{\n    float foamExtinctionCoef = 2.0*foamAmount;\n    foamTransmittance = exp(-0.2*foamExtinctionCoef*stepDistance);\n\n    vec3 sunLighting = (msPhase + hgPhase*1.5)\n        * kSunColour * shadow;\n    foamInscatter = min(1.0, foamExtinctionCoef*stepDistance) * 0.5*(sunLighting + ambient);\n}\n\nconst vec3 kCleanWaterAbsorptionCoeffs = vec3(0.65, 0.064, 0.015) * 6.0;  // x10 for ocean, x50 for turbid\nconst vec3 kCleanWaterSSAlbedo         = vec3(0.001, 0.025, 0.4)*1.0;\n\nvoid computeWaterInscatterTransmittance(vec3 rayDirWS, float stepDistance, float foamAmount,\n                                        out vec3 inscatter, out vec3 transmittance)\n{\n    float hgPhase = henyeyGreensteinPhase(dot(rayDirWS, kDirToSunWS), 0.75);\n\n    transmittance = exp(-kCleanWaterAbsorptionCoeffs * stepDistance);\n    vec3 sunLighting = (saturate(stepDistance * 0.1) + hgPhase/kIsotropicScatteringPhase)\n        * kSunColour;\n    \n    vec3 ambient = computeAmbientColour();\n    inscatter = (oz.xxx - transmittance ) * (sunLighting + ambient) * kCleanWaterSSAlbedo;   \n    \n    //Add some foam\n\tfloat foamTransmittance = 1.0;\n    vec3 foamInscatter = oz.yyy;\n    float foamStepD = min(0.3, stepDistance);\n    computeFoamInscatterTransmittance(rayDirWS, foamStepD, foamAmount, \n                                      henyeyGreensteinPhase(dot(rayDirWS, kDirToSunWS), 0.5), 0.5,\n                                      ambient, 0.7, foamInscatter, foamTransmittance);\n    \n    //Colour the foam\n    float foamDepth = (1.0 - foamAmount);\n    foamDepth *= 4.0 * foamDepth;\n\tvec3 waterTransmittance = exp(-kCleanWaterAbsorptionCoeffs * foamStepD * foamDepth);\n    vec3 waterInstatter = (oz.xxx - waterTransmittance ) \n        * (sunLighting + ambient) * kCleanWaterSSAlbedo;   \n    \n    foamInscatter = foamInscatter * waterTransmittance + waterInstatter*foamAmount;\n    \n    inscatter *= foamTransmittance;\n    transmittance *= foamTransmittance;\n    inscatter += foamInscatter;    \n}\n\n\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n//////////////////////////// Lighting ///////////////////////////////\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n\nvec3 doLighting(vec3 posWS, vec3 rayDirWS, uint materialId, float distUnderWater)\n{\n    vec3 originalPosWS = posWS; //Need to use that for anything that calls fSDF because the rotation is applied internally\n    posWS = computeWalkRotatedPosWS(posWS, s_time);\n    \n    vec3 albedo = oz.yyy;\n    float roughness = 0.0;\n\t\n    uint partSelection = 0u;\n    float normalSamplingDT = 0.0;\n    float shadowRayStartOffset = 0.02;\n    vec3 normalOffset = oz.yyy;\n    \n    if(materialId == kSandMatId)\n    {\n        partSelection = kIslandPartId;\n        \n    \tvec3 sandNoise = textureLod(iChannel2, posWS.xz*0.25, 0.0).rgb - 0.5*oz.xxx;\n\n        float waterFbm = computeWaterFbm(posWS, originalPosWS, 0.0);\n        float waterHighLine = 0.25 + kWaterFbmAmount * waterFbm;\n        float waterDistDelayed0 = fBeachWaterDist(originalPosWS - oz.yxy * 0.01, s_time - 0.2, waterFbm);\n\n        float wetness = saturate((-waterDistDelayed0)*10.0 + 1.0);\n        wetness = max(wetness, step(0.01, distUnderWater));\n        wetness = max(wetness, smoothstep(waterHighLine + 0.15, waterHighLine - 0.25, posWS.y));\n\t\t\n        wetness = safePow(wetness, 1.0 / 2.0);\n        float normalNoiseAmount = saturate(0.25*(1.0 - wetness*wetness) + 0.05);\n        normalNoiseAmount *= linearstep(0.05, 0.0, distUnderWater);\n        \n        albedo = vec3(0.5, 0.35, 0.15);\n        albedo *= 1.0 - sandNoise.r*0.25;\n\n        float rocks = 0.0;\n\t\tfloat rockStrength = getPebbleDisp(posWS, originalPosWS, rocks);\n        \n        albedo = mix(albedo, (1.0 - wetness*0.35) * oz.xxx, rockStrength);\n        normalNoiseAmount *= (1.0 - rockStrength);\n        \n        albedo = safePow(albedo, vec3(1.0 + wetness));\n        albedo *= (1.0 - wetness * 0.05);\n   \n        albedo *= 0.7;\n        \n        \n        normalOffset = (sandNoise)*normalNoiseAmount*0.5; \n        \n        roughness = min(1.0, 0.1 + (sandNoise.r * 0.1 + 0.7)*smoothstep(1.0, 0.75, wetness));\n        normalSamplingDT = mix(0.05, 0.01, saturate((rocks - 0.4)/0.5));\n    }\n    else if(materialId == kRockMatId)\n    {\n        partSelection = kRockPartId;\n        albedo = vec3(0.5, 0.45, 0.35)*0.6;\n        roughness = 0.8;\n        float rockFbm = rockFbm(posWS*4.0 + oz.xxx * 10.0);\n        \n        float blendToMoss = linearstep(0.42, 0.68, rockFbm - (posWS.y - 1.0)*0.015);\n\t\talbedo = mix(albedo, vec3(0.05, 0.2, 0.1)*0.65, blendToMoss);\n        \n        albedo *= 0.2 + 0.8*linearstep(0.2, 0.6, rockFbm);\n        \n        albedo *= 0.7;\n        \n        roughness = min(1.0, roughness + (rockFbm - 0.5) * 0.5);\n            \n        normalSamplingDT = 0.1;\n        shadowRayStartOffset = 0.2;\n    }\n    else if(materialId == kFoamMatId)\n    {\n        partSelection = kFoamPartId | kWaveFoamPartId;\n        roughness = 0.1;\n        albedo = oz.yyy;\n        normalSamplingDT = 0.05;\n    }\n    else if(materialId == kBirdsMatId)\n    {\n        partSelection = kBirdsPartId;\n        float wingTips = 0.0;\n        fBirds(originalPosWS, wingTips);\n        albedo = mix(oz.xxx * 0.5, oz.xxx * 0.1, wingTips);\n        albedo = mix(oz.xxx * 0.8, albedo, min(1.0, wingTips * 5.0));\n        roughness = 0.7;\n        normalSamplingDT = 0.05;\n    }\n    \n    vec3 normalWS = computeNormalForPart(originalPosWS, partSelection, normalSamplingDT);\n    normalWS = normalize(normalWS + normalOffset);\n    \n    float sunModulation = marchShadow(originalPosWS + normalWS * shadowRayStartOffset, kDirToSunWS);\n    \n    vec3 reflectionDirWS = reflect(rayDirWS, normalWS);\n    \n    vec3 ambientColour = computeSkyColour(normalize(normalWS + reflectionDirWS), 1.0);\n\tvec3 dirToSunWS = kDirToSunWS;\n\tvec3 sunColour = kSunColour;\n    \n#if 1\n    if(distUnderWater > 0.01)\n    {\n        float refractionStrength = saturate(distUnderWater * 1.0 - 0.15)* linearstep(5.0, 1.0, distUnderWater);;\n        \n        //Refract the reflection dir by an imgaginary horizontal water plane\n        vec3 refractedReflectionDirWS = -refract(-reflectionDirWS, oz.yxy, 1.0/kWaterIoR);\n        \n        //Refract the light coming from the sun by an imgaginary horizontal water plane\n        vec3 refractedDirToSunWS = -refract(-kDirToSunWS, oz.yxy, 1.0/kWaterIoR);\n    \tfloat waterPlaneT = max(0.0, -(originalPosWS.y-distUnderWater)/max(0.0001, refractedDirToSunWS.y));\n    \t\n        vec3 waterSurfaceNormalWS = computeWaterPlaneNormal(originalPosWS + refractedDirToSunWS * waterPlaneT, 0.1);\n        \n        sunColour *= exp(-waterPlaneT * kCleanWaterAbsorptionCoeffs * refractionStrength);\n\n        float caustics = sunModulation*40.0*linearstep(0.0, 0.2, refractionStrength)*\n            pow(max(0.0001, dot(waterSurfaceNormalWS, refractedDirToSunWS)), 8.0);\n        sunModulation = max(sunModulation, caustics);\n        \n        //blend \n        dirToSunWS = normalize(mix(kDirToSunWS, refractedDirToSunWS, refractionStrength));\n        reflectionDirWS = normalize(mix(reflectionDirWS, refractedReflectionDirWS, refractionStrength));\n    }    \n#endif    \n    \n    float nDotL = dot(normalWS, dirToSunWS);\n    float vDotL = dot(dirToSunWS, rayDirWS);\n\tfloat nDotV = dot(normalWS, -rayDirWS);\n    \n    \n    float fresnelReflectance = roughFresnel(0.04, max(0.0001, nDotV), roughness);\n    vec3 lighting = oz.yyy;\n    vec3 diffuseLighting = oz.yyy;\n    \n    if(materialId == kFoamMatId)\n    {\n        float normalBasedSunModulation = smoothstep(-1.0, 0.5, nDotL);\n        float hgPhase = henyeyGreensteinPhase(dot(rayDirWS, dirToSunWS), 0.5);\n        float msPhase = 0.6*smoothstep(-0.5, 0.3, nDotL) * smoothstep(-0.5, 1.0, nDotV);\n        sunModulation = min(normalBasedSunModulation, sunModulation);\n\n        float foamTransmittance;\n        vec3 foamInscatter;\n        float foamStepD = 10.0;\n        computeFoamInscatterTransmittance(rayDirWS, foamStepD, 1.0, hgPhase, msPhase,\n                                          ambientColour, sunModulation,\n                                          foamInscatter, foamTransmittance);\n\n        //If the ray goes down, it should hit the water plane\n        //Our reflections can't handle that, so fallbackk to diffuse lighting\n        fresnelReflectance *= linearstep(-0.3, 0.2, reflectionDirWS.y);\n\n        diffuseLighting = foamInscatter;\n    }     \n    else if(materialId == kSandMatId)\n    {\n        //Diffuse with light leaking through the sand\n        diffuseLighting = albedo *\n            (smoothstep(-0.2, 1.0, nDotL) * sunColour * sunModulation + ambientColour);\n    }\n    else\n    {\n        //Lambertian diffuse\n        diffuseLighting = albedo *\n            (max(0.0, nDotL) * sunColour * sunModulation + ambientColour);\n    }\n    \n    vec3 specularSky = computeSkyColour(reflectionDirWS, roughness, true, false, false);\n    vec3 specularSun = computeSunColour(dot(reflectionDirWS, dirToSunWS), roughness);\n    vec3 specularReflection = specularSky + specularSun * sunModulation;\n\n    lighting = mix(diffuseLighting, specularReflection, fresnelReflectance);\n\n    return lighting;\n}\n\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n////////////////////////// Ray marching /////////////////////////////\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n\nfloat findSdfIntersectionDist(vec3 rayOriginWS, vec3 rayDirWS, inout uint numSteps,\n                             out uint matId, out float foamAmount, out float taaStrength)\n{    \n    vec3 posWS = rayOriginWS;\n    \n    matId = 999u;\n    foamAmount = 0.0;\n    taaStrength = 1.0;\n    \n    float maxT = kMaxDist;\n    \n    //No point in raymarching too high, so compute a maximum distance\n    float topPlaneD = (25.0 - rayOriginWS.y)/max(0.0001, rayDirWS.y);\n    if(topPlaneD > 0.0)\n    {\n        maxT = min(topPlaneD, maxT);\n    }\n    \n    float t = 0.0;\n    \n \tfloat d;\n    for(;numSteps > 0u; --numSteps)\n    {\n        d = fSDF(posWS, 0xffffffffu,\n                 /*outs*/matId, foamAmount, taaStrength);\n        \n        float coneWidth = t * 0.0015;\n        float stepD = max(kStepEpsilon + coneWidth, d);\n        \n        posWS += rayDirWS * stepD;\n        \n        if(t >= maxT)\n        {\n\t\t\tbreak;\n        }\n\n        if((d) < (kDistanceEpsilon + coneWidth))\n        {\n\t\t\tt = max(0.0, t + d);\n            return t;\n        }\n        \n        t += stepD;\n    }\n\t\n    //If we run out of steps intersect with water plane\n    \n    float cosDirY = abs(rayDirWS.y) < 0.00001 ? 0.0001 : rayDirWS.y;\n    foamAmount = 0.0;\n    taaStrength = 1.0;\n    return rayOriginWS.y/-cosDirY;\n}\n\n#define ITER 256u\nvec3 march(vec3 rayOriginWS, vec3 rayDirWS, \n           out float outTaaStrength, out float outIntersectDist)\n{   \n    outTaaStrength = 1.0;\n    outIntersectDist = kMaxDist;\n    \n    vec3 eyePosWS = rayOriginWS;\n    vec3 finalLighting = oz.yyy;\n    vec3 remainingLight = oz.xxx;\n    \n    uint remainingSteps = ITER;\n    \n    float roughness = -1.0;\n    \n    for(uint bounce = NON_CONST_ZERO_U; bounce < 2u; ++bounce)\n    {\n        uint matId = 999u;\n        float foamAmount = 0.0, taaStrength = 1.0;\n        float intersectT = findSdfIntersectionDist(rayOriginWS, rayDirWS, remainingSteps,\n                                                   matId, foamAmount, taaStrength);\n        \n        if(intersectT > 0.0)\n        {\n            vec3 hitPosWS = rayOriginWS + rayDirWS * intersectT;\n\n            outTaaStrength = bounce == 0u ? taaStrength : outTaaStrength;\n            outIntersectDist = bounce == 0u ? intersectT : outIntersectDist;\n            \n\t\t\tif(matId == kWaterMatId)\n            {\n                vec3 normalWS = computeNormalForPart(hitPosWS, kWaterPartId, 0.025);\n                //On thin wave parts, we can get backfacing normals\n                normalWS = fixNormalBackfacingness(normalWS, rayDirWS);\n                \n                roughness = computeWaterRoughness(hitPosWS - eyePosWS);\n\n                //We just hit water, refract the ray and add the relfection\n                float fresnelReflectance = \n                  computeWaterSpecularReflectance(rayDirWS, normalWS, roughness);\n                vec3 refractedDirWS = refract(rayDirWS, normalWS, 1.0 / 1.33);\n                vec3 reflectedDirWS = reflect(rayDirWS, normalWS);\n     \n                float refractedRayDotNormal = max(0.01, dot(normalWS, -refractedDirWS));\n                float thickness = (0.05 + linearstep(1.5, 0.0, hitPosWS.y))/refractedRayDotNormal;\n              \n                vec3 refractedLight = oz.yyy;\n                //Apply refracted light\n                float islandIntersectT = sphIntersect(hitPosWS + oz.yxy * 0.05, refractedDirWS, kIslandSphereCenterWS,\n                                                kIslandSphereRadius).x;\n                \n                thickness = min(thickness, islandIntersectT > 0.0 ? islandIntersectT : 99999.0);\n                \n                vec3 refractedSkyColour = computeSkyColour(refractedDirWS, 0.0);\n                if(islandIntersectT > 0.0)\n                {\n                    vec3 refractedHitPos = hitPosWS + refractedDirWS * islandIntersectT;\n                    \n                    refractedLight = doLighting(refractedHitPos, refractedDirWS, kSandMatId, islandIntersectT);\n                    //No sky fade, we have water transmittance\n                    \n                    refractedLight = mix(refractedSkyColour, refractedLight, \n                                         exp(-islandIntersectT*0.1));\n                }\n                else\n                {\n                    refractedLight = refractedSkyColour;\n                }\n\n                vec3 waterInscatter = oz.yyy, waterTransmittance = oz.xxx;\n#if 1                \n                computeWaterInscatterTransmittance(refractedDirWS, max(0.0, thickness - 0.2), foamAmount,\n                                                   waterInscatter, waterTransmittance);\n#endif                \n\n                finalLighting += remainingLight * (1.0 - fresnelReflectance)*(waterInscatter + \n                    waterTransmittance * refractedLight);\n                \n                float skyFade = computeSkyTransmittance(intersectT, rayOriginWS, rayDirWS);\n                vec3 skyFadeColour = computeSkyFadeColour(rayDirWS);\n                \n                finalLighting = finalLighting * skyFade  + \n                    remainingLight * skyFadeColour * (1.0 - skyFade);\n\n                remainingLight *= fresnelReflectance;\n                remainingLight *= skyFade;\n                \n                rayDirWS = reflectedDirWS;\n\n                rayOriginWS = hitPosWS + normalWS * 0.1;\n\n                //Skip the reflection ray in the distance\n                if(intersectT > 150.0)\n                {\n                    break;\n                }\n            }\n            else\n            {               \n                vec3 skyColour = computeSkyFadeColour(rayDirWS);\n    \t\t\tvec3 sceneColour = skyColour;\n\n                float skyFade = computeSkyTransmittance(intersectT, rayOriginWS, rayDirWS);\n                sceneColour = doLighting(hitPosWS, rayDirWS, matId, 0.0);\n                sceneColour = mix(skyColour, sceneColour, skyFade);\n                \n                finalLighting = finalLighting + remainingLight*sceneColour;\n                remainingLight = oz.yyy;\n                \n                break;\n            }\n        }\n        else\n        {\n            break;\n        }\n    }\n\n\n\tvec3 skyColour = roughness >= 0.0 ? computeSkyColour(rayDirWS, roughness)\n        : computeSkyColour(rayDirWS);\n    \n    return finalLighting + remainingLight*skyColour;\n}\n\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n//////////////////////////// Cameras ////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////\n\nvec2 getScreenspaceUvFromRayDirectionWS(\n    vec3 rayDirectionWS,\n\tvec3 cameraForwardWS,\n\tvec3 cameraUpWS,\n\tvec3 cameraRightWS,\n\tfloat aspectRatio)\n{\n    vec3 eyeToCameraPlaneCenterWS = cameraForwardWS * kCameraPlaneDist;\n    // project rayDirectionWs onto camera forward\n    float projDist                 = dot(rayDirectionWS, cameraForwardWS);\n    vec3  eyeToPosOnCameraPlaneWS = rayDirectionWS / projDist * kCameraPlaneDist;\n    vec3  vecFromPlaneCenterWS       = eyeToPosOnCameraPlaneWS - eyeToCameraPlaneCenterWS;\n\n    float xDist = dot(vecFromPlaneCenterWS, cameraRightWS);\n    float yDist = dot(vecFromPlaneCenterWS, cameraUpWS);\n\n    xDist /= aspectRatio;\n    xDist = xDist * 0.5 + 0.5;\n    yDist = yDist * 0.5 + 0.5;\n\n    return vec2(xDist, yDist);\n}\n\nvoid computeCamera(float time, vec2 mouseNorm,\n                   out vec3 rayOriginWS,\n                   out vec3 cameraForwardWS,\n                   out vec3 cameraUpWS,\n                   out vec3 cameraRightWS\n                  )\n{\n#if BIRDS_EYE_VIEW  \n    float flyTime = time * kTimeScale * 0.1;\n    //walk head bob\n    float headBodUp = sin(flyTime * PI);\n    float headBobSide = cos(flyTime * 0.5 * PI);\n    \n    float dy = cos(flyTime * PI);\n    float dx = -sin(flyTime * PI * 0.5) * 4.0;\n    \n    float flapping = max(0.0, dy);\n    headBodUp += sin(time*11.0)*0.1*flapping*flapping;\n    \n\trayOriginWS = vec3( -1.0 + headBobSide * 4.0, 2.2 + headBodUp * 1.0, -40.0 );    \n#else\n    float walkTime = time * 1.5 * kTimeScale;\n    //walk head bob\n    float headBodUp = sin(walkTime*PI);\n    float headBobSide = cos(walkTime*0.5*PI);\n    \n    float dy = cos(walkTime * PI) * 0.025 * 0.5;\n    float dx = -sin(walkTime * PI * 0.5) * 0.05 * 0.5;\n    \n\trayOriginWS = vec3( -4.0 + headBobSide * 0.05, 1.8 + headBodUp * 0.025, -50.0 );\n#endif\n    \n    cameraForwardWS = normalize(vec3(dx, dy, kWalkRotationTimeScale * 2.0));\n    pR(cameraForwardWS.yz, mouseNorm.y * 0.25*PI);\n    pR(cameraForwardWS.xz, mouseNorm.x * PI);\n    cameraRightWS = normalize(cross(oz.yxy, cameraForwardWS));\n    cameraUpWS = normalize(cross(cameraForwardWS, cameraRightWS));\n    \n    rayOriginWS -= cameraForwardWS*kCameraPlaneDist*0.5;    \n}\n\n#define TAA 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float jitterAmount = step(iMouse.z, 0.01) * float(TAA);\n    \n    vec4 blueNoise = textureLod(iChannel2, fragCoord.xy/1024.0, 0.0).rgba;\n    vec2 subPixelJitter = fract(blueNoise.xz + float(iFrame%256) * kGoldenRatio * oz.xx) - 0.5*oz.xx;\n    \n\tvec2 uv = (fragCoord.xy + jitterAmount * subPixelJitter*0.5) / iResolution.xy;\n    \n    float aspectRatio = iResolution.x/iResolution.y;\n    vec2 uvNorm = uv * 2.0 - vec2(1.0);\n    uvNorm.x *= aspectRatio;\n    \n    vec2 mouseUNorm = iMouse.xy/iResolution.xy;\n    //Make sure the default (0, 0) mouse looks nice and centered\n    if(length(iMouse.xy) < 30.0 && iMouse.z < 1.0) \n    {\n        mouseUNorm = oz.xx*0.5;\n    }\n    vec2 mouseNorm = mouseUNorm*2.0 - vec2(1.0);\n\n    s_time = iTime - blueNoise.z * min(0.033, iTimeDelta);\n    \n    float prevTime = (s_time - iTimeDelta); \n    \n    \n    // ---- Camera setup ---- //\n    vec3 cameraForwardWS, cameraUpWS, cameraRightWS;\n    computeCamera(s_time, mouseNorm, s_eyePosWS, cameraForwardWS, cameraUpWS, cameraRightWS);\n    \n    s_pixelSpacingAtUnitLengthWS = (2.0 / kCameraPlaneDist) / iResolution.y;\n    \n    vec3 eyeToPosOnCameraPlaneWS = cameraForwardWS*kCameraPlaneDist + cameraRightWS*uvNorm.x\n        + uvNorm.y * cameraUpWS;\n     \n    vec3 rayDirWS = normalize(eyeToPosOnCameraPlaneWS);    \n    \n    // ---- Lens flare ---- //\n\t//Some weird idea about how lens flares are refracted light of a curved lens\n    //led to this. Almost definitively wrong, but gives interesting results.\n    float curvature = 1.0 - length(uvNorm)/aspectRatio;\n    vec3 lensNormal = normalize(rayDirWS*0.5 + cameraForwardWS*curvature);\n    vec3 refractedSunLight = refract(-kDirToSunWS, lensNormal, 1.0/1.8);\n    float flare = linearstep(0.9, 0.99995, dot(-refractedSunLight, rayDirWS));\n    s_flare = flare;\n    \n    // ---- Ray march ---- //\n    float intersectDist = kMaxDist;\n    float thisFrameTaaStrength = 0.0;\n    vec3 sceneColour = march(s_eyePosWS, rayDirWS, thisFrameTaaStrength, intersectDist);\n    \n    // ---- Reprojection ----//\n    //Compute the prev camera data\n    vec3 prevCameraPosWS, prevCameraForwardWS, prevCameraUpWS, prevCameraRightWS;\n    computeCamera(prevTime, mouseNorm, prevCameraPosWS, \n                  prevCameraForwardWS, prevCameraUpWS, prevCameraRightWS);\n    \n    vec3 currentRefPosWS = s_eyePosWS + rayDirWS * intersectDist;\n    currentRefPosWS = computeWalkRotatedPosWS(currentRefPosWS, iTimeDelta);\n    vec3 prevCameraRayDirWS = normalize(currentRefPosWS - prevCameraPosWS);\n    \n\n    //And work back to get the prev frame uv\n    vec2 prevFrameUv = getScreenspaceUvFromRayDirectionWS(prevCameraRayDirWS,\n    \tprevCameraForwardWS, prevCameraUpWS, prevCameraRightWS, aspectRatio);\n\tprevFrameUv = (prevFrameUv * iResolution.xy - jitterAmount * subPixelJitter) / iResolution.xy;    \n    \n\tsceneColour = min(2.0*oz.xxx, sceneColour); //Clamp to prevent noisy sun highlights\n    \n#if TAA    \n    float taaStrength = thisFrameTaaStrength;\n    vec4 prevData = textureLod(iChannel0, prevFrameUv, 0.0);\n\t\n    vec3 prevColour = prevData.rgb;\n    float prevTaaStrength = prevData.a;\n    \n    float blendToCurrent = mix(1.0, 1.0/8.0, taaStrength);\n    taaStrength = mix(prevTaaStrength, taaStrength, blendToCurrent);\n    blendToCurrent = mix(0.85, 1.0/8.0, taaStrength);\n    \n    vec2 outOfPrevTexture = max(oz.yy, abs(prevFrameUv-0.5*oz.xx) - 0.5*oz.xx);\n\tblendToCurrent = min(1.0, blendToCurrent + max(outOfPrevTexture.x, outOfPrevTexture.y) * 100.0);\n    \n    if(iMouse.z > 0.001)\n    {\n        blendToCurrent = 0.5;\n    }\n    \n    sceneColour = mix(prevColour, sceneColour, blendToCurrent);\n    \n    \n    fragColor.rgb = sceneColour;\n    fragColor.a = intersectDist;\n    fragColor.a = taaStrength;\n    \n#else\n    fragColor.rgb = sceneColour;\n#endif    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\nvec2 waveNoise(float time)\n{\n    return textureLod(iChannel0, vec2(time, time + kPI * 0.5), 0.0).rg*2.0 - oz.xx;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    //wave every 10s\n    float repTime = mod(time + 3.4, 10.0);\n    float waveStrength = smoothstep(0.0, 1.5, repTime) - smoothstep(1.5, 5.0, repTime);\n    \n    float waveNoiseTime = time * 1.5;\n    vec2 bluishNoise = waveNoise(waveNoiseTime*0.2) * 0.3;\n    bluishNoise \t+= waveNoise(waveNoiseTime*0.4) * 0.4;\n    bluishNoise \t+= waveNoise(waveNoiseTime*0.8) * 0.3;\n    vec2 waveCrashSound = bluishNoise * 0.3 * (0.05 + waveStrength);\n\n    return waveCrashSound;\n}","name":"Sound","description":"","type":"sound"}]}