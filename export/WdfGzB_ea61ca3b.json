{"ver":"0.1","info":{"id":"WdfGzB","date":"1546884856","viewed":159,"name":"Mandelbrot Orbit Traps","username":"oalpha","description":"Experimenting with coloring the mandelbrot set","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot","orbit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 complexMultiply( vec2 a, vec2 b )\n{\n    return vec2(dot(a, b * vec2(1.,-1.)), dot(a, b.yx));\n}\nvec2 complexPower( vec2 a, int power )\n{\n    vec2 o = vec2(1.,0.);\n    int i = 0;\n    while(i < power) {\n        complexMultiply(o, a);\n        i++;\n    }\n    return o;\n}\nvec2 mandelbrot(vec2 z, vec2 c, int power) {\n    return complexMultiply(z, z) + c;\n    //return complexPower(z, power) + c;\n}\nvec2 pinwheel(float t) {\n    float BIGF = .25;\n    float LITTLEF = .9;\n    BIGF *= 4.;\n    LITTLEF *= 4.;\t\n    float BIGR = 1.;\n    float LITTLER = .4;\n    BIGR *= 2.;\n    LITTLER *= 2.;\n    return (BIGR - LITTLER) * vec2(cos(BIGF * t), sin(BIGF * t)) +\n        LITTLER * vec2(cos(LITTLEF * t), sin(LITTLEF * t));\n}\n#define ITERATIONS 500\n#define modi(a, b) ((a) - ((a) / (b)) * (b))\nstruct linetrap {\n    vec2 base;\n    vec2 dir;\n    vec3 cola;\n    vec3 colb;\n    vec3 colc;\n    float weight;\n    int num;\n    float dist;\n    float mean;\n    float var;\n};\nstruct pointtrap {\n    vec2 point;\n    vec3 cola;\n    vec3 colb;\n    vec3 colc;\n    float weight;\n    int num;\n    float dist;\n    float mean;\n    float var;\n};\n    #define AA 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+vec2(float(m),float(n))/float(AA)))/iResolution.y;\n        float w = float(AA*m+n);\n        float time = iTime + 0.5*(1.0/24.0)*w/float(AA*AA);\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n        float time = iTime;\n#endif\n    \n        float zoo = 0.62 + 0.38*cos(.07*time);\n        float coa = cos( 0.15*(1.0-zoo)*time );\n        float sia = sin( 0.15*(1.0-zoo)*time );\n        zoo = pow( zoo,8.0);\n        vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\n        vec2 c = vec2(-.745,.186) + xy*zoo;\n        \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2. * fragCoord/iResolution.y - (iResolution.xy / iResolution.y);\n    float scale = 1.2;\n    scale = 5e-2;\n    vec2 shift = vec2(.5, 0.);\n    shift = vec2(1.4, .098);\n    uv = uv * scale - shift;\n        uv = c;\n    \n    vec2 z = uv, dz = vec2(0.);\n        /*\n        dz = vec2(1.);\n        uv = vec2(-.1,.7);\n        uv = vec2(-.79,.15);\n        uv = vec2(-.162,1.04);\n        uv = vec2(.3,-.01);\n        //uv = vec2(-1.476,.0);\n        //uv = vec2(-.12,-.77);\n        //uv = vec2(.28,.008);\n\t\t*/\n    int iterations = 0;\n    float bailout = 2.;\n    bailout = 2e5;\n    float bailoutradius = 0., bailoutiteration = 0.;\n    int power = 2;\n    float t = .59;\n    vec2 pointtrap = pinwheel(t);\n    vec2 linetrappoint = vec2(1., 0.);\n    t = 9.16;\n    //t = 0.;\n    linetrappoint = pinwheel(t);\n    vec2 linetrapdir = normalize(vec2(1., 1.));\n    float pointorbit = 1e10;\n    vec2 innerpointtrap = vec2(0.);\n    float innerpointorbit = 1e10;\n    \n    #define LINETRAPS 6\n    linetrap linetraps[LINETRAPS];\n    //*\n    for(int i = 0; i < 5; i++) {\n        float a = float(i - 2) * 3.14159 / (6. * 10.);\n        linetraps[i] = linetrap(\n            linetrappoint,\n            mat2(cos(a), sin(a), -sin(a), cos(a)) * linetrapdir,\n            //vec3(.5,0.,1.),\n            vec3(float(0xEE) / 255., float(0x78) / 255., float(0x6E) / 255.),\n            //.1 * vec3(1.,1.,0.),\n            vec3(float(0xA2) / 255., float(0xCC) / 255., float(0xB6) / 255.),\n            //vec3(0.,0.,1.),\n            vec3(float(0xEE) / 255., float(0x78) / 255., float(0x6E) / 255.),\n            .2,\n            0,\n            1e10,\n            0.,\n            0.\n        );\n    }\n\t//*/\n    t = 0.;\n    //*\n    linetraps[5] = linetrap(\n        pinwheel(t),\n        normalize(vec2(1., 2.)),\n        //vec3(0.,1.,1.),\n        vec3(float(0xFC) / 255., float(0xEE) / 255., float(0xB5) / 255.),\n        .0 * vec3(1.,0.,1.),\n        //vec3(0.,1.,0.),\n        vec3(float(0xFC) / 255., float(0xEE) / 255., float(0xB5) / 255.),\n        .5,\n        0,\n        1e10,\n        0.,\n        0.\n    );\n\t//*/\n    \n    while(iterations < ITERATIONS && length(z) < bailout) {\n        dz = 2. * complexMultiply(z, dz) + vec2(1.,0.);\n        z = mandelbrot(z, uv, power);\n        pointorbit = min(pointorbit, distance(pointtrap, z));\n        innerpointorbit = min(innerpointorbit, distance(innerpointtrap, z));\n        for(int i = 0; i < LINETRAPS; i++) {\n            vec2 ld = z - linetraps[i].base;\n            vec2 lp = dot(ld, linetraps[i].dir) * linetraps[i].dir;\n            float d = length(ld - lp);\n            linetraps[i].num = iterations;\n            linetraps[i].dist = min(linetraps[i].dist, d);\n            linetraps[i].mean =\n                float(iterations) / float(iterations + 1) * linetraps[i].mean +\n                1. / float(iterations + 1) * d;\n            linetraps[i].var += d * d;\n        }\n        iterations++;\n        if(iterations >= ITERATIONS || length(z) >= bailout) {\n            bailoutradius = length(z);\n            bailoutiteration = float(iterations);\n        }\n    }\n    for(int i = 0; i < LINETRAPS; i++)\n        linetraps[i].var = linetraps[i].var / float(linetraps[i].num) -\n        pow(linetraps[i].mean, 2.);\n\tfloat d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n    float escape = 1. - log(log(length(z))/log(bailout))/log(float(power));\n\n    // Output to screen\n    float minside = iterations < ITERATIONS ? 1. : 0.;\n    float cinside = length(uv) < 1. ? 1. : 0.;\n    \n    vec3 escapetimecolor = mix(vec3(0.), mix(\n        vec3(0.),\n        vec3(1., 0., 0.),\n        bailoutiteration / float(ITERATIONS)\n    ), minside);\n    vec3 distancecolor = mix(vec3(0.), mix(\n        vec3(1., 0., 0.),\n        vec3(0.),\n        pow(d, .125)\n    ), minside);\n    const int grade = 4;\n    const int cols = 7;\n    vec3 histogramcolors[grade * cols];\n    histogramcolors[0] = vec3(1.,0.,0.);\n    histogramcolors[grade] = vec3(1.,.5,0.);\n    histogramcolors[2 * grade] = vec3(1.,1.,0.);\n    histogramcolors[3 * grade] = vec3(0.,1.,0.);\n    histogramcolors[4 * grade] = vec3(0.,1.,1.);\n    histogramcolors[5 * grade] = vec3(0.,0.,1.);\n    histogramcolors[6 * grade] = vec3(1.,0.,1.);\n    for(int i = 0; i < cols; i++)\n        for(int j = 1; j < grade; j++)\n            histogramcolors[i*grade+j] = mix(\n                histogramcolors[i*grade],\n                histogramcolors[(i == cols - 1 ? 0 : i + 1)*grade],\n                float(j) / float(grade)\n            );\n    vec3 histogramcolor = mix(\n        vec3(0.),\n        histogramcolors[modi(iterations, grade * cols)],\n        minside\n    );\n    vec3 histogramcolora = histogramcolor;\n    vec3 histogramcolorb = mix(\n        vec3(0.),\n        histogramcolors[modi(iterations + 1, grade * cols)],\n        minside\n    );\n    bool useescape = true;\n    vec3 histogramcolori = mix(\n        histogramcolora,\n        histogramcolorb,\n        useescape ? escape : 1.\n    );\n    vec3 pointorbitcolor = mix(\n        vec3(0.),\n        mix(\n            //vec3(1.,0.,0.),\n            vec3(float(0xEE) / 255., float(0x78) / 255., float(0x6E) / 255.),\n            vec3(0.),\n            clamp(pointorbit, 0., 1.)\n        ),\n        minside\n    );\n    vec3 lineorbitcolor = vec3(0.);\n    for(int i = 0; i < LINETRAPS; i++)\n        lineorbitcolor += mix(\n            vec3(0.),\n            mix(\n                mix(\n                    linetraps[i].cola,\n                    linetraps[i].colc,\n                    log(float(linetraps[i].num + 1)) / log(float(ITERATIONS))\n                ),\n                linetraps[i].colb,\n                //linetraps[i].dist\n                clamp(linetraps[i].dist, 0., 1.)\n                //clamp(log(linetraps[i].mean)/log(bailout), 0., 1.)\n            ),\n            minside\n        ) * linetraps[i].weight;\n    vec3 innerpointorbitcolor = mix(\n        mix(\n            1.5 * vec3(float(0xFC) / 255., float(0xEE) / 255., float(0xB5) / 255.),\n            -2. + vec3(float(0xEE) / 255., float(0x78) / 255., float(0x6E) / 255.),\n            clamp(innerpointorbit, 0., 1.)\n        ),\n        vec3(0.),\n        minside\n    );\n    float shade = 1.;\n    fragColor = vec4(\n        vec3(minside) * vec3(1., 1. - cinside, 1. - cinside) * shade,\n        1.0\n    );\n    fragColor = vec4(escapetimecolor * shade,1.0);\n    fragColor = vec4(distancecolor * shade,1.0);\n    fragColor = vec4(histogramcolor * shade,1.0);\n    fragColor = vec4(histogramcolori * shade,1.0);\n    //*\n    fragColor = vec4(pointorbitcolor * shade,1.0);\n    fragColor = vec4(lineorbitcolor * shade,1.0);\n    fragColor = vec4((pointorbitcolor + lineorbitcolor + innerpointorbitcolor) * shade,1.0);\n    //fragColor = vec4(vec3(linetraps[2].dist) * shade,1.0);\n\t//*/\n}","name":"Image","description":"","type":"image"}]}