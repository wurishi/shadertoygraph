{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"float heartCurve(vec3 v) {\n    float d = dot(v,v)-1.0;\n\treturn d*d*d - v.x*v.x*v.y*v.y*v.y;\n}\n\nvec3 shadeBg(vec3 nml)\n{\n    vec3 lightPos_ = vec3( sin(iTime)*0.1, -0.15+0.0*cos(3.14159*0.5+iTime/3.14159*2.0)*0.15, 1.0 );\n//        -cos(iTime*0.1)*-8.5,\n//        3.5+sin(iTime*0.05)*3.0,\n//        -(sin(iTime*0.1)*4.0-5.4)\n//    );\n    vec3 bgLight = normalize(lightPos_);\n    vec3 lightPos = bgLight * 9999.0;\n    vec3 sun = vec3(5.0, 3.5, 6.0)*0.03;\n\n\tvec3 bgCol = vec3(0.5, 0.15, 0.4)*1.3;\n\tfloat bgDiff = dot(nml, vec3(0.0, 1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tbgCol += 0.1*sun*pow( max(sunPow, 0.0), 2.0);\n\tbgCol += 0.3*bgDiff*vec3(0.4, 0.1, 0.2);\n\tbgCol += sun*pow( max(sunPow, 0.0), abs(bgLight.y)*256.0);\n\tbgCol += bgCol*pow( max(sunPow, 0.0), abs(bgLight.y)*128.0);\n    \n    if (nml.z > 0.0) {\n        float r = max(0.0, 0.1*-tan(-0.25*3.14159+iTime/3.14159*8.0)+0.9);\n        //float d = heartCurve(r*vec3(nml.xy*vec2(2.5,-2.5)+vec2(0.0,0.15), 0.0)); \n        float d = dot(nml, vec3(0.0,0.0,1.0));\n        float r1 = r/0.8;\n        float r0 = r*0.7;\n        //float r1 = 0.05, r0 = -0.05;\n        if (d < r1 && d > r0) {\n            //d = 0.24; \n            d = 0.5 - (smoothstep(d, r0, r0+(r1-r0)/2.0)+smoothstep(d, r1, r0+(r1-r0)/2.0));\n            d *= 2.0;\n            d = d*d*d;\n            d *= 0.5;\n        } else {\n            d = 0.0;\n        }\n        bgCol += vec3(0.8, 0.2, 0.8) * d;\n    }\n    \n\treturn max(vec3(0.0), bgCol);\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);  \n}\n\nfloat heart(vec3 v) {\n    vec3 v2 = v*v;\n    float v3 = v2.x + (9.0/4.0)*v2.y + v2.z - 1.0;\n    float t = -( v2.x*v2.z*v.z + (9.0/80.0)*v2.y*v2.z*v.z ) + v3*v3*v3;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (0.5 - uv) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    float a = sin(8.0*iTime/3.53423)*0.5;\n    float ca = cos(a), sa = sin(a);\n    uv *= mat2(ca, sa, -sa, ca);\n    mat3 rot = rotationMatrix(normalize(vec3(1.0, 0.0, 0.25*sa)), 3.14159*0.5);\n    float scale = (-0.8*abs(sin(8.0*iTime/3.14159))+1.4);\n    rot *= scale;\n    vec3 ro = vec3(0,0,-3.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    ro += rd * 2.5;\n    vec3 transmit = vec3(1.0);\n    \n    for (int i=0; i<30; i++) {\n        vec3 v = rot*(ro+vec3(0.0, -0.35, 0.0));\n        float t = heart(v);\n        if (t < 0.0) {\n            vec3 nml = normalize(ro*vec3(1., 1., 3.4/scale));\n\t\t\tfloat f = 1.0-abs(dot(normalize(ro), rd));\n            f = f*f;\n            rd = normalize(mix(reflect(rd, nml), rd, f));\n            transmit = 1.25*vec3(1.0, 0.4, 0.5);\n            break;\n        } else {\n        \tro += rd * 0.015;\n        }\n    }\n\tfragColor = vec4(transmit*shadeBg(rd), 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4lsGRf","date":"1423879090","viewed":139,"name":"heartbounce","username":"kig","description":"Bouncing heart anim for 2015-02-14 #shadeADay","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["heart","shadeaday"],"hasliked":0,"parentid":"","parentname":""}}