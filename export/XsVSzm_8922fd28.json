{"ver":"0.1","info":{"id":"XsVSzm","date":"1464597280","viewed":156,"name":"Satori Plasma (Not Yet Cube)","username":"JasonD","description":"Inspired by Satori (After Dark).\nCode comments has full inspiration.\nMOUSE: Click & hold up/down = change no. of patterns.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["generator","points","focal","disturbance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Jason Allen Doucette\n// http://xona.com/jason/\n//\n// Satori Plasma Cube\n// May 30, 2016\n//\n// INSPIRATION:\n// 1. Satori, After Dark screensaver.[1]\n// 2. [2]My own recreation of Satori in Turbo Pascal.\n// 3. Future Crew's Second Reality demoscene demo, [3]plasma cube effect.\n//\n// THE MAIN IDEA:\n// Back in 1993-95, I remade Satori, and it took ~60 minutes to make a pre-rendered graphic,\n// that I could palette shift.  I pondereed (with amazement that it would indeed be true) that\n// one day we would have computers SO fast that I could do it in real time, with no palette \n// shifting (meaning the point sources could be moving dynamically), on the side of a cube, \n// with perspective correct texture mapping, at full frame rate, at full resolution.\n//\n// Today, we are there.\n// However, this is just the texture; not yet the cube, which I will get to one day. :)\n//\n// [1]Satori still exists today!  \n//    http://www.sticksoftware.com/software/Satori.html\n//\n// [2]Recreated myself in Turbo Pascal, using the IBM 8514 driver, for 1280x1024 x 256 color mode.\n// Early 90's: monitors in those days were a blur of pixels, so a checkboard patter was very hard\n// to see, if noticeable at all.  It took something like 30 or 60 minutes to render a full screen.\n\n// [3]Future Crew heavily cheated to make that amazing effect.  These are all of the cool things\n// they did, from my own analysis.  I've never checked the source code to verify (it's now\n// online, 20 years later):\n// 1. Changed the scan repeat from 3 to 2, so that the 400 scans of 320x200 mode produced 133 lines\n//    rather than 200.  That's a 66% of the normal total of calculations.\n// 2. They texture mapped 4 pixels at a time.  But off-shifted this by 2 pixels every frame, so it'd\n//    flicker back and forth.  Because it was a plasma texture being rendered, they could do this.\n//    Thus only 80 columns to render, not 320.  That's 25% of the normal total calculations.\n//    Of course the polygon edges were still 320.  Mode-X allows 4-pixel writes with a single write.\n// 3. Plasma was a simple texture that distorted in one axis, which easy to do; just change an offset.\n//    In fact, it could have been a simple math formula, which may have been even faster than the\n//    texture lookup (due to caching reasons).  Either way, the plasma was *simple*.  If it was a\n//    texture, it could be changed and used for all 3 visible sides.\n// 4. Affine tetxure mapping (constant du,dv during the scan), not perspective correct.  Again, because\n//    of the plasma, this was OK.\n// 5. Light source shading, by keeping the three colored sides using different palettes, which also\n//    allowed them to show different color plasmas on the sides.\n\n// ---- SETTINGS ----------------------------------------------------\n\n#define MAX_PATTERNS 3\n#define NUM_KNOTS 7\n#define KIND_MIN 1\n#define KIND_MAX 3\n\n// TOOD -- THE ORIGINAL HAD COOLER PALETTES THAN BORING R, G, B. \n//         IMPLEMENT THESE, AND THINK OF A WAY TO COMBINE THEM WITHOUT DILUTING THE COLORS.\n//         LIKELY VIA CAMERA LIGHT LOG/POWER FUNCTION (HOW FILM WORKS FOR IMAGES).\n// TODO -- THE ORIGINAL PALETTE SHIFTED, SO THESE \"SOURCES\" SHOULD HAVE A \"SPEED\".\n// TODO -- SOME \"SOURCE\" KINDS COULD HAVE A STRENGTH, FOR THE MULTIPLIER, \n//         OR THE # OF FANS FOR ANGLES, ETC.\n\n// ---- CONSTANTS ----------------------------------------------------\n\n#define PI 3.141592653589793238462643383\n\n// ---- STRUCTS ----------------------------------------------------\n\nstruct Knot\n{\n    // needed globally:\n    vec2 source;\n    \n    // these two aren't needed globally:\n    //float direction; // +1 or -1\n    //int kind;\n};\n\n// ---- GLOBALS ----------------------------------------------------\n\nKnot g_knot;\nvec2 g_uv;\n\n// ---- METHODS ----------------------------------------------------\n\nfloat noise(vec2 co) {\n    // SOURCE: https://www.shadertoy.com/view/XtX3D4\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat smoothAbs(float x) {\n    float a = 1. - (1. / (abs(x) + 1.)); // 0..1 for x = 0..infinity\n    return mix(x*x, abs(x), a);\n}\n\n// ==== MY ORIGINAL TURBO PASCAL PATTERNS =====================================================\n\nfloat getPer_kind1(vec2 diff) {\n    // Turbo Pascal Kind 1 \n    // circle waves\n    return sqrt(sqrt( \n        sqrt(diff.x*diff.x + diff.y*diff.y)  /*  *mix  */\n    )) * 4.;\n}\n\nfloat getPer_kind2(vec2 diff) {\n    // Turbo Pascal Kind 2 \n    // y=1/x graph waves\n    /*\n    // these have 1st order derivative discontinuities:\n\t// (I didn't consider this, since they didn't move in real-time\n\t// in my original 1280x1024x256color demo!)\n    return (\n        // 1.\n        //abs(diff.x) * abs(diff.y) // all positive - TURBO PASCAL ORIGINAL\n        // 2.\n        //diff.x * diff.y // looks the same, but it goes negative as well!\n    ) * 4.;\n\t*/\n    \n    // 1st order derivative continuous:\n\n    // 3. works but due to x^2, it quickly repeats rapidly\n    /*\n    return (\n        diff.x * diff.x * diff.y * diff.y\n    ) * 7.;\n\t*/\t\n    \n    // my attempt to make a smooth abs() function, and use it, like the ORIGINAL:\n    // (this is why I made: https://www.shadertoy.com/view/ldyXD1 )\n    return (\n        smoothAbs(diff.x) * smoothAbs(diff.y)\n    ) * 3.;    \n}\n\nfloat getPer_kind3(vec2 diff) {\n    // Turbo Pascal Kind 3\n    // clock angle waves\n    \n    // TODO -- this could be an attribute of the knot:\n    #define NUM_CYCLES 3.0 \n    // TODO -- also the spin rate.. could have a dAngle added to it... actually\n    //         the time of the knot does this.\n    \n    float angle = atan(diff.y, diff.x); // -PI..+PI;\n    float per = (\n        (angle / PI) // -1..+1\n       \t+ 1. // 0..2\n        ) * (0.5 * NUM_CYCLES); // 0..NUM_CYCLES\n    return per;\n}\n\n// ==== NEW PATTERNS 2016 =====================================================\n\nfloat getPer_kind4(vec2 diff) {\n    return 0.0;\n}\n\n// ==== PALETTES =====================================================\n\nvec3 getColorFromPer_pattern1(float per) {\n    // per = 0..1\n    if (per >= 0.5) {\n        per = 0.5 - (per - 0.5);\n    }\n    per *= 2.0; // 0..1 (for the half)\n    return vec3(per, 0, 0);\n}\n\nvec3 getColorFromPer_pattern2(float per) {\n    // per = 0..1\n    if (per >= 0.5) {\n        per = 0.5 - (per - 0.5);\n    }\n    per *= 2.0; // 0..1 (for the half)\n    return vec3(0, 0, per);\n}\n\nvec3 getColorFromPer_pattern3(float per) {\n    // per = 0..1\n    if (per >= 0.5) {\n        per = 0.5 - (per - 0.5);\n    }\n    per *= 2.0; // 0..1 (for the half)\n    return vec3(0, per, 0);\n}\n\n\n// =========================================================\n\n// ---- CODE ----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // ---- init\n    \n    // isotropic scaling\n    // UV = 0..1 for X and Y guaranteed,\n    // likely with X going a bit further past 1 (due to widescreen).\n    float minRes = min(iResolution.x, iResolution.y);\n    g_uv = fragCoord / minRes;\n    \n \t// get center\n    vec2 center = (iResolution.xy / minRes) / 2.0;\n    \n    // and center UV\n    // now UV = -0.5..+0.5 for X and Y,\n    // with x likely going further (due to widescreen)\n    g_uv = center - g_uv;\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    // ---- mouse\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    int NUM_PATTERNS = 1 + int(mouse.y * (float(MAX_PATTERNS) - 0.001));\n    if (iMouse.z < 0.5) {\n        NUM_PATTERNS = 2;\n    }\n    \n    // ---- set up the knots\n    \n    // typically, this would be done in an init() function,\n    // and only updated where needed.\n    \n    vec3 color = vec3(0.);\n    \n    for (int p=0; p<MAX_PATTERNS; p++) {\n        \n        // mouse controls number of patterns to show\n        if (p >= NUM_PATTERNS) {\n            break;\n        }\n    \tfloat pp = float(p); // convenience\n        \n        float per = 0.; // distance into color palette, thought of from 0..1\n        // but extends beyond that; it repeats.  So the final calculation is\n        // the fract() of this.\n        \n        // we can reuse the same array for every pattern\n    \tfor (int knot=0; knot<NUM_KNOTS; knot++) {\n\t    \tfloat kk = float(knot); // convenience\n            \n            // constants\n            // NOTE: noise(vec2(0,0)) makes 0.\n            float c1 = noise(vec2(+pp+34.5972,+kk+49.3152));\n            float c2 = noise(vec2(+pp+97.6723,-kk+45.1903));\n            float c3 = noise(vec2(-pp+51.5890,+kk+04.6721));\n            float c4 = noise(vec2(-pp+13.9623,-kk+52.9513));\n            float c5 = noise(vec2(+kk+82.5982,+pp+59.0153));\n            float c6 = noise(vec2(+kk+16.2986,-pp+31.6972));\n            float c7 = noise(vec2(-kk+72.4502,+pp+41.5372));\n            \n            // two time steps, for X and Y calculations,\n            // to ensure sin() and cos() are out of sync\n            // for every knot.\n            float t1 = (iTime * c1) * 0.26346;\n            float t2 = (iTime * c2) * 0.32353;\n            \n            // size of cos() and sin() waves\n            // 0.0..0.5, since it's used as a dx,dy from the center (0.5,0.5)\n            // except considering wide-screen aspect ratio\n            float m1 = (0.35 + 0.1 * cos(c3)) * aspect;\n            float m2 = (0.35 + 0.1 * sin(c4));\n\n            // move points dynamically\n            g_knot.source = vec2(\n                cos(t1) * m1,\n                sin(t2) * m2\n            );\n      \n            int numKinds = (KIND_MAX - KIND_MIN + 1);\n            int kind = KIND_MIN + int(c7 * (float(numKinds) - 0.001));\n            float directionSign = floor(c5 * 1.999) * 2. - 1.; // +1 or -1\n            \n            vec2 diff = g_uv - g_knot.source;\n\n            float perChange = 0.;\n\t        // -----------------------------------------\n                   if (kind == 1) {\n            \tperChange += getPer_kind1(diff); // 0..1, or so\n            } else if (kind == 2) {\n            \tperChange += getPer_kind2(diff); // 0..1, or so\n            } else if (kind == 3) {\n            \tperChange += getPer_kind3(diff); // 0..1, or so\n            } else if (kind == 4) {\n            \tperChange += getPer_kind4(diff); // 0..1, or so\n            }\n\t        // -----------------------------------------\n            \n            // time for each knot\n            float tknot = (sin(c6) + 1.) * 0.5 // 0..1 (random)\n                * 0.125; // multiplier\n           \n            per += (perChange + iTime * tknot) * directionSign;\n    \t}\n        \n        per = fract(per); // 0..1\n        // -----------------------------------------\n               if (p == 0) {\n        \tcolor += getColorFromPer_pattern1(per);\n        } else if (p == 1) {\n        \tcolor += getColorFromPer_pattern2(per);\n        } else if (p == 2) {\n        \tcolor += getColorFromPer_pattern3(per);\n        }\n        // -----------------------------------------\n    }\n    \n    //color /= float(NUM_PATTERNS);\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}