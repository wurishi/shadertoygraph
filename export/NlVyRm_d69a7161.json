{"ver":"0.1","info":{"id":"NlVyRm","date":"1661179536","viewed":187,"name":"Electromagnetic Field","username":"romeosoft","description":"Can algorithms make math easier?\n\nI define an electromagnetic force field in the Y-axis direction, \nand its scalar part exhibits an inverse square distribution near the Zero Point\nNote: This field does not exist in reality!\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["physics","electromagnetic","gaugefield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n                          .-''--.\n                         _`>   `\\.-'<\n                      _.'     _     '._\n                    .'   _.='   '=._   '.\n                    >_   / /_\\ /_\\ \\   _<\n                      / (  \\o/\\\\o/  ) \\\n                      >._\\ .-,_)-. /_.<\n                          /__/ \\__\\\n                            '---'  \n            \n          “If I can’t picture it, I can’t understand it.”\n*/\n// =========================================================\n// Electromagnetic Field And 3D Image\n// =========================================================\n#define resolution_3d\t0.02 \n#define depth_of_field\t100\n#define draw_strength_E\t0.002\n#define draw_strength_B\t0.004\n\n// ---------------------------------------------------------\n// Electromagnetic Field:\n// I define an electromagnetic force field in the Y-axis direction, \n// its scalar part exhibits an inverse square distribution near the Zero Point.\n// Note: This field does not exist in reality!\n\n// I prefer the equations in Maxwell's original form:\n// Q = Fai + |A>\n// ---------------------------------------------------------\n// Eigen Electromagnetic Field Define\n\n// The Scalar Part\nfloat Fai(vec3 p, float t)\n{\n    float r = length(p);\n    if(r < 0.001)\n        r = 0.001;\n\treturn (1.0 / (r*r)) * (cos(t*0.25)); \n}\n// The Vector Part\nvec3 A(vec3 p, float t) {\n    float r = length(p.xz);\n    if(r < 0.001)\n        r = 0.001;\n    return vec3(0.0,1.0,0.0) * (10.0*sin(t*0.25) / (r)); \n}\n\n// ---------------------------------------------------------\n// E/B Field in default coordinate system\n// ---------------------------------------------------------\nvec3 get_Efield(vec3 p, real t)\n{  \n\treturn GRAD_V(Fai, p, t) - DT(A, p, t); \n}\nvec3 get_Bfield(vec3 p, real t)\n{  \n\treturn coord_ax_cross(default_coord, GRAD_C(A, p, t));\n}\n\n// ---------------------------------------------------------\n// 3D Image\n// ---------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pp = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    float eyer = 0.5;\n    float eyea = -((iMouse.x) / iResolution.x) * PI * 2.0;\n    float eyef = ((iMouse.y / iResolution.y) - 0.24) * PI * 2.0;\n    \n\tvec3 cam = vec3(\n        eyer * cos(eyea) * sin(eyef),\n        eyer * cos(eyef),\n        eyer * sin(eyea) * sin(eyef));\n         \n    ROT(cam.xz, (0.25) * (iTime + 15.0)); // auto rotation\n    \n\tvec3 front = normalize(- cam);\n\tvec3 left = normalize(cross(normalize(vec3(0.0,1,-0.001)), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 v = normalize(front + left*pp.x + up*pp.y);\n   \n    vec3 p = cam;\n\t\n\t// Default Coordinate System\n    default_coord.ux = vec3(1.0,0.0,0.0);\n    default_coord.uy = vec3(0.0,1.0,0.0);\n    default_coord.uz = vec3(0.0,0.0,1.0);\n    \n    float dt = resolution_3d;\n    vec3 cor1 = vec3(0.0);\n    vec3 cor2 = vec3(0.0);\n\t\n    float t = 0.5 * SEC;\n    for(int i = 0; i < depth_of_field; i ++)\n    {\n\t\tcor1 += (get_Bfield(p, t))*draw_strength_B;\n        cor2 += (get_Efield(p, t))*draw_strength_E;\n        \n        p += v * dt;\n    }\n    \n    fragColor = vec4(\n\t\tsin(cor1+cor2),\t// MAKE it pretty!\n\t\t1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Using procedural algorithms should not be a numerical tool of mathematics,\n// Program algorithms should be calculated in it's own form.\n\n/** I think the physical formula is made up of several parts:\n\t\t\t\n\t\t\tGauge * EigenNumbers * Dimension\n\n 1) Coordinate System is a simple form of Gauge.\n 2) Quaternions are typical EigenNumbers.\n 3) Dimension is related to measurement and is the bridge between mathematics and physics.\n*/\n\n#define real float\n#define ROT(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n#define deta_d 0.0001\n#define deta_t 0.01\n\n// ---------------------------------------------------------\n// Coordinate System:\n// A coordinate system in three-dimensional space \n// consists of an origin plus three orientation axes \n// ---------------------------------------------------------\nstruct coord3\n{\n   vec3 ux,uy,uz; // three axial unit vectors\n   vec3 o;        // origin\n};\ncoord3 create_coord(vec3 _ux, vec3 _uy, vec3 _uz)\n{\n    coord3 c;c.ux = _ux;c.uy = _uy; c.uz = _uz;\n    return c;\n}\n// mul: define this vector in a coordinate system\nvec3 coord_mul (vec3 p, coord3 c)\n{\n\treturn c.ux * (p.x) + c.uy * (p.y) + c.uz * (p.z) + c.o;\n}\n// div: measure this vector in a coordinate system\nvec3 coord_div (vec3 p, coord3 c)\n{\n    vec3 v = p - c.o;\n    return vec3(dot(v,c.ux), dot(v,c.uy), dot(v,c.uz));\n}\n// axes's dot\nreal coord_ax_dot(vec3 v, coord3 c)\n{\n\treturn dot(v, (c.ux + c.uy + c.uz));\n}\n// axes's cross\nvec3 coord_ax_cross(coord3 a, coord3 b)\n{\n    return vec3(\n        dot(a.uy,b.uz) - dot(a.uz,b.uy),\n        dot(a.uz,b.ux) - dot(a.ux,b.uz),\n        dot(a.ux,b.uy) - dot(a.uy,b.ux)\n    );\n}\n// flip x\ncoord3 flipx_coord(coord3 c)\n{\n    c.ux = -c.ux;\n    return c;\n}\n// flip y\ncoord3 flipy_coord(coord3 c)\n{\n    c.uy = -c.uy;\n    return c;\n}\n// flip z\ncoord3 flipz_coord(coord3 c)\n{\n    c.uy = -c.uy;\n    return c;\n}\ncoord3 default_coord;\t\t// The Default Coordinate System\n\n// ---------------------------------------------------------\n// GRAD, DT\n// ---------------------------------------------------------\n#define GRAD_V(Fai, p, t) \\\n        vec3((Fai(p + vec3(deta_d,0.0,0.0), t) - Fai(p, t)) / deta_d,\\\n        (Fai(p + vec3(0.0,deta_d,0.0), t) - Fai(p, t)) / deta_d, \\\n        (Fai(p + vec3(0.0,0.0,deta_d), t) - Fai(p, t)) / deta_d)\n\n#define GRAD_C(A, p, t) \\\n    create_coord( \\\n    (A(p + vec3(1.0,0.0,0.0) * deta_d, t) - A(p, t)) / deta_d, \\\n    (A(p + vec3(0.0,1.0,0.0) * deta_d, t) - A(p, t)) / deta_d, \\\n    (A(p + vec3(0.0,0.0,1.0) * deta_d, t) - A(p, t)) / deta_d)\n    \n#define DT(A, p, t) (A(p,t + deta_t) - A(p, t)) / deta_t\n\n\n// ---------------------------------------------------------\n// Quaternion:\n// Quaternions are real mathematics numbers, \n// meaning there is number theory behind them.\n// ---------------------------------------------------------\nstruct quaternion\n{\n   real w,x,y,z;\n};\nquaternion angax_q(real ang, vec3 ax)\n{\n    quaternion q;\n    real halfang = 0.5 * ang;\n    real fsin = sin(halfang);\n    q.w = cos(halfang);\n    q.x = fsin * ax.x;\n    q.y = fsin * ax.y;\n    q.z = fsin * ax.z;\n    return q;\n}\nquaternion qmul (quaternion q1, quaternion q2)\n{\n\tquaternion q;\n    \n\tq.w = q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z;\n\tq.x = q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y;\n\tq.y = q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z;\n\tq.z = q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x;\n\treturn q;\n}\nquaternion qrot(quaternion q, real ang, vec3 ax)\n{\n\tquaternion qt = angax_q(ang, ax);\n\treturn qmul(q, qt);\n}\n\n// ---------------------------------------------------------\n// Dimension or Const:\n// Dimensions and constants define our physical world!\n// ---------------------------------------------------------\n#define PI 3.1415926535\n#define MET 1.0\n#define SEC 0.5\n","name":"Common","description":"","type":"common"}]}