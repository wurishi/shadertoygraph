{"ver":"0.1","info":{"id":"dt3Xzj","date":"1685572624","viewed":120,"name":"Where are they all going?","username":"chronos","description":"I have no idea what I'm doing :)","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["blobs","sdf","domain","colorful","sphere","repetition","glow","tracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.28318\n\nfloat hash(float x)\n{\n    uint y = floatBitsToUint(x) | 1u;\n    \n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    uint z = ((y>>9) & 0x007FFFFFu) | (0xFF800000u & floatBitsToUint(.5));\n    \n    return 2. * uintBitsToFloat(z) - 1.;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat map(vec3 p)\n{\n    float d = length(p) - 0.2; // sphere SDF\n    const int N = 8;\n    for(int i = 0; i < N/2; ++i)\n    {\n        float  angle = TAU * float(i)/float(N) + iTime;\n        vec3 offset = 0.25 * vec3(sin(angle), 0., cos(angle));\n        float l = (length(p + offset), distance(p, offset));\n        l = smin(l, min(length(p + offset.yxz), distance(p, offset.yxz)),.15);\n        l = smin(l, min(length(p + offset.zxy), distance(p, offset.zxy)),.15);\n        d = smin(d, l - 0.05, .15);\n    }\n    return d;\n}\n\nvec3 palette(float t)\n{\n    return .5 + .5 * cos(TAU * (t+vec3(0.263, 0.416, 0.557)));\n}\n\nmat2 rot2(float phi)\n{\n    float c = cos(phi);\n    float s = sin(phi);\n    return mat2(c, s, -s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 jitter =  vec2(hash(fragCoord.x+iTime), hash(fragCoord.y + 28376. + iTime)) - vec2(0.5);\n    vec2 uv = ( 2. * (fragCoord + 0.5 * jitter) - iResolution.xy)/iResolution.y;\n    vec2 mouse = ( 2. * iMouse.xy - iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    vec3 rd = normalize(vec3(uv, -2.));\n    vec3 ro = vec3(0.1 - 0.2 * sin(iTime), 1. + 0.1 * cos(iTime),2. + iTime);\n    \n    rd.yz = rot2(mouse.y) * rd.yz;\n    rd.xz = rot2(mouse.x) * rd.xz;\n    \n    const int max_iter = 50;\n    const float eps = 0.0005;\n    \n    float t = 0.;\n    for(int i = 0; i < max_iter; ++i)\n    {\n        vec3 p = t * rd + ro;\n        \n        vec3 rep = mod(p-2., 4.) -2.; // Domain repetition\n        vec3 cell = (p - rep) / 2.;\n        \n        p = rep;\n        \n        float cell_variance = sin(iTime + cell.z + sin(cell.x) + 0.5 * cos(cell.y));\n        p.xy = rot2(iTime + cell_variance) * p.xy;\n        \n        vec3 wobble = vec3(0,0.15*cell_variance, 0.);\n        float d = map(p + wobble);\n        \n        t += d * 0.8; // factor helps with inaccurate distance artifacts and glow smoothness\n                \n        col += exp(-d * 5.0 -t * 0.5) * palette(t);\n        \n        col *= 0.99; // can make distance spheres more visible through glows, but looks a bit (more) non-physical\n        \n        if(d < eps) break;\n    }\n\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}