{"ver":"0.1","info":{"id":"3dccR8","date":"1605856380","viewed":89,"name":"RayMarchingTemplate1","username":"treize","description":"RayMarchingTemplate","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITERATION_NUM 99\n\nfloat map(vec3 rayPos) \n{\n    float d=sdBox(rayPos+vec3(0.0,0.15,0.0), vec3(2.1,0.1,2.1));\n    d=\topUnion(d,sphere(rayPos+vec3(0.0,-0.9,0.0), 0.3));\n \td=\topUnion(d,sphere(rayPos+vec3(0.9,-0.9,0.0), 0.3));\n    d=\topUnion(d,sphere(rayPos+vec3(-0.9,-0.9,0.0), 0.3));\n    d=\topUnion(d,sphere(rayPos+vec3(0.0,-0.9,1.8), 0.3));\n    d=\topUnion(d,sphere(rayPos+vec3(0.9,-0.9,1.8), 0.3));\n    d=\topUnion(d,sphere(rayPos+vec3(-0.9,-0.9,1.8), 0.3));\n    d=\topUnion(d,sphere(rayPos+vec3(0.0,-0.9,0.9), 0.3));\n    d=\topUnion(d,sphere(rayPos+vec3(0.9,-0.9,0.9), 0.3));\n    d=\topUnion(d,sphere(rayPos+vec3(-0.9,-0.9,0.9), 0.3));\n\treturn d;\n}\n\nvec3 getnormal(vec3 p)\n{\n    vec2 e =vec2(0.00001,0.0);\n    return normalize(vec3(\n        sphere(p+e.xyy,0.1)-sphere(p-e.xyy,0.1),\n        sphere(p+e.yxy,0.1)-sphere(p-e.yxy,0.1),\n        sphere(p+e.yyx,0.1)-sphere(p-e.yyx,0.1)\n    ));\n}\nvec3 lighting(vec3 p,vec3 lp,vec3 lc)\n{\n    vec3 normal=getnormal(p);\n    vec3 lightdir=normalize(lp);\n    float NdotL = max(dot(lightdir,normal),0.0);\n    vec3 col = vec3(NdotL)+lc;\n    return col;\n}\nvec3 raymarch(vec3 rayOrigin, vec3 rayDirection) \n{\n\tvec3 rayPos,col = vec3(0.0);\n\tfloat depth = 0.0;\n\tfor(int i=0; i<ITERATION_NUM; i++) \n\t{\n        rayPos=rayOrigin+rayDirection*depth;\n\t\tfloat d = map(rayPos);\n\t\tif(d<0.01)\n\t\t{\n            col+=lighting( rayPos,vec3(cos(iTime),0.0,sin(iTime)),vec3(0.5,0.5,0.5));\n\t\t    break;\n\t\t}\n\t\tdepth += d;\n\t}\n\treturn col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 origin = vec3(0.0, 3.0, -5.0);\n    vec3 target = vec3(0.0);\n    float rotate=0.0;\n    float screen_z=3.5;\n    mat3 camera = SetCamera(origin, target, rotate);\n    vec3 rayDirection = camera * normalize(vec3(p, screen_z));\n\tvec3 col=raymarch(origin , rayDirection);    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float pi = acos(-1.0);\n\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat sphere(vec3 rayPos, float r) \n{\n    float d=length(rayPos)-r;\n\treturn d;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nmat3 SetCamera(in vec3 origin, in vec3 target, float rotation)\n{\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}","name":"Common","description":"","type":"common"}]}