{"ver":"0.1","info":{"id":"mltczX","date":"1699512242","viewed":109,"name":"Dolphin_Remap_Blur","username":"dolphin","description":"Remap implementation, blur along the x axis","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["glsl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926538\n// uv: normalized uv map\n// pos: offset with respect to the center\n// w: width of the rectangle\n// h: height of the rectangle\n// blur: outside blur amount\nfloat Rectangle(vec2 uv, vec2 pos, float w, float h, float blur)\n{\n    vec2 center = uv-pos;\n    float wid = center.x;\n    float hei = center.y;\n    \n    // width part calculation\n    float c1 = smoothstep(-w/2.0-blur, -w/2.0+blur, wid);\n    float c2 = smoothstep(w/2.0-blur, w/2.0+blur, wid);\n    float c3 = c1-c2;\n    \n    // height part calculaion\n    float c4 = smoothstep(-h/2.0-blur, -h/2.0+blur, hei);\n    float c5 = smoothstep(h/2.0-blur, h/2.0+blur, hei);\n    float c6 = c4-c5;\n    \n    // interaction\n    return c3*c6;\n}\n\n\n// take a shape value, output 1 if c>0 else 0\n// it won't take additional value that messy up the calculation\nfloat normalize_shape(float c){\n    if(c>0.){\n        return 1.;\n    }else{\n        return 0.;\n    }\n}\n\n\n// if t=a return 0; \n// if t=b return 1; \nfloat remap_one(float a, float b, float t){\n    return (t-a)/(b-a);\n}\n\n// if t=a return c;\n// if t=b return d;\nfloat remap(float a, float b, float c, float d, float t){\n    return remap_one(a, b, t) * (d-c) + c;\n}\n\n\n// approximate function curve\nfloat draw_function(float x, float y, float fun, float thickness, float blur){\n    y = y - fun;\n    float c = Rectangle(vec2(x, y), vec2(.0, .0), 2., thickness, blur);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    // Change the coordinates to [-0.5, 0.5]\n    uv -= .5; // so the origin of the circle is in the center\n    \n    // Change the scale of uv.x according to aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float t = iTime;\n    \n    // Extract x and y from uv\n    float x = uv.x;\n    float y = uv.y;\n    \n    // change of the blur value along x axis from 0.001 to 0.3 →\n    float blur = remap(-1., 1., .05, .25, uv.x);\n    float blur2 = remap(-1., 1., .25, .05, uv.x);\n    blur = pow(blur*4., 6.); // make it blurs exponentially as the x increase...\n    blur2 = pow(blur2*4., 6.);\n    \n    // change the linewidth alone x axis from 0.005 to 0.03 →\n    float thickness = remap(-1., 1., 0.005, 0.1, uv.x) * abs(sin(t)+2.);\n    float thickness2 = remap(-1., 1., 0.1, 0.005, uv.x) * abs(sin(t)+2.);\n    \n    //////THE IMPORTANT DEFINITION OF THE FUNCTION//////\n    float fun1 = sin(2.*t+x*4.)*0.2*sin(t);\n    float c1 = draw_function(uv.x, uv.y, fun1, thickness, blur);\n    vec3 line_color1 = vec3(1., 0., 0.);\n    \n    float fun2 = cos(2.*-t+x*4.)*0.2*sin(t);\n    float c2 = draw_function(uv.x, uv.y, fun2, thickness2, blur2);\n    vec3 line_color2 = vec3(0., 1., 0.);\n    \n    float fun3 = cos(t+x*4.+ PI)*0.2*cos(t);\n    float c3 = draw_function(uv.x, uv.y, fun3, thickness, blur);\n    vec3 line_color3 = vec3(0., 0., 1.);\n    \n    float fun4 = sin(-t+x*4.+ PI)*0.2*cos(t);\n    float c4 = draw_function(uv.x, uv.y, fun4, thickness2, blur2);\n    vec3 line_color4 = vec3(1., 1., 0.);\n    //////THE IMPORTANT DEFINITION OF THE FUNCTION//////\n    \n    vec3 result = c1*line_color1 + c2*line_color2 + c3*line_color3 + c4*line_color4;\n   \n    // Output to screen\n    fragColor = vec4(result, 1.0);\n}","name":"Image","description":"","type":"image"}]}