{"ver":"0.1","info":{"id":"ss2Szd","date":"1620856139","viewed":59,"name":"Spiral Test 01","username":"DOSLuke","description":"Unlike the previous circle tests, this one is a spiral, and converts the fragcoords to the values that was previously an iterator, using something like run length encoding. hopefully efficient at scale.. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["spiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 c = vec3(1);\nconst float AA = 1.2; //antialiasing\nconst float Speed = 100.;\nconst float Curve = 1.9;\nconst float Scale = 5.;\nconst float pi = 3.14159;\nconst float d = -1.; //direction, -1 or 1\n\n//circle func provided by https://www.shadertoy.com/user/elenzil\nvoid circle(vec2 pos, vec2 pixelPos, float rad, vec3 color) {\n    c = mix(c, color, smoothstep(1.0, -1. * AA, length(pos-pixelPos) - rad));\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //if (int(fragCoord.x) % 2 == 0 || int(fragCoord.y) % 2 == 0)\n    {\n    \n    // Normalized pixel coordinates (from 0 to 1) and centered\n    //vec2 uv = (fragCoord.xy - iResolution.xy / 2.) / iResolution.y;\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    //vec2 uv = fragCoord.xy;\n    \n    float j = uv.y*10. + uv.x;\n    float a = sin(j*Curve)*j/Scale;\n    float b = cos(j*Curve)*j/Scale;\n    \n    float r = (d*iTime*pi/180.)*Speed;\n    float aa = cos(r)*a +sin(r)*b;\n    float bb = -sin(r)*a +cos(r)*b;\n    \n    circle(vec2(aa,bb), uv, 1., vec3(0,0,0));\n    \n    }\n    \n\n    fragColor = vec4(c, 1.0);\n    \n    //fragColor = vec4(coords/iResolution.xy, vec2(1,1));\n}","name":"Image","description":"","type":"image"}]}