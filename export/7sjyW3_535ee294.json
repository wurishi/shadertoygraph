{"ver":"0.1","info":{"id":"7sjyW3","date":"1644416160","viewed":251,"name":"Labyrinth 2D/3D","username":"tucna","description":"Demo of the raycastng technique featuring 2D map. The computations are independent on a resolution, give it try. You can also edit a map as you wish.\n\nLEFT/RIGHT - rotate","likes":11,"published":1,"flags":48,"usePreview":0,"tags":["2d","3d","raycasting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAP_SIZE 8\n#define RAYS_NUMBER 40\n#define WALL_HEIGHT 40.0\n\nint[MAP_SIZE * MAP_SIZE] map = int[](\n    1,1,1,1,1,1,1,1,\n    1,0,0,0,0,0,1,1,\n    1,0,1,0,0,0,0,1,\n    1,0,1,0,0,0,0,1,\n    1,0,1,0,0,1,0,1,\n    1,0,1,0,1,1,0,1,\n    1,0,0,0,1,0,0,1,\n    1,1,1,1,1,1,1,1\n);\n\n// Global variables - not nice but keeps code shorter\n\n// Holds map offset for centered drawing\nfloat offsetY;\n// Holds information about tileSize with respect to resolution\nfloat tileSize;\n\n// ------------\n\nfloat sdfCircle(vec2 uv, float r, vec2 offset)\n{\n    float x = uv.x - offset.x;\n    float y = uv.y - offset.y;\n    \n    float d = length(vec2(x, y)) - r;\n    \n    return step(0.0, -d);\n}\n\n// https://www.shadertoy.com/view/MlcGDB\nfloat line(vec2 P, vec2 A, vec2 B, float r) \n{\n    vec2 g = B - A;\n    vec2 h = P - A;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn smoothstep(r, 0.5 * r, d);\n}\n\nint tileAt(vec2 position) // screen space\n{\n    ivec2 tile = ivec2(position.x / tileSize, position.y / tileSize);\n \n    return map[tile.y * MAP_SIZE + tile.x];\n}\n\nvoid computeTileSize(vec2 window)\n{\n    tileSize = window.x / float(MAP_SIZE);\n}\n\nvec3 drawMap(vec2 position, vec2 window)\n{           \n    float finalHeight = tileSize * float(MAP_SIZE);\n    \n    // Offset on Y axis to center 2D map\n    offsetY = (window.y - finalHeight) / 2.0;    \n    position.y -= offsetY;\n       \n    if (tileAt(position) == 1)\n    {   \n        // Add a border\n        if (mod(position.x, tileSize) > 1.0 && mod(position.y, tileSize) > 1.0)\n            return vec3(0.8);\n        else\n            return vec3(0.3);\n    }\n    else\n    {\n        // Add a border\n        if (mod(position.x, tileSize) > 1.0 && mod(position.y, tileSize) > 1.0)\n            return vec3(0.1);\n        else\n            return vec3(0.3);\n    }\n}\n\nvec2 screenSpaceToUV(vec2 position)\n{\n    return (position - 0.5 * iResolution.xy) / iResolution.y;\n}\n\nivec2 screenSpaceToTile(vec2 position, float tileSize)\n{\n    // Count with the offset\n    position.y -= offsetY;\n    vec2 tile = position / tileSize;\n\n    return ivec2(tile);\n}\n\nvec3 shootRay(vec2 origin, vec2 direction, vec2 window)\n{   \n    // Step size in hypotenuse direction with respect to X and Y\n    float unitStepX = sqrt(1.0 + (direction.y / direction.x) * (direction.y / direction.x)); \n    float unitStepY = sqrt(1.0 + (direction.x / direction.y) * (direction.x / direction.y)); \n\n    ivec2 currentTile = screenSpaceToTile(origin, tileSize);\n    vec2 currentTilePosition = vec2(currentTile) * tileSize;\n    currentTilePosition.y += offsetY;\n    \n    vec2 rayLength;           \n    vec2 currentStep;\n    \n    if (direction.x < 0.0)\n    {\n        currentStep.x = -tileSize;\n        rayLength.x = (origin.x - currentTilePosition.x) * unitStepX;\n    }\n    else\n    {\n        currentStep.x = tileSize;\n        rayLength.x = ((currentTilePosition.x + tileSize) - origin.x) * unitStepX;        \n    }\n\n    if (direction.y < 0.0)\n    {\n        currentStep.y = -tileSize;\n        rayLength.y = (origin.y - currentTilePosition.y) * unitStepY;        \n    }\n    else\n    {\n        currentStep.y = tileSize;\n        rayLength.y = ((currentTilePosition.y + tileSize) - origin.y) * unitStepY;                \n    }\n\n    bool tileFound = false;\n    float dist = 0.0;\n\n    while (!tileFound)\n    {\n        if (rayLength.x < rayLength.y)\n        {\n            currentTilePosition.x += currentStep.x;\n            dist = rayLength.x;\n            rayLength.x += unitStepX * tileSize;\n        }\n        else\n        {\n            currentTilePosition.y += currentStep.y;\n            dist = rayLength.y;            \n            rayLength.y += unitStepY * tileSize;\n        }\n        \n        if (tileAt(vec2(currentTilePosition.x, currentTilePosition.y - offsetY)) == 1)\n            tileFound = true;\n    }\n\n    vec2 intersection = origin + direction * dist;\n\n    return vec3(intersection, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = screenSpaceToUV(fragCoord);\n            \n    vec2 mapWindow = vec2(iResolution.x / 2.0, iResolution.y);  \n    computeTileSize(mapWindow);\n\n    // Screen division for a map and actual 3D representation\n    vec3 color = fragCoord.x < mapWindow.x ? drawMap(fragCoord, mapWindow) : vec3(0.0);\n\n    // Return the angle value from the last frame (zero if it's first frame)\n    float angle = texelFetch(iChannel0, ivec2(0,0), 0).x;\n        \n    // Center of the right subwindow is currently player position as well\n    vec2 window2DCenter = mapWindow / vec2(2.0, 2.0);\n    window2DCenter.y += offsetY;\n    \n    // TODO player movement\n    //window2DCenter += vec2(35.0,-35.0);\n    \n    vec2 playerUV =  screenSpaceToUV(window2DCenter);\n    \n    vec2 window3DCenter = vec2(iResolution.x * 0.75, iResolution.y * 0.5);\n    vec2 window3DUV = screenSpaceToUV(window3DCenter);   \n        \n    // Rays\n    for (int a = -RAYS_NUMBER; a < RAYS_NUMBER + 1; a += 1) // one degree per iteration\n    {\n        float rayAngle = radians(angle + float(a));\n        vec2 rayDirection = normalize(vec2(cos(rayAngle), sin(rayAngle)));    \n        vec3 closestPoint = shootRay(window2DCenter, rayDirection, mapWindow);\n\n        vec2 intersection = screenSpaceToUV(closestPoint.xy);\n        \n        // Draw 2D\n        float ray = line(uv, playerUV, intersection, 0.004);\n        color = mix(color, vec3(0.35,0.95,0.51), ray);    \n\n        float player = sdfCircle(uv, 0.01, playerUV);    \n        color = mix(color, vec3(0.7, 0.7, 0), player);  \n        \n        // Draw 3D\n        // Fish eye correction with respect to a player view direction\n        closestPoint.z = cos(radians(float(a))) * closestPoint.z;\n        closestPoint.z = WALL_HEIGHT / closestPoint.z;\n        \n        vec2 from = window3DUV;\n        from.x -= float(a) * 0.01;\n        from.y -= closestPoint.z / 2.0;\n\n        vec2 to = window3DUV;\n        to.x -= float(a) * 0.01;\n        to.y += closestPoint.z / 2.0;\n        \n        float darkening = closestPoint.z;\n\n        // Wall\n        float vertical = line(uv, from, to, 0.004);\n        color = mix(color, vec3(0.1, 0.2, 0.9) * darkening, vertical);      \n        \n        // Floor\n        vertical = line(uv, from, vec2(to.x, -1.0), 0.004);\n        color = mix(color, vec3(0.1, 0.8, 0.1), vertical);  \n        \n        // Ceiling\n        vertical = line(uv, to, vec2(to.x, 1.0), 0.004);\n        color = mix(color, vec3(0.2, 0.2, 0.2), vertical);         \n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Based on https://www.shadertoy.com/view/sdf3RS\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\n\nfloat handleKeyboard(float angle) \n{\n    float velocity = 20.0 * iTimeDelta;\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    angle += texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * velocity;\n    angle -= texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * velocity;\n\n    return angle;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    float angle = texelFetch( iChannel0, ivec2(0, 0), 0).x;\n    \n    // Pass in the offset of the last frame and return a new offset based on keyboard input\n    angle = handleKeyboard(angle);\n\n    // Store offset in the angle values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = vec4(angle, 0, 0, 0);\n}","name":"Buffer A","description":"","type":"buffer"}]}