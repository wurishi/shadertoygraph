{"ver":"0.1","info":{"id":"3s2fzV","date":"1590429581","viewed":174,"name":"Outline 2020 battle MsieurSoleil","username":"MonsieurSoleil","description":"25 min shader battle result.\n\nI don't really know if the is a value to publish that shader, but... let's let it here =)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["livecoding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n#define mod01 floor(mod(time*2.0, 4.0))\n#define mod02 floor(mod(time*4.0, 8.0))\n#define mod03 floor(mod(time*2.0, 16.0))\n\nfloat gg = 0.0;\n\nfloat sphere(vec3 p, float r)\n{\n  return length(p) -r ;\n}\n\nfloat box(vec3 p, vec3 s)\n{\n  p = abs(p) - s;\n  return max(p.x, max(p.y, p.z));\n  \n}\n\nfloat rnd2(vec2 uv)\n{\n  return fract( dot( sin(uv*4521.562549+uv.yx*562.2354) , vec2(452.12336)));\n}\n\nfloat rnd(float t)\n{\n  return fract( sin(t*4521.562549) * 452.12336);\n}\n\nfloat curve(float t)\n{\n  return mix( rnd(t), rnd(t)+1.0, smoothstep(0.0, 1.0, fract(t)));\n  \n}\n\nfloat smin(float a, float b, float k)\n{\n  float h = clamp(0.5 - 0.5 * (a - b)/k, 0.0, 1.0);\n  return mix(b,a, h) - k*h*(1.0 - h);\n}\n\nfloat map(vec3 p)\n{\n  float mat;\n  \n  float repeat = 2.0;\n  float height = sin(time) + sin(p.x * 0.1 + time);\n  \n  vec2 grid = (floor(abs(p.xz) / repeat - 0.5) - 0.5) * repeat;\n  float rndX = rnd2(grid * 16.2) * 2.0;\n  vec3 p2 = p;\n  p2.xz = (fract(abs(p.xz) / repeat - 0.5) - 0.5) * repeat;\n  \n  vec3 scale = vec3(0.8 * rndX * mod03, 0.1 + 0.2 * mod01 + 0.5 * mod02* rndX  , 2.0);\n  \n  mat = box(p2 + vec3(0.0, height * rndX, 0.0), scale);\n  \n   gg += 0.1/(0.9+mat*mat);\n  \n   mat = smin(mat, p.y, 3.5);\n  \n  \n  return mat;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 o = vec3(0.0, 26.0, curve(mod01) * 75.0 + 5.0), t = vec3(0.0);\n\n  vec3 fr = normalize(t -o);\n  vec3 ri = normalize(cross(vec3(0.0, 1.0, 0.0), fr));\n  vec3 up = normalize(cross(fr, ri));\n  vec3 dir = normalize(fr + uv.x * ri + uv.y * up);\n  vec3 p = o + dir * 0.5;\n  \n  float shad = 0.0, d = 0.0, mat = .0;\n\tvec3 col = vec3(0.0);\n  for(int i = 0; i < 100; ++i)\n  {\n    mat = map(p);\n    if(mat < 0.01)\n    {\n      shad = clamp(1.0 - (float(i) / 200.0) ,0.0, 1.0);\n    }\n    \n    p += dir * mat;\n    d += mat;\n    \n    col += gg * vec3(0.0, 0.2, 0.5) * 0.005 * abs(sin(mod01) + 0.5);\n  }\n  \n  col += vec3(0.4) * shad;\n  \n  float fog = clamp(1.0 - (float(d)/100.0), 0.0, 1.0);\n  vec3 sky = mix(vec3(1.0, 0.5, 0.0), vec3(0.5, 0.5, 1.0), uv.y - 0.5);\n  col += sky * fog;\n  \n  \n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}