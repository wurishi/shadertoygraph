{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*\n\tThere are probably some mistakes in the below.\n\n\tImagine a triangle with uv and linePoint as two of the vertices.\n\tThe other sides of the triangle are the line defined by lineDir\n\tthat passes through linePoint, and the normal of the line that \n\tpasses through uv.\n\n\n\t              uv_\n\t             /|  \\\n\t            /b|  |\n\t           /  |  |-- distance of uv to line\n\t          /a  | _/\n\tlinePoint --------------- > lineDir\n\t              |\n\t              v\n\t       normal of lineDir\n\n\n\tuv - linePoint = hypotenuse of the triangle\n\n\tFrom the hypotenuse, we can solve the distance side with a bit of trig.\n\n\tsin(a) * length(hypotenuse) = distance\n\tor\n\tcos(b) * length(hypotenuse) = distance\n\n\tTo get the angles, we can use the dot product:\n\tdot(u, v) = cos(angle_u_to_v) * length(u) * length(v)\n\n\ta = acos( dot(lineDir, hypotenuse) / length(lineDir) / length(hypotenuse) );\n\tb = acos( dot(normalOfLineDir, hypotenuse) / length(normalOfLineDir) / length(hypotenuse) );\n\n\tAnd for 2D lines, the normal is (-y, x):\n\n\tnormalOfLineDir = vec2(-lineDir.y, lineDir.x)\n\n\tNow let's plug all this into the distance equation that uses the angle b:\n\n\n\tcos(b) * length(hypotenuse) = distance\n\n\tnml = vec2(-lineDir.y, lineDir.x)\n\thyp = uv - linePoint\n\n\tcos( acos( dot(nml, hyp) * (1.0 / length(nml)) * (1.0 / length(hyp)) ) ) * length(hyp) = distance\n\n\t> cos and acos cancel out\n\n\tdot(nml, hyp) * (1.0 / length(nml)) * (1.0 / length(hyp)) * length(hyp) = distance\n\n\t> (1.0 / length(hyp)) * length(hyp) = 1.0\n\t> and let's assume that lineDir and nml are unit vectors, so length(nml) = 1.0\n\t> 1.0 / length(nml) = 1.0\n\n\tdot(nml, hyp) * 1.0 * 1.0 = distance\n\tdot(nml, hyp) = dot(vec2(-lineDir.y, lineDir.x), uv - linePoint) = distance\n\n\t> This is a signed distance though. For unsigned distance, use abs(distance)\n\n\n\tAnd there we go.\n\n*/\nfloat lineDistCos(vec2 uv, vec2 lineDir, vec2 linePoint) {\n    return abs(dot(vec2(-lineDir.y, lineDir.x), uv - linePoint));\n}\n\n// sin(x) = sqrt(1.0 - cos^2(x)) | http://www.wolframalpha.com/input/?i=relation+between+sin%28x%29+and+cos%28x%29\nfloat lineDistSin(vec2 uv, vec2 lineDir, vec2 linePoint) {\n    float len = length(uv - linePoint);\n\tfloat c = clamp(dot(lineDir, uv - linePoint) / len, -1.0, 1.0);\n    return sqrt(1.0 - c*c) * len;\n}\n\nfloat crossLen(vec2 a, vec2 b)\n{\n    return abs(a.x*b.y - a.y*b.x);\n}\n\nfloat crossLen(vec3 a, vec3 b)\n{\n   \tfloat x = a.y*b.z - a.z*b.y;\n    float y = a.z*b.x - a.x*b.z;\n    float z = a.x*b.y - a.y*b.x;\n    return sqrt(x*x + y*y + z*z);\n}\n\nvec4 closestPoint(vec4 uv, vec4 lineDir, vec4 linePoint)\n{\n    vec4 uvL = uv - linePoint;\n    return linePoint + dot(uvL, lineDir) * lineDir;\n}\n\n// Cross product line distance from valentingalea in comments, thanks!\n// cross(a,b) = normal(a,b) * sin(theta) * length(a) * length(b) \nfloat lineDistCross(vec2 uv, vec2 lineDir, vec2 linePoint) {\n    return crossLen(lineDir, uv-linePoint); \n    \n    // With vec3 cross product\n    //return crossLen(vec3(lineDir, 0.0), vec3(uv-linePoint, 0.0));\n    \n    // With vec4 normal calculation (???)\n    //return length(\n    //    vec4(uv, 0.0, 0.0) - \n    //    closestPoint(vec4(uv, sin(iTime), cos(iTime*0.2)), normalize(vec4(lineDir, -0.3*cos(iTime*2.0), sin(iTime*0.2)*1.0)), vec4(linePoint, 0.3, 0.2))\n    //    );\n\n    // With vec2 normal calculation\n    //vec2 uvL = uv - linePoint;\n    //return length(uvL - dot(uvL, lineDir)*lineDir);\n}\n\nfloat lineDist(vec2 uv, vec2 lineDir, vec2 linePoint) {\n    float mt = mod(iTime*5.0, 3.0);\n    return mt > 1.0\n        ? (mt > 2.0 ? lineDistCross(uv, lineDir, linePoint) : lineDistSin(uv, lineDir, linePoint))\n        : lineDistCos(uv, lineDir, linePoint);\n}\n\n// Optimized lineSegDist from iq in the comments, thanks!\nfloat lineSegDist(vec2 uv, vec2 lineDir, vec2 linePoint, float r) {\n    vec2 ba = -lineDir * r;\n    vec2 pa = uv - linePoint + ba;\n    ba *= 2.0;\n    return length(pa - ba*clamp( dot(pa, ba)/dot(ba, ba), 0.0, 1.0));\n\n    /*\n    vec2 nml = vec2(-lineDir.y, lineDir.x);\n    vec2 uvL = linePoint - uv;\n\tfloat signedDist = dot(nml, uvL);\n    float t = length(uvL - nml * signedDist);\n    if (t > r) {\n        return length(uvL - lineDir*r*sign(dot(uvL, lineDir)));\n    } else {\n        return abs(signedDist);\n    }\n\t*/\n}\n\nfloat aa(float dist, float threshold)\n{\n    float pixelSize = 2.0 / iResolution.y;\n\treturn dist < threshold-pixelSize ? 0.0 : 1.0-(threshold-dist)/pixelSize;\n}\n\nfloat scene(vec2 uv)\n{\n    vec2 v = normalize(vec2(sin(iTime), cos(iTime)));\n    vec2 p = vec2(sin(iTime*2.3), cos(iTime)*0.4);\n\tvec2 p2 = vec2(sin(1.0+iTime*2.3), cos(0.7+iTime)*0.4);\n\n    return min(\n        aa(lineDist(uv, v, p), 0.01),\n    \taa(lineSegDist(uv, v, p2, 0.3*abs(sin(iTime*3.0))), 0.05)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(iResolution.x/iResolution.y, 1.0) * (-1.0 + 2.0*fragCoord.xy / iResolution.xy);\n\tfragColor = (1.0 - scene(uv)) * vec4(abs(uv)+0.3,0.5+0.5*sin(iTime),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XllGDs","date":"1426224693","viewed":408,"name":"2d line distance - shadeADay","username":"kig","description":"Finally figured out the distance from a point to a 2D line :D\n#shadeADay for 12 March 2015","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","antialias","shadeaday"],"hasliked":0,"parentid":"","parentname":""}}