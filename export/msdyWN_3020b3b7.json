{"ver":"0.1","info":{"id":"msdyWN","date":"1695134578","viewed":38,"name":"Flushing Thunder","username":"lire","description":"A simple example of multiple segment sdfs, reference https://www.shadertoy.com/view/MllGRl and make some improvements","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["thunder","lightening"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TIM  iTime*5.33\n#define ITER_CNT 19\n#define ITER_CNT2 8\n#define ITER_CNT3 3\n#define FRACTAL_CNT 3\n#define WID_DECAY 3.\n#define BRANCH_CNT 2\n#define DB_BRANCH_CNT (2*BRANCH_CNT)\n#define PIDIV2 1.570796\n#define RADOFF 0.628319\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\nvec2 add = vec2(1.0, 0.0);\n\nvec2 noise2(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float dis_base)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), -.1, 1.3 );\n    float dis = dis_base;// + noise2(p * 10.+TIM).x / 60.;\n    float dis_to_line = length( pa - ba*h );\n    return max(mix(dis_to_line - dis, dis_to_line, clamp(dis_to_line / .04, .0, 1.)),.0);\n}\n\nfloat sdPoint (in vec2 p, in vec2 point, float rad) {\n    float d = max(length(p - point) - rad,0.);\n    return step(.004, d) * d * 10000.;\n}\n\nvec2 rotate(in vec2 v, in float rad) {\n    return vec2(\n        cos(rad) * v.x - sin(rad) * v.y,\n        sin(rad) * v.x + cos(rad) * v.y\n    );\n}\n\nfloat sdMainThunder3(in vec2 uv, in vec2 start, in vec2 offset, in vec2 expLength, in float wid) {\n    vec2 real_off = length(expLength) / float(ITER_CNT3) / length(offset) * offset;\n    float rat = length(expLength * 1.3 / float(ITER_CNT3));\n    vec2 pos = start;\n    float dis = 10000.;\n    for (int i = 1; i <= ITER_CNT3; ++i) {\n        vec2 sample_noise = (noise2(pos * 9.87 + TIM) + vec2(.14, 0)) * rat + real_off;\n        dis = min(dis, sdSegment(uv, pos, pos + sample_noise, wid));\n        //dis = min(dis, sdPoint(uv, pos, .02));\n        pos = pos + sample_noise;\n    }\n    return dis * 2.;\n}\n\nfloat sdMainThunder2(in vec2 uv, in vec2 start, in vec2 offset, in vec2 expLength, in float wid) {\n    vec2 real_off = length(expLength) / float(ITER_CNT2) / length(offset) * offset;\n    float rat = length(expLength * 1.3 / float(ITER_CNT2));\n    vec2 pos = start;\n    float dis = 10000.;\n    for (int i = 1; i <= ITER_CNT2; ++i) {\n        vec2 sample_noise = (noise2(pos * 9.87 + TIM) + vec2(.14, 0)) * rat + real_off;\n        dis = min(dis, sdSegment(uv, pos, pos + sample_noise, wid));\n        //dis = min(dis, sdPoint(uv, pos, .02));\n        pos = pos + sample_noise;\n        // off cross dir > 0\n        if (i - i /  DB_BRANCH_CNT * DB_BRANCH_CNT == 0) {\n            // remap [-1, 1] to [-pi/6, pi/6]\n            float off_r = (noise2(pos * 3.76 + TIM).x + 0.14) * RADOFF;\n            vec2 off_red = rotate(offset, off_r + RADOFF);\n            dis = min(dis, sdMainThunder3(uv, pos, off_red, expLength.yx / 4., wid / WID_DECAY));\n        }\n        if (i - i / DB_BRANCH_CNT * DB_BRANCH_CNT == BRANCH_CNT) {\n            float off_r = (noise2(pos * 3.76 + TIM).x + 0.14) * RADOFF;\n            vec2 off_red = rotate(offset, -RADOFF - off_r);\n            dis = min(dis, sdMainThunder3(uv, pos, off_red, expLength.yx / 4., wid / WID_DECAY));\n        }\n    }\n    return dis * 2.;\n}\n\nfloat sdMainThunder(in vec2 uv, in vec2 start, in vec2 offset, in vec2 expLength, in float wid) {\n    vec2 real_off = length(expLength) / float(ITER_CNT) / length(offset) * offset;\n    float rat = length(expLength * 1.3 / float(ITER_CNT));\n    vec2 pos = start;\n    float dis = 10000.;\n    for (int i = 1; i <= ITER_CNT; ++i) {\n        vec2 sample_noise = (noise2(pos * 9.87 + TIM) + vec2(.14, 0)) * rat + real_off;\n        dis = min(dis, sdSegment(uv, pos, pos + sample_noise, wid));\n        //dis = min(dis, sdPoint(uv, pos, .02));\n        pos = pos + sample_noise;\n        // off cross dir > 0\n        if (i - i /  DB_BRANCH_CNT * DB_BRANCH_CNT == 0) {\n            // remap [-1, 1] to [-pi/6, pi/6]\n            float off_r = (noise2(pos * 3.76 + TIM).x + 0.14) * RADOFF;\n            vec2 off_red = rotate(offset, off_r + RADOFF);\n            dis = min(dis, sdMainThunder2(uv, pos, off_red, expLength.yx / 2., wid / WID_DECAY));\n        }\n        if (i - i / DB_BRANCH_CNT * DB_BRANCH_CNT == BRANCH_CNT) {\n            float off_r = (noise2(pos * 3.76 + TIM).x + 0.14) * RADOFF;\n            vec2 off_red = rotate(offset, -RADOFF - off_r);\n            dis = min(dis, sdMainThunder2(uv, pos, off_red, expLength.yx / 2., wid / WID_DECAY));\n        }\n    }\n    return dis;\n}\n\nfloat flushing(float t, float flush, float keep, float interval) {\n    // [0, flush] light [flush, flush + keep] keep [2 * flush + keep] fade out \n    float rt = mod(t, 2. * flush + keep + interval);\n    if (rt < flush) {\n        return smoothstep(0., flush, rt);\n    } else if (rt < flush + keep) {\n        return 1.;\n    } else if (rt < 2. * flush + keep) {\n        return 1. - smoothstep(0., flush, rt - flush - keep);\n    } else {\n        return 0.;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n    \n    vec2 po = vec2(.8, .95);\n    vec2 off = vec2(.0, -1.);\n    vec2 expLength = vec2(.0, 1.6);\n    float wid = .01;\n    \n    float d = sdMainThunder(uv, po, off, expLength, wid);\n    \n    d=exp(-40.*d);\n    vec3 col;\n    col=clamp(1.3*vec3(0.8,.7,.9)*d,0.,1.) + vec3(0.8,.7,.9) / 6.;\n    col *= flushing(iTime, .1, .7, 2.);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}