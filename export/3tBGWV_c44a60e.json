{"ver":"0.1","info":{"id":"3tBGWV","date":"1561118805","viewed":232,"name":"IFS Sphere","username":"ankd","description":"sdCross, IFS, intersect sphere, point light, softshadow, ","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sphere","ifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float PI = 3.14159265359;\n\nvec3 hsv(in float h, in float s, in float v) {\n  return ((clamp(abs(fract(h+vec3(0., 2., 1.)/3.0)*6.0-3.0)-1.0, 0., 1.)-1.0)*s+1.0)*v;\n}\n\nfloat usin(in float x) {\n    return 0.5+0.5*sin(x);\n}\nvec2 rotate(in vec2 p, in float r) {\n  float c=cos(r), s=sin(r);\n  return mat2(c, -s, s, c) * p;\n}\n\nfloat sphere(in vec3 p, in float r) {\n  return length(p) - r;\n}\nfloat box(in vec3 p, in vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\nfloat boxCross(in vec3 p, in vec2 b) {\n  vec3 q = abs(p);\n  q.xy = q.y<q.x ? q.xy : q.yx;\n  q.xz = q.z<q.x ? q.xz : q.zx;\n  return box(q, vec3(b.x, b.y, b.y));\n}\n\nvec2 opU(in vec2 d1, in vec2 d2) {\n  return d1.x<d2.x ? d1 : d2;\n}\n\nvec2 opI(in vec2 d1, in vec2 d2) {\n  return d1.x<d2.x ? d2 : d1;\n}\n\nvec3 opRep(in vec3 p, in vec3 c) {\n  return mod(p, c) - 0.5*c;\n}\n\nvec2 map(in vec3 p) {\n  vec3 q= p;\n  vec2 res = vec2(1e8, -1.0);\n\n  q.xz = rotate(q.xz, 0.5*PI);\n  for(int i=0;i<3;i++) {\n    q = abs(q) - vec3(0.6, 0.7, 0.8);\n    q.xy = rotate(q.xy, PI*0.25);\n    q.yz = rotate(q.yz, PI*0.25);\n    q.zx = rotate(q.zx, PI*0.25);\n  }\n  q = opRep(q, vec3(4.0));\n  float t = iTime*0.2;\n  float r1 = PI*fract(0.125*floor(t));\n  float r2 = PI*fract(0.125*floor(t+1.0));\n  float r = mix(r1, r2, 1.0-pow(1.0-fract(t), 16.0));\n  for(int i=0;i<3;i++) {\n    q = abs(q) - vec3(0.1, 0.2, 0.3);\n    q.xy = rotate(q.xy, r);\n    q.yz = rotate(q.yz, r);\n  }\n  res = opU(res, vec2(boxCross(q, vec2(5.0, 0.08)), 1.0));\n\n  res = opI(res, vec2(sphere(p, 30.0), 1.0));\n\n  return res;\n}\n\n\n#define MARCH_ITER 100\nconst float MARCH_MIN = 0.0;\nconst float MARCH_MAX = 100.0;\nconst float MARCH_THR = 1e-4;\nvec2 rayMarch(in vec3 ro, in vec3 rd) {\n  float d=MARCH_MIN, m=-1.0;\n  for(int i=0;i<MARCH_ITER; i++){\n    vec3 pos = ro + rd*d;\n    vec2 tmp = map(pos);\n    tmp.x = max(abs(tmp.x), 0.02);\n    if(tmp.x<MARCH_THR || MARCH_MAX<tmp.x) break;\n    d += tmp.x*0.5;\n    m = tmp.y;\n  }\n  if(MARCH_MAX<d) m=-1.0;\n  return vec2(d, m);\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax)\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    float ph = 1e10;\n\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n\n        t += h;\n\n        if( res<0.0001 || t>tmax ) break;\n\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nvec3 calcNormal(in vec3 p) {\n  vec2 e = vec2(1.0, -1.0) * 1e-3;\n  return normalize(\n      e.xyy*map(p+e.xyy).x +\n      e.yxy*map(p+e.yxy).x +\n      e.yyx*map(p+e.yyx).x +\n      e.xxx*map(p+e.xxx).x\n    );\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n  vec2 res = rayMarch(ro, rd);\n  float d=res.x, m=res.y;\n\n  vec3 pos = ro+rd*d;\n  vec3 nor = calcNormal(pos);\n\n  // material\n  vec3 color;\n  if(m<0.0) {\n    color = vec3(30.0*exp((1.0-sin(abs(rd.y*PI*2.0))*26.)));\n  } else {\n    color = vec3(pow(fract(length(pos)*0.046-iTime*1.1), 6.0))*hsv(0.15*sin(iTime*0.1)+0.7, 0.8+0.2*sin(iTime*1.3), 1.0);\n  }\n\n  // light\n  vec3 lp = 5.0 * sin(vec3(2.1, 2.3, 2.7));\n  vec3 ld = normalize(lp-pos);\n  vec3 lh = normalize(ld-rd);\n\n  float dif = clamp(dot(ld, nor), 0.1, 1.);\n  float spe = pow(clamp(dot(nor, lh), 0., 1.), 36.0) * dif * (0.05 + 0.95*pow( clamp(1.0+dot(lh, rd),0.0,1.0), 5.0 ));\n  color *= 0.01+clamp(dot(ld, nor), 0., 1.) * calcSoftshadow(pos, ld, .01, 1.);\n  color += 12.0*spe*dif;\n  color = pow(color, vec3(0.4545));\n\n  return color;\n}\n\nfloat easeInOut(in float x, in float a) {\n  float x2 = x*2.0;\n  return x2<1.0 ?\n    0.5*pow(x2, a) :\n    0.5*(1.0-pow(2.0-x2, a)) + 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 p = (fragCoord.xy*2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n  vec3 color = vec3(0.1+0.1*sin(iTime));\n\n  vec3 ro = vec3(0.);\n  float cl = mix(1., 45.0, easeInOut(usin(iTime*PI*0.21), 4.0));\n  ro = cl*vec3(cos(iTime*0.3), 0.3*sin(iTime*0.3), sin(iTime*0.3));\n  vec3 tar = sin(vec3(0.17, 0.13, 0.19)*iTime);\n  vec3 cz = normalize(tar - ro);\n  float cr = iTime*0.08;\n  vec3 cx = normalize(cross(cz, vec3(sin(cr), cos(cr), 0.)));\n  vec3 cy = normalize(cross(cx, cz));\n  vec3 rd = mat3(cx, cy, cz) * normalize(vec3(p, 1.0));\n\n  color = render(ro, rd);\n\n  fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}