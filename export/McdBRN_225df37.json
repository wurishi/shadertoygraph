{"ver":"0.1","info":{"id":"McdBRN","date":"1732803414","viewed":260,"name":"Chinese ink painting","username":"Jatpeng","description":"Can anyone help me and how to optimize performance？\n","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["wave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nprecision mediump float;\n\n// 基础参数配置\nconst float WAVE_LAYERS = 50.0;        // 波浪层数\nconst float BASE_SCALE = 3.0;          // 基础缩放\nconst float DETAIL_FACTOR =0.9400;      // 细节系数 \nconst float MAX_DETAIL = 50.0;         // 最大细节\nconst float INTENSITY = 0.051;          // 强度系数\nconst float VIEW_ANGLE = -0.39;        // 视角旋转角度\nconst float HEIGHT_SCALE = 1.0;        // 高度缩放\nconst float GEOMETRY_FACTOR = 0.732423;     // 几何变形系数\nconst float MIN_EFFECT = 0.1;         // 最小效果阈值\nconst float SPEED = 1.0;//速度\n// 2D旋转矩阵\nmat2 rotate2D(float angle) {\n    return mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n}\n\nvec2 calculateWaveEffect(vec3 position, float scale) {\n    float rippleEffect = 0.0;  // 涟漪效果累积值\n    float waveEffect = 0.0;    // 波浪效果累积值\n    \n    // 循环增加细节，直到达到最大细节级别\n    for(; scale < MAX_DETAIL;) {\n        scale /= DETAIL_FACTOR;  // scale变大 (因为DETAIL_FACTOR < 1.0)\n        \n        // 对xz平面进行旋转，创造不同方向的波纹\n        position.xz *= rotate2D(scale);\n        \n        // 计算涟漪效果\n        rippleEffect += abs(\n            dot(\n                sin(position * scale) / scale,  // 创建正弦波形并按比例缩放\n                position - position + 0.6       // 等于固定值0.6\n            )\n        );\n        \n        // 计算波浪效果\n        waveEffect += abs(\n            dot(\n                // 在xz平面创建移动的正弦波\n                sin(position.xz * scale * 0.33 + (iTime * SPEED)) / scale,\n                // 使用屏幕分辨率比来调整波浪形状\n                iResolution.xy / iResolution.xy\n            )\n        );\n    }\n    \n    return vec2(rippleEffect, waveEffect);\n}\n\n// 计算几何变形\nvec3 calculateGeometry(vec2 fragCoord, float scale, float geometryFactor) {\n    vec3 position = vec3((fragCoord - iResolution.xy / scale) / iResolution.y * geometryFactor, \n                        geometryFactor - scale);\n    \n    // 应用视角变换                    \n    position.yz *= rotate2D(VIEW_ANGLE);\n    position.y *= HEIGHT_SCALE;\n    \n    return position;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 texcoord = fragCoord/iResolution.xy;\n    vec4 baseColor = texture(iChannel1, texcoord);\n    \n    float geometryFactor = 0.0;\n    float finalIntensity = 1.0;\n    float rippleEffect = 0.0;\n    float waveEffect = 0.0;\n    \n    // 主循环生成波浪效果\n    for(int i = 0; i < int(WAVE_LAYERS); i++) {\n        float scale = BASE_SCALE;\n        \n        // 累积几何变形\n        geometryFactor += min(waveEffect, max(MIN_EFFECT, rippleEffect)) * GEOMETRY_FACTOR;\n        \n        // 计算位置\n        vec3 position = calculateGeometry(fragCoord, scale, geometryFactor);\n        \n        // 初始化波浪效果\n        rippleEffect = position.y;\n        waveEffect = position.y;\n        \n        // 计算波浪效果\n        vec2 effects = calculateWaveEffect(position, scale);\n        rippleEffect += effects.x;\n        waveEffect += effects.y;\n        \n        // 累积强度\n        if(waveEffect > INTENSITY * INTENSITY) {\n            finalIntensity += rippleEffect * finalIntensity * INTENSITY;\n        } else {\n            finalIntensity += -exp(-waveEffect * waveEffect) * finalIntensity * INTENSITY;\n        }\n    }\n    \n    // 输出最终颜色\n    fragColor = vec4(vec3(finalIntensity * 0.2), 1.0);\n}","name":"Image","description":"","type":"image"}]}