{"ver":"0.1","info":{"id":"XlK3D3","date":"1477184292","viewed":706,"name":"reflection and refraction","username":"bostelk","description":"left uses fresnel, and right uses schlick's approximation to compute reflectance.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["reflection","refraction","fresnel","schlick"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * started as learning tool.\n * \n * light is reflected from the surface when viewed at a grazing angle.\n * light is transmitted into surface when viewed at a perpendicular angle.\n * \n * Raymarching - Primitives by iq\n * https://www.shadertoy.com/view/Xds3zN\n *\n * Reflections and Refractions in Ray Tracing\n * http://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n */\n\n#define time iTime\n#define air_ior 1.\n#define water_ior 1.330\n#define saturate(n) clamp(n, 0., 1.)\n\nvec2 map(vec3 p)\n{\n    float d = length(p) - 1.;\n    return vec2(d, 40.);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<102; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n// reflectance using fresnel equation.\nfloat rFresnel(in vec3 incident,in vec3 normal, float n1, float n2)\n{\n    float n = n1 / n2;\n    float cosI = -dot(normal, incident);\n    float sinT2 = n * n * (1.0 - cosI - cosI);\n    if (sinT2 > 1.0) return 1.0; // TIR\n    float cosT = sqrt(1.0 - sinT2);\n    float r0rth = (n1 * cosI * - n2 * cosT) / (n1 * cosI + n2 * cosT);\n    float rPar = (n2 * cosI - n1 * cosT) / (n2 * cosI + n1 * cosT);\n    return saturate((r0rth * r0rth + rPar * rPar) / 2.0);\n}\n\n// reflectance using schlick's approximation.\nfloat rSchlick(in vec3 incident,in vec3 normal, float n1, float n2)\n{\n    float r0 = (n1 - n2) / (n1 + n2);\n    r0 *= r0;\n        \n    // requires n1 <= n2.\n    float x  = 1.0 + dot(normal, incident);\n    return saturate(r0 + (1.0 - r0) * x * x * x * x * x);;\n}\n\nvec3 render(vec3 ro, vec3 rd, bool use_schlick)\n{\n    vec3 col = vec3(0);\n    vec2 res = castRay(ro, rd);\n    float t = res.x;\n    float m = res.y;\n    \n    if (m > 0.)\n    {\n        vec3 pos = ro + t*rd;\n        vec3 n = calcNormal(pos);\n   \n        float n1 = air_ior;\n        float n2 = water_ior;\n        \n        float reflectance = 0.;\n\n        if (use_schlick)\n        {\n            reflectance = rSchlick(rd, n, n1, n2);\n        }\n        else\n        {\n            reflectance = rFresnel(rd, n, n1, n2);\n        }\n\n        col = reflectance * pow(texture(iChannel0, reflect(rd, n)).xyz, vec3(2.2)) + \n            (1. - reflectance) * pow(texture(iChannel0, refract(rd, n, n1 / n2)).xyz, vec3(2.2));\n    }\n\telse\n\t{\n        // background\t\t\n\t\tcol = pow(texture( iChannel0, rd ).xyz, vec3(2.2) );\n\t}\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n    p.y *= -1.;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    vec2 m = iResolution.xy/2.;\n    if ( iMouse.z >0.) m=iMouse.xy;\n    \n    // camera\t\n\tvec3 ro = vec3( -0.5+3.5*cos(0.1*time),\n                   -(1.0 + 3.0*mo.y),\n                   0.5 + 3.5*sin(0.1*time) );\n\tvec3 ta = vec3(0.);\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd , m.x < fragCoord.x);\n    col *= smoothstep(0.001,0.001,abs((m.x  - fragCoord.x)) / iResolution.x);\n    col = pow(col, vec3(0.45) );\n                  \n\tfragColor =  vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}