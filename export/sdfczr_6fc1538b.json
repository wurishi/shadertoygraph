{"ver":"0.1","info":{"id":"sdfczr","date":"1641596153","viewed":201,"name":"Turret Bases  Stand & Gun Exp 2","username":"Yusef28","description":"More experiments, lot's of unused code in common tab. Focusing more on OO concepts.","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["animated"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat sdCappedCylinder( vec3 p, float r, float h ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinderZ( vec3 p, float r, float h ){\n  vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nstruct Base {\n    vec3 center;\n    vec3 dim;\n    mat3 basis;\n};\n\nstruct Stand {\n    vec3 center;\n    vec3 dim;\n    mat3 basis;\n    vec3 gunAxelPos;\n};\n\nstruct Gun {\n    vec3 center;\n    vec3 dim;\n    mat3 basis;\n    vec2 bounds;\n    float angle;\n};\n\n\nBase theBase;\nStand theStand;\nGun theGun;\n\nvoid initializeBase(){\n    theBase.dim = vec3(1.,0.2,1.) * WORLD_SCALE;\n    theBase.center = vec3(0.,0.,0.);\n    theBase.basis = IDENTITY;     \n}\n\nvoid initializeStand(float time){\n    theStand.dim = vec3(0.5) * WORLD_SCALE;                \n    theStand.center = vec3(0.,theBase.dim.y + theStand.dim.y,0.) \n                   + theBase.center;              \n    theStand.gunAxelPos = vec3(0.0,0.9,0.05);\n    theStand.basis = rotateY(time,theBase.basis);\n}\n\nvoid initializeGun(float time){\n    theGun.dim = vec3(0.25,.25,0.25)  * WORLD_SCALE;\n    theGun.center = vec3(0.,theStand.center.y+0.,0.)\n                 + theStand.center;\n    theGun.center = theStand.gunAxelPos+ theStand.center;\n    theGun.bounds = vec2(-PI/2.,PI/2.);\n    theGun.angle = clamp(abs(fract(time/4.)-0.5)*PI,theGun.bounds.x,theGun.bounds.y);\n    theGun.basis = rotateX(theGun.angle+4.,theBase.basis);\n}\n\nvoid initializeObjects(float time){\n    \n    initializeBase();\n    initializeStand(time);                \n    initializeGun(time);\n}\n\n\nfloat base(vec3 p){\n    float d = sdBox(p * theBase.basis - theBase.center, theBase.dim);\n    return d;\n}\n\nfloat stand(vec3 p){\n    \n    vec3 pos = (p  - theStand.center)* theStand.basis;\n    float cyl1 = sdCappedCylinder(pos+vec3(0.,theStand.dim.y-0.05,0.),\n    cos(atan(pos.x,pos.z)*60.)/40. + .6,0.05)  - 0.01;\n    \n    float cyl2 = sdCappedCylinder(pos+vec3(0.,theStand.dim.y-0.15,0.),\n    0.66,\n    0.05-smoothstep(0.9,0.85,length(pos.xz)/0.66)*0.035) - 0.015;\n    \n    float cyl3b = sdCappedCylinder(pos+vec3(0.,theStand.dim.y-0.2,0.),\n    0.3-geoPath1D_b(pos.y*15.-0.4)*0.05,\n    0.15)- 0.015;\n    \n    float cyl4b = sdCappedCylinder(pos+vec3(0.,theStand.dim.y-0.45,0.),\n    0.15,\n    0.2)- 0.015;\n    \n    //////////////////////finegeo start/////////////////////////\n    \n    float width = 0.7;\n    float height = 0.09;\n    float lange = 0.25;\n        \n    float yDesign = max(smoothstep(0.0,0.05,abs(fract(pos.z/(lange))-0.5)-0.9)/20.,\n                       smoothstep(0.0,0.05,abs(((pos.x)/width))-0.42)/20.);\n                       \n    float zDesign = max(smoothstep(0.,0.05,abs(fract(pos.y/height)-0.5)-0.2)/20.,\n                       smoothstep(0.,0.05,abs(2.*pos.x/width)-0.85)/20.);\n    \n    float xDesign = max(smoothstep(0.,0.05,abs(fract(2.*pos.y/height)-0.5)-0.5)/30.,\n                       smoothstep(0.,0.05,abs(pos.z/lange)-0.7)/30.);\n         \n    /////////////////end of fine geo///////////////////////////   \n    \n    float legBottom = sdBox(pos-vec3(0.,theStand.dim.y-0.26,0.),\n    vec3(width, height-yDesign, lange));\n    \n    vec3 mirroredZ = vec3(abs(pos.x)-0.55,pos.yz);\n    \n    /////////////////////////for fine geo///////////////\n    width = 0.15\n                -geoPath1D_b(pos.y*1.+0.7)*0.4*step(0.,mirroredZ.x);\n    height = 0.6;\n    lange = 0.25 -geoPath1D_b(pos.y+2.7)*0.3*step(mirroredZ.z,0.) ;//*step(pos.z,0.)*.1;\n    //+geoPath1D(pos.y);\n    \n    yDesign = max(smoothstep(0.0,0.05,abs(fract(1.*pos.z/(lange))-0.5)-0.4)/20.,\n                       smoothstep(0.0,0.05,abs(((pos.x)/width))-0.42)/20.);\n                       \n    zDesign = max(smoothstep(0.,0.05,abs(fract(pos.y/height)-0.5)-0.2)/20.,\n                       smoothstep(0.,0.05,abs(2.*pos.x/width)-0.85)/20.);\n                        \n    xDesign = max(smoothstep(0.,0.05,abs(fract(2.*pos.y/height)-0.5)-0.5)/30.,\n                       smoothstep(0.,0.05,abs(pos.z/lange)-0.7)/30.);\n          \n     //////////////////////end of fine geo/////////////////     \n          \n    float leg = sdBox(mirroredZ-vec3(0.,0.8,0.0), \n                vec3(width-xDesign,\n                     height,\n                     lange));\n     \n    // vec3 vec3(0.05,0.,0.9).zxy (abc).zxy  cab\n    float gunAxel = sdCappedCylinder(pos.zxy-vec3(0.05,0.,0.9),\n    0.05,0.65) - 0.015;\n    \n    float topBarRidged = sdCappedCylinder(pos.zxy-vec3(0.05,0.,0.9),\n    0.15 - geoPath1D_b(pos.x*30.)*0.02,\n    0.33) - 0.015;\n    \n    float mirrorX_float = abs(pos.x)-0.4;\n    float topBarGaurd = sdCappedCylinder(vec3(pos.z,mirrorX_float,pos.y)-vec3(0.05,0.,0.9),\n    0.18,0.05) - 0.015;\n    \n    mirrorX_float = abs(pos.x)-0.45;\n    float sideCaps =  length(vec3(mirrorX_float,pos.y-0.9,pos.z-0.05))-0.2;\n        \n   \n    \n    float d = sdBox(pos, \n              theStand.dim);\n    d = 1000.;\n    d = min(d, min(cyl2,cyl1));\n    d = min(d, cyl3b);\n    d = min(d, cyl4b);\n    d = min(d, legBottom);\n    d = min(d, leg);\n    d = min(d, gunAxel);\n    d = min(d, topBarRidged);\n    d = min(d, topBarGaurd);\n    d = min(d, sideCaps);\n        \n\n    \n   /*\n   d = min(d,leg);\n    d = min(d,cyl3);\n    d = min(d,bumper);\n        d = min(d,cyl4);\n        d = min(d,cyl5);*/\n    return d;\n}\n\nfloat gun(vec3 p){\n    vec3 pos = ( p*theStand.basis  - theGun.center) * theGun.basis ;\n              \n   float d = 100.;//\n   \n   float width = .25;\n    float height = .2+geoPath1D_b(pos.z*3.-1.99)*0.2;\n    float lange = .3;//*step(pos.z,0.)*.1;\n    //+geoPath1D(pos.y);\n    \n    float yDesign = max(smoothstep(0.0,0.05,abs(fract(1.*pos.z/(lange))-0.5)-0.4)/20.,\n                       smoothstep(0.0,0.05,abs(((pos.x)/width))-0.42)/20.);\n                       \n    float zDesign = max(smoothstep(0.,0.05,abs(fract(pos.y/height)-0.5)-0.2)/20.,\n                       smoothstep(0.,0.05,abs(2.*pos.x/width)-0.85)/20.);\n                        \n    float xDesign = max(smoothstep(0.,0.05,abs(fract(2.*pos.y/height)-0.5)-0.3)/20.,\n                       smoothstep(0.,0.05,abs(2.*pos.z/lange)-0.85)/20.);\n                       \n            \n            \n   float charger = sdBox(pos, vec3(width,height-yDesign,lange-zDesign));\n              \n    \n    width = .2;\n    height = .1+geoPath1D_b(pos.x*5.-1.99)*0.29;\n    lange = .6;\n\n    \n    yDesign = max(smoothstep(0.0,0.05,abs(fract(8.*pos.z/(lange))-0.5)-0.4)/20.,\n                       smoothstep(0.0,0.05,abs(((pos.x/4.)/width))-0.22)/20.);\n                       \n    zDesign = max(smoothstep(0.,0.05,abs(fract(pos.y/height)-0.5)-0.2)/20.,\n                       smoothstep(0.,0.05,abs(pos.x/width)-0.85)/20.);\n                        \n    xDesign = max(smoothstep(0.,0.05,abs(fract(pos.y/height)-0.5)-0.3)/20.,\n                       smoothstep(0.,0.05,abs(8.*pos.z/lange)-0.85)/20.);\n                       \n                       \n                       \n                       \n    //float leg = sdBox(pos,vec3(width-xDesign,height-yDesign,lange-zDesign));\n  \n    float barrel = sdBox(pos-vec3(0.,0.,.8),vec3(width-xDesign,height-yDesign,lange-zDesign));\n\n    float cylBarrel1 = sdCappedCylinderZ(pos-vec3(0.,0.,1.),\n    0.12-geoPath1D(pos.z*34.)*0.05*step(pos.z,1.8),\n    0.9)- 0.015;\n    float cylBarrel2 = sdCappedCylinderZ(pos-vec3(0.,0.,1.3),\n    0.08,\n    0.9)- 0.015;\n    float cylBarrel3 = sdCappedCylinderZ(pos-vec3(0.,0.,2.4),\n    0.1 + clamp(geoPath1D(atan(pos.x,pos.y)*3.)*0.08,0.,0.03)\n        * smoothstep(2.4,2.45,pos.z),\n    0.25)- 0.015;\n    \n    float cylBarrelCut = sdCappedCylinderZ(pos-vec3(0.,0.,2.4),\n    0.08, 1.3)- 0.015;\n    \n    \n    d = min(d, charger);\n    d = min(d, barrel);\n    d = min(d, cylBarrel1);\n    d = min(d, cylBarrel2);\n    d = min(d, cylBarrel3);\n    d = max(d, -cylBarrelCut);\n    \n    return d;\n}\n\nfloat map(vec3 p){\n    //Split the world into coordinates,\n    vec2 floorID = vec2(0.);//floor(p.xz/4.-2.);\n    //p.xz = mod(p.xz,4.*WORLD_SCALE)-2.*WORLD_SCALE;\n    //initalize the objects in their current animated position,\n    initializeObjects(rnd2D(floorID)*800.+iTime);\n    //and return the distance field.\n    float alle = 1000.;\n    alle = min(gun(p),alle);\n    alle = min(stand(p),alle);\n    alle = min(base(p),alle);\n    return alle;\n    \n    //return min(gun(p),min(stand(p),min(100.,base(p))));\n}\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i = 0; i < 96; i++){\n\n        d = map(ro + rd*t);\n        \n        // Using the hacky \"abs,\" trick, for more accuracy. \n        if(abs(d)<.001 || t>FAR) break;        \n        \n        t += d*.5;  // Using more accuracy, in the first pass.\n    }\n    \n    return t;\n}\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i = 0; i < 24; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.002 || t>FAR) break;\n        \n        t += d*0.75;\n    }\n    \n    return t;\n}\n\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), \n    map(p + e.yxy) - map(p - e.yxy),\t\n    map(p + e.yyx) - map(p - e.yyx)));\n}\n\nvec3 getObjectColor(vec3 p){\n    return fract(p);\n}\n\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t){\n    \n    vec3 ld = lp-sp; // Light direction vector.\n    float lDist = max(length(ld), .001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n    \n    // Attenuating the light, based on distance.\n    float atten = 1. / (1. + lDist*.2 + lDist*lDist*.1);\n    \n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 0.);\n    \n    // Standard specualr term.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 8.);\n    vec3 objCol = getObjectColor(sp);\n    vec3 sceneCol = (objCol*(diff + .15) + vec3(1., .6, .2)*spec*2.) ;//* atten;\n    float fogF = smoothstep(0., .95, t/FAR);\n    sceneCol = mix(sceneCol, vec3(0), fogF); \n    return sceneCol;\n    \n}\n\nvec3 getCameraDirection(vec2 uv, vec3 ro, vec3 ta){\n\n    vec3 fwd = normalize(ta-ro);\n    vec3 uu = vec3(0.,1.,0.);\n    vec3 ri = normalize(cross(uu,fwd));\n    vec3 up = normalize(cross(fwd,ri));\n    return normalize(uv.x*ri + uv.y*up + fwd*1.2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec3 col = vec3(0.);\n    vec3 ta = vec3(0.);\n    vec3 ro = vec3(0.,3.,10.5) * WORLD_SCALE;\n    \n   \n    if(iMouse.z > 0.5){\n        //float rotScale = 4.;\n        vec2 m = iMouse.xy/iResolution.xy;\n        //vec3 ro = vec3(0., 1., -3.);\n        ro.yz *= rot(-m.y*PI+1.);\n        ro.xz *= rot(-m.x*PI*2.);\n        //ro.xz *= rot(4.*(iMouse.x/iResolution.x)-rotScale/2.);\n        //ro.yz *= rot((iMouse.y/iResolution.y)*PI);\n    }\n    else{\n        ro.yz *= rot(sin(iTime/4.)-0.2);\n        ro.xz *= rot(-iTime/3.);\n    }\n    vec3 rd = getCameraDirection(uv,ro,ta);\n    \n\n\n    vec3 lp = ro + vec3(0., 0., 1.);\n    //\n    \n    float planeT = pointOnPlane(ro,rd);\n    \n    if(planeT > 0.){\n        vec3 pos = ro + rd*planeT; \n        vec3 sn = vec3(0.,1.,0.);\n        vec2 vh = step(abs(fract(pos.xz)),vec2(0.04));\n       // float hori = step(abs(fract(pos.z)-0.5),0.04);\n        col += (vh.x+vh.y)/5.;//doColor(pos, rd, vec3(0.,1.,0.), lp, t);\n       // float sh = softShadow(ro +  sn*.0015, lp, 16.);\n       \n    }\n\n   // initializeObjects();//(and animate them)\n    float t = trace(ro, rd);\n    \n    if(t < FAR){\n        vec3 pos = ro + rd*t; \n        vec3 sn = getNormal(pos);\n        col += doColor(pos, rd, sn, lp, t)/2.;\n        vec3 p = pos;\n        \n        /*\n        col = mix(col, vec3(1.,0.,0.),\n            step(0.01,shapeDecline(p.xz / WORLD_SCALE,0.,0.,0.,0.)));\n            \n        col = mix(col, vec3(1.),\n            step(0.01,complexMap(p.xz / WORLD_SCALE)));  \n            \n        col = mix(col, vec3(0.,0.,1.),\n            step(0.01,floppyDiskThing(p.xz / WORLD_SCALE))); \n            \n        col = mix(col, vec3(0.,0.,1.),\n            step(0.01,floppyDiskThing3(p.xz / WORLD_SCALE)));*/\n\n    }\n    if(rd.y >= 0.){\n        col = mix(col,vec3(0.8,0.8,0.9),pow(1.-rd.y,50.));\n    }\n    \n    \n    //col = vec3(floppyDiskThing3(uv*3.));//shapeLadder(uv*2.));\n    float textureFrame;\n    vec2 uvFrame = abs(uv)-0.3;\n    float uvF = max(uvFrame.x,uvFrame.y);\n    //col += smoothstep(0.01,0.,abs(uvF-0.2));\n    fragColor = vec4(col,1.);//sqrt(clamp(col, 0., 1.)), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI acos(-1.)\n#define animator (sin(iTime)*0.5+0.5)\n#define startTime (iTime*4.+9.)\n#define newAnimator (sin(startTime)*0.5+0.5)\n#define sequence (abs(mod(startTime/4.,8.)-4.))\n\n#define SEQ_1 clamp(sequence-1.,0.,1.)\n#define SEQ_2 clamp(sequence-1.,0.,1.)\n#define SEQ_3 clamp(sequence-2.,0.,1.)\n#define IDENTITY mat3(vec3(1.,0.,0.),vec3(0.,1.,0.),vec3(0.,0.,1.))\n\n#define WORLD_SCALE 1.\n#define FAR 50.\n\n\nfloat rnd(float a){\n    return fract(sin(a)*45960.24562);\n}\n\nfloat rnd2D(vec2 id){\n    return fract(sin(dot(vec2(12.94,73.59),id))*45960.24562);\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\nfloat smax( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\n\nfloat sdBox(vec3 pos, vec3 dim){\n    vec3 aPos = abs(pos) - dim;\n    return max(aPos.x, max(aPos.y,aPos.z) );\n}\n\nmat3 rotateX(float a, mat3 basis){\n    mat2 theRotation = rot(a);\n    basis[0].yz *= theRotation;\n    basis[1].yz *= theRotation;\n    basis[2].yz *= theRotation;\n    return basis;\n}\n\nmat3 rotateY(float a, mat3 basis){\n    mat2 theRotation = rot(a);\n    basis[0].xz *= theRotation;\n    basis[1].xz *= theRotation;\n    basis[2].xz *= theRotation;\n    return basis;\n}\n\nmat3 rotateZ(float a, mat3 basis){\n    mat2 theRotation = rot(a);\n    basis[0].xy *= theRotation;\n    basis[1].xy *= theRotation;\n    basis[2].xy *= theRotation;\n    return basis;\n}\n\nfloat pointOnPlane(vec3 ro, vec3 rd){\n    vec3 pp = vec3(0.);\n    vec3 n = vec3(0.,1.,0.);\n    float t = (dot(pp,n)-dot(ro,n))/dot(rd,n);\n    return t < FAR ? t : -1.;\n}\n\nfloat geoPath1D(float dir){\n    return clamp(\n               abs(fract(dir/2.)-0.5), \n           0.1, 0.35)*1.5;\n}\nfloat geoPath1D_b(float dir){\n    return clamp(\n               abs(fract(dir/2.)-0.5), \n           0.0, 0.23)*1.4;\n}\n\nvec2 geoPath(vec2 dir){\n    return clamp(\n               abs(fract(dir/2.)-0.5), \n           0.0, 0.35)*1.5;\n}\n\nvec2 geoBumpPath(vec2 dir){\n    return clamp(\n                abs(fract(dir/2.)-0.5),\n           0.0, 0.35)*1.5;\n}\n\nfloat shapeDecline(vec2 uv, \n    float height, float degree, float smoothStart, float smoothEnd){\n    vec2 decline = pow(smoothstep(1.,0.75,abs(uv)),vec2(4.)) *0.15;\n    return min(decline.x,decline.y);\n}\n\nfloat shapeSinGroove(vec2 uv,float height,\nfloat smoothStart,float smoothEnd){\n    //smoothstart = 0.75, smoothEnd = 0.7    \n    return smoothstep(smoothStart,smoothEnd,\n    abs(uv.x-sin(uv.y)))/height;//9.\n}\n\nfloat shapeGeoGroove(vec2 uv, float widen, float height){\n    float shiftToSide = 0.;\n   // float widen = widen;// 0.3; //-0.4 to 0.4\n    vec2 geoGroove = smoothstep(0.75,0.7,\n                abs(uv.xy+shiftToSide)-widen+geoPath(uv.yx))/height;//18.\n                \n    return min(geoGroove.x,geoGroove.y);\n}\nfloat shapeGeoGroove1D(vec2 uv, float widen, float height){\n    float shiftToSide = 0.;\n   // float widen = widen;// 0.3; //-0.4 to 0.4\n    float geoGroove = smoothstep(0.75,0.7,\n                abs(uv.x+shiftToSide)-widen+geoPath1D(uv.y))/height;//18.\n                \n    return geoGroove;\n}\nfloat shapeGeoGroove1D_b(vec2 uv, float widen, float height){\n    float shiftToSide = 0.;\n   // float widen = widen;// 0.3; //-0.4 to 0.4\n    float geoGroove = smoothstep(0.75,0.7,\n                abs(uv.x+shiftToSide)-widen+geoPath1D_b(uv.y))/height;//18.\n                \n    return geoGroove;\n}\nfloat shapeOutlineBump(vec2 uv){\n\n    vec2 outlineBump = smoothstep(0.08,0.0, \n                abs(abs(uv.xy)-0.96) ) * 0.05;\n    return max(outlineBump.x,outlineBump.y);\n}\n\nfloat shapeGeoBump(vec2 uv){\n\n    float widenSides = 0.99;\n    float widenBump = 0.6; //larger is thinner, thinnest is 1.4\n    vec2 geoBump = smoothstep(0.75,0.7, \n                     abs(abs(uv.xy)-widenSides+\n                     geoBumpPath(uv.yx))+widenBump)/15.;\n    return  max(geoBump.x,geoBump.y);\n}\n\nfloat shapeLadder(vec2 uv){\n    float sq = max(abs(uv.y)-0.3,abs(uv.x)-0.3);\n    uv *= rot(PI*0.25);\n    uv = abs(uv)-0.65;\n    uv *= rot(PI*0.25);\n    float d = smoothstep(0.2,0.18,abs(uv.x)-0.06) * \n              step(abs(uv.y)-0.2,0.1);\n              \n    uv.y = smoothstep(.2,0.2,abs(fract(uv.y*25.+0.24)-0.4));\n    vec2 bf = abs(uv)+vec2(0.22,-0.2);\n    float cut = max(bf.x,bf.y);\n    cut = smoothstep(0.3,0.2,cut);\n    d = min(d,cut);\n    \n    return d*step(sq,0.55);\n}\n\nfloat complexMap(vec2 uv){\n    //uv *= 2.;\n    \n    float d = smoothstep(0.,0.1,shapeGeoGroove1D(uv,.0,12.))/18.;\n    d += smoothstep(0.1,0.,shapeGeoGroove1D(uv,.06,12.))/18.;\n    d -= smoothstep(0.1,0.,shapeGeoGroove1D(uv,.2,12.))/18.;\n    d += smoothstep(0.1,0.,shapeGeoGroove1D(uv,.26,12.))/18.;\n    d -= smoothstep(0.1,0.,shapeGeoGroove1D(uv,.3,12.))/18.;\n    d += smoothstep(0.1,0.,shapeGeoGroove1D_b(uv,.49,12.))/18.;\n    return d;\n}\n\nfloat floppyDiskThing(vec2 uv){\n    vec2 spread = vec2(6., 2.2);\n    uv*=8.;\n    uv = abs(uv)-spread;\n    float d = max(abs(uv.x)-0.3-geoPath1D(uv.y/1.5)*step(uv.x,0.)\n             ,abs(uv.y)-0.3);\n    d = clamp(d,0.,1.);\n    d = sin(d*8.)*0.5+0.5;\n    return clamp(1.-d,0.,1.)/1.;\n}\n\nfloat floppyDiskThing2(vec2 uv){\n    \n    uv*=2.;\n    //uv = abs(uv)-vec2(6.,1.5);\n    float d = max(abs(uv.x)-0.3-geoPath1D(uv.y/1.5)*step(uv.x,0.)\n             ,abs(uv.y)-0.3);\n             \n    d = clamp(d,0.,1.);\n    \n    uv*=2.;\n    uv.y = abs(uv.y)-1.5;\n    float cut = max(abs(uv.x)-0.3-geoPath1D(uv.y/1.5)*step(uv.x,0.)\n             ,abs(uv.y)-0.3);\n    cut = clamp(cut,0.,1.);    \n    d = min(d,cut);\n   // d = sin(d*8.)*0.5+0.5;\n    return clamp(1.-d,0.,1.)/1.;\n}\nfloat floppyDiskThing3(vec2 uv){\n    uv*= 2.;\n    uv.x = abs(uv.x)-1.4;\n    uv*=2.;\n    //uv = abs(uv)-vec2(6.,1.5);\n    float d = max(abs(uv.x)-0.3-geoPath1D(uv.y/1.5)*step(uv.x,0.)\n             ,abs(uv.y)-0.3);\n             \n    d = clamp(d,0.,1.);\n    \n    uv*=1.2;\n    uv.x -= 0.55;\n    uv.y = abs(uv.y)-1.2;\n    float cut = max(abs(uv.x*0.8)-0.3-geoPath1D(uv.y/1.)*step(uv.x,0.)\n             ,abs(uv.y)-0.3);\n    //cut = clamp(cut,0.,1.); \n    cut = smoothstep(0.9,0.4,cut);\n    d = max(d,cut);\n   // d = sin(d*8.)*0.5+0.5;\n    return clamp(1.-d,0.,1.)/1.;\n}\n\n\n","name":"Common","description":"","type":"common"}]}