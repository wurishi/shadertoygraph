{"ver":"0.1","info":{"id":"7tX3zf","date":"1622574685","viewed":170,"name":"Class 3: Complex Scene","username":"xarmalarma","description":"Sphereflake","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sphereflake"],"hasliked":0,"parentid":"7tfGzf","parentname":"Class 3: Many objects"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXX 1000000.0\n\nfloat seed = 0.0;\n\nvec3 bgColor = vec3(0, 1, 1);\n\n// random number between 0 and 1\nfloat random() {\n    return fract(sin(seed++)*43758.5453123);\n}\n\n// a Light is defined by a location and a color\nstruct Light {\n    vec3 location;\n    vec3 color;\n};\n\n// Sphere is defined by a center and radius and material: color\nstruct Sphere {\n\tfloat radius;\n\tvec3 center;\n    vec3 color;\n};\n\n// Ray is define by an origin point and a direction vector\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n  \n  \n// Intersection code for Ray-Sphere    \nfloat raySphereIntersect(in Ray ray, in Sphere sphere) {\n    \n    vec3 rayToSphere = ray.origin - sphere.center;\n    float b = dot(rayToSphere, ray.direction);\n    float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n\tfloat disc = b*b - c;\n    float t = MAXX; // initialize to a large number\n    if (disc > 0.0) {\n        t = -b - sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }\n        t = -b + sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }  \n    }\n    return t;\n}\n\n\nconst int NUM_SPHERE = 43;\nSphere spheres[NUM_SPHERE];\nLight  lights[1];\n\nfloat theta = 0.0;\n\nvoid rotateSceneTenDegrees(int f) {\n    theta += float(f)/5.0 * 3.1415/45.0;\n    //theta = 0.0;\n    for (int i=0; i<6; i++) {\n        // rotate each child sphere about y-axis \n        // through the center of the large one\n        vec3 v1 = spheres[i+1].center - spheres[0].center;\n        vec3 axis = normalize(vec3(0.0, spheres[0].radius, 0.0));\n        vec3 newv = v1*cos(theta) + cross(axis, v1)* sin(theta) + axis*dot(axis, v1)*(1.0-cos(theta));\n        spheres[i+1].center = newv + spheres[0].center;\n    }\n}\n\nint addSixSpheres(Sphere parentSphere, int count) {\n    float radius = parentSphere.radius;\n    vec3 center = parentSphere.center;\n    float childRadius = radius/2.8;\n    spheres[++count] = Sphere(childRadius, vec3(center.x, center.y+radius+childRadius-0.1, center.z), vec3(random(), random(), random()));\n    spheres[++count] = Sphere(childRadius, vec3(center.x, center.y-radius-childRadius+0.1, center.z), vec3(random(), random(), random()));\n    spheres[++count] = Sphere(childRadius, vec3(center.x+radius+childRadius-0.1, center.y, center.z), vec3(random(), random(), random()));\n    spheres[++count] = Sphere(childRadius, vec3(center.x-radius-childRadius+0.1, center.y, center.z), vec3(random(), random(), random()));\n    spheres[++count] = Sphere(childRadius, vec3(center.x, center.y, center.z+radius+childRadius-0.1), vec3(random(), random(), random()));\n    spheres[++count] = Sphere(childRadius, vec3(center.x, center.y, center.z-radius-childRadius+0.1), vec3(random(), random(), random()));\n    return count;\n}\n\nvoid makeScene(int f) {\n    float radius=0.8;\n    vec3 center = vec3(0, 0, -6); \n    vec3 color = vec3(random(), random(), random());\n    int count = -1;\n    spheres[++count] = Sphere(radius, center, color);\n    count = addSixSpheres(spheres[0], count);\n    count = addSixSpheres(spheres[1], count);\n    count = addSixSpheres(spheres[2], count);\n    count = addSixSpheres(spheres[3], count);\n    count = addSixSpheres(spheres[4], count);\n    count = addSixSpheres(spheres[5], count);\n    count = addSixSpheres(spheres[6], count);\n\n    lights[0] = Light(vec3(0.0, 0.0, 0.0), vec3(1, 1, 1));\n    rotateSceneTenDegrees(f);   \n}\n\n\n\nint numSamples = 2;\n\n\n/* The main entry point:\n   * This is called for every pixel on the screen \n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \n   // fragCoord ranges from \n   //   in x: 0.5 to iResolution.x-0.5\n   //   in y: 0.5 to iResolution.y-0.5\n   // pixel (0,0) is at the bottom left corner\n   if (iFrame==0) theta = 0.0;\n   \n   makeScene(iFrame);\n   \n   vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n   \n   float screenDepth = -2.0;\n   \n   float width = iResolution.x;\n   float height = iResolution.y; \n   \n   vec3 samp = vec3(0, 0, 0);\n   seed = 0.0;\n   for (int i=0; i<numSamples; i++) {\n       float x = fragCoord.x + random() - 0.5;\n       float y = fragCoord.y + random() - 0.5;\n       \n   \n       // map (0.5, w-0.5) to (-1, 1)\n       // and (0.5, h-0.5) to (-1, 1)\n       x = (x/width)*2.0 - 1.0;\n       y = (y/height)*2.0 - 1.0;\n       \n       // account for the non-square window\n       float aspectRatio = width/height;\n       y = y/aspectRatio;\n       \n       vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n       \n       Ray ray = Ray(rayOrigin, rayDirection);\n       float t = MAXX;\n       int iSphere = -1;\n       float minT = MAXX;\n       for (int i=0; i < NUM_SPHERE; i++) {\n           Sphere sphere = spheres[i];\n         \n           t = raySphereIntersect(ray, sphere);\n         \n           if (t < minT) {\n               minT = t;\n               iSphere = i;\n           }\n       }\n       if (iSphere > -1 && minT < MAXX) {\n           Sphere sphere = spheres[iSphere];\n           vec3 hit = ray.origin + minT*ray.direction;\n           vec3 norm = normalize(hit - sphere.center);\n           vec3 hitPointNormal = normalize(hit-sphere.center);\n           vec3 hitPointToEye = normalize(vec3(0, 0, 0)-hit);\n           float angle = dot(hitPointNormal, hitPointToEye);\n           samp = samp + angle*sphere.color;\n          \n       }\n   }\n   fragColor = vec4(samp/float(numSamples), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}