{"ver":"0.1","info":{"id":"4ldSWN","date":"1479673802","viewed":593,"name":"Monolith Sun","username":"jojendersie","description":"Space-sim game \"Monolith\" sun shader\nParametrization: See constants at the top and several in the main\nOptimization: Use a 3d (fractal) noise texture to reduce the number of fetches down to 10\nCC-BY-3.0\n\nSimilar: https://www.shadertoy.com/view/4dXGR4","likes":11,"published":1,"flags":0,"usePreview":1,"tags":["sun","3dnoise","star","solarstorm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// If you want to use this shader in a space whatsever feel free!\n// CC-BY-3.0 Johannes Jendersie\n//\n// General technical overview:\n// First there is a fractal value noise (2d) which is wrapped onto a sphere.\n// This noise can be interpreted as temperature which is color mapped\n// at the end. A third noise dimension is used for the time.\n// Then, solar storms are added by raymarching the surrounding of the sphere\n// by a combination of different step strategies:\n//   * Using ray intersections with larger spheres\n//   * Using ray intersections with cones of different opening angle\n//     which start in the sun and are oriented towards the camera.\n// The first strategie gives good results for perpendicular rays,\n// whereas the second yields artifact free results in the tangential plane.\n// Both are combined by interpolation to create a smooth animated radial\n// burst effect.\n\n// The constants below are meant to be set from a game or other application side.\nconst vec3 SUN_CENTER = vec3(0.0);\nconst vec3 CAM_POS = vec3(0.0, 0.0, 8.0);\nconst float SUN_RADIUS = 0.9;\nconst float STORM_RADIUS = 0.7;\n\n// Get the closest point between ray and sphere. If the ray hits the sphere\n// this is a point on the surface. Otherwise, it is in the tangential plane.\nvec3 raySphereCP(vec3 spherePos, float radius, vec3 rayOrigin, vec3 rayDirection, out float mask, out float t, out float r)\n{\n    vec3 p = spherePos - rayOrigin;\n    // Distance to the closest point between ray and sphere\n\tt = dot( rayDirection, p );\n    // Distance between ray origin and center\n    float l = dot( p, p );\n    // If inside the root is positive. Go back to the surface in this case\n    r = l - t * t;\n    mask = radius * radius <= r ? 0.0 : 1.0;\n    t -= sqrt(max(0.0, radius * radius - r));\n\treturn rayOrigin + rayDirection * t;\n}\n\n// Find ray-cone intersection assuming the rays origin is on the cone axis.\nfloat simpleRayCone(vec3 rayOToConeO, vec3 rayDirection, float coneAngle, float sinConeAngle, float rcDist)\n{\n    // Compute the ray-to-cone side length of the triangle (RO, CO, intersection)\n    // using the sin rule.\n    float sinC = sin(3.1415926 - acos(dot(rayDirection, rayOToConeO) / rcDist) - coneAngle);\n    return sinConeAngle * rcDist / sinC;\n}\n\n\n// from https://www.shadertoy.com/view/4sfGzS\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n    vec2 uv = p.xy + f.xy;\n\tvec2 rg = vec2(texture( iChannel0, (uv+vec2(37.0,17.0)*p.z+0.5)/256.0, -100.0 ).x,\n                   texture( iChannel0, (uv+vec2(37.0,17.0)*(p.z+1.0)+0.5)/256.0, -100.0 ).x );\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\nfloat sunSurfaceNoise(vec3 spos, float time)\n{\n    float s = 0.28;\n    float detail = 3.0;\n    for(int i = 0; i < 4; ++i)\n    {\n        float warp = noise(spos*8.0 * detail + time);\n        float n = noise(vec3(spos.xy * detail / spos.z + vec2(warp, 0.0), time * detail / 10.0 + float(i) * 0.618033989));\n        n = pow(n, 5.0-float(i));\n        s += n / detail;\n        detail *= 1.847;\n    }\n    return s;\n}\n\n// AAARRRG: no for loop with variable count in WebGL. May use only one function with 2 or 4 octaves.\nfloat sunSurfaceNoise2(vec3 spos, float time)\n{\n    float s = 0.28;\n    float detail = 3.0;\n    for(int i = 0; i < 2; ++i)\n    {\n        float warp = noise(spos*8.0 * detail + time);\n        float n = noise(vec3(spos.xy * detail / spos.z + vec2(warp, 0.0), time * detail / 10.0 + float(i) * 0.618033989));\n        n = pow(n, 5.0-float(i));\n        s += n / detail;\n        detail *= 1.847;\n    }\n    return s;\n}\n\n// Compute solar storm heat for a single point somewhere outside the\n// sphere.\nfloat solarStorm(vec3 pos, float time)\n{\n    float l = length(pos);\n    float surfaceDist = (l - SUN_RADIUS) / STORM_RADIUS;\n    float f = sunSurfaceNoise2(pos / l, time - surfaceDist * 8.0 * STORM_RADIUS) - surfaceDist * surfaceDist - 0.35;\n    return max(0.0, f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.5;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 viewDir = normalize(vec3(uv, -3.0));\n    float mask = 0.0, t, r;\n    vec3 spos = raySphereCP(SUN_CENTER, SUN_RADIUS, CAM_POS, viewDir, mask, t, r);\n    \n    float value = 0.0;\n\n    // Noise on the sphere surface itself (masked in non sphere regions)\n    float s = sunSurfaceNoise(spos, time);\n    value = s * mask;\n    \n    // Extremly bright areas...\n    value *= 1.9;\n    value = pow(value, 4.0) * 5.0;\n    if(value > 5.0) value *= 8.0;\n\n    //value /= spos.z * 0.5 + 0.5;\n    \n    vec3 camToSun = SUN_CENTER - CAM_POS;\n    float dist = length(camToSun);\n    float cosMax = SUN_RADIUS / dist;\n    float maxAngle = acos(cosMax);\n    float cosVtimesL = dot( viewDir, camToSun );\n    float cosVMax = t / dist;\n    \n    // Solar storms\n    float storm = 0.0;\n    for(int i = 1; i <= 9; ++i)\n    {\n        float step = (float(i) ) * 0.02;\n        //s = solarStorm(spos + viewDir * step, time);\n        \n        // Projection to another sphere with a larger radius:\n        // good quality for bursts in view direction.\n        float radius = SUN_RADIUS + step;\n        float t0 = (cosVtimesL - sqrt(max(0.0, radius * radius - r)));\n        \n        // Projection to a cone starting in the sun center and pointing into\n        // viewer direction: good quality for tangential bursts.\n        float angle = float(i) / 11.0 * maxAngle;\n        float t1 = simpleRayCone(camToSun, viewDir, angle, sin(angle), dist);\n        \n        //float tf = min(t0, t1);\n        //float tf = sqrt(min(t1, t) * t0);\n        float tf = mix(t1, t0, pow(max(cosVtimesL / dist - cosVMax, 0.0) / (1.0 - cosVMax), 5.0));\n        vec3 spacePos = CAM_POS + viewDir * tf;\n        s = solarStorm(spacePos, time);\n        storm += s * s;// * s;\n    }\n    value += storm * 300.0;\n    \n    fragColor = value * vec4(1, 0.2, 0.05, 1);\n}","name":"Image","description":"","type":"image"}]}