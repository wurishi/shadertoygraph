{"ver":"0.1","info":{"id":"4XtSWX","date":"1719681573","viewed":68,"name":"tunnel in star nest","username":"nayk","description":"combination\noriginals source https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/WtsXRr https://www.shadertoy.com/view/tlt3WS","likes":3,"published":1,"flags":1,"usePreview":0,"tags":["stars","cosmos","universe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define iterations 15\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nconst float MAX_TRACE_DISTANCE = 100.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.0001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 190;\n\n\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat TWO_PI = 2.0*3.141592;\n\n\nfloat sdTunnel( vec3 p, float s )\n{\n  vec3 inp = vec3(15.5*p.x,0.5*p.y,20.0*p.z+5.0*iTime);\n  float ns =  simplex3d(inp);\n  float yy = -0.15*pow(max(0.,-0.5*p.z),1.5);\n  float angle2 = atan((p.y+yy),p.x);\n  float sph = abs(length(vec2(p.x+yy,p.y))-s)+0.01+0.017*sin(1.0*angle2+6.0*p.z+TWO_PI*iTime);\n  float offset2 = 0.05;\n  if (sph < offset2) {\n    sph += offset2 * ns;\n  }\n  return sph;\n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n \tvec2 res = vec2( sdTunnel( pos - vec3( .0 , .0 , -0.4 ) , 0.7 ) , 1. ); \n    \n    return res;\n    \n}\n\nvec3 result;\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if(t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += max(abs(h), INTERSECTION_PRECISION);\n        id = m.y;\n        result += vec3(4.*0.013/(0.5+3.0*abs((ro+rd*t).z-2.0)));\n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.05),sin(iTime*0.05),-sin(iTime*0.05),cos(iTime*0.05) );// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\n#define COLOR vec3(0.1, 0.2, 1.)\n//#define COLOR (sin(time*vec3(.345, .456, .657))*.4+.6)\n#define OFFSET vec2(0.5*cos(0.5*time-sin(time*0.5)), 0.5*sin(0.5*time+cos(time*0.75)))\n#define time iTime\n\nfloat saturate(float x){\n    return clamp(x,0.0,1.0);\n}\n\nvec3 CenterLight(vec2 p){\n    p -= OFFSET;\n    p *= 12.;\n \tfloat l = 1. / dot(p, p);\n    return l*l * COLOR;\n}\nvec3 Straws(vec2 p){\n    p -= OFFSET;\n\tfloat a = atan(p.y, p.x);\n    float d = dot(p,p);\n    \n    float l = saturate(1.-length(p));\n    \n  \n    \n    l *= 0.5 + 0.3 * sin(d*10.+a*10.-time*5.);\n    return l*l*COLOR;\n}\nvec3 Lights(vec2 p){\n    p -= OFFSET;\n    \n    float res = 0.0;\n    \n    for(float i = 0.; i < 500.; ++i){\n        float t = time + i*i;\n        \n        vec2 q = p + vec2(cos(t), sin(t)) * sin(i*11.+time*0.5);\n        float l = 0.0003 / pow(length(q), 1.5);\n        \n        res += l;\n    }\n    \n    res = res*res;\n    \n    return res * COLOR;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\n\n result = vec3(0.);\n    vec3 color = vec3(0.,0.,0.);\n    vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+vec2(0,0)))/iResolution.y;\n\n    vec3 ro = vec3( 0., 0., 2.);\n    vec3 ta = vec3( 0. , 0. , 0. );\n vec2 uvs = fragCoord.xy/iResolution.xy;\n    vec2 uv2 = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.0);\n    \n    vec2 p2 = uv2;\n    \n    col += CenterLight(p2);\n \tcol += Straws(p2);\n    col += Lights(p2);\n    \n    col = max(min(vec3(1.0), col), vec3(0.0));\n    vec3 newFrame = pow(col, vec3(5./3.2));\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n\n    vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    vec2 res = calcIntersection( ro , rd  );\n\t\n\tvec3 from=vec3(1.,.5,0.5)*result ;\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\n    fragColor+=vec4(newFrame,1.);\n}\n","name":"Image","description":"","type":"image"}]}