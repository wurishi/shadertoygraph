{"ver":"0.1","info":{"id":"lldyWn","date":"1533697241","viewed":5289,"name":"[SH18] BabyToy","username":"BigWIngs","description":"My entry for the 2018 ShaderToy competition. Mouse X&Y = rotate & light See comments for details.","likes":153,"published":1,"flags":96,"usePreview":0,"tags":["baby","human","boy","sh18","fetus","womb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Ms2SWy","filepath":"https://soundcloud.com/thyveils/mountain-and-cloud","previewfilepath":"https://soundcloud.com/thyveils/mountain-and-cloud","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [SH18] BabyToy - by Martijn Steinrucken aka BigWings 2018\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Takes a while to compile and needs a powerful graphics card to get a decent framerate.\n// mouse.x = rotate, mouse.y=light\n//\n// I did a rough sketch in Blender, using only spheres, to lay down the basics.\n//\n// I hacked in some decent translucency of the feet and hands that show a hint of the bones\n// at the cost of only one extra map call. Make sure you move the light down and have the \n// angle right to see it.\n//\n// Code is a bit of a mess and could probably be optimized more but it will never be perfect\n// and at some point you just gotta ship it. Hope you like!\n//\n// Music Mountain and Cloud - Thy Veils\n// https://soundcloud.com/thyveils/mountain-and-cloud\n// Heartbeat sound:\n// https://soundcloud.com/elderalcantara/heartbeat-sound\n//\n// Video of the effect can be found here:\n// https://youtu.be/czO9fTwVSYg\n\n// shows the baby without bubble deformation etc\n//#define DEVELOPER\n\n// I'm using bounding volumes for the head hands and feet so it doesn't\n// have to evaluate all the toes, nails wrinkles etc, if its still far away\n// should be faster..\n#define USE_BOUNDING_VOLUMES\n\n// turns on my hacky sub surface scattering implementation on the feet and hands\n#define USE_SSS\n\n\n// raymarch settings\n#define MIN_DIST .1\n#define MAX_DIST 8.\n#define MAX_STEPS 200.\n#define SURF_DIST .005\n\nfloat Map(vec3 p);\n\n\n// started out with this struct, not really using most of it so for this shader the \n// castray function could probably just return a vec4\nstruct de {\n    vec3 p;\n    vec3 rp;\n    float dm; \t\t// minimum passing distance\n    float mat;\n    float i;\t\t// number of iters before break\n};\n\n\n// https://iquilezles.org/articles/distfunctions   \nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n\n// like sdCapsule but this can vary width and smoothing along the length of it\nfloat Capsule( vec3 p, vec3 a, vec3 b, float r1, float r2, float s1, float s2, float d )\n{\n\tvec3 pa = p-a, ba = b-a;\n    float t = dot(pa,ba)/dot(ba,ba);\n\tfloat h = clamp( t, 0.0, 1.0 );\n\td = smin(d, length( pa - ba*h ) - mix(r1, r2, S(0.,1.,h)), mix(s1, s2, h))*.98;\n    \n    return d;\n}\n\n// I was trying to get more toe definition so I added an additional tweakable notch\n// Turns out that for the toes it didn't really work but it gave nice wrinkles at the \n// bottom of the foot. Lucky accident!\nfloat ToeCaps(vec3 p, vec3 a, vec3 b, float r1, float r2, float s1, float s2, float d, float x, float y, float k )\n{\n\tvec3 pa = p-a, ba = b-a;\n    float t = dot(pa,ba)/dot(ba,ba);\n\tfloat h = clamp( t, 0.0, 1.0 );\n\td = smin(d, length( pa - ba*h ) - mix(r1, r2, S(0.,1.,h)), mix(s1, s2, h))*.98;\n    \n    float g = 1.-min(1., abs(h-x)*k);\n    d -= g*g*g*g*y;\n    return d;\n}\n\nvec3 GetRay(vec2 uv, vec3 p, vec3 lookat, vec3 up, float zoom) {\n    vec3 f = normalize(lookat-p),\n         r = normalize(cross(up, f)),\n         u = cross(f, r),\n         c = p+f*zoom,\n         i = c + r*uv.x + u*uv.y;\n    \n    return normalize(i-p);\n}\n\n/*\nvec3 GetNormal( vec3 p ) {\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    Map(p+eps.xyy) - Map(p-eps.xyy),\n\t    Map(p+eps.yxy) - Map(p-eps.yxy),\n\t    Map(p+eps.yyx) - Map(p-eps.yyx) );\n\treturn normalize(nor);\n}*/\n#define ZERO 0\n// Faster compilation by preventing inlining of Map function\n// Thanks IQ!\nvec3 GetNormal( vec3 p )\n{\n    const float eps = 0.01;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*Map(p+eps*e);\n    }\n    return normalize(n);\n}\n\n\n\n\nfloat dHand(vec3 p, vec3 pWrist) {\n    #ifdef USE_BOUNDING_VOLUMES\n    float handDist = length(p-(pWrist+vec3(.1,.35,.4)));\n    if(handDist>.95) return handDist-.65;\n    #endif\n    \n    vec3 pThumb = pWrist+vec3(-.34, 0.43,.4);\n    vec3 piFinger = pWrist+vec3(-.13, .72,.64);\n    vec3 pmFinger = pWrist+vec3(.09, .74,.62);\n    vec3 prFinger = pWrist+vec3(.3, .68,.52);\n    vec3 pPinky = pWrist+vec3(.49, .54,.36);\n    \n    pWrist -= vec3(0,-.1,.05);\n    float s1 = .05;\n    float s2 = .1;\n    \n    float d = MAX_DIST;\n    \n    d = Capsule(p, pWrist+vec3(0,0,0), pThumb, .2, .13, s1, s2, d);\n    d = Capsule(p, pThumb, pThumb+vec3(0,0,.2), .13, .12, .06, .01, d);\n    d = smin(d, length(pThumb+vec3(0.05,-.1,.2)-p)-.08, .1);\n    \n    d = Capsule(p, pWrist+vec3(0,.0,0), piFinger, .2, .12, s1, s2, d);\n    d = Capsule(p, piFinger, piFinger+vec3(0,0,.2), .12, .11, .03, .01, d);\n    d = smin(d, length(piFinger+vec3(0.,-.1,.2)-p)-.08, .1);\n    \n    d = Capsule(p, pWrist+vec3(0,.0,0), pmFinger, .2, .13, s1, s2, d);\n    d = Capsule(p, pmFinger, pmFinger+vec3(.025,0,.2), .12, .11, .03, .01, d);\n    d = smin(d, length(pmFinger+vec3(0.075,-.1,.2)-p)-.08, .1);\n    \n    d = Capsule(p, pWrist+vec3(0,.0,0), prFinger, .2, .13, s1, s2, d);\n    d = Capsule(p, prFinger, prFinger+vec3(.05,0,.2), .12, .11, .03, .01, d);\n    d = smin(d, length(prFinger+vec3(0.075,-.1,.28)-p)-.08, .1);\n    d = min(d,  length(prFinger+vec3(0.08,-.08,.285)-p)-.08);\n    \n    d = Capsule(p, pWrist+vec3(0,.0,0), pPinky, .2, .13, s1, s2, d);\n    d = Capsule(p, pPinky, pPinky+vec3(0.075,0,.2), .12, .11, .03, .01, d);\n    d = smin(d, length(pPinky+vec3(0.075,-.1,.28)-p)-.08, .1);\n     d = min(d, length(pPinky+vec3(0.08,-.08,.285)-p)-.08);\n    \n    return d;\n}\n\nfloat dFoot(vec3 p, vec3 pAnkle) {\n    #ifdef USE_BOUNDING_VOLUMES\n    float footDist = length(p-(pAnkle+vec3(-.1,.6,.1)));\n    if(footDist>1.) return footDist-.75;\n    #endif\n    \n    vec3 g = p;\n    p -= pAnkle;\n    vec3 pToe1 = vec3(-.6, 1.02,.21);\n    vec3 pToe2 = vec3(-.42, 1.15,.07);\n    vec3 pToe3 = vec3(-.24, 1.17,-.01);\n    vec3 pToe4 = vec3(-.05, 1.13,-.13);\n    vec3 pToe5 = vec3(.15, 1.02,-.24);\n    \n    float d = ToeCaps(p, vec3(0), pToe1, .2, .13, .25, .05, MAX_DIST, .85, -.01, 8.);\n    d = ToeCaps(p, vec3(0), pToe2, .2, .1, .25, .05, d, .5, -.02, 8.);\n    d = ToeCaps(p, vec3(0), pToe3, .2, .1, .25, .05, d, .35, -.01, 6.);\n    d = ToeCaps(p, vec3(0), pToe4, .2, .1, .25, .04, d, .25, -.01, 6.);\n    d = Capsule(p, vec3(.2,.1,0), pToe5, .18, .09, .25, .07, d);\n   \n    vec3 h = vec3(.05, .02, .0);\n    \n    d = smin(d, length(p-(pToe5+vec3(.02, .02, .02)))-.08, .05);\n    \n    \n    float toeNails = length(pToe1-p-vec3(.05,0,.1)*.5)-.09;\n    toeNails = min(toeNails, length(pToe2-p-vec3(.05,0,.1)*.4)-.07);\n    toeNails = min(toeNails, length(pToe3-p-vec3(.05,0,.1)*.35)-.07);\n    toeNails = min(toeNails, length(pToe4-p-vec3(.05,0,.1)*.35)-.07);\n    \n    d = smin(d, toeNails, .01);\n    \n    return d;\n}\n\nfloat dHead(vec3 p) {\n    #ifdef USE_BOUNDING_VOLUMES\n    float headDist = length(p-vec3(-2.3,1.36,0));\n    if(headDist > 2.) return (headDist-1.6);\n    #endif\n        \n    // head\n    vec3 hp = p-vec3(-2.71,1.36,0);\n    float d = length((hp)*vec3(1,1,1.2))-1.2;\t\t\t\t// back of head\n    d = smin(d, length(p-vec3(-2.06,1.71,0))-.94, .5);\t\t// forehead\n    d = smin(d, length(p-vec3(-1.83,1.02,0))-.94,.1);\t\t// jaws etc\n    \n     // ears\n    vec3 tp = p-vec3(-2.27, .73, -.95);\n    tp.z -= tp.x*.4;\n    tp.z -= S(.9, .0, p.y)*.1;\n    tp.x += -.25*S(.3, -.4, tp.y+.1);\n    float dEar = length(tp.xy-vec2(.1, 0));\n    float ear = sdCylinder(tp.xzy-vec3(0,.18,0), vec2(.25, .15));\n    ear += cos(dEar*30.-3.)*.01;\n    ear = smin(ear, sdTorus(tp.xzy, vec2(.25, .043)), .05);\n    d = smin(d, ear*.8, .05);\n     \n    \n    d = smin(d, .12-length(p-vec3(-2.05, .7, -.94)), -.07);\n   // d = smin(d, .08-length(p-vec3(-2.0, .7, -.75)), -.04);\n    \n    \n    // eyes\n    vec3 ep = p-vec3(-1.37,1.46,-.4);\n    float ed = length(ep)-.3;\n    float slitFade = S(-.79, -.5, p.z);\n    slitFade *= S(-.1, -.5, p.z);\n    ed += S(.05*slitFade, 0., abs(ep.y-abs(ep.x*.6)))*.02*slitFade;\n    d = smin(d, ed, .1);\n    \n    // mouth\n    float md = length((p-vec3(-.78,.9,0))*vec3(1,1,.4))-.09;\n    float noseGutter = cos(p.z*30.)*.2*S(.3, .0, -p.z)*.15*S(.85, 1.3, p.y);\n    md = smin(-md, length(p-vec3(-1.25,.98,0))-.56+noseGutter, -.075);\n    d = smin(d, md,.1+pow(abs(cos(iTime*.25)), 10.)*.175);\t\t\n    \n    // nose\n    d = Capsule(p, vec3(-.9,1.37,0), vec3(-1.26,1.59,0), .2, .15, .1, .3, d);\n    float nd = length(p-vec3(-.83, 1.27, -.12))-.05;\n    d = smin(d, length(p-vec3(-.9,1.3,-.16))-.12,.1);\n    d = smin(-nd, d, -.14);\n\n    d = smin(d, length(p-vec3(-1.17,.611,0))-.348,.05);\t\t// chin\n    \n    return d;\n}   \n\nfloat dCord(vec3 p) {\n    #ifdef USE_BOUNDING_VOLUMES\n    float cordDist = sdCapsule(p, vec3(1, -1, 0), vec3(1, 5., 0),.01);\n    if(cordDist>.5 && p.y<4.) return (cordDist-.35);\n    #endif\n    \n    vec3 up = p-vec3(1, -1, 0);\n    float g = p.y * 2.;\n    float r = .13+S(4., 6., p.y)*2.5;\n    up = p+vec3(sin(g), 0, cos(g))*.2;\n    float d = sdCapsule(up, vec3(1, -1, 0), vec3(1, 5., 0), r);\n    float a = atan(up.x-1., up.z);\n    d += sin(a*3.+p.y*7.)*.03;\n    \n    return d*.8;\n}\n\nfloat dBody(vec3 p) {\n    #ifdef USE_BOUNDING_VOLUMES\n\tif(p.y>0.7) return p.y+.2;\n    if(abs(p.z)>1.5) return abs(p.z)-1.1;\n    #endif\n    \n    float d = length(p-vec3(-2.16,.2,0))-.758;\t\t// neck\n    d -= abs(sin(p.x*-4.+p.y*20.))*.0075*S(0., 1., p.y+.25);\n    \n    d = smin(d, length(p-vec3(-1.49,-.63,0))-.947,.25);\t\t// chest\n    d = smin(d, length(p-vec3(-.52,-1.09,0))-1.063,.35);\t// chest/body\n    d = smin(d, length(p-vec3(.41,-1.37,0))-1.09,.35);\t\t// belly\n     d -= abs(sin(p.x*8.+p.z*-2.))*.03*S(1., 0., abs(p.x+.2));\n    return d;\n}\n\nfloat Map(vec3 p) {\n    float d;\n    float m = iMouse.y/iResolution.y - .5;\n    float side = step(p.z, 0.)-.5;\n    vec3 offs = vec3(side, side*.2, -0.5);\n    float t= iTime;\n    float j = sin(t+sin(t));\n    offs.xy *= .5*j;    \n    \n    vec3 pm = vec3(p.x, p.y, -abs(p.z));\n   \n    d = dHead(pm);\n    d = smin(d, dBody(pm), .1);\n    d = smin(d, dCord(p), .1); \n    \n    // arm\n    vec3 pShoulder = vec3(-1.79,-.75,-1)+vec3(.2,.1,0);\n    vec3 pElbow = vec3(-.37, -1.05,-1.39);\n    vec3 pWrist = vec3(-.02, .33,-.92)+offs;\n    d = Capsule(pm, pShoulder, pElbow, .57, .45, .4, .1, d);\n    d = Capsule(pm, pElbow, pWrist, .43, .31, .05, .05, d);\n    d = smin(d, dHand(pm, pWrist), .1);\n    \n    // leg\n    vec3 pHip = vec3(1.05, -1.87,-.35);\n    vec3 pKnee = vec3(.82, -0.87,-1.39);\n    vec3 pAnkle = vec3(1.86, -0.03,-.42)+offs;\n    d = Capsule(pm, pHip, pKnee, .69, .43, .05, .01, d);\n    d = Capsule(pm, pKnee, pAnkle, .43, .34, .05, .05, d);\n    d = smin(d, dFoot(pm, pAnkle), .1);\n    \n    // genitals\n    d = smin(d, length(vec3(1.5, -1.52, 0)-p)-.22, .075);\n    d = smin(d, length(vec3(1.62, -1.25, 0)-p)-.07, .1);\n    \n    return d;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = Map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\nde CastRay(vec3 ro, vec3 rd) {\n    vec3 p = ro + MIN_DIST*rd;\n    float dS;\n    float dC = 0.;\n    float mat = 0.;\n    float dM = MAX_DIST;\n    \n    float m = iMouse.y/iResolution.y -.5;\n\n    \n    dC = MIN_DIST;\n    for(float i=0.;i<MAX_STEPS; i++) {\n    \tp = ro + dC * rd;\n        \n        dS = Map(p);\n        \n        if(dS<SURF_DIST || dC>MAX_DIST)\n            break;\n        \n        dM = min(dM, dS);\n        dC += dS;\n    }\n    \n    if(dS<SURF_DIST)\n        mat = 1.;\n    \n    de o;\n    o.p = p;\n    o.dm = dM;\n    o.mat = mat;\n    //o.i = i;\n    \n    return o;\n}\n\nvec3 Background(vec2 uv, vec3 ro, vec3 rd) {\n\tfloat d = length(uv-vec2(0., .2));\n    \n    vec3 col = vec3(1., .4, .3);\n    col *= S(.8, .0, d)*1.5;//(1.5+sin(iTime)*.5);\n    \n    return col;\n}\n\nvec2 RaySphere(vec3 ro, vec3 rd, vec3 s, float r) {\n    float t = dot(s-ro, rd);\n    vec3 p = ro+rd*t;\n    float y = length(s-p);\n    if(y<r) {\n        float x = sqrt(r*r-y*y);\n        return vec2(t-x, t+x);\n    }\n    return vec2(-1, -1);\n}\n\nvec3 Render(vec2 uv, vec3 ro, vec3 rd) {\n    \n    ro.x += sin(rd.x*5.+iTime)*.1;\t\t\t\t// bend rays to get some waviness\n    ro.y += sin(rd.y*6.+iTime)*.1;\n    \n    vec3 bg = Background(uv, ro, rd);\n    vec3 col = bg;\n    \n    vec3 pBubble = vec3(.13, 1.42, .0);\n    vec2 s = RaySphere(ro, rd, pBubble, 4.075);\t// get intersection with the bubble\n    if(s.x==-1.) {\t\t\t\t\t\t\t\t// if there is no intersection, then just render background\n        col = col.bgr*(1.+sin(iTime)*.2);\n        col *= 1.-texture(iChannel0, (uv+.5)*.7).x*.4;\n        return col;\t\t\t\t\t\t\t\t// .. and we are done!\n    }\n    \n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    #ifdef DEVELOPER\n    vec3 nb = vec3(0);\n    #else\n   \n    ro = ro+s.x*rd;\t\t\t\t\t\t\t\t// forward ray to boundary of bubble\n    vec3 nb = normalize(ro-pBubble);\t\t\t// bubble normal\n\tfloat fresnel = 1.-max(0., -dot(nb, rd));\t// falloff on sides of bubble\n    #endif\n    \n    de result = CastRay(ro, normalize(rd-nb*.5)); // bend ray inwards a bit to get refraction effect\n    \n    if(result.mat>0.) {\n        \n        vec3 n = GetNormal(result.p);\n       \n        \n        vec3 light = normalize(vec3(1,1,1));\n        \n        #ifdef DEVELOPER\n        return vec3(dot(n, light));\n        #endif\n        float lh = m.x<.03||m.x>.97?(-cos(iTime*.2)*.5+.5):m.y;\n        light = vec3(1., 6.*lh, 0.)-result.p;\n        float l = min(1., 5./dot(light, light));\n        \n        float dif = max(0., dot(n, normalize(light)));\n       \n        \n        float ao = calcAO(result.p, n);\t\t // IQs ambient occlusion \n        dif = max(dif, .2)*ao*2.*l;\n        float bfresnel = max(0., -dot(n, rd)); // get fresnel falloff of baby\n        \n                               \n        vec3 baseCol = vec3(1., .4, .2);\n        // modeling the earhole looked problematic due to fresnel, so I just render a dark spot there\n        float earHole = length(vec3(result.p.x,result.p.y,abs(result.p.z))-vec3(-2.03, .7, .8));\n        earHole = S(.05, .1, earHole);\n        baseCol *= mix(.3, 1., earHole);\n        \n        col = mix(col, dif * baseCol, bfresnel);\n        \n       \n        float d = length(result.p-ro);\t// distance from front of bubble along eye ray\n        d = S(2., 7., d);\t\t\t\t// add some distance fade \n        col = mix(col, bg, d);\n        col = mix(col, bg, S(3., 6., result.p.y)); // fade bottom of bubble black\n\n        // cheap sub surface scattering\n\t\t#ifdef USE_SSS    \t\t\t\t\t\t\t\t\t\t\n        float sss = 1.-Map(result.p+rd*.1)/-.1;\t\t// advance ray a bit past hit point\t\n        \n        float sssMask = S(2.7,.0,length(light));\t// only show sss when close to light\n        float angleFade = abs(nb.b);\t\t\t\t// mask unflattering angle\n        col.r += max(0.,sss)*sssMask*angleFade;\t\t// add sss only in red channel\n\t\t#endif\n        \n       \n    }\n    \n    #ifndef DEVELOPER\n\n    \n    vec3 rimCol = pow(fresnel, 3.)*S(1., .9, fresnel)*vec3(1., .55, .5);\n    rimCol *= S(.6, .0, -rd.y);\n    col += rimCol;\n    \n    \n    #endif\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tfloat t = iTime*2.;\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    \n\tt *= m.x<.03||m.x>.97 ? .2 : 0.;\n    vec3 cPos = vec3(sin(m.x*6.283+t), .2, cos(m.x*6.283+t))*6.;\n    vec3 cLookat = vec3(0);\n    //cLookat= vec3(-.9, 1.37, 0);\n    //cLookat = vec3(-1.37,1.46,-.4);\n    cLookat = vec3(-0,1.42,0);\n    \n    #ifdef DEVELOPER\n    float zoom = 1.;\n    #else\n    float zoom = .5;\n    #endif\n    \n    vec3 up = vec3(0, 1, 0);\n    vec3 eyeRay = GetRay(uv, cPos, cLookat, up, zoom);\n    \n    vec3 col = Render(uv, cPos, eyeRay);\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define S(a,b,t) smoothstep(a,b,t)\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat N2(vec2 p) {\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat N2(float x, float y) { return N2(vec2(x, y)); }\n\nvec3 N23(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 N23(float x, float y) {return N23(vec2(x, y));}\n\n\n\nfloat SmoothNoise(vec2 uv) {\n    // noise function I came up with\n    // ... doesn't look exactly the same as what i've seen elswhere\n    // .. seems to work though :)\n    vec2 id = floor(uv);\n    vec2 m = fract(uv);\n    m = 3.*m*m - 2.*m*m*m;\n    \n    float top = mix(N2(id.x, id.y), N2(id.x+1., id.y), m.x);\n    float bot = mix(N2(id.x, id.y+1.), N2(id.x+1., id.y+1.), m.x);\n    \n    return mix(top, bot, m.y);\n}\n\nfloat LayerNoise(vec2 uv) {\n    float c = SmoothNoise(uv*4.);\n    c += SmoothNoise(uv*8.)*.5;\n    c += SmoothNoise(uv*16.)*.25;\n    c += SmoothNoise(uv*32.)*.125;\n    c += SmoothNoise(uv*65.)*.0625;\n    \n    return c / 2.;\n}\n\nvec3 SmoothNoise3(vec2 uv) {\n    // noise function I came up with\n    // ... doesn't look exactly the same as what i've seen elswhere\n    // .. seems to work though :)\n    vec2 id = floor(uv);\n    vec2 m = fract(uv);\n    m = 3.*m*m - 2.*m*m*m;\n    \n    vec3 top = mix(N23(id.x, id.y), N23(id.x+1., id.y), m.x);\n    vec3 bot = mix(N23(id.x, id.y+1.), N23(id.x+1., id.y+1.), m.x);\n    \n    return mix(top, bot, m.y);\n}\n\nvec3 LayerNoise3(vec2 uv) {\n    vec3 c = SmoothNoise3(uv*4.);\n    c += SmoothNoise3(uv*8.)*.5;\n    c += SmoothNoise3(uv*16.)*.25;\n    c += SmoothNoise3(uv*32.)*.125;\n    c += SmoothNoise3(uv*65.)*.0625;\n    \n    return c / 2.;\n}\n\n\n/*\nfloat dEllipsoid(vec3 p, vec3 a, vec3 b, float r) {\n\tfloat d1 = length(p-a);\n    float d2 = length(p-b);\n    float d3 = length(a-b);\n    return mix(d1, d2, .5)-.5*d3-r;\n}*/\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Some value noise that only gets rendered for the first 5 frames,\n// or when the resolution has changed. In order to detect the resolution change\n// the width of the screen is written into the alpha channel. \n// I took this idea from one of Shane's shaders.\n// Its used to give some texture to the background. I tried using it to texture the\n// body and the womb walls but it just turned out to be distracting and it was too hard to\n// get proper uv coordinates that would stick on the body while its kicking so in the end\n// I decided that less is more ;)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    if(iFrame<5|| abs(iResolution.x - col.a)>.001) {\n    \tvec3 center = LayerNoise3(uv*5.);\n        vec3 edge = LayerNoise3(fract(uv-vec2(.5))*5.);\n        \n        uv -= .5;\n        col.rgb = mix(center, edge, dot(uv, uv));\n    }\n\n\tcol.a = iResolution.x;\n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"}]}