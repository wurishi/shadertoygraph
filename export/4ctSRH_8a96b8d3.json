{"ver":"0.1","info":{"id":"4ctSRH","date":"1713602918","viewed":69,"name":"Gradient 2d pixel snake","username":"fredthedeadhead","description":"Snake made of rounded pixels, that bounces around the screen at a 45 degree angle. The pixels are shaded with a colour gradient.\n\nThis is my first shader - hints and tips are very much appreciated!\n\nI would like to be able to make the snake smooth...","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["gradient"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float speed = 0.6;\n\nconst int tailSize = 10;\nconst float tailTimeStep = 0.3;\n// TODO I want to make the snake 'smooth', so it looks like a continuous line.\n//      I can bump up tailSize and decrease tailTimeStep, but the performance is bad :(\n//const int tailSize = 500;\n//const float tailTimeStep = 0.01;\n\nconst float border = 0.4; // a tiny black border, so the snake doesn't _quite_ touch the side.\n\nvec3 orange = vec3(1.0, 0.5803921568627451, 0.);\nvec3 red = vec3(1.,0.008,0.114);\nvec3 purple = vec3(0.9019607843137255, 0, 1);\n\nvoid flip(inout vec2 pos) {\n    vec2 flip = mod(floor(pos), 2.);\n    pos = abs(flip - mod(pos, 1.));\n}\n\nfloat roundedBox(vec2 center, vec2 size, float radius) {\n    return length(max(abs(center) - size + radius, 0.0)) - radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 screenSize = vec2(aspectRatio, 1.) * 2.;\n    \n    float time = iDate.w;\n    \n    vec4 col = vec4(0,0,0,0); // black background\n    \n    for (int i = 0; i < tailSize; i++) {\n        time += tailTimeStep;\n\n        vec2 direction = vec2(1., 1.);\n        vec2 move = direction * time * speed;\n        float snakeScale = .1;\n        vec2 snakeSize = vec2(snakeScale);\n\n        vec2 size = screenSize - snakeSize * (2.0 + border); \n\n        // Remap so (0,0) is bottom left, and (1,1) is top right\n        move = move / size + .5;\n\n        // Flip every second cell to create reflection\n        flip(move);\n\n        // Remap back to screen space\n        move = (move - .5) * size;\n\n        // box\n        vec2 pos = (p - move) / snakeScale;\n        float d = roundedBox(pos, vec2(snakeScale), -0.5);\n        d = smoothstep(1., 0.95, d);\n\n        vec3 gradient;\n        if (float(i) / float(tailSize) <= 0.3) {\n            gradient = mix(purple, red, float(i) / (0.3 * float(tailSize)));\n        } else {\n            gradient = mix(red, orange, (float(i) - 0.3 * float(tailSize)) / (0.7 * float(tailSize)));\n        }\n\n        col.rgb = mix(col.rgb, gradient, d);\n    }\n    fragColor = col;\n}\n","name":"Image","description":"","type":"image"}]}