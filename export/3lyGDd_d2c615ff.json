{"ver":"0.1","info":{"id":"3lyGDd","date":"1580143133","viewed":346,"name":"Sunset Waves","username":"peterbraden","description":"Mix of other peoples work.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["waves","sunset","rayleigh","mie"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// - rand sea from https://www.shadertoy.com/view/Ms2SD1\n// - various from https://github.com/erichlof/THREE.js-PathTracing-Renderer/blob/gh-pages/js/pathTracingCommon.js\n\nprecision mediump float;\nstruct Ray { vec3 origin; vec3 direction; };\n\n#define INFINITY         999.9e16\n#define PI               3.14159265358979323\n#define PHI              1.61803398874989484820459  // Golden Ratio   \n#define EARTH_RADIUS      6360000.0 // in m\n#define ATMOSPHERE_RADIUS 6420000.0 // in m\n#define SUN_POWER 20.0\n#define SKY_SAMPLES 16\n#define SUN_SAMPLES 8\n#define SUNTIME (iTime/2.0)\n#define EPSILON_NRM (0.1 / iResolution.x)\n    \nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 2.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\nconst int NUM_STEPS = 8;\n\nfloat hash( vec2 p ) {\n  return fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);}\n\n\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uv+iTime)*freq,choppy);\n    \td += sea_octave((uv-iTime)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = sea_octave((uv+iTime)*freq,choppy);\n    \td += sea_octave((uv-iTime)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(Ray ray, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ray.origin + ray.direction * tx);\n    if(hx > 0.0) return tx;   \n    float hm = map(ray.origin + ray.direction * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ray.origin + ray.direction * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n\nbool solveQuadratic(float a, float b, float c, out float t0, out float t1){\n\tfloat discrim = b * b - 4.0 * a * c;\n\tif (discrim < 0.0) return false;\n\tfloat rootDiscrim = sqrt(discrim);\n\tfloat q = (b > 0.0) ? -0.5 * (b + rootDiscrim) : -0.5 * (b - rootDiscrim); \n\tt1 = q / a; \n\tt0 = c / q;\n\treturn true;\n}\n\nbool PlanetSphereIntersect( Ray ray, float rad, vec3 pos, inout float t0, inout float t1 ) {\n\tvec3 L = ray.origin - pos;\n\tfloat a = dot( ray.direction, ray.direction );\n\tfloat b = 2.0 * dot( ray.direction, L );\n\tfloat c = dot( L, L ) - (rad * rad);\n\n\tif (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n\t\n\tfloat temp;\n\tif (t0 > t1)\n\t{\n\t\ttemp = t0;\n\t\tt0 = t1;\n\t\tt1 = temp;\n\t}\n\treturn true;\n}\n\nvec3 calculateSkySphereColor(Ray r, float tmin, float tmax, vec3 sunDirection){ \n  vec3 earthCenter = vec3(0, -1.0 * EARTH_RADIUS, 0);\n\tvec3 betaR = vec3(3.8e-6, 13.5e-6, 33.1e-6); \n\tvec3 betaM = vec3(21e-6);  \n\tfloat Hr = 7994.0;\n\tfloat Hm = 1200.0;\n\tfloat t0, t1; \n\tif (!PlanetSphereIntersect(r, ATMOSPHERE_RADIUS, earthCenter, t0, t1) || t1 < 0.0) return vec3(0); \n\tif (t0 > tmin && t0 > 0.0) tmin = t0; \n\tif (t1 < tmax) tmax = t1; \n  float segmentLength = (tmax - tmin) / float(SKY_SAMPLES); \n\tfloat tCurrent = tmin; \n\tvec3 sumR = vec3(0); // rayleigh contribution\n\tvec3 sumM = vec3(0); // mie contribution \n\tfloat opticalDepthR = 0.0;\n\tfloat opticalDepthM = 0.0; \n\tfloat mu = dot(r.direction, sunDirection); // mu in the paper which is the cosine of the angle between the sun direction and the ray direction \n\tfloat phaseR = 3.0 / (16.0 * PI) * (1.0 + mu * mu); \n\tfloat g = 0.76; \n\tfloat phaseM = 3.0 / (8.0 * PI) * ((1.0 - g * g) * (1.0 + mu * mu)) / ((2.0 + g * g) * pow(max(0.0, 1.0 + g * g - 2.0 * g * mu), 1.5)); \n\n  for (int i = 0; i < SKY_SAMPLES; ++i) { \n\t\tvec3 samplePosition = r.origin + (tCurrent) * r.direction; \n\t\tfloat height = length(samplePosition - earthCenter) - EARTH_RADIUS; \n\n\t\t// compute optical depth for light\n\t\tfloat hr = exp(-height / Hr) * segmentLength; \n\t\tfloat hm = exp(-height / Hm) * segmentLength; \n\t\topticalDepthR += hr; \n\t\topticalDepthM += hm; \n\n\t\t// light optical depth\n\t\tfloat t0Light, t1Light; \n\t\tPlanetSphereIntersect(Ray(samplePosition, sunDirection), ATMOSPHERE_RADIUS, earthCenter, t0Light, t1Light); \n\t\tfloat segmentLengthLight = t1Light / float(SUN_SAMPLES);\n\t\tfloat tCurrentLight = 0.0; \n\t\tfloat opticalDepthLightR = 0.0;\n\t\tfloat opticalDepthLightM = 0.0; \n\t\tint jCounter = 0; \n    for (int j = 0; j < SUN_SAMPLES; ++j) { \n\t\t\tvec3 samplePositionLight = samplePosition + (tCurrentLight) * sunDirection; \n\t\t\tfloat heightLight = length(samplePositionLight - earthCenter) - EARTH_RADIUS; \n\t\t\tif (heightLight < 0.0) break;\n\t\t\tjCounter += 1;\n\t\t\topticalDepthLightR += exp(-heightLight / Hr) * segmentLengthLight; \n\t\t\topticalDepthLightM += exp(-heightLight / Hm) * segmentLengthLight; \n\t\t\ttCurrentLight += segmentLengthLight; \n\t\t} \n\t\tif (jCounter == SUN_SAMPLES) { \n\t\t\tvec3 tau = betaR * (opticalDepthR + opticalDepthLightR) + betaM * 1.1 * (opticalDepthM + opticalDepthLightM); \n\t\t\tvec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z)); \n\t\t\tsumR += attenuation * hr; \n\t\t\tsumM += attenuation * hm; \n\t\t} \n\t\ttCurrent += segmentLength; \n  } \n\n  vec3 attenuate_vec = (sumR * betaR * phaseR + sumM * betaM * phaseM) * SUN_POWER;\n  //return attenuate_vec;\n  // color map\n  if (attenuate_vec.x < 1.413) { \n    attenuate_vec.x = pow(attenuate_vec.x * 0.38317, 1.0 / 2.2); \n  } else { \n    attenuate_vec.x = 1.0 - exp(-attenuate_vec.x);\n  } \n  if (attenuate_vec.y < 1.413){\n    attenuate_vec.y = pow(attenuate_vec.y * 0.38317, 1.0 / 2.2); \n  } else { \n    attenuate_vec.y = 1.0 - exp(-attenuate_vec.y);\n  } \n  if (attenuate_vec.z < 1.413){\n    attenuate_vec.z = pow(attenuate_vec.z * 0.38317, 1.0 / 2.2); \n  } else { \n    attenuate_vec.z = 1.0 - exp(-attenuate_vec.z);\n  }\n  return attenuate_vec;\n} \n\nvec3 calculateSkyColor(Ray r, float tmin, float tmax, vec3 sunDirection){\n  return calculateSkySphereColor(r, tmin, tmax, sunDirection);\n}\n\nvec3 perspectiveCameraRayDirection(in vec2 pixelCoord) {\n  vec2 pixelPos = (pixelCoord) * 2.0 - 1.0;\n  vec3 camRight   = vec3( 1.0,  0.0,  0.0);\n  vec3 camUp      = vec3( 0.0,  1.0,  0.0);\n  vec3 camForward = vec3(0.0, 0.0, 1.0);\n  return normalize( pixelPos.x * camRight + pixelPos.y * camUp + camForward );\n}\n\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\n    fresnel = pow(fresnel,3.0) * 0.5;\n        \n    vec3 reflected = calculateSkyColor(Ray(vec3(0), reflect(eye,n)), 0.0, INFINITY, l);    \n    vec3 base = SEA_BASE * calculateSkyColor(Ray(vec3(0), vec3(1.0)), 0.0, INFINITY, l); // SEA_BASE\n    vec3 refracted = base + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n\n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    float atten = max(1.0 - dot(dist,dist) * 0.01, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    color += vec3(specular(n,l,eye,20.0))* 0.8 * reflected;\n    return color;\n}\n\nvec4 pixel(in vec2 uv ) {\n  Ray r = Ray( vec3(0.0, 3.0,  -15.0), perspectiveCameraRayDirection(uv));\n  vec3 sunDir = normalize(vec3(0,abs(cos(SUNTIME))/2.0 - 0.2, abs(sin(SUNTIME)) * 2.0));\n  vec3 sky = calculateSkyColor(r, 0.0, INFINITY, sunDir);\n  vec3 p;\n  heightMapTracing(r,p);\n  vec3 dist = p - r.origin;\n  vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n\n  vec3 waves = mix(\n        sky,\n        getSeaColor(p,n, sunDir, r.direction, dist),\n    \tpow(smoothstep(0.0,-0.5,r.direction.y),0.5));\n\n  return vec4(waves, 1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 aa = 0.25 / iResolution.xy;\n  fragColor = pixel(uv); \n  fragColor += pixel(uv + aa);\n  fragColor *= 0.5;  \n}\n","name":"Image","description":"","type":"image"}]}