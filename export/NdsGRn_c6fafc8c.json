{"ver":"0.1","info":{"id":"NdsGRn","date":"1615393539","viewed":323,"name":"inverse bluenoise","username":"Carandiru","description":"experiments with inverse generated by checkerboard pattern sampling in successive buffers?\ntop = bluenoise + inverse bluenoise quaternion based animation (trick?)\nleft = bluenoise\nright = inverted bluenoise\ngreen = sum (cancelling out)","likes":5,"published":3,"flags":32,"usePreview":0,"tags":["inverse","bluenoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// inverse bluenoise by checkerboard convolution\n// http://bit.ly/supersinfulsilicon\n\n// inverse bluenoise by checkerboard convolution by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/NdsGRn\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\n#define PI (3.141592653589793 * 2.0f)\n\nvec4 qmul(in vec4 q0, in vec4 q1)\n{\n    vec4 qq;\n    \n    qq.xyz = cross(q0.xyz, q1.xyz) + q0.w*q1.xyz + q1.w*q0.xyz;\n    qq.w = q0.w*q1.w - dot(q0.xyz, q1.xyz);\n    return(qq);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float inverse_bn, bn;\n    \n    inverse_bn = textureLod(iChannel0, uv, 0.0f).r;\n    bn = textureLod(iChannel1, fragCoord/iChannelResolution[1].xy, 0.0f).r;\n    \n    // expand inverse back, inverse is all negative values\n    inverse_bn = inverse_bn * 2.0f - 1.0f;\n    \n    // which ends up being like...\n    // bn [0.0 ... 1.0]\n    // inverse_bn [0.0 ... -1.0]\n    // combined range [1.0 ... -1.0]\n    \n    vec3 color = vec3(0);\n    \n    float green_mask = mix(0.01f, 0.25f, fract(iTime));\n    if (uv.y < green_mask && uv.y > (green_mask - 0.1f)) {\n    \n        // sum\n        color.g = (bn + inverse_bn) * 0.5f + 0.5f;\n    }\n    else if (uv.y > 0.25f) {\n        \n        // quaternion op\n        \n        float tt = iTime;\n        vec4 p = vec4(uv, 0.0f, 0.0f); p = p * 2.0f - 1.0f;\n        vec4 q = normalize(vec4(cos((tt + bn) * PI), -sin((tt + bn) * PI), 0.0f, 1.0f));\n        vec4 q_inv = normalize(vec4(cos((tt - inverse_bn) * PI), -sin((tt - inverse_bn) * PI), 0.0f, 1.0f));\n\n        // p' = qpq-1\n        vec4 pp = qmul(qmul(q,p), q_inv);\n\n        color = vec3(pp.w);\n        \n    }\n    else {\n    \n        if ( uv.x < 0.5f ) {\n        \n            // show original blue noise\n            color = vec3(bn);\n\n        }\n        else if (uv.x >= 0.5f) {\n\n            // show inverse blue noise\n            color = vec3(inverse_bn * 0.5f + 0.5f);\n        }\n    }\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec2 uFragCoord = uvec2(floor(fragCoord.xy));\n    \n    bool checker_tile_quad = bool( (uFragCoord.x & QUAD) - (uFragCoord.y & QUAD) );\n    \n    float alternating = mix( float(ODD checker_tile_quad),\n                             float(EVEN checker_tile_quad), \n                             0 == (int(iTime) & 1)\n                           );\n    \n    float shade;\n    \n    shade = textureLod(iChannel0, fragCoord/iChannelResolution[0].xy, 0.0f).r;\n    shade = mix(shade, (-1.0f * shade) * 0.5f + 0.5f, alternating);\n    \n    fragColor = vec4(vec3(shade), 1.0f);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec2 uFragCoord = uvec2(floor(fragCoord.xy));\n    \n    bool checker_tile_quad = bool( (uFragCoord.x & QUAD) - (uFragCoord.y & QUAD) );\n    \n    float alternating = mix( float(EVEN checker_tile_quad),\n                             float(ODD checker_tile_quad), \n                             0 == (int(iTime) & 1)\n                           );\n    \n    float shade;\n    \n    shade = textureLod(iChannel0, fragCoord/iChannelResolution[0].xy, 0.0f).r;\n    shade = mix(shade, (-1.0f * shade) * 0.5f + 0.5f, alternating);\n    \n    fragColor = vec4(vec3(shade), 1.0f);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define EVEN !\n#define ODD\n#define QUAD 1U","name":"Common","description":"","type":"common"}]}