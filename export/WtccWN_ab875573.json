{"ver":"0.1","info":{"id":"WtccWN","date":"1609185026","viewed":128,"name":"Floating Sandbox Water Surface","username":"GabrieleGiuseppini","description":"Experiments for water surface in Floating Sandbox.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["floatingsandboxwater"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 CalculateOceanPlaneColor(vec4 baseColor, float yWorld, float yBackWorld, float yMidWorld, float yFrontWorld, float backPlaneToggle)\n{\n    #define BorderWidthHalf 0.1\n\n    // Enlarge borders for steep vertical edges and for world dimensions\n    float worldDimensionsAdjustment = abs(dFdy(yWorld)) * 1.5;\n    float borderWidthHalfBack = BorderWidthHalf + abs(dFdx(yBackWorld)) + worldDimensionsAdjustment;\n    float borderWidthHalfMid = BorderWidthHalf + abs(dFdx(yMidWorld)) + worldDimensionsAdjustment;\n    float borderWidthHalfFront = BorderWidthHalf + abs(dFdx(yFrontWorld)) + worldDimensionsAdjustment;\n\n    // Color\n\n    // 1 when yWorld is below middle of the border, 0 otherwise\n    float baseColorBack = step(yWorld, yBackWorld - borderWidthHalfBack);\n    float baseColorMid = step(yWorld, yMidWorld - borderWidthHalfMid);\n    float baseColorFront = step(yWorld, yFrontWorld - borderWidthHalfFront);\n\n    float baseColorAlpha =\n        max(\n            1. * baseColorFront,\n            max(\n                .6 * baseColorMid * backPlaneToggle,\n                .5 * baseColorBack * backPlaneToggle));\n\n    //return vec4(baseColor, baseColorAlpha);\n\n    // Border\n\n    float borderBack =\n        1. - smoothstep(0., borderWidthHalfBack, abs(yWorld - (yBackWorld - borderWidthHalfBack)));\n\n    float borderMid =\n        1. - smoothstep(0., borderWidthHalfMid, abs(yWorld - (yMidWorld - borderWidthHalfMid)));\n\n    float borderFront =\n        1. - smoothstep(0., borderWidthHalfFront, abs(yWorld - (yFrontWorld - borderWidthHalfFront)));\n\n    // epsilon when front is visible, 1 otherwise\n    #define FrontObscuredAlpha 0.4\n    float borderFrontOpaqueness = (1. - baseColorFront) * (1. - FrontObscuredAlpha) + FrontObscuredAlpha;\n\n    // epsilon when mid is visible, 1 otherwise\n    #define MidObscuredAlpha 0.4\n    float borderMidOpaqueness = (1. - baseColorMid) * (1. - MidObscuredAlpha) + MidObscuredAlpha;\n\n    float borderAlpha =\n        max(\n            1. * borderFront,\n            max(\n                .9 * borderMid * borderFrontOpaqueness * backPlaneToggle,\n                .7 * borderBack * borderFrontOpaqueness * borderMidOpaqueness * backPlaneToggle));\n\n    //return vec4(1., 1., 1., borderAlpha);\n\n    // Combine\n\n    vec4 finalColor = mix(\n        vec4(baseColor.xyz, baseColorAlpha * baseColor.w),\n        vec4(1.), // Border color\n        borderAlpha);\n\n    return finalColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // This prolog is a simulation of the vertex shader that we use in Floating Sandbox.\n    // The bulk of this shader is really the 'CalculateOceanPlaneColor' function above.\n    \n    vec4 backgroundColor = vec4(135./255., 206./255., 250./255., 1.);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - vec2(1.); // (x=[-1.0, 1.0], y=[-1.0, 1.0])    \n    \n    #define WorldMult 10.\n    vec2 worldCoords = uv * vec2(WorldMult, WorldMult);\n    \n    float amplitude = (0.3 + 0.1 * sin(iTime) * 8.) * WorldMult;\n                \n    float yBackWorld = amplitude * .24 * sin(worldCoords.x * 4. / WorldMult + float(iTime) * 2. - .15);   \n    float yMidWorld = amplitude * .3 * sin(worldCoords.x * 4. / WorldMult + float(iTime) * 2.);\n    float yFrontWorld = amplitude * .27 * sin(worldCoords.x * 4. / WorldMult + float(iTime) * 2. + .2);\n    \n    float backPlaneToggleParam = 1.; // step(1., mod(iTime * 2., 2.));\n    \n    //////////////////////////////////////////////////////////////////\n        \n    // Sample texture, anchoring textureY=0.0 at mid\n    vec2 textureCoords = vec2(worldCoords.x, yMidWorld - worldCoords.y);\n    vec4 baseColor = texture(iChannel0, textureCoords);\n    // TODO: Comment below to use texture\n    baseColor = vec4(92./255., 237./255., 237./255., 1.);\n    \n    vec4 color = CalculateOceanPlaneColor(baseColor, worldCoords.y, yBackWorld, yMidWorld, yFrontWorld, backPlaneToggleParam);\n    \n    //\n    // Output to screen\n    //\n    \n    fragColor = mix(\n        backgroundColor,\n        color,\n        color.w);\n}","name":"Image","description":"","type":"image"}]}