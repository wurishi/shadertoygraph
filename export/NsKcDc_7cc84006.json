{"ver":"0.1","info":{"id":"NsKcDc","date":"1661656235","viewed":151,"name":"Chess Scene","username":"ScalarField","description":"First attempt at rendering something with SDFs. Primarily referenced iq's stuff and this \"Opera Game\" shader (https://www.shadertoy.com/view/tt2XDt).","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","chess"],"hasliked":0,"parentid":"7tyXDd","parentname":"ScalarField's Raymarching Test"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raymarching parameters\n#define RM_ITERS 100\n#define RM_MAX_DIST 50.0\n#define RM_HIT_DIST 1e-3\n\n#define PI 3.14159265\n\n// Materials\n#define NULL_MAT -1.\n#define BOARD_MAT 0.\n#define WALL_MAT  1.\n#define TABLE_MAT 2.\n#define WHITE_MAT 3.\n#define BLACK_MAT 4.\n\n// Coordinate system:\n// - right-handed coordinate system for world space\n// - +z direction is up\n\n// Box stuff #######################################################################\nbool insideBox(vec3 x, vec3 xmin, vec3 xmax){\n    return all(greaterThanEqual(x, xmin)) && all(lessThanEqual(x, xmax));\n}\n\n\n// Ray/box collision\nvec2 boxIntersect(vec3 src, vec3 dir, vec3 xmin, vec3 xmax){\n    \n    vec3 tmin = (xmin - src)/dir;\n    vec3 tmax = (xmax - src)/dir;\n    \n    vec3 en = min(tmin, tmax);\n    vec3 ex = max(tmin, tmax);\n    \n    return vec2(max(en.x, max(en.y, en.z)), min(ex.x, min(ex.y, ex.z)));\n    \n}\n\n// Quaternion stuff (xyz stores vector part, w stores scalar part)\n\n// Axis-angle to unit quaternion\nvec4 quat(vec3 axis, float angle){\n    return vec4(sin(angle/2.0)*normalize(axis), cos(angle/2.0));\n}\n\n// Quaternion rotation\nvec3 rotate(vec4 q, vec3 v){\n    return v + 2.0*cross(q.xyz, q.w*v + cross(q.xyz, v));\n}\n\n// Useful functions #################################################################\n\nfloat smoothMin(float a, float b, float k){\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min(a, b) - h*h*h*k*(1.0/6.0);\n}\n\nfloat smoothMax(float a, float b, float k){\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return h*h*h*k*(1.0/6.0) - min(-a, -b);\n}\n\n// CSG operations\nfloat sdfUnion(float a, float b, float k){ return smoothMin(a, b, k); }\nfloat sdfInt(float a, float b, float k){ return smoothMax(a, b, k); }\nfloat sdfDiff(float a, float b, float k){ return smoothMax(a, -b, k); }\n\n// Aliases for unsmoothed versions\nfloat u_sdfUnion(float a, float b){ return min(a, b); }\nfloat u_sdfInt(float a, float b){ return max(a, b); }\nfloat u_sdfDiff(float a, float b){ return max(a, -b); }\n\n// min with value and material ID\nvec2 objUnion(vec2 a, vec2 b){\n    return mix(a, b, step(b.x, a.x));\n}\n\n// Scene primitive SDFs #############################################################\n\nfloat sdfSphere(vec3 p, float r){\n    return length(p) - r;\n}\n\n// Torus (position, [\"main\" radius, \"tube\" radius])\nfloat sdfRing(vec3 p, vec2 r){\n    vec2 v = vec2(length(p.xy) - r.x, p.z);\n    return length(v) - r.y;\n}\n\n// Closed cylinder (position, [radius, half height])\nfloat sdfDisk(vec3 p, vec2 d){\n    vec2 v = abs(vec2(length(p.xy), p.z)) - d;\n    return min(max(v.x, v.y), 0.0) + length(max(v, 0.0));\n}\n\n// Box (position, half-dimensions, border radius)\nfloat sdfBox(vec3 p, vec3 d, float r){\n    vec3 v = abs(p) - d;\n    return length(max(v, 0.0)) + min(0.0, max(v.x, max(v.y, v.z))) - r;\n}\n\nfloat sdfKing(vec3 p){\n\n    vec2 v = vec2(length(p.xy)-2.6, p.z);\n    float bodySdf =  max(v.x-1., sdfDiff(abs(v.y+0.1)-0.7, length(v) - 2.5, 0.1)) - 0.05;\n    float ring1 = sdfRing(p - vec3(0., 0., -0.85), vec2(0.27, 0.07));\n    float ring2 = sdfRing(p - vec3(0., 0., -0.95), vec2(0.31, 0.05));\n    float body = sdfUnion(bodySdf, sdfUnion(ring1, ring2, 0.02), 0.1);\n    \n    float ring3 = sdfDisk(p, vec2(0.20, 0.01)) - 0.02;\n    float ring6 = sdfDisk(p - vec3(0.0, 0.0, 0.03), vec2(0.17, 0.02)) - 0.02;\n    float ring4 = sdfRing(p - vec3(0., 0., 0.35), vec2(0.176, 0.02));\n    float ring5 = sdfRing(p - vec3(0., 0., -0.7), vec2(0.25, 0.02));\n    float rings = u_sdfUnion(sdfUnion(ring3, ring6, 0.01), u_sdfUnion(ring4, ring5));\n     \n    float cross1 = sdfSphere(p - vec3(0.0, 0.0, 0.6), 0.1);\n    float cross2 = sdfBox(p - vec3(0.0, 0.0, 0.8), vec3(0.04, 0.01, 0.1), 0.01);\n    float cross3 = sdfBox(p - vec3(0.0, 0.0, 0.8), vec3(0.1, 0.01, 0.04), 0.01);\n    float crossdf = sdfUnion(cross1, sdfUnion(cross2, cross3, 0.01), 0.03);\n    \n    return sdfUnion(sdfUnion(body, rings, 0.03), crossdf, 0.1);\n    \n}\n\nfloat sdfRook(vec3 p){\n\n    vec2 v = vec2(length(p.xy)-2.6, p.z);\n    float bodySdf =  max(v.x-1., sdfDiff(abs(v.y+0.35)-0.45, length(v) - 2.5, 0.1)) - 0.05;\n    float ring1 = sdfRing(p - vec3(0., 0., -0.85), vec2(0.27, 0.07));\n    float ring2 = sdfRing(p - vec3(0., 0., -0.95), vec2(0.31, 0.05));\n    float body = sdfUnion(bodySdf, sdfUnion(ring1, ring2, 0.02), 0.1);\n    \n    float ring3 = sdfRing(p - vec3(0., 0., -0.7), vec2(0.25, 0.02));\n    \n    float disk = sdfDisk(p - vec3(0.0, 0.0, 0.14), vec2(0.2, 0.1)) - 0.04;\n    float inDisk = sdfDisk(p - vec3(0.0, 0.0, 0.25), vec2(0.18, 0.1));\n    float disk1 = sdfDisk(p - vec3(0., 0., -0.02), vec2(0.21, 0.02));\n    float disk2 = sdfDisk(p - vec3(0., 0., -0.05), vec2(0.18, 0.02));\n    float slice1 = sdfBox(p - vec3(0.0, 0.0, 0.25), vec3(0.03, 0.3, 0.1), 0.0);\n    float slice2 = sdfBox(p - vec3(0.0, 0.0, 0.25), vec3(0.3, 0.03, 0.1), 0.0);\n\n    float head = sdfUnion(\n        sdfDiff(\n            sdfDiff(disk, inDisk, 0.1),\n            u_sdfUnion(slice1, slice2),\n            0.05\n        ), \n        sdfUnion(disk1, disk2, 0.02), \n        0.05);\n    \n    return sdfUnion(sdfUnion(body, ring3, 0.03), head, 0.1);\n    \n}\n\nfloat sdfPawn(vec3 p){\n\n    vec2 v = vec2(length(p.xy)-1.95, p.z);\n    float bodySdf =  max(v.x-1., sdfDiff(abs(v.y+0.4)-0.4, length(v) - 1.9, 0.1)) - 0.05;\n    float ring1 = sdfRing(p - vec3(0., 0., -0.85), vec2(0.27, 0.07));\n    float ring2 = sdfRing(p - vec3(0., 0., -0.95), vec2(0.31, 0.05));\n    float body = sdfUnion(bodySdf, sdfUnion(ring1, ring2, 0.02), 0.1);\n    \n    float ring3 = sdfRing(p - vec3(0., 0., -0.7), vec2(0.23, 0.02));\n    float disk3 = sdfDisk(p - vec3(0.0, 0.0, -0.24), vec2(0.2, 0.01)) - 0.02;\n    float head = sdfSphere(p - vec3(0.0, 0.0, -0.11), 0.2);\n    \n    return sdfUnion(\n        sdfUnion(sdfUnion(body, ring3, 0.03), disk3, 0.03),\n        head,\n        0.05\n    );\n    \n}\n\n// SDF of full scene\nvec2 sdf(vec3 pos){\n    \n    vec2 board = vec2(\n        sdfBox(pos, vec3(4.5, 4.5, 0.05), 0.05),\n        BOARD_MAT\n    );\n    \n    vec2 wall = vec2(min(6.0 - pos.y, 10.0 + pos.x), WALL_MAT);\n    vec2 table = vec2(pos.z+0.1, TABLE_MAT);\n    \n    vec2 background = objUnion(board, objUnion(wall, table));\n    \n    if(pos.z > 2.5){\n        return objUnion(background, vec2(0.5, NULL_MAT));\n    }\n    \n    // Get integer coords and only evaluate piece SDFs if there's a piece there\n    // else use lower bound (idea from https://www.shadertoy.com/view/tt2XDt)\n    ivec2 fpos = ivec2(floor(pos));\n    if(fpos.x == 1 && fpos.y == 1){\n        return objUnion(\n            background, \n            vec2(sdfPawn(pos-vec3(1.5, 1.5, 1.1)), WHITE_MAT)\n        );\n    }\n    else if(fpos.x == 2 && fpos.y == 1){\n        return objUnion(\n            background, \n            vec2(sdfPawn(pos-vec3(2.5, 1.5, 1.1)), WHITE_MAT)\n        );\n    }\n    else if(fpos.x == 3 && fpos.y == 1){\n        return objUnion(\n            background, \n            vec2(sdfKing(pos-vec3(3.5, 1.5, 1.1)), WHITE_MAT)\n        );\n    }\n    else if(fpos.x == 0 && fpos.y == 3){\n        return objUnion(\n            background, \n            vec2(sdfRook(pos-vec3(0.5, 3.5, 1.1)), WHITE_MAT)\n        );\n    }\n    else if(fpos.x == 2 && fpos.y == 3){\n        return objUnion(\n            background, \n            vec2(sdfKing(pos-vec3(2.5, 3.5, 1.1)), BLACK_MAT)\n        );\n    }\n    else {\n        return objUnion(background, vec2(0.2, NULL_MAT));\n    }\n    \n}\n\n// Rendering stuff ##################################################################\n\n// Numerical gradient calculation\nvec3 grad(vec3 pos){\n    \n    \n    vec2 eps = vec2(1e-3, 0.0);\n    return normalize(vec3(\n        (sdf(pos+eps.xyy) - sdf(pos-eps.xyy)).x,\n        (sdf(pos+eps.yxy) - sdf(pos-eps.yxy)).x,\n        (sdf(pos+eps.yyx) - sdf(pos-eps.yyx)).x\n    )); \n\n}\n\n// Move from src along dir until collision with scene; return distance travelled\nvec2 raymarch(vec3 src, vec3 dir){\n    \n    float dist = 0.0;\n    float mat = NULL_MAT;\n    \n    for(int i=0;i<RM_ITERS;i++){\n        \n        vec3 pos = src + dir*dist;\n        \n        vec2 s = sdf(pos);\n        float d = s.x;\n        mat = s.y;\n        \n        if(d < RM_HIT_DIST || dist > RM_MAX_DIST){ break; }\n        \n        dist += d;\n        \n    }\n    \n    return vec2(dist, mat);\n    \n}\n\n// Soft shadows as per https://iquilezles.org/articles/rmshadows/\nfloat getShadow(vec3 src, vec3 dir, float minDist, float k){\n\n    float shadow = 1.0;\n    float d = minDist;\n    \n    for(int i=0;i<100 && d < 50.;i++){\n        \n        vec2 s = sdf(src + d*dir);\n        float r = s.x;\n        float m = s.y;\n        \n        if(r < 0.001){\n            return 0.0;\n        }\n        if(m > NULL_MAT){\n           shadow = min(shadow, k*r/d); \n        }\n        d += r;\n        \n    }\n    \n    return clamp(shadow, 0.0, 1.0);\n\n}\n\n// Identify point on scene and figure out its color\nvec3 colorPixel(vec3 src, vec3 dir){\n\n    vec2 dm = raymarch(src, dir);\n    \n    vec3 pos = src + dir*dm.x;\n    vec3 norm = grad(pos);\n    \n    if(dm.x > RM_MAX_DIST || dm.y < 0.0){ return vec3(0.0); }\n    \n    vec3 materialColor = vec3(1.0);\n    vec4 matVector = vec4(0.0); // (diffuse, specular, shininess, ambient)\n    \n    // Get material properties of location\n    if(dm.y == BOARD_MAT){\n        ivec2 fpos = ivec2(floor(pos.x), floor(pos.y));\n        if( (fpos.x > 3 || fpos.x < -4) || (fpos.y > 3 || fpos.y < -4) ){\n        \n            // Lazy attempt at some kind of wood pattern\n            float t = fract( cos(2.0*pos.y) + sin(5.0*(pos.x+cos(5.0*pos.y) ) ));\n            vec3 c1 = vec3(0.25, 0.06, 0.03);\n            vec3 c2 = vec3(0.27, 0.08, 0.05);\n            materialColor = mix(c1, c2, t);\n            \n        } else {\n        \n            // Checkerboard\n            materialColor = mix(\n                vec3(0.05), \n                vec3(1.0), \n                vec3(mod(float(fpos.x+fpos.y),2.))\n            );\n            \n        }\n        matVector = vec4(0.9, 0.9, 15.0, 0.0);\n    } else if(dm.y == WALL_MAT){\n        materialColor = vec3(0.1, 0.9, 0.7);\n        matVector = vec4(1.0, 0.0, 0.0, 1.0);\n    } else if(dm.y == TABLE_MAT){\n        materialColor = vec3(0.6, 0.4, 0.2);\n        matVector = vec4(0.9, 0.9, 3.0, 1.0);\n    } else if(dm.y == WHITE_MAT){\n        materialColor = vec3(0.9, 0.9, 0.9);\n        matVector = vec4(0.9, 0.2, 5.0, 0.0);\n    } else if(dm.y == BLACK_MAT){\n        materialColor = vec3(0.1, 0.1, 0.1);\n        matVector = vec4(0.2, 0.3, 5.0, 0.0);\n    }\n    \n    vec3 view = normalize(-dir);\n    \n    vec3 lightDir = normalize(vec3(0.3, -1.0, 0.7));\n    vec3 halfv = normalize(lightDir-dir);\n\n    vec3 diffuse = materialColor*clamp(dot(norm, lightDir), 0.0, 1.0)\n        *getShadow(pos, lightDir, 0.05, 30.0);\n        \n    vec3 specular = vec3(pow(dot(halfv, norm), matVector.z));\n    \n    vec3 ambient = vec3(1.0)*sdf(pos+norm*0.1).x/0.1;\n    \n    return 0.9*matVector.x*diffuse + \n           0.3*matVector.y*specular + \n           0.1*matVector.w*ambient;\n    \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 xy = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 cameraPos = vec3(5.5, -0.5, 1.7);\n    \n    vec3 rayDir = rotate(\n        quat(vec3(-0.2, -0.05, 1.0), PI/4.0),\n        vec3(xy.x, 1.0, xy.y)\n    );\n    \n    vec3 col = colorPixel(cameraPos, normalize(rayDir));\n    col = pow(col, vec3(0.45));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}