{"ver":"0.1","info":{"id":"3sGBDy","date":"1607815956","viewed":70,"name":"sdf shader - first shader","username":"cookieguy","description":"SDF shaders","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["ray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdBox(vec3 p, vec3 c, vec3 b, float r)\n{\n    vec3 q = abs(p - c) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat sdSphere(in vec3 p, in vec3 o, in float r)\n{\n    return length(p - o) - r;\n}\n\n\nfloat map(in vec3 pos)\n{\n       float plane = pos.y + .25f;\n       float box1 = sdBox(pos, vec3(cos(iTime) * 1.f, 0.f, -1.f), vec3(1.f), .1f);\n       float tri = sdPyramid(pos - vec3(0.f, 0.f, -3.f), 5.f);\n       return min(plane, min(box1,min(sdSphere(pos, vec3(0.f, sin(iTime) * .5f, 0.f), .5f), tri)));\n}\n\nvec4 texCube(sampler2D tex, vec3 p, vec3 n)\n{\n    vec4 x = texture(tex, p.yz);\n    vec4 y = texture(tex, p.xz);\n    vec4 z = texture(tex, p.xy);\n    return x * abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\nvec3 calcNormals(in vec3 pos)\n{\n    const vec2 e = vec2(.001f, 0.f);\n    return normalize(vec3(\n        map(pos+e.xyy) - map(pos-e.xyy),\n        map(pos+e.yxy) - map(pos-e.yxy),\n        map(pos+e.yyx) - map (pos-e.yyx)\n    ));\n}\n\n\n\n\nfloat castRay(in vec3 ro, in vec3 rd)\n{\n\n    float t = 0.0f;\n    \n    for (int index = 0; index < 100; index++)\n    {\n        vec3 pos = ro + t*rd;\n        \n        float h = map(pos);\n        \n        if (h < .001f)\n            break;\n        \n        t += h;\n        if (t > 20.f)\n            break;\n    }\n    if ( t > 20.f)\n        t = -1.5f;\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p =(2.f*fragCoord-iResolution.xy) / iResolution.y;\n    \n    //vec3 ro = vec3(0.f, 0.f, 2.f);\n    //vec3 rd = normalize(vec3(p, -1.5f));\n    \n    // Camera code below:\n    \n    float an = 10.f * iMouse.x/iResolution.x;\n    \n    vec3 ro = vec3(1.f*sin(an), .5f, 3.f*cos(an));\n    vec3 ta = vec3(.0f, .0f, 0.f);\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0, 1, 0)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    vec3 rd = normalize(p.x*uu + p.y*vv + 1.5f*ww);\n \n    vec3 col = vec3(.025f, .2f, .3f);\n    \n    float t = castRay(ro,rd);\n    \n    \n    if ( t > -1.5f)\n    {\n        vec3 pos = ro +rd*t;\n        vec3 nor = calcNormals(pos);\n        \n        const vec3 sun_dir = vec3(.8f, .4f, .2f);\n        vec3 mate = texCube(iChannel0, pos, nor).xyz * .25f;\n        \n        float sun_dif = clamp(dot(nor, sun_dir), 0.f, 1.f);\n        float sky_dif = clamp(.5f + .5f*dot(nor, vec3(.0f, 1.f, .0f)), .0f, 1.f);\n        \n        float sun_shadow = step(castRay(pos + nor * .001f, sun_dir), 0.0f);\n        \n        col = mate * vec3(7.f, 4.f, 3.f) * sun_dif * sun_shadow;\n        col += mate * vec3(.5f, .8f, .9f) * sky_dif;\n    }\n    \n    col =  pow(col, vec3(.4545f));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}