{"ver":"0.1","info":{"id":"fty3D1","date":"1637697870","viewed":355,"name":"city_sandbox","username":"skaplun","description":"Can see certain traverse bug. Still can't figure out the root cause(\nOriginal animation - https://s3.amazonaws.com/vice_asset_uploader/files/1406060560tumblr_n8rv2jPVqO1sp8304o4_500.gif","likes":29,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ZERO (min(iFrame,0))\n\nbool building(vec3 pos, Ray r, out vec4 hitRes){\n    vec4 hash = texelFetch(iChannel0, ivec2(pos.xz + 20.), 0);\n    float width = .1 + .3 * abs(hash.z);\n    float height = saturate(mod(iTime, 3.) - length(pos.xz)/10.)\n                 * saturate(1. - length(pos.xz)/(9. + hash.x * 2.))\n                 * (1. + 3. * hash.y);\n    if(height == 0.)\n        return false;\n\n    vec3 center = vec3(pos.x, 2. + height, pos.z);\n    center.xz += vec2(.5 - width) * (vec2(hash.w, hash.x) * 2. - 1.);\n    return box_hit(Box(center, vec3(width, height, width)), r, hitRes.w, hitRes.xyz);\n}\n\nvec4 traverseRay(Ray r, float start, float end, float gridSize){\n    float dst = start + EPS;\n    float maxMarchingSteps = ceil(sqrt(2. * pow(gridSize, 2.)));\n    for(float i=0.; i<maxMarchingSteps; i++) {\n        vec3 pos = floor(r.origin + r.dir * dst) + .5;\n        vec4 hitRes;\n        if(building(pos, r, hitRes))\n            return hitRes;\n        \n        float dx = -fract(pos.x);\n        float dz = -fract(pos.z);\n        float nearestVoxel = max(fract(dx/r.dir.x), fract(dz/r.dir.z));\n\n        dst += nearestVoxel;\n        if ((dst > end)) break;\n    }\n    \n    return vec4(MAX_FLOAT);\n}\n\nvec4 geometry(Ray r){\n    float BOX_SIDE = 10.;\n    vec4 res = vec4(MAX_FLOAT);\n    float hitFloor = (-.1-r.origin.y)/r.dir.y;\n    if(hitFloor >= 0.)\n        res = minByW(res, vec4(vec3(0., 1., 0.), hitFloor));\n    \n    {\n        vec4 dst;\n        if(box_hit(Box(vec3(0.), vec3(BOX_SIDE, 2., BOX_SIDE)), r, dst.w, dst.xyz)){\n            res = minByW(res, dst);\n        }\n    }\n    \n    {\n        vec2 dst = vec2(-MAX_FLOAT);\n        if(box_hit(Box(vec3(0., 4.5, 0.), vec3(BOX_SIDE - EPS, 3., BOX_SIDE - EPS)), r, dst))\n        {\n            vec4 tmp = traverseRay(r, max(dst[0], 0.), max(dst[0], dst[1]), 50.);\n            res = minByW(res, tmp);\n        }\n    }\n\n    return res;\n}\n\nfloat worldDist(vec3 pos){\n    float res = pos.y;\n    \n    res = min(res, sdBox(pos, vec3(10, 2., 10.)));\n    \n    vec4 hash = texelFetch(iChannel0, ivec2(pos.xz + 20.), 0);\n    \n    float width = .1 + .3 * abs(hash.z);\n    float height = saturate(mod(iTime, 3.) - length(pos.xz)/10.)\n                 * saturate(1. - length(pos.xz)/(9. + hash.x * 2.))\n                 * (1. + 3. * hash.y);\n    if(height != 0.){\n        vec3 center = vec3(floor(pos.x) + .5, 2. + height, floor(pos.z) + .5);\n        center.xz += vec2(.5 - width) * (vec2(hash.w, hash.x) * 2. - 1.);\n        res = min(res, sdBox(center, vec3(width, height, width)));\n    }\n    \n    return res;\n}\n\nfloat ao(in vec3 pos, in vec3 n) {\n    float eps = 0.01;\n    pos += n * eps * 2.0;\n    float occlusion = 0.0;\n    for (float i=1.0; i<10.0; i++) {\n        float d = worldDist(pos);\n        float coneWidth = 2.0 * eps;\n        float occlusionAmount = max(coneWidth - d, 0.);\n        float occlusionFactor = occlusionAmount / coneWidth;\n        occlusionFactor  *= 1.0 - (i / 10.0);\n        occlusion = max(occlusion, occlusionFactor);\n        eps *= 2.0;\n        pos += n * eps;\n    }\n    return max(0.0, 1.0 - occlusion);\n}\n\nfloat shadow(Ray r, float maxDst){\n    float e = .005;\n    float n = step(maxDst, geometry(r).w)\n            + step(maxDst, geometry(Ray(r.origin, normalize(r.dir + vec3(0., e, 0.)))).w)\n            //+ step(maxDst, geometry(Ray(r.origin, normalize(r.dir + vec3(e, e, 0.)))).w)\n            + step(maxDst, geometry(Ray(r.origin, normalize(r.dir + vec3(e, 0., 0.)))).w)\n            //+ step(maxDst, geometry(Ray(r.origin, normalize(r.dir + vec3(e, -e, 0.)))).w)\n            + step(maxDst, geometry(Ray(r.origin, normalize(r.dir + vec3(0., -e, 0.)))).w)\n            //+ step(maxDst, geometry(Ray(r.origin, normalize(r.dir + vec3(-e, -e, 0.)))).w)\n            + step(maxDst, geometry(Ray(r.origin, normalize(r.dir + vec3(-e, 0., 0.)))).w);\n            //+ step(maxDst, geometry(Ray(r.origin, normalize(r.dir + vec3(-e, e, 0.)))).w);\n            \n    return n/5.;\n}\n\nvec3 makeClr(vec2 fragCoord){\n    vec3 viewDir = rayDirection(60., iResolution.xy, fragCoord);\n    float ang = (iResolution.x - iMouse.x) * .05 / 3.1415;\n    vec3 origin = vec3(30. * sin(ang), 12., 30. * cos(ang));\n    mat4 viewToWorld = viewMatrix(origin, vec3(0., 1., -2.), vec3(0., 1., 0.));\n    vec3 dir = (viewToWorld * vec4(viewDir, 1.0)).xyz;\n    \n    //vec3 lightPos = vec3(20. * sin(iTime), 30., 20. * cos(iTime));\n    vec3 lightPos = vec3(100., 100., 50.);\n    Ray camRay = Ray(origin, dir);\n    \n    vec4 geom = geometry(camRay);\n    \n    if(geom.w < 0.){\n        return vec3(0.);\n    }\n    \n    vec3 pos = camRay.origin + geom.w * camRay.dir;\n    pos.y = max(pos.y, 0.);\n    vec3 toLight = normalize(lightPos - pos);\n    \n    vec3 col;\n    {\n        vec3 nor = geom.xyz;\n        vec3 ref = reflect(dir, nor);\n        col = vec3(1.);\n        \n        // lighting\n        float occ = ao(pos, nor);\n        \n        vec3 lin = vec3(0.0);\n        float ks = 1.0;\n        \n        // sun\n        {\n            //vec3  lig = normalize( vec3(-0.5, 0.1, 0.5) );\n            vec3  lig = normalize( vec3(-0.2, 0.2, 0.5) );\n            vec3  hal = normalize( lig - dir );\n            float dif = clamp( dot( nor, lig ), 0., 1.0 );\n        \t      dif *= shadow(Ray(pos, lig), 100.);\n\t\t\tfloat spe = pow(clamp( dot( nor, hal ), 0.0, 1.0 ), 16.);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.0,1.00,1.0);\n            lin +=     5.00*spe*vec3(1.0,1.00,1.0) * ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.02+0.98*pow(clamp(1.0+dot(nor, dir),0.0,1.0), 5.0 );\n                  spe *= shadow(Ray(pos, ref), 100.) * 3.;\n            lin += col*.60*dif*vec3(0.0,0.70,.6);\n            lin +=     2.00*spe*vec3(0.0,0.70,.6)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor, dir),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n    }\n    \n    return Uncharted2ToneMapping(col);\n}\n\n#define AA 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = vec4(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            fragColor.rgb += clamp(makeClr(fragCoord + vec2(x, y) / float(AA)), 0., 1.);\n        }\n    \n    fragColor.rgb /= float(AA * AA);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_FLOAT 1e5\n#define MIN_FLOAT 1e-5\n#define EPS 1e-4\n#define GAMMA 2.2\n#define saturate(x) clamp(x, 0., 1.)\nconst float PI = acos(-1.);\n\nstruct Ray{ vec3 origin, dir;};\nstruct Box{ vec3 o; vec3 size;};\nstruct Cone\n{\n    float cosa;\t// half cone angle\n    float h;\t// height\n    vec3 c;\t\t// tip position\n    vec3 v;\t\t// axis\n};\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye),\n         s = normalize(cross(f, up)),\n         u = cross(s, f);\n    return mat4(vec4(s, 0.), vec4(u, 0.), vec4(-f, 0.), vec4(vec3(0.), 1.));\n}\n\nmat3 calcLookAtMatrix(in vec3 camPosition, in vec3 camTarget, in float roll) {\n    vec3 ww = normalize(camTarget - camPosition);\n    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\n#define MIN x\n#define MAX y\nbool box_hit(const in Box inbox, in Ray inray){\n    vec2 tx, ty, tz;\n    vec3 maxbounds = inbox.o + vec3( inbox.size);\n    vec3 minbounds = inbox.o + vec3(-inbox.size);\n    tx = ((inray.dir.x >= 0.?vec2(minbounds.x, maxbounds.x):vec2(maxbounds.x, minbounds.x)) - inray.origin.x) / inray.dir.x;\n\tty = ((inray.dir.y >= 0.?vec2(minbounds.y, maxbounds.y):vec2(maxbounds.y, minbounds.y)) - inray.origin.y) / inray.dir.y;\n    if ((tx.MIN > ty.MAX) || (ty.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, ty.MIN), min(tx.MAX, ty.MAX));\n\ttz = ((inray.dir.z >= 0.?vec2(minbounds.z, maxbounds.z):vec2(maxbounds.z, minbounds.z)) - inray.origin.z) / inray.dir.z;\n    if ((tx.MIN > tz.MAX) || (tz.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, tz.MIN), min(tx.MAX, tz.MAX));\n    \n    if(tx.MIN >= 0.){\n    \treturn true;\n    }\n        \n    return false;\n}\n\nbool box_hit(const in Box inbox, in Ray inray, out vec2 dst){\n    vec2 tx, ty, tz;\n    vec3 maxbounds = inbox.o + vec3( inbox.size);\n    vec3 minbounds = inbox.o + vec3(-inbox.size);\n    tx = ((inray.dir.x >= 0.?vec2(minbounds.x, maxbounds.x):vec2(maxbounds.x, minbounds.x)) - inray.origin.x) / inray.dir.x;\n\tty = ((inray.dir.y >= 0.?vec2(minbounds.y, maxbounds.y):vec2(maxbounds.y, minbounds.y)) - inray.origin.y) / inray.dir.y;\n    if ((tx.MIN > ty.MAX) || (ty.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, ty.MIN), min(tx.MAX, ty.MAX));\n\ttz = ((inray.dir.z >= 0.?vec2(minbounds.z, maxbounds.z):vec2(maxbounds.z, minbounds.z)) - inray.origin.z) / inray.dir.z;\n    if ((tx.MIN > tz.MAX) || (tz.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, tz.MIN), min(tx.MAX, tz.MAX));\n    \n    if(tx.MIN >= 0. || tx.MAX >= 0.){\n        dst = vec2(tx.MIN, tx.MAX);\n        return true;\n    }\n        \n    return false;\n}\n\nvec3 box_normal_at(const in Box box, const in vec3 point) {\n    vec3 normal;\n    vec3 localPoint = point - box.o;\n    float mindist = MAX_FLOAT;\n    float dist = abs(box.size.x - abs(localPoint.x));\n    if (dist < mindist) {\n        mindist = dist;\n        normal = vec3(1., 0., 0.);\n        normal *= sign(localPoint.x);\n    }\n    \n    dist = abs(box.size.y - abs(localPoint.y));\n    if (dist < mindist) {\n        mindist = dist;\n        normal = vec3(0, 1., 0);\n        normal *= sign(localPoint.y);\n    }\n    dist = abs(box.size.z - abs(localPoint.z));\n    if (dist < mindist) { \n        mindist = dist; \n        normal = vec3(0, 0, 1.);\n        normal *= sign(localPoint.z);\n    } \n    return normal;\n}\n\nbool box_hit(const in Box inbox, const in Ray inray, out float dst, out vec3 nrm){\n    vec2 tx, ty, tz;\n    vec3 maxbounds = inbox.o + vec3( inbox.size);\n    vec3 minbounds = inbox.o + vec3(-inbox.size);\n    tx = ((inray.dir.x >= 0.?vec2(minbounds.x, maxbounds.x):vec2(maxbounds.x, minbounds.x)) - inray.origin.x) / inray.dir.x;\n\tty = ((inray.dir.y >= 0.?vec2(minbounds.y, maxbounds.y):vec2(maxbounds.y, minbounds.y)) - inray.origin.y) / inray.dir.y;\n    if ((tx.MIN > ty.MAX) || (ty.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, ty.MIN), min(tx.MAX, ty.MAX));\n\ttz = ((inray.dir.z >= 0.?vec2(minbounds.z, maxbounds.z):vec2(maxbounds.z, minbounds.z)) - inray.origin.z) / inray.dir.z;\n    if ((tx.MIN > tz.MAX) || (tz.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, tz.MIN), min(tx.MAX, tz.MAX));\n    \n    if(tx.MIN >= 0.){\n        dst = tx.MIN;\n        vec3 p = inray.origin + inray.dir * dst;\n        nrm = box_normal_at(inbox, p);\n        return true;\n    }\n        \n    return false;\n}\n\nbool hit_cone(Cone cone, Ray r, out float t, out vec3 n){\n    vec3 co = r.origin - cone.c;\n\n    float a = dot(r.dir, cone.v)*dot(r.dir,cone.v) - cone.cosa*cone.cosa;\n    float b = 2. * (dot(r.dir, cone.v)*dot(co, cone.v) - dot(r.dir,co)*cone.cosa*cone.cosa);\n    float c = dot(co,cone.v)*dot(co, cone.v) - dot(co,co)*cone.cosa*cone.cosa;\n\n    float det = b*b - 4.*a*c;\n    if (det < 0.) return false;\n\n    det = sqrt(det);\n    float t1 = (-b - det) / (2. * a);\n    float t2 = (-b + det) / (2. * a);\n\n    // This is a bit messy; there ought to be a more elegant solution.\n    t = t1;\n    if (t < 0. || t2 > 0. && t2 < t) t = t2;\n    if (t < 0.) return false;\n\n    vec3 cp = r.origin + t*r.dir - cone.c;\n    float h = dot(cp, cone.v);\n    if (h < 0. || h > cone.h) return false;\n\n    n = normalize(cp * dot(cone.v, cp) / dot(cp, cp) - cone.v);\n    \n    return true;\n}\n\nfloat sdBox(vec3 p, vec3 b){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cylCap(vec3 p, float r, float lenRad){\n    float a = length(p.xy) - r;\n    a = max(a, abs(p.z) - lenRad);\n    return a;\n}\n\nvec4 minByW(vec4 a, vec4 b){\n    return a.w < b.w ? a : b;\n}\n\nvec2 Hash22(vec2 uv){\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\n\nvec3 Uncharted2ToneMapping(vec3 color)\n{\n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\tfloat W = 11.2;\n\tfloat exposure = 1.2;\n\tcolor *= exposure;\n\tcolor = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n\tfloat white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n\tcolor /= white;\n\tcolor = pow(color, vec3(1. / GAMMA));\n\treturn color;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(Hash22(Hash22(fragCoord)),\n                     Hash22(Hash22(fragCoord + vec2(1037., 234.))));\n}","name":"Buffer A","description":"","type":"buffer"}]}