{"ver":"0.1","info":{"id":"4lcGDr","date":"1468617955","viewed":162,"name":"SimpleRayMarcher","username":"ottopo","description":"Basic raymarching implementation\nOttavio Hartman - hartmano@sas.upenn.edu","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Ottavio Hartman - hartmano@sas.upenn.edu - https://github.com/omh1280\n\n#define ITR 100\n#define FAR 10.\n#define time iTime\n\nfloat sphere(vec3 p)\n{\n    return distance(p, vec3(0.0)) - .4;\n}\n\nfloat map(vec3 p) \n{\n    return sphere(p);\n}\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\nfloat march(in vec3 ro, in vec3 rd) \n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    h = map(ro+rd*d);\n    }\n\treturn d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n\tmo.x *= iResolution.x/iResolution.y;\n\n    // Ray origin\n    vec3 ro = vec3(0.,0.,4.);\n\n    ro.xz *= mm2(mo.x*3.);\n\n    // \"look at\"\n\tvec3 ta = vec3(0);\n    // Change FOV\n    vec3 ww = normalize(ta - ro);\n    // Camera Right\n    vec3 uu = normalize(cross(vec3(0.,1.,0.), ww));\n    // Camera up\n    vec3 vv = normalize(cross(ww, uu));\n    // Ray dir\n    vec3 rd = normalize(p.x*uu + p.y*vv + 2.*ww);\n\t\n\tfloat rz = march(ro,rd);\n    \n    vec4 col = vec4(0.1, 0.2, 0.0, 1.0);\n    if (rz < FAR) {\n        vec3 d = ro + rz*rd;\n        vec3 normal = normalize(d);\n        \n        // Phong shading\n\t\tvec3 lightDir = normalize(vec3(3., 3., 10.) - d);\n\n      \tfloat lambertian = max(dot(lightDir,normal), 0.0);\n      \tfloat specular = 0.0;\n\n      \tif(lambertian > 0.0) {\n\n        \tvec3 viewDir = normalize(-rd);\n\n            vec3 reflectDir = -reflect(lightDir, normal);\n            float specAngle = max(dot(reflectDir, viewDir), 0.0);\n\n            specular = pow(specAngle, 20.0);\n\n      \t}\n      \tcol = vec4(lambertian * vec3(.8, .5, .7) + specular * vec3(1.), 1.);\n    }\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}