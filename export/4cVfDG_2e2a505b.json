{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"float hash21(vec2 p) {\n    p = fract(p*vec2(234.34, 435.345));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}\n\nfloat sdStar( in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.283185*(c*t+d) );\n}\n\nfloat smoothSquareWave(in float x, in float b) {\n    return sin(x) / sqrt(b * b + sin(x)*sin(x));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = mod(iTime, 1000.);\n    \n    const float timeMod = 0.2;\n\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv *= 5.;\n    uv.y += 0.5;\n    uv.x += t * timeMod;\n\n    vec3 col = vec3(0.0);\n\n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);\n    \n    float scale = 1.0;\n    \n    float n = hash21(id);\n    \n    for (float i = 0.0; i <= 2.0; i++) {\n        if (n > 0.5) {\n            break;\n        }\n        \n        gv = fract(uv * i * pow(2.0, i)) - 0.5;\n        id = floor(uv * i * pow(2.0, i));\n        n = hash21(id);\n        \n        scale++;\n    }\n    \n    float modifier = 0.01;\n    float h = smoothSquareWave((t + 500.) * 3.1415926535 * n * 0.02, 0.3 * modifier);\n    float v = smoothSquareWave((t + 1500.) * 3.1415926535 * n * 0.02, 0.3 * modifier);\n    \n    gv.y /= v;\n    gv.x /= h;\n    \n    col += smoothstep(0.01, -0.01, length(gv) - 0.5) * n;\n    \n    col *= palette(n * 2.0 - 1.0 , vec3(0.8, 0.5, 0.4), vec3(0.2, 0.4, 0.2), vec3(2.0, 1.0, 1.0), vec3(0.00, 0.25, 0.25));\n\n    //if (gv.x + 0.025 > 0.45 || gv.y + 0.025 > 0.45) col.r = 1.0;\n    \n    col += 0.2;\n    \n    col += 0.1 * smoothstep(0.01, -0.01, sdStar(gv, 0.4, int(floor(n * 5.0 + 2.0)), 0.2));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4cVfDG","date":"1734456487","viewed":52,"name":"subdividing mk 2","username":"noxfy","description":":3","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["asdasd"],"hasliked":0,"parentid":"","parentname":""}}