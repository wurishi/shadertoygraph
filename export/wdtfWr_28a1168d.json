{"ver":"0.1","info":{"id":"wdtfWr","date":"1605013409","viewed":239,"name":"Clean Circle Segment Distance","username":"nr4","description":"Circle segments require an awful amount of bookkeeping to produce the right result for every possible combination of angles. This shader contains a working version. It is not optimized though.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sdf","circle","distance","function","analytic","segment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Clean Circle Segment Distance\n * \n * Copyright (C) 2020  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = acos(-1.);\n\n// Distance to circle segment\nfloat circlesegment(vec2 x, float r, float p0, float p1)\n{\n    float p = atan(x.y, x.x),\n        t = 2.*pi;\n    \n    vec2 philo = vec2(p0, p1);\n    philo = sign(philo)*floor(abs(philo)/t)*t;\n    philo = vec2(min(philo.x, philo.y), max(philo.x,philo.y));\n    philo.y = mix(philo.y,philo.x,.5+.5*sign(p0-p1));\n    \n    p0 -= philo.y;\n    p1 -= philo.y;\n    \n    philo = vec2(max(p0, p1), min(p0, p1));\n    \n    if((p < philo.x && p > philo.y) \n       || (p+t < philo.x && p+t > philo.y) \n       || (p-t < philo.x && p-t > philo.y)\n      )\n    \treturn abs(length(x)-r);\n    return min(\n        length(x-r*vec2(cos(p0), sin(p0))),\n        length(x-r*vec2(cos(p1), sin(p1)))\n        );\n}\n\nfloat sm(in float d)\n{\n    return smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Ignore the drawing code, it's messy, I know :)\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\tfloat d = circlesegment(uv, .4, iTime, 1.3*iTime);\n    d = min(d, circlesegment(uv, .2, -iTime, -1.3*iTime));\n    d = abs(d)-.0025;\n    float interval = clamp(.03 * (d-mod(d,.025))/.025, 0., 1.);\n    vec3 col = mix(vec3(1.00,0.90,0.68), vec3(0.98,0.64,0.67), 2.*interval);\n    if(interval > .5) col = mix(col, vec3(0.54,0.80,0.80), 2.*(interval-.5));\n    col = mix(col, c.yyy, sm(d));\n    \n    col = mix(col, .4*c.xxx, sm(abs(mod(d+.0125,.025)-.0125)-.001));\n\n    col = mix(col, c.xyy, sm(abs(length(uv-.4*vec2(cos(iTime), sin(iTime)))-.025)-.002));\n    col = mix(col, c.yyx, sm(abs(length(uv-.4*vec2(cos(1.3*iTime), sin(1.3*iTime)))-.025)-.002));\n    col = mix(col, c.xyy, sm(abs(length(uv-.2*vec2(cos(-iTime), sin(-iTime)))-.025)-.002));\n    col = mix(col, c.yyx, sm(abs(length(uv-.2*vec2(cos(-1.3*iTime), sin(-1.3*iTime)))-.025)-.002));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}