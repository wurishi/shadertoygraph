{"ver":"0.1","info":{"id":"MsSBDK","date":"1502192582","viewed":159,"name":"Too many reflections","username":"slerpy","description":"A rotating cube inside a sphere","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["reflection","simple","raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.28318530718\n\n#define FAR 50.\n#define ITER 80\n#define QUA .001\n#define NORK 5e-3\n\n#define REF 0.8\n#define RITER 32\n#define RRFB .05\n\n#define BRG .4\n\nmat3 rx(float a){ float sa=sin(a), ca=cos(a); return mat3(1.,0.,0.,0.,ca,sa,0.,-sa,ca); }\nmat3 ry(float a){ float sa=sin(a), ca=cos(a); return mat3(ca,0.,sa,0.,1.,0.,-sa,0.,ca); }\nmat3 rz(float a){ float sa=sin(a), ca=cos(a); return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.); }\n\nfloat box(vec3 p){ p=abs(p); return max(max(p.x,p.y),p.z); }\n\nfloat map(vec3 p)\n{\n    //float s = 10. - box(p);\n    float s = 10. - length(p);\n    float c = box(p) - 1.;\n    return min(s, c);\n}\n\nvec3 normal(vec3 p, float k)\n{\n\tvec2 e = vec2(.0,k);\n\treturn normalize(vec3(\n\t\tmap(p) - map(p - e.yxx),\n\t\tmap(p) - map(p - e.xyx),\n\t\tmap(p) - map(p - e.xxy)\n\t));\n}\n\nfloat tracer(vec3 ro, vec3 rd)\n{    \n    float t = .0, d;\n    for(int i=0; i < ITER; i++){        \n        d = map(ro + rd*t);\n        if (d < QUA*t || t > FAR) break;\n        t += d;\n    } \n    return t;\n}\n\nfloat hard_shadow(vec3 sp, vec3 lp, int iter)\n{   \n\tvec3 p, ld = normalize(sp - lp);\n\n\tfloat t = .0;\n\tfor(int i = 0; i < iter; i++)\n\t{\n\t\tp = lp + ld * t;\n\t\tfloat m = map(p);\n\t\tif (m < .0 || t > FAR) break;\n\t\tt += m;\n\t}\n\n\treturn max(1. - distance(p, sp), 0.);\n}\n\nvec3 color(vec3 sp, vec3 sn)\n{   \n    vec3 lp = vec3(-3, 2, -4);\n\tvec3 ld = normalize(lp - sp);\n    \n    float diff = max(dot(sn,ld),0.);\n    float shd = hard_shadow(sp, lp, 30);\n    \n    vec3 col = (sn.xyz+1.)/2.;\n    return col * diff * shd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    mat3 rm = ry(iTime/3.) * rx(iTime/4.);\n    \n\tvec3 ro = rm * vec3(vec2(.0), -5.);\n    vec3 rd = rm * normalize(vec3(uv,2.));\n    \n    float t = tracer(ro,rd);\n\tvec3 sp = ro + rd*t;\n\tvec3 sn = normal(sp,NORK);\n    \n    vec3 col = color(sp, sn);\n    \n    for(int i=0; i<RITER; i++)\n    {\n        if(t > FAR) break;\n            \n        rd = normalize(reflect(rd, sn));\n        ro = sp + rd * RRFB;\n        \n        t = tracer(ro, rd) - RRFB;\n        \n        sp = ro + rd * t;\n\t\tsn = normal(sp,NORK);\n    \n        col += color(sp, sn) * pow(REF, float(i) + 1.);\n    }\n    \n\tfragColor = BRG * vec4(col,1.);\n}\n","name":"Image","description":"","type":"image"}]}