{"ver":"0.1","info":{"id":"NddcDn","date":"1653315246","viewed":130,"name":"technical difficulties please st","username":"HaleyHalcyon","description":"created as a background graphic for a technical difficulties screen","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["aeuaoueaouaeo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define HEX(x) (vec3((x >> 16) & 255, (x >> 8) & 255, x & 255) / 255.)\nconst vec3 COL_BACK = HEX(0x222932);\nconst vec3 COL_FRONT = HEX(0x85807f);\n\n// uniform noise, pre-generated.\nconst float[32] rfloat = float[](\n0.870967,\n0.580645,\n0.193548,\n0.774193,\n0.838709,\n0.225806,\n0.806451,\n0.161290,\n0.967741,\n0.741935,\n0.096774,\n0.645161,\n0.032258,\n0.0,\n0.935483,\n0.677419,\n0.290322,\n0.354838,\n0.064516,\n0.387096,\n0.451612,\n0.258064,\n1.0,\n0.129032,\n0.709677,\n0.322580,\n0.548387,\n0.516129,\n0.612903,\n0.903225,\n0.483870,\n0.419354\n);\n\nfloat crosshatch(vec2 xyf) {\n    ivec2 xy = ivec2(xyf) & 1;\n    return float((xy.x ^ xy.y) * 2 + xy.y)/ 4.;\n}\n\n// How many squares to render.\n#define COUNT 16\n// The time multiplier. 1x will cause it to loop once every second!\n#define SPEED 1./16.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / length(iResolution.xy);\n    float v = 0.;\n    float t = iTime * SPEED;\n    \n    for (int i = 0; i < COUNT; i++) {\n        // generate random squares\n        float rOffset = rfloat[i];\n        float rSize = rfloat[(1 + i * 3) % 32];\n        float rXPosition = rfloat[(2 + i * 7) % 32];\n        float rYPosition = rfloat[(3 + i * 13) % 32];\n        // generate the properties\n        float time = fract(t + rOffset);\n        float size = 0.05 + 0.25 * rSize;\n        // x offset from -1 to 1\n        float pos = 2. * (rXPosition - 0.5);\n        // y offset from -0.6 to 0.6\n        float ypos = 1.2 * (rYPosition - 0.5);\n        // antialias width (used for y only)\n        float aa = fwidth(uv.y) * 1.;\n        \n        // generate square bounds\n        float alphaX = step(abs(uv.x - pos), size);\n        // y bounds move with time\n        float alphaY = smoothstep(\n            -aa, aa,\n            size - abs(uv.y - (time - 0.5) * 3. * size + ypos)\n        );\n        // squares fade in/out\n        float alphaTime = 0.5 - abs(0.5 - time);\n        \n        float alpha = alphaX * alphaY * alphaTime;\n        \n        v = mix(v, 1., alpha);\n    }\n    const float steps = 2.;\n    float thres = 1.0 - (\n    crosshatch(fragCoord) +\n    crosshatch(fragCoord / 2.) / 4. +\n    crosshatch(fragCoord / 4.) / 16.+\n    crosshatch(fragCoord / 8.) / 64.);\n    //v = fract(uv.x + 0.5); // crosshatch patterntest \n    v = (floor(steps * v) + step(thres, fract(steps * v))) / steps;\n    \n    // Output to screen\n    fragColor = vec4(mix(\n        COL_BACK, COL_FRONT, v\n    ),1.0);\n}","name":"Image","description":"","type":"image"}]}