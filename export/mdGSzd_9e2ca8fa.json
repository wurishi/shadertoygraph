{"ver":"0.1","info":{"id":"mdGSzd","date":"1681453540","viewed":61,"name":"AmbientCubeToSphericalHarmonics","username":"ShadingKnight","description":"WIP","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sphericalharmonics","ambientcube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float ambientCube[6] = float[6](0.0, 1.0, 0.0, 0.0, 0.0, 0.0);\n// float ambientCube[6] = float[6](0.7, 0.7, 0.7, 0.7, 0.7, 0.7);\n\nfloat sampleAmbientCube(float ambientCubeCoeff[6], vec3 n)\n{\n    vec3 dirSquared = n * n;\n    float result\n        = dirSquared.x * (n.x < 0.0 ? ambientCubeCoeff[0] : ambientCubeCoeff[1])\n        + dirSquared.y * (n.y < 0.0 ? ambientCubeCoeff[2] : ambientCubeCoeff[3])\n        + dirSquared.z * (n.z < 0.0 ? ambientCubeCoeff[4] : ambientCubeCoeff[5]);\n\n    return result;\n}\n\nstruct SH\n{\n    float L0;\n    vec3 L1;\n};\n\nSH evaluateSH(vec3 p)\n{\n    SH result;\n\n    float x = -p.x;\n    float y = -p.y;\n    float z = p.z;\n\n    const float sqrtPi = sqrt(PI);\n\n    result.L0 = 1.0f / (2.0f * sqrtPi);\n    result.L1 = vec3(-sqrt(3.0f / (4.0f * PI)) * y, sqrt(3.0f / (4.0f * PI)) * z, -sqrt(3.0f / (4.0f * PI)) * x);\n\n    return result;\n}\n    \nfloat evaluateSHGeometrics(SH sh, vec3 normal)\n{\n#if 1\n    if (dot(sh.L1, sh.L1) <= 0.0f)\n    {\n        return (PI / sqrt(2.0f * PI)) * sh.L0;\n    }\n    \n    float L0 = sh.L0;\n    vec3 L1 = sh.L1;\n    float R0 = L0;\n    vec3 R1 = 0.5f * L1.zxy * L0;\n    float lenR1 = length(R1);\n    float q = 0.5f * (1.0f + dot(R1 / lenR1, normal));\n    float p = 1.0f + 2.0f * lenR1 / R0;\n    float a = (1.0f - lenR1 / R0) / (1.0f + lenR1 / R0);\n    return R0 * (a + (1.0f - a) * (p + 1.0f) * pow(q, p));\n#else\n    SH directionSH = evaluateSH(normal);\n    float res = (PI / sqrt(2.0f * PI)) + (dot(directionSH.L1, sh.L1) * 2.0f * PI / 3.0f);\n    return sh.L0 * res;\n#endif\n}\n\nvoid normalizeSH(inout SH sh)\n{\n    sh.L1 = sh.L1 / max(0.0001f, sh.L0);\n}\n\nSH convertAmbientCubeToSHLeastSquare(float ambientCubeCoeff[6])\n{\n    const float sqrtPi = 1.7724538509055160272981674833411f;\n    const float sqrtThree = 1.7320508075688772935274463415059f;\n    const float c0 = sqrtPi / 3.0f;\n    const float c1 = sqrtThree * sqrtPi / 4.0f;\n        \n    vec4 conversionVectors[6];\n    conversionVectors[0] = vec4(c0, 0.0f, 0.0f, -c1);\n    conversionVectors[1] = vec4(c0, 0.0f, 0.0f, c1);\n    conversionVectors[2] = vec4(c0, -c1, 0.0f, 0.0f);\n    conversionVectors[3] = vec4(c0, c1, 0.0f, 0.0f);\n    conversionVectors[4] = vec4(c0, 0.0f, c1, 0.0f);\n    conversionVectors[5] = vec4(c0, 0.0f, -c1, 0.0f);\n    \n    SH result;\n    result.L0 = 0.0f;\n    result.L1 = vec3(0.0f);\n    \n    for (int i = 0; i < 6; i++)\n    {\n        result.L0 += ambientCubeCoeff[i] * conversionVectors[i].x;\n        result.L1 += ambientCubeCoeff[i] * conversionVectors[i].yzw;\n    }\n    \n    // normalizeSH(result);\n    \n    return result;\n}\n\nSH projectAmbientCubeToSH(float ambientCubeCoeff[6])\n{\n    SH result;\n    \n    vec3 dir = vec3(1.0f, 0.0f, 0.0f);\n    float radiance = 1.0f * PI;\n    result.L0 = evaluateSH(dir).L0 * radiance;\n    result.L1 = evaluateSH(dir).L1 * radiance;\n\n    return result;\n}\n\nvec3 shade( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, bool useAmbientCube)\n{\n    vec3 uvw = positionToUVW(pos);\n    if (displayUVW)\n    {\n        return uvw;\n    }\n    \n    if (useAmbientCube)\n    {\n        return vec3(sampleAmbientCube(ambientCube, nor));\n    }\n    else\n    {\n        // const float sqrtPi = 1.7724538509055160272981674833411f;\n        // SH sh = convertAmbientCubeToSHLeastSquare(ambientCube);\n        SH sh = projectAmbientCubeToSH(ambientCube);\n        \n        float comp = evaluateSHGeometrics(sh, nor) / PI;\n        return vec3(comp);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    float s = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n    \n       \n    \n    Camera cam = createCamera(iTime);\n    Ray ray = createCameraRay(p, cam);\n\n    vec3 col = vec3(0.0);\n    \n    RayQuery query = raycast(ray);\n    if (query.valid)\n    {\n        vec3 pos = ray.origin + query.t * ray.dir;\n        vec3 nor = calcNormal(pos);\n\n        col = shade(pos, nor, ray.dir, query.t, p.x < s);\n    }\n    \n    col *= 0.2f;\n\tcol = pow(clamp(col, 0.0, 1.0), vec3(0.4545));\n    \n    float e = 2.0/iResolution.y;\n    col *= smoothstep( 0.0, 2.0 * e, abs(p.x-s) );\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592653589793\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\nstruct Camera\n{\n    vec3 pos;\n    vec3 target;\n};\n\nbool displayUVW = false;\nfloat vlmCellSize = 15.0f;\nvec3 vlmDimension = vec3(1.0, 1.0, 1.0);\n\nvec3 positionToUVW(vec3 posW)\n{\n    vec3 volumeSize = vlmCellSize * vlmDimension;\n    vec3 uvw = posW / volumeSize;\n    return uvw;\n}\n\nCamera createCamera(in float time)\n{\n    Camera camera;\n    float an = 0.5f * time;\n\tcamera.pos = vec3(float(5.0f)*4.*sin(an) + 25.0f,40.0,float(5.0f) * 4.*cos(an) + 25.0f);\n    camera.target = 0.5f * vlmCellSize * vlmDimension;\n    return camera;\n}\n\nmat3 createCameraMatrix(Camera camera)\n{\n    vec3 ww = normalize(camera.target - camera.pos);\n    vec3 uu = normalize(cross(ww, vec3(sin(0.0), cos(0.0), 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n\nRay createCameraRay(vec2 p, Camera camera)\n{\n    Ray cameraRay;\n    cameraRay.origin = camera.pos;\n    mat3 camMat = createCameraMatrix(camera);\n\tcameraRay.dir = normalize(camMat * vec3(p.xy,8.0));\n    return cameraRay;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nvec3 opRepLim(in vec3 p, in float c, in vec3 l)\n{\n    return c * clamp(round(p / c), vec3(0.0f), l);\n}\n\nfloat sdSphere(vec3 pos, Sphere sphere)\n{\n    return length(pos - sphere.center) - sphere.radius;\n}\n\nfloat map(vec3 p)\n{     \n    Sphere sphere;\n    sphere.center = opRepLim(p, vlmCellSize, vlmDimension - vec3(1.0, 1.0, 1.0));\n    sphere.radius = 0.25 * vlmCellSize;\n    float res = sdSphere(p, sphere);\n    return res;\n}\n\nstruct RayQuery\n{\n    bool valid;\n    float t;\n};\n\nRayQuery raycast(Ray ray)\n{\n    const float tMax = 200.0;\n\n    RayQuery result;\n    result.valid = true;\n    result.t = 0.0;\n\n    for(int i = 0; i < 70; i++)          \n    {\n        if (result.t > tMax)\n        {\n            result.valid = false;\n            return result;\n        }\n\n        float h = map(ray.origin + ray.dir * result.t);\n        if (h < (0.0001 * result.t))\n        {\n            return result;\n        }\n        result.t += h;\n    }\n\n    return result;\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    const float eps = 0.002;\n\n    const vec3 v1 = vec3( 1.0, -1.0, -1.0);\n    const vec3 v2 = vec3(-1.0, -1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0, -1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize(v1 * map(pos + v1 * eps) + \n\t\t\t\t\t  v2 * map(pos + v2 * eps) + \n\t\t\t\t\t  v3 * map(pos + v3 * eps) + \n\t\t\t\t\t  v4 * map(pos + v4 * eps));\n}","name":"Common","description":"","type":"common"}]}