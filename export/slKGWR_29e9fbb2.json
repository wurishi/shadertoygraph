{"ver":"0.1","info":{"id":"slKGWR","date":"1637592625","viewed":156,"name":"Dissolve:3D","username":"Aiibow","description":"Sphere surface dissolve (aka freeze, don't move)\nTwo sphere mapping function:\n1. Tri Planar Mapping\n2. Mercator Projection","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","dissolve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 100.\n#define MAX_STEPS 100\n#define SUR_DIST 0.01\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n#define MAT_PLANE 1\n#define MAT_SPHERE 2\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr){\n    vec3 f = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.);\n    vec3 r = normalize(cross(cp, f));\n    vec3 u =           cross(f, r);\n    \n    return mat3(r, u, f);\n}\n\nvec2 getDist(vec3 p){\n    vec2 dMat = vec2(0.);\n\n    float dP = 1000.;\n    float dSphere = length(p - vec3(0., 2., 0.)) - 1.5;\n    \n    float d = min(dP, dSphere);\n    \n    int matId = 0;\n    if (d == dP){\n        matId = MAT_PLANE;\n    }\n    else if(d == dSphere){\n        matId = MAT_SPHERE;\n    }\n    \n    dMat = vec2(d, float(matId));\n    return dMat;\n}\n\nvec3 getNormal(vec3 p){\n    vec2 dMat = getDist(p);\n    float d = dMat.x;\n    vec2 e = vec2(0.01, 0.);\n    \n    return normalize(d - vec3(\n        getDist(p - e.xyy).x,\n        getDist(p - e.yxy).x,\n        getDist(p - e.yyx).x\n        ));\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    float matId = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd * dO;\n        vec2 dMat = getDist(p);\n        float dS = dMat.x;\n        matId = dMat.y;\n        \n        if (dO > MAX_DIST || abs(dS) < SUR_DIST) break;\n        dO += dS;\n    }\n    \n    return vec2(dO, matId);\n}\n\nvec3 render(vec3 ro, vec3 rd){\n    vec3 col = texture(iChannel3, rd).rgb;\n    \n    const float PI = 3.1415;\n    vec2 dMat = rayMarch(ro, rd);\n    float d = dMat.x;\n    int matId = int(dMat.y);\n    \n    if (d < MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 nor = getNormal(p);\n        vec3 l = vec3(2., 5., 5.);\n        vec3 ld = normalize(l - p);\n        \n        float dif = clamp(dot(nor,ld)*0.5 + .5, 0., 1.);\n        \n        if (matId == MAT_PLANE)\n        {\n            col += dif * dif;\n        }\n        else if(matId == MAT_SPHERE){\n            // tri planar map\n            vec3 colXZ = texture(iChannel0, p.xz*.5 + .5).rgb;\n            vec3 colYZ = texture(iChannel0, p.yz*.5 + .5).rgb;\n            vec3 colXY = texture(iChannel0, p.xy*.5 + .5).rgb;\n            \n            vec3 n = abs(nor);\n\n            n *= pow(n, vec3(20));\n            n /= n.x + n.y + n.z;\n\n            col = colYZ*n.x + colXZ*n.y + colXY*n.z;\n            col.gb *= vec2(2., 5.);\n        \n            // Mercator Projection\n            vec3 p_u = vec3(0.,1.,0.);\n            vec3 n_v = dot(nor, p_u) * p_u;\n            vec3 n_h = nor - n_v;\n            float Phi = atan(length(n_v), length(n_h));\n            float x = atan(p.x, p.z) / PI / 2.;\n            float y = 1.5 * log(1. + Phi / 2.) / PI / 2.;\n            vec2 st = vec2(x,y);\n            \n            float pAlpha =.5 + cos(iTime) * .5;\n            vec4 alphaTex = texture(iChannel2, st);\n            float a = step(alphaTex.r, pAlpha);\n\n            // simpilify map\n            vec3 ball = vec3(0.);\n            ball += dif*pow(dif,25.);\n            vec2 uv = vec2(atan(p.x, p.z) / PI / 2.  + .5, 1.5 * p.y / 3. -.5); \n\n            // animate sync\n            float t = iTime / 6.2831;\n            float w = fract(t);\n            w = smoothstep(0.05, 0.95, w);\n            uv.x -= w;\n            uv.y = clamp(uv.y, 0., 1.);\n\n            vec4 cats = texture(iChannel1, uv);\n            ball = mix(ball, cats.rgb, cats.a) * dif;\n            \n            col = mix(ball, col, a * .8);\n        }\n        else\n            col = vec3(0., 0.1, 1.);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n    \n    vec3 ta = vec3(0., 0., 0.);\n    vec3 ro = vec3(0., 9., -6.);\n    ro.yz *= rot(-m.y+.01);;\n    ro.xz *= rot(-m.x * 6.2831);\n    \n    // facal length\n    float fl = 1.;\n    mat3 cam = setCamera(ro, ta, 0.);\n \n    vec3 rd = normalize(cam*vec3(uv, fl));\n    \n    vec3 col = render(ro, rd);\n    \n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}