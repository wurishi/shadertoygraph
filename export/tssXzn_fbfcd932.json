{"ver":"0.1","info":{"id":"tssXzn","date":"1550515499","viewed":204,"name":"banded mandelbrot fog","username":"pde","description":"An odd-event banded version of the ray-marched Julia fog; this view is oriented around one of the Mandelbrot cross-sections of the Julia set, use the mouse to explore!\n\nNow accelerated with dynamic ray jump sizes and early stopping in the inky blackness.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","juliaset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 cmult(vec2 a, vec2 b)\n{\n\n    return mat2(a,-a.y,a.x) * b;\n}\n\nvec2 spacify(vec2 p)\n{\n    return ( p - .5 * iResolution.xy ) / iResolution.y;\n}\n\nconst int counts = 17;\nconst float fcount = float(counts);\n\nint julia(in vec2 z0, in vec2 c)\n{\n    vec2 z = z0;\n    if (length(z) > 4.0)\n        return 0;\n    for (int n=0; n <counts; n++) {\n        z = cmult(z,z) +c;\n\n        if (length(z) > 4.0) return n;\n    }\n    return -1;\n}\n\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c           );\n}\n\n\nconst float ideal_frame_duration = 1.0/60.0;\n\nvoid raymarchJulia(in vec3 camera, in vec3 ray, out vec4 col)\n{\n    col =vec4(0.0);\n    float core = 0.0;\n    float steps = 50.0;\n    float time = iTime + 28.19;\n    float z2 = sin(time/7.0);\n    float corr =cos(time/3.1415);\n    vec3 pos=camera; int inc=0; float jumpsize,j0;\n    int n=0;\n    for (float dist=0.0; dist < 5.0; ) {\n        // there are lots of weird artefacts that result from jumpsize selection choices,\n        // but this one seems to work fairly well.\n        j0 = (fcount - float(inc))/fcount;\n        if (inc == -1) j0 = 1.0/fcount;\n        jumpsize = j0 * 0.04;\n        \n        pos += jumpsize*ray;\n        dist +=jumpsize;\n        inc = julia(vec2(pos.z,z2),vec2(pos.x+corr, pos.y));\n       \n        if (inc < 0) {\n            // collisions with the core of the julia set\n            core += 2.0;\n        \tif (core > 30.0)\n                break;\n        }else {\n            // collisions with the halo\n            col.x += float(inc)*jumpsize*50.0;\n            if (inc % 2 == 0) {\n                col.y += float(inc)*jumpsize*50.0;\n                col.z += float(inc)*jumpsize*50.0;\n            }\n\n        }\n        n += 1;\n        if (n == 3000) break;\n    }\n    float scale = 10.24 * steps;\n    float pen = core / 10.0;\n    col /= scale;\n    col.z -= pen;\n    col.x = col.x * 1.0 - pen/5.0;\n    col.z = col.z * 2.0 - pen;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // start at 0,0,z=3, shoot a ray at the plane z=1\n    //vec3 camera = vec3(0.2*sin(iTime/2.3),0.2*cos(iTime/18.8),4.0);\n    vec3 camera = vec3(0,0,4.0);\n    vec2 xy = spacify(fragCoord);\n    vec3 coord = vec3(xy.x, xy.y, 3.0);\n    vec3 ray = coord - camera;\n    float radius =  length(xy);\n    vec2 mouse = iMouse.xy;\n    clamp(mouse.x, 0.0, iResolution.x);\n    clamp(mouse.y, 0.0, iResolution.y);\n    \n    vec2 mouse_xy=spacify(mouse);\n    vec2 offset=spacify(vec2(iResolution.x*0.74,iResolution.y*0.25));\n    mat3 rot = rotationMatrix(vec3(2.0*mouse_xy.y, mouse_xy.x, 0.0),2.0*length(mouse_xy));\n    \n    camera = camera*rot;\n    ray = ray*rot;\n    raymarchJulia(camera, ray, fragColor);\n\n}\n  ","name":"Image","description":"","type":"image"}]}