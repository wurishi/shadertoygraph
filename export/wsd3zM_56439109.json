{"ver":"0.1","info":{"id":"wsd3zM","date":"1569328143","viewed":141,"name":"Complex Joukowski wing","username":"Ultraviolet","description":"Follow-up of https://www.shadertoy.com/view/wdtGD7","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["map","complex","conformal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// Complex potential around a circle with attack angle alpha\nvec2 circlePot(vec2 z)\n{\n    vec2 w = vec2(0,0);\n    w += U0 * cmul(cexp(-alpha), z);\n    w += U0 * cmul(cexp(alpha), cdiv(vec2(a*a, 0.), z));\n    w += cmul(vec2(0., -gamma / 2. / pi), clog(z));\n    return w*vec2(1., -1.);\n}\n\nvec2 invJouk(vec2 z)\n{\n    z = cmul(cexp(alpha), z);\n    \n    vec2 r1 = z/2. + csqrt(cmul(z,z)/4. - vec2(_c*_c, 0.))-z0;\n    vec2 r2 = z/2. - csqrt(cmul(z,z)/4. - vec2(_c*_c, 0.))-z0;\n\n    if (cnorm(r1) > cnorm(r2))\n        return r1;\n    else\n        return r2;\n}\n\n// Compute velocity using potential derivative\n// Taking into account z0 shift and inverse conformal map\nvec2 complexVelocity(vec2 z)\n{\n    vec2 eps = vec2(1./900., 0.);\n    vec2 dwdz = (circlePot(invJouk(z+eps)) - circlePot(invJouk(z)))/eps.x;\n    return dwdz;\n}\n\nfloat computeP(vec2 z)\n{\n    vec2 v = complexVelocity(z);\n    return U0*U0-dot(v,v);\n}\n\nfloat computeW(vec2 z)\n{\n    return cnorm(invJouk(z))<a?1.:0.;\n}\n\n\n\n// This comes from the Bernstein polynomial B2,4.\n// It is not perfect as Sum(w(t+i/4)) for i in [0,3] is not exactly 1.\n// I'm opened for suggestions !\nfloat weight(float t)\n{\n    t = mod(t, 1.);\n    return 7.5*t*t*(1.-t)*(1.-t);\n}\n\n\nvec2 screenToWorld(vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n    return 4.*((fragCoord / iResolution.y) * 2. - vec2(aspect, 1.));\n}\n\nvec2 worldToScreen(vec2 pos)\n{\n    float aspect = iResolution.x / iResolution.y;\n    return (pos/4. - vec2(aspect, 1.))/2.*iResolution.y;\n}\n\n\nfloat getV( vec2 fragCoord )\n{\n    vec4 buf = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    return buf.x;\n    \n    float t = iTime;\n    return weight(t)*buf.x + weight(t+.25)*buf.y + weight(t+.5)*buf.z + weight(t+.75)*buf.w;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 pos = screenToWorld(fragCoord);\n    \n    //pos = invJouk(pos);\n\t//renderGrid(pos, fragColor.rgb);\n    //renderUnitSquare(pos, fragColor.rgb);\n    //renderUnitCircle(pos, fragColor.rgb);\n    //renderAxes(vec2(0), pos, fragColor.rgb);\n    \n    float pAlpha = 0.4;\n    \n    \n    // --- Pressure\n    float P = computeP(pos);\n    \n    fragColor.rgb = vec3(1.);\n        \n    //fragColor.rgb = vec3(1.-pAlpha*max(-P, 0.),1.-pAlpha*max(-P, 0.)-pAlpha*max(P, 0.),1.-pAlpha*max(P, 0.));\n    \n    //fragColor.rgb = vec3(1.);\n    \n    \n    //fragColor.rgb = vec3(complexVelocity(pos).y, 0., 0.);\n    //fragColor.rgb = vec3(circlePot(pos).y, 0., 0.);\n    \n    // --- integral lines\n    \n    float vAlpha = .5;\n    float V = 1.-vAlpha+vAlpha*getV(fragCoord);\n    fragColor.rgb *= V;\n    \n    // --- Wing\n    float W = computeW(pos);\n    fragColor.rgb *= 1.-W;\n    if(W>0.5)\n        fragColor.rgb = vec3(0.3,0.5,0.7);\n    \n    \n    \n    //fragColor.rgb = mix(vec3(V*vAlpha+1.-vAlpha), vec3(.6, .6, 1.), max(-P, 0.));\n    \n    //vec2 val = complexVelocity(pos)-vec2(U0, 0.);\n    //vec2 val = complexVelocity(pos);\n    //vec2 val = .5*circlePot(pos);\n    //float vv = 1.-mod(length(val), 1.);\n    //float vv = (atan(val.y, val.x) +pi) / pi / 2.;\n    //fragColor.rgb = vec3(vv);\n    \n    //fragColor.gb *= 1.-W;\n    \n    //*\n    vec2 tileCenter = screenToWorld(arrowTileCenterCoord(fragCoord));\n\tfloat arrow_dist = arrow(fragCoord.xy, ARROW_TILE_SIZE*.2*(complexVelocity(tileCenter)-vec2(U0, 0.)*0.));\n\tvec4 arrow_col = vec4(0, 0, 0, clamp(arrow_dist, 0.0, 1.0));\n\tfragColor = mix(arrow_col, fragColor, arrow_col.a);\n\t//*/\n      \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nconst float pi = 3.14;\n\nvec2 cadd( vec2 a, float s ) { return vec2( a.x+s, a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\nvec2 csqrt( vec2 z )         { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 cconj( vec2 z )         { return vec2(z.x,-z.y); }\nvec2 cexp( float b )         { return vec2(cos(b), sin(b)); }\nvec2 cexp( vec2 z )          { return exp(length(z))*cexp(atan(z.y, z.x)); }\nfloat cnorm( vec2 z )        { return length(z); }\nvec2 clog(vec2 z)            { return vec2(log(length(z)),atan(z.y, z.x)); }\n\n\nconst float U0 = 1.;              // Velocity\nconst float a = 1.;               // Radius\n\n//#define _c  0.9   \n//#define alpha  (20./180.*pi)\n#define b1 0.05\n#define b2 0.2\n\n\n#define _c  (iMouse.z>0.5 ? iMouse.x/iResolution.x : 0.9)\n#define alpha  (iMouse.z>0.5 ? 2.*pi*iMouse.y/iResolution.y-pi : 20./180.*pi)\n//#define b1 (2.*iMouse.x/iResolution.x-1.)     \n//#define b2 (2.*iMouse.y/iResolution.y-1.)\n\n\n#define gamma ( -4.*pi*U0*((a+b1) * sin(alpha) + b2*cos(alpha)))\n#define z0  vec2(-b1,b2)\n\n// https://www.shadertoy.com/view/ls2GWG\n\n\nconst float ARROW_TILE_SIZE = 32.0;\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n\treturn (floor(pos / ARROW_TILE_SIZE) + 0.5) * ARROW_TILE_SIZE;\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2) {\n\tvec2 center = (p1 + p2) * 0.5;\n\tfloat len = length(p2 - p1);\n\tvec2 dir = (p2 - p1) / len;\n\tvec2 rel_p = p - center;\n\tfloat dist1 = abs(dot(rel_p, vec2(dir.y, -dir.x)));\n\tfloat dist2 = abs(dot(rel_p, dir)) - 0.5*len;\n\treturn max(dist1, dist2);\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n\t// Make everything relative to the center, which may be fractional\n\tp -= arrowTileCenterCoord(p);\n\t\t\n\tfloat mag_v = length(v), mag_p = length(p);\n\t\n\tif (mag_v > 0.0) {\n\t\t// Non-zero velocity case\n\t\tvec2 dir_v = v / mag_v;\n\t\t\n\t\t// We can't draw arrows larger than the tile radius, so clamp magnitude.\n\t\t// Enforce a minimum length to help see direction\n\t\t//mag_v = clamp(mag_v, 5.0, ARROW_TILE_SIZE * 0.5);\n\n\t\t// Arrow tip location\n\t\tv = dir_v * mag_v;\n\n\t\t// Signed distance from shaft\n\t\tfloat shaft = line(p, v, -v);\n\t\t// Signed distance from head\n\t\tfloat head = min(line(p, v, 0.4*v + 0.2*vec2(-v.y, v.x)),\n\t\t                 line(p, v, 0.4*v + 0.2*vec2(v.y, -v.x)));\n\n\t\treturn min(shaft, head);\n\t} else {\n\t\t// Signed distance from the center point\n\t\treturn mag_p;\n\t}\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PERIOD\t1.\n#define EPSILON\t0.05\n\n#define SPEED_EV\t(1.5*iMouse.x/iResolution.x)\n#define SPEED_AM\t(0.5+iMouse.y/iResolution.y)\n\n\n\n\nvec2 screenToWorld(vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n    return 4.*((fragCoord / iResolution.y) * 2. - vec2(aspect, 1.));\n}\n\nvec2 worldToScreen(vec2 pos)\n{\n    float aspect = iResolution.x / iResolution.y;\n    return (pos/4. - vec2(aspect, 1.))/2.*iResolution.y;\n}\n\n\n// Shift of circle  as a complex number\n\n\n// Complex potential around a circle with attack angle alpha\nvec2 circlePot(vec2 z)\n{\n    vec2 w = vec2(0,0);\n    w += U0 * cmul(cexp(-alpha), z);\n    w += U0 * cmul(cexp(alpha), cdiv(vec2(a*a, 0.), z));\n    w += cmul(vec2(0., -gamma / 2. / pi), clog(z));\n    return w*vec2(1., -1.);\n}\n        \nvec2 Jouk(vec2 z)\n{\n    \n    return cmul(-cexp(alpha), z+z0 + cdiv(vec2(_c*_c, 0.),z+z0));\n}\n\nvec2 invJouk(vec2 z)\n{\n    z = cmul(cexp(alpha), z);\n    \n    vec2 r1 = z/2. + csqrt(cmul(z,z)/4. - vec2(_c*_c, 0.))-z0;\n    vec2 r2 = z/2. - csqrt(cmul(z,z)/4. - vec2(_c*_c, 0.))-z0;\n\n    if (cnorm(r1) > cnorm(r2))\n        return r1;\n    else\n        return r2;\n}\n\n// Compute velocity using potential derivative\n// Taking into account z0 shift and inverse conformal map\nvec2 complexVelocity(vec2 z)\n{\n    vec2 eps = vec2(1./900., 0.);\n    vec2 dwdz = (circlePot(invJouk(z+eps)) - circlePot(invJouk(z)))/eps.x;\n    return dwdz;\n}\n\nfloat computeP(vec2 z)\n{\n    vec2 v = complexVelocity(z);\n    return U0*U0-dot(v,v);\n}\n\nfloat computeW(vec2 z)\n{\n    return cnorm(invJouk(z))<a?1.:0.;\n}\n\n\n\n\nvec2 speed(vec2 fragCoord)\n{\n    return complexVelocity(screenToWorld(fragCoord));\n}\n\n#define h 2.\nvec2 RK4(vec2 p){\n    vec2 k1 = speed(p);\n    \n    return h*k1;\n    \n    vec2 k2 = speed((p-0.5*h*k1));\n    vec2 k3 = speed((p-0.5*h*k2));\n    vec2 k4 = speed((p-h*k3));\n    return h/3.*(0.5*k1+k2+k3+0.5*k4);\n}\n\nfloat noiseTexture(vec2 p, float t)\n{\n    float val = texture(iChannel2,p/iResolution.xy + t).x;\n    \n    /*\n    //if(texelFetch(iChannel2, ivec2(32,2),0).x>.5)\n    {\n        val *= .5;\n        val += texture(iChannel2,p.xy*2. + t*2.).x *.25;\n        val += texture(iChannel2,p.xy*4. + t*4.).x *.125;\n        val += texture(iChannel2,p.xy*8. + t*8.).x *.0625;\n    }\n\t//*/\n    \n    return val;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    \n    //O = texture(iChannel2,worldToScreen(screenToWorld(C))/iResolution.xy);\n    //return;\n    \n    /*\n    if(iFrame == 0)\n    {\n        O = vec4(0);\n    }\n    \n    O = texture(iChannel0, (C-0.1*worldToScreen(complexVelocity(screenToWorld(C))))/iResolution.xy);\n    return;\n*/\n    \n    \n    vec4 buf = texture(iChannel0,(C-speed(C))/iResolution.xy);\n    \n    \n    float val0, val1, val2, val3;\n    \n    if(iTime < EPSILON)\n    {\n        val0 = noiseTexture(C, 0.);\n        val1 = val0;\n        val2 = val0;\n        val3 = val0;\n    }\n    else\n    {\n        val0 = buf.x;\n        val1 = buf.y;\n        val2 = buf.z;\n        val3 = buf.w;\n    }\n        \n    float t = iTime/PERIOD;\n    if(mod(t, 1.0) < EPSILON)\n    {\n        val0 = noiseTexture(C, t);\n    }\n    \n    if(mod(t+.25, 1.0) < EPSILON)\n    {\n        val1 = noiseTexture(C, t);\n    }\n    \n    if(mod(t+.5, 1.0) < EPSILON)\n    {\n        val2 = noiseTexture(C, t);\n    }\n    \n    if(mod(t+.75, 1.0) < EPSILON)\n    {\n        val3 = noiseTexture(C, t);\n    }\n    \n    O = vec4(val0, val1, val2, val3);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvec2 screenToWorld(vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n    return 4.*((fragCoord / iResolution.y) * 2. - vec2(aspect, 1.));\n}\n\nvec2 worldToScreen(vec2 pos)\n{\n    float aspect = iResolution.x / iResolution.y;\n    return (pos/4. - vec2(aspect, 1.))/2.*iResolution.y;\n}\n\n\n\n\n// Complex potential around a circle with attack angle alpha\nvec2 circlePot(vec2 z)\n{\n    vec2 w = vec2(0,0);\n    w += U0 * cmul(cexp(-alpha), z);\n    w += U0 * cmul(cexp(alpha), cdiv(vec2(a*a, 0.), z));\n    w += cmul(vec2(0., -gamma / 2. / pi), clog(z));\n    return w*vec2(1., -1.);\n}\n        \nvec2 Jouk(vec2 z)\n{\n    \n    return cmul(-cexp(alpha), z+z0 + cdiv(vec2(_c*_c, 0.),z+z0));\n}\n\nvec2 invJouk(vec2 z)\n{\n    z = cmul(cexp(alpha), z);\n    \n    vec2 r1 = z/2. + csqrt(cmul(z,z)/4. - vec2(_c*_c, 0.))-z0;\n    vec2 r2 = z/2. - csqrt(cmul(z,z)/4. - vec2(_c*_c, 0.))-z0;\n\n    if (cnorm(r1) > cnorm(r2))\n        return r1;\n    else\n        return r2;\n}\n\n// Compute velocity using potential derivative\n// Taking into account z0 shift and inverse conformal map\nvec2 complexVelocity(vec2 z)\n{\n    vec2 eps = vec2(1./900., 0.);\n    vec2 dwdz = (circlePot(invJouk(z+eps)) - circlePot(invJouk(z)))/eps.x;\n    return dwdz;\n}\n\nfloat computeP(vec2 z)\n{\n    vec2 v = complexVelocity(z);\n    return U0*U0-dot(v,v);\n}\n\nfloat computeW(vec2 z)\n{\n    return cnorm(invJouk(z))<a?1.:0.;\n}\n\n\n\n\nvec2 speed(vec2 fragCoord)\n{\n    return complexVelocity(screenToWorld(fragCoord));\n}\n\n#define h 2.\nvec2 RK4(vec2 p){\n    vec2 k1 = speed(p);\n    \n    return h*k1;\n    \n    vec2 k2 = speed((p-0.5*h*k1));\n    vec2 k3 = speed((p-0.5*h*k2));\n    vec2 k4 = speed((p-h*k3));\n    return h/3.*(0.5*k1+k2+k3+0.5*k4);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    vec4 buf = texture(iChannel0,(C-10.*speed(C))/iResolution.xy);\n    \n    \n    float val = buf.x;\n    \n    C.y -= C.x*speed(C).y/speed(C).x;\n    \n    if(C.x<5.)\n        val = max(0.,sin(C.y/iResolution.y*50.));\n    \n    O = vec4(val);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nvec2 screenToWorld(vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n    return 4.*((fragCoord / iResolution.y) * 2. - vec2(aspect, 1.));\n}\n\nvec2 worldToScreen(vec2 pos)\n{\n    float aspect = iResolution.x / iResolution.y;\n    return (pos/4. - vec2(aspect, 1.))/2.*iResolution.y;\n}\n\n\n\n\n// Complex potential around a circle with attack angle alpha\nvec2 circlePot(vec2 z)\n{\n    vec2 w = vec2(0,0);\n    w += U0 * cmul(cexp(-alpha), z);\n    w += U0 * cmul(cexp(alpha), cdiv(vec2(a*a, 0.), z));\n    w += cmul(vec2(0., -gamma / 2. / pi), clog(z));\n    return w*vec2(1., -1.);\n}\n    \nvec2 invJouk(vec2 z)\n{\n    z = cmul(cexp(alpha), z);\n    \n    vec2 r1 = z/2. + csqrt(cmul(z,z)/4. - vec2(_c*_c, 0.))-z0;\n    vec2 r2 = z/2. - csqrt(cmul(z,z)/4. - vec2(_c*_c, 0.))-z0;\n\n    if (cnorm(r1) > cnorm(r2))\n        return r1;\n    else\n        return r2;\n}\n\n// Compute velocity using potential derivative\n// Taking into account z0 shift and inverse conformal map\nvec2 complexVelocity(vec2 z)\n{\n    vec2 eps = vec2(1./900., 0.);\n    vec2 dwdz = (circlePot(invJouk(z+eps)) - circlePot(invJouk(z)))/eps.x;\n    return dwdz;\n}\n\n\nvec2 speed(vec2 fragCoord)\n{\n    return complexVelocity(screenToWorld(fragCoord));\n}\n\n#define h 2.\nvec2 RK4(vec2 p){\n    vec2 k1 = speed(p);\n    \n    return h*k1;\n    \n    vec2 k2 = speed((p-0.5*h*k1));\n    vec2 k3 = speed((p-0.5*h*k2));\n    vec2 k4 = speed((p-h*k3));\n    return h/3.*(0.5*k1+k2+k3+0.5*k4);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    if(all(equal(ivec2(C), ivec2(0))))\n    {\n        O=vec4(_c, alpha, z0);\n        return;\n    }\n           \n    \n    if(iFrame != 0 && all(lessThan(abs(texelFetch(iChannel0, ivec2(0), 0) - vec4(_c, alpha, z0)), vec4(.001))))\n        C = texelFetch(iChannel0, ivec2(C), 0).yz;\n    \n    vec2 s;\n    \n    if(C.x>0.)\n    {\n        for(int i=0; i<256; ++i)\n        {\n            s = speed(C);\n            C -= 1.*s;\n            if(C.x<0.)\n            {\n                C.y-=C.x*s.y/s.x;\n                break;\n            }\n        }\n    }\n    \n    O = vec4(max(0.,sin((C.y)/iResolution.y*50.)), C, 0.);\n    \n}","name":"Buffer C","description":"","type":"buffer"}]}