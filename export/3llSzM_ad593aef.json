{"ver":"0.1","info":{"id":"3llSzM","date":"1562432573","viewed":1247,"name":"Devour (procedural artwork)","username":"noby","description":"A port of my 4 kilobyte procedural graphics entry from earlier this year. Released at Revision 2019, where it got 2nd place in a very tough competition.\n\nSource: https://github.com/armak/pbr-devour\nPouet: https://www.pouet.net/prod.php?which=81043","likes":46,"published":1,"flags":32,"usePreview":0,"tags":["procedural","fractal","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float gamma = 2.2;\nvec3 tonemap(vec3 color){\n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.01;\n\tfloat F = 0.30;\n\tfloat W = 90.0;\n\tfloat exposure = 4.0;\n\tcolor *= exposure;\n\tcolor = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n\tfloat white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n\tcolor /= white;\n\t\n\treturn color;\n}\n\nconst int N = 8;\nvec3 ca(sampler2D t, vec2 UV){\n\tvec2 uv = 1.0 - 2.0 * UV;\n\tvec3 c = vec3(0);\n\tfloat rf = 1.0;\n\tfloat gf = 1.0;\n    float bf = 1.0;\n\tfloat f = 1.0/float(N);\n\tfor(int i = 0; i < N; ++i){\n\t\tc.r += f*texture(t, 0.5-0.5*(uv*rf) ).r;\n\t\tc.g += f*texture(t, 0.5-0.5*(uv*gf) ).g;\n\t\tc.b += f*texture(t, 0.5-0.5*(uv*bf) ).b;\n\t\tbf *= 0.9995;\n\t\tgf *= 0.9997;\n        rf *= 0.99988;\n\t}\n\treturn c;\n}\n\nvec3 source(vec2 coord){\n    vec4 fc = texelFetch(iChannel0, ivec2(coord), 0);\n    //fc = vec4(ca(iChannel0, coord/iResolution.xy), fc.w);\n\tfc.rgb = fc.rgb/(float(iFrame)-fc.w);\n    \n    vec2 uv = (coord / iResolution.xy - 0.5) * (iResolution.x/iResolution.y) * 2.0;\n\tfc.rgb *= 1.0 / pow(0.09 * dot(uv, uv) + 1.0, 2.0);\n    \n    fc.rgb = tonemap(fc.rgb);\n    fc.rgb = smoothstep(vec3(0), vec3(1), fc.rgb);\n    return fc.rgb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 center = source(fragCoord + vec2(0, 0));\n    vec3 c = vec3(0);\n    // sharpening\n    //c += source(fragCoord + vec2(-1,-1));\n    //c += source(fragCoord + vec2( 1,-1));\n    //c += source(fragCoord + vec2(-1, 1));\n    //c += source(fragCoord + vec2( 1, 1));\n    c += -1.0*source(fragCoord + vec2( 0,-1));\n    c += -1.0*source(fragCoord + vec2(-1, 0));\n    c +=  5.0*center;\n    c += -1.0*source(fragCoord + vec2( 1, 0));\n    c += -1.0*source(fragCoord + vec2( 0, 1));\n    \n    c = mix(center, c, 0.12);\n    \n    // color correction and gamma\n    fragColor.rgb = pow( pow(c, vec3(1.005, 1.0, 0.99)), vec3(1.0 / gamma));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// by Dave_hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec4 hash42(vec2 p){\n    vec4 p4 = fract(vec4(p.xyxy)*vec4(1031,.1030,.0973,.1099));\n    p4 += dot(p4,p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n// by nimitz\n// https://www.shadertoy.com/view/4t3yDn\nfloat orbitnoise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 fp = fract(p) - 0.5;\n    float rz = 0.;\n    float orbitRadius = 0.5;\n    for (int j = -2; j <= 2; j++){\n        for (int i = -2; i <= 2; i++){\n            vec2 dp = vec2(j,i);\n            vec4 rn = hash42(dp + ip) - 0.5;\n            vec2 op = fp - dp - rn.zw*orbitRadius;\n            rz += smoothstep(1.4, float(0), length(op))*dot(rn.xy*1.4, op);\n        }\n    }\n    return rz*0.5 + 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 s = 15.8*(fragCoord/iResolution.xx);\n\tfloat r = 0.0;\n\tfragColor = vec4(0);\n    for(int g = 0; g < 5; g++){\n\t\tr += .45*sin(1.63*s.x)*sin(1.5*s.y);\n\t\ts  = mat2(.8,.61,-.6,.8)*s*2.002;\n        r += .25*sin(1.5*s.x)*sin(1.5*s.y);\n        s  = mat2(.7,.62,-.59,.8)*s*2.003;\n        r += .125*sin(1.5*s.x)*sin(1.5*s.y);\n        s  = mat2(.8,.7,-.6,.8)*s*2.001;\n        r += .0625*sin(1.5*s.x)*sin(1.5*s.y);\n        \n        fragColor += 0.9+r/.7;\n        s = fragColor.xx;\n    }\n\n    fragColor.x = pow(1.0-smoothstep(0.4,1.05, fragColor.x*0.09), 1.25);\n\n    float n = 120000000.0;\n    for(int i = 0; i < 7; ++i){\n        float f = pow(2.0, float(1+i));\n        n *= 0.02+0.98*orbitnoise(s*f*0.125)/f;\n    }\n\n    fragColor.b = smoothstep(0.01, 1.25, n);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//#define LOOKS_WRONG\n//#define SLURM\n\nconst float pi  = 3.1415926;\nconst float pi2 = 2.0*pi;\n\nfloat maxcomp(vec3 p) { return max(p.x,max(p.y,p.z));}\nvec4 mmin(vec4 a, vec4 b) { return a.x < b.x ? a : b; }\nvec4 mmax(vec4 a, vec4 b) { return a.x > b.x ? a : b; }\n\nfloat box(vec3 p, vec3 b){\n\tvec3  di = abs(p) - b;\n\tfloat mc = maxcomp(di);\n\treturn mc;\n}\n\nfloat hash13(vec3 p3){\n    p3 = fract((p3)*0.1031);\n    p3 += dot(p3, p3.yzx  + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat seed;\nfloat hash(){\n\tvec3 p3  = fract(vec3(seed++) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash(float p){\n    vec3 p3 = fract(vec3(p)*vec3(.1031,.1030,.0973));\n    p3 += dot(p3,p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 fc;\nfloat sd;\nvec2 hash2(float n){\n    vec2 rand = texelFetch(iChannel1, ivec2(mod(fc,1024.)),0).rg;\n    rand += hash(sd+float(iFrame)+n);\n    return mod(rand, 1.0);\n}\n\n#define scale .7\n#define maxi 0.75\n#define fr_it 8\nvec4 map(vec3 p){\n    vec3 po = p;\n    \n    #ifdef LOOKS_WRONG\n    p = -p;\n    #endif\n    \n    float k=1.;\n    for(int i = 0; i < fr_it; ++i){\n        vec3 ss = vec3(-.54,0.84,1.22);\n        p = 2.0*clamp(p,-ss,ss)-p;\n        float f = max(scale/dot(p,p),maxi);\n        p *= f;\n        k *= f*1.05;\n        //e = f;\n    }\n    \n    vec4 res = vec4(max(length(p.xz)-.9,length(p.xz)*abs(p.y)/length(p))/k, 3.0, 0.0, 1.0);\n    \n    #ifdef LOOKS_WRONG\n    p = -p;\n    #endif\n    \n\t// crumbly\n    res.x += (-1.0+2.0*hash13( floor(p*10.0) ))*0.005 * (1.0-step(0.01, po.y));\n    \n    // glowy bits\n    const float of = -1.0;\n    const float l = 0.1;\n    res.z = max(0.0, 60.0*(smoothstep(of-l,of,p.y)-smoothstep(of,of+l,p.x)));\n    res.z *= step(-1.0, po.z);\n    \n    // blast\n\tconst float ang = 0.04;\n    const mat2 rot = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\n    vec3 tpo = po-vec3(0,0.12,-1.5);\n    tpo.xy *= rot;\n    float blast = pow(smoothstep(-1.6, 0.35,po.x)-smoothstep(0.4,0.48,po.x), 3.0);\n    res = mmin(res, vec4(length( (tpo).yz )-0.02*blast, 2, mix(0.0,25.0, pow(blast,2.0)), 0));\n    \n    #ifdef SLURM\n    tpo = po-vec3(0,0.4,0.1);\n    float an2 = p.y*2.2;\n    tpo.xy *= mat2(cos(an2), sin(an2), -sin(an2), cos(an2));\n    float blas2 = pow(smoothstep(-1.6, 0.35,po.x)-smoothstep(0.4,1.0,po.x), 3.0);\n    vec4 fume = vec4(length( (tpo).xz )-0.12*blas2, 2, .0, 0);\n    fume = mmax(fume, vec4( -(length(po-vec3(0.55,0.18,0.0))-0.25), 0,0,0));\n    res = mmin(res, vec4(0.05,1,1,1)*fume);\n    #endif\n\n    // ground plane\n    res = mmin(res, vec4( po.y+0.015, 0, 0, 0 ));\n\n    // bounding box\n    res = mmax(res, vec4(box(po, vec3(11,1.0,11)), 3, 0, 1));\n    \n    // medium light source (background)\n    res = mmin(res, vec4(length(po-vec3(-2.4,0,-5))-0.4, vec3(0, 30, 0)));\n    \n    // huge light source (off camera)\n    return mmin(res, vec4(length(po-vec3(-3.8,3.,-2.7))-2.4, vec3(1, 30, 0)));\n}\n\nconst float E = 0.00025; //0.0002\nvec4 intersect(vec3 ro, vec3 rd){\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n\tvec4 h = vec4(1.0);\n    for(int i = 0; i < 125; i++){\n        // dynamic epsilon\n        float eps = E + E*5.0*pow(float(i)/200.0,2.0);\n\t\tif(h.x < eps || t > 15.0)\n            break;\n        h = map(ro + rd*t);\n        res = vec4(t, h.yzw);\n        t += h.x;\n    }\n\t\n    // signal for no intersection and reached maximum distance\n\treturn (t >= 15.0 ? vec4(-999) : res);\n}\n\nvec3 calcNormal(vec3 p){\n    // basic central difference with 3 (4) samples\n    // TODO: optimize the central sample away since it's available from callee always anyway\n    float c = map(p).x;\n    const float e = 0.00001;\n    return normalize(vec3(c-map(p-vec3(e,0,0)).x, c-map(p-vec3(0,e,0)).x, c-map(p-vec3(0,0,e)).x));\n}\n\nvec3 lambert(in vec3 normal, in vec2 uv){\n   float theta = pi2 * uv.x;\n   uv.y = 2.0 * uv.y - 1.0;\n   vec3 spherePoint = vec3(sqrt(1.0 - uv.y * uv.y) * vec2(cos(theta), sin(theta)), uv.y);\n   return normalize(normal + spherePoint);\n}\n\nvec3 ggx(vec3 rd, vec3 n, float rgh, vec2 rand){\n    float s  = -1.+2.*step(0.,n.z);\n    float a  = -1./(s+n.z);\n    float b  = n.x*n.y*a;\n    mat3  cs = mat3(vec3(1.+s*n.x*n.x*a,s*b,-s*n.x),n,vec3(b,s+n.y*n.y*a,-n.y));\n    float th = 0.5*pi*atan((rgh*sqrt(rand.x))/sqrt(1.0-rand.x));\n    \n    vec3 reflection = normalize(transpose(cs)*rd);\n    vec3 normal_distribution = vec3(cos(pi2 * rand.y)*sin(th), cos(th), sin(pi2 * rand.y)*sin(th));\n    \n    //normal_distribution.x *= 0.1;\n    //normal_distribution = normalize(normal_distribution);\n    \n    return normalize(cs*reflect(reflection, normal_distribution));\n}\n\nvec3 brdf(in vec3 normal, in vec2 uv, in vec3 rd){\n\tfloat theta = 2.0 * pi * uv.x;\n\tuv.y = 2.0 * uv.y - 1.0;\n\tvec3 p = vec3(sqrt(1.0 - uv.y * uv.y) * vec2(cos(theta), sin(theta)), uv.y);\n\tfloat z=dot(p,normal);\n\tp-=z*normal;\n\n\tp/=sqrt(1.0-z*z);\n\tp*=(1.0-2.0*z+z*z)/4.0;\n\tp+=normal*sqrt(1.0-dot(p,p));\n\n\tvec3 ha=normalize(p);\n\tp=normalize(reflect(normalize(rd),p));\n\n\treturn p;\n}\n\nvec3 colors[6];\n\nvec3 render(vec3 ro, vec3 rd){\n\n    vec3 color = vec3(0);\n    vec3 absorption = vec3(1);\n    const int bounces = 4;\n\n    for(int b = 0; b < bounces; b++)\n    {\n        sd += 1.0;\n        vec4 tmat = intersect(ro,rd);\n        if(tmat.x >= 0.0)\n        {\n            vec3 pos = ro + tmat.x*rd;\n            vec3 nor = calcNormal(pos);\n            \n            // fake texture coordinates for the metal parts\n            // looks good enough from the camera position\n            vec2 metal_coords = cross(nor, normalize(vec3(1,0,2)) ).xy;\n            // get roughness map values\n            float rough_map = mix(texture(iChannel2, mod(metal_coords*1.21,1.0)).r,\n                                  texture(iChannel2, mod(metal_coords*0.53,1.0)).r, 0.7);\n            rough_map = pow(1.0-rough_map,2.0);\n\n            // incoming light value\n            vec3 incoming = colors[int(tmat.y)];\n            // modulate surface color (metal parts) with the roughmess map a bit\n            incoming *= 1.0+0.1*(1.0-2.0*rough_map)*step(1.0, tmat.w);\n\n            vec2 tval = max(texture(iChannel2, pos.zx*0.61).br, texture(iChannel2, pos.xz*0.75).rb);\n            tval = mix(tval, pow(texture(iChannel2, pos.zx*-3.43).rb, vec2(2))*0.5, 0.25);\n            incoming = mix(incoming*vec3(0,0.5,1)*0.2, incoming, mix(0.75+0.5*length(tval), 1.0, step(-0.001, pos.y)));\n\n            // emissive materials\n            vec3 emission = tmat.z*incoming;\n            // recursive color etc\n            color += absorption * emission;\n            \n            // calculate the brdf with magic formulas\n            vec3 rv = reflect(rd, nor);\n            \n            float rough1 = 0.3-0.3*pow(min(tval.x, tval.y), 0.1);\n            float rough2 = mix(0.04, 0.02+0.04*pow(1.0-rough_map,2.0), step(0.01,pos.y));\n            \n            // this shadertoy version uses the blue noise texture for material/light sampling since it's available\n            // should be at least as good or better as far as quality and performance go\n            vec3 metal  = mix(brdf(nor, hash2(-431.23), rd), ggx(rd, nor, rough2, hash2(-43.531)), step(0.45,hash()));\n            vec3 ground = mix(lambert(nor, hash2(9531.5312)), ggx(rd, nor, rough1, hash2(86439.3)), step(0.5,hash()));\n            //vec3 metal  = mix(brdf(nor, R2_seq(iFrame, 0.5, 31.23+sd), rd), ggx(rd, nor, rough2, R2_seq(iFrame, 0.5, -43.531)), step(0.45,hash()));\n            //vec3 ground = mix(lambert(nor, R2_seq(iFrame, 0.5, 9531.5312+sd)), ggx(rd, nor, rough1, R2_seq(iFrame, 0.5, 86439.3)), step(0.5,hash()));\n            \n            // physical attenuation factor\n            // TODO: pi is correct only for lambert; find and pick the appropriate\n            // normalization factor for other brdfs\n            absorption *= incoming/pi;\n            \n            rd = mix(ground, metal, tmat.w);\n            // fresnel doesn't look so good here, honestly\n            //float fresnel = pow(max(0., dot(nor, rd)), 5.);\n            //rd = mix(rd, rv, 1.0-step(fresnel, hash()));\n            \n            // new origin position, offset away from the surface to prevent self-intersection\n            ro = pos+rd*E*20.0;\n        } else {\n            // no intersection, currently actually doesn't doo much of anything...\n            vec3 pos = ro + tmat.x*rd;\n            color += absorption * colors[4]*0.9;\n            break;\n        }\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    if(iMouse.z > 0.5 && iFrame > 0){\n        fragColor = vec4(vec3(0), float(iFrame));\n        return;\n    } else if(iFrame == 0){\n        fragColor.w = 0.0;\n    }\n\t\n\t// fill global color values\n\tcolors[0] = 1.25*vec3(0.75,0.52,0.4).bgr;\n    colors[1] = 1.25*vec3(0.75,0.38,0.2).bgr;\n    colors[2] = vec3(0.6,0.32,0.92).bgr;\n    colors[3] = vec3(0.42,0.66,0.95).bgr;\n    colors[4] = normalize(vec3(3.0,1.0,0.5)).bgr;\n    colors[5] = vec3(1.0, 0.1 ,0.04).bgr;\n    fc = gl_FragCoord.xy;\n    seed = float(((iFrame*73856093)^int(gl_FragCoord.x)*19349663^int(gl_FragCoord.y)*83492791)%38069);\n        \n    float aspect = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 ro = vec3(.6,.1,.7)*20.0;\n    \n    fc = fragCoord;\n    vec3 col = vec3(0.0);\n    \n    // we only do one sample in this version, the loop is redundant\n    ///const int samples = 1;\n    //for(int s = 0; s < samples; s++){\n\n        // calculate camera/view orientation\n        vec3 ww = normalize(vec3(0.76,0.38,0.1)-ro);\n\t\tvec3 uu = normalize(cross(normalize(vec3(0,1,0)),ww));\n\t\tvec3 vv = normalize(cross(ww,uu));\n        \n        //vec2 rand = R2_seq(iFrame, 1.0, -10.0);\n        vec2 rand = hash2(0.0);\n        \n        // anti aliasing samples\n        vec2 p = -1.0 + 2.0 * (uv + 0.667*(-1.0+2.0*hash2(3531.412))/iResolution.xy);\n        p.x *= aspect;\n        \n        // lens samples...\n        vec2 lens_sample = vec2(cos(rand.x*pi2),sin(rand.x*pi2))*pow(rand.y, 0.32);\n        // anamorphic stretch\n        lens_sample *= vec2(0.75, 1.333);\n        // re-calculate view vectors based on the lens samples\n        float ffac = pow( smoothstep(0.1, 1.99, length(p)), 4.0);\n        float depth_of_field = 0.1+0.035*ffac;\n        float fov_length = 40.4-0.8*ffac;\n        float focus_distance = 0.45;\n        vec3 lens_pos = ro + (lens_sample.x*uu + lens_sample.y*vv) * depth_of_field;\n        vec3 vr = normalize(ro+(p.x*uu + p.y*vv + fov_length*ww) * focus_distance-lens_pos);\n\n        // render/sample the scene\n        // offset the origin with a magic number (a \"near plane\")\n        // the result is clamped a bit to make it visually more pleasant\n        col = min(render(lens_pos+17.3*vr, vr), 15.0);\n    //}\n    \n    //col /= float(samples);\n    vec4 fc = texture(iChannel0, uv);\n    fragColor.rgb = col+fc.rgb;\n    if(iFrame > 0)\n    \tfragColor.w = fc.w;\n}","name":"Buffer B","description":"","type":"buffer"}]}