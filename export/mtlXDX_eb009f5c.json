{"ver":"0.1","info":{"id":"mtlXDX","date":"1675443182","viewed":101,"name":"Rule 30 with scroll","username":"PauloFalcao","description":"A simple elementary cellular automaton (rule 30) to finally try out the buffers.\n[url]http://mathworld.wolfram.com/ElementaryCellularAutomaton.html[/url]\n[url]http://mathworld.wolfram.com/Rule30.html[/url]","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["elementarycellularautomaton","rule30"],"hasliked":0,"parentid":"MtBfRt","parentname":"Rule 30"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(texelFetch( iChannel0, ivec2(fragCoord), 0 ).xxx, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Rule 30 elementary cellular automaton, 2018 by JT.\n// http://mathworld.wolfram.com/ElementaryCellularAutomaton.html\n// http://mathworld.wolfram.com/Rule30.html\n// https://en.wikipedia.org/wiki/Rule_30\n// https://en.wikipedia.org/wiki/Patterns_in_nature\nint Cell(ivec2 p)\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p.x = (p.x + r.x) % r.x;\n    //if(p.x < 0 || p.x >= r.x)\n    //    return 1;\n    if(p.y >= r.y && p.x * 2 == r.x)\n        return 0;\n    if(p.y < 0 || p.y >= r.y)\n        return 1;\n    \n    // Paulo Falcao added scroll\n    // (original) return (texelFetch(iChannel0, p, 0 ).x > 0.5) ? 1 : 0;\n    return (texelFetch(iChannel0, p+((iFrame<r.y)?ivec2(0,0):ivec2(0,-1)), 0 ).x > 0.5) ? 1 : 0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 p = ivec2(fragCoord);\n\n\tint l = Cell(p + ivec2(-1, +1));\n    int m = Cell(p + ivec2( 0, +1));\n    int r = Cell(p + ivec2(+1, +1));\n    int c = l * 4 + m * 2 + r * 1;\n\n    float f = (c >= 3 && c < 7) ? 0.0 : 1.0;\n\n    if(iFrame == 0)\n        f = 0.0;\n\t\n\tfragColor = vec4(f);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}