{"ver":"0.1","info":{"id":"Wls3DB","date":"1557573924","viewed":756,"name":"Metallic liquid dive","username":"ciphered","description":"First time I ever use the raytracing algorithm. Could not find a way to optimise this, everytime I try to optimise it the quality gets too low to be sufficient :(","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raytracingfractalmetallicalien"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Basic raytracing algorithm \n */\n\n#define NEAR 0.001\n#define FAR 40.0\n#define FOG 0.00005\n#define FOV 0.5\n#define RT_ITERATIONS 128\n#define TARGET vec3(0.0)\n#define PI 3.14159265359\n\n\n\nfloat glow = 0.0, ttpi;\n\nvec3 cw, cu, cv, rd;\nvec4 np;\n\nvec2 e = vec2(0.00035, -0.00035);\n\n// useful functions\nmat2 r2 (float r) { return mat2(cos(r), sin(r), -cos(r), cos(r)); }\nfloat noise (vec3 p) {\n\tvec3 ip = floor(p),\n         s = vec3(7.0, 157.0, 113.0);\n    p-= ip;\n    vec4 h = vec4(0.0, s.yz, s.y+s.z) + dot(ip, s);\n    h = mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n// primitives\nfloat bo (vec3 p, vec3 r) { p = abs(p)-r; return max(max(p.x, p.y), p.z); } // box\nfloat ca (vec3 p, float h, float r) { p.y-= clamp(p.y, 0.0, h); return length(p)-r; } // capsule\n\n\n/**\n * this function generates a scene, distance based\n */\nvec2 fb (in vec3 p) {\n    vec2 h, t = vec2(ca(p+vec3(0.0,2.0,0.0), 4.0, 1.0), 5.0);\n    t.x = min(bo(abs(p)-vec3(4.8,4.8,4.8), vec3(1.2, 1.2, 1.2)), t.x);\n    \n    h = vec2(ca(p, 10.0, 0.2), 3.0);\n    \n    t = t.x < h.x ? t : h;\n    \n    glow+= 0.1 / (0.1+t.x*t.x*100.0);\n    \n    t.x*= 0.1;\n    \n    return t;\n}\n\n\n/**\n * MAPPING FUNCTION\n */\nvec2 mp (vec3 p) {\n    p.z = mod(p.z+iTime*12.0, 20.0)-8.0;\n    \n    \n    np = vec4(p, 1.0);\n    \n    float s = sin(p.z*0.1+ttpi*2.0-5.0)*0.1;\n    \n    for (float i = 0.0; i < 6.0; i++) {\n    \tnp = abs(np) - vec4(4.0, 0.0, max(4.0*s, 2.2), 0.0);\n        np.xy*= r2(0.4+s);\n        np.zy*= r2(0.1+s*abs(cos(iTime/6.0)));\n        np.xz*= r2(0.4*s*cos(iTime/10.0));\n    }\n    \n    vec2 h, t = fb(np.xyz);\n    return t;\n}\n\n\n/**\n * RAY TRACING METHOD \n */\nvec2 tr (in vec3 ro, in vec3 rd) {\n    vec2 h, t = vec2(0.1);\n    for (int i = 0; i < RT_ITERATIONS; i++) {\n        h = mp(ro+rd*t.x);\n        if (h.x < NEAR || t.x > FAR) break;\n        t.x+= h.x;\n        t.y = h.y;\n    }\n    if (t.x > FAR) t.x = 0.0;\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-= 0.5;\n    uv/= vec2(iResolution.y/iResolution.x, 1.0);\n    uv.x/= 2.6; // looks better if upscaled on x\n    \n    // a bit naive but enough\n    float bassLevel = (texture(iChannel0, vec2(0.0, 0.0)).r+texture(iChannel0, vec2(0.2, 0.0)).r)/2.0;\n    \n    // time \n    float tt = mod(iTime, 100.0),\n          bb = 0.5 + clamp(sin(tt), -0.5, 0.5);\n    \n    // background\n    vec3 col, fo, ld = normalize(vec3(0.1,0.5,-0.5));\n    col = fo = vec3(0.4)*cos(iTime/8.0) + vec3(0.1) * (1.0 - length(uv)*1.5 - 0.1);\n    \n    // camera \n    ttpi = mod(tt, 2.0*PI);\n    ttpi = ttpi > PI ? 2.0*PI-ttpi : ttpi;\n    //vec3 ro = vec3(cos(ttpi)*15.0, 0.0, sin(ttpi)*16.0);\n    vec3 ro = vec3(0.0,0.0,-10.0);\n    cw = normalize(TARGET-ro);\n    cu = normalize(cross(cw, vec3(0.0, 1.0, 0.0)));\n    cv = normalize(cross(cu, cw));\n    rd = mat3(cu, cv, cw) * normalize(vec3(uv, FOV));\n    \n    // raytracer algorithm is called\n    vec2 sc = tr(ro, rd);\n    \n    // distance camera / object\n    float d = sc.x;\n    \n    // if d > 0, we compute the color of the pixel based on the scene \n    if (d > 0.0) {\n   \t\tvec3 po = ro + rd*d,\n             no = normalize(e.xyy*mp(po+e.xyy).x + e.yyx*mp(po+e.yyx).x + e.yxy*mp(po+e.yxy).x + e.xxx*mp(po+e.xxx).x),\n             al = mix(vec3(1.0, 1.0,1.0), vec3(1.0, 0.0, 0.32),abs(cos(iTime/5.0)));\n        \n        if (sc.y < 5.0) {\n            al = mix(vec3(1.0, 1.0,1.0), vec3(1.0, 0.0, 0.8),abs(cos(iTime/5.0)));\n        }\n        \n        // lighting\n        \n        float dif = max(0.0, dot(no, ld)),\n              aor = d / 50.0,\n              fr = pow(1.0+dot(no, rd), 4.0);\n        \n        vec3 sss = vec3(1.5) * smoothstep(0.0, 1.0, mp(po+ld*0.4).x/0.4);\n            \n        \n        col = mix(al*0.2+al*(dif+sss), fo, min(fr, 0.5));\n        col = mix(col, fo, 1.0 - exp(-FOG*d*d*d));\n    }\n    \n    // we add the glow\n    //bassLevel*= bassLevel;\n    col+= vec3(0.0,.9,.3)*glow*0.05*bassLevel;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}