{"ver":"0.1","info":{"id":"XscBzn","date":"1523894026","viewed":447,"name":"Worley fractal Brownian motion","username":"chronos","description":"Simple fBm based on animated Worley noise.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["fractal","worley","brownian","motion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define NUM_OCTAVES 6\n#define FBM_NOISE_FUNCTION worley2\n\n\nfloat rnd(vec2 u) { return fract(3e5 * sin(dot(u, vec2(1, 78)))); }\n\nvec2 rnd2( vec2 p ) {\n    vec2 q = vec2( dot(p,vec2(127.1,311.7)),\n                   dot(p,vec2(269.5,183.3)));\n    return fract(sin(q)*43758.5453);\n}\n\nfloat valueNoise(vec2 u)\n{\n\tvec2 i = floor(u), f = u-i,\n    X = vec2(rnd(i), rnd(i+vec2(1, 0))),\n    Y = vec2(rnd(i + vec2(0, 1)), rnd(i + 1.));\n    f *= f*(3. - 2.*f);\n    u = mix(X, Y, f.y);\n    return mix(u.x, u.y, f.x);\n}\n\nvec2 valueNoise2(vec2 u) {\n\tvec2 i = floor(u), f = u-i,\n    X = vec2(rnd(i), rnd(i+vec2(1, 0))),\n    Y = vec2(rnd(i + vec2(0, 1)), rnd(i + 1.));\n    f *= f*(3. - 2.*f);\n    u = mix(X, Y, f.y);\n    return u;\n}\n\n// input, rotation angle, scaling, translation\nvec2 rigidTransform(vec2 p, float theta, float scale, vec2 t) {\n    float c = cos(theta), s = sin(theta);\n    return scale * (mat2(c, s, -s, c) * p) + t;\n}\n\nvec2 spin(vec2 u) { return .5 + .5 * sin(iTime + 6.2831*u); }\n\n#define WORLEY_ANIMATION spin\nfloat worley(vec2 u) {\n    float d = 1e3, a;\n    vec2 k =  floor(u), f = u-k, p, q = k + vec2(0, 0);\n    for(int i = -1; i < 2; i++) {\n        for(int j = -1; j < 2; j++) {\n            p = WORLEY_ANIMATION(valueNoise2(k+vec2(i, j)));\n            a = distance(f, vec2(i, j) + p);\n            if(a < d) {\n            \td = a;\n                q = p;\n            }\n    } }\n    return dot(q, vec2(.3,.6));\n}\n\nfloat worley2(vec2 u) {\n    float d = 1e4, a;\n    float acc = 0., acc_w = 0.;\n    vec2 k =  floor(u), f = u-k, p, q = k + vec2(0, 0);\n    for(int i = -3; i < 3; i++) {\n        for(int j = -3; j < 3; j++) {\n            vec2 p_i = vec2(i, j);\n            vec2 p_f = WORLEY_ANIMATION(rnd2(k+p_i));\n            float d = length(p_i - f + p_f);\n            float w = exp(-8. * d);\n            acc += w * d;\n            acc_w += w;\n    } }\n    return acc / acc_w;\n}\n\nfloat worley3(vec2 u) {\n    float d = 1e4, a;\n    float acc = 0., acc_w = 0.;\n    vec2 k =  floor(u), f = u-k, p, q = k + vec2(0, 0);\n    const int r = 3;\n    for(int i = -r; i < r; i++) {\n        for(int j = -r; j < r; j++) {\n            vec2 p_i = vec2(i, j);\n            vec2 p_f = WORLEY_ANIMATION(rnd2(k+p_i));\n            float d = length(p_i - f + p_f);\n            float w = exp(-8. * d) * (1.-step(sqrt(float(r*r)),d));\n            acc += w * valueNoise(k+p_i);\n            acc_w += w;\n    } }\n    return acc / acc_w;\n}\n\nfloat fbm(vec2 u) {\n    float v = 0.;\n    for(int i = 0; i < NUM_OCTAVES; i++) {\n        v += pow(.5, float(i+1)) * FBM_NOISE_FUNCTION(u);\n        u = rigidTransform(u, .5, 2., vec2(1e3));\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n\tvec2 p = uv * 3.;\n    vec3 col = vec3(0.);\n    float f = fbm( p );\n    //f = fbm( p + f);\n    //f = fbm( p + f);\n\t\n    col += f;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}