{"ver":"0.1","info":{"id":"M3SfRm","date":"1729283316","viewed":160,"name":"Frankenshader","username":"darrinm","description":"I used Claude Sonnet 3.5 to combine two shaders:\n\nmrange's [url=https://www.shadertoy.com/view/ctBSRR] Colorful interference pattern[/url]\nFlexi's [url=https://www.shadertoy.com/view/4df3zH] half sphere lens distortion[/url]","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["hatch","ai","mrange"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I used Claude Sonnet 3.5 to combine mrange's https://www.shadertoy.com/view/ctBSRR with Flexi's https://www.shadertoy.com/view/4df3zH.\n// Full experience on Hatch: https://darrin.hatch.one/frankenshader\n\n/* Uniforms for https://hatch.one\n\nuniform float speed; // default: 0.3, min: 0.0, max: 2.0, step: 0.01, title: \"animation speed\"\nuniform float colorIntensity; // default: 8.0, min: 1.0, max: 20.0, step: 0.1, title: \"color intensity\"\nuniform float lensRadius; // default: 0.166, min: 0.01, max: 0.5, step: 0.01, title: \"lens radius\"\nuniform float lensRefractivity; // default: 1.575, min: 1.0, max: 2.5, step: 0.01, title: \"lens refractivity\"\n*/\n\n#define speed 0.3\n#define colorIntensity 8.0\n#define lensRadius 0.3\n#define lensRefractivity 2.5\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define pi 3.141592653589793238462643383279\n\nfloat df(vec2 p) {\n  const float m = 0.25;\n  float l = length(p);\n  l = mod(l+(0.5*m), m)-(0.5*m);\n  return abs(l)-(m*0.25);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: MÃ¥rten RÃ¥nge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  float aa = 2.0/RESOLUTION.y;\n  float tm = TIME*speed;\n  vec2 p0 = p+sin(vec2(1.0, sqrt(0.5))*(tm+100.0));\n  vec2 p1 = p+sin(1.2*vec2(1.0, sqrt(0.5))*(tm+200.0));\n  float sm = 0.0666*length(p);\n  float d0 = df(p0);\n  float d1 = df(p1);\n  float d = d0;\n  d = pmax(d, d1, sm);\n  float dd = -d0;\n  dd = pmax(dd, -d1, sm);\n  d =  min(d, dd);\n  const float co = 0.5;\n  vec3 bcol0 = (1.0+sin(vec3(0.0, 1.0, 2.0) + co*length(p0)+1.0-TIME))/(colorIntensity*dot(p0, p0)+0.0001);\n  vec3 bcol1 = (1.0+sin(vec3(0.0, 1.0, 2.0) + co*length(p1)+3.0+TIME))/(colorIntensity*dot(p1, p1)+0.0001);\n  vec3 bcol = (bcol0+bcol1);\n  vec3 col = vec3(0.0);\n  col += 0.005*bcol/(max(dd+0.005, 0.0)+0.0001);\n  col = mix(col, bcol, smoothstep(aa, -aa, d));\n  col -= 0.25*vec3(0.0, 1.0, 2.0).zyx*length(pp);\n  col *= smoothstep(1.5, 0.5, length(pp));\n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n  return col;\n}\n\nfloat atan2(float y, float x){\n    if(x>0.) return atan(y/x);\n    if(y>=0. && x<0.) return atan(y/x) + pi; \n    if(y<0. && x<0.) return atan(y/x) - pi; \n    if(y>0. && x==0.) return pi/2.;\n    if(y<0. && x==0.) return -pi/2.;\n    if(y==0. && x==0.) return pi/2.; // undefined usually\n    return pi/2.;\n}\n\nvec2 uv_polar(vec2 uv, vec2 center){\n    vec2 c = uv - center;\n    float rad = length(c);\n    float ang = atan2(c.x,c.y);\n    return vec2(ang, rad);\n}\n\nvec2 uv_lens_half_sphere(vec2 uv, vec2 position, float radius, float refractivity){\n    vec2 polar = uv_polar(uv, position);\n    float cone = clamp(1.-polar.y/radius, 0., 1.);\n    float halfsphere = sqrt(1.-pow(cone-1.,2.));\n    float w = atan2(1.-cone, halfsphere);\n    float refrac_w = w-asin(sin(w)/refractivity);\n    float refrac_d = 1.-cone - sin(refrac_w)*halfsphere/cos(refrac_w);\n    vec2 refrac_uv = position + vec2(sin(polar.x),cos(polar.x))*refrac_d*radius;\n    return mix(uv, refrac_uv, float(length(uv-position)<radius));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 aspect = vec2(1., iResolution.y/iResolution.x);\n    vec2 uv_correct = 0.5 + (uv - 0.5) * aspect;\n\n\n    vec2 mouse_correct = 0.5 + (iMouse.xy / iResolution.xy - 0.5) * aspect;\n    if (iMouse.x == 0. && iMouse.y == 0.) {\n        mouse_correct = vec2(0.5, 0.5);\n    }\n    vec2 pos = mouse_correct;\n\n    vec2 uv_lens_distorted = uv_lens_half_sphere(uv_correct, pos, lensRadius, lensRefractivity);\n    uv_lens_distorted = 0.5 + (uv_lens_distorted - 0.5) / aspect;\n\n    vec2 p = -1. + 2. * uv_lens_distorted;\n    vec2 pp = p;\n    p.x *= RESOLUTION.x/RESOLUTION.y;\n    \n    vec3 col = effect(p, pp);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}