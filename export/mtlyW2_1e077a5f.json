{"ver":"0.1","info":{"id":"mtlyW2","date":"1691225756","viewed":349,"name":"Commented Reflection Denoiser","username":"Mathis","description":"A commented reflection wavelet denoiser\n\nPress 1,2,3,4 to look at the denoising process.","likes":38,"published":1,"flags":48,"usePreview":0,"tags":["reflections","glossy","wavelet","denoising"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n//\n//READ ME!\n//\n\n\n\n\nImportant:\n    Simplifications are made to make the code more readable\n        There is no per material roughness\n            Only one cone ratio is used: ReflectionCR defined in the Common tab\n        Constant reflection cone ratio\n            This means that cone at grazing angles will have parts of it outside of the pixel hemisphere\n            resulting in flattening of the reflection\n                In my other shaders this is fixed by clamping the cone angle to the floor angle\n                A better fix is to use the reflective GGX lobe\n    Curved surfaces\n        The truth is disappointing: I use reprojection on the surface and use\n        spatial color clamping to enable temporal accumulation of reflections on curved surfaces\n            This means that the reflections hitpoint is not reprojected between frames\n\n\n\n\nControls:\n    Use the mouse to rotate the camera\n    Press 1-4 to change visualisation mode\n        1: Raw reflections only\n        2: Projected cone radius (as percentage of the horisontal viewport resolution)\n        3: Only reflections denoised with one denoising pass\n        4: Composition\n*/\n\nvec4 textureCube(vec2 UV) {\n    //Samples the cubemap\n    float Sign = -mod(floor(UV.y*I1024),2.)*2.+1.;\n    vec3 D = vec3(vec2(UV.x,mod(UV.y,1024.))*I512-1.,Sign);\n    if (UV.y>4096.) D = D.xzy;\n    else if (UV.y>2048.) D = D.zxy;\n    return texture(iChannel3,D);\n}\n\nvec3 acesFilm(vec3 x) {\n    //Aces film curve\n    return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14),0.,1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 Color = vec3(0.3,0.,0.);\n    //Visualisation index\n    float VisIndex = texture(iChannel0,0.5*IRES).x;\n    if (VisIndex<1.5) {\n        //Raw reflections only\n        Color = texture(iChannel1,fragCoord*IRES).xyz;\n    } else if (VisIndex<2.5) {\n        //Projected cone radius (as percentage of the horisontal viewport resolution)\n        vec3 Eye = GetEye(iMouse,IRES);\n        vec3 Pos = GetPosition(Eye);\n        vec3 Tan; vec3 Bit = TBN(Eye,Tan); //Basis vectors where \"Eye\" is the z direction\n        mat3 EyeMat = TBN(Eye); //Transform matrix from view space to world space\n        vec3 Dir = normalize(vec3(((fragCoord*IRES)*2.-1.)*(ASPECT*CFOV),1.)*TBN(Eye));\n        vec4 CAttr = texture(iChannel0,fragCoord*IRES); //Sample the G-Buffer\n        vec3 Normal = CAttr.xyz; //Pixel normal\n        vec3 PPos = Pos+Dir*CAttr.w; //Pixel position\n        //Output\n        if (CAttr.w>-0.5) {\n            //Geometry hit\n            //Compute the projected cone radius\n                /*\n                Important note:\n                    The base of the cone tends to be elliptic at the corners of the screen\n                    I place two points at the horisontal part of the base in relation to the camera\n                        So if the pixel direction is e_z, then its horisontal tangent is e_x and the\n                        points are placed one radius away in the x direction\n                Virtual positions\n                    The cone continues through the geometry in the \"Dir\" direction\n                        All reflection hitpoints exists in a virtual world beyond the geometry\n                    Positions in this virtual world are calculated as \"Pos+Dir*(PrimaryDistance+ReflectionDistance)\"\n                    The radius of the base is \"ReflectionCR*ReflectionDistance\", since the cone\n                        begins at the geometry hit point\n\n                Note how Tan is used to place \"ConePos1\" and \"ConePos2\" in the tangential direction\n                */\n            vec4 RefDist = texture(iChannel1,fragCoord*IRES); //vec4(ReflectionLight,ReflectionDistance)\n            vec3 DirTan; vec3 DirBit = TBN(Dir,DirTan); //Basis vectors where \"Dir\" is the z direction\n            vec3 ConePos1 = Dir*(CAttr.w+RefDist.w)+DirTan*(RefDist.w*ReflectionCR); //First position\n            vec3 ConePos2 = Dir*(CAttr.w+RefDist.w)-DirTan*(RefDist.w*ReflectionCR); //Second position\n            //Reproject ConePos1 and ConePos2 on their horisonal viewport coordinates\n            vec3 VPos1 = vec3(dot(ConePos1,Tan),dot(ConePos1,Bit),dot(ConePos1,Eye)); //Transform to view space\n            vec3 VPos2 = vec3(dot(ConePos2,Tan),dot(ConePos2,Bit),dot(ConePos2,Eye));\n            vec2 ConeUV1 = ((VPos1.xy/VPos1.z)*0.5/(ASPECT*CFOV)+0.5)*RES; //Reprojection on the screen\n            vec2 ConeUV2 = ((VPos2.xy/VPos2.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n            //Use the horisonal coordinates to compute the radius\n            float ConeRadius = length(ConeUV1-ConeUV2)*0.5;\n            Color = vec3(ConeRadius*IRES.x);\n        } else Color = SampleSky(Dir);\n    } else if (VisIndex<3.5) {\n        //Only reflections denoised with one denoising pass\n        Color = texture(iChannel2,fragCoord*IRES).xyz;\n    } else {\n        //Composition\n        float YOffset = floor(fragCoord.x*I1024)*1024.+floor(fragCoord.y*I1024)*3072.;\n        Color = textureCube(mod(fragCoord,1024.)+vec2(0.,YOffset)).xyz;\n    }\n    //Output\n    fragColor = vec4(pow(acesFilm(max(vec3(0.),Color)),vec3(0.45)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Settings\nconst float FOV = radians(60.);\nconst vec3 SkyLight = vec3(0.6,0.8,1.);\nconst vec3 SunLight = vec3(1.,0.5,0.25)*5.;\nconst vec3 SunDir = normalize(vec3(0.4,0.7,-0.7));\nconst float ReflectionCR = 0.2; //Reflections cone ratio\n\n//Other vars\nconst float CFOV = tan(FOV*0.5);\nconst float PI = 3.141592653;\nconst float HPI = PI*0.5;\nconst float IPI = 1./PI;\nconst float PI2 = PI*2.;\nconst float IPI2 = 0.5/PI;\nconst float ToRadians = PI/180.;\nconst float I3 = 1./3.;\nconst float I16 = 1./16.;\nconst float I32 = 1./32.;\nconst float I64 = 1./64.;\nconst float I128 = 1./128.;\nconst float I256 = 1./256.;\nconst float I300 = 1./300.;\nconst float I512 = 1./512.;\nconst float I1024 = 1./1024.;\nconst float I2048 = 1./2048.;\nconst vec2 eps = vec2(0.005,0.);\n//RES\n#define RES iChannelResolution[0].xy\n#define IRES (1./iChannelResolution[0].xy)\n#define ASPECT vec2(RES.x/RES.y,1.)\n\nconst vec2 SSOffsets[16] = vec2[16](vec2(0.),vec2(-0.4,-0.4),vec2(0.,0.2),vec2(0.15,-0.4),vec2(-0.4,-0.15),\n                                    vec2(0.15,0.4),vec2(-0.2,-0.2),vec2(-0.4,0.4),vec2(0.4,0.15),vec2(0.2,-0.2),\n                                    vec2(0.4,0.4),vec2(-0.4,0.15),vec2(0.4,-0.15),\n                                    vec2(-0.15,0.4),vec2(0.4,-0.4),vec2(-0.15,-0.4));\n\nstruct HIT { float D; vec3 N; vec3 E; };\n\n//SKY\nvec3 SampleSky(vec3 d) {\n    //return SkyLight*(1.-0.5*d.y)*(d.y*0.5+0.5);\n    return vec3(0.2,0.4,1.);\n    return mix(SkyLight*(1.-0.5*d.y)*(d.y*0.5+0.5),vec3(0.2,0.4,1.),d.z*0.5+0.5);\n}\n\n//SDF\nfloat DFBox(vec3 p, vec3 b) {\n    vec3 d = abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat DFBoxC(vec3 p, vec3 b) {\n    vec3 d = abs(p)-b;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat DFBox(vec2 p, vec2 b) {\n    vec2 d = abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat DFBoxC(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat DFDisk(vec3 p) {\n    float d = length(p.xz-0.5)-0.35;\n    vec2 w = vec2(d,abs(p.y));\n    return min(max(w.x,w.y),0.)+length(max(w,0.));\n}\n\nfloat DFLine(vec3 p, vec3 a, vec3 b) {\n    vec3 ba = b-a;\n    float k = dot(p-a,ba)/dot(ba,ba);\n    return length((a+clamp(k,0.,1.)*(b-a))-p);\n}\n\nfloat DFCylinder(vec3 p, float r, float h) {\n    vec2 d = vec2(length(p.xz)-r,abs(p.y)-h);\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\n\nfloat DFPlane(vec3 p, vec3 p0, vec3 p1, vec3 p2) {\n    //Intersects a plane\n    vec3 Normal = normalize(cross(p1-p0,p2-p0));\n    vec3 tp = vec3(dot(p-p0,normalize(p1-p0)),dot(p-p0,normalize(p2-p0)),dot(p-p0,Normal));\n    return DFBox(tp-vec3(0.,0.,-0.005),vec3(length(p1-p0),length(p2-p0),0.01));\n}\n\nvec2 Rotate(vec2 p, float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c-p.y*s,p.x*s+p.y*c);\n}\n\nvec2 Repeat(vec2 p, float n) {\n    float ang = 2.*3.14159/n;\n    float sector = floor(atan(p.x,p.y)/ang+0.5);\n    p = Rotate(p,sector*ang);\n    return p;\n}\n\nfloat smin(float a, float b, float k) {\n    //https://iquilezles.org/articles/smin\n    float h = max(k-abs(a-b),0.)/k;\n    return min(a,b)-h*h*h*k*(1.0/6.0);\n}\n\nmat3 TBN(vec3 N) {\n    vec3 Nb,Nt;\n    if (abs(N.y)>0.999) {\n        Nb=vec3(1.,0.,0.);\n        Nt=vec3(0.,0.,1.);\n    } else {\n        Nb=normalize(cross(N,vec3(0.,1.,0.)));\n        Nt=normalize(cross(Nb,N));\n    }\n    return mat3(Nb.x,Nt.x,N.x,Nb.y,Nt.y,N.y,Nb.z,Nt.z,N.z);\n}\n\nvec3 TBN(vec3 N, out vec3 O) {\n    O = ((abs(N.y)<=0.999)?normalize(cross(N,vec3(0.,1.,0.))):vec3(1.,0.,0.));\n    return normalize(cross(O,N));\n}\n\nvec3 RandSample(vec2 v) {\n    float r=sqrt(1.-v.x*v.x);\n    float phi=2.*3.14159*v.y;\n    return vec3(cos(phi)*r,sin(phi)*r,v.x);\n}\n\nvec3 RandSampleCos(vec2 v) {\n    float theta=sqrt(v.x);\n    float phi=2.*3.14159*v.y;\n    float x=theta*cos(phi);\n    float z=theta*sin(phi);\n    return vec3(x,z,sqrt(max(0.,1.-v.x)));\n}\n\nvec3 SchlickFresnel(vec3 r0, float angle) {\n    //Schlick Fresnel approximation\n    return r0+(1.-r0)*pow(1.-angle,5.);\n}\n\nvec3 ARand23(vec2 uv) {\n    //Analytic random\n    return fract(sin(uv.x*uv.y)*vec3(403.125,486.125,513.432)+cos(dot(uv,vec2(13.18273,51.2134)))*vec3(173.137,261.23,203.127));\n}\n\nfloat ARand21(vec2 uv) {\n    //Analytic random\n    return fract(sin(uv.x*uv.y)*403.125+cos(dot(uv,vec2(13.18273,51.2134)))*173.137);\n}\n\nvec2 ABox(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t1 = min(tMin,tMax);\n    vec3 t2 = max(tMin,tMax);\n    return vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));\n}\n\nvec2 ABoxfarNormal(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax) {\n    vec2 tMin=(bmin-origin)*dir;\n    vec2 tMax=(bmax-origin)*dir;\n    vec2 t2=max(tMin,tMax);\n    vec2 signdir = -(max(vec2(0.),sign(dir))*2.-1.);\n    if (t2.x<t2.y) return vec2(signdir.x,0.);\n    else return vec2(0.,signdir.y);\n}\n\nvec2 ABoxNormal(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax, out vec3 N) {\n    vec3 tMin=(bmin-origin)*dir;\n    vec3 tMax=(bmax-origin)*dir;\n    vec3 t1=min(tMin,tMax);\n    vec3 t2=max(tMin,tMax);\n    vec3 signdir = -(max(vec3(0.),sign(dir))*2.-1.);\n    if (t1.x>max(t1.y,t1.z)) N = vec3(signdir.x,0.,0.);\n    else if (t1.y>t1.z) N = vec3(0.,signdir.y,0.);\n    else N = vec3(0.,0.,signdir.z);\n    return vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));\n}\n\n//Camera\nvec3 GetEye(vec4 m, vec2 ires) {\n    if (m.z>0.) {\n        //Mouse click\n        vec2 a = m.xy*ires*vec2(1.55,-1.6)+vec2(3.14159,0.2);\n        return vec3(sin(a.x)*cos(a.y),sin(a.y),cos(a.x)*cos(a.y));\n    } else {\n        //Standard view\n        return normalize(vec3(-1.,-1.,-1.));\n    }\n}\n\nvec3 GetPosition(vec3 eye) {\n    return vec3(0.5,0.25,0.5)-eye*1.5;\n}\n\n//Tracing\nvec4 MIN(vec4 a, vec4 b) {\n    return ((a.w<b.w)?a:b);\n}\n\nvec4 SampleSDF(vec3 sp, float Time) {\n    //Samples the volume SDF: vec4(Emissive,Distance)\n    vec4 d = vec4(0.);\n    //d.w = max(DFBox(sp-vec3(0.,-0.1,0.),vec3(1.,1.2,1.)),-DFBox(sp-vec3(0.05,0.,0.05),vec3(10.,1.,10.)));\n    d.w = max(DFBox(sp-vec3(0.,-0.1,0.),vec3(10.,10.2,1.)),-DFBox(sp-vec3(0.05,0.,0.05),vec3(20.)));\n\n    //Walls\n    d.w = max(d.w,-DFBox(sp-vec3(0.05,0.3,-5.),vec3(0.9,0.17,10.)));\n    d.w = max(d.w,-DFBox(sp-vec3(0.05,0.7,-5.),vec3(0.9,0.17,10.)));\n\n    //Interior\n    d.w = min(d.w,DFBox(sp-vec3(0.2,0.,0.2),vec3(0.2,0.3,0.2)));\n    d.w = min(d.w,length(sp-vec3(0.3,0.4,0.3))-0.1);\n\n    //Emissive\n    //vec3 rp = sp-vec3(0.05,0.5,0.5); rp.zy = Rotate(rp.zy,Time);\n    //d = MIN(d,vec4(vec3(1.,0.15,0.05)*5.,DFBox(rp-vec3(0.,-0.075,-0.3),vec3(0.05,0.15,0.6))));\n    vec3 rp = sp-vec3(1.3,0.5,0.05); rp.xy = Rotate(rp.xy,Time);\n    d = MIN(d,vec4(vec3(1.,0.15,0.05)*4.,DFBox(rp-vec3(-0.3,-0.075,0.),vec3(0.6,0.15,0.05))));\n    rp = sp-vec3(0.05,0.08,0.65); rp.zy = Rotate(rp.zy,0.3);\n    d = MIN(d,vec4(vec3(0.1,0.7,1.)*3.,DFBox(rp,vec3(0.05,0.15,0.15))));\n    rp = sp-vec3(0.05,0.5,0.5); rp.zy = Rotate(rp.zy,Time*0.75);\n    d = MIN(d,vec4(vec3(0.1,0.7,1.)*3.5,DFBox(rp-vec3(0.,-0.075,-0.3),vec3(0.05,0.15,0.6))));\n\n    //Return\n    return d;\n}\n\nHIT Trace(vec3 P, vec3 D, float Time) {\n    //Traces a ray through the SDF\n    HIT OUT = HIT(100000.,vec3(0.),vec3(-1.));\n    float FAR = 8.; //FAR value\n    float t = 0.; //Initial dist\n    vec4 dfs = vec4(10000.); //tmp value\n    for (int i=0; i<512; i++) {\n        vec3 sp = P+D*t;\n        dfs = SampleSDF(sp,Time);\n        t += dfs.w;\n        if (min(FAR-t,dfs.w-0.0005)<0.) break;\n    }\n    if (dfs.w<0.001) {\n        //We have an intersection\n        vec3 sp = P+D*t;\n        return HIT(t,normalize(vec3(SampleSDF(sp+eps.xyy,Time).w-SampleSDF(sp-eps.xyy,Time).w,\n                                    SampleSDF(sp+eps.yxy,Time).w-SampleSDF(sp-eps.yxy,Time).w,\n                                    SampleSDF(sp+eps.yyx,Time).w-SampleSDF(sp-eps.yyx,Time).w)),dfs.xyz);\n    }\n    //Return\n    return OUT;\n}\n\nvec3 ComputeDirectLight(vec3 P, vec3 N, float Time) {\n    //Computes the direct light at P\n        //I separate emissive and direct light\n    vec3 L = vec3(0.);\n    vec3 Emissive = SampleSDF(P,Time).xyz;\n    if (Emissive.x>0.) {\n        //Emissive surface\n        L = Emissive;\n    } else {\n        //Directional light\n        vec3 sp = P+N*0.001; //Sample position\n        if (dot(N,SunDir)>0.) {\n            //Positive contribution\n            L = SunLight*dot(N,SunDir)*float(Trace(sp,SunDir,Time).E.x<-0.5);\n        }\n        //Fake bounce light (because that is cool)\n        vec3 PToL = vec3(0.2,0.,0.8)-P;\n        L += max(0.,-PToL.y)*max(0.,dot(PToL,N))*SunLight/(0.001+16.*dot(PToL,PToL))*0.5;\n        PToL = vec3(0.6,0.,0.4)-P;\n        L += max(0.,-PToL.y)*max(0.,dot(PToL,N))*SunLight/(0.001+16.*dot(PToL,PToL))*0.5;\n    }\n    return L;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//0-4 index and G-Buffer\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = texture(iChannel0,fragCoord*IRES);\n    if (fragCoord.y<1.) {\n        //Visualisation storage\n        if (fragCoord.x<1.) {\n            if (texelFetch(iChannel1,ivec2(49,0),0).x>0.) Output.x = 1.;\n            else if (texelFetch(iChannel1,ivec2(50,0),0).x>0.) Output.x = 2.;\n            else if (texelFetch(iChannel1,ivec2(51,0),0).x>0.) Output.x = 3.;\n            else if (texelFetch(iChannel1,ivec2(52,0),0).x>0.) Output.x = 4.;\n            if (iFrame<2) Output.x = 4.;\n        } else if (fragCoord.x<2.) {\n            //Copy mouse last frame\n            Output = texture(iChannel0,vec2(2.5,0.5)*IRES);\n        }  else if (fragCoord.x<3.) {\n            //Copy mouse current frame\n            Output = iMouse;\n        }\n    } else if (fragCoord.y>1.) {\n        //G-Buffer\n        //Update visualisation index\n        float VisIndex = texture(iChannel0,0.5*IRES).x;\n        if (texelFetch(iChannel1,ivec2(49,0),0).x>0.) VisIndex = 1.;\n        else if (texelFetch(iChannel1,ivec2(50,0),0).x>0.) VisIndex = 2.;\n        else if (texelFetch(iChannel1,ivec2(51,0),0).x>0.) VisIndex = 3.;\n        else if (texelFetch(iChannel1,ivec2(52,0),0).x>0.) VisIndex = 4.;\n        if (iFrame<2) VisIndex = 4.;\n        //Camera\n        vec2 SSOffset = SSOffsets[iFrame%16]*float(VisIndex>3.5);\n        vec3 Eye = GetEye(iMouse,IRES);\n        vec3 Pos = GetPosition(Eye);\n        vec3 Dir = normalize(vec3((((fragCoord+SSOffset)*IRES)*2.-1.)*(ASPECT*CFOV),1.)*TBN(Eye));\n        HIT Hit = Trace(Pos,Dir,iTime);\n        //Output\n        if (Hit.E.x>-0.5) {\n            //Geometry hit\n            Output = vec4(Hit.N,Hit.D);\n        } else {\n            //No geometry hit\n            Output = vec4(0.,0.,0.,-1.);\n        }\n    }\n    fragColor = Output;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//3 first visualisations\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.);\n    float VisIndex = texture(iChannel0,0.5*IRES).x;\n    if (fragCoord.y>1.) {\n        vec2 SSOffset = SSOffsets[iFrame%16]*float(VisIndex>3.5);\n        vec3 Eye = GetEye(iMouse,IRES);\n        vec3 Pos = GetPosition(Eye);\n        vec3 Dir = normalize(vec3((((fragCoord+SSOffset)*IRES)*2.-1.)*(ASPECT*CFOV),1.)*TBN(Eye));\n        vec4 CAttr = texture(iChannel0,fragCoord*IRES); //Sample the G-Buffer\n        vec3 Normal = CAttr.xyz; //Pixel normal\n        vec3 PPos = Pos+Dir*CAttr.w; //Pixel position\n        //Output\n        if (CAttr.w>-0.5) {\n            //Geometry hit\n            vec2 Rand2 = ARand23(fragCoord*IRES*(1.+mod(float(iFrame)*6.63839,27.2734))).xy; //Random numbers for monte carlo\n            vec3 RefDir = reflect(Dir,Normal); //Reflections direction (or cone direction)\n            mat3 RefMat = TBN(RefDir); //Transform matrix from reflection space to world space\n            vec3 RandDir = normalize(RandSampleCos(Rand2)*RefMat*ReflectionCR+RefDir);\n            if (dot(RandDir,Normal)<0.) RandDir = reflect(RandDir,Normal);\n            //Trace reflection ray\n            HIT RefHit = Trace(PPos+Normal*0.01,RandDir,iTime);\n            if (RefHit.E.x>-0.5) {\n                //Geometry hit\n                    //We store the lighting at the reflection point and the distance to the hit point\n                Output = vec4(ComputeDirectLight(PPos+Normal*0.01+RandDir*RefHit.D,RefHit.N,iTime),RefHit.D);\n            } else {\n                //No geometry hit\n                    //Sky is assumed to be a large distance away\n                Output = vec4(SampleSky(RandDir),100000.);\n            }\n        } else {\n            //No geometry hit\n            Output = vec4(SampleSky(Dir),-1.);\n        }\n    }\n    fragColor = Output;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Show cone radius and first denoising pass\n/*\nBuffer A: vec4(Normal,Depth)\nBuffer B: vec4(ReflectionLight,ReflectionDistance)\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.);\n    float VisIndex = texture(iChannel0,0.5*IRES).x;\n    if (fragCoord.y>1.) {\n        vec2 SSOffset = SSOffsets[iFrame%16]*float(VisIndex>3.5);\n        vec3 Eye = GetEye(iMouse,IRES);\n        vec3 Pos = GetPosition(Eye);\n        vec3 Tan; vec3 Bit = TBN(Eye,Tan); //Basis vectors where \"Eye\" is the z direction\n        mat3 EyeMat = TBN(Eye); //Transform matrix from view space to world space\n        vec3 Dir = normalize(vec3((((fragCoord+SSOffset)*IRES)*2.-1.)*(ASPECT*CFOV),1.)*TBN(Eye));\n        vec4 CAttr = texture(iChannel0,fragCoord*IRES); //Sample the G-Buffer\n        vec3 Normal = CAttr.xyz; //Pixel normal\n        vec3 PPos = Pos+Dir*CAttr.w; //Pixel position\n        //Output\n        if (CAttr.w>-0.5) {\n            //Geometry hit\n            vec4 RefDist = texture(iChannel1,fragCoord*IRES); //vec4(ReflectionLight,ReflectionDistance)\n            vec3 DirTan; vec3 DirBit = TBN(Dir,DirTan); //Basis vectors where \"Dir\" is the z direction\n            vec3 ConePos1 = Dir*(CAttr.w+RefDist.w)+DirTan*(RefDist.w*ReflectionCR); //First position\n            vec3 ConePos2 = Dir*(CAttr.w+RefDist.w)-DirTan*(RefDist.w*ReflectionCR); //Second position\n            //Reproject ConePos1 and ConePos2 on their horisonal viewport coordinates\n            vec3 VPos1 = vec3(dot(ConePos1,Tan),dot(ConePos1,Bit),dot(ConePos1,Eye)); //Transform to view space\n            vec3 VPos2 = vec3(dot(ConePos2,Tan),dot(ConePos2,Bit),dot(ConePos2,Eye));\n            vec2 ConeUV1 = ((VPos1.xy/VPos1.z)*0.5/(ASPECT*CFOV)+0.5)*RES; //Reprojection on the screen\n            vec2 ConeUV2 = ((VPos2.xy/VPos2.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n            //Use the horisonal coordinates to compute the radius\n            float ConeRadius = length(ConeUV1-ConeUV2)*0.5;\n            //First denoising pass\n                /*\n                It is important that surrounding pixels generate reflection hitpoints that fall inside\n                the current pixels reflection cone\n                    Otherwise we will overblur the reflections as any other blur\n                Math:\n                    Inequality: \"sqrt(1./dot(normalize(HitP-PPos),RefDir)-1.)<=ReflectionCR\"\n                    This inequality comes from how the random directions are generated\n                    Assume that the part of \"RandDir\" existing in the tangent plane of \"RefDir\" has length\n                        \"ReflectionCR\" before normalizing\n                    Then we know that after normalization: RandDir.z = 1/1.+ReflectionCR^2)\n                        This implies that all valid direction will be larger that RandDir.z that fullfills this equation\n                */\n            vec3 RefDir = reflect(Dir,Normal);\n            float HalfRadius = min(32.,ConeRadius)*0.5; //Half the radius since we let the offsets go from [-2,2]: 2*0.5 = 1\n            vec4 RefC = vec4(RefDist.xyz*2.,2.);\n            for (float x=-2.; x<2.5; x+=1.) {\n                for (float y=-2.; y<2.5; y+=1.) {\n                    if (x==0. && y==0.) continue;\n                    vec2 Offset2 = normalize(vec2(x,y))*max(abs(x),abs(y))*HalfRadius; //UV offsets in a circle with max radius 2\n                    vec2 SUV = floor(fragCoord+Offset2)+0.5; //Sample UV coordinates\n                    vec4 SC = texture(iChannel0,SUV*IRES); //Sample G-Buffer\n                    vec3 SNormal = SC.xyz;\n                    vec3 SDir = normalize(vec3(((SUV+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat); //Sample UV direction\n                    if (SC.w<-0.5 || DFBox(SUV-vec2(0.,1.),RES-vec2(0.,1.))>0.) continue; //Sky sample or outside screen\n                    vec4 SRefShad = texture(iChannel1,SUV*IRES); //Reflection buffer\n                    vec2 SRand = ARand23(SUV*IRES*(1.+mod(float(iFrame)*6.63839,27.2734))).xy; //Random values\n                    vec3 SRefDir = reflect(SDir,SNormal);\n                    vec3 SRDir = normalize(RandSampleCos(SRand)*TBN(SRefDir)*ReflectionCR+SRefDir); //Generate random dir\n                    vec3 HitP = Pos+SDir*SC.w+SNormal*0.01+SRDir*SRefShad.w;\n                    if (dot(HitP-PPos,Normal)<=0.) continue; //Only hitpoints in the current hemisphere are valid\n                    if (sqrt(1./dot(normalize(HitP-PPos),RefDir)-1.)<=ReflectionCR)\n                        //This hitpoint generated by SUV is inside the reflection cone from the current hitpoint\n                        RefC += vec4(SRefShad.xyz,1.);\n                }\n            }\n            RefC.xyz /= RefC.w;\n            Output = vec4(RefC.xyz,RefDist.w);\n        } else {\n            //No geometry hit\n            Output = vec4(SampleSky(Dir),-1.);\n        }\n    }\n    fragColor = Output;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//2nd denoising pass\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.);\n    float VisIndex = texture(iChannel0,0.5*IRES).x;\n    if (fragCoord.y>1.) {\n        vec2 SSOffset = SSOffsets[iFrame%16]*float(VisIndex>3.5);\n        vec3 Eye = GetEye(iMouse,IRES);\n        vec3 Pos = GetPosition(Eye);\n        vec3 Tan; vec3 Bit = TBN(Eye,Tan); //Basis vectors where \"Eye\" is the z direction\n        mat3 EyeMat = TBN(Eye); //Transform matrix from view space to world space\n        vec3 Dir = normalize(vec3((((fragCoord+SSOffset)*IRES)*2.-1.)*(ASPECT*CFOV),1.)*TBN(Eye));\n        vec4 CAttr = texture(iChannel0,fragCoord*IRES); //Sample the G-Buffer\n        vec3 Normal = CAttr.xyz; //Pixel normal\n        vec3 PPos = Pos+Dir*CAttr.w; //Pixel position\n        //Output\n        if (CAttr.w>-0.5) {\n            //Geometry hit\n            vec4 RefDist = texture(iChannel1,fragCoord*IRES); //vec4(ReflectionLight,ReflectionDistance)\n            vec3 DirTan; vec3 DirBit = TBN(Dir,DirTan); //Basis vectors where \"Dir\" is the z direction\n            vec3 ConePos1 = Dir*(CAttr.w+RefDist.w)+DirTan*(RefDist.w*ReflectionCR); //First position\n            vec3 ConePos2 = Dir*(CAttr.w+RefDist.w)-DirTan*(RefDist.w*ReflectionCR); //Second position\n            //Reproject ConePos1 and ConePos2 on their horisonal viewport coordinates\n            vec3 VPos1 = vec3(dot(ConePos1,Tan),dot(ConePos1,Bit),dot(ConePos1,Eye)); //Transform to view space\n            vec3 VPos2 = vec3(dot(ConePos2,Tan),dot(ConePos2,Bit),dot(ConePos2,Eye));\n            vec2 ConeUV1 = ((VPos1.xy/VPos1.z)*0.5/(ASPECT*CFOV)+0.5)*RES; //Reprojection on the screen\n            vec2 ConeUV2 = ((VPos2.xy/VPos2.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n            //Use the horisonal coordinates to compute the radius\n            float ConeRadius = length(ConeUV1-ConeUV2)*0.5;\n            vec3 RefDir = reflect(Dir,Normal);\n            float HalfRadius = min(8.,ConeRadius)*0.5; //Half the radius since we let the offsets go from [-2,2]: 2*0.5 = 1\n            vec4 RefC = vec4(RefDist.xyz*2.,2.);\n            for (float x=-2.; x<2.5; x+=1.) {\n                for (float y=-2.; y<2.5; y+=1.) {\n                    if (x==0. && y==0.) continue;\n                    vec2 Offset2 = normalize(vec2(x,y))*max(abs(x),abs(y))*HalfRadius; //UV offsets in a circle with max radius 2\n                    vec2 SUV = floor(fragCoord+Offset2)+0.5; //Sample UV coordinates\n                    vec4 SC = texture(iChannel0,SUV*IRES); //Sample G-Buffer\n                    vec3 SNormal = SC.xyz;\n                    vec3 SDir = normalize(vec3(((SUV+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat); //Sample UV direction\n                    if (SC.w<-0.5 || DFBox(SUV-vec2(0.,1.),RES-vec2(0.,1.))>0.) continue; //Sky sample or outside screen\n                    vec4 SRefShad = texture(iChannel1,SUV*IRES); //Reflection buffer\n                    vec2 SRand = ARand23(SUV*IRES*(1.+mod(float(iFrame)*6.63839,27.2734))).xy;\n                    vec3 SRefDir = reflect(SDir,SNormal);\n                    vec3 SRDir = normalize(RandSampleCos(SRand)*TBN(SRefDir)*ReflectionCR+SRefDir); //Generate random dir\n                    vec3 HitP = Pos+SDir*SC.w+SNormal*0.01+SRDir*SRefShad.w;\n                    if (dot(HitP-PPos,Normal)<=0.) continue; //Only hitpoints in the current hemisphere are valid\n                    if (sqrt(1./dot(normalize(HitP-PPos),RefDir)-1.)<=ReflectionCR)\n                        //This hitpoint generated by SUV is inside the reflection cone from the current hitpoint\n                        RefC += vec4(SRefShad.xyz,1.);\n                }\n            }\n            RefC.xyz /= RefC.w;\n            Output = vec4(mix(RefC.xyz,ComputeDirectLight(PPos,Normal,iTime),SchlickFresnel(vec3(0.4),dot(-Dir,Normal))),1.);\n        } else {\n            //No geometry hit\n            Output = vec4(SampleSky(Dir),-1.);\n        }\n    }\n    fragColor = Output;\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"//TAA\n\nvec4 textureCube(vec2 UV) {\n    //Samples the cubemap\n    float Sign = -mod(floor(UV.y*I1024),2.)*2.+1.;\n    vec3 D = vec3(vec2(UV.x,mod(UV.y,1024.))*I512-1.,Sign);\n    if (UV.y>4096.) D = D.xzy;\n    else if (UV.y>2048.) D = D.zxy;\n    return texture(iChannel3,D);\n}\n\nvec4 sampleLevel0(vec2 PriorUV) {\n    float YOffset = floor(PriorUV.x*I1024)*1024.+floor(PriorUV.y*I1024)*3072.;\n    return textureCube(mod(PriorUV,1024.)+vec2(0.,YOffset));\n}\n\nvoid MIN(inout vec2 Out, vec2 In) {\n    Out = ((Out.x<In.x)?Out:In);\n}\n\nvec4 SampleTextureCatmullRom(vec2 uv) {\n    vec2 samplePos = uv;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n    vec2 f = samplePos - texPos1;\n    vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n    vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n    vec2 w3 = f * f * (-0.5 + 0.5 * f);\n    vec2 w12 = w1 + w2;\n    vec2 offset12 = w2 / w12;\n    vec2 texPos0 = texPos1 - vec2(1.0);\n    vec2 texPos3 = texPos1 + vec2(2.0);\n    vec2 texPos12 = texPos1 + offset12;\n    vec4 result = vec4(0.);\n    result += sampleLevel0( vec2(texPos0.x,  texPos0.y)) * w0.x * w0.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos0.y)) * w12.x * w0.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos0.y)) * w3.x * w0.y;\n    result += sampleLevel0( vec2(texPos0.x,  texPos12.y)) * w0.x * w12.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos12.y)) * w12.x * w12.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos12.y)) * w3.x * w12.y;\n    result += sampleLevel0( vec2(texPos0.x,  texPos3.y)) * w0.x * w3.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos3.y)) * w12.x * w3.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos3.y)) * w3.x * w3.y;\n    return max(vec4(0.,0.,0.,1.),result);\n}\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    vec4 Output = texture(iChannel3,rayDir);\n    vec2 UV; vec3 aDir = abs(rayDir);\n    if (aDir.z>max(aDir.x,aDir.y)) {\n        //Z-side\n        UV = floor(((rayDir.xy/aDir.z)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.z<0.) UV.y += 1024.;\n    } else if (aDir.x>aDir.y) {\n        //X-side\n        UV = floor(((rayDir.yz/aDir.x)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.x>0.) UV.y += 2048.;\n        else UV.y += 3072.;\n    } else {\n        //Y-side\n        UV = floor(((rayDir.xz/aDir.y)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.y>0.) UV.y += 4096.;\n        else UV.y += 5120.;\n    }\n    //TAA\n    vec2 RESOffset = vec2((mod(floor(UV.y*I1024)+0.5,3.)-0.5)*1024.,floor(UV.y*I1024*I3)*1024.);\n    vec2 CUV = mod(UV,1024.)+RESOffset;\n    if (iFrame>2 && DFBox(CUV-1.,RES-2.)<0.) {\n        //Inside the screen\n        vec3 FinalColor = texture(iChannel2,CUV*IRES).xyz;\n        //Reprojection\n        vec2 SSOffset = SSOffsets[iFrame%16];\n        vec3 Eye = GetEye(iMouse,IRES);\n        vec3 Pos = GetPosition(Eye);\n        vec3 Tan; vec3 Bit = TBN(Eye,Tan);\n        mat3 EyeMat = TBN(Eye);\n        vec4 PriorMouse = texture(iChannel0,vec2(1.5,0.5)*IRES);\n        vec3 PriorEye = GetEye(PriorMouse,IRES);\n        vec3 PriorPos = GetPosition(PriorEye);\n        vec3 PriorTan; vec3 PriorBit = TBN(PriorEye,PriorTan);\n        mat3 PriorEyeMat = TBN(PriorEye);\n        vec3 Dir = normalize(vec3(((CUV+SSOffset)*IRES*2.-1.)*CFOV*ASPECT,1.)*EyeMat);\n        vec4 CAttr = texture(iChannel0,CUV*IRES);\n        float Distance = CAttr.w;\n        if (Distance<-0.5) Distance = 100000.; //Sky pixel\n        vec3 PPos = Pos+Dir*Distance;\n        vec3 Normal = CAttr.xyz;\n        //Prior position\n        vec3 PriorVPos = vec3(dot(PPos-PriorPos,PriorTan),dot(PPos-PriorPos,PriorBit),dot(PPos-PriorPos,PriorEye));\n        vec2 PriorUV = ((PriorVPos.xy/PriorVPos.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n        if (DFBox(PriorUV-3.,RES-6.)<0.) {\n            //Valid reprojection\n            vec4 LFinalColor;\n            if (length(PriorUV-CUV-SSOffset)>0.02) {\n                //Catmull-rom sampling\n                PriorUV -= SSOffsets[(iFrame-1)%16];\n                LFinalColor = SampleTextureCatmullRom(PriorUV);\n            } else {\n                //Nearest neighbour sampling\n                PriorUV = floor(PriorUV)+0.5;\n                float YOffset = floor(PriorUV.x*I1024)*1024.+floor(PriorUV.y*I1024)*3072.;\n                LFinalColor = textureCube(mod(PriorUV,1024.)+vec2(0.,YOffset));\n            }\n            //Clamping\n            vec3 FMIN = vec3(1000.);\n            vec3 FMAX = vec3(0.);\n            for (float x=-1.; x<1.5; x+=1.) {\n                for (float y=-1.; y<1.5; y+=1.) {\n                    vec3 Sample = texture(iChannel2,(CUV+vec2(x,y))*IRES).xyz;\n                    //Clamp\n                    FMIN = min(FMIN,Sample);\n                    FMAX = max(FMAX,Sample);\n                }\n            }\n            LFinalColor.xyz = clamp(LFinalColor.xyz,FMIN,FMAX);\n            //Output\n            Output = vec4((FinalColor+LFinalColor.xyz*LFinalColor.w)/(LFinalColor.w+1.),min(31.,LFinalColor.w+1.));\n        } else {\n            //Invalid reprojection\n            Output = vec4(FinalColor,1.);\n        }\n    } else Output = vec4(0.,0.,0.,1.);\n    //Output\n    fragColor = Output;\n}","name":"Cube A","description":"","type":"cubemap"}]}