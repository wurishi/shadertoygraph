{"ver":"0.1","info":{"id":"XdGczW","date":"1521139937","viewed":1791,"name":"Random Sampling Simulation","username":"Hsiett","description":"This shader tries to simulate random sampling of a scene. I use the default scene to simplify the code. The probability of each pixel being sampled in this demo, p(u,v)=pi*r^2/(iResolution.x*iResolution.y).","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["randomsampling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//This shader tries to simulate random sampling of\n//a target pixel. The probability of the pixel being\n//sampled is:\n// p(u,v)=pi*r^2/(iResolution.x*iResolution.y)\n// In this demo, I set r between 0.05 and 0.55 of iResolution.x.\n\n//======================================================\n//random noise function\n//    I assume that the noise is random distributed. There\n//ref:https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n//    https://www.shadertoy.com/view/ltB3zD\n\n// Gold Noise function\nfloat PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   \nfloat PI  = 3.14159265358979323846264 * 00000.1; // PI\nfloat SRT = 1.41421356237309504880169 * 10000.0; // Square Root of Two\n\n\nfloat random_0t1(in vec2 coordinate, in float seed)\n{\n    return fract(sin(dot(coordinate*seed, vec2(PHI, PI)))*SRT);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    //================================================\n    //generate a uniform random number between [0,1]\n    //two seed is different to mitigate aliasing\n    // (iTime+450, iDate.w)\n    // Without adding 450 seconds, the random sampling seems to have aliasing\n    // You can change the constant to see the effect after refreshing the website.\n    float antialiasingOffset=450.0;\n    int ur= int(random_0t1(uv,iTime+antialiasingOffset)*iResolution.x);\n    int vr= int(random_0t1(uv,iDate.w)*iResolution.y);\n    \n    \n    //the prabability of a pixel being selected.\n    // here p(x,y)=pi*r^2/(iResolution.x*iResolution.y)\n    float r = iResolution.x/2.0*(sin(iTime)*0.5+0.6);\n    \n    //the samppling flags\n    bool isSampled=length(fragColor.xy-vec2(ur,vr))<r?true:false;\n    \n    \n    //================================================\n    // The default rendered scene.\n    // Time varying pixel color\n    vec3 col=vec3(0.0,0.0,0.0);\n    \n    //add a comparison \n    if (isSampled ||(0.5*uv.x+0.25<uv.y)){\n        //render the scene using the scene shader codes\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    }\n    \n    // Output to screen with mask\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}