{"ver":"0.1","info":{"id":"cl2XDw","date":"1685260386","viewed":110,"name":"Yet another raytracer","username":"totimannino","description":"Haven't written a pathtracer in awhile. Very simple Lambertian material. MIS sampling from Area light. ACES tonemapping.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 computeCCDFlare(int filterLen, vec2 pixCoord, vec2 pixDelta, float lumThreshold)\n{\n    float lum = 0.;\n    vec2 pixOffset;\n    vec3 colorOffset;\n    vec3 accumColor = vec3(0.);\n    for(int ii = -filterLen; ii <= filterLen; ++ii)\n    {\n        pixOffset = pixCoord + float(ii)*pixDelta;\n        colorOffset = texture(iChannel0, pixOffset).rgb;\n        lum = dot(colorOffset, vec3(0.2126, 0.7152, 0.0722));\n        if(lum >= lumThreshold)\n        {\n            accumColor = accumColor + vec3(colorOffset)*exp(-10.*float(abs(ii))/float(filterLen + 1));\n        }\n    }\n    \n    return accumColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 pixCoord = fragCoord/iResolution.xy;\n    vec3 pixDelta = vec3(vec2(1.)/iResolution.xy, 0.);\n    fragColor = texture(iChannel0, pixCoord);\n    vec3 uFlareColor = computeCCDFlare(20, pixCoord, pixDelta.xz, 3.0);\n    vec3 vFlareColor = computeCCDFlare(4, pixCoord, pixDelta.zy, 3.0);\n    vec3 flareColor = uFlareColor + vFlareColor;\n    \n    fragColor.rgb = TonemapACES(fragColor.rgb  + flareColor);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592653589793238\n#define MAX_DIST 99999999999.\n#define RAY_EPS 0.0001\n\nstruct Primitive\n{\n    int objGeoTypeId;\n    int geoIndexId;\n    int materialModelId;\n    int materialIndexId;\n};\n\n// Geometry\nstruct PlaneDef\n{\n    vec3 norm;\n    vec3 pos;\n};\n\nstruct DiskDef\n{\n    vec3 norm;\n    vec3 pos;\n    float radius;\n};\n\nstruct SphereDef\n{\n    vec3 center;\n    float radius;\n};\n\n// Camera\nstruct CameraDef\n{\n    vec3 pos;\n    vec3 lookAt;\n    float yaw;\n};\n\n// Ray tracing\nstruct Ray\n{\n    vec3 dir;\n    vec3 orig;\n};\n\nstruct TraceInfo\n{\n    Ray sampleRay;\n    vec3 pos;\n    vec3 norm;\n    vec3 color;\n    float dist;\n    int prim;\n};\n\nstruct RaySample\n{\n    Ray ray;\n    float pdf;\n};\n\n// Materials\nstruct EmissionMat\n{\n    vec3 emissionColor;\n    float radiance;\n};\n\nstruct LambertMat\n{\n    vec3 diffuseColor;\n};\n\nmat3 constructCameraMat(CameraDef cam) \n{\n\tvec3 cw = normalize(cam.lookAt-cam.pos);\n    vec3 cp;\n    if(abs(cw.x) > 0. || abs(cw.z) > 0.)\n    {\n        cp = vec3(sin(cam.yaw), cos(cam.yaw), 0.);\n    }\n    else\n    {\n        cp = vec3(sin(cam.yaw), 0., cos(cam.yaw));\n    }\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = cross(cu,cw);\n    return mat3(cu, cv, cw);\n}\n\nvec3 rayHitPos(Ray ray, float t)\n{\n    return ray.orig + t*ray.dir;\n}\n\nfloat planeIntersect(Ray ray, PlaneDef plane)\n{   \n    float t = dot(plane.norm, plane.pos-ray.orig)/dot(plane.norm, ray.dir);\n    if(t > RAY_EPS) return t;\n    else return MAX_DIST;\n}\n\nfloat diskIntersect(Ray ray, DiskDef plane)\n{\n    float rdotn = dot(plane.norm, ray.dir);\n    if(rdotn > 0.) return MAX_DIST;\n    float t = dot(plane.norm, plane.pos-ray.orig)/rdotn;\n    if(t <= RAY_EPS) return MAX_DIST;\n    vec3 dist = rayHitPos(ray, t) - plane.pos;\n    if(length(dist) > plane.radius) return MAX_DIST;\n    else return t;\n}\n\nfloat sphereIntersect(Ray ray, SphereDef s)\n{\n    vec3 tcenter = s.center - ray.orig;\n \tfloat c = dot(tcenter,tcenter)-s.radius*s.radius;\n    float b = 2.0*dot(-tcenter, ray.dir);\n    //assumption is ray.dir is normalized\n    //float a = 1.0;//dot(ray.dir, ray.dir);\n    float det = b*b-4.0*c;\n    vec2 hits = vec2(-1.0,-1.0);\n    if(det > 0.0) {\n    \tfloat t1 = 0.5*(-b+sqrt(det));\n    \tfloat t2 = 0.5*(-b-sqrt(det));\n        if(t1 < t2 && t1 > 0.) return t1;\n        else if(t2 < t1 && t2 > 0.) return t2;\n    }\n    return MAX_DIST;\n}\n\n\nvec3 sphereNorm(SphereDef sd, vec3 pos)\n{\n    return normalize(pos-sd.center);\n}\n\n// Frisvad method, from \n// https://backend.orbit.dtu.dk/ws/portalfiles/portal/126824972/onb_frisvad_jgt2012_v2.pdf\n// implementation from https://www.shadertoy.com/view/4lfcDr\nmat3 computeONB(vec3 normal)\n{\n\tmat3 ret;\n\tret[2] = normal;\n\tif(normal.z < -0.999805696) {\n\t\tret[0] = vec3(0.0, -1.0, 0.0);\n\t\tret[1] = vec3(-1.0, 0.0, 0.0);\n\t}\n\telse {\n\t\tfloat a = 1.0 / (1.0 + normal.z);\n\t\tfloat b = -normal.x * normal.y * a;\n\t\tret[0] = vec3(1.0 - normal.x * normal.x * a, b, -normal.x);\n\t\tret[1] = vec3(b, 1.0 - normal.y * normal.y * a, -normal.y);\n\t}\n\treturn ret;\n}\n\nvec2 sampleDisk(vec2 uvRand, float radius)\n{\n    float theta = 2.0 * PI * uvRand.x;\n\treturn vec2(cos(theta), sin(theta)) * sqrt(uvRand.y*radius);\n}\n\nvec3 sampleCosine(vec2 uvRand)\n{\n\tvec2 disk = sampleDisk(uvRand, 1.);\n\treturn vec3(disk.x, disk.y, sqrt(max(0.0, 1.0 - dot(disk, disk))));\n}\n\n// Tone mapping and transfer functions\n// Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\nvec3 TonemapACES(const vec3 x) \n{\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Primitives\n#define NPRIMITIVES 13\n\n#define PLANEID 0\n#define NPLANES 5\n\n#define DISKID 1\n#define NDISKS 6\n\n#define SPHEREID 2\n#define NSPHERES 2\n\nPrimitive primitives[NPRIMITIVES];\nPlaneDef plane[NPLANES];\nDiskDef disk[NDISKS];\nSphereDef sphere[NSPHERES];\n\n// Materials\n#define NMATERIALS 2\n\n#define EMISSIONID 0\n#define NEMISSION 3\n\n#define LAMBERTID 1\n#define NLAMBERT 5\n\n#define PATHLENGTH 4\n\nEmissionMat emission[NEMISSION];\nLambertMat lambert[NLAMBERT];\n\n// Emission surfaces (for sampling)\n#define NEMISSIONPRIMS 3\nPrimitive emissionPrims[NEMISSIONPRIMS];\n\nint seed = 0;\nint coordIdx = 0;\n\n// tiny encryption algorithm for random sampling\n// https://redirect.cs.umbc.edu/~olano/papers/GPUTEA.pdf\n// implementation from https://www.shadertoy.com/view/4lfcDr\nvoid tinyEncrypt(inout uvec2 arg)\n{\n\tuvec4 key = uvec4(0xa341316c, 0xc8013ea4, 0xad90777d, 0x7e95761e);\n\tuint v0 = arg.x;\n    uint v1 = arg.y;\n\tuint sum = 0u;\n\tuint delta = 0x9e3779b9u;\n\n\tfor(int i = 0; i < 32; i++) {\n\t\tsum += delta;\n\t\tv0 += ((v1 << 4) + key.x) ^ (v1 + sum) ^ ((v1 >> 5) + key.y);\n\t\tv1 += ((v0 << 4) + key.z) ^ (v0 + sum) ^ ((v0 >> 5) + key.w);\n\t}\n\targ.x = v0;\n\targ.y = v1;\n}\n\nvec2 random2d()\n{\n  \tuvec2 arg = uvec2(coordIdx, seed++);\n  \ttinyEncrypt(arg);\n  \treturn fract(vec2(arg) / vec2(0xffffffffu));\n}\n\nvec3 computeNorm(vec3 hitPos, int primId)\n{\n    if(primitives[primId].objGeoTypeId == PLANEID)\n    {\n        return plane[primitives[primId].geoIndexId].norm;\n    }\n    else if(primitives[primId].objGeoTypeId == DISKID)\n    {\n        return disk[primitives[primId].geoIndexId].norm;\n    }\n    else if(primitives[primId].objGeoTypeId == SPHEREID)\n    {\n        return sphereNorm(sphere[primitives[primId].geoIndexId], hitPos);\n    }\n    else \n    {\n        return vec3(0.);\n    }\n}\n\nTraceInfo traceScene(Ray ray)\n{\n    float minHitT = MAX_DIST;\n    float currHitT = MAX_DIST;\n    int minPrimHit = -1;\n    for(int i = 0; i < NPRIMITIVES; i++)\n    {\n        if(primitives[i].objGeoTypeId == PLANEID)\n        {\n            currHitT = planeIntersect(ray, plane[primitives[i].geoIndexId]);\n        }\n        else if(primitives[i].objGeoTypeId == DISKID)\n        {\n            currHitT = diskIntersect(ray, disk[primitives[i].geoIndexId]);\n        }\n        else if(primitives[i].objGeoTypeId == SPHEREID)\n        {\n            currHitT = sphereIntersect(ray, sphere[primitives[i].geoIndexId]);\n        }\n        \n        if(currHitT < minHitT)\n        {\n            minHitT = currHitT;\n            minPrimHit = i;\n        }\n    }\n    \n    TraceInfo traceInfo;\n    traceInfo.prim = -1;\n    if(minHitT < MAX_DIST)\n    {\n        traceInfo.dist = minHitT;\n        traceInfo.pos = rayHitPos(ray, minHitT);\n        traceInfo.norm = computeNorm(traceInfo.pos, minPrimHit);\n        traceInfo.prim = minPrimHit;\n        if(primitives[minPrimHit].materialModelId == LAMBERTID)\n        {\n            traceInfo.color = lambert[primitives[minPrimHit].materialIndexId].diffuseColor;\n        }\n        else if(primitives[minPrimHit].materialModelId == EMISSIONID)\n        {\n            traceInfo.color = vec3(1.);\n        }\n    }\n    \n    return traceInfo;\n}\n\nRaySample sampleRay(TraceInfo trace)\n{\n    RaySample rsamp;\n    if(primitives[trace.prim].materialModelId == LAMBERTID)\n    {\n        vec3 sampleRayDir = sampleCosine(random2d());\n        mat3 onb = computeONB(trace.norm);\n        rsamp.ray = Ray(onb*sampleRayDir, trace.pos);\n        rsamp.pdf = max(0., dot(trace.norm, rsamp.ray.dir))/PI; // use dir.z?\n    }\n    return rsamp;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixOffset = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    float focalLength = 1.0;\n    \n    // for random2d\n    int coordIdx = int(dot(fragCoord.xy, vec2(1, iResolution.y)));\n    seed = iFrame*coordIdx;\n    \n    // create camera\n    CameraDef sceneCam = CameraDef(vec3(0.,-5.,0.), vec3(0.,0.,0.), 0.);\n    mat3 camMat = constructCameraMat(sceneCam);\n    vec3 rayDir = camMat*normalize(vec3(pixOffset, focalLength));\n    \n    plane[0] = PlaneDef(vec3(0.,0.,1.), vec3(0.,0.,-10.));\n    plane[1] = PlaneDef(vec3(0.,0.,-1.), vec3(0.,0.,10.));\n    plane[2] = PlaneDef(vec3(1.,0.,0.), vec3(-14.,0.,0.));\n    plane[3] = PlaneDef(vec3(-1.,0.,0.), vec3(14.,0.,0.));\n    plane[4] = PlaneDef(vec3(0.,-1.,0.), vec3(0.,30.,0.));\n    \n    float lightHt = 9.2f;\n    disk[0] = DiskDef(vec3(0.,0.,-1.), vec3(-7.,21.,lightHt), 1.5f);\n    disk[1] = DiskDef(vec3(0.,0.,-1.), vec3(0.,21.,lightHt), 1.5f);\n    disk[2] = DiskDef(vec3(0.,0.,-1.), vec3(7.,21.,lightHt), 1.5f);\n    \n    // light backside\n    disk[3] = DiskDef(vec3(0.,0.,1.), vec3(-7.,21.,lightHt), 1.5f);\n    disk[4] = DiskDef(vec3(0.,0.,1.), vec3(0.,21.,lightHt), 1.5f);\n    disk[5] = DiskDef(vec3(0.,0.,1.), vec3(7.,21.,lightHt), 1.5f);\n    \n    sphere[0] = SphereDef(vec3(-4.5,18.,-4.), 3.0);\n    sphere[1] = SphereDef(vec3(4.,21.,-4.), 5.0);\n    \n    lambert[0] = LambertMat(vec3(1.,1.,1.));\n    lambert[1] = LambertMat(vec3(.9,0.,.7));\n    lambert[2] = LambertMat(vec3(0.,.9,0.7));\n    lambert[3] = LambertMat(vec3(.9,.2,1.));\n    lambert[4] = LambertMat(vec3(0.9,.9,.9));\n    \n    primitives[0] = Primitive(PLANEID, 0, LAMBERTID, 0);\n    primitives[1] = Primitive(PLANEID, 1, LAMBERTID, 0);\n    primitives[2] = Primitive(PLANEID, 2, LAMBERTID, 1);\n    primitives[3] = Primitive(PLANEID, 3, LAMBERTID, 3);\n    primitives[4] = Primitive(PLANEID, 4, LAMBERTID, 2);\n    primitives[5] = Primitive(DISKID, 0, EMISSIONID, 0);\n    primitives[6] = Primitive(DISKID, 1, EMISSIONID, 1);\n    primitives[7] = Primitive(DISKID, 2, EMISSIONID, 2);\n    primitives[8] = Primitive(DISKID, 3, LAMBERTID, 0);\n    primitives[9] = Primitive(DISKID, 4, LAMBERTID, 1);\n    primitives[10] = Primitive(DISKID, 5, LAMBERTID, 2);\n    primitives[11] = Primitive(SPHEREID, 0, LAMBERTID, 0);\n    primitives[12] = Primitive(SPHEREID, 1, LAMBERTID, 0);\n    \n    emissionPrims[0] = primitives[5];\n    emissionPrims[1] = primitives[6];\n    emissionPrims[2] = primitives[7];\n    \n    emission[0] = EmissionMat(vec3(0.3,0.3,0.9), 150.);\n    emission[1] = EmissionMat(vec3(0.1,0.9,0.1), 150.);\n    emission[2] = EmissionMat(vec3(0.8,0.1,0.1), 150.);\n    \n    vec3 totalColor = vec3(0.);\n    vec3 throughput = vec3(1.);\n    Ray currRay = Ray(rayDir, sceneCam.pos);\n    int nsamples = 1;\n    for(int i = 0; i < PATHLENGTH; i++)\n    {\n        TraceInfo trace = traceScene(currRay);\n        vec3 misRadiance = vec3(0.);\n        if(primitives[trace.prim].materialModelId == EMISSIONID)\n        {\n            totalColor += throughput*emission[primitives[trace.prim].materialIndexId].emissionColor*emission[primitives[trace.prim].materialIndexId].radiance;\n            break;\n        }\n        else\n        {\n            throughput *= trace.color;\n            for(int j = 0; j < NEMISSIONPRIMS; j++)\n            {\n                if(emissionPrims[j].objGeoTypeId == DISKID)\n                {\n                    float lightRadius = disk[emissionPrims[j].geoIndexId].radius;\n                    vec3 sampDisk2D = vec3(sampleDisk(random2d(), lightRadius), 0.);\n                    vec3 lightNorm = disk[emissionPrims[j].geoIndexId].norm;\n                    mat3 diskONB = computeONB(lightNorm);\n                    vec3 sampPosToDiskRay = disk[emissionPrims[j].geoIndexId].pos + diskONB*sampDisk2D - trace.pos;\n                    float distToLightSampSqr = dot(sampPosToDiskRay, sampPosToDiskRay);\n                    sampPosToDiskRay = sampPosToDiskRay/sqrt(distToLightSampSqr);\n\n                    TraceInfo traceEmissive = traceScene(Ray(sampPosToDiskRay, trace.pos));\n                    if((primitives[traceEmissive.prim].objGeoTypeId == emissionPrims[j].objGeoTypeId) && (primitives[traceEmissive.prim].geoIndexId == emissionPrims[j].geoIndexId))\n                    {\n                        float lightArea = PI*lightRadius*lightRadius;\n                        vec3 lightRadiance = emission[emissionPrims[j].materialIndexId].emissionColor*emission[emissionPrims[j].materialIndexId].radiance;\n                        float nDotL = max(0., dot(trace.norm, sampPosToDiskRay));\n                        float lnDotL = max(0.,abs(dot(lightNorm,sampPosToDiskRay)));\n                        float invpdf = lightArea*lnDotL/distToLightSampSqr;\n                        misRadiance += lightRadiance*invpdf*nDotL;\n                    }\n                    nsamples += 1;\n                }\n            }\n        }\n        \n        //float hitpdf = dot(trace.norm, -currRay.dir)/PI;\n        \n        totalColor += throughput*misRadiance;\n        RaySample rsamp = sampleRay(trace);\n        \n        currRay = rsamp.ray;\n    }\n    \n    totalColor /= float(nsamples);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float accR = 1./float(iFrame+1);\n    vec3 sumColor = texture(iChannel0, uv).rgb*(1. - accR) + totalColor*accR;\n    fragColor = vec4(sumColor, 1.);\n    //fragColor = vec4(totalColor, 1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}