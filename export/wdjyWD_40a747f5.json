{"ver":"0.1","info":{"id":"wdjyWD","date":"1586697721","viewed":201,"name":"SDF-based View Merge Animation","username":"pashabou","description":"Animation for merging of UI views using signed distance fields","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","animation","ui"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nstruct Circle {\n\tvec2 position;\n    float radius;\n};\n\nstruct RoundBox {\n\tvec2 position;\n    vec2 dimensions;\n    float cornerRadius;\n};\n    \nRoundBox boundingBox(in RoundBox b1, in RoundBox b2) {\n\tvec2 pos = b1.position + b2.position;\n    vec2 dim = abs(b2.position - b1.position) + b1.dimensions + b2.dimensions;\n    return RoundBox(pos * 0.5, dim * 0.5, max(b1.cornerRadius, b2.cornerRadius));\n}\n\nfloat SDF(in vec2 p, in Circle c) {\n    return length(p - c.position) - c.radius;\n}\n\nfloat SDF(in vec2 p, in RoundBox b) {\n    vec2 q = abs(p - b.position) - b.dimensions + b.cornerRadius;\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - b.cornerRadius;\n}\n\nfloat smoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float t = abs(sin(iTime));\n    float t2 = max(0., t*t-.6);\n\tvec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n   \tRoundBox leftBox = RoundBox(vec2(-0.25, 0.), vec2(0.2), 0.03);\n    RoundBox rightBox = RoundBox(vec2(0.25, 0.5 * (1.-t)), vec2(0.2), 0.03);\n    Circle leftCirc = Circle(vec2(-0.25, 0.), 0.15);\n    Circle rightCirc = Circle(vec2(0.25, 0.5 * (1.-t)), 0.15);\n    \n    float d = smoothUnion(SDF(p, leftCirc), SDF(p, rightCirc), 0.1 * t2);\n    float d1 = smoothUnion(SDF(p, leftBox), d, 0.8 * t2);\n    float d2 = smoothUnion(SDF(p, rightBox), d, 0.8 * t2);\n    d = smoothUnion(d1, d2, 0.4 * t2);\n    \n    RoundBox mask = boundingBox(leftBox, rightBox);\n    d = max(d, SDF(p, mask));\n    \n    vec3 col = vec3(0.);\n    if (d < 0.) {\n    \tvec2 v = p - (leftBox.position + leftBox.dimensions.x * 0.5);\n        vec2 s = (rightBox.position - vec2(rightBox.dimensions.x * 0.5, 0.));\n        s -= (leftBox.position + vec2(leftBox.dimensions.x * 0.5, 0.));\n        float r = dot(v, s) / dot(s, s);\n        col = mix(vec3(0.1, 0.4, 0.7), vec3(0.7, 0.2, 0.1), clamp(r, 0., 1.));\n        if (SDF(p, leftBox) < 0.) {\n        \tcol = mix(vec3(0.1, 0.4, 0.7), col, t2/.4);\n        } else if (SDF(p, rightBox) < 0.) {\n        \tcol = mix(vec3(0.7, 0.2, 0.1), col, t2/.4);\n        }\n    }\n        \n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}