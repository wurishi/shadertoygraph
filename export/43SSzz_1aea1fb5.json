{"ver":"0.1","info":{"id":"43SSzz","date":"1710773929","viewed":241,"name":"Torus Disco","username":"NivBehar","description":"An old shader I made in Milkdrop\nMake sure sound is working :)","likes":14,"published":1,"flags":96,"usePreview":0,"tags":["raymarching","sound","torus","hexagons","shine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    //uv *= 1.4;\n    \n    bass = GET_BASS;\n    mid = GET_MID;\n    treb = GET_TREB;\n    sound = GET_SOUND;\n    bass_cont = GET_BASS_CONT;\n    mid_cont = GET_MID_CONT;\n    treb_cont = GET_TREB_CONT;\n    sound_cont = GET_SOUND_CONT;\n    \n    vec3 col = texture(iChannel2, uv).xyz;\n  \n    vec2 sunpos = vec2(0.5, 0.5);\n\n    // a nice trick a guy called Martin made on Milkdrop to make the all scene shine\n    vec3 shine = col; \n    float radi = 1.;\n    int anz = 70;//70;\n    for (int n=1; n <= anz; n++)\n    { \n      vec2 newUV = (uv-sunpos)*radi+sunpos;\n      shine += (0.8 + 250.*pow(sound,15.))/float(anz)*texture(iChannel2, newUV).xyz;\n      radi -= 1./float(anz);\n    }\n    \n    col = max(shine, col); // add shine\n    \n\n    //col += clamp(shine,0.,1.);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define BufA(x, y) texture(iChannel1, (vec2(x, y) + 0.5) / iResolution.xy)\n#define GET_BASS_PURE BufA(0.,0.).x\n#define GET_BASS BufA(0.,3.).x\n#define GET_BASS_CONT BufA(0.,2.).x\n#define GET_MID_PURE BufA(1.,0.).x\n#define GET_MID BufA(1.,3.).x\n#define GET_MID_CONT BufA(1.,2.).x\n#define GET_TREB_PURE BufA(2.,0.).x\n#define GET_TREB BufA(2.,3.).x\n#define GET_TREB_CONT BufA(2.,2.).x\n#define GET_SOUND_PURE (GET_BASS_PURE + GET_MID_PURE + GET_TREB_PURE)/3.\n#define GET_SOUND (GET_BASS + GET_MID + GET_TREB)/3.\n#define GET_SOUND_CONT (GET_BASS_CONT + GET_MID_CONT + GET_TREB_CONT)/1.5\n\nfloat bass;\nfloat mid;\nfloat treb;\nfloat sound;\nfloat bass_cont;\nfloat mid_cont;\nfloat treb_cont;\nfloat sound_cont;\n\nvec2 mou;\n\n// Hexagon Dist by BigWings\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    \n    float c = dot(p, normalize(vec2(1.,1.732050808)));\n    c = max(c, p.x);\n    \n    return c;\n}\n\nstruct hex\n{\n    float x;\n    float y;\n    float ang;\n    float dist;\n    vec2 id;\n};\n\n// Hexagon Coords by BigWings\n// ID's by Shane\nhex HexCoords(vec2 UV) \n{\n    vec2 r = vec2(1., sqrt(3.));\n    vec2 h = r*.5;\n    \n    vec2 a = mod(UV, r)-h;\n    vec2 b = mod(UV-h, r)-h;\n    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    \n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = UV - gv;\n    \n    vec4 hC = floor(vec4(UV, UV - vec2(.5, 1))/r.xyxy) + vec4(.5, .5, 1, 1.5);\n    vec2 final_hC = dot(a, a) < dot(b,b) ? hC.xy : hC.zw;\n    //final_hC = UV-gv;\n    //angle, dist from center, id_x, id_y\n    hex ret = hex(gv.x, gv.y, x, y, final_hC);\n    return ret;\n}\n\nfloat sdSphere( vec3 p, float r)\n{\n    float sphereDist = length(p)-r;\n    return sphereDist;\n}\n\nvec3 RotX (vec3 p, float speed)\n{\n    return vec3(p.x, p.y*cos(speed) + p.z*-sin(speed),  p.y*sin(speed) + p.z*cos(speed));\n}\nvec3 RotY (vec3 p, float speed)\n{\n    return vec3(p.x*cos(speed) + p.z*sin(speed), p.y, p.x*-sin(speed) + p.z*cos(speed));\n}\nvec3 RotZ (vec3 p, float speed)\n{\n    return vec3(p.x*cos(speed)  + p.y*-sin(speed), p.x*sin(speed) + p.y*cos(speed), p.z);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4stGDs","filepath":"https://soundcloud.com/naxatras/the-great-attractor","previewfilepath":"https://soundcloud.com/naxatras/the-great-attractor","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"# define time iTime\n\n// bass bands\n# define BASS_START 0\n# define BASS_END 14\n// middle bands\n# define MID_START 15\n# define MID_END 143\n// treble bands\n# define TREBLE_START 144\n# define TREBLE_END 511\n\n/*------------ Tuning ------------*/\n\n/*---- Smooth Sound values ----*/\n// lower value - less time for the smooth sound stay on top of the pure sound\n#define DECREASE_MIN 0.001\n// lower value - lower decrease time. should be above 1.\n#define DECREASE_MUL 1.\n/* lower value - slower increase of smooth sound. \n   higher value - faster increase.\n   should be below 1. */\n#define INCREASE_MUL 0.9\n\n/*---- Smooth Sound Continues values ----*/\n/* play with this to get smaller\\bigger \"acceleration\" for the circles\n   lower value - more deceleration\n   should be below 1 */\n#define DELTA_INCREASE 0.8\n\n/* should be a value between 0 and 1\n   play with this to get smaller\\bigger \"deceleration\" for the circles\n   lower value - less acceleration */\n#define DELTA_MUL 0.95\n\n/* bigger DELTA_COUNT_MAX value will take into account more of the \"acceleration\"\n   lower value will restrain the acceleration\n   in other words - saturate it */\n#define DELTA_COUNT_MAX 8.\n\nfloat getSound(int start, int end)\n{\n    float ret = 0.;\n    for(int i = start; i <= end; i++)\n    {\n        float samp = texelFetch(iChannel0, ivec2(i, 0), 0).x;\n        \n        samp = samp*samp + 0.5*samp;\n        if(samp > 0.8)\n            samp *= 0.8; // just to reduce the magnitude of the low frequencies\n        ret += samp;\n    }\n    \n    ret /= float(end - start + 1);\n    return ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float fpsInv = 60./iFrameRate;\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    vec2 operation = fragCoord - 0.5;\n\n    int start, end;\n    \n    float sound; // pure sound samples average\n    float prev_sound; // previous sound\n    float smooth_sound; // smooth sound\n    float prev_smooth_sound; // previous smooth sound\n    float decrease;\n    float smooth_sound_cont; // smooth sound continues\n    float prev_smooth_sound_cont; // previous smooth sound continues\n    float delta;\n    float delta_count;\n\n    // Initialize values\n    if(iFrame == 0)\n    {\n        sound = 0.;\n        prev_sound = 0.;\n        smooth_sound = 0.;\n        prev_smooth_sound = 0.;\n        decrease = 0.;\n        smooth_sound_cont = 0.;\n        prev_smooth_sound_cont = 0.;\n        delta = 0.;\n        delta_count = 0.;\n    }\n    \n    // fragCoord.x determines to calculate bass\\mid\\treble\n    if(operation.x == 0.) { start = BASS_START; end = BASS_END;}\n    if(operation.x == 1.) { start = MID_START; end = MID_END;}\n    if(operation.x == 2.) { start = TREBLE_START; end = TREBLE_END;}\n    \n    // prev sound\n    sound = getSound(start, end);\n    prev_sound = BufA(operation.x, 0.).x;\n    \n    // sound type 2\n    prev_smooth_sound_cont = BufA(operation.x, 2.).x;\n    prev_smooth_sound = BufA(operation.x, 3.).x;;\n    decrease = BufA(operation.x, 4.).x;\n    if(sound > prev_smooth_sound)\n    {\n        smooth_sound = prev_smooth_sound + (sound-prev_smooth_sound)*INCREASE_MUL;\n        decrease = DECREASE_MIN;\n    }\n    else\n    {\n        smooth_sound = prev_smooth_sound - decrease;\n        decrease *= 1. + iTimeDelta * DECREASE_MUL;\n    }\n    \n    // smooth_sound_cont - circles motion\n    delta = BufA(operation.x, 5.).x;\n    delta_count = BufA(operation.x, 6.).x;\n    if(sound > prev_sound)\n    {\n        // this statement is to prevent exreme acceleration, when bass\\middle\\treble goes higher very quickly.\n        // in other words - saturate it.\n        // bigger value - accept a bigger acceleration.\n        // to notice the difference, just comment the if statement and reset the shader,\n        // then look at the blue circle which represent the treble\n        if(delta_count < DELTA_COUNT_MAX)\n        {\n            //delta += DELTA_INCREASE;\n            delta += iTimeDelta * DELTA_INCREASE;\n            delta_count += 1.; // for each delta increase\n        }\n    }\n    else\n    {\n        delta_count = 0.; // reset the counting\n        delta *= DELTA_MUL;\n    }\n    smooth_sound_cont = smooth_sound*iTimeDelta + delta + prev_smooth_sound_cont; \n    \n    // to prevent the value to go extremely high, can be useful in some cases when we only care about the fraction value\n    //if(smooth_sound_cont > 50.)\n    //    smooth_sound_cont -= floor(smooth_sound_cont);\n    \n    // fragCoord.y determines to calculate sound\\smoth_sound\\etc..\n    if(operation.y == 0.)\n        fragColor = vec4(sound, 0.,0.,1.0);\n    if(operation.y == 2.)\n        fragColor = vec4(smooth_sound_cont, 0.,0.,1.0);\n    if(operation.y == 3.)\n        fragColor = vec4(smooth_sound, 0.,0.,1.0);\n    if(operation.y == 4.)\n        fragColor = vec4(decrease, 0.,0.,1.0);\n    if(operation.y == 5.)\n        fragColor = vec4(delta, 0.,0.,1.0);\n    if(operation.y == 6.)\n        fragColor = vec4(delta_count, 0.,0.,1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"# define time iTime\n# define PI 3.141592654\n# define MaxSteps 50 // max steps for ray marching\n\n#define CAM_SHAKE_X (sound_cont*0.225)\n#define CAM_SHAKE_Z (sound_cont*0.262)\n#define CAM_SHAKE_X_MAG (mid*mid*0.210075)\n#define CAM_SHAKE_Z_MAG (mid*mid*0.205075)\n#define CAM_SHAKE_Y_OFF (17.*pow(sound,4.))\n\n#define SPACE_GIF_OFF (-mid_cont*0.5 - time)\n\n#define TORUS_ROTY_SPEED (sound_cont*0.05)\n\n#define SPHERE_ROTY_SPEED (-2.321*time)\n\n#define LIGHT_POS_SPEED_MUL (.5)\n#define LIGHT_POS_SPEED_X (treb_cont*LIGHT_POS_SPEED_MUL)\n#define LIGHT_POS_SPEED_Z (mid_cont*LIGHT_POS_SPEED_MUL)\n\nvec3 camerapos()\n{\n    vec3 ret = vec3(0., 18., 0.);\n    ret.x = CAM_SHAKE_X_MAG*sin(CAM_SHAKE_X);\n    ret.z = CAM_SHAKE_Z_MAG*cos(CAM_SHAKE_Z);\n    ret.y -= CAM_SHAKE_Y_OFF;\n    ret.y = min(15., ret.y);\n    return ret;\n}\nvec3 cameralookat() \n{\n    return camerapos()*vec3(1,0,1) + 0.001;\n}\n\nvec3 LightPos()\n{\n    vec3 ret = vec3(0.,10.,0.);\n    float r = 10.;\n    ret.x = sin(LIGHT_POS_SPEED_X)*r;\n    ret.z = cos(LIGHT_POS_SPEED_Z)*r;\n    return ret;\n}\n\n// By BigWings\nvec3 SpaceGif(vec2 UV)\n{\n    UV.x += 0.285;\n    UV.y += 0.26;\n    vec3 col = vec3(0,0,0);\n \n    UV *= 1.8;   \n    vec2 gv = fract(UV) - 0.5;\n    vec2 id = floor(UV);\n    float m = 0.;\n \n    for(int y = -1; y <= 1; y++)\n    {\n        for(int x = -1; x <= 1; x++)\n        {\n            vec2 offs = vec2(x,y);\n            float d = length(gv - offs);\n            float dist = length(id+offs)*0.9;\n            float r = 0.51 + 0.5*sin(dist + SPACE_GIF_OFF);\n            \n            float uv_scale = 0.1;\n            float r_mul = 0.5 - 0.3*sin(length(UV*uv_scale) + uv_scale * SPACE_GIF_OFF);\n            \n            float c = smoothstep(r, r*r_mul, d);\n            m = m*(1.-c) + c*(1.-m);\n        }\n    }\n\n    col = vec3(2,1,0.7);\n    col *= m;\n    \n    return col;\n}\nvec3 toruscol(vec3 p, vec3 tpos, vec2 tsize, float rotspeed)\n{\n    vec3 a1 = vec3(0.5, 0.5, 0.5);\n    vec3 b1 = vec3(0.5, 0.5, 0.5);\n    vec3 c1 = vec3(1., 1., 1.)*3.*mid*mid*mid + time*0.3;// + time; // animate \\ offset\n    vec3 d1 = vec3(0.0, 0.33, 0.67);\n    vec3 base_col = a1 + b1 * cos(2.*PI*(d1 + c1));\n\n\n    float x = atan(p.x + tpos.x, p.z + tpos.z);\n    float y = atan(length(p.xz + tpos.xz)-tsize.x, p.y + tpos.y);\n    float speed = time * 7.;\n\n    float f1 = smoothstep(0.4, 0.5, 0.5 + 0.5*cos(y*(30.*sin(time*0.5)) + x*15.));\n    float f2 = smoothstep(0.4, 0.5, 0.5 + 0.5*sin(y*(30.*cos(time*0.5)) + x*15.));\n    vec3 col = f1*f2*base_col;//vec3(1.000,0.933,0.110);\n\n    return col;\n}\nvec3 Hive(vec2 UV, float mul, float add)\n{\n    vec3 col = vec3(0);\n    UV *= mul;\n    hex hc = HexCoords(UV + add);\n\n    float c = smoothstep(0., 0.15, hc.dist*1.4  + 2.4*hc.dist*sin(hc.id.x*hc.id.y)*cos(hc.id.x*hc.id.y));\n    float c2 = smoothstep(0., 0.15,hc.dist*sin(hc.id.x*hc.id.y+1.5*time)*cos(hc.id.x*hc.id.y+1.5*time));\n    float c3 = smoothstep(0.01, 0.6, hc.dist*sin(hc.id.x*hc.id.y + 1.5*time)*cos(hc.id.x*hc.id.y+1.5*time));\n    col = (1.-c)*normalize(vec3(1.,1.,0.3));\n    col += c2*normalize(vec3(3.,1.4,0.));\n    \n    \n    //col += c3*normalize(vec3(4.,1.4,0.));\n\n    return col;\n}\n\nconst vec3 torus1Pos = vec3(0., 1.5, 0.);\nconst vec2 torus1Size = vec2(sin(0.)*0.7 + 4.3, 1.);\n\nvec3 spherePos = vec3(0,0,0);\nfloat sphereRad = 1.3;\n\nvec2 GetShapes(vec3 p)\n{\n//return vec2(0);\n    return (1.35*sin(time*0. + sound_cont*0.02))*sin(2.*p.xz)\n           + 0.025*sin(7.*p.zx + sound_cont*0.01)\n           + 0.25 * cos(p.zx*3. + time);//*sin(time*0.421);\n}\n\nfloat sdTorus1(vec3 p, vec2 r) {\n    float x = length(p.xz + GetShapes(p) )-r.x;\n    return (length(vec2(x, p.y))-r.y);\n}\n\nvec3 torusTransform(vec3 p)\n{\n    p = RotY(p, TORUS_ROTY_SPEED);\n    p = RotZ(p, p.x*0.01*p.z);\n    \n    return p;\n}\n\nvec3 sphereCol(vec3 p, vec3 spPos, float r)\n{\n    p*=1.6;\n    vec3 n = normalize(p-r);\n    float x = atan(n.x, n.z)/(2.*PI) + 0.5;\n    float y = 0.5 + 0.5*n.y;\n    vec3 col = 1.-Hive(vec2(x,y*0.5), 50., 0.);\n    return col;\n}\n\nvec2 GetDist(vec3 p)\n{\n    float groundDist = p.y;\n    float groundID = 1.;\n    // torus\n    vec3 pNew = torusTransform(p);\n    float torusDist = sdTorus1(pNew - torus1Pos, torus1Size);\n    float torusID = 2.;\n\n    // sphere\n    float sphereDist = sdSphere(p - spherePos, sphereRad);\n    float sphereID = 3.;\n    float shape = min(groundDist, torusDist);   \n    //shape = min(shape, torus2Dist);\n    shape = min(shape, sphereDist);\n    vec2 toreturn; \n    if(shape == groundDist)\n        toreturn = vec2(groundDist, groundID);\n    if(shape == torusDist)\n         toreturn = vec2(torusDist, torusID);   \n     if(shape == sphereDist)\n         toreturn = vec2(sphereDist, sphereID);\n     return toreturn;\n}\nvec3 RayMarch(vec3 ro, vec3 rd, int steps) \n{\n    vec2 dS;\n    float dO;\n    vec3 p;\n    for(int i = 0; i<steps; i++)\n    {\n        p = ro + rd * dO;\n        dS = GetDist(p);\n        if(dS.x < 0.0001) {break;}\n        dO += dS.x;\n    }     \n    return vec3(dO,dS);\n}\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p).x;\n    vec2 e = vec2(.01, 0);\n \n    vec3 n = d-vec3(GetDist(p-e.xyy).x, \n                        GetDist(p-e.yxy).x, \n                        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\nfloat GetLight(vec3 p, vec3 normal, vec3 lightpos, float lightpower, float shadowstrength, int steps)\n{\n    vec3 l = normalize(lightpos - p);\n    float dif = clamp(dot(normal, l*lightpower), 0., 1.);\n    if(steps > 0) // shadows\n    {\n        float d = RayMarch(p + normal*0.2, l, steps).x;\n        if(d < length(lightpos-p))\n            dif *= shadowstrength;\n    }\n    return dif;\n}\nfloat specularReflection(vec3 p, vec3 normal, vec3 rd, vec3 lightPos, float intensity, float shininessVal)\n{\n    vec3 L = normalize(lightPos - p);\n    float lambertian = max(dot(L, normal), 0.0);\n    float specular = 0.;\n  \tif(lambertian > 0.0 ) {\n        vec3 R = reflect(-L, normal); // Reflected light vector\n        vec3 V = normalize(-rd); // Vector to viewer\n        // Compute the specular term\n        float specAngle = max(dot(R, V), 0.0);\n        specular = pow(specAngle, shininessVal);\n  \t}\n    return specular * intensity;\n}\nfloat calcOcclusion(vec3 p) // calcOcclusion by iq\n{\n    vec3 n = GetNormal(p);\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = p + h*n;\n        float d = GetDist(opos).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\nvec3 GetCol(vec3 ro, vec3 rd, vec3 p, vec3 d) \n{\n    vec3 ret = vec3(0);\n    vec3 n = GetNormal(p);\n\tfloat dif = GetLight(p, n, LightPos(), 1., 0.,  0); //***\n    float spRef = specularReflection(p, n, rd, LightPos(), 1., 5.);\n\n    if(d.z == 1.) // Floor Col\n    {        \n        vec3 gif = SpaceGif(p.xz);\n        vec3 hive = Hive(p.xz, 2., 100.)*dif;\n        float hex = smoothstep(-0.7,1.,sin(HexDist(p.xz)*0.9 - time*2.));\n        //ret = lum(hex)*hive;\n        ret = dot(ret, vec3(0.2126, 0.7152, 0.0722))*vec3(hex) * hive;\n        // apply gif\n        ret = vec3(gif * hex);\n        ret += hive * (1.-hex);\n        \n        // fire look at the center\n        //ret *= gif;\n\n        vec3 circle;\n        float circler = 4.;\n        circle = vec3(smoothstep(circler, circler+10., length((p.xz ))));\n        ret -= circle*ret;\n        circle *= (hive);\n        ret += circle;\n        \n        // add some \"lava\" at the edges of the screen\n        // rotate for hiding the line caused by polar coordinate\n        p.xz = RotY(vec3(p.x,1.,p.z), -0.8).xz;\n        vec2 lava_uv_polar;\n        lava_uv_polar.x = (length(p.xz))*0.1;\n        lava_uv_polar.y = atan(p.x,p.z);\n        lava_uv_polar *= 3.;\n        vec3 tex = 5.*pow(texture(iChannel2,lava_uv_polar).xyz, vec3(5.));\n        tex = clamp(tex, 0., 1.);\n        float tex_mask = smoothstep(0.03, 0.18,length(p.xz*0.015)); \n        \n        ret = mix(ret, ret*tex.xxx*vec3(0.918,0.408,0.035), tex_mask);\n        \n        //ret *= dif;\n\n        ret += spRef*0.3;\n        //ret = vec3(1.);\n        float sphere_mask = smoothstep(sphereRad*0.5, sphereRad*1.8, length(p.xz));\n        ret *= sphere_mask;\n        //ret += 1.-sphere_mask;\n    }\n    if(d.z == 2.) // Torus Col\n    {        \n        ret = vec3(1);\n        vec3 pNew = torusTransform(p);\n        vec3 col =  toruscol(pNew, torus1Pos, torus1Size, 0.);\n        ret = dif*col;\n        ret += spRef;\n    }\n    if(d.z == 3.) // Sphere Col\n    {\n        ret = sphereCol(RotZ(RotX(RotY(p,SPHERE_ROTY_SPEED), PI + 0.8), -0.9), spherePos, sphereRad);\n        ret *= dif;\n        \n        float edge_mask = smoothstep(sphereRad, sphereRad*0.8, length(p.xz));\n        ret *= edge_mask;\n        //ret += 1.-edge_mask;\n\n        //ret += spRef;\n\n    }\n\n    return ret;\n}\n\nvec3 getScene(vec2 uv)\n{\n    vec3 ret = vec3(0);\n    \n    vec3 lookat = cameralookat();\n    float zoom = 1.;// + 0.15*sin(time*0.4);//0.5 + 0.3*sin(time*0.326);\n    vec3 ro = camerapos();\n    \n    vec3 F = normalize(lookat-ro); // Forward\n    vec3 Ri = normalize(cross(vec3(0., 1., 0.), F)); //Right\n    vec3 U = cross(F, Ri); //Up\n    vec3 C = ro + F*zoom;\n    vec3 I = C + uv.x*Ri + uv.y*U;\n    vec3 rd = normalize(I-ro);\n    \n    vec3 d = RayMarch(ro,rd, MaxSteps);\n    vec3 p = ro + rd*d.x;\n    \n    ret = GetCol(ro, rd, p, d);\n    \n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 R = iResolution.xy,\n    //uv = fragCoord / R.y;                     // [0,1] vertically\n    //uv = ( 2.*fragCoord - R ) / R.y;          // [-1,1] vertically\n    //uv = ( fragCoord - .5*R ) / R.y;          // [-1/2,1/2] vertically\n    //uv = ( 2.*fragCoord - R ) / min(R.x,R.y); // [-1,1] along the shortest side\n\n    uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    bass = GET_BASS;\n    mid = GET_MID;\n    treb = GET_TREB;\n    sound = GET_SOUND;\n    bass_cont = GET_BASS_CONT;\n    mid_cont = GET_MID_CONT;\n    treb_cont = GET_TREB_CONT;\n    sound_cont = GET_SOUND_CONT;\n\n    vec3 col = getScene(uv);\n    \n    //col = SpaceGif(uv*15.);//\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}