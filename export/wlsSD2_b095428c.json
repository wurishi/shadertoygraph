{"ver":"0.1","info":{"id":"wlsSD2","date":"1564410627","viewed":372,"name":"triagulated landscape","username":"run","description":"A landscape consiting of triangles. Raymarched. Please note that I only wrote the SDF, the raymarcher, shading and texture was grabbed from some other shadertoy implementation.","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["triangulatedsdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//------------------------------------------------------------------------\n// Here rather hacky and very basic sphere tracer, feel free to replace.\n//------------------------------------------------------------------------\n\n// fField(p) is the final SDF definition, declared at the very bottom\n\n#define PI 3.14159265\n\nconst int iterations = 200;\nconst float dist_eps = .001;\nconst float ray_max = 200.0;\nconst float fog_density = .03;\n\nconst float cam_dist = 5.;\n\nfloat fField(vec3 p);\n\nvec3 dNormal(vec3 p)\n{\n   const vec2 e = vec2(.005,0);\n   return normalize(vec3(\n      fField(p + e.xyy) - fField(p - e.xyy),\n      fField(p + e.yxy) - fField(p - e.yxy),\n      fField(p + e.yyx) - fField(p - e.yyx) ));\n}\n\nvec4 trace(vec3 ray_start, vec3 ray_dir)\n{\n   float ray_len = 0.0;\n   vec3 p = ray_start;\n   for(int i=0; i<iterations; ++i) {\n   \t  float dist = fField(p) / 4.;\n      if (dist < dist_eps) break;\n      if (ray_len > ray_max) return vec4(0.0);\n      p += dist*ray_dir;\n      ray_len += dist;\n   }\n   return vec4(p, 1.0);\n}\n\n// abs(0+0-1)=1\n// abs(1+0-1)=0\n// abs(0+1-1)=0\n// abs(1+1-1)=1\nfloat xnor(float x, in float y) { return abs(x+y-1.0); }\n\nvec4 checker_texture(vec3 pos, float sample_size)\n{\n\n   \n   vec4 path_line_color = vec4(0., 0., 1.0, 1.0); \n   vec4 sep_line_color = vec4(0., 0., 1.0, 1.0);\n   vec4 ground_color = vec4(.1, .1, .1, 1.0);\n    \n   float tile_size = 0.3;\n   float line_width = 0.01;\n   float tpx = mod(pos.x - line_width / 2., tile_size);\n   float tpz = mod(pos.z - line_width / 2., tile_size);\n   if (pos.x > 0. && pos.x < 0.6) {\n      return vec4(1.0);\n   }   \n    if (tpx < line_width) {\n    \treturn sep_line_color;\n    } else if (tpz < line_width) {\n        return sep_line_color;\n    } else if (tpz + tpx > tile_size && tpz + tpx < tile_size + line_width) {\n        return sep_line_color;\n    } else {\n    \treturn ground_color;\n    }\n    \n    \n   pos = pos*8.0 + .5;\n   vec3 cell = step(1.0,mod(pos,2.0));\n   float checker = xnor(xnor(cell.x,cell.y),cell.z);\n   vec4 col = mix(vec4(.4),vec4(.5),checker);\n   float fade = 1.-min(1.,sample_size*24.); // very fake \"AA\"\n   col = mix(vec4(.5),col,fade);\n   pos = abs(fract(pos)-.5);\n   float d = max(max(pos.x,pos.y),pos.z);\n   d = smoothstep(.45,.5,d)*fade;\n   return mix(col,vec4(0.0),d);\n}\n\nvec3 sky_color(vec3 ray_dir, vec3 light_dir)\n{\n   float d = max(0.,dot(ray_dir,light_dir));\n   float d2 = light_dir.y*.7+.3;\n   vec3 base_col;\n   base_col = mix(vec3(.3),vec3((ray_dir.y<0.)?0.:1.),abs(ray_dir.y));\n   return base_col*d2;\n}\n\nvec4 debug_plane(vec3 ray_start, vec3 ray_dir, float cut_plane, inout float ray_len)\n{\n    // Fancy lighty debug plane\n    if (ray_start.y > cut_plane && ray_dir.y < 0.) {\n       float d = (ray_start.y - cut_plane) / -ray_dir.y;\n       if (d < ray_len) {\n           vec3 hit = ray_start + ray_dir*d;\n           float hit_dist = fField(hit);\n           float iso = fract(hit_dist*5.0);\n           vec3 dist_color = mix(vec3(.2,.4,.6),vec3(.2,.2,.4),iso);\n           dist_color *= 1.0/(max(0.0,hit_dist)+.001);\n           ray_len = d;\n           return vec4(dist_color,.1);\n      }\n   }\n   return vec4(0);\n}\n\nvec3 shade(vec3 ray_start, vec3 ray_dir, vec3 light_dir, vec4 hit)\n{\n   vec3 fog_color = sky_color(ray_dir, light_dir);\n   \n   float ray_len;\n   vec3 color;\n   if (hit.w == 0.0) {\n      ray_len = 1e16;\n      color = fog_color;\n   } else {\n      vec3 dir = hit.xyz - ray_start;\n      vec3 norm = dNormal(hit.xyz);\n      float diffuse = max(0.0, dot(norm, light_dir));\n      float spec = max(0.0,dot(reflect(light_dir,norm),normalize(dir)));\n      spec = pow(spec, 16.0)*.5;\n       \n      ray_len = length(dir);\n   \n      vec3 base_color = checker_texture(hit.xyz,ray_len/iResolution.y).xyz;\n      color = mix(vec3(0.,.1,.3),vec3(1.,1.,.9),diffuse)*base_color +\n         spec*vec3(1.,1.,.9);\n\n      float fog_dist = ray_len;\n      float fog = 1.0 - 1.0/exp(fog_dist*fog_density);\n      color = mix(color, fog_color, fog);\n   }\n   \n   \n    \n   float cut_plane0 = sin(iTime)*.15 - .8;\n   for(int k=0; k<4; ++k) {\n      vec4 dpcol = debug_plane(ray_start, ray_dir, cut_plane0+float(k)*.75, ray_len);\n      //if (dpcol.w == 0.) continue;\n      float fog_dist = ray_len;\n      dpcol.w *= 1.0/exp(fog_dist*.05);\n      //color = mix(color,dpcol.xyz,dpcol.w);\n   }\n\n   return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n   vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    \n   vec3 light_dir = normalize(vec3(.5, 1.0, -.25));\n   \n   // Simple model-view matrix:\n   float ang, si, co;\n   ang = iTime*.25;\n   si = sin(ang); co = cos(ang);\n   mat4 cam_mat = mat4(\n      co, 0., si, 0.,\n      0., 1., 0., 0.,\n     -si, 0., co, 0.,\n      0., 0., 0., 1.);\n   ang = iTime*.2;\n   si = sin(ang); co = cos(ang);\n   cam_mat = cam_mat * mat4(\n      1., 0., 0., 0.,\n      0., co, si, 0.,\n      0.,-si, co, 0.,\n      0., 0., 0., 1.);\n\n   vec3 pos = vec3(cam_mat*vec4(0., 0., -cam_dist, 1.0));\n   vec3 dir = normalize(vec3(cam_mat*vec4(uv, 1., 0.)));\n   \n   vec3 color = shade(pos, dir, light_dir, trace(pos, dir));\n   color = pow(color,vec3(.44));\n   fragColor = vec4(color, 1.);\n}\n\n//------------------------------------------------------------------------\n// Your custom SDF\n//------------------------------------------------------------------------\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n\nfloat noise(vec2 p, float unit){\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = mod(p,unit)/unit;\n\t//xy = 3.*xy*xy-2.*xy*xy*xy;\n\txy = .5*(1.-cos(PI*xy));\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat bumpy_terrain(vec3 p) {\n \tfloat large_scale_noise = noise(vec2(p.x, p.z), 1.) - noise(vec2(0., p.z), 1.);\n    float small_scale_noise = noise(vec2(p.x, p.z), .2) - noise(vec2(0., p.z), .2);\n    return p.y + 1.0 * cos(p.x) - 0.3 * small_scale_noise - 1.0 * large_scale_noise;   \n}\n\nfloat fField(vec3 p)\n{   \n    //pMod3(p, vec3(1.));\n    float tile_size = 0.3;\n    // Snap point x and y. Snapped to the tile below.\n    float tpx = mod(p.x, tile_size);\n    float tpz = mod(p.z, tile_size);\n    float spx = p.x - tpx;\n    float spz = p.z - tpz;\n    \n    float t00 = bumpy_terrain(vec3(spx, p.y, spz));\n    float d00t01 = bumpy_terrain(vec3(spx, p.y, spz - tile_size)) - t00;\n    float d00t10 = bumpy_terrain(vec3(spx - tile_size, p.y, spz)) - t00;\n    float t11 = bumpy_terrain(vec3(spx - tile_size, p.y, spz - tile_size));\n    float d11t01 = bumpy_terrain(vec3(spx, p.y, spz - tile_size)) - t11;\n    float d11t10 = bumpy_terrain(vec3(spx - tile_size, p.y, spz)) - t11;\n    \n    if (tpx + tpz > tile_size) {\n        return t00 + d00t10 * (1. - tpx / tile_size) + d00t01 * (1. - tpz / tile_size);\n    } else {\n        return t11 + d11t01 * tpx / tile_size + d11t10 * tpz / tile_size;// + d11t01 * (1. - tpz / tile_size);\n    }\n    \n\t\n                              \n    \n    return mod(p.x, tile_size) * bumpy_terrain(vec3(spx, p.y, spz)) + (tile_size - mod(p.x, tile_size)) * bumpy_terrain(vec3(spx - tile_size, p.y, spz));\n    //return bumpy_terrain(p);\n}\n","name":"Image","description":"","type":"image"}]}