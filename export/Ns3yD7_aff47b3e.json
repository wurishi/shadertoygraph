{"ver":"0.1","info":{"id":"Ns3yD7","date":"1653580200","viewed":60,"name":"gfx_final_proj","username":"pbohlman","description":"value-noise based terrain","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.);\n\n    // read color from Buffer A output \n    col = texture(iChannel0, uv).xyz;\n\n    // gamma correct\n    col = clamp(pow(col, vec3(1./2.2)), 0., 1.);\n     \n    fragColor = vec4(col, 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Ray tracing in one weekend basecode for Dartmouth CS 77/177 \n// by Wojciech Jarosz, 2019\n\n#define EPSILON 1e-3 \n#define MAX_FLOAT 1e5\n#define MAX_RECURSION 5\n\n/////////////////////////////////////////////////////////////////////////////\n//////////////////////// RANDOM NUMBERS CODE ////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////\n\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nfloat g_seed = 0.;\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nvoid init_rand(in vec2 frag_coord, in float time) {\n    g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+time;\n}\n\n\nfloat rand1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 rand2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 rand3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n\nvec2 random_in_unit_disk(inout float seed) {\n    vec2 h = rand2(seed) * vec2(1.,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r * vec2(sin(phi),cos(phi));\n}\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = rand3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n//////////////////////// fBm CODE ///////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////\n\n// map fragment coordinates to world coordinates\n//vec2 frag2World(in vec2 frag)\n//{\n    //vec2 uv = frag.xy / iResolution.xy - 0.5;\n\t//return uv*vec2(iResolution.x/iResolution.y, 1.0)*10.0;\n//}\n\nfloat falloff(float t)\n{\n    float t2 = clamp(0., 1., abs(t));\n    \n    // use smoothstep S function \n    return 1. - smoothstep(0., 1., t2);\n    \n    // use tent function\n    //else\n        //return 1. - t2;\n}\n\nvec2 grad(vec2 center)\n{\n    // iD rand angle\n    float angle = radians(360.*hash12(center));\n    \n    // add animation\n    // if (isKeyToggled(KEY_F))\n    //     angle *= iTime * 2.;\n    \n    vec2 g = vec2(cos(angle), sin(angle));\n    \n    // direction of the gradient based on mouse position\n    //vec2 g = vec2(frag2World(iMouse.xy) - center);\n    return g;\n}\n\nfloat bump_value(vec2 p, vec2 center)\n{\n    vec2 offset = p - center;\n    \n    float b =  falloff(offset.x) * falloff(offset.y);\n    float v = 2. * hash12(center) - 1.;\n    \n    return v * b;\n}\n\nfloat bump_grad(vec2 p, vec2 center)\n{\n    vec2 offset = p - center;\n    \n    float b =  falloff(offset.x) * falloff(offset.y);\n    float v = dot(offset, grad(center));\n\n    return v * b;\n}\n\n// signed noise\n// return value in [-1,1]\nfloat snoise(vec2 p)\n{\n    float results = 0.;\n    \n    // lower left corner of integer latice\n    vec2 ll = floor(p);\n    \n    results += bump_grad(p, ll + vec2(0.));\n    results += bump_grad(p, ll + vec2(1., 0.));\n    results += bump_grad(p, ll + vec2(1., 1.));\n    results += bump_grad(p, ll + vec2(0., 1.));\n\n    return results;\n}\n\nfloat fractalSum(vec2 p, float H, float octaves)\n{\n    float value = 0.;\n    float w = 1.0;\n    float si = sin(0.64);\n    float co = cos(0.64);\n    mat2 m = 2.* mat2(co, si,\n                      -si, co);\n    \n    // inner loop of fractal constructions\n    for (float i = octaves; i > 0.; i --)\n    {\n        float f = snoise(p);\n        // for turbulance use abs\n        //if (isKeyToggled(KEY_T))\n            //f = abs(f);\n            \n        float fade = min(1.0, i);\n        \n        p *= m;\n        w *= pow(2., -H);\n        value += fade * w * f;\n        \n    }\n    return value;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n//////////////////////// SDF CODE ///////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////\n\n// returns the signed distance to a sphere from position p\nfloat sdSphere(vec3 p, float r)\n{\n \treturn length(p) - r;\n}\n\n// returns the signed distance to a box from position p\nfloat sdBox( vec3 p, vec3 half_bounds )\n{\n    vec3 loc = abs(p) - half_bounds;\n    \n    return length(max(loc, 0.)) + min(max(max(loc.x, loc.z), loc.y), 0.);\n}\n\n// returns the signed distance to a cylinder from position p\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b - a;\n    float height = length(ab);\n    vec3 pa = p-a;\n    float t = dot(pa, ab) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float dist_circ = length(p-c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float outside = length(vec2(max(dist_circ, 0.), max(y, 0.)));\n    float inside = min(max(dist_circ, y), 0.);\n    return outside + inside;\n}\n    \n\n// returns the signed distance to a cone from position p\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    vec3 ab = b - a;\n    float height = length(ab);\n    vec3 pa = p-a;\n    float t = dot(pa, ab) / dot(ab, ab);\n    float r = mix(ra, rb, t);\n    vec3 c = a + t * ab;\n    float dist_circ = length(p-c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float outside = length(vec2(max(dist_circ, 0.), max(y, 0.)));\n    float inside = min(max(dist_circ, y), 0.);\n    return outside + inside;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 ab = b - a;\n    vec2 pa = p-a;\n    vec2 pb = p-b;\n    vec2 pab = min(max(dot(pa, ab) / dot(ab, ab), 0.), 1.) * ab;\n    return min(min(length(pa), length(pb)), length(p - (a + pab)));\n}\n\nfloat opSmoothUnion(float d1, float d2, float k)\n{\n    float h = max(k - abs(d1 - d2), 0.);\n    return min(d1, d2) - (h*h)/(4.*k);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k)\n{\n    float h = max(k - abs(d1 + d2), 0.);\n    return max(-d1, d2) + (h*h)/(4.*k);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = max(k - abs(d1 - d2), 0.);\n    return max(d1, d2) + (h*h)/(4.*k);\n}\n\nfloat opRound(float d, float iso)\n{\n    return -(iso - d);\n}\n\n// taken from https://iquilezles.org/articles/distfunctions/\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14156920\n#define INF 10000000000000000000000000000000.\n#define NUM_PRIMITIVES 2\n#define LAMBERTIAN 1\n#define METAL 2\n#define DIELECTRIC 3\n#define MAX_HEIGHT 200.\n\n/////////////////////////////////////////////////////////////////////////////\n//////////////////////// RAY TRACING CODE ///////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////\n\n//////////////////////// STRUCTS ////////////////////////////////////////////\n\nvec3  lookfrom = vec3(0., 250., 600.);\nvec3  lookat   = vec3( 0., 200., -200.);\nvec3 sun = vec3(1500.,1000.,-100.);\nvec3 brown = vec3(50./255.,50./255.,50./255.);\nvec3 green = vec3(0.34, 0.49, 0.27);\nvec3 white = vec3(1.);\nvec3 black = vec3(0.);\n\nvec3 sunColor = vec3(1.64,1.27,0.99);\nvec3 shadowColor = vec3(1.0,1.2,1.5);\nvec3 skyColor = vec3(0.16,0.20,0.28);\nvec3 indColor = vec3(0.40,0.28,0.20);\n\n// camera struct\nstruct camera\n{\n    float lens_radius;\n    vec3 u;\n    vec3 v;\n    vec3 w;\n    vec3 origin;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 lower_left_corner;\n    \n};\n\n// ray struct\nstruct ray\n{\n    vec3 o; // origin\n    vec3 d; // direction\n};\n\n\n// hit_record struct\nstruct hit_record {\n    vec3 p;\n    vec3 normal;\n    float t;\n    bool front;\n};\n\n\n////////////////////// FUNCTION DEFINITIONS //////////////////////////////////////\ncamera init_camera(float vfov, float aspect_ratio, float focal_dist, float aperture, vec3 lookfrom, vec3 lookat, vec3 up)\n{\n    \n    float theta = radians(vfov);\n    float height = tan(theta/2.);\n    \n    float viewport_height = 2.0 * height;\n    float viewport_width = aspect_ratio * viewport_height; \n    \n    float focal_length = 1.;\n    \n    vec3 w = normalize(lookfrom - lookat);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n    \n    vec3 origin = lookfrom;\n    vec3 horizontal = focal_dist * viewport_width * u;\n    vec3 vertical = focal_dist * viewport_height * v;\n    vec3 lower_left_corner = origin - horizontal/2. - vertical/2. - focal_dist * w;\n \n    float lens_radius = aperture/2.;\n    return camera(lens_radius,\n                    u,\n                    v,\n                    w,\n                    origin,\n                    horizontal,\n                    vertical,\n                    lower_left_corner);\n}\n\n\n\n// returns 2D value noise and its 2 derivatives\n// taken from https://www.shadertoy.com/view/4ttSWf\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    #if 1\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    #else\n    vec2 u = w*w*(3.0-2.0*w);\n    #endif\n\n    float a = hash12(p+vec2(0,0));\n    float b = hash12(p+vec2(1,0));\n    float c = hash12(p+vec2(0,1));\n    float d = hash12(p+vec2(1,1));\n    \n    return -1.0+2.0*(a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y);\n}\n\n\n// returns 3D fbm and its 3 derivatives\n// taken from https://iquilezles.org/articles/morenoise/\nfloat fbm( in vec2 x, int octaves )\n{\n    \n    \n    float freq  = 1.8;      // increase fequency at higher octaves\n    float scale = 0.5;      // reduce scale at higher octaves\n    float height= 0.0;      // initial noise value\n    float b = 0.8;          // initial scale value\n    vec2  d = vec2(0.0);    // for tracking derivatives (Not used atm)\n    \n    mat2  m = mat2(1.0,0.0, // identity mat\n                   0.0,1.0);\n    mat2  rotate_m = mat2(0.7,0.7, // rotation matrix\n                         -0.7,0.7);// approx 20 degree rotation              \n      \n    // add heterogeneity by \n    for( int i=0; i < octaves; i++ )\n    {\n        float n = noise(x);\n        \n        // float n = 1 - abs(noise(x));\n        \n        //a += n;\n        height += b*n;          // accumulate values\n        //d += b*m*n.yz;      // accumulate derivatives\n        b *= scale;\n        x = freq*rotate_m*x; // rotate coords for the next iteration\n       // m = f*m3i*m;\n    }\n    //return vec3( a, d );\n    return height;\n}\n\nfloat terrain_map(in vec2 x)\n{\n    // adjust these constants to generate different terrain.\n    float freq = .007; // freq in and z\n    float amp  = MAX_HEIGHT/2.;           // amplitude of the terrain\n    int octaves = 12;            // num fractal octaves to iterate\n    \n    return amp*fbm(freq*x, octaves) + amp;\n}\n\nvec3 getNormal( vec3 p )\n{\n    return normalize( vec3( terrain_map(vec2(p.x-EPSILON,p.z)) - terrain_map(vec2(p.x+EPSILON,p.z)),\n                            2.0*EPSILON,\n                            terrain_map(vec2(p.x,p.z-EPSILON)) - terrain_map(vec2(p.x,p.z+EPSILON)) ) );\n}\n\n// adapted from https://iquilezles.org/articles/terrainmarching/\nbool ray_march(in ray r, out float resT)\n{\n    \n    // Raising dt and lowering maxt will speed up performance\n    float dt = 0.05; // step size\n    float mint = 0.001; // minimum ray dist\n    float maxt = 10.0; // draw dist\n    \n    float lh = 0.0; \n    float ly = 0.0;\n    float h;\n    vec3 p;\n    \n    for (float t = mint; t < maxt; t += dt)\n    {\n        p = r.o + r.d*t;\n        h = terrain_map(p.xz);\n        \n        // terrain hit!\n        // replace with terrain height function\n        if (p.y < h)\n        {\n            // interpolate the intersection distance\n            resT = t - dt + dt*(lh-ly)/(p.y-ly-h+lh);\n            return true;\n        }\n        lh = h;\n        ly = p.y;\n    }\n    // no terrain hit\n    return false;\n}\n\n// HOW TO? Add soft shadows?\n// See 8:30 https://www.youtube.com/watch?v=BFld4EBO2RE\nfloat shadow(vec3 p)\n{\n    float res = 1.0;\n    vec3 to_sun = sun - p;\n    float dt = 0.05; // step size\n    float mint = 0.001; // minimum ray dist\n    float maxt = 10.0; // draw dist\n    vec3 loc;\n    \n    for (float t = mint; t < maxt; t += dt)\n    {\n        loc = p + t*to_sun;\n        float n = terrain_map(loc.xz);\n        if (loc.y < n)\n            return 0.;\n        res = min( res, (2.*(loc.y - n))/t );\n    }\n    \n    return res;\n\n}\n\n\n\nvec3 terrain_color(vec3 p, vec3 n)\n{\n\n\n\n    // dot the normal with straight up\n    float cosT = abs(dot(n, vec3(0.,1.,0.)));\n    \n    // if we're above a certain elevation\n    // add some noise to the 0.5 barrier to make it look more random\n    if (p.y > (MAX_HEIGHT*(0.5 + 0.05*hash12(p.xz)))){\n        // and we're a certain flatness\n        if (cosT > 0.5)\n            return white;\n        else\n            return brown;\n    }\n        \n    // we're below the snowy elevation\n    else\n    {\n        // and we're a certain flatness\n        if (cosT > 0.65)\n            return green;\n        else\n            return brown;\n    }\n        \n}\n\n// TODO: play with b... and consider the fog that varies in 3 directions\n//from https://iquilezles.org/articles/fog/\nvec3 applyFog(  vec3  rgb,       // original color of the pixel\n                float dist,      // camera to point distance\n                vec3  rayDir,    // camera to point vector\n                vec3  sunDir )   // sun light direction\n{\n    float b = 0.0005; // density coffieent\n    float fogAmount = 1.0 - exp( -dist*b );\n    \n    // TODO: consider this extra functionality below that mixes \n    //       yellow into the fog color depending on the camera's\n    //       angle relative to the sun\n    //float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    //vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish\n    //                      vec3(1.0,0.9,0.7), // yellowish\n    //                       pow(sunAmount,8.0) );\n                           \n    vec3  fogColor = vec3(0.5,0.6,0.7); \n    return mix( rgb, fogColor, fogAmount );\n}\n\nvec3 ray_color(ray r)\n{\n    float resT;\n    \n    // mars-type color, placeholder\n    vec3 brown = vec3(193./255.,68./255.,14./255.);\n    \n    // return terrain color\n    if (ray_march(r, resT))\n    {\n        vec3 p = r.o + r.d*resT;\n        vec3 n = getNormal(p);\n        vec3 to_sun = normalize(sun-p);\n        \n        // BASIC LIGHTING RIG TAKEN FROM\n        // https://iquilezles.org/articles/outdoorslighting/\n        \n        //float occ = doGorgeousOcclusion( pos, nor );\n        float sha = shadow(p);\n        float sun = clamp( dot(n, to_sun ), 0.0, 1.0 );\n        float sky = clamp( 0.5 + 0.5*n.y, 0.0, 1.0 );\n        float ind = clamp( dot( n, normalize(to_sun*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n\n        vec3 light = sun*sunColor*pow(vec3(sha),shadowColor);\n             light += sky*skyColor;\n             light += ind*indColor;\n\n        vec3 mat_color = terrain_color(p,n);\n        \n        vec3 color = mat_color*light;\n        \n        color = applyFog(color, distance(lookfrom, p), r.d, to_sun);\n        \n        return color;\n    }\n    // return sky color;\n    else\n    {\n        return skyColor;\n    }\n}\n\n\n\n// MAIN /////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect_ratio = iResolution.x / iResolution.y;\n    float image_width = iResolution.x;\n    float image_height = iResolution.y;\n    int depth = 200;\n\n    // Camera\n    //vec3  lookfrom = vec3(0., 400., 0.);\n    //vec3  lookat   = vec3( 60., 250., 0.);\n    vec3  up       = vec3( 0., 1., 0.);\n    float dist     = 200.;\n    float aperture = 0.;\n    \n    camera cam = init_camera(20., aspect_ratio, dist, aperture, lookfrom, lookat, up);\n    //camera cam = init_camera(90., aspect_ratio, vec3(0., 0., 0.), vec3(0., 0., -1.), vec3(0., 1., 0.));\n    //init_rand(fragCoord, float(iTime));\n    init_rand(fragCoord, 0.); \n    // Render\n    //ray r = ray(cam.origin, cam.lower_left_corner + uv.x*cam.horizontal + uv.y*cam.vertical - cam.origin);\n    vec3 col = vec3(0.);\n    vec3 accumulated_col = vec3(0.);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord + rand2(g_seed))/iResolution.xy;\n    \n    // get the starting ray\n    vec3 rand_disk = vec3(cam.lens_radius * random_in_unit_disk(g_seed), 0.);\n    vec3 cam_u = cam.u;\n    vec3 cam_v = cam.v;\n    vec3 offset = cam_u * rand_disk.x + cam_v * rand_disk.y;\n    ray r = ray(cam.origin + offset, cam.lower_left_corner + uv.x*cam.horizontal + uv.y*cam.vertical - cam.origin - offset);\n    \n    // calculate the color\n    col = ray_color(r);\n\n    // get color from buffer\n    //accumulated_col = texture(iChannel1, fragCoord/iResolution.xy).xyz;\n    // average color from buffer with just calculated color\n    //accumulated_col = mix(accumulated_col, col, 1./float(iFrame +1));\n        \n    //fragColor = vec4(accumulated_col, 1.0);\n    \n    fragColor = vec4(col, 1.0);\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}