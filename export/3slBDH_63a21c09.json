{"ver":"0.1","info":{"id":"3slBDH","date":"1588174051","viewed":177,"name":"Stained Glass Dancer","username":"spalmer","description":"Please don't bother the nice lady, just let her dance in peace.\nSaw one of flockaroo's toys, tried to get it to do this, gave up and then thought, hey, maybe I can get my old lame stained glass voronoise to do it.  Voila!","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","glass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// pseudo-random point locations\nvec2 rpoint(int i)\n{\n    return sin(float(i)*vec2(32.1,31.1) + floor(iDate.z))\n\t\t* vec2(iResolution.x/iResolution.y,1)\n        ;\n}\n\nvec2 StoQ(vec2 s,vec2 r)\n{\n    return (s+s-r)/r.y;\n}\n\nfloat edge(vec2 q, vec2 a, vec2 b)\n{\n\treturn abs(dot(q-(a+b)*.5,normalize(a-b)));\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    vec2 R = iResolution.xy\n    , q = StoQ(p,R);\n    int index = 0;\n    const int npts = 1 << 7;\n    // since not limiting search to the closest points\n    // by some spatial hash, just using naive iteration,\n    // just does not perform well.  Won't scale.  FIXME\n    // usually folks use some jittered grid instead\n    // of some loose bag of randomly scattered points\n    // but this is just a toy!\n    float d = 9e9;\n    for (int n = npts; --n >= 0; ) {\n\t\tfloat t = distance(q, rpoint(n));\n        if (t < d) { d = t; index = n; }\n    }\n    const float bevel = .03;\n    float g = 9e9;\n    vec2 p_i = rpoint(index);\n    for (int n = npts; --n >= 0; ) {\n        if (n == index) continue;\n        vec2 b = rpoint(n);\n\t\tfloat t = edge(q, p_i, b);\n        if (t < g) { g = t; }\n    }\n    g = min(g, bevel);\n    // fake hue tint\n    vec2 grad = vec2(dFdx(g),dFdy(g)) * R * .1; // auto derivatives aren't great quality.\n\t// some fine noise texture bumps\n    q *= .03;\n    vec2 bnoise2 = textureLod(iChannel1, q, 0.).xy * 2. - 1.;\n    bnoise2 += textureLod(iChannel1, q*2., 0.).xy * 1. - .5;\n    bnoise2 = 1. - 2. * abs(bnoise2); // ridged\n    grad += bnoise2 * .0015;\n    vec3 col = .25 + .5*cos(float(index)*10.1664074+vec3(0,2,4)*1.04719755);\n    col *= 1.-exp2(-250.*max(0., g - .005));\n    col = mix(clamp(col, 0., 1.), vec3(1), .5);\n    vec2 refr = p/R;\n    refr += .08f*vec2(sin(iTime*.03),cos(iTime*.03));\n    refr += 25. * refract(vec3(0,0,1),vec3(grad,-1),.3).xy;\n\t// Britney dancing behind the window, slightly blurred!  \n    // Got inspired by a toy by flockaroo :)\n    vec3 tex = textureLod(iChannel0, refr, 0.).rgb;\n    col *= mix(pow(tex, vec3(2.2)), vec3(1), .5);\n    // fake lighting\n    float l = max(0.,mix(dot(grad, 3.*.707*vec2(1,-1)), 1., .25));\n//    col /= length(grad) * .1 + 1.;\n    col += .15*pow(max(0.,l), 1.2); // 'specular'\n\tcol = pow(col, vec3(1./2.2));\n    c = vec4(col,1.0);\n}\n\n// TODO there should be lead soldering the panes together\n\n","name":"Image","description":"","type":"image"}]}