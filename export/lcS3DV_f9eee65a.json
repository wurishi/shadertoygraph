{"ver":"0.1","info":{"id":"lcS3DV","date":"1704638087","viewed":53,"name":"star and krystal","username":"nayk","description":"stars, krystal, cosmos,  universe","likes":1,"published":1,"flags":1,"usePreview":0,"tags":["stars","cosmos","universe","krystal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*originals https://www.shadertoy.com/view/lslyRn# https://www.shadertoy.com/view/ftlyRS*/\n\n#define iterations 14\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\nvec3 V[] = vec3[](\n         vec3( 0  , 0  , 1   ), \n         vec3( .58, .33, .75 ), \n         vec3( 0  ,-.67, .75 ), \n         vec3(-.58, .33, .75 ),\n         vec3( .36, .87, .33 ),\n         vec3( .93,-.13, .33 ), \n         vec3( .58,-.75, .33 ), \n         vec3(-.58,-.75, .33 ), \n         vec3(-.93,-.13, .33 ), \n         vec3(-.36, .87, .33 ), \n         vec3( .58, .75,-.33 ),\n         vec3( .93, .13,-.33 ), \n         vec3( .36,-.87,-.33 ), \n         vec3(-.36,-.87,-.33 ), \n         vec3(-.93, .13,-.33 ),  \n         vec3(-.58, .75,-.33 ),  \n         vec3( 0  , .67,-.75 ),  \n         vec3( .58,-.33,-.75 ), \n         vec3(-.58,-.33,-.75 ), \n         vec3( 0  , 0  ,-1   ) \n      );\n             \nint S[] = int[] (    0, 2, 6, 5, 1  // 3 bottom\n                   , 0, 3, 8, 7, 2\n                   , 0, 1, 4, 9, 3\n                   , 2, 7,13,12, 6  // 6 crown\n                   , 8,14,18,13, 7\n                   , 6,12,17,11, 5\n                   , 3, 9,15,14, 8\n                   , 1, 5,11,10, 4 \n                   , 4,10,16,15, 9\n                   ,19,18,14,15,16  // 3 top\n                   ,19,17,12,13,18\n                   ,19,16,10,11,17\n  );\n#define S(i) S[clamp(i,0,59)]\n\nfloat segment(vec2 p, vec3 A, vec3 B) {\n    vec2  a = A.xy, \n          b = B.xy - a;\n         p -= a;\n    float h =  clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return    length(p - b * h ) \n           + .01* mix(A.z, B.z, h);  // thickness immitating apparent width (NB: shouldn't be linear)\n}\n\n#define R      iResolution.xy\n#define rot(a) mat2(cos(a+vec4(0,33,11,0)))\n\nvec3 T(vec3 p) {\n    vec2 M = iMouse.xy;          // camera rotation\n    M = length(M) > 10.\n      ? ( 2.*M/R - 1. ) * 3.14\n      : iTime/vec2(8,-5);\n    p.yz *= rot( M.y),  // theta\n    p.zx *= rot(-M.x);  // phi\n  \n    return p / ( p.z - 1.7 ); // perspective projection ( + z )\n}\n\n#define rot3(P,A,a) ( mix( A*dot(P,A), P, cos(a) ) + sin(a)*cross(P,A) )\n#define sf(t)       ( floor(t) + smoothstep(1.,0., (1.-fract(t))/.8)) // smoothfloor https://www.shadertoy.com/view/4t3SD7 \n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.02),sin(iTime*0.02),-sin(iTime*0.02),cos(iTime*0.02));\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.02,1.);\t\n}\nfloat cheap_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\n#define DTR 0.01745329\n#define rot2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec2 uv;\nvec3 cp,cn,cr,ro,rd,ss,oc,cc,gl,vb;\nvec4 fc;\nfloat tt,cd,sd,io,oa,td;\nint es=0,ec;\n\nfloat bx(vec3 p,vec3 s){vec3 q=abs(p)-s;return min(max(q.x,max(q.y,q.z)),0.)+length(max(q,0.));}\nfloat smin(float a, float b, float k){float h=clamp(0.5+0.5*(b-a)/k,0.,1.);return mix(b,a,h)-k*h*(1.-h);}\n\nvec3 lattice(vec3 p, int iter, float an)\n{\n\t\tfor(int i = 0; i < iter; i++)\n\t\t{\n\t\t\tp.xy *= rot(an*DTR);\n\t\t\tp.yz=abs(p.yz)-1.;\n\t\t\tp.xz *= rot(-an*DTR);\n\t\t}\n\t\treturn p;\n}\n\nfloat mp(vec3 p)\n{\n//now with mouse control\nif(iMouse.z>0.){\n    p.yz*=rot(2.0*(iMouse.y/iResolution.y-0.5));\n    p.zx*=rot(-7.0*(iMouse.x/iResolution.x-0.5));\n}\n\t\tvec3 pp=p;\n\t\t\n\t\tp.xz*=rot(tt*0.1);\n\t\tp.xy*=rot(tt*0.1);\n\n\t\tp=lattice(p,9,45.+cos(tt*0.1)*5.);\n\t\n\n\t\tsd = bx(p,vec3(1)) - 0.01;\n\t\n\t\tsd = smin(sd, sd, 0.8);\n\n\t\tgl += exp(-sd*0.001) * normalize(p*p) * 0.003;\n\t\n\t\tsd=abs(sd)-0.001;\n\n\t\tif(sd<0.001)\n\t\t{\n\t\t\toc=vec3(1);\n\t\t\tio=1.2;\n\t\t\toa=0.0;\n\t\t\tss=vec3(0);\n\t\t  vb=vec3(0.,10,2.8);\n\t\t\tec=2;\t\n\t\t}\n\t\treturn sd;\n}\n\nvoid tr(){vb.x=0.;cd=0.;for(float i=0.;i<256.;i++){mp(ro+rd*cd);cd+=sd;td+=sd;if(sd<0.0001||cd>128.)break;}}\nvoid nm(){mat3 k=mat3(cp,cp,cp)-mat3(.001);cn=normalize(mp(cp)-vec3(mp(k[0]),mp(k[1]),mp(k[2])));}\n\nvoid px()\n{\n  cc=vec3(00.55,0.55,0.55)+length(pow(abs(rd+vec3(0,0.5,0)),vec3(3)))*1.3+gl;\n  vec3 l=vec3(0.9,0.7,0.5);\n  if(cd>128.){oa=1.;return;}\n  float df=clamp(length(cn*l),0.,1.);\n  vec3 fr=pow(1.-df,3.)*mix(cc,vec3(0.4),0.5);\n\tfloat sp=(1.-length(cross(cr,cn*l)))*0.2;\n\tfloat ao=min(mp(cp+cn*0.3)-0.3,0.3)*0.4;\n  cc=mix((oc*(df+fr+ss)+fr+sp+ao+gl),oc,vb.x);\n}\n\nvoid render(vec2 frag, vec2 res, float time, out vec4 col)\n{\n\ttt=mod(time+25., 260.);\n  uv=vec2(frag.x/res.x,frag.y/res.y);\n  uv-=0.5;uv/=vec2(res.y/res.x,1);\n\tfloat an = (sin(tt*0.3)*0.5+0.5);\n    an = 3.-pow(1.-pow(an, 5.),10.);\n  ro=vec3(0,0,-5. - an*15.);rd=normalize(vec3(uv,1));\n  \n\tfor(int i=0;i<25;i++)\n  {\n\t\ttr();cp=ro+rd*cd;\n    nm();ro=cp-cn*0.01;\n    cr=refract(rd,cn,i%2==0?1./io:io);\n    if(length(cr)==0.&&es<=0){cr=reflect(rd,cn);es=ec;}\n    if(max(es,0)%3==0&&cd<128.)rd=cr;es--;\n\t\tif(vb.x>0.&&i%2==1)oa=pow(clamp(cd/vb.y,0.,1.),vb.z);\n\t\tpx();fc=fc+vec4(cc*oa,oa)*(1.-fc.a);\t\n\t\tif((fc.a>=1.||cd>128.))break;\n  }\n  col = fc/fc.a;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    \n    render(fragCoord.xy,iResolution.xy,iTime,fragColor);\n    \n    vec2 frag=fragCoord.xy;\n    vec2 res =iResolution.xy;\n    vec2 uv2=fragCoord.xy/iResolution.xy-.5;\n    float time2=iTime;\n    vec4 col =fragColor;\n    tt=mod(time2+25., 260.);\n  uv2=vec2(frag.x/res.x,frag.y/res.y);\n  uv2-=0.5;uv2/=vec2(res.y/res.x,1);\n\tfloat an = (sin(tt*0.3)*0.5+0.5);\n    an = 1.-pow(1.-pow(an, 5.),10.);\n  ro=vec3(10.,1,-5. - an*15.);rd=normalize(vec3(uv2,1));\n  \n\tfor(int i=0;i<25;i++)\n  {\n\t\ttr();cp=ro+rd*cd;\n    nm();ro=cp-cn*0.11;\n    cr=refract(rd,cn,i%2==0?1./io:io);\n    if(length(cr)==0.&&es<=0){cr=reflect(rd,cn);es=ec;}\n    if(max(es,0)%3==0&&cd<128.)rd=cr;es--;\n\t\tif(vb.x>0.&&i%2==1)oa=pow(clamp(cd/vb.y,1.,1.),vb.z);\n\t\tpx();fc=fc+vec4(cc*oa,oa)*(1.-fc.a);\t\n\t\tif((fc.a>=10.||cd>128.))break;\n  }\n  col = fc/fc.a;\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\n    \n    vec4 O =  fragColor;\n    vec2 U = fragCoord;\n U = ( 2.*U - R.xy ) / R.y;\n    O = vec4(1);\n    \n    for( int i,i0,i1; i <= S.length(); i++ ) {\n        vec3 A = V[ i0 = S(i-1) ],\n             B = V[ i1 = S(i%5 > 0 ? i : i-5) ],\n             M = normalize(A+B);\n       float t =  sf(iTime/2.);      \n       A = rot3(A,M,3.571*t)*cos(iTime); // tilting\n       B = rot3(B,M,3.571*t)*12.*cos(iTime);\n       t = mod(t,2.)+cos(iTime);\n       M = min(t,2.-t)* .26*(B-A)/2.+cos(iTime); A -= M; B += M; // adjust segment length\n       if ( i1 > i0 ) // draw segments only once \n           O -= smoothstep(2./R.y, -2./R.y, segment( U, T(A), T(B) ) -.007 );\n    }\n    \n    \n    \t\n\tvec3 from=vec3(1.,.5,0.5)*col.xyz;\n\tfrom+=vec3(time*2.,time,-2.);\n\t\n\t\n    \n\tmainVR(fragColor, fragCoord, from, dir);\n     uv *= 2.0 * ( cos(iTime * 2.0) -2.5);\n    \n    // anim between 0.9 - 1.1\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;    \n\n    fragColor*= vec4(cheap_star(uv,anim) * vec3(0.55,0.5,0.55)*1.1, 1.0);\n fragColor*= col;\n}\n","name":"Image","description":"","type":"image"}]}