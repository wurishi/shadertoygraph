{"ver":"0.1","info":{"id":"ddKBDR","date":"1698143014","viewed":69,"name":"Line-Circle 2D intersection","username":"jaszunio15","description":"Line-circle 2D intersection algorithm.\nLine is defined by the origin point and a direction.\n\nPosting this in case you find it useful for some reason.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["line","intersection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float DrawLine(vec2 uv, vec2 origin, vec2 direction, float width)\n{\n    float pixelSize = fwidth(uv.x);\n    vec2 tangent = normalize(vec2(-direction.y, direction.x));\n    return smoothstep(width * pixelSize + pixelSize * 0.5, width * pixelSize - pixelSize * 0.5, abs(dot(uv - origin, tangent)));\n}\n\nfloat DrawCircle(vec2 uv, vec2 center, float radius, float width)\n{\n    float sdf = distance(uv, center) - radius;\n    float pixelSize = fwidth(sdf);\n    return smoothstep((width * 0.5 + 1.0)*pixelSize, width * 0.5 * pixelSize, abs(sdf));\n}\n\nfloat DrawPoint(vec2 uv, vec2 coord, float size)\n{\n    float pixelSize = fwidth(uv.x);\n    return smoothstep(size * pixelSize + pixelSize * 0.5, size * pixelSize - pixelSize * 0.5, distance(uv, coord));\n}\n\n// returns true if there is an intersection\n// outPoint1, and outPoint2 will contain calculated intersection points\nbool LineCircleIntersection(vec2 lineOrigin, vec2 lineDirection, vec2 circleCenter, float circleRadius, out vec2 outPoint1, out vec2 outPoint2)\n{\n    lineDirection = normalize(lineDirection); // this line can be removed if you're sure that line direction is already normalized\n    \n    // That's the simplest solution I came up with.\n    vec2 lineTangent = lineDirection.yx * vec2(1.0, -1.0);\n    float distanceToLine = dot(lineTangent, lineOrigin - circleCenter);\n    \n    if (abs(distanceToLine) > circleRadius)\n        return false;\n    \n    vec2 middlePoint = circleCenter + lineTangent * distanceToLine;\n    float intersectionDistance = sqrt(circleRadius * circleRadius - distanceToLine * distanceToLine);\n    outPoint1 = middlePoint - lineDirection * intersectionDistance;\n    outPoint2 = middlePoint + lineDirection * intersectionDistance;\n    \n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n    float pixelSize = fwidth(uv.x);\n    \n    vec2 origin1 = vec2(cos(iTime * 0.5), sin(iTime * 0.4)) * 0.8;\n    vec2 direction1 = normalize(vec2(sin(iTime * 0.2), cos(iTime * 0.25)));\n    \n    vec2 circleCenter = vec2(sin(iTime * 0.58), cos(iTime * 0.41)) * 0.8;\n    float circleRadius = cos(iTime * 0.4) * 0.2 + 0.5;\n    \n    float line1 = DrawLine(uv, origin1, direction1, 1.0);\n    float circle = DrawCircle(uv, circleCenter, circleRadius, 1.0);\n    \n    fragColor = vec4(0.5, 1.0, 1.0, 1.0) * (line1 + DrawPoint(uv, origin1, 5.0));\n    fragColor += vec4(1.0, 0.5, 0.5, 1.0) * (circle + DrawPoint(uv, circleCenter, 5.0));   \n    \n    vec2 hit1, hit2;\n    if (LineCircleIntersection(origin1, direction1, circleCenter, circleRadius, hit1, hit2))\n    {\n        fragColor += vec4(0.0, 1.0, 0.0, 1.0) * DrawCircle(uv, hit1, pixelSize * 6.0, 1.0);\n        fragColor += vec4(0.0, 1.0, 0.0, 1.0) * DrawCircle(uv, hit2, pixelSize * 6.0, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}