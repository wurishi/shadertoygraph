{"ver":"0.1","info":{"id":"Mf3GRB","date":"1712006616","viewed":46,"name":"Dream Field","username":"Chromaney","description":"A combination of Perlin noise, color-changing texture and \"low-bit\" effects.\nDithering was designed to look more \"structured\" compared to Bayer matrix.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["2d","noise","dithering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader \"Dream Field\" by Chromaney.\n// Licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A combination of Perlin noise, color-changing texture and \"low-bit\" effects.\n// Dithering was designed to look more \"structured\" compared to Bayer matrix.\n\n// --------------------------------\n\n// Main effect code.\n\nfloat flip16(float x){\n    x = mod(x, 16.0);\n    float res = 0.0;\n    float mult = 8.0;\n    for (int i = 0; i < 4; i ++){\n        res += mult * mod(x, 2.0);\n        x = floor(x / 2.0);\n        mult /= 2.0;\n    }\n    return res;\n}\n\nfloat flip256(float x){\n    x = mod(x, 256.0);\n    float res = 0.0;\n    float mult = 128.0;\n    for (int i = 0; i < 8; i ++){\n        res += mult * mod(x, 2.0);\n        x = floor(x / 2.0);\n        mult /= 2.0;\n    }\n    return res;\n}\n\nfloat maskPattern(float x, float y){\n    float xm = mod(x, 16.0);\n    float ym = mod(mod(y, 16.0) + xm, 16.0);\n    float val = flip256(flip16(15.0 + flip16(ym) + xm) * 16.0 + flip16(flip16(xm) + ym));\n    return (val / (256.0 - 1.0));\n}\n\nfloat maskCoeff(float x, float y){\n    float val1 = maskPattern(x, y);\n    float val2 = maskPattern(y, x);\n    \n    float val = val1 + val2 - 2.0 * val1 * val2;\n    return val;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float fcScale = 4.0;\n    vec2 roughCoordInt = floor(fragCoord / fcScale);\n    vec2 roughCoord = roughCoordInt * fcScale / iResolution.xy;\n    \n    vec3 col = texture(iChannel0, roughCoord).xyz;\n    \n    float discrCoeff = 4.0;\n    float mask = maskCoeff(roughCoordInt.x, roughCoordInt.y);\n    \n    col += (mask - 0.5) / discrCoeff;\n    col = floor(col * discrCoeff) / (discrCoeff - 1.0);\n    \n    fragColor = vec4(pow(col, vec3(1.0 / 1.0)), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer for Perlin noise.\n\nvec4 hash2to4(vec2 coord){\n    vec4 col = vec4(0.0);\n    uint k = 835171995U;\n    uint a = uint(coord.x + 123.0);\n    uint b = uint(coord.y + 456.0);\n\n    uvec4 res = uvec4(a + k, b + k, a * b, k);\n    res = (res.zxwy * k + res.ywxz) ^ res.w;\n    res = (res.zxwy * k + res.ywxz) ^ res.z;\n    res = (res.zxwy * k + res.ywxz) ^ res.y;\n    res = (res.zxwy * k + res.ywxz) ^ res.x;\n\n    col = vec4(res.xyzw) / float(0xffffffffU);\n    return col;\n}\n\nvec4 blendFcn(vec4 a, vec4 b, float t){\n    //return (a + (b - a) * smoothstep(0.0, 1.0, t));\n    return ((b - a) * ((t * (t * 6.0 - 15.0) + 10.0) * t * t * t) + a);\n}\n\nvec4 perlinNoise(vec2 coord, float scale){\n    vec2 intCoord = floor(coord / scale);\n    vec2 fracCoord = mod(coord, vec2(scale)) / scale;\n    \n    vec4 rand00 = hash2to4(intCoord + vec2(0.0, 0.0));\n    vec4 rand01 = hash2to4(intCoord + vec2(0.0, 1.0));\n    vec4 rand10 = hash2to4(intCoord + vec2(1.0, 0.0));\n    vec4 rand11 = hash2to4(intCoord + vec2(1.0, 1.0));\n    \n    vec2 dir00 = fracCoord - vec2(0.0, 0.0);\n    vec2 dir01 = fracCoord - vec2(0.0, 1.0);\n    vec2 dir10 = fracCoord - vec2(1.0, 0.0);\n    vec2 dir11 = fracCoord - vec2(1.0, 1.0);\n    \n    vec4 val00 = mat2x4(cos(2.0 * M_PI * rand00), sin(2.0 * M_PI * rand00)) * dir00;\n    vec4 val01 = mat2x4(cos(2.0 * M_PI * rand01), sin(2.0 * M_PI * rand01)) * dir01;\n    vec4 val10 = mat2x4(cos(2.0 * M_PI * rand10), sin(2.0 * M_PI * rand10)) * dir10;\n    vec4 val11 = mat2x4(cos(2.0 * M_PI * rand11), sin(2.0 * M_PI * rand11)) * dir11;\n    \n    vec4 val0x = blendFcn(val00, val01, fracCoord.y);\n    vec4 val1x = blendFcn(val10, val11, fracCoord.y);\n    vec4 valxx = blendFcn(val0x, val1x, fracCoord.x);\n    \n    return valxx;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec4 col = vec4(0.0);\n    float baseLenScale = 128.0;\n    float amplScale = 1.0;\n    vec2 sampleCoord = fragCoord;\n    mat2 sampleCoordTf = mat2(2.0, 0.0, 0.0, 2.0) * mat2(0.0, 1.0, -1.0, 0.0);\n    for (int i = 0; i < 4; i ++){\n        vec4 staticNoise = vec4(perlinNoise(sampleCoord, baseLenScale));\n        vec4 dynNoise = vec4(perlinNoise(\n            sampleCoord + vec2(1.0, 1.0) * 10.0 * iTime, baseLenScale));\n        col += amplScale * vec4(staticNoise.xy, dynNoise.zw);\n        sampleCoord = sampleCoordTf * sampleCoord;\n        amplScale /= 2.0;\n    }\n    col = 0.5 + 0.5 * col;\n    fragColor = col;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define M_PI 3.1415926536\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buffer for color-changing texture.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pos = mod(texture(iChannel0, uv).xy + texture(iChannel0, uv).zw, 1.0);\n    \n    float scaledTime = 0.02 * iTime;\n    vec3 colX = 0.5 + 0.5 * cos(2.0 * M_PI * \n        (pos.x + vec3(1.01, 1.12, 1.23) * 1.015 * scaledTime + vec3(0.2, 0.5, 0.8)));\n    vec3 colY = 0.5 + 0.5 * cos(2.0 * M_PI * \n        (pos.y + vec3(1.17, 1.34, 1.09) * 1.000 * scaledTime + vec3(0.3, 0.6, 0.0)));\n    colX *= sin(M_PI * pos.x);\n    colY *= sin(M_PI * pos.y);\n    vec3 col = colX + colY - colX * colY;\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}