{"ver":"0.1","info":{"id":"ctG3WR","date":"1683767496","viewed":45,"name":"House v6","username":"Cesium_137","description":"The only reason this exists is because of ThePlaneGuy45 so big thanks to him.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","interactive","projection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float d = 3.0; //FOV; lower numbers = higher FOV\nfloat width = 2.0;\nconst int faces = 88;\nconst int vertices = 46;\nvec3 lightPos = vec3(-0.4,-0.2,1.);\nfloat lightStrength = 1.0;\n\nfloat saign(vec2 p1, vec2 p2, vec2 p3){\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}//I couldn't use sign for the function name because that's already a different built-in function\n\nfloat inTriangle(vec2 pt, vec2 p1, vec2 p2, vec2 p3){\n    float d1 = saign(pt,p1,p2);\n    float d2 = saign(pt,p2,p3);\n    float d3 = saign(pt,p3,p1);\n    if(d1 < 0. && d2 < 0. && d3 < 0.){\n        return 1.;\n    }\n    else{\n        return 0.;\n    }\n}\n\nvec3 normal(vec3 p1, vec3 p2, vec3 p3){\n    vec3 n;\n    vec3 v = p2 - p1;\n    vec3 w = p3 - p1;\n    n.x = (v.y*w.z)-(v.z*w.y);\n    n.y = (v.z*w.x)-(v.x*w.z);\n    n.z = (v.x*w.y)-(v.y*w.x);\n    return normalize(n);\n}\n\nfloat calculateIntensity(vec3 p1, vec3 p2, vec3 p3){\n    return clamp(dot(normalize(lightPos),normal(p1,p2,p3)),0.1,0.8);\n}\n\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\nfloat z(vec2 a, float theta, float r, float h){\n    return cos(a.y)*r*sin(a.x + theta) - sin(a.y)*h;\n}\n\nfloat zcart(vec2 a, vec3 p){\n    return z(a,atan(p.y,p.x),sqrt(p.x*p.x+p.y*p.y),p.z);\n}\n\nvec2 c(vec2 a, float theta, float r, float h){\nfloat A = a.y, \n          B = a.x + theta;\n    vec2 v = mat2(cos(A), -sin(A), sin(A), cos(A) ) * vec2(h,r*sin(B));\n    return .2 * d / ( d - v.y ) \n              * vec2( r*cos(B), v.x ) +.5;\n} //plots cylindrical coordinates\n\nvec2 b(vec2 a, float x, float y, float h){\n    return c(a, atan(y,x),sqrt(x*x+y*y),h);\n} // plots cartesian coordinates\n\nfloat furthestDist(vec2 rot, vec3 a, vec3 b, vec3 c) {\n    float farthest = max(max(\n        d/(d-zcart(rot,a)),\n        d/(d-zcart(rot,b))),\n        d/(d-zcart(rot,c)));\n    return farthest;\n}\nfloat[] xcoords = float[](-1.25,0.0,-1.0,1.0,0.0,1.25,-0.5,0.5,0.5,-0.5,-1.0,0.0,-1.25,0.0,1.0,1.25,-1.0,-1.0,1.0,0.0,0.0,1.0,1.0,-1.0,-1.0,1.0,-0.75,0.75,-0.75,-0.5,-0.5,-0.75,0.75,0.5,0.5,0.75,1.0,0.75,1.0,0.75,1.0,1.0,0.75,-0.75,0.75,0.78);\nfloat[] ycoords = float[](1.25,1.25,1.25,1.25,1.25,1.25,1.0,1.0,1.0,1.0,-1.25,-1.25,-1.25,-1.25,-1.25,-1.25,1.0,1.0,1.0,1.0,-1.0,-1.0,1.0,-1.0,-1.0,-1.0,0.75,0.75,0.75,0.75,0.75,-0.75,-0.75,0.75,0.75,0.75,0.0,0.0,0.0,-0.5,-0.5,-0.5,-0.75,-0.75,0.0,-0.5);\nfloat[] zcoords = float[](0.5,1.5,0.5,0.5,1.75,0.5,-1.0,-1.0,0.0,0.0,0.5,1.5,0.5,1.75,0.5,0.5,-1.5,0.5,-1.5,1.5,1.5,0.5,0.5,0.5,-1.5,-1.5,-1.5,-1.5,0.5,-1.0,0.0,-1.5,-1.5,0.0,-1.0,0.5,-1.5,-1.5,-0.5,-1.5,-1.5,-0.5,0.5,0.5,-0.5,-0.5);\nint[] triData1 = int[](2,1,5,4,7,18,17,19,10,14,11,23,15,14,13,12,19,16,20,20,8,5,14,12,20,20,3,12,22,19,23,27,29,29,32,25,17,17,28,27,34,21,37,37,35,35,37,23,26,40,26,9,9,22,41,10,10,35,34,34,42,23,34,29,43,43,17,17,27,27,36,38,33,46,33,36,39,39,46,46,45,45,16,3,43,29,5,5);\nint[] triData2 = int[](3,5,6,2,8,9,18,17,7,13,12,9,16,12,1,2,8,15,21,22,9,1,5,11,18,24,2,4,24,27,18,19,27,30,33,26,27,32,36,28,35,24,38,28,8,7,19,39,25,41,33,34,31,26,42,31,30,30,9,8,39,22,36,31,33,32,25,24,29,44,28,45,46,43,43,45,45,38,42,41,39,42,4,11,44,36,14,16);\nint[] triData3 = int[](1,2,2,6,19,10,7,7,18,12,13,18,12,16,11,4,23,4,22,23,23,13,13,2,24,21,11,15,26,17,20,28,30,31,25,24,32,25,35,35,36,22,28,19,7,30,39,19,33,33,41,31,10,42,26,30,7,27,8,35,22,39,31,36,32,44,24,18,44,32,45,28,40,45,46,43,38,37,41,40,42,46,6,1,36,44,16,6);\nvec2[vertices] projected;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float maxDist;\n    vec2 uv = 2.*( fragCoord -.5*iResolution.xy ) / iResolution.x +.5;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec2 rot = vec2(-mouse.x * 4. - iTime / 2.,(mouse.y - 0.2) * 4.); // rot is rotation\n    float col = 0.2;\n    for(int i = 0; i < vertices; i++)\n    {\n        projected[i] = b(rot,xcoords[i],ycoords[i],zcoords[i]);\n    }\n    for(int i = 0; i < faces; i++)\n    {\n        float intensity = calculateIntensity(vec3(xcoords[triData1[i]-1],ycoords[triData1[i]-1],zcoords[triData1[i]-1]),vec3(xcoords[triData2[i]-1],ycoords[triData2[i]-1],zcoords[triData2[i]-1]),vec3(xcoords[triData3[i]-1],ycoords[triData3[i]-1],zcoords[triData3[i]-1])) * lightStrength;\n        if(inTriangle(uv,projected[triData1[i]-1],projected[triData2[i]-1],projected[triData3[i]-1]) == 1.){\n            float dist = furthestDist(rot,vec3(xcoords[triData1[i]-1],ycoords[triData1[i]-1],zcoords[triData1[i]-1]),vec3(xcoords[triData2[i]-1],ycoords[triData2[i]-1],zcoords[triData2[i]-1]),vec3(xcoords[triData3[i]-1],ycoords[triData3[i]-1],zcoords[triData3[i]-1]));\n            if(dist > maxDist){\n                col = inTriangle(uv,projected[triData1[i]-1],\n                                     projected[triData2[i]-1],\n                                     projected[triData3[i]-1]) * intensity;\n                maxDist = dist;\n            }\n        }\n    }\n    fragColor = vec4(vec3(col),1.0);\n}","name":"Image","description":"","type":"image"}]}