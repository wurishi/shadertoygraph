{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*\n\nTODO:\n\n* clean stuff up, move various params to \"global / uniform\" space\n\n* put back in the \"early out\" for if the ray leaves the bounding box of the terrain\n\n* maybe have some haze at the horizon?\n\n* cone light instead of directional?\n\n\n*/\n\nconst float c_timeMultiplier = 0.25;\n#define scaledTime (iTime * c_timeMultiplier)\n\nconst float c_maxVisibilityDistance = 7.0;\n\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\n// Value noise generator. Returns\n// three values on [-1, +1]\nvec3 noised(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n\t// The constant for tileWidth doesn't matter much unless it is too small\n    const float tileWidth = 1024.0;\n    float n = p.x + p.y * tileWidth;\n\n    // Grab noise values at four corners of a square\n    float a = hash(n +  0.0);\n    float b = hash(n +  1.0);\n    float c = hash(n + tileWidth);\n    float d = hash(n + tileWidth + 1.0);\n\n    // use smoothstep-filtered lerp for one component and compute the derivatives for the others\n\t// See https://iquilezles.org/articles/morenoise\n\n    // The (negative) smoothstep weight\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t30.0*f*f*(f*(f-2.0)+1.0)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nconst int octaves = 3;\n\n// On the range [0, 1].  This is the sum\n// of a convergent series http://en.wikipedia.org/wiki/Series_(mathematics)#Convergent_series, \n// where each term has a pseudorandom weight on [-1, 1].  The largest sum is therefore\n// 2 (the smallest is -2), and the final line of code rescales this to the unit interval.\n// \nfloat HeightAtPos(vec2 P) {\n\t\n\tP *= 0.5;\n\t\n    const mat2 M2 = mat2(1.6, -1.2, 1.2, 1.6);\n    float height = 0.0;\n\tvec2 d = vec2(0.0);\n\n    // Magnitude at this octave\n    float magnitude = 1.0;\n\n    // Add multiple octaves of noise, chosen from points that spiral outward\n    // to avoid hitting the tiling period of the noise function.\n    for (int i = 0; i < octaves; ++i) {\n        vec3 n = noised(P);\n        d += n.yz;\n\n        // The 1 + |d|^2 denominator creates the mountainous lumpiness.\n        // Without it, this is a standard value noise function.\n        height += magnitude * n.x / (1.0 + dot(d, d));\n        P = M2 * P;\n\t\tmagnitude *= 0.5;\n    }\n\n\t// iq's original had 0.5 here, but that doesn't fit the range\n    return (height * 0.5 + 0.5);\n}\n\n//=======================================================================================\nvec3 NormalAtPos( vec2 p )\n{\n\tfloat eps = 0.01;\n    vec3 n = vec3( HeightAtPos(vec2(p.x-eps,p.y)) - HeightAtPos(vec2(p.x+eps,p.y)),\n                         2.0*eps,\n                         HeightAtPos(vec2(p.x,p.y-eps)) - HeightAtPos(vec2(p.x,p.y+eps)));\n    return normalize( n );\n}\n\n//=======================================================================================\nvec2 path( float time ) {\n\treturn vec2( cos(0.2+0.0525*time), sin(0.1+0.07425*time));\t\n}\n\n//=======================================================================================\nvec3 CameraPointInTime (float t)\n{\n\tvec2 pos2D = path(t);\n\tpos2D *= 16.0;\n\treturn vec3(pos2D.x, HeightAtPos(pos2D) + 0.2, pos2D.y);\n}\n\n//=======================================================================================\n// Scene parameters\n//=======================================================================================\n\n#define cameraTime1 scaledTime\n\n#define cameraPos CameraPointInTime(cameraTime1)\n#define cameraAt CameraPointInTime(cameraTime1 + 0.01)\n\n#define cameraUp mix(NormalAtPos(cameraPos.xz),vec3(0.0,1.0,0.0),0.75)\n#define cameraFwd2 normalize(cameraAt - cameraPos)\n#define cameraLeft  normalize(cross(cameraFwd2, cameraUp))\n#define cameraFwd normalize(cross(cameraUp, cameraLeft))\n\nfloat cameraViewWidth\t= 6.0;\n#define cameraViewHeight cameraViewWidth * iResolution.y / iResolution.x\nfloat cameraDistance\t= 6.0;  // intuitively backwards!\n\n#define minimapTarget ((path(cameraTime1) + 1.0) * 0.1 + vec2(0.0,0.8)) * iResolution.xy\n\n//=======================================================================================\nvec3 ShadePoint (in vec3 pos, float time)\n{\n\t/*\n\tbool whiteSquare = true;\n\t\n\tif (mod(pos.x, 2.0) < 1.0)\n\t\twhiteSquare = !whiteSquare;\n\n\tif (mod(pos.z, 2.0) < 1.0)\n\t\twhiteSquare = !whiteSquare;\t\n\t\n\tvec3 diffuseColor = whiteSquare ? vec3(1.0,1.0,1.0) : vec3(0.4,0.4,0.4);\n\t*/\n\t\n\tvec3 color1 = texture( iChannel2, pos.xz ).rgb;\n\tvec3 color2 = texture( iChannel1, pos.xz ).rgb;\n\t\n\tvec3 diffuseColor = mix(color1, color2, pos.y * 2.0);\n\t\n\tvec3 reverseLightDir = normalize(vec3(1.0,1.0,-1.0));\n\tvec3 lightColor = vec3(1.0,1.0,1.0);\t\n\tvec3 ambientColor = vec3(0.1,0.1,0.1);\n\n\tvec3 normal = NormalAtPos(pos.xz);\n\n\tvec3 color = ambientColor;\n\tfloat dp = dot(normal, reverseLightDir);\n\tif(dp > 0.0)\n\t\tcolor += (diffuseColor * dp * lightColor);\t\n\t\n\tfloat b = 0.5;\n    float fogAmount = pow(time / c_maxVisibilityDistance, 1.0);\n    return mix( color, vec3(0.0,0.0,0.0), fogAmount );\t\n}\n\n//=======================================================================================\nbool HandleRay (in vec3 rayPos, in vec3 rayDir, inout vec3 pixelColor)\n{\n\tfloat time = 0.0;\n\tfloat lastHeight = 0.0;\n\tfloat lastY = 0.0;\n\tfloat deltaT = 0.01;\n\tvec3 pos;\n\tfloat height;\n\tbool hitFound = false;\n\tfor (int index = 0; index < 150; ++index)\n\t{\t\t\n\t\tpos = rayPos + rayDir * time;\n\t\theight = HeightAtPos(pos.xz);\n\t\tif (height > pos.y)\n\t\t{\t\t\t\t\t\n\t\t\thitFound = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tdeltaT = max(0.01*float(time), (pos.y - height)*0.5);\n\t\ttime += deltaT;\t\t\n\t\t\n\t\tif (time > c_maxVisibilityDistance)\n\t\t\tbreak;\n\t\t\n\t\tlastHeight = height;\n\t\tlastY = pos.y;\n\t}\n\t\n\tif (hitFound) {\n\t\ttime = time - deltaT + deltaT*(lastHeight-lastY)/(pos.y-lastY-height+lastHeight);\n\t\tpos = rayPos + rayDir * time;\n\t\theight = HeightAtPos(pos.xz);\t\t\n\t\tpixelColor = ShadePoint(vec3(pos.x, height, pos.z), time);\n\t}\n\t\n\treturn hitFound;\n}\n\n//=======================================================================================\nbool DrawUI (inout vec3 pixelColor, in vec2 fragCoord)\n{\n\t\n\t// early out of UI box area\n\tint borderX = int(iResolution.x * 0.2) + 1;\n\tint borderY = int(iResolution.y * 0.8) - 1;\n\n\tint bufferX = int(iResolution.x * 0.05);\n\tint bufferY = int(iResolution.y * 0.05);\n\n\tint pixelX = int(fragCoord.x) - bufferX;\n\tint pixelY = int(fragCoord.y) + bufferY;\t\n\n\tif (pixelX < 0 || pixelX > borderX || pixelY > int(iResolution.y) || pixelY < borderY)\n\t\treturn false;\n\t\n\tif (pixelX == 0 || pixelX == borderX ||\n\t\tpixelY == int(iResolution.y) || pixelY == borderY)\n\t{\n\t\tpixelColor += vec3(0.0,1.0,0.0);\n\t\treturn true;\n\t}\n\t\n\tif (int(minimapTarget.x)+1 == pixelX)\n\t{\n\t\tpixelColor += vec3(1.0,0.0,0.0);\n\t\treturn true;\n\t}\n\tif (int(minimapTarget.y)-1 == pixelY)\n\t{\n\t\tpixelColor += vec3(1.0,1.0,0.0);\n\t\treturn true;\n\t}\n    \n   vec2 mmtarget = minimapTarget;\n\t\n\tvec2 dist = vec2(mmtarget.x + 1.0 - float(pixelX), mmtarget.y - 1.0 - float(pixelY));\n\tif (length(dist) < float(bufferX) * 0.15)\n\t{\n\t\tpixelColor += vec3((sin(scaledTime*50.0)+ 1.0) * 0.5,0.0,0.0);\n\t\treturn true;\t\t\n\t}\t\n\t\n\tif (mod(float(pixelX), float(bufferX) * 0.5) < 0.1)\n\t{\n\t\tpixelColor += vec3(0.0,0.2,0.0);\n\t\treturn true;\n\t}\t\n\t\n\tif (mod(float(pixelY+2), float(bufferY) * 0.5) < 0.1)\n\t{\n\t\tpixelColor += vec3(0.0,0.2,0.0);\n\t\treturn true;\n\t}\t\t\n\t\n\treturn false;\n}\n\n//=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\t\n\t\n\t// UI\n\tvec3 pixelColor = vec3(0.0,0.0,0.0);\t\n\tif (DrawUI(pixelColor, fragCoord))\n\t{\n\t\tfragColor = vec4(pixelColor, 1.0);\n\t\treturn;\n\t}\n\t\t\n\t// Terrain\n\tvec2 rawPercent = (fragCoord.xy / iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\t\n\tvec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n\t\t\t\t   - (cameraLeft * percent.x * cameraViewWidth)\n\t\t           + (cameraUp * percent.y * cameraViewHeight);\n\tvec3 rayDir = normalize(rayTarget);\n\t\n\t\n\tif (HandleRay(cameraPos, rayDir, pixelColor))\n\t{\n\t\tfragColor = vec4(pixelColor, 1.0);\n\t\treturn;\n\t}\n\t\n\t// Stars\n\tfloat starXf = (atan(rayDir.x, rayDir.z) + 3.14) / 6.28;\n\tfloat starYf = (asin(rayDir.y) / 1.57);\n\tint starX = int(starXf * 1000.0 * 5.0);\n\tint starY = int(starYf * 250.0 * 5.0);\n\t\n\t\n\tfloat starTest = float(7 + starX * starY * 13);\n\tfloat value = abs(mod(starTest, 5000.0));\n\tif ( value >= 0.0 && value <= 1.0)\n\t{\n\t\tfragColor = vec4(vec3(value * 0.5 + 0.5), 1.0);\n\t\treturn;\t\t\n\t}\n\tfragColor = vec4(0.0,0.0,0.0, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mds3DX","date":"1381100592","viewed":6430,"name":"Asteroid Rover","username":"demofox","description":"Playing around with stuff I read about on IQ's site and shadertoys\nhttps://iquilezles.org/articles/terrainmarching/terrainmarching.htm\nhttps://iquilezles.org/articles/morenoise/morenoise.htm\n\nMuch left to learn about ray marching hehe...","likes":42,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""}}