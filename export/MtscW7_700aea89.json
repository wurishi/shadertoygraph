{"ver":"0.1","info":{"id":"MtscW7","date":"1506765378","viewed":199,"name":"fooling around with diamonds","username":"Pehat","description":"based on https://www.shadertoy.com/view/4ttGDH","likes":6,"published":1,"flags":8,"usePreview":0,"tags":["stolen","begginer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FAR 50. // Far plane, or maximum distance.\n\n//float objID = 0.; // Object ID\n\nfloat accum; // Used to create the glow, by accumulating values in the raymarching function.\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) - a);\treturn mat2(v, -v.y, v.x); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.zy).xyz;\n    vec3 ty = texture(t, p.xz).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n\n// Camera path.\nvec3 camPath(float t){\n  \n    return vec3(0, 0, t); // Straight path.\n    \n    \n}\n\nfloat map(vec3 p){\n   vec3 d = 1.5 * (fract(p * 0.05) - 0.5);\n   return 5. - 10. * ((abs(d.x) + abs(d.y) + abs(d.z)));\n    \n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 p, in vec3 n)\n{\n\tfloat sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.35/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nr(vec3 p){\n\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), \n                          map(p + e.yxy) - map(p - e.yxy), map(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    accum = 0.;\n    float t = 0.0, h;\n    for(int i = 0; i < 128; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.001*(t*.25 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h;\n        \n        // Simple distance-based accumulation to produce some glow.\n        if(abs(h)<.35) accum += (.35-abs(h))/24.;\n        \n    }\n\n    return min(t, FAR);\n}\n\n\n// Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 24; \n\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n\n        dist += clamp(h, 0.01, 0.2);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if (abs(h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.4, 1.0); \n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db(in vec3 p, in vec3 n, float bf){\n    return vec3(1, 1, 1); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(vec3 p){\n    return 1.;\n}\n\n\n\n// Simple environment mapping.\nvec3 envMap(vec3 rd, vec3 n){\n    \n    vec3 col = tpl(iChannel1, rd*4., n);\n    return smoothstep(0., 1., col);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n    float speed = 4.;\n    vec3 o = camPath(iTime*speed); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime*speed + .25);  // \"Look At\" position.\n    vec3 l = camPath(iTime*speed + 2.) + vec3(0, 1, 0); // Light position, somewhere near the moving camera.\n\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .5 * 3.14159/2.; ///3. FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0, -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    //vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    // Lens distortion.\n    vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    r = normalize(vec3(r.xy, (r.z - length(r.xy)*.125)));\n\n\n    // Raymarch.\n    float t = trace(o, r);\n    \n    // Save the object ID directly after the raymarching equation, since other equations that\n    // use the \"map\" function will distort the results. I leaned that the hard way. :)\n    //float sObjID = objID;\n\n    // Initialize the scene color to the background.\n    vec3 col = vec3(0);\n    \n    // If the surface is hit, light it up.\n    if(t<FAR){\n    \n        // Position.\n        vec3 p = o + r*t;\n\t\t\n        // Normal.\n        vec3 n = nr(p);\n        \n        // Sometimes, it's handy to keep a copy of the normal. In this case, I'd prefer the\n        // bumps on the surface to not have as much influence on the reflrection and \n        // refraction vectors, so I tone down the bumped normal with this. See the reflection\n        // and refraction lines.\n        vec3 svn = n;\n        \n        // Texture bump the normal.\n        float sz = 1./3.; \n        n = db(p*sz, n, .1/(1. + t*.25/FAR));\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n\n        \n        float at = 1./(1. + d*.1 + d*d*.01); // Light attenuation.\n        \n        // Ambient occlusion and shadowing.\n        float ao =  cao(p, n);\n        float sh = sha(p, l, 0.04, d, 16.);\n        \n        // Diffuse, specular, fresnel. Only the latter is being used here.\n        float di = max(dot(l, n), 0.);\n        float sp = pow(max( dot( reflect(r, n), l ), 0.), 64.); // Specular term.\n        float fr = clamp(1.0 + dot(r, n), .0, 1.); // Fresnel reflection term.\n \n         \n        \n        // Texturing - or coloring - the surface. The \"color\"' of glass is provide by the surrounds...\n        // of it's contents, so just make it dark.\n        vec3 tx = vec3(1, 1, 1); // tpl(iChannel0, p*sz, n);\n         \n\n\t\t// Very simple coloring.\n        col = tx*(di*.1 + ao*.25) + vec3(1., 1., 1)*sp*1. + vec3(1, 1, 1)*pow(fr, 8.)*.25;\n \n        // Very cheap, and totally fake, reflection and refraction. Obtain the reflection and\n        // refraction vectors at the surface, then pass them to the environment mapping function.\n        // Note that glass and fluid have different refractive indices, so I've fudged them into \n        // one figure.\n        vec3 refl = envMap(normalize(reflect(r, svn*.5 + n*.5)), svn*.5 + n*.5);\n        vec3 refr = envMap(normalize(refract(r, svn*.5 + n*.5, 1./1.35)), svn*.5 + n*.5);\n        \n        /*\n\t\t// You can also index into a 3D texture, but I prefer the above.\n        vec3 refl = texture(iChannel2, normalize(reflect(r, svn*.5 + n*.5))).xyz;\n        vec3 refr = texture(iChannel2, normalize(refract(r, svn*.5 + n*.5, 1./1.31))).xyz;\n        refl *= refl*.5;\n        refr *= refr*.5;\n        */\n        \n        // More fake physics that looks like real physics. :) Mixing the reflection and refraction \n        // colors according to a Fresnel variation.\n        vec3 refCol = mix(refr, refl, pow(fr, 5.)); //(refr + refl)*.5; // Adding them, if preferred.\n        \n        // Obviously, the reflected\\refracted colors will involve lit values from their respective\n        // hit points, but this is fake, so we're just combining it with a portion of the surface \n        // diffuse value.\n        col += refCol*((di*di*.25+.75) + ao*.25)*1.5; // Add the reflected color. You could combine it in other ways too.\n        \n        // Based on IQ's suggestion: Using the diffuse setting to vary the color slightly in the\n        // hope that it adds a little more depth. It also gives the impression that Beer's Law is \n        // taking effect, even though it clearly isn't. I might try to vary with curvature - or some other\n        // depth guage - later to see if it makes a difference.\n       \n       \n        col += col*12.;\n \n\n        \n        // Apply some shading.\n        col *= ao*sh*at;\n\n        \n    }\n    \n    \n    // Blend in a bit of light fog for atmospheric effect.\n   \n    // Rough gamma correction, and we're done.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 sine(float time, float freq) {\n    return vec2(sin(time * freq * 3.1415 * 2.));\n}\n\nvec2 square(float time, float freq) {\n    return vec2(2. * float(int(time * 2. * freq) % 2) - 1.);\n}\n\nvec2 saw(float time, float freq) {\n    return vec2(2. * fract(time * freq) - 1.);\n}\n\nvec2 tri(float time, float freq) {\n    return vec2(2. * abs(fract(time * freq - 0.5)) - 1.);\n}\n\nvec2 noise(float a, float b) {\n    return vec2(2. * (0.5 - fract(sin(dot(vec2(a, b) ,vec2(12.9898,78.213))) * 42758.5453)));\n}\n\nvec2 exp_noise(float time, float b, float q) {\n    return vec2(noise(time, b) * exp(-time * q));\n}\n\n\nvec2 exp_square(float time, float freq, float q) {\n    return vec2(square(time, freq) * exp(-time * q));\n}\n\nvec2 exp_saw(float time, float freq, float q) {\n    return vec2(saw(time, freq) * exp(-time * q));\n}\n\nvec2 exp_sine(float time, float freq, float q) {\n    return vec2(sine(time, freq)) * exp(-time * q);\n}\n\nvec2 tom(float time) {\n    return exp_sine(time, 60. * exp(-time), 25.);\n}\n\nvec2 snare(float time) {\n    return exp_noise(time, 1., 20.) * 0.3 + exp_sine(time, 200. * exp(-time), 50.) * 0.7;\n}\n\nvec2 hihat(float time) {\n   return exp_noise(time, 8., 18.) * 0.9 + exp_sine(time, 300. * exp(-time), 40.) * 0.1;\n}\n\nvec2 open_hat(float time) {\n   return exp_noise(time, 180., 8.);\n}\n\nfloat note(float n) {\n    return 27.5 * exp(n * 0.05776226504666210911810267678818);\n}\n\nvec2 drums(float time) {\n    return (\n        0.7 * (tom(fract(time)) + snare(fract(time + 0.5))) +\n        0.25 * (hihat(fract(time * 4.)) * 0.7 + open_hat(fract(time * 0.5)) * 0.3)\n    );\n}\n\nvec2 bass_instrument(float note_time, float n, float q) {\n    return 0.6 * exp_saw(note_time, note(n), q) + 0.4 * exp_saw(note_time, note(n) * 1.99, q);\n}\n\nvec2 bass(float time) {\n    const int NOTE_COUNT = 64;\n    float notes[NOTE_COUNT] = float[NOTE_COUNT](\n        21., 16., 19., 21., 19., 16., 14., 16.,\n        21., 16., 19., 21., 19., 16., 14., 16.,\n        21., 16., 19., 21., 19., 16., 14., 16.,\n        21., 16., 19., 21., 19., 16., 14., 16.,\n        26., 21., 24., 26., -100., 24., 21., 19.,\n        26., 21., 24., 26., -100., 24., 21., 19.,\n        21., 16., 19., 21., 19., 16., 14., 16.,\n        21., 16., 19., 21., 19., 16., 14., 16.\n    \n    );\n    float sample_length = 16.;\n    float sample_pos = fract(time / sample_length) * float(NOTE_COUNT);\n    int note_number = int(trunc(sample_pos));\n    float note_time = fract(sample_pos);\n    return bass_instrument(note_time, notes[note_number] - 24. - 12., 1.5);\n    \n}\n\nvec2 harm_instrument(float note_time, float n, float q) {\n\treturn exp_square(note_time, note(n), q);\n}\n\nvec2 harm1(float time) {\n    float sample_length = 16.;\n    float d = 0.25;\n    const int NOTE_COUNT = 17;\n    vec3 notes[NOTE_COUNT] = vec3[NOTE_COUNT](\n        vec3(0., 4. * d, 45.),\n        vec3(3. * d, 7. * d, 47.),\n        vec3(8. * d, 12. * d, 48.),\n        vec3(11. * d, 15. * d, 47.),\n        \n        vec3(16. * d, 20. * d, 45.),\n        vec3(19. * d, 23. * d, 47.),\n        vec3(24. * d, 28. * d, 48.),\n        vec3(27. * d, 31. * d, 47.),\n        \n        vec3(32. * d, 36. * d, 45.),\n        vec3(35. * d, 39. * d, 45.),\n        vec3(40. * d, 44. * d, 45.),\n        vec3(43. * d, 47. * d, 45.),\n        vec3(45. * d, 49. * d, 47.),\n        \n        vec3(48. * d, 52. * d, 45.),\n        vec3(51. * d, 55. * d, 47.),\n        vec3(56. * d, 59. * d, 48.),\n        vec3(59. * d, 64. * d, 47.)\n    );\n    float sample_time = fract(time / sample_length) * sample_length;\n    vec2 result = vec2(0.);\n    for (int i = 0; i != NOTE_COUNT; ++i) {\n        if ((notes[i].x <= sample_time) && (sample_time < notes[i].y)) {\n        \tresult += harm_instrument(sample_time - notes[i].x, notes[i].z, 2.);\n        }\n    }\n    return result;\n}\n\n\nvec2 harm2(float time) {\n    float sample_length = 16.;\n    float d = 0.25;\n    const int NOTE_COUNT = 17;\n    vec3 notes[NOTE_COUNT] = vec3[NOTE_COUNT](\n        vec3(0., 4. * d, 40.),\n        vec3(3. * d, 7. * d, 42.),\n        vec3(8. * d, 12. * d, 43.),\n        vec3(11. * d, 15. * d, 42.),\n        \n        vec3(16. * d, 20. * d, 40.),\n        vec3(19. * d, 23. * d, 42.),\n        vec3(24. * d, 28. * d, 43.),\n        vec3(27. * d, 31. * d, 42.),\n        \n        vec3(32. * d, 36. * d, 41.),\n        vec3(35. * d, 39. * d, 41.),\n        vec3(40. * d, 44. * d, 41.),\n        vec3(43. * d, 47. * d, 41.),\n        vec3(45. * d, 47. * d, 41.),\n                \n        vec3(48. * d, 52. * d, 40.),\n        vec3(51. * d, 55. * d, 42.),\n        vec3(56. * d, 59. * d, 43.),\n        vec3(59. * d, 64. * d, 42.)\n    );\n    float sample_time = fract(time / sample_length) * sample_length;\n    vec2 result = vec2(0.);\n    for (int i = 0; i != NOTE_COUNT; ++i) {\n        if ((notes[i].x <= sample_time) && (sample_time < notes[i].y)) {\n        \tresult += harm_instrument(sample_time - notes[i].x, notes[i].z, 2.);\n        }\n    }\n    return result;\n}\n\nvec2 harm3(float time) {\n    float sample_length = 16.;\n    float d = 0.25;\n    const int NOTE_COUNT = 17;\n    vec3 notes[NOTE_COUNT] = vec3[NOTE_COUNT](\n        vec3(0., 4. * d, 36.),\n        vec3(3. * d, 7. * d, 38.),\n        vec3(8. * d, 12. * d, 40.),\n        vec3(11. * d, 15. * d, 38.),\n        \n        vec3(16. * d, 20. * d, 36.),\n        vec3(19. * d, 23. * d, 38.),\n        vec3(24. * d, 28. * d, 40.),\n        vec3(27. * d, 31. * d, 38.),\n        \n        vec3(32. * d, 36. * d, 38.),\n        vec3(35. * d, 39. * d, 38.),\n        vec3(40. * d, 44. * d, 38.),\n        vec3(43. * d, 47. * d, 38.),\n        vec3(45. * d, 47. * d, 38.),\n        \n        vec3(48. * d, 52. * d, 36.),\n        vec3(51. * d, 55. * d, 38.),\n        vec3(56. * d, 59. * d, 40.),\n        vec3(59. * d, 64. * d, 38.)\n    );\n    float sample_time = fract(time / sample_length) * sample_length;\n    vec2 result = vec2(0.);\n    for (int i = 0; i != NOTE_COUNT; ++i) {\n        if ((notes[i].x <= sample_time) && (sample_time < notes[i].y)) {\n        \tresult += harm_instrument(sample_time - notes[i].x, notes[i].z, 2.);\n        }\n    }\n    return result;\n}\n\n\nvec2 harmony(float time) {\n\treturn (\n        0.33 * harm1(time) +\n        0.33 * harm2(time) + \n        0.33 * harm3(time)\n    );\n}\n\nvec2 mix_tracks(float time, float a) {\n    return (\n        0.7 * drums(time) + \n        0.2 * bass(time) + \n        0.07 * harmony(time)\n    );\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    return mix_tracks(time, 0.8);\n}","name":"Sound","description":"","type":"sound"}]}