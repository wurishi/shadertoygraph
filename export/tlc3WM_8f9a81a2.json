{"ver":"0.1","info":{"id":"tlc3WM","date":"1577110342","viewed":187,"name":"Tests CA (not original)","username":"Chuee","description":"Based on the Towers of Life by Polygon\nhttps://www.shadertoy.com/view/MsXfRH\n\nIt is just the same code with less features but more comments, too much comments I think.\nI take no credit of the code.\n","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["cellularautomata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* \n\n\tDISCLAIMER!!!\n\n\tTowers of Life  -  By Polygon\n\n\tThis is a exact copy of the original by Polygon (https://www.shadertoy.com/user/Polygon) \n\twith less features but more comments in this file.\n\n    Original shader : https://www.shadertoy.com/view/MsXfRH\n\tGo check the original one!!\n\t\n\tThe purpose of this shader is for students (like me) to understand more deeply raymarching and\n\tshow it to my classmates and teacher.\n\tHopefully later we will be able to do other cellular automatas in 3D with nice and fancy effects!\n\n\tThe comments that start with 'DOUBT?' are the lines where there is doubt of what is exactly the purpose\n\tof that code or what it does.\n\t\n\tI take no credit of the code below.\n\n/* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /* /*/\n\n\n\n//Width and length of rendered area. If you change them, I recommend you also change them in Buf A.\n#define width 64\n#define height 64\n\n//Distance of 224 ensures that nothing will be missed if the width and height are both 64.\n//To ensure nothing will be missed, set DISTANCE to width + height + 96. Anything bigger than that will have no improvement.\n#define DISTANCE 224\n//#define USE_MIPS\n#define MIP_DIST 16\n\n#define FOV 90.0\n\n//Don't mess with these.\n#define pi 3.14159265\n//This is degreesToRadians. Exactly this is 1 degree in radians\n#define d2r 0.0174533 \n\n\n#define EPSILON 0.001\n#define MAX_STEPS 100\n#define SURFACE_DIST 200.0\n\n\nbool check(vec3 pos);\nbool mipCheck(vec3 pos);\nvoid render (vec2 i, inout vec4 o);\nfloat getDist(vec3 pos, vec3 cubePos);\nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection, vec3 cubePos);\nfloat GetShadow(vec3 pos, vec3 dir);\nvec3  CalcNormal(vec3 pos, vec3 cubePos);\nfloat calcSoftShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, vec3 cubePos);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    \n    render(fragCoord, fragColor);\n    \n}\n\nfloat calcOcclusion(in vec3 pos, in vec3 nor, in vec3 cubePos)\n{\n    pos += nor * 0.02;\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i=0; i<5; i++){\n        float h = 0.001 + 0.11*float(i)/4.;\n        vec3 opos = pos + h * nor;\n        float d = getDist(pos, cubePos);\n        occ += (h-d)/sca;\n        sca *= .95;\n    }\n    \n    occ = clamp(2.*occ,0.,1.);\n    return occ*occ;\n}\n\nvec3 calcIlumination(vec3 hitPos, vec3 camDir, vec3 cubePos)\n{\n    vec3 nor = CalcNormal(hitPos-cubePos,cubePos-vec3(.5));\n    \n    vec3  sunDir    = normalize(vec3(5.,6.,2.));\n    vec3  sunColor  = vec3(0.7,0.45,0.3);\n    float sunIntens = 7.0;\n    float sunDiff   = clamp(0.5+0.5*dot(nor, sunDir),0.0,1.0);\n    \n    vec3  skyDir   = vec3(0.0,1.0,0.0);\n    vec3  skyColor = vec3(0.5,0.8,0.9);\n    float skyDiff  = clamp(0.5+0.5*dot(nor, -skyDir),0.0,1.0);\n    \n    float fresnel  = clamp(1.-dot(nor, camDir), 0., 1.);\n    vec3 freColor = vec3(0.9, 0.9, 0.1);\n    \n    vec3 o = vec3(0);\n    // Base color material\n    vec3 mat = vec3(0.1,0.9,0.4) * 0.2;\n    \n    vec3 botColor = vec3(0.189, 0.123, 0.22)*0.2;\n    mat = mix(mat, botColor, pow(hitPos.y/96., 2.));\n    \n    float occ = calcOcclusion(hitPos-cubePos, nor, cubePos-vec3(.5));\n    \n    vec3 light = sunColor*sunDiff*sunIntens*occ;\n    light += skyColor*skyDiff*occ;\n    light += fresnel*freColor;\n    \n    o  = mat*light;\n    \n    \n    \n    return o;\n}\n\nvoid render(vec2 i, inout vec4 o) {\n    float distanceMarch = 1.0;\n    vec3 cubePos = vec3(0);\n    vec2 uv = i.xy / iResolution.xy;\n    vec2 uvM = iMouse.xy / iResolution.xy;\n    \n    float maxRes = max(iResolution.x, iResolution.y);\n    \n    //Some kind of UVs but called 's' because why not\n    vec2 s = i.xy / maxRes - vec2(0.5 * iResolution.x / maxRes, 0.5 * iResolution.y / maxRes);\n    \n    //Camera position and rotation\n    vec2 rot = vec2(iTime / 3. + pi,\n               0.6 + 0.75 * sin(1. / 4.));\n    vec3 pos = vec3(float(width) * sin(iTime / 3.) * cos(rot.y) + float(width) / 2.,\n               -0.707 * float(width) * sin(rot.y),\n               float(height) * cos(iTime / 3.) * cos(rot.y) + float(height) / 2.);\n   \n    if (iMouse.z > 0.0) {\n        rot = vec2(6.5 * (uvM.x - .5),\n               -pi / 6. + (pi / 2. + pi / 6.) * min(uvM.y / .8, 1.));\n    \tpos = vec3(float(width) * -sin(rot.x) * cos(rot.y) + float(width) / 2.,\n               -1.0 / (tan(d2r * FOV / 2.)) * max(float(height) * iResolution.x / iResolution.y, float(width)) / 2.0 * sin(rot.y),\n               float(height) * -cos(rot.x) * cos(rot.y) + float(height) / 2.);\n    }\n    \n    //Smooth vertical movement\n    pos.y += float(texelFetch(iChannel1, ivec2(0), 0).y != 1.0) *\n        texelFetch(iChannel1, ivec2(0), 0).z * (texelFetch(iChannel1, ivec2(0), 0).x - iTime + texelFetch(iChannel1, ivec2(0), 0).w);\n    \n    //Direction of ray\n    vec3 d = vec3(2.0 * s.x * tan(d2r * FOV / 2.0), -2.0 * s.y * tan(d2r * FOV / 2.0), 1.0);\n    d = normalize(d);\n    \n    //Apply rotations of screen\n    d = vec3(d.x, d.y * cos(rot.y) + d.z * sin(rot.y), d.z * cos(rot.y) - d.y * sin(rot.y));\n    d = vec3(d.x * cos(rot.x) + d.z * sin(rot.x), d.y, d.z * cos(rot.x) - d.x * sin(rot.x));\n    \n    \n    //Sky Color\n    vec4 sky = vec4(0.5 - 0.5 * sin(d.y) * 4., 0.7 - 0.3 * sin(d.y),1.0,0.0);\n    o = sky;\n    \n    // Light Direction\n    vec3 lightDir = vec3(5.,6.,2.);\n    lightDir = normalize(lightDir);\n    \n    //DOUBT? I have no idea\n    vec3 bounderies = vec3(width, 96., height) * (0.5 - 0.5 * sign(d));\n    //DOUBT? derived from bounderies so IDK\n    vec3 t = (bounderies - pos) / d;\n    \n    //DOUBT? This is (1,0,0) or (0,1,0) or (0,0,1). See visualizations\n    //mask appears to be the normals of the planes (slices of the cube) without sign, BUT how are they gotten??\n    vec3 mask = vec3(greaterThanEqual(t.xyz, max(t.yzx, t.zxy)));\n    //This is the first plane (one of the three near to the camera) of the cube\n    //How is this calculated?\n    vec3 nextPlane = (1. - mask) * (floor(pos + d * dot(t, mask)) + 0.5 + 0.5 * sign(d)) + mask * bounderies;\n    #ifdef USE_MIPS\n    nextPlane = floor(nextPlane/4.)*4.;\n    #endif\n    \n    vec3 distToNext;\n    //RayMarcher by slices in a cube of (width x 96 x height) dimensions\n    for (int j = 0; j < DISTANCE; j++) {\n        #ifndef USE_MIPS\n        //DOUBT? I dont understand this calculation nor the type\n        //why it is a vec3 and not a single float? see visualizations\n        distToNext = (nextPlane - pos) / d;\n        \n        // This is (1,0,0) or (0,1,0) or (0,0,1). See visualizations\n        mask = vec3(lessThanEqual(distToNext.xyz, min(distToNext.yzx, distToNext.zxy)));\n        // March 1 unit in one axis, the axis is chosen depending on the normal of the hit.\n        nextPlane += sign(d)*mask;\n        #endif\n        \n        \n        \n        //Break if out of boundaries\n        if (  nextPlane.x > float(width)  || nextPlane.x < 0.0\n           || nextPlane.y > 96.\t\t      || nextPlane.y < 0.\n           || nextPlane.z > float(height) || nextPlane.z < 0.0)\n        {\n           \t//distToNext = vec3((96.-pos.y)/d.y);\n            distanceMarch = (96.-pos.y)/d.y;\n            break;\n        }\n        \n        //Using mip-------\n        #ifdef USE_MIPS\n        if (mipCheck((nextPlane -.5 -.5 * sign(d)))) {\n            //o = vec4(int(floor(nextPlane.x/4.))%2,int(floor(nextPlane.y/4.))%2,int(floor(nextPlane.z/4.))%2,1.) * 0.2;\n            vec3 nextMipPlane = vec3(0.0,0.0,0.0);\n            for (int k = 0; k < MIP_DIST; k++) {\n                \n                if (  abs(nextMipPlane.x) >= 4.0\n           \t\t\t|| abs(nextMipPlane.y) >= 4.0\n           \t\t\t|| abs(nextMipPlane.z) >= 4.0)\n        \t\t{\n            \t\tbreak;\n        \t\t}\n            \tif(check((nextPlane + nextMipPlane - 0.5 - 0.5 * sign(d)))){\n                    vec3 endPos = pos + d * distToNext;\n            \t\tfloat dist = distance(pos, endPos);\n\n            \t\tcubePos = (nextPlane + nextMipPlane - 0.5 - 0.5 * sign(d)) + vec3(.5,.5,.5);\n               \n            \t\tdistanceMarch = RayMarch(pos, d, cubePos);\n            \t\tif(distanceMarch > -0.5){\n                \t\t// Base color\n                \t\to += vec4(1.0,0.2,1.0,1.0) * 0.8;\n                \t\tif(cubePos.x < 1. || cubePos.x > 63. || cubePos.z < 1. || cubePos.z > 63. ){\n                    \t\to = vec4(1.0,1.0,0.2,1.0) * 0.8;\n                \t\t}\n                \t\tvec3 hitPos = pos + d * distanceMarch;    \n                \t\tvec3 nor = CalcNormal(hitPos-cubePos,cubePos-vec3(.5));\n                \n                \t\to *= dot(nor, lightDir);\n                \t\t//o += dot(nor, vec3(0,1,0))*0.1;\n                        o *= GetShadow(hitPos, -lightDir); \n                        return;\n            \t\t}\n                }\n                distToNext = (nextPlane + nextMipPlane - pos) / d;\n        \n        \t\tmask = vec3(lessThanEqual(distToNext.xyz, min(distToNext.yzx, distToNext.zxy)));\n        \t\tnextMipPlane += sign(d)*mask;\n            }\n            nextPlane += nextMipPlane;\n     \t}\n        else{\n            distToNext = (nextPlane - pos) / d;        \n        \tmask = vec3(lessThanEqual(distToNext.xyz, min(distToNext.yzx, distToNext.zxy)));\n        \tnextPlane += sign(d)*mask; \n        }\n        \t\n        \n        #else\n        \n        //-----------------------\n        //Not using mip\n        /*if(mipCheck(nextPlane -0.5 + vec3(-2.,0.,-2.) - 0.5 * sign(d))){\n         \to = vec4(0.,1.,0.,1.)   ;\n        }*/\n        if(check(nextPlane - 0.5 - 0.5 * sign(d))){\n            vec3 endPos = pos + d * distToNext;\n            float dist = distance(pos, endPos);\n\n            cubePos = (nextPlane - 0.5 - 0.5 * sign(d)) + vec3(.5,.5,.5);\n               \n            distanceMarch = RayMarch(pos, d, cubePos);\n            if(distanceMarch > -0.5){\n    \t\t\t\n                vec3 hitPos = pos + d * distanceMarch; \n                o = vec4(calcIlumination(hitPos, d, cubePos), 1);\n               \n                \n                break;\n            }   \n        }\n        #endif        \n    }\n    \n    //o *= 1.-vec4(distanceMarch)*.0019;\n    //o *= o;\n    // Trying shadows\n    vec3 hitPos = pos + d * distanceMarch;\n    \n    vec3 nor = CalcNormal(hitPos-cubePos,cubePos-vec3(.5));\n    \n    \n    //o = vec4(nor, 1);\n    //o *= dot(nor, lightDir);\n    o *= GetShadow(hitPos, -lightDir);\n    \n    // Gamma correction\n    o = pow(o, vec4(0.4545));\n    \n    \n    //Some visualizations of the data\n    //o = vec4(0.);\n    //o *= vec4(bounderies*0.01, 1.);\n    //o *= vec4(t, 1.);\n   \t//o *= vec4(mask, 1.);\n    //o *= vec4(sign(d)*mask, 1.); //This is the true normal of the planes\n    //o *= vec4(nextPlane*0.1, 1.);\n    //o  = vec4(vec3(directionHit), 1.)*.5;\n    //o = vec4(vec3(length(hitPos-pos)/200.), 1.);\n    //o = vec4(vec3(length(hitPos/500.)), 1.);\n    //o.xy = fract(s);  o.z = 0.;\n    //o = vec4((distanceMarch)*0.019);\n    float zoom = 5.0;\n    int layer = (1 << 0);\n    //o = vec4(int(texelFetch(iChannel0, ivec2(i/zoom),0).x) & layer);\n    //o = vec4(dot(t,mask)*.5+.5);\n}\n\n//This whole function is a DOUBT? \nbool check(vec3 pos) {\n    int b = 1 << (int(pos.y) % 24);\n    vec4 mask = vec4(lessThan(pos.yyy, vec3(24.,48.,72.)),1.0);\n    mask.yzw -= mask.xyz;\n    int xz = int(dot(mask,texelFetch(iChannel0, ivec2(pos.xz),0)));\n    return ((xz & b) == b);\n}\n\nbool mipCheck(vec3 pos){\n    int p = 1 << (int(pos.y) % 24)/4;\n    vec4 mask = vec4(lessThan(pos.yyy, vec3(24.,48.,72.)),1.0);\n    mask.yzw -= mask.xyz;\n    int xz = int(dot(mask,texelFetch(iChannel2, ivec2(pos.xz)/4,0)));\n    return ((xz & p) == p);\n}\n\n\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////           ///////////////////////////////////////////////\n///////////////////////////////////////////////  MY CODE  ///////////////////////////////////////////////\n///////////////////////////////////////////////           ///////////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat SmoothMin( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\nfloat sdSphere(vec3 pos, float r)\n{\n\treturn length(pos)-r;\n}\n\nfloat getDist(vec3 pos, vec3 cubePos){\n    //vec3 size = vec3(0.5);\n    //float cube = length(max(abs(pos)-size, 0.0));\n    //vec3 mask = vec3(greaterThanEqual(pos.xyz,max(pos.yzx,pos.zxy)));\n    \n    float r = 0.5;\n    float dist = 1000.;\n    float sphere = sdSphere(pos, r);\n    \n    vec4 mask = vec4(sign(pos),0);\n    \n    if(check(cubePos+mask.xww) && (cubePos+mask.xww).x>0. && (cubePos+mask.xww).x<64.){\n        sphere = SmoothMin(sphere,sdSphere(pos-mask.xww, r),0.5);\n    }\n    if(check(cubePos+mask.wyw)){\n        sphere = SmoothMin(sphere,sdSphere(pos-mask.wyw, r),0.5);\n    }\n    if(check(cubePos+mask.wwz) && (cubePos+mask.wwz).z>0. && (cubePos+mask.wwz).z<64.){\n        sphere = SmoothMin(sphere,sdSphere(pos-mask.wwz, r),0.5);\n    }\n    \n    dist = sphere;\n    return dist;\n}\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection, vec3 cubePos)\n{\n    float rayDist = 0.0;\n    for(int i=0; i<MAX_STEPS;i++)\n    {\n        vec3 pos = rayOrigin + rayDist*rayDirection;\n        \t\n        float h = getDist(pos-cubePos,cubePos-vec3(0.5,.5,.5));\n        if(abs(h)<EPSILON) break; // Hit\n        \n        rayDist += h;\n        if(rayDist>SURFACE_DIST) break; // NO hit\n    }\n    if(rayDist>SURFACE_DIST) rayDist = -1.0;\n    return rayDist;\n}\n\nfloat GetShadow(vec3 pos, vec3 dir){\n    //if(pos.y>0.) return 1.;\n    float distanceMarch = -1.;\n    vec3 bounderies = vec3(width, 96., height) * (0.5 - 0.5 * sign(dir));\n    vec3 t = (bounderies - pos) / dir;\n    vec3 mask = vec3(greaterThanEqual(t.xyz, max(t.yzx, t.zxy)));\n    vec3 nextPlane = (1. - mask) * (floor(pos + dir * dot(t, mask)) + 0.5 + 0.5 * sign(dir)) + mask * bounderies;\n    \n    for (int j = 0; j < DISTANCE; j++) {\n        \n        vec3 distToNext;\n        distToNext = (nextPlane - pos) / dir;\n        \n        mask = vec3(lessThanEqual(distToNext.xyz, min(distToNext.yzx, distToNext.zxy)));\n        nextPlane += sign(dir)*mask;\n        \n        if (  nextPlane.x > float(width)  || nextPlane.x < 0.0\n           || nextPlane.y > 96.           || nextPlane.y < 0.0\n           || nextPlane.z > float(height) || nextPlane.z < 0.0)\n        {\n            //distToNext = vec3((96.-pos.y)/d.y);\n   \t\t\treturn 1.;\n        }\n        \n        if (check((nextPlane - 0.5 - 0.5 * sign(dir)).xyz)) {\n            \n    \t\tvec3 cubePos = (nextPlane - 0.5 - 0.5 * sign(dir)) + vec3(.5,.5,.5);\n            \n            //distanceMarch = calcSoftShadow((pos+dir*0.01), dir, 0.01, 3.0, cubePos);\n            \n            distanceMarch = RayMarch((pos+dir*0.01), dir, cubePos);\n            \n            if(distanceMarch >-0.5){\n            \treturn 0.4;\n            }\n     \t}\n    }\n    return 1.;\n}\n\nvec3 CalcNormal(vec3 pos, vec3 cubePos)\n{\n    vec2 e = vec2(EPSILON, 0.0);\n    // Why are the normals inverted?\n    return normalize(-vec3(getDist(pos+e.xyy,cubePos)-getDist(pos-e.xyy,cubePos),\n                    \t   getDist(pos+e.yxy,cubePos)-getDist(pos-e.yxy,cubePos),\n                    \t   getDist(pos+e.yyx,cubePos)-getDist(pos-e.yyx,cubePos)));\n}\n\nfloat calcSoftShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, vec3 cubePos)\n{\n\t/*float res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = getDist( ro + rd*t , vec3(0.));       \n        // use this if you are getting artifact on the first iteration, or unroll the\n        // first iteration out of the loop\n        //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );*/\n    \n    float res = 1.0;\n    float t = 0.001;\n    for(int i=0; i<10;i++)\n    {\n        vec3 pos = ro + t*rd;\n        float h = getDist(pos-cubePos,cubePos-vec3(.5,.5,.5));\n        \n        res = min(res, 16.0*h/t);\n        t += h;\n        \n        if(res<EPSILON) break; // Hit\n        \n        if(t>SURFACE_DIST) break; // NO hit\n    }\n    return clamp(res, 0.,1.);\n   \n}\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//This buffer runs the game and saves the past 96 states.\n\n\n//Width and height of the area of the \"game board\"\n//I suggest matching them with the width and height of Image.\n#define width 64\n#define height 64\n\n//Chance of a cell being alive at start. Kinda complicated to explain the specifics.\n#define INITIAL_CHANCE 1.15\n\nfloat rand(vec2 co);\nbool check(vec3 pos);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec4 col = ivec4(texelFetch(iChannel0, ivec2(fragCoord), 0));\n    \n    if (texelFetch(iChannel2, ivec2(0), 0).y == 1.0) {\n        // Get how many neighbors are 'alive' \n        int neighbors = 0;\n        if (check(vec3(mod(fragCoord + vec2(-1., -1.), vec2(width, height)), 0.0))) neighbors++;\n        if (check(vec3(mod(fragCoord + vec2(-1.,  0.), vec2(width, height)), 0.0))) neighbors++;\n        if (check(vec3(mod(fragCoord + vec2(-1.,  1.), vec2(width, height)), 0.0))) neighbors++;\n        if (check(vec3(mod(fragCoord + vec2( 0., -1.), vec2(width, height)), 0.0))) neighbors++;\n        if (check(vec3(mod(fragCoord + vec2( 0.,  1.), vec2(width, height)), 0.0))) neighbors++;\n        if (check(vec3(mod(fragCoord + vec2( 1., -1.), vec2(width, height)), 0.0))) neighbors++;\n        if (check(vec3(mod(fragCoord + vec2( 1.,  0.), vec2(width, height)), 0.0))) neighbors++;\n        if (check(vec3(mod(fragCoord + vec2( 1.,  1.), vec2(width, height)), 0.0))) neighbors++;\n\n        // The whole 'col' vector is the buffer that stores all states of each cell in the game of life\n        // It fills the x value bitwise up to 24, then the same for y, z and w. In that order\n        // It keeps track of each layer, this is why it is evaluated for 96 layers(4*24=96)\n        \n        if (( col.w & (1 << 23)) == (1 << 23)) {\n            col.w -= (1 << 23);\n        }\n\n        col.w = col.w << 1;\n\n        if ((col.z & (1 << 23)) == (1 << 23)) {\n            col.z -= (1 << 23);\n            col.w++;\n        }\n\n        col.z = col.z << 1;\n\n        if ((col.y & (1 << 23)) == (1 << 23)) {\n            col.y -= (1 << 23);\n            col.z++;\n        }\n\n        col.y = col.y << 1;\n\n        if ((col.x & (1 << 23)) == (1 << 23)) {\n            col.x -= (1 << 23);\n            col.y++;\n        }\n\n        col.x = col.x << 1;\n\n        // Put a 1 if the cell must be alive and nothing if it is dead\n        if ((check(vec3(fragCoord, 0.0)) && neighbors > 1 && neighbors < 4) || (!check(vec3(fragCoord, 0.0)) && neighbors == 3)) {\n            col.x ++;\n        }\n    }\n    \n    fragColor = vec4(col);\n    \n    if (iFrame == 0 || texelFetch(iChannel1, ivec2(13, 1), 0).x == 1.0) {\n        fragColor.x = sign(floor(INITIAL_CHANCE * rand(fragCoord)));\n        fragColor.yzw = vec3(0);\n    }\n}\n\nbool check(vec3 pos) {\n    int xy = int(texelFetch(iChannel0, ivec2(pos.xy), 0).x);\n    return ((xy & 1) == 1);\n}\n\n\n\n\nfloat rand(vec2 co) {\n   \t//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    ###########################\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453 * mod(iDate.w, 100.) / 100.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//This buffer keeps track of how fast the game runs, and handles restarting.\n\n\n//Ticks per second. If it is higher than your framerate, it will just run at your framerate.\n//The game will slowly accelerate until it meets that speed for effect.\n#define speed 20.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float next = texelFetch(iChannel0, ivec2(0),0).x;\n    float startTime = texelFetch(iChannel0, ivec2(0),0).w;\n    \n    if (iFrame == 0 || texelFetch(iChannel1, ivec2(13, 1), 0).x == 1.0) {\n        next = 1.;\n        startTime = (iFrame == 0) ? 0.0 : iTime;\n    }\n    \n    if (iTime - startTime >= next) {\n        fragColor.y = 1.0;\n        next += 1.0 / min(float(speed), iTime - startTime);\n    }\n    fragColor.x = next;\n    fragColor.z = min(float(speed), iTime - startTime);\n    fragColor.w = startTime;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define width 16\n#define height 16\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec4 col;\n    int b = 0;\n    for(int y = 0; y < 6; y++){\n        bool found = false;\n        for(int x = 0; x < 4 && !found; x++){\n            for(int z = 0; z < 4 && !found; z++){\n                b = int(texelFetch(iChannel0, ivec2(4.*fragCoord)+ivec2(x,z), 0).x) >> y*4;\n                if((b & 15) > 0){\n                 \tcol.x = int(col.x | 1<<y);\n                    found = true;\n                }\n            }\n        }\n    }\n    for(int y = 0; y < 6; y++){\n        bool found = false;\n        for(int x = 0; x < 4 && !found; x++){\n            for(int z = 0; z < 4 && !found; z++){\n                b = int(texelFetch(iChannel0, ivec2(4.*fragCoord)+ivec2(x,z), 0).y) >> y*4;\n                if((b & 15) > 0){\n                 \tcol.y = int(col.y | 1<<y);\n                    found = true;\n                }\n            }\n        }\n    }\n    for(int y = 0; y < 6; y++){\n        bool found = false;\n        for(int x = 0; x < 4 && !found; x++){\n            for(int z = 0; z < 4 && !found; z++){\n                b = int(texelFetch(iChannel0, ivec2(4.*fragCoord)+ivec2(x,z), 0).z) >> y*4;\n                if((b & 15) > 0){\n                 \tcol.z = int(col.z | 1<<y);\n                    found = true;\n                }\n            }\n        }\n    }\n    for(int y = 0; y < 6; y++){\n        bool found = false;\n        for(int x = 0; x < 4 && !found; x++){\n            for(int z = 0; z < 4 && !found; z++){\n                b = int(texelFetch(iChannel0, ivec2(4.*fragCoord)+ivec2(x,z), 0).w) >> y*4;\n                if((b & 15) > 0){\n                 \tcol.w = int(col.w | 1<<y);\n                    found = true;\n                }\n            }\n        }\n    }\n    \n    fragColor = vec4(col);\n}","name":"Buffer C","description":"","type":"buffer"}]}