{"ver":"0.1","info":{"id":"lstXDj","date":"1462239869","viewed":1262,"name":"Segmented Bezier","username":"akohdr","description":"Temporally builds primitive line segments.  Includes quadratic Bezier approximated to straight sections.\nMouse sets Bezier control point, Mouse.x sets circle time offset.","likes":45,"published":1,"flags":0,"usePreview":0,"tags":["2d","bezier","lines"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Examples of generation and traversal of primitive line segments in interval 0<=t<=1\n\n// comment to hide output\n#define SHOW_GRN_LINES\n#define SHOW_BLU_LINES\n#define SHOW_CURSORS\n#define BLOOM\n\n#define RED vec4(1.,.5,0,1)\n#define GRN vec4(0,.5,0,1)\n#define BLU vec4(0,0,1,1)\n#define BLK vec4(0,0,0,1)\n\n#define PI  3.14159265358979\n#define PI2 6.28318530717858\n\nvec2 rot2D(vec2 p, float a) \n{\n    vec3 csa = vec3(cos(a),-sin(a),0);\n               csa.z = -csa.y;\n    return p * mat2( csa.xyzx);\n}\n\n           \n// convert (x,y) to polar coordinate (r,a)\nvec2 polar(vec2 p)\n{\n    float x = p.x,  \n          y = p.y,\n          a = atan(abs(y/x)),\n          r = sqrt(x*x+y*y);\n    \n    // quadrant adjustment\n    a = x>0. ? y>0. ?    a : PI2-a :\n               y>0. ? PI-a :  PI+a;\n                   \n\treturn vec2(r, a);    \n}\n\n\nvoid antialias(inout vec4 k, float d, float w)\n{\n    float w1 = max(.2,.5*w),\n          s  = w1/(d+2e-9);\n    \t  s += w1/(d-3e-9);\n    \n    k += vec4(1)*s;\n}\n\n\nfloat dLine(vec2 p, vec2 a, vec2 b) \n{\n    b -= a;  \n    p -= a;\n    return length (p - clamp (dot (p, b) / dot (b, b), .0, 1.) * b);\n}\n\n\nvec2 linePos(vec2 a,vec2 b, float t)\n{\n    vec2 d = a - b,\n         s = -d / d;\n    float g = s.y / s.x,\n          d1 = 1. - t;\n    vec2 l = g * d1 * d;\n    return b + l;\n}\n\n// temporal straight line t steps from a -> b\nfloat dLine(vec2 p, vec2 a, vec2 b, float t) \n{\n    return dLine(p, a, linePos(a,b,t));\n}\n\n// standard circle\nfloat dCircle(vec2 p, vec2 a, float r, float w)\n{\n    float w2 = w/2.,\n           l = length(p-a);\n    return (l>r) ? abs((l-r)+w2): abs((r-l)-w2);\n}\n\n\nvec2 cirPos(vec2 a, float r, float t)\n{\n    return a+r*vec2(cos(PI2*t),sin(PI2*t));\n}\n\n\n// circular arc (anti clockwise) t steps from s toward full circle\nfloat dCircle(vec2 p, vec2 a, float r, float w, float t, float s)\n{\n    vec2 pa = rot2D(p-a,PI2*s),\n        pol = polar(pa);\n    float l = length(pa),\n         w2 = w/2.;\n    \n    return (pol.x>r+w || pol.y > PI2*t) ? 1e9 : \n    \t\t(l>r) ? abs((l-r)+w2) : abs((r-l)-w2);\n}\n\n\n// optimized version of quadratic bezier curve position\nvec2 bzPos(float t, vec2 a, vec2 b, vec2 c) \n{\n    float mT = 1.-t;\n//    vec2 pos = a * 1.      * mT*mT +\n//               b * 2.* t   * mT    + \n//               c * 1.* t*t          ;\n    return a *           mT*mT +\n           b * 2.* t   * mT    + \n           c *     t*t          ;\n}\n\n\n// standard math version\nvec2 bzPos_Math(float t, vec2 a, vec2 b, vec2 c) {  \n    // b is control point a,c endpoints\n    \n    t = 1.-t;\n//    vec3 tv = vec3(1, t, t*t);   // forgot to reverse tv\n    vec3 tv = vec3(t*t, t, 1);\n    \n    const mat3 bz2D = mat3( 1, 0, 0,\n                           -2, 2, 0,\n                            1,-2, 1);\n\n    // pad mat3 since no 2x3 matrices\n    mat3 m_xy = mat3(a.x, b.x, c.x,\n                     a.y, b.y, c.y,\n                     0,   0,   0   );\n   \n\tvec3 v3 = tv * (bz2D * m_xy);\t// are padded mat3 op more efficient on GPU?\n    return v3.xy;\n}\n\n\n// bezier curve abc built from segments dt steps from a -> c\nfloat dBezierSegs(vec2 p, vec4 ac, vec2 b, float dt) {\n    float d = 9999.;\n    vec2 a = ac.xy, c = ac.zw, q = a, r;\n    \n    for(float t=0.; t<=1.; t+=.03) {\n        r = bzPos(t,a,b,c);\n        d = min(d, dLine(p,q,r));\n        q = r;\n        if(t>dt) return d;\n    }\n    \n    return d;\n}\n\n\nvoid mainImage( out vec4 k, in vec2 p )\n{\n    float t = iTime,\n         st = .5-.5*cos(t),\n          w = 3.;\n    \n\tvec2 ir = iResolution.xy,\n          a = ir * vec2(.15),\n          b = ir * vec2(.8),\n          c = ir * vec2(.3,.8),\n         dx = ir * vec2(.3,0),\n//          q = iMouse.z>0. ? iMouse.xy : b;\n          q = iMouse.x>0. ? iMouse.xy : b;\n    float cs = q.x/ir.x;\n        \n    vec4 ka = BLK;\n#ifdef SHOW_GRN_LINES\n    // antialiases lines\n    antialias(ka, dBezierSegs(p,vec4(a,c),q,1.), w);\n    antialias(ka, dLine(p,a+dx,c+dx), w);\n    antialias(ka, dCircle(p, a+vec2(2,.5)*dx.xx, a.x,w), w);\n#endif \n    \n#ifdef BLOOM\n    w = max(2., 15.*st);\n#else\n    w = 2.;\n#endif\n    float w2 = w/2.;\n    \n    vec4 kt = BLK;\n#ifdef SHOW_BLU_LINES\n    // temporal lines\n    antialias(kt, dBezierSegs(p,vec4(a,c),q,st), w);\n    antialias(kt, dLine(p,a+dx,c+dx,st), w);\n    antialias(kt, dCircle(p, a+vec2(2,.5)*dx.xx, a.x+w2, w, st, cs), w);\n#endif \n    \n    vec4 kc = BLK;\n#ifdef SHOW_CURSORS\n    // cursor points\n    antialias(kc, dCircle(p, q, 2.,w), w);\n    antialias(kc, dCircle(p, bzPos(st, a, q, c), 2., w), w);\n    antialias(kc, dCircle(p, linePos(a+dx,c+dx, st), 2., w), w);\n    antialias(kc, dCircle(p, cirPos(a+vec2(2,.5)*dx.xx, a.x, st-cs), 2., w), w);\n#endif \n    \n\t// GRN line is fixed line primitive for interval 0<t<1\n    // BLU line temporal section for interval 0<t\n    k = mix(mix(GRN*ka,BLU*kt,.5),RED*kc,.5);\n}\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}