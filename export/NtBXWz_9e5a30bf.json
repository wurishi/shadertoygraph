{"ver":"0.1","info":{"id":"NtBXWz","date":"1627394141","viewed":93,"name":"Fake Reflection Shadow Tracer","username":"lyar_soft","description":"A ray martcher with volumetric shadows, fogs and ray-tracing-based fake reflections.\n","likes":2,"published":1,"flags":16,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//============================================================================\n// PROJECT ID: SWS3005_ 11\n//\n// GROUP NUMBER: 11\n//\n// STUDENT NAME: Luo Ye'an \n// NUS User ID.: t0922585\n//\n// STUDENT NAME: Wang Xinyu\n// NUS User ID.: t0922507\n//\n// COMMENTS TO GRADER: \n// Implemented ray marching combined with ray tracing to produce soft \n// shadow, volumetric shadow and their reflection images. Ray marching \n// technique for generating shadow and scattering was borrowed from\n// https://www.shadertoy.com/view/XlBSRz.\n//\n// If the frame rate is too low, try to set NUM_ITERATIONS to 1, which\n// will completely disable reflection.\n//\n// Press down arrow or up arrow to add dynamic light sources.\n//\n//============================================================================\n\n\nconst float PI = 3.1415926536;\nconst float FOVY = 50.0 * PI / 180.0;\nconst vec3 BACKGROUND_COLOR = vec3( 0.0, 0.0, 0.0 );\nconst float DEFAULT_TMIN = 10.0e-4;\nconst float DEFAULT_TMAX = 10.0e6;\nconst int NUM_ITERATIONS = 3;\nint lightLimit = 1;\n\n\n\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nbool isKeyPressed(float key)\n{\n\treturn texture(iChannel1, vec2(key, 0.5/3.0) ).x > 0.5;\n}\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n    float shadowCasting;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n    float shadowCasting;\n};\n\nstruct SphereFog_t {\n    vec3 center;\n    float radius;\n    float shadowCasting;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n    float strength;\n};\n\nstruct LightingSlot{\n    vec3 texColor;\n    vec3 amb;\n    vec3 krg;\n    vec3 lightAndShadow;\n    vec4 scatter;\n    vec3 hitNormal;\n    int mat_id;\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 7;\nconst int NUM_PLANES = 6;\nconst int NUM_SPHERES = 3;\nconst int NUM_SPHERE_FOGS = 1;\n\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nSphereFog_t SphereFog[NUM_SPHERE_FOGS];\n\n\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    bool intersect = false;\n    float delta = 0.0;\n    float inter = dot(ray.d, ray.o - sph.center);\n    float dirDot = dot(ray.o - sph.center, ray.o - sph.center);\n    float root = 0.0;\n    float t1 = 0.0, t2 = 0.0, minT = DEFAULT_TMAX;\n    float lenSquare = dot(ray.d, ray.d);\n    delta = inter * inter - dirDot + sph.radius * sph.radius;\n    if(delta >= 0.0){\n        root = sqrt(delta);\n        t1 = (-inter - root) / lenSquare;\n        t2 = (-inter + root) / lenSquare;\n        if(tmin < t1 && t1 < tmax && t1 < minT){\n            minT = t1;\n            intersect = true;\n        }\n        if(tmin < t2 && t2 < tmax && t2 < minT){\n            minT = t2;\n            intersect = true;\n        }\n        t = minT;\n        hitPos = ray.o + t * ray.d;\n        hitNormal = normalize(hitPos - sph.center);\n    }\n    else{\n        intersect = false;\n    }\n    return intersect;  // Replace this with your code.\n}\n\n\nvoid InitScene()\n{\n    \n    Plane[0].A = 1.0;\n    Plane[0].B = 0.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 1;\n\n\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = -1.0;\n    Plane[1].D = 0.0;\n    Plane[1].materialID = 0;\n\n    Plane[2].A = 0.0;\n    Plane[2].B = 1.0;\n    Plane[2].C = 0.0;\n    Plane[2].D = 0.0;\n    Plane[2].materialID = 6;\n\n    Plane[3].A = 0.0;\n    Plane[3].B = -1.0;\n    Plane[3].C = 0.0;\n    Plane[3].D = 60.0;\n    Plane[3].materialID = 6;\n\n    Plane[4].A = -1.0;\n    Plane[4].B = 0.0;\n    Plane[4].C = 0.0;\n    Plane[4].D = 50.0;\n    Plane[4].materialID = 3;\n\n    Plane[5].A = 0.0;\n    Plane[5].B = 0.0;\n    Plane[5].C = 1.0;\n    Plane[5].D = -60.0;\n    Plane[5].materialID = 6;\n\n    Sphere[0].center = vec3( 40.0, 20.0 + 10.0 * sin(iTime), -20.0 );\n    Sphere[0].radius = 5.0;\n    Sphere[0].materialID = 4;\n    Sphere[0].shadowCasting = 5.0;\n    if(isKeyPressed(KEY_RIGHT)) Sphere[0].center = vec3( 40.0, 20.0 + 10.0, -20.0 );\n\n    Sphere[1].center = vec3( 10.0, 10.0 + 10.0 * cos(iTime), -20.0 );\n    Sphere[1].radius = 5.0;\n    Sphere[1].materialID = 2;\n    Sphere[1].shadowCasting = 5.0;\n    if(isKeyPressed(KEY_RIGHT)) Sphere[1].center = vec3( 10.0, 10.0 + 10.0, -20.0 );\n\n    Sphere[2].center = vec3( 25.0, 15.0 + 10.0 * sin(iTime), -20.0 );\n    Sphere[2].radius = 5.0;\n    Sphere[2].materialID = 1;\n    Sphere[2].shadowCasting = 5.0;\n    if(isKeyPressed(KEY_RIGHT)) Sphere[2].center = vec3( 25.0, 15.0 + 10.0, -20.0 );\n\n    SphereFog[0].center = vec3(20.0, 32.0, -17.0);\n    SphereFog[0].radius = 5.0;\n    SphereFog[0].shadowCasting = 1.0;\n\n    Material[0].k_d = vec3( 1.0, 0.0, 0.0 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    Material[1].k_d = vec3( 1.0, 1.0, 1.0);\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 4.0 * Material[1].k_d;\n    Material[1].n = 64.0;\n\n    Material[2].k_d = vec3( 0.0, 0.0, 1.0 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n\n    Material[3].k_d = vec3( 0.3, 0.9, 0.3 );\n    Material[3].k_a = 0.2 * Material[3].k_d;\n    Material[3].k_r = 2.0 * Material[3].k_d;\n    Material[3].k_rg = 1.5 * Material[3].k_d;\n    Material[3].n = 64.0;\n\n    Material[4].k_d = vec3( 0.8, 0.7, 0.1 );\n    Material[4].k_a = 0.2 * Material[4].k_d;\n    Material[4].k_r = 2.0 * Material[4].k_d;\n    Material[4].k_rg = 5.0 * Material[4].k_r;\n    Material[4].n = 64.0;\n\n    Material[5].k_d = vec3( 0.0, 0.8, 0.0 );\n    Material[5].k_a = 0.2 * Material[5].k_d;\n    Material[5].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[5].k_rg = 0.5 * Material[5].k_r;\n    Material[5].n = 128.0;\n\n    Material[6].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[6].k_a = 0.2 * Material[6].k_d;\n    Material[6].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[6].k_rg = vec3( 0.0 );\n    Material[6].n = 128.0;\n\n    Light[0].position = vec3( 28.0, 40.0,-20.0);\n    if(isKeyPressed(KEY_DOWN)) Light[0].position = vec3( 28.0, 23.0+ 16.0 * sin(0.5 * iTime),-10.0);\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 0.9, 0.5);\n    Light[0].strength = 600.0;\n\n    Light[1].position = vec3( 20.0+15.0, 15.0+12.0*cos(iTime * 0.4),-20.0 -15.0*sin(iTime * 0.4));\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = vec3( 1.0, 0.9, 0.5);\n    Light[1].strength = 300.0;\n}\n\nfloat displacementSimple( vec2 p )\n{\n    float f;\n    f  = 0.5000* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;\n    f += 0.2500* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;\n    f += 0.1250* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;\n    f += 0.0625* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;\n    return f;\n}\n\nvec3 getTexColor(vec3 p, in int material, out vec3 amb)\n{\n\tif(material >= 0){\n        amb = Material[material].k_a;\n        return Material[material].k_d;\n    }\n\t\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\nvec3 evaluateLight(in vec3 pos, in int lightIndex)\n{\n    vec3 lightPos = Light[lightIndex].position;\n    vec3 lightCol = Light[lightIndex].I_source * Light[lightIndex].strength;\n    vec3 L = lightPos-pos;\n    return lightCol * 1.0/dot(L,L);\n}\n\nvec3 evaluateLight(in vec3 pos, in vec3 normal, in int lightIndex)\n{\n    vec3 lightPos = Light[lightIndex].position;\n    vec3 L = lightPos-pos;\n    float distanceToL = length(L);\n    vec3 Lnorm = L/distanceToL;\n    return max(0.0,dot(normal,Lnorm)) * evaluateLight(pos, lightIndex);\n}\n\nvoid SDFLighting(out float sigmaS, out float sigmaE, in vec3 pos)\n{\n    float heightFog = 7.0 + 3.0 * clamp(displacementSimple(pos.xz*0.005 + iTime*0.01),0.0,1.0);\n    heightFog = 0.3* 4.0 *clamp((heightFog-pos.y)*1.0, 0.0, 1.0);\n    \n    const float fogFactor = 1.0 + 0.0 * 5.0;\n    int i = 0;\n    float sphereShadow = 0.0;\n    float planeShadow = 0.0;\n    for(i = 0; i < NUM_SPHERE_FOGS; ++i){\n        sphereShadow += clamp((SphereFog[i].radius - length(pos-SphereFog[i].center))/SphereFog[i].radius, 0.0,1.0) * SphereFog[i].shadowCasting;\n    }\n    for(i = 0; i < NUM_SPHERES; ++i){\n        sphereShadow += clamp((Sphere[i].radius - length(pos-Sphere[i].center))/Sphere[i].radius, 0.0,1.0) * Sphere[i].shadowCasting;\n    }\n    const float constantFog = 0.005;\n    sigmaS = constantFog + heightFog*fogFactor + sphereShadow + planeShadow;\n    sigmaE = max(0.000000001, sigmaS); \n}\n\n\nfloat phaseFunction()\n{\n    return 1.0/(4.0*PI);\n}\n\nfloat volumetricShadow(in vec3 from, in int lightIndex)\n{\n    const float numStep = 32.0;\n    float shadow = 1.0;\n    float sigmaS = 0.0;\n    float sigmaE = 0.0;\n    vec3 to = Light[lightIndex].position;\n    float dd = length(to-from) / numStep;\n\n    for(float s=0.5; s<(numStep-0.1); s+=1.0)\n    {\n        vec3 pos = from + (to-from)*(s/(numStep));\n        SDFLighting(sigmaS, sigmaE, pos);\n        shadow *= exp(-sigmaE * dd);\n    }\n    return shadow;\n}\n\nvoid traceScene(vec3 camPos, vec3 viewDir, out vec3 clr)\n{\n\tconst int numIter = 800;\n    float sigmaS = 0.0;\n    float sigmaE = 0.0;\n    LightingSlot slots[NUM_ITERATIONS];\n    float transmittance = 1.0;\n    vec3 scatteredLight = vec3(0.0, 0.0, 0.0);\n    \n\tfloat d = 1.0;\n\tint material = 0;\n\tvec3 p = vec3(0.0, 0.0, 0.0);\n    float dd = 0.0;\n    int j = 0;\n    Ray_t ray;\n    vec3 nextView = normalize(viewDir);\n    vec3 nextPos = camPos;\n    vec3 amb;\n    int rayLevel = 0;\n    vec3 compounded_k_rg = vec3(1.0);\n    vec3 finalPos = vec3(0.0);\n    vec3 normal = vec3(0.0);\n    \n        for (rayLevel = 0; rayLevel < NUM_ITERATIONS; ++rayLevel){\n            ray.o = nextPos;\n            ray.d = nextView;\n            int i = 0;\n\n            bool hasHitSomething = false;\n            float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n            vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n            vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n            int nearest_hitMatID = 0;             // MaterialID of the object at the nearest hit point.\n\n            float temp_t;\n            vec3 temp_hitPos;\n            vec3 temp_hitNormal;\n            bool temp_hasHit;\n\n            for(i = 0; i < NUM_SPHERES; ++i){\n                temp_hasHit = IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n                if(temp_hasHit && temp_t < nearest_t){\n                    nearest_t = temp_t;\n                    nearest_hitPos = vec3(temp_hitPos);\n                    nearest_hitNormal = vec3(temp_hitNormal);\n                    nearest_hitMatID = Sphere[i].materialID;\n                    hasHitSomething = true;\n                }\n            }\n\n            for(i = 0; i < NUM_PLANES; ++i){\n                temp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n                if(temp_hasHit && temp_t < nearest_t){\n                    nearest_t = temp_t;\n                    nearest_hitPos = vec3(temp_hitPos);\n                    nearest_hitNormal = vec3(temp_hitNormal);\n                    nearest_hitMatID = Plane[i].materialID;\n                    hasHitSomething = true;\n                }\n            }\n\n\t        for(i=0; i<numIter;++i)\n\t        {\n\t        \tp = nextPos + d*nextView;\n                vec3 S = vec3(0.0);\n                for(j = 0; j < lightLimit; ++j){\n                    SDFLighting(sigmaS, sigmaE, p);\n                    S += (evaluateLight(p, j))* sigmaE * phaseFunction()* volumetricShadow(p,j);\n                }\n                vec3 Sint = (S - S * exp(-sigmaE * dd)) / sigmaE;\n                scatteredLight += transmittance * Sint;\n                transmittance *= exp(-sigmaE * dd);\n                dd = min(1.0, nearest_t - d);\n                if(dd<0.02 || d >= nearest_t) break; \n\t        \td += dd;\n\t        }\n            finalPos = nextPos + d*nextView;\n            material = -1;\n            slots[rayLevel].texColor = vec3(0.0);\n            slots[rayLevel].amb = vec3(0.1);\n            slots[rayLevel].krg = vec3(0.0);\n            slots[rayLevel].lightAndShadow = vec3(0.0);\n            slots[rayLevel].scatter = vec4(scatteredLight, transmittance);\n            slots[rayLevel].hitNormal = vec3(0.0);\n            slots[rayLevel].mat_id = -1;\n\t        if(hasHitSomething){\n                finalPos = nextPos + nearest_t * normalize(nextView);\n                normal = nearest_hitNormal;\n                material = nearest_hitMatID;\n            }\n            else {\n                break;\n            }\n            vec3 lightL = vec3(0.0), shadowL = vec3(0.0);\n            for(j = 0; j < lightLimit; ++j){\n                lightL += (evaluateLight(finalPos, normal, j));\n                shadowL += volumetricShadow(finalPos,j);\n            }\n            slots[rayLevel].lightAndShadow = lightL * shadowL;\n            slots[rayLevel].hitNormal = normal;\n            slots[rayLevel].krg = Material[material].k_rg;\n            slots[rayLevel].mat_id = material;\n            slots[rayLevel].texColor = getTexColor(finalPos, material, amb);\n            slots[rayLevel].amb = amb;\n            nextPos = finalPos;\n            nextView = normalize(reflect(nextView, normal));\n            d = 0.0;\n            dd = 0.5;\n        }\n        if(NUM_ITERATIONS > 1){\n            for(; rayLevel >= 1; --rayLevel){\n                vec3 color = (slots[rayLevel].texColor / PI) * slots[rayLevel].lightAndShadow;\n                color = color * slots[rayLevel].scatter.w + slots[rayLevel].scatter.xyz;\n                slots[rayLevel - 1].texColor += color * slots[rayLevel - 1].krg;\n            }\n        }\n        \n    \n    clr = (slots[0].texColor / PI) * slots[0].lightAndShadow;\n    clr += slots[0].amb * 0.05;\n    clr = clr * slots[0].scatter.w + slots[0].scatter.xyz;\n    clr = pow(clr, vec3(1.0/2.2));\n}\n\nvec3 camPos = vec3( 20.0, 38.0,-90.0);\nvec3 cam_lookat = vec3( 20.0, 38.0, 0.0 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    if(isKeyPressed(KEY_LEFT)) camPos = vec3( 20.0, 38.0,-60.0);\n\t\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n    vec3 dir = camPos - cam_lookat;\n    if(isKeyPressed(KEY_UP)){\n        lightLimit = 2;\n    }\n    \n    if(iMouse.x+iMouse.y > 0.0){\n        vec3 ms = (vec3(iMouse.x, iMouse.y, 0.0)-vec3(iResolution.xy*0.5, 0.0)) / 300.0;\n        dir = normalize(dir * mat3(cos(ms.x), 0.0, sin(ms.x), 0.0, 1.0, 0.0, sin(ms.x), 0.0, cos(ms.x)));\n        dir = normalize(dir * mat3(1.0, 0.0, 0.0, 0.0, cos(ms.y), sin(ms.y), 0.0, -sin(ms.y), cos(ms.y)));\n        cam_up_vec = normalize(cam_up_vec * mat3(cos(ms.x), 0.0, sin(ms.x), 0.0, 1.0, 0.0, sin(ms.x), 0.0, cos(ms.x)) * mat3(1.0, 0.0, 0.0, 0.0, cos(ms.y), sin(ms.y), 0.0, -sin(ms.y), cos(ms.y)));\n    }\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 cam_z_axis = normalize( dir);\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n\t\n\tvec3 rD = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n    vec3 cl = vec3( 0.0, 0.0, 0.0 );\n    \n    traceScene(camPos, rD, cl);\n\tfragColor = vec4(cl ,1.0);\n}\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}