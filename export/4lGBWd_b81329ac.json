{"ver":"0.1","info":{"id":"4lGBWd","date":"1544447280","viewed":82,"name":"something something raytracing","username":"eclmist","description":"raytracing\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct sphere {\n\tvec3 center;\n    float radius;\n};\n    \nstruct ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \nstruct light\n{\n    vec3 dir;\n    float intensity;\n    vec3 color;\n    vec3 ambient;\n};\n    \nstruct plane\n{\n    float d;\n    vec3 normal;\n};\n    \nvec3 getPointOnRay(ray r, float t) {\n    return r.origin + t * r.dir;\n}\n\nbool raycastSphere(ray r, sphere s, out vec3 hitPoint) {\n \t\n    vec3 so = s.center - r.origin;\n    float t = dot(so, r.dir);\n    vec3 p = getPointOnRay(r, t);\n    float y = length(so - p);\n    \n    if (y <= s.radius) {            \n        float x = sqrt(pow(s.radius, 2.0) - (y*y));\n        hitPoint = getPointOnRay(r, t - x);        \n    \treturn true;\n    }\n    \n    \n    return false;\n}\n\nbool raycastPlane(ray r, plane p) {\n\treturn dot(r.dir, p.normal) < 0.0;    \n}\n\nfloat remap01(float a, float b, float r) {\n \treturn (r - a) / (b - a);   \n}\n\n\n\nvec3 calcDiffuse(vec3 pos, vec3 normal, light l) {\n    return l.ambient + l.color * l.intensity * max(0.0, dot(normal, l.dir));\n}\n\nvec3 calcSpecular(vec3 v, vec3 normal, light l) {\n    vec3 rf = reflect(l.dir, normal);\n    float RdotV = max(0.0, dot(rf, v)) * 0.42;\n    float pf = pow(RdotV, 200.);\n    \n    return l.color * pf * 0.005;\n}\n\nvec3 calcReflection(vec3 v, vec3 normal) {\n \tvec3 rf = reflect(v, normal);\n    float dp = max(0., dot(rf, vec3(0, 1, 0)));\n    float dr = max(0., dot(rf, vec3(0, -1, 0)));\n    return dp * vec3(0.3, 0.8, 1.0) + dr * vec3(0.5);\n}\n\nvec3 calcLighting(vec3 pos, vec3 normal, vec3 view, light sun){\n    \n \treturn (calcDiffuse(pos, normal, sun) +\n        \tcalcSpecular(view, normal, sun) +\n        \tcalcReflection(view, normal) * 0.75) *\n        vec3(0.8, 0.5, 0.6);\n}\n\nvec3 calcRefraction(vec3 n, vec3 view) {\n    vec3 rf = refract(view, n, 1./1.4);\n  \n    float dp = dot(rf, vec3(0, 1, 0));\n    return dp >= 0.\n        ? vec3(0.3, 0.8, 1.0)\n        : vec3(0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) /iResolution.y;\n    vec3 col = vec3(0);\n\n    // view ray\n    ray r;\n    r.origin = vec3(0.0);\n    r.dir = normalize(vec3(uv, 2.0));\n    \n    sphere s;\n    s.center = vec3(sin(iTime) * 5., sin(iTime), 30. + 10. * cos(iTime * 0.5));\n    s.radius = 2.0;\n    \n    // floor\n    plane p;\n    p.normal = vec3(0., 1., 0.);\n    p.d = dot(vec3(0.0, 0.0, -5.0), p.normal);\n\n    \n    // Draw Sphere\n    vec3 hit = vec3(0,0,0);\n    \n    if(raycastSphere(r, s, hit)){\n     \t// setup lighting\n        light sun;\n        \n        float ct = cos(iTime);\n        float st = sin(iTime);\n        mat3x3 rot = mat3x3(ct, 0, -st, 0, 1, 0, st, 0, ct);\n        \n        sun.dir = rot * vec3(1., 1., -2.);\n        sun.color = vec3(0.8, 0.9, 0.8);\n        sun.intensity = 0.45;\n        sun.ambient = vec3(0.05, 0.05, 0.2);\n        \n        vec3 n = normalize(hit - s.center);\n        \n        col = calcLighting(hit, n, r.dir, sun);\n    } else if (raycastPlane(r, p)) {\n        col = vec3(0.5,0.5,0.5);\n    } else {\n        col = vec3(0.3, 0.8, 1.0);\n    }\n    \n    \n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}