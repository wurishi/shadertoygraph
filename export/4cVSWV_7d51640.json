{"ver":"0.1","info":{"id":"4cVSWV","date":"1715791893","viewed":27,"name":"pbr experiments 2","username":"int_45h","description":"my lips are sealed","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["e"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\n#define MIN_DIST .001\n#define MAX_DIST 100.\n#define STEPS 80\n#define SHADOW_STEPS 20\n#define FOV 90.\n\n#define res iResolution\n\nfloat mdot(vec3 a, vec3 b){return max(dot(a,b),0.);}\nfloat luma(vec3 p){return dot(p, vec3(.299,.587,.114));}\n\nstruct surface\n{\n    float d, spec, rough, metal;\n    vec3 color;\n};\n\n// https://www.shadertoy.com/view/csdGR7\nvec3 ACES(vec3 x) {\n    float a = 2.51;\n    float b =  .03;\n    float c = 2.43;\n    float d =  .59;\n    float e =  .14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nfloat smooth_union(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sd_sphere(vec3 p, float r){return length(p)-r;}\n\nsurface blend_surface(surface a, surface b, float s)\n{\n    float d = .5+.5*((a.d - b.d) / s);\n    d = clamp(d, 0., 1.);\n    \n    return surface(\n        smooth_union(a.d,b.d,s),\n        mix(a.spec,b.spec,d),\n        mix(a.rough,b.rough,d),\n        mix(a.metal,b.metal,d),\n        mix(a.color,b.color,d)\n    );\n}\n\nsurface SDF(vec3 p)\n{\n    float r = 0.1;\n    float m = .0;\n    surface s1 = surface(sd_sphere(p-vec3(+0.,+0.,5), .6), .5, r, m, vec3(1));\n    surface s2 = surface(sd_sphere(p-vec3(-.8,+.8,5), .5), .5, r, m, vec3(1));\n    surface s3 = surface(sd_sphere(p-vec3(-.8,-.8,5), .5), .5, r, m, vec3(1));\n    surface s4 = surface(sd_sphere(p-vec3(+.8,+.8,5), .5), .5, r, m, vec3(1));\n    surface s5 = surface(sd_sphere(p-vec3(+.8,-.8,5), .5), .5, r, m, vec3(1));\n    \n    float s = .4;\n    \n    return blend_surface(blend_surface(\n        blend_surface(s2, s3, s),\n        blend_surface(s4, s5, s),\n        s\n    ), s1, s);\n}\n\nvec3 get_bg(vec3 d){return texture(iChannel0, d).rgb;}\nvec3 get_tex_sphere(vec3 p)\n{\n    float r = length(p);\n    float a = atan(p.y/p.x);\n    float z = atan(p.z/r);\n    \n    return texture(iChannel1, vec2(a,z)).rgb;\n}\n\nvec3 get_tex_tri(vec3 p, vec3 n, float s)\n{\n    vec3 ax = texture(iChannel1, p.yz*s).rgb;\n    vec3 ay = texture(iChannel1, p.xz*s).rgb;\n    vec3 az = texture(iChannel1, p.xy*s).rgb;\n    \n    vec3 triW = abs(n);\n    triW /= dot(triW, vec3(1));\n    \n    return ax * triW.x + ay * triW.y + az * triW.z;\n}\n\nvec3 get_normals(vec3 p)\n{\n    const float e = .001;\n    const vec2 k = vec2(e,-e);\n    return normalize(vec3(\n        k.xyy*SDF(p+k.xyy).d+\n        k.yyx*SDF(p+k.yyx).d+\n        k.yxy*SDF(p+k.yxy).d+\n        k.xxx*SDF(p+k.xxx).d\n    ));\n}\n\nfloat get_shadow(vec3 p, vec3 n, vec3 l, int k)\n{\n    float s = 1.;\n    \n    vec3 o = p+n*.01;\n    vec3 d = l;\n    float t = 0.;\n    \n    for (int i=0; i<20; i++)\n    {\n        vec3 p2 = o+d*t;\n        float res = SDF(p2).d;\n        t += res;\n        \n        if (res < MIN_DIST)\n            return 0.;\n            \n        s = min(float(k)*res/t,s);\n    }\n    \n    return s;\n}\n\n// https://typhomnt.github.io/teaching/ray_tracing/raymarching_intro/#bonus-effect-ambient-occulsion\nfloat get_ao2(vec3 o, vec3 n, float od, int s)\n{\n    float is = 1./float(s);\n    float t = 0.;\n    float ao = 0.;\n    \n    for (int i=0;i<s;i++)\n    {\n        t += is*float(i)*od;\n        ao += clamp(.5+.5*SDF(o+n*t).d/(t+.001),0.,1.);\n    }\n    ao *= is;\n    return ao*ao*ao;\n}\n\nfloat beckmann(float r, float NdotH)\n{\n    float r2 = r*r;\n    float nh2 = NdotH*NdotH;\n    return exp((nh2-1.) / (r2*nh2+.001)) / (PI*r2*nh2*nh2+.001);\n}\n\nfloat cook_torrance(float NdotH, float NdotV, float NdotL, float VdotH)\n{\n    return min(1., min(\n        2.*NdotH*NdotV / (VdotH+.001), \n        2.*NdotH*NdotL / (VdotH+.001)\n    ));\n}\n\nfloat schlick(float ior)\n{\n    float s = ior*ior;\n    s *= s * ior;\n    return s;\n}\n\nvec3 brdf(vec3 p, vec3 o, vec3 d, surface s)\n{\n    vec3 lp = vec3(2,2,3);\n    vec3 lc = vec3(1);\n    vec3 n = get_normals(p);\n    vec3 v = normalize(o-d);\n    vec3 l = lp-p;\n    vec3 h = normalize(l+v);\n    // Attenuation\n    float a = length(l);\n    a = 20. / (a*a);\n    l = normalize(l);\n            \n    // Important dot products\n    float NdotL = mdot(n,l);\n    float NdotV = mdot(n,v);\n    float NdotH = mdot(n,h);\n    float VdotH = mdot(v,h);\n            \n    // Radiometry\n    lc = lc*mix(s.color, vec3(.04), s.metal);\n    vec3 r = lc * a;\n            \n    float s5 = schlick(VdotH);\n    float D = beckmann(s.rough, NdotH);\n    float G = cook_torrance(NdotH, NdotV, NdotL, VdotH);\n    vec3 F = lc+(1.-lc)*s5;\n            \n    vec3 kS = D*G*F / (4.*NdotL*NdotV+.002);\n    vec3 kD = (1.-kS)*(1.-s.metal);\n            \n    vec3 ab = get_tex_tri(p,n,.25);\n    vec3 Lo = (kD*ab/PI+kS)*r*NdotL;\n    float ao = get_ao2(p,n,.5,8);\n    vec3 kA = .4*ab*ao;\n            \n    float sh = get_shadow(p,n,l,8);\n    return kA + Lo*sh;\n}\n\nvec4 raymarch(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*res.xy)/res.y;\n    vec3 o = vec3(0);\n    vec3 d = normalize(vec3(uv*tan(.5*FOV*PI/180.), 1));\n    float t = 0.;\n    \n    vec4 col = vec4(get_bg(d), 1);\n    \n    for (int i=0;i<STEPS;i++)\n    {\n        vec3 p = o+d*t;\n        surface s = SDF(p);\n        t += s.d;\n        \n        if (t > MAX_DIST)\n            break;\n            \n        if (s.d < MIN_DIST)\n        {\n            col = vec4(brdf(p,o,d,s),1);\n            break;\n        }\n    }\n    \n    col = vec4(ACES(col.xyz), 1);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = raymarch(fragCoord);\n}","name":"Image","description":"","type":"image"}]}