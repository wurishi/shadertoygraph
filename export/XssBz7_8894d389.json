{"ver":"0.1","info":{"id":"XssBz7","date":"1495422538","viewed":185,"name":"Fun with fuzzy logic and colors","username":"FractalCurious","description":"SEIZURE WARNING!\n\nhttps://en.wikipedia.org/wiki/Fuzzy_logic\n\nFuzzy logic allows treating values from 0 to 1 in a similar fashion as booleans. I thought I'd play around with XOR'ing several moving shapes, thus inverting the colors where they intersect.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["colors","fuzzylogic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat circle(vec2 p, vec2 center, float radius) {\n    \n    float border = .05;\n    \n    return smoothstep(radius * (1. - border), radius * (1. + border), length(p - center));\n}\n\nfloat squareWave(float x, float period) {\n\treturn step(period * .5, mod(x, period));\n}\n\nfloat reduceAtZero(float x) {\n\treturn x * x / (x + 1.) / (x + 1.);\n}\n\nvec2 twistedPolarCoords(vec2 p, float twistFactor) {\n    float r = length(p);\n    float a = atan(p.y / p.x);\n    \n    a += r * twistFactor;\n    \n    return vec2(r * cos(a), r * sin(a));\n}\n\nfloat scene(vec2 p) {\n    \n    float displacement = sin((iTime + 2. * p.x + p.y) * 2.5);\n    float displacement2 = iTime / 10.;\n    \n    p.y += displacement2;\n    \n    p = mod(p, .2);\n    \n    return circle(p, vec2(0.1 + 0.05 * displacement, 0.1), .05);\n}\n\nfloat fNot1(float x) {\n    return 1. - x;\n}\n\nfloat fAnd1(float x, float y) {\n    return x * y;\n}\n\nfloat fOr1(float x, float y) {\n    return x + y - x * y;\n}\n\nfloat fXor1(float x, float y) {\n\treturn fOr1(fAnd1(x, fNot1(y)), fAnd1(fNot1(x), y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy - vec2(.5, .5);\n    p.x *= iResolution.x / iResolution.y;\n    \n    float scene1 = scene(p);\n    float scene2 = scene(p.yx);\n    \n    float slowDownAtStart = reduceAtZero(iTime / 3.) * reduceAtZero(iTime / 3.);\n    \n    float square_size = .5  + .495 * sin(iTime / 3.) + 1.5 -  1.5 * slowDownAtStart;\n    vec2 polarTwist = p; //twistedPolarCoords(p, 2. + square_size / 1.55 * 2.);\n    float scene3 = (mod(polarTwist.x - square_size / 2., square_size) + mod(polarTwist.y - square_size / 2., square_size)) / square_size / 2.;\n    \n    float timeAdjustment = iTime / 5. * slowDownAtStart + .1 * sin(iTime) * slowDownAtStart;\n    \n    float radius = .25 + .03 * sin(sin(iTime / 10.) - 1.1 * sin(length(p))) * reduceAtZero(iTime / 5.) + 4. * (1. - reduceAtZero(iTime / 5.));\n    float s4 = squareWave(length(p) - timeAdjustment, radius);\n    \n    float angle = iTime * .332;\n    float s5 = squareWave(length(p - .2 * vec2(cos(angle), sin(angle))) - timeAdjustment, radius);\n    \n    float r = fXor1(scene1, fXor1(s4, scene2));\n    \n\tfragColor = vec4(vec3(\n        r * r,\n        fXor1(fXor1(scene3 * .75, s5), fXor1(fNot1(s4), scene2)),\n        fXor1(s4, fXor1(scene1, scene3))\n    ), 1.0);\n}","name":"Image","description":"","type":"image"}]}