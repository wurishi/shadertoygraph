{"ver":"0.1","info":{"id":"mllcz7","date":"1690559685","viewed":54,"name":"Aberth solver (numerical)","username":"Envy24","description":"https://en.wikipedia.org/wiki/Aberth_method\n10th degree polynomial is too much for float)\nFor degrees 3,4,5 works fine.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["approximation","solver","polynomial","numeric","aberth"],"hasliked":0,"parentid":"DlXczH","parentname":"Numeric Cubic Solver Test"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define SCENE_SCALE               ( 3. )\n#define UNIT                      ( (SCENE_SCALE*3.0) / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R) { return length(C - NDC)-R; }\n\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx;\n    return SMAA(abs(sdf) / sqrt(1.0 + dfdx * dfdx)); // absolute value / arclenght over unit length interval\n}\nfloat explicit(float x) { return eval_poly(x, pcs, degree); }\nfloat dydx(float x)\n{\n    const float dx = 0.01;\n    return (explicit(x+dx) - explicit(x-dx) ) / (2.*dx);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), false);\n\n    init_poly_coeffs(iTime);\n\n    // Cauchy's roots bounds.\n    float upper_bound = Cauchys_upper_bound(pcs);\n    float lower_bound = Cauchys_lower_bound(pcs);\n\n    vec3 color = (NDC.x <= upper_bound && NDC.x >= -lower_bound) ? vec3(.9,.9,.9) : vec3(1.);\n         color -= draw_explicit_func(NDC, explicit(NDC.x), dydx(NDC.x));\n         color -= x_axis(NDC); color -= y_axis(NDC);\n  \n    // Numeric solvers.\n    int num = Aberth_method(roots, pcs, dcs, degree);\n\n    for (int r=0; r < degree; ++r) \n    {\n        float x = roots[r];\n        color = mix(color, vec3(1, 0, 0), SMAA(diskSDF_L2(NDC, vec2(x, 0.0), 0.05)));\n    }\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Min degree 1, max degree 10.\nconst int degree = 10;\nfloat roots[degree];\nfloat pcs[degree + 1]; // Polynomial coeffitients\nfloat dcs[degree];     // First derivative coeffitients\n#define TOLERANCE ( 0.5 ) // for cubic 1e-5\n\n/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvoid init_poly_coeffs(float iTime)\n{\n    float T = iTime;\n    pcs[0] = sinOSC(-1.25, 1.25, T * 0.15);  // a   \n    pcs[1] = sinOSC( -2.0,  2.0, T * 0.6);   // b\n    pcs[2] = sinOSC( -1.0,  1.0, T * 0.45);  // c\n    pcs[3] = sinOSC( -1.0,  1.0, T * 0.25);  // d\n    pcs[4] = sinOSC( -1.0,  1.0, T * 0.17);  // e\n    pcs[5] = sinOSC( -1.0,  1.0, T * 0.07);  // f\n    pcs[6] = sinOSC( -1.0,  1.0, T * -0.17); // g\n    pcs[7] = sinOSC( -1.0,  1.0, T * -0.3);  // h\n    pcs[8] = sinOSC( -1.0,  1.0, T * 0.3);   // k\n    pcs[9] = sinOSC( -1.0,  1.0, T * 0.12);  // l\n    pcs[10] = sinOSC( -1.0,  1.0, T * 0.77); // n\n    \n    for (int d = 0; d < degree; ++d)\n    {\n        dcs[d] = float(degree - d) * pcs[d];\n    }   \n}\n\n/*\n    Returns hash in range [-1.0; 1.0].\n*/\nfloat shash1to1(uint value)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 12345u;\n    const uint entropy1 = 67890u;\n\n    // Calculate hash.\n\tvalue += entropy1;\n\tvalue *= 445593459u;\n\tvalue ^= entropy0;\n\n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n    \n    return float(value * value * value) * 4.6566128730773926e-10 - 1.0f;\n}\n#define HASH(x)                ( shash1to1(uint(x)) )\n\nfloat eval_poly(\n    float x,\n    float pcs[degree+1],\n    int degree)\n{\n    float power = x, p_sum = pcs[degree];\n\n    for (int d = 1; d <= degree; ++d)\n    {\n        p_sum += power * pcs[degree - d];\n        power *= x;\n    }\n\n    return p_sum;\n}\nfloat eval_poly_deriv(\n    float x,\n    float dcs[degree],\n    int degree)\n{\n    float power = x, d_sum = dcs[degree - 1];\n\n    for (int d = 2; d <= degree; ++d)\n    {\n        d_sum += power * dcs[degree - d];\n        power *= x;\n    }\n\n    return d_sum;\n}\n\nvec2 eval_poly_and_deriv(\n    float x,\n    float pcs[degree + 1],\n    float dcs[degree],\n    int degree)\n{\n    float power = 1., p_sum = 0., d_sum = 0.;\n\n    for (int d = 1; d <= degree; ++d)\n    {\n        p_sum += power * pcs[degree - d + 1];\n        d_sum += power * dcs[degree - d];\n        power *= x;\n    }\n    p_sum += power * pcs[0];\n\n    return vec2(p_sum, d_sum);\n}\n\nfloat Cauchys_upper_bound(float pcs[degree + 1])\n{\n    float inv_a = 1./ pcs[0], m = -pcs[0] * inv_a;\n    \n    for (int i = 0; i < degree; ++i)\n    {\n        m = max(m, -pcs[i + 1] * inv_a);\n    }\n    m = max(0., 1. + m);\n    \n    return m;\n}\nfloat Cauchys_lower_bound(float pcs[degree + 1])\n{\n    float inv_a = 1./ pcs[0], m = pcs[0] * inv_a;\n    \n    for (int i = 0; i < degree; ++i)\n    {\n        m = max(m, pcs[i + 1] * inv_a);\n    }\n    m = max(0., 1. + m);\n    \n    return m;\n}\n\nint Aberth_method(\n    out float roots[degree],\n    float pcs[degree + 1],\n    float dcs[degree],\n    int degree)\n{\n    // Minimal bound for roots.\n    float min_b = max(Cauchys_upper_bound(pcs), Cauchys_lower_bound(pcs));\n\n    // Initial guess.\n    for (int k = 0; k < degree; ++k) { roots[k] = HASH(k) * min_b; }\n\n    const float tolerance = TOLERANCE; /* Desired precision */\n    int roots_found = 0;\n    \n    // Approximation process.    \n    for (int step = 0; step < 64 && roots_found != degree; ++step)\n    {\n        roots_found = 0; // Reset counter for this iteration.\n\n        // Iterate over shifts.\n        for (int k = 0; k < degree; ++k)\n        {\n            vec2 eval = eval_poly_and_deriv(roots[k], pcs, dcs, degree);         \n            float sum = 0., ratio = eval.x / eval.y;\n    \n            for (int j = 0; j < degree; ++j)\n            {\n                if (j == k) { continue; }\n                sum += 1. / (roots[k] - roots[j]);\n            }\n\n            // Shift root.\n            float wk = ratio / (1. - ratio * sum);\n            roots[k] -= wk;\n\n            // Converge to desired tolerance OR diverge to infinity?\n            if (abs(wk) <= tolerance || abs(wk) > 9e5 || isinf(wk) == true) { ++roots_found; }\n        }\n    }\n    \n    roots_found = degree; // Assume that we find all roots.\n    /*On/off validation*/\n    for (int k = 0; k < degree; ++k)\n    {\n        // Invalid root?\n        if (abs(eval_poly(roots[k], pcs, degree)) > tolerance)\n        {    \n            roots[k] = 9e5; // Mark as invalid.\n            --roots_found; // Subtract from counter.\n        }\n    }\n    /*On/off validation*/\n    \n    return roots_found;\n}","name":"Common","description":"","type":"common"}]}