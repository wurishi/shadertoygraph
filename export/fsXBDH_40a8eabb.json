{"ver":"0.1","info":{"id":"fsXBDH","date":"1650301140","viewed":38,"name":"Expérimentation 3D","username":"HanoRobelthon","description":"Expérimentation en 3D","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["lifgraphique"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n//=====Structure=====//\n\nvec4 colonne(vec3 pos, float height, float width, vec3 point) {\n    vec4 res = cylindre(pos, vec3(0, 1, 0), height, width*0.8, point, WHITE);\n    \n    vec3 p = abs(point);\n    p.y = point.y;\n    \n    float angle = -PI * 0.5 / 2.;\n    \n    for(int i = 0; i <= 2; i++) {\n        vec3 pp = rotaY(p, angle * float(i), vec3(0));\n        res = opP(res, cylindre(vec3(width*0.8, 0, 0), vec3(0, 1, 0), 0.15 * width, pp, WHITE));\n    }\n    \n   \n    p.y= abs(point.y + height * 0.65);\n    p = translat(p, vec3(0, height * 0.4, 0));\n    res = opU(res, box(vec3(0, 0, 0), vec3(height * 0.4, height * 0.1, height * 0.4), p, WHITE));\n    \n    return res;\n}\n\nvec4 bonhommeDeNeige(in vec3 pos, in float size, in vec3 point) {\n    vec3 body = pos + vec3(0,  size, 0);\n    vec3 head = pos + vec3(0, 2.3 * size, 0);\n    \n    return opU(\n        opU(\n            sphere(body, size, point, WHITE),\n            sphere(head, 0.60 * size, point, WHITE)\n        ),\n        opU(\n            opU(\n                cone(head + vec3(0, 0, -0.58 * size), head + vec3(0, 0, -size * 1.2), size / 8.f, 0., point, RED),\n                tore(head + vec3(0, size * 1.f, 0), vec3(0, 1, 0), 0.5 * size, 0.1 * size, point, BLUE)\n            ),\n            opU(\n                gellule(body + vec3(size * 0.5, 0, 0), body + vec3(size * 2.f, size * 0.75, 0), size * 0.05, point, WHITE),\n                gellule(body + vec3(-size * 0.5, 0, 0), body + vec3(-size * 2.f, size * 0.75, 0), size * 0.05, point, WHITE)\n            )\n        )\n    );\n}\n\nvec4 piseTop(in float height, in float width, in vec3 point) {\n    float epaisseur = 5.;\n    float voute_level = height * 0.75;\n    \n    //\n    vec4 res = tube(vec3(0, 0, 0), vec3(0, 1, 0), height, width, epaisseur, point, YELLOWISH_WHITE);\n    \n    //couronne étage\n    res = opU(res, cylindre(vec3(0, 0, 0), vec3(0, 1, 0), height * 0.05, width * 1.6, point, YELLOWISH_WHITE));\n    \n    //couronne toit\n    res = opU(res, tube(vec3(0, height, 0), vec3(0, 1, 0), height * 0.05, width * 1.05, epaisseur * 1.1, point, YELLOWISH_WHITE));\n    \n    //couronne sous voute\n    res = opU(res, tube(vec3(0, voute_level - height * 0.02, 0), vec3(0, 1, 0), height * 0.02, width * 1.04, epaisseur * 1.1, point, YELLOWISH_WHITE));\n    \n    //On envoie le point dans le quart + + du plan xz\n    vec3 p = abs(point);\n    p.y = point.y;\n    \n    \n    int nbCol = 3;\n    float angle = -(PI * 0.5) / float(nbCol);\n    vec3 pp;\n    \n    \n    \n    vec3 baseCol = vec3(width, 0, 0);\n    vec4 supr_voute = vec4(1000, 0, 0, 0);\n    \n    for(int i = 0; i <= nbCol; i++) {\n        //on aura 3 division de quart de cercle\n    \n        pp = rotaY(p, angle * float(i), vec3(0, 0, 0));\n        if(i%3 != 0) {//Ne pas mettre la colonne centrale\n            res = opU(res, cylindre(baseCol, vec3(0, 1, 0), voute_level, width * 0.03 / 0.6, pp, YELLOWISH_WHITE));\n        }\n        else if(i%3 == 0) {\n            res = opP(res, box(baseCol + vec3(0, height * 0.3, 0), vec3(epaisseur * 1.5, width * 0.3, width * 0.3), pp, YELLOWISH_WHITE));\n            res = opP(res, cylindre(baseCol + vec3(0, height * 0.3 + width * 0.3, 0), vec3(1, 0, 0), width*0.3, pp, YELLOWISH_WHITE));\n        }\n        \n        res = opU(res, box(baseCol + vec3(0, voute_level - 0.5, 0), vec3(1, 0.5, 1), pp, YELLOWISH_WHITE));\n        \n        pp = rotaY(pp, angle * 0.5, vec3(0, 0, 0));\n        supr_voute = opU(supr_voute, cylindre(baseCol + vec3(0, voute_level, 0), vec3(1, 0, 0), width * .18, pp, RED));\n        \n        if(i%3 == 1) {\n            res = opP(res, box(baseCol + vec3(0, voute_level - width * .295, 0), vec3(epaisseur * 1.5, width * .3, width * .18), pp, RED));\n        }\n    }\n    supr_voute = opI(supr_voute,\n        demiEspace(vec3(0, voute_level, 0), vec3(0, -1, 0), point, YELLOWISH_WHITE)\n    );\n    res = opP(res, supr_voute);\n    \n    \n    return res;\n}\n\nvec4 etage(in float height, in float width, in vec3 point) {\n    float separation_height = height * 0.05;\n\n //tour centrale\n    vec4 res = cylindre(vec3(0, 0, 0), vec3(0, 1, 0), height, width * 0.8, point, YELLOWISH_WHITE);\n    \n //couronne étage\n    res = opU(res, cylindre(vec3(0, 0, 0), vec3(0, 1, 0), separation_height, width, point, YELLOWISH_WHITE));\n    \n //colonnes\n    \n    //On envoie le point dans le quart + + du plan xz\n    vec3 p = abs(point);\n    p.y = point.y;\n    \n    int nbCol = 6;\n    float angle = -(2. * PI) / (float(nbCol) * 4.);\n    float col_height = height * 0.56;\n    float bloc_height = height * 0.05;\n    \n    float voute_level = separation_height + 3. * bloc_height + col_height;\n    float voute_height = height - voute_level + 2. * bloc_height;\n    \n    vec3 baseCol = vec3(width * 0.9, separation_height, 0);\n    \n    //voute\n    vec4 supr_voute = tube(vec3(0, voute_level, 0), vec3(0, 1, 0), voute_height, width * 0.9 + bloc_height, bloc_height * 2., point, YELLOWISH_WHITE);\n    \n    for(int i = 0; i<=nbCol; i++) {\n     //colonne\n       vec3 pp = rotaY(p, angle * float(i), vec3(0, 0, 0));\n       res = opU(res, cylindre(baseCol + vec3(0, bloc_height, 0), vec3(0, 1, 0), col_height, width * 0.03, pp, YELLOWISH_WHITE));\n       res = opU(res, box(baseCol, vec3(bloc_height), pp, WHITE));\n       res = opU(res, box(baseCol + vec3(0, col_height + bloc_height * 2., 0), vec3(bloc_height), pp, YELLOWISH_WHITE));\n     //voutes\n       pp = rotaY(pp, angle * 0.5, vec3(0, 0, 0));\n       \n       supr_voute = opP(supr_voute,\n           cylindre(baseCol + vec3(-1., voute_level - bloc_height, 0), vec3(1, 0, 0), voute_height * 0.4, pp, YELLOWISH_WHITE));\n    }\n    res = opU(res, supr_voute);\n    \n    return res;\n}\n\nvec4 rdc(in float height, in float width, in vec3 point) {\n    //le demi espace permet de résoudre un problème à la jonction entre rdc et étages\n    vec4 res = demiEspace(height + vec3(0, .01, 0), vec3(0, 1, 0), point, YELLOWISH_WHITE);\n    \n    int nbCol = 3;\n    float angle = -(2. * PI) / (float(nbCol) * 4.);\n    \n    //On envoie le point dans le quart + + du plan xz\n    vec3 p = abs(point);\n    p.y = point.y;\n    \n    float col_height = height * 0.56;\n    float bloc_height = height * 0.04;\n    \n    float voute_level = col_height + 2. * bloc_height;\n    float voute_height = height - voute_level;\n    \n    vec3 baseCol = vec3(width * 0.92, 0, 0);\n    \n    //tour centrale\n    res = cylindre(vec3(0, 0, 0), vec3(0, 1, 0), height, width * 0.9, point, YELLOWISH_WHITE);\n    \n    //voutes\n    vec4 supr_voute = cylindre(vec3(0, voute_level - .6 * bloc_height, 0), vec3(0, 1, 0), voute_height + .6 * bloc_height, width * 0.9 + bloc_height * .75, point, YELLOWISH_WHITE);\n    \n    \n    for(int i =0; i<=nbCol; i++) {\n      //colonne\n       vec3 pp = rotaY(p, angle * float(i), vec3(0, 0, 0));\n       \n       res = opU(res, cylindre(baseCol + vec3(0, bloc_height, 0), vec3(0, 1, 0), col_height, width * 0.05, pp, YELLOWISH_WHITE));\n       res = opU(res, box(baseCol, vec3(bloc_height), pp, WHITE));\n       res = opU(res, box(baseCol + vec3(0, col_height + bloc_height * 1.4, 0), vec3(bloc_height, bloc_height * 0.4, bloc_height), pp, YELLOWISH_WHITE)); \n       \n      //voutes\n       pp = rotaY(pp, angle * 0.5, vec3(0, 0, 0));\n       \n       supr_voute = opP(supr_voute,\n           cylindre(baseCol + vec3(-1., voute_level - bloc_height, 0), vec3(1, 0, 0), voute_height * 0.4, pp, YELLOWISH_WHITE));\n    }\n    \n    res = opU(res, supr_voute);\n    \n    return res;\n}\n\nvec4 pise(in float height, in vec3 point) {\n    vec4 res;\n    int nb_etage = 6;\n\n    //étage   haut <--------------------> bas\n    //ratio pise: 1.5, 1, 1, 1, 1, 1, 1, 2\n    float ratio_height = height / 9.5;\n    float top_height = 1.5 * ratio_height;\n    float rdc_height = 2. * ratio_height;\n    float etage_height = ratio_height;\n    \n    float width = height * 0.3 * 0.5;\n\n  //segmentation de la tour (optimisation)\n    if(length(point.xz) < width + 0.5) { //Si le point testé est à l'intérieur d'un cylindre autour de la tour\n\n//Rez de chaussée---------------------------------------------------------------------------------------------------------\n        if(point.y <= rdc_height) { \n            res = rdc(rdc_height, width, point);\n        }\n//Etages---------------------------------------------------------------------------------------------------------\n       else if(point.y > rdc_height && point.y <= rdc_height + float(nb_etage) * etage_height) { \n            vec3 p = point;\n            p.y = (point.y - rdc_height); //ramène le point à sa hauteur par rapport au bas d'un étage\n            int rep = int(p.y / etage_height); // |coorespond au modulo\n            p.y -= float(rep) * etage_height;  // |\n\n            //l'union avec un demi espace permet de résoudre un problème à la jonction des répétitions\n            res = opU(etage(etage_height, width, p),\n                    demiEspace(vec3(0, etage_height + 0.1, 0), vec3(0, -1, 0), p, YELLOWISH_WHITE)\n            );\n        }\n//Top---------------------------------------------------------------------------------------------------------\n        else if(point.y > rdc_height + float(nb_etage) * etage_height) { \n            res = piseTop(top_height, width * 0.6, point - vec3(0, height - top_height, 0));\n        }\n\n    }\n//Sinon calculer la distance au cylindre\n    else {\n        res = vec4(length(point.xz) - width, WHITE);\n    }\n    return res;\n}\n\nvec4 penguin(in vec3 pos, in float size, in vec3 point) {\n    //corps\n    vec4 res = opULisse(\n        sphere(pos + vec3(0, size, 0), size, point, BLACK),\n        sphere(pos + vec3(0, size * 2.7, 0), size * 0.75, point, BLACK),\n        size * 3.\n    );\n    //yeux\n    res = opU(res, sphere(pos + vec3(size * 0.5, size*2.8, -size*0.8), size*0.12, point, GREEN));\n    res = opU(res, sphere(pos + vec3(-size * 0.5, size*2.8, -size*0.8), size*0.12, point, GREEN));\n    //bec\n    vec3 p = scale(point, vec3(4, 1.3, 1), pos + vec3(0, size*2.7, -size*1.7));\n    res = opU(res, cone(pos + vec3(0, size*2.7, -size*1.7), pos + vec3(0, size * 2.7, -size * 0.7), size * 0.03, size * 0.1, p, ORANGE));\n    //pattes\n    p = scale(point, vec3(5, 1, 1), pos + vec3(size *0.5, size*0.1, -size*1.));\n    res = opU(res, cone(pos + vec3(size * 0.5, size*0.1, -size*1.), \n                        pos + vec3(size * 0.5, size * 0.1, size*0.2), \n                        size * 0.09, size * 0.01, p, ORANGE));\n                        \n    p = scale(point, vec3(5, 1, 1), pos + vec3(-size *0.5, size*0.1, -size*1.));\n    res = opU(res, cone(pos + vec3(-size * 0.5, size*0.1, -size*1.), \n                        pos + vec3(-size *0.5, size * 0.1, size*0.2), \n                        size * 0.09, size * 0.01, p, ORANGE));\n    //ventre\n    p = scale(point, vec3(2, 3, 1), pos + vec3(0, size, 0));\n    res = opU(res, sphere(pos + vec3(0, size*1.1, -size*0.85), size * 0.33, p, WHITE));\n    \n    //ailes\n    p = scale(point, vec3(2, 10, 5), pos + vec3(-size, size * 1.5, 0));\n    res = opU(res, sphere(pos + vec3(-size, size * 1.5, 0), size * 0.1, p, BLACK));\n    \n    p = scale(point, vec3(2, 10, 5), pos + vec3(size, size * 1.5, 0));\n    res = opU(res, sphere(pos + vec3(size, size * 1.5, 0), size * 0.1, p, BLACK));\n    \n    \n    return res;\n}\n\n\nvec4 feuille(vec3 point) {\n    vec4 res;\n    vec3 orig = vec3(0, 10, 0);\n    point = scale(point, vec3(10, 1, 10), orig);\n    point.z = point.z - point.x * point.x * point.x;\n    \n    res = sphere(orig, 1., point, GREEN); \n    return res;\n}\n\nvec4 arbre(vec3 point) {\n    \n    point = translat(point, vec3(-10., 0, -10));\n    \n    int rep = int(point.y / 10.);\n    point.y -= float(rep) * 10.; \n    //point.y = 10. * (point.y - float(int(point.y)));\n    \n    point.x = abs(point.x);\n    point.z = abs(point.z);\n    \n    point = translat(point, vec3(10., 0, 10));\n    \n    \n    return feuille(point);\n}\n\n\n//=====Code=====//\n\n//1: Saint-Homme Neige\n//2: Des bubulles\n//3: Tests\n//4: Pise\n//5: Pingouin\n#define RENDERED_WORLD 4\n\n\nvec4 World(in vec3 point) {\n    switch(RENDERED_WORLD) {\n    case 1:\n        return opU(\n           colonne(vec3(0, -14, 0), 12.f, 6.f, point),\n          opU(\n              bonhommeDeNeige(vec3(0, -3, 0), 4.f, point)\n              ,demiEspace(vec3(0, -14, 0), vec3(0, 1, 0), point, WHITE)//-14\n          )\n        );\n        break;\n    case 2:\n        return opU(\n            demiEspace(vec3(0, -5, 0), vec3(0, 1, 0), point, WHITE),\n            opU(\n                opU(sphere(vec3(5, 0, -15), 5.f, point, RED),\n                    sphere(vec3(-15, 5.f, -10), 10.f, point, GREEN)\n                ),\n                opU(sphere(vec3(20, 7, 0), 5.f, translat(point, vec3(0, 0, -20)), BLUE),\n                    //sphere(vec3(-5, 5.f, 20), 5.f, point, BLACK)\n                    //tor(vec3(-5, 5, 20), vec3(0, 1, 0), 5.f, 0.5, point, BLUE)\n                    \n                    cylindre(vec3(0, 0, -25), vec3(1, 0, 0), 5.f, point, WHITE)\n                    //cone(vec3(0, 0, 3), vec3(4, 9, 400), 5.f, 7.f, point, GREEN)\n                )\n            )\n        );\n        break;\n    case 3:\n        return opU(cone(vec3(0, 0, 3), vec3(4, 9, 4), 5.f, 7.f, point, GREEN),\n                demiEspace(vec3(0, -5, 0), vec3(0, 1, 0), point, WHITE)\n        );\n        break;\n    case 4:\n        vec3 p = rotaZ(point, 6.0 * RAD, vec3(0, 0, 0));\n        p = translat(p, vec3(0, -5, 0));\n        return opU(pise(120.f, p),\n                demiEspace(vec3(0), vec3(0, 1, 0), point, WHITE)\n        );\n        break;\n    case 5:\n        return opU(penguin(vec3(0, 20, 0), 5.f, point),\n            demiEspace(vec3(0, 20, 0), vec3(0, 1, 0), point, WHITE)\n        );\n        break;\n    case 6:\n        return opU(arbre(point),\n            demiEspace(vec3(0, 0, 0), vec3(0, 1, 0), point, WHITE)\n        );\n        break;\n   }\n}\n\n\n/*\n\n\nSource:\n    https://reindernijhoff.net/2017/07/raymarching-distance-fields/\n*/\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.005;\n    return normalize(\n        e.xyy * World(p + e.xyy).x +\n        e.yyx * World(p + e.yyx).x +\n        e.yxy * World(p + e.yxy).x +\n        e.xxx * World(p + e.xxx).x);\n}\n\n\nvec4 RayMarching(in vec3 ray, in vec3 dir, in float renderDistance) {\n    float t = 1.f;\n    vec4 step;\n    \n    \n    do {\n        step = World(ray + dir * t);\n        t += max(step.x, 0.01);\n    } while(step.x > 0.01 && t < renderDistance);\n\n    \n    return vec4(t, step.yzw);\n}\n\n\n\n\n\n\nvec4 render(in vec3 ray, in vec3 dir, in vec3 light, in float lightRayon, in float renderDistance) {\n    vec4 obj = RayMarching(ray, dir, renderDistance);\n    float distObj = obj.x;\n    vec3 colObj = obj.yzw;\n    \n    float ratio = (distObj / renderDistance);\n    \n    \n    if(distObj < renderDistance) { //Si le rayon touche un objet\n    \n        float incidenceObjLight = 0.f;\n        float incidenceObjBounce = 0.f;\n        float incidenceBounceLight = 0.f;\n    \n    \n        vec3 objPos = ray + dir * distObj;\n        vec3 objNorm = calcNormal(objPos);\n        \n        float epsilon = 0.0001f;\n        float distLight = RayMarching(objPos/* + epsilon * objNorm*/, normalize(light - objPos), renderDistance).x;\n        if(distLight > renderDistance - 0.02) { //Si l'impact à un contact direct avec la lumière\n            incidenceObjLight = dot(objNorm, normalize(light - objPos));\n        }\n        \n        vec3 bounceDir = reflect(dir, objNorm);;\n        vec4 bounce = RayMarching(objPos /*+ epsilon * objNorm*/, bounceDir, renderDistance);\n        float distBounce = bounce.x;\n        vec3 colBounce = bounce.yzw;\n        \n        \n        \n        if(distBounce < renderDistance) { //Le rayon réfléchi touche un objet\n            vec3 bouncePos = objPos + bounceDir * distBounce;\n            vec3 bounceNorm = calcNormal(bouncePos);\n            \n            incidenceObjBounce = dot(objNorm, normalize(bouncePos - objPos));\n            \n            float distBounceLight = RayMarching(bouncePos/* + epsilon * bounceNorm*/, normalize(light - bouncePos), renderDistance).x;\n            if(distBounceLight > renderDistance - 0.02) { //Si le reflet à un contact direct avec la lumière\n                incidenceBounceLight = dot(bounceNorm, normalize(light - bouncePos));\n            }\n        }\n\n        vec3 bounceFinalColor = incidenceBounceLight * colBounce;\n        vec3 objFinalColor = colObj;\n        //vec3 col = incidenceObjLight * objFinalColor + (1.f - incidenceObjLight) * (1.f - incidenceObjBounce) * bounceFinalColor;\n        //debug\n        //vec3 col = (1. - distObj / renderDistance) * colObj;\n        vec3 col = incidenceObjLight * objFinalColor;\n        \n        return vec4(col, 1.f);\n    }\n    \n    return vec4(NICE_PURPLE, 1.f);\n}\n\n\nvec3 Soleil(in float dT) {\n    //source wikipédia Position du Soleil\n    vec3 res;\n    res.x = cos(dT) * 5.;\n    res.y = cos(dT) * 10.;\n    res.z = sin(dT) * 10.;\n    return 100. * res;\n}\n\n//=====Main=====//\n\n\n//Camera\nvec3 camPos = vec3(0.f, 60.f, 0.f);\n//x: verticale, y: horizontal\nvec2 camAngle = vec2(0.f, 0.f);\nvec3 camDir;\nvec3 camCross;\nvec3 camTop;\n\nfloat camDist = 100.f;\n\nfloat renderDistance = 500.f;\nvec2 screenSize = vec2(8.f, 4.5) * 30.f; //le coeff doit être égal à camDist\n\n\n\nvoid processInput() {\n    float dx = iMouse.x - abs(iMouse.z);\n    float dy = iMouse.y - abs(iMouse.w);\n        \n    camAngle = vec2(dy * 0.005, dx * 0.01);\n}\n\nvoid processCam() {\n    camDir = vec3(       \n        cos(camAngle.x) * sin(camAngle.y),\n        sin(camAngle.x),\n        cos(camAngle.x) * cos(camAngle.y)\n    );\n    camCross = vec3(\n        sin(camAngle.y + PI * 0.5),\n        0.f,\n        cos(camAngle.y + PI * 0.5)\n    );\n    camTop = cross(camDir, camCross);\n\n    camPos += -camDir * camDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    processInput();\n    processCam();\n\n    vec3 lightPos = vec3(50, 200, -120);//Soleil(iTime * 0.2)\n\n    vec3 baseCoord = vec3(fragCoord.xy / iResolution.xy - 0.5, 0.f) * vec3(screenSize, 0);\n\n    vec3 rayStart = camPos + vec3(0, 0, 1) + camCross * baseCoord.x + camTop * baseCoord.y;\n\n    fragColor = render(rayStart, camDir, lightPos, 3.f, renderDistance);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926538\n#define RAD PI / 180.\n#define BLACK vec3(0.f, 0.f, 0.f)\n#define WHITE vec3(1.f, 1.f, 1.f)\n#define RED vec3(1.f, 0.f, 0.f)\n#define GREEN vec3(0.f, 1.f, 0.f)\n#define BLUE vec3(0.f, 0.f, 1.f)\n#define ORANGE vec3(230, 150, 40) / 255.f\n#define NICE_GREEN vec3(134, 205, 162) / 255.f\n#define NICE_PURPLE vec3(190, 133, 204) / 255.f\n#define YELLOWISH_WHITE vec3(233, 210, 210) / 255.f\n\n\n\n\n\n//=====Opérateurs=====//\n\n\nvec4 opU(in vec4 a, in vec4 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec4 opI(in vec4 a, in vec4 b) {\n    return a.x > b.x ? a : vec4(b.x, a.yzw);\n}\n\nvec4 opP(in vec4 a, in vec4 b) {\n    return a.x > -b.x ? a : vec4(-b.x, a.yzw);\n}\n\nvec4 opULisse(in vec4 a, in vec4 b, in float r) {\n    vec4 res = opU(a, b);\n    float h = max(r - length(a.x - b.x), 0.f) / r;\n    res.x -= (1.f/6.f) * r * h * h * h;\n    return res;\n}\n\nvec3 translat(vec3 P, vec3 dir) {\n    return P - dir;\n}\n\n\nvec3 rotaX(in vec3 P, in float angle, in vec3 orig) {\n    float cosA =  cos(-angle);\n    float sinA = sin(-angle);\n\n    mat3 xRot;\n    xRot[0] = vec3(1,  0, 0);\n    xRot[1] = vec3(0, cosA, sinA);\n    xRot[2] = vec3(0, -sinA, cosA);\n\n    P = translat(P, -orig);\n    P = xRot * P;\n    return translat(P, orig);\n}\n\nvec3 rotaY(in vec3 P, in float angle, in vec3 orig) {\n    float cosA =  cos(-angle);\n    float sinA = sin(-angle);\n\n    mat3 yRot;\n    yRot[0] = vec3(cosA,  0, -sinA);\n    yRot[1] = vec3(0, 1, 0);\n    yRot[2] = vec3(sinA, 0,  cosA);\n\n    P = translat(P, -orig);\n    P = yRot * P;\n    return translat(P, orig);\n}\n\nvec3 rotaZ(in vec3 P, in float angle, in vec3 orig) {\n    float cosA =  cos(-angle);\n    float sinA = sin(-angle);\n\n    mat3 zRot;\n    zRot[0] = vec3(cosA,  sinA, 0);\n    zRot[1] = vec3(-sinA, cosA, 0);\n    zRot[2] = vec3(0, 0,  1);\n\n    P = translat(P, -orig);\n    P = zRot * P;\n    return translat(P, orig);\n}\n\nvec3 rota(in vec3 P, in vec3 angle, in vec3 orig) {\n    vec3 cosA =  vec3(cos(angle.x), cos(angle.y), cos(angle.z));\n    vec3 sinA = vec3(sin(angle.x), sin(angle.y), sin(angle.z));\n    \n    mat3 xRot;\n    xRot[0] = vec3(1,  0, 0);\n    xRot[1] = vec3(0, cosA.x, sinA.x);\n    xRot[2] = vec3(0, -sinA.x, cosA.x);\n    \n    mat3 yRot;\n    yRot[0] = vec3(cosA.y,  0, -sinA.y);\n    yRot[1] = vec3(0, 1, 0);\n    yRot[2] = vec3(sinA.y, 0,  cosA.y);\n    \n    mat3 zRot;\n    zRot[0] = vec3(cosA.z,  sinA.z, 0);\n    zRot[1] = vec3(-sinA.z, cosA.z, 0);\n    zRot[2] = vec3(0, 0,  1);\n    \n    P = translat(P, -orig);\n    P = xRot * yRot * zRot * P;\n    return translat(P, orig);\n}\n\nvec3 scale(in vec3 P, in vec3 factor, in vec3 orig) {\n    P = translat(P, -orig);\n    P /= factor;\n    return translat(P, orig);\n}\n\n\n//=====Primitive=====//\n/*Liste des primitives\nvec4 sphere(in vec3 centre, in float rayon, in vec3 point, in vec3 color)\nvec4 demiEspace(in vec3 a, in vec3 n, in vec3 point, in vec3 color)\nvec4 plan(in vec3 a, in vec3 n, in float e, in vec3 point, in vec3 color)\nvec4 box2(in vec3 c, in vec3 len, in vec3 point, in vec3 color)\nvec4 box(in vec3 c, in vec3 len, in vec3 point, in vec3 color)\nvec4 gellule(in vec3 A, in vec3 B, in float rayon, in vec3 point, in vec3 color)\nvec4 tore(in vec3 c, in vec3 n, in float r, in float ri, in vec3 point, in vec3 color)\nvec4 disque(in vec3 c, in vec3 n, in float r, in float ri, in vec3 point, in vec3 color)\nvec4 cylindre(vec3 point, vec3 color)\nvec4 cylindre(vec3 c, vec3 n, float r, vec3 point, vec3 color)\nvec4 cylindre(vec3 b, vec3 n, float length, float r, vec3 point, vec3 color)\nvec4 tube(in vec3 A, in vec3 n, float length, in float r, in float epaisseur, in vec3 point, in vec3 color)\nvec4 cone(in vec3 A, in vec3 B, in float radiusBottom, in float radiusTop, in vec3 point, in vec3 color)\n*/\n\n/*\nParam:\n    centre: centre de la sphère\n    rayon: rayon de la sphère\n\nRésultat:\n    la coordonnée x représente la distance à la sphère paramétrée.\n*/\nvec4 sphere(in vec3 centre, in float rayon, in vec3 point, in vec3 color) {\n    return vec4(distance(centre, point) - rayon, color);\n}\n\n/*\nParam:\n    a: un point à la surface du demi-espace\n    n: un vecteur normale pointant à l'extérieur de la surface\n\nRésultat:\n    la coordonnée x représente la distance au demi-espace paramétrée\n*/\nvec4 demiEspace(in vec3 a, in vec3 n, in vec3 point, in vec3 color) {\n    n = normalize(n);\n    return vec4(dot(point - a, n), color);\n}\n\n/*\nParam:\n    a: un point contenu dans le plan\n    n: la normale au plan\n    e: demi-épaisseur du plan\n    \nRésultat:\n    la coordonnée x représente la distance au plan\n    \nDesc:\n    On donne une épaisseur à un plan, comme une planche infini\n*/\nvec4 plan(in vec3 a, in vec3 n, in float e, in vec3 point, in vec3 color) {\n    n = normalize(n);\n    return vec4(abs(dot(point - a, n)) - e, color);\n}\n\n/*\nParam:\n    c: barycentre de la boite\n    len: longueur des côté\n    \nRésultat:\n    la coordonnée x représente la distance à une boite de barycentre c, de côté len\n    \nSource:\n    Inigo Quilez: https://www.youtube.com/watch?v=62-pRVZuS5c\n*/\nvec4 box2(in vec3 c, in vec3 len, in vec3 point, in vec3 color) {\n    return vec4(length(max(abs(point - c) - len, 0.f)), color);\n}\n\n/*\nParam:\n    c: barycentre de la boite\n    len: longueur des côté\n    \nRésultat:\n    la coordonnée x représente la distance à une boite de barycentre c, de côté len\n    Fonctionne mieux avec le calcul de normal\n*/\nvec4 box(in vec3 c, in vec3 len, in vec3 point, in vec3 color) {\n    return opI(\n        opI(\n            plan(c, vec3(0, 1, 0), len.y, point, color),\n            plan(c, vec3(0, 0, 1), len.z, point, color)\n        ),\n        plan(c, vec3(1, 0, 0), len.x, point, color)\n    );\n}\n\n\n/*\nParam:\n    A: Première extrémité du segement\n    B: Deuxième extrémité du segment\n    rayon: rayon d'épaisseur autour du segment\n    \nRésultat:\n    la coordonnée x représente la distance à un segment d'épaisseur rayon\n*/\nvec4 gellule(in vec3 A, in vec3 B, in float rayon, in vec3 point, in vec3 color) {\n    vec3 AP = point - A;\n    vec3 AB = B - A;\n    if(dot(AB, AP) < 0.f) {\n        return vec4(length(AP) - rayon, color);\n    }\n    if(dot(AB, point - B) > 0.f) {\n        return vec4(length(point - B) - rayon, color);\n    }\n    else {\n        float baseTri = dot(AP, normalize(B - A));\n        return vec4(sqrt(length(AP) * length(AP) - baseTri * baseTri) - rayon, color);\n    }\n}\n\n/*\nParam:\n    c: centre du cercle\n    n: normale au cercle\n    r: rayon du cercle\n    ri: rayon intérieur de l'épaisseur du cercle\n    \nRésultat:\n    la coordonnée x représente la distance à un cercle d'épaisseur ri\n*/\nvec4 tore(in vec3 c, in vec3 n, in float r, in float ri, in vec3 point, in vec3 color) {\n    vec3 CP = point - c;\n    float distPlan = dot(CP, n);\n    float baseTri = sqrt(length(CP) * length(CP) - distPlan * distPlan) - r;\n    return vec4(sqrt(distPlan * distPlan + baseTri * baseTri) - ri, color);\n}\n\n/*\nParam:\n    c: centre du disque\n    n: normale au disque\n    r: rayon du disque\n    ri: rayon intérieur de l'épaisseur du disque\n    \nRésultat:\n    la coordonnée x représente la distance à un disque d'épaisseur ri\n*/\nvec4 disque(in vec3 c, in vec3 n, in float r, in float ri, in vec3 point, in vec3 color) {\n    vec3 CP = point - c;\n    float distPlan = dot(CP, n);\n    float baseTri = sqrt(length(CP) * length(CP) - distPlan * distPlan) - r;\n    if(baseTri < 0.f)\n        return vec4(abs(distPlan) - ri, color);\n    return vec4(sqrt(distPlan * distPlan + baseTri * baseTri) - ri, color);\n}\n\n/*\nRésultat:\n    la coordonnée x représente la distance à un cylindre de rayon 0.5 (diamètre 1.f), infini.\n*/\nvec4 cylindre(vec3 point, vec3 color) {\n    float baseTri = dot(vec3(0, 1, 0), point);\n    return vec4(\n        sqrt(length(point) * length(point) - baseTri * baseTri) - 0.5,\n        color\n    );\n}\n\n/*\nParam:\n    c: barycentre du cylindre (infini)\n    n: vecteur directeur du cylindre\n    r: rayon de l'épaisseur du cylindre\n\nRésultat:\n    la coordonnée x représente la distance à un cylindre infini parametré\n*/\nvec4 cylindre(vec3 c, vec3 n, float r, vec3 point, vec3 color) {\n    n = normalize(n);\n    point = (point - c);\n    float baseTri = dot(n, point);\n    return vec4(\n        sqrt(length(point) * length(point) - baseTri * baseTri) - r,\n        color\n    );\n}\n\n/*\nParam:\n    b: point à la base du cylindre\n    n: vecteur normale à la base (pointe vers l'intérieur du cylindre)\n    height: hauteur du cylindre\n    r: rayon de l'épaisseur dy cylindre\n    \nRésultat:\n    la coordonnée x renvoie la distance à un cylindre paramétré de longueur length\n\n*/\nvec4 cylindre(vec3 b, vec3 n, float length, float r, vec3 point, vec3 color) {\n    n = normalize(n);\n    return \n        opI(\n            cylindre(b, n, r, point, color),\n            plan(b + 0.5 * length, n, 0.5 * length, point, color)\n        );\n}\n\n/*\nParam:\n    A: point à la base\n\n*/\nvec4 tube(in vec3 A, in vec3 n, float length, in float r, in float epaisseur, in vec3 point, in vec3 color) {\n    return opP(\n        cylindre(A, n, length, r, point, color),\n        cylindre(A, n, r - epaisseur, point, color)\n    );\n}\n\n/*\nParam:\n    A: Base du cone\n    B: Haut du cone\n    radiusBottom: rayon de la base\n    radisuTop: rayon du haut\n    \nRésultat:\n    la coordonnée x représente la distance à un cone paramétré\n    \nDesc:\n    la pente est donné par une interpolation linéaire entre le rayon de la base et au sommet\n    La distance n'est pas exact, puisque la distance se fait perpendiculairement à AB et non pas à la pente.\n\n*/\nvec4 cone(in vec3 A, in vec3 B, in float radiusBottom, in float radiusTop, in vec3 point, in vec3 color) {\n    vec4 res;\n    vec3 norm = normalize(B - A);\n    \n    vec3 AP = point - A;\n    \n    float projP = dot(AP, norm);\n\n    \n    float heightRatio = projP / distance(A, B);\n    res = vec4(\n        sqrt(length(AP) * length(AP) - projP * projP) - (heightRatio * radiusTop + (1.f - heightRatio) * radiusBottom),\n        color\n    );\n    \n    return opI(res, \n        plan(A + 0.5 * length(B - A), norm, 0.5*length(B-A), point, color)\n    );\n}\n\n","name":"Common","description":"","type":"common"}]}