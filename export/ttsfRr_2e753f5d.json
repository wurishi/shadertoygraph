{"ver":"0.1","info":{"id":"ttsfRr","date":"1595897068","viewed":98,"name":"Mediterranean tiles","username":"carolhmj","description":"Shader following The Art of Code's video about KIFS fractals. I used the same method he used to build the first snowflake to repeat more snowflakes.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","kifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ZOOM 15.\n\nvec2 N(float angle) {\n\treturn vec2(sin(angle), cos(angle));\n}\n\nfloat sigmoid(float x) {\n\treturn 1./(1.+.6*exp(-x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n \n    float mult = 1. + MAX_ZOOM*sigmoid(sin(iTime*.08)*5.);\n    uv *= mult;\n    \n    vec3 col = vec3(0);\n       \n    vec2 n;\n    float d;\n    \n    for (int i = 0; i < int(mult); i++) {\n        uv = abs(uv);\n        vec2 delta = vec2(.25,0.); // Distance between repetitions - increase this to make then repeat farther away from each other\n        uv -= delta;\n        n = N((1./3.)*3.1415);\n        d = dot(uv-vec2(.5,0.), n);\n        uv -= n*max(0., d)*2.;\n        uv += delta;\n    }\n    \n    uv.x = abs(uv.x);\n    uv.y += tan((5./6.)*3.1415)*.5;\n    \n    n = N((5./6.)*3.1415);\n    d = dot(uv-vec2(.5,0.), n);\n    uv -= n*max(0., d)*2.;\n    \n    n = N((2./3.) * 3.1415);\n    uv.x += .5;\n    float scale = 1.;\n    for (int i = 0; i < 4; i++) {\n        uv *= 3.;\n        scale *= 3.;\n        uv.x -= 1.5;\n\n        // The shape is symmetrical around the x-axis, so we only have\n        // to worry about half of the x coordinates\n        uv.x = abs(uv.x);\n        // Make the line wider (both sides will measure .5 more)\n        uv.x -= .5;\n        // Bend the line around a normal\n        uv -= n*min(0., dot(uv, n))*2.;\n    }\n    \n    d = length(uv - vec2(clamp(uv.x, -1., 1.), 0));\n    col += smoothstep(1./iResolution.y, .0, d/(scale*mult));\n    uv /= scale;\n    col += texture(iChannel0, uv*2.-iTime*.02).rgb;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}