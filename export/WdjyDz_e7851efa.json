{"ver":"0.1","info":{"id":"WdjyDz","date":"1586507474","viewed":81,"name":"Savukvartsia, komissario Palmu!","username":"elefAntti","description":"Wanted to play around with attenuation of light, ended up adding some refraction as well.\nThe code is hacky due to working late at night, but it gets the job done:)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["refraction","attenuation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define GammaValue 0.5\n#define VignetteStrength 1.1\n#define FocalLength 2.0\n#define GroundHeight 4.0\n\nmat3 rot_y(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat3(c, 0.0 , -s,\n              0.0, 1.0, 0.0,\n               s, 0.0, c);\n}\n\n//The distance field fot the diamond\nfloat diamond3( vec3 pos )\n{\n    float r = 2.0;\n    return max(\n        max(\n            max(\n                max(\n                    max(abs(pos.x), abs(pos.y))\n                    , abs(pos.z))\n                , abs(pos.x + pos.y))\n            , abs(pos.z + pos.y))\n        , abs(pos.x + pos.z)) / 2.0 - r;\n}\n\n//Distance between two skew lines\nfloat distBetweenLines(vec3 origin, vec3 dir, vec3 origin2, vec3 dir2)\n{\n    vec3 normal = normalize(cross(dir, dir2));\n    return abs(dot(normal, origin - origin2));\n}\n\n//Distance to a line from origin along a ray\nfloat distToLine(vec3 origin, vec3 dir, vec3 origin2, vec3 dir2)\n{\n    vec3 normal = normalize(cross(dir, dir2));\n    vec3 n2 = cross(dir2, normal);\n    return dot(origin2 - origin, n2) / dot(dir, n2);\n}\n\n//Laser brightness as a function of distance from surface\nfloat laserBrightness(float dist)\n{\n    return smoothstep(0.2, 0.1,dist);\n}\n\n//The distance field function\nfloat distModel(vec3 pos, float time)\n{\n    return min(diamond3(rot_y(time) * pos), -pos.y + GroundHeight);\n}\n\n//Computes the normal of the distance field \nvec3 normModel(vec3 pos, float time)\n{\n    float delta = 0.001;\n    return normalize(vec3(\n         distModel(pos + vec3(delta, 0.0, 0.0), time) - distModel(pos - vec3(delta, 0.0, 0.0), time),\n         distModel(pos + vec3(0.0, delta, 0.0), time) - distModel(pos - vec3(0.0, delta, 0.0), time),\n         distModel(pos + vec3(0.0, 0.0, delta), time) - distModel(pos - vec3(0.0, 0.0, delta), time)\n    ) / (2.0 * delta));\n}\n\nfloat castRay(vec3 pos, vec3 dir, float time, float mult)\n{\n    float totalDist = 0.0;\n    float distToSurface = distModel(pos, time) * mult;\n    \n    while(totalDist < 100.0)\n    {\n        totalDist += distToSurface + 0.01;\n        vec3 currentPos = pos + dir * totalDist;\n        distToSurface = distModel(currentPos, time) * mult;\n        \n        if(distToSurface < 0.00)\n        {\n        \ttotalDist += distToSurface;\n            return totalDist;\n        }\n    }\n    \n    return 100.0;\n}\n\nvec3 rtMain(in vec2 fragCoord, in float time)\n{\n    vec2 position = fragCoord * -2.0 + 1.0;\n    vec3 rayDir = normalize(vec3( position, FocalLength));\n    vec3 cameraPos = vec3( 0, -2.0, -30.0 );\n    vec3 lightPos = vec3(-3.784, -2.0, 3.26);\n    vec3 laserPos = vec3(-1.0, -1.0, 2.0);\n    vec3 laserLookAt = vec3(0.0, 0.0, 2.0);\n    vec3 laserDir = normalize(laserLookAt - laserPos);\n    vec3 laserColor = vec3(1.0, 0.01, 0.01);\n    //The attenuation of light within the diamond\n    float lightDecay = 0.4;\n    float refractiveIndex = 1.0/1.43;\n    //The attenuation of laser when ray is traversing through the diamond\n    float laserAttenuation = 0.7;\n\n    float laserHitDist = castRay(laserPos, laserDir, time, 1.0) ;\n    vec3 laserHitPos = laserPos + laserDir * (laserHitDist + 0.05);\n    vec3 normalAtLaserHit = normModel(laserHitPos, time);\n    vec3 refractedLaserDir = refract(laserDir, normalAtLaserHit, refractiveIndex);\n    \n    \n    float internalCastLen = castRay(laserHitPos, refractedLaserDir, time, -1.0);\n    vec3 laserExitPos = laserHitPos + refractedLaserDir * internalCastLen;\n    float laserInsideDist = length(laserExitPos - laserHitPos);\n    vec3 normalAtLaserExit = -normModel(laserExitPos, time);\n    vec3 laserExitDir = refract(refractedLaserDir, normalAtLaserExit, 1.0/refractiveIndex);    \n    \n    float distToSurface = castRay(cameraPos, rayDir, time, 1.0);\n    vec3 cameraRayEnter = cameraPos + rayDir * (distToSurface + 0.1);\n    float distInside = castRay(cameraRayEnter, rayDir, time, -1.0);\n    vec3 cameraRayExit = cameraRayEnter + rayDir * distInside;\n\n    \n    \n    vec3 frontNormal = normModel(cameraRayEnter, time);\n    vec3 backNormal = normModel(cameraRayExit, time);\n    vec3 lightDirFront = normalize(lightPos - cameraRayEnter);\n    vec3 lightDirBack = normalize(lightPos - cameraRayExit);\n    float shadeFront = max(0.0, dot(lightDirFront, frontNormal));\n    float shadeBack = max(0.0, -dot(lightDirBack, backNormal));\n\n    vec3 diamondColor = vec3(shadeBack) * exp(-lightDecay * distInside) + vec3(shadeFront);\n    \n    \n    //Background\n    diamondColor *= smoothstep(100.0, 80.0, distToSurface);\n        \n    float laserDist = distToLine(cameraPos, rayDir, laserPos, laserDir);    \n    float laserIntensity = 0.0; \n    \n    vec3 laserPoint = cameraPos + laserDist * rayDir;\n    float distanceToLaser = dot(laserDir, laserPoint - laserPos);\n    \n    if(distanceToLaser < laserHitDist)\n    {\n        //Ray hasn't yet hit the diamond\n        laserIntensity = laserBrightness(distBetweenLines(cameraPos, rayDir, laserPos, laserDir));\n    }\n    else\n    {\n        laserDist = distToLine(cameraPos, rayDir, laserHitPos, refractedLaserDir);\n        laserPoint = cameraPos + laserDist * rayDir;\n    \tfloat distanceToLaserEnter = dot(refractedLaserDir, laserPoint - laserHitPos);\n        \n        if(distanceToLaserEnter < laserInsideDist)\n        {\n            //Laser is inside the diamond\n            laserAttenuation *= exp(-lightDecay * (distanceToLaser - laserHitDist));\n            laserIntensity = laserBrightness(distBetweenLines(cameraPos, rayDir, laserHitPos, refractedLaserDir));\n        }\n        else\n        {\n            //Laser has exited the diamond\n            laserAttenuation *= exp(-lightDecay * laserInsideDist);\n            laserIntensity = laserBrightness(distBetweenLines(cameraPos, rayDir, laserExitPos, laserExitDir));\n            laserDist = distToLine(cameraPos, rayDir, laserExitPos, laserExitDir);\n            laserPoint = cameraPos + laserDist * rayDir;\n        }\n    }\n    \n    if(laserPoint.y > GroundHeight)\n    {\n        //Laser has entered the ground\n        laserAttenuation = 0.0;\n    }\n    \n    //The attenuation of laser when ray is returning through the diamond\n    float returnLaserAttenuation = 1.0;\n    if(laserDist < distToSurface)\n    {\n        //Laser seen in front of the diamond\n    }\n    else if(laserDist < (distToSurface + distInside))\n    {\n       //Laser seen inside the diamond\n       returnLaserAttenuation *= exp(-lightDecay * (laserDist - distToSurface));\n    }\n    else\n    {\n       //Laser seen behind the diamond\n       returnLaserAttenuation *=  exp(-lightDecay * distInside);\n    }\n    \n    //Add a laser dot to where the laser enters the diamond\n    float laserOnSurface =  (laserBrightness(length(laserHitPos - laserPoint)))\n        * abs(dot(frontNormal, -laserDir));\n    laserOnSurface += (laserBrightness(length(laserExitPos - laserPoint)))\n        * exp(-lightDecay * laserInsideDist)\n        * 2.0 //Hack to make it more visible\n        * abs(dot(backNormal, -refractedLaserDir));\n    \n    //If laser refracts back inside, there is no hitpoint on the ground plane\n    if(dot(refractedLaserDir, laserExitDir) > 0.0)\n    {\n       \tfloat distAfterExit = castRay(laserExitPos, laserExitDir, time, 1.0);\n    \tvec3 laserGroundPos = laserExitPos + laserExitDir * distAfterExit;\n        laserOnSurface += (laserBrightness(length(laserGroundPos - laserPoint)))\n            * exp(-lightDecay * laserInsideDist)\n            * 2.0 //Hack to make it more visible\n            * abs(dot(backNormal, -refractedLaserDir));        \n    }\n    \n    diamondColor += laserOnSurface * returnLaserAttenuation * laserColor;\n    \n    return diamondColor + laserIntensity * laserColor * laserAttenuation * returnLaserAttenuation;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - vec2(0.5f)) * vec2(1.0, aspect) + vec2(0.5);\n    // Time varying pixel color\n    vec3 color = rtMain(uv, iTime * 0.3);\n\n    //Gamma\n    color.rgb = pow(color.rgb, vec3(GammaValue));\n\n    //Saturate channels\n    color.rgb = min(color.rgb, vec3(1.0));\n\n    //Vignette\n    color.rgb *= pow(1.0 - length(uv - vec2(0.5, 0.5)) * VignetteStrength, 0.5); \n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}