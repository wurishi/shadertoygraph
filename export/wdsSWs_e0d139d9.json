{"ver":"0.1","info":{"id":"wdsSWs","date":"1552592526","viewed":1430,"name":"Cube Singularity","username":"dracusa","description":"It's very dense, there's an infinity of cubes in a single point.","likes":45,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","sdf","spiral","recursive","polar","zoomer","logpolar","loopless"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nLog-polar tiled cubes. The log-polar mapping is applied to the xz coordinates of\nthe 3D SDF. The remaining dimension is shrunk by a factor of length(xz). In this\nway, the mapping becomes uniform and the SDF distortion is greatly reduced.\n*/\n\n#define AA 2\n#define HEIGHT 0.25\n#define M_PI 3.1415926535897932384626433832795\n#define LONGSTEP (M_PI*4.)\n\nfloat gTime;\n\n/* \nThe tiling switches between 3 different densities at regular time points. These\nswitches are not instant, but propagate like a shockwave from the origin. So at\nany given time during the transitions, there are two different densities, and a\nboundary position between the two. These are stored in globals, set in main()\nand consumed in the sdf: \n*/\nfloat gABPos;\nfloat gDensA;\nfloat gDensB;\n\n// Modified from https://iquilezles.org/articles/distfunctions\nfloat sdCube( vec3 p, float b )\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// Axis rotation taken from tdhooper. R(p.xz, a) rotates \"x towards z\".\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// spiked surface distance (h >= 0)\n// https://www.shadertoy.com/view/3ssSR7\nfloat sdSpike2D(vec2 p, float h)\n{\n\tfloat d = p.y - (h*0.1)/(abs(p.x)+0.1);\n\td = min(d, length(p - vec2(0, min(h, p.y))));\n\tfloat d2 = abs(p.x) - ((h*0.1)-0.1*p.y)/p.y;\n\tif (p.y<h && d>0.0)\n\t\td = min(d, d2);\n\treturn d;\n}\n\n/*\nTile space in a spiked log-polar grid.\n\n- in `pin`: point with length(pin.xz) precomputed in pin.w\n- out `density`: density of tiling\n- out `cubsz`: size of cube\n- returns: tiled point coordinates\n*/\nvec3 tile(in vec4 pin, out float density, out float cubsz)\n{\n\tfloat r = pin.w;\n\t// switch densities in shockwaves\n\tdensity = mix(gDensA, gDensB, smoothstep(0., 0.1, r-gABPos));\n\t// log-polar transformation in xz; spike and proportional shrink in y\n\tvec3 p = vec3(\n\t\tlog(r), \n\t\t(pin.y-HEIGHT*0.1/(r+0.1))/r, \n\t\tatan(pin.z, pin.x)\n\t);\n\t// scaling in the log-polar domain creates density\n\tp *= density;\n\t// rho-translation causes zooming\n\tp.x -= gTime*2.0;\n\t// make it a spiral by rotating the tiled plane\n\tpR(p.xz, 0.6435); // atan(3/4)\n\t// convert to single-tile coordinates\n\tp.xz = mod(p.xz, 2.0) - 1.0;\n\t// scale and rotate the individual cubes\n\t// using an oscillation that spreads from the center over time\n\tfloat osc = sin(sqrt(r)-gTime*0.25-1.0);\n\tfloat cubrot = smoothstep(0.5, 0.8, osc);\n\tcubsz = sin(p.x*0.1)*0.29 + 0.5;\n\tcubsz = mix(cubsz, 0.96, smoothstep(0.7, 1.0, abs(osc)));\n\tpR(p.xy, cubrot);\n\treturn p;\n}\n\nfloat sdf(in vec3 pin)\n{\n\t// tile the coordinates and get cube distance\n\tfloat r = length(pin.xz);\n\tfloat cubsz, density; // out\n\tvec3 tiled = tile(vec4(pin, r), density, cubsz);\n\tfloat ret = sdCube(tiled, cubsz);\n\t// adjust the distance based on how much scaling occured\n\tret *= r/density;\n\n\t// avoid overstepping:\n\t// add hidden surface to bring rays into the right tiles\n\tfloat pkofs = r * cubsz / density;\n\tfloat pk = sdSpike2D(vec2(r, pin.y), HEIGHT) - pkofs;\n\tif (pk < 0.002) pk = ret;\n\tret = min(ret, pk);\n\t// shorten steps near the peak\n\tfloat shorten = length(pin - vec3(0., 0.25, 0.));\n\tshorten = 1. + 1.5*(1.-smoothstep(0., 0.22, shorten));\n\tret /= shorten;\n\n\treturn ret;\n}\n\n// Color the faces of cubes, reusing the tiling function.\nvec3 colr(in vec3 pin)\n{\n\tfloat a = 0.26;\n\tfloat b = 0.65;\n\tfloat z = 0.19;\n\tfloat cubsz, density; // out\n\tvec3 p = tile(vec4(pin, length(pin.xz)), density, cubsz);\n\tif (p.x > abs(p.y) && p.x > abs(p.z)) return vec3(z,a,b);\n\tif (p.x < -abs(p.y) && p.x < -abs(p.z)) return vec3(z,b,a)*0.7;\n\tif (p.z > abs(p.x) && p.z > abs(p.y)) return vec3(z,a,a);\n\tif (p.z < -abs(p.x) && p.z < -abs(p.y)) return vec3(b*0.5,z,a);\n\treturn vec3(b,b,a);\n}\n\n// Adapted from https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pos)\n{\n\tvec2 e = vec2(1.0,-1.0)*0.5773;\n\tconst float eps = 0.0005;\n\treturn normalize(\n\t\te.xyy*sdf(pos + e.xyy*eps) + \n\t\te.yyx*sdf(pos + e.yyx*eps) + \n\t\te.yxy*sdf(pos + e.yxy*eps) + \n\t\te.xxx*sdf(pos + e.xxx*eps)\n\t);\n}\n\nfloat time2density(float x)\n{\n\tfloat fullMod = fract(x/(LONGSTEP*3.))*3.;\n\tif (fullMod > 2.) return 45.;\n\telse if (fullMod > 1.) return 25.;\n\telse return 15.;\n}\n\n// Based on https://iquilezles.org/articles/raymarchingdf\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\t// automate the shockwave transitions between densities\n\tgTime = iTime+1.8;\n\tfloat ltime = gTime + M_PI*6.3;\n\tgABPos = smoothstep(0.45, 0.6, fract(ltime/LONGSTEP))*2.2-0.2;\n\tgDensA = floor(time2density(ltime))/M_PI;\n\tgDensB = floor(time2density(ltime-LONGSTEP))/M_PI;\n\n\t // camera movement\t\n\tfloat camera_y = pow(sin(gTime*0.2), 3.)*0.2+0.7;\n\tvec3 ro = vec3(0., camera_y, 1.);\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\t// camera matrix\n\tvec3 ww = normalize(ta - ro);\n\tvec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)));\n\tvec3 vv = normalize(cross(uu,ww));\n\n\tvec3 tot = vec3(0.0);\n\t\n\t#if AA>1\n\tfor(int m=0; m<AA; m++)\n\tfor(int n=0; n<AA; n++)\n\t{\n\t\t// pixel coordinates\n\t\tvec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n\t\tvec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\t\t#else    \n\t\tvec2 p = (-iRes.xy + 2.0*fragCoord)/iRes.y;\n\t\t#endif\n\n\t\t// create view ray\n\t\tvec3 rd = normalize(p.x*uu + p.y*vv + 3.5*ww); // fov\n\n\t\t// raymarch\n\t\tconst float tmax = 3.0;\n\t\tfloat t = 0.0;\n\t\tfor(int i=0; i<256; i++)\n\t\t{\n\t\t\tvec3 pos = ro + t*rd;\n\t\t\tfloat h = sdf(pos);\n\t\t\tif( h<0.0001 || t>tmax ) break;\n\t\t\tt += h;\n\t\t}\n\t\n\t\t// shading/lighting\t\n\t\tvec3 bg = vec3(0.1, 0.15, 0.2)*0.3;\n\t\tvec3 col = bg;\n\t\tif(t<tmax)\n\t\t{\n\t\t\tvec3 pos = ro + t*rd;\n\t\t\tvec3 nor = calcNormal(pos);\n\t\t\tfloat dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n\t\t\tfloat amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n\t\t\tcol = colr(pos)*amb + colr(pos)*dif;\n\t\t}\n\t\t// fog\n\t\tcol = mix(col, bg, smoothstep(2., 3., t));\n\n\t\t// gamma        \n\t\tcol = sqrt(col);\n\t\ttot += col;\n\t#if AA>1\n\t}\n\ttot /= float(AA*AA);\n\t#endif\n\n    // Output to screen\n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}