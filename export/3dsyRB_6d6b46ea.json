{"ver":"0.1","info":{"id":"3dsyRB","date":"1600353170","viewed":160,"name":"Terrain #47","username":"GCScholar","description":"terrain","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_DISTANCE 10.\n#define PI 3.14\n#define ASP_RATIO iResolution.x/iResolution.y\n#define FOG_COLOR vec3(0.5,0.5,0.5)\n\nvec3 applyFog(vec3  pixelCol, float distance )\n{\n    float fogAmount = 1.0 - exp( -distance*0.02);\n    vec3  fogColor = FOG_COLOR;\n    return mix( pixelCol, fogColor, fogAmount);\n}\n\nstruct Point \n{\n\tfloat d;\t\t// Point distance\n    vec3 P;\t\t\t// Point coordinate\n    vec3 normal;\n    float mat;  \t// Point material\n};\n\nfloat sdSphere(vec3 P, float r) \n{\n\treturn length(P) - r;\n}\n\n\n// WALLS\nfloat terrainMap(vec3 P)\n{\t\n    // Size of the tile mapped on the texture\n    float tileSize = 10.0;\n    \n    vec2 uv = fract((P.xz-tileSize*0.7)/tileSize);\n    return P.y - 3.*texture(iChannel0, uv).x;\n}\n\nvec3 terrainMapNormal(vec3 P)\n{\n\tvec2 eps = vec2(0.01, 0.0);\n    return normalize(vec3(\n        terrainMap(P + eps.xyy) - terrainMap(P - eps.xyy),\n        terrainMap(P + eps.yxy) - terrainMap(P - eps.yxy),\n        terrainMap(P + eps.yyx) - terrainMap(P - eps.yyx)));\n}\n\nvec3 terrainMaterial(vec3 P, vec3 N)\n{\n    vec3 mat = vec3(0.0);\n    float ns = noise(P.xy)*0.12;\n    vec3 snow = vec3(0.3+ns, 0.3+ns, 0.4+ns) * smoothstep(1.5, 2.5, P.y) * N.y;\n    vec3 rock = vec3(0.05, 0.05, 0.08) * smoothstep(0.0, 1.7, P.y);;\n    return snow + rock;\n}\n\n// Render scene\nPoint castRayIntoScene(const vec3 ro, const vec3 rd) \n{\n    // Holds (distance, material)\n\tPoint hit = Point( 0.0, vec3(0.0), vec3(0.0), 0.0);\n    \n    // Render terrain map and the sphere map\n    float dt = 0.01;\n    float lh = 0.0;\n    float ly = 0.0;\n    for( float t=0.1; t<MAX_MARCHING_DISTANCE; t+=dt)\n    {\n    \tvec3 P = ro + rd*t;\n        float h;        \n\n        // Terrain\n        h = terrainMap(P);\n        if(h < 0.001)\n        {\n            hit.d = t - 0.5*dt;\n            hit.P = ro + rd*hit.d;\n            hit.mat = 1.0;\n            hit.normal = terrainMapNormal(P);\n            return hit;\n        }\n        \n        h = sdSphere(P, 1.0);\n        if(abs(h) < 0.001*t)\n        {\n            hit.d = t - 0.5*dt;\n            hit.P = ro + rd*hit.d;\n            hit.mat = 1.0;\n            vec2 eps = vec2(1.0, 0.0);\n            //hit.normal = vec3(hit.P + eps.xyy;\n            return hit;\n        }\n\n    }\n   \n    return Point(MAX_MARCHING_DISTANCE + 1.0, vec3(0.0), vec3(0.0), 0.0);\t // Hit nothing\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize coordinates\n    vec2 U = (2.* fragCoord - iResolution.xy) / iResolution.y;\n    \n    // Camera\n    vec3 target = vec3(0.0, 3.0, 0.0);\n    float angle = iMouse.x / iResolution.x * 2.0 * 3.14;\n    vec3 eye = vec3(2.0*sin(angle),  3.0, 2.0*cos(angle));\n    \n    // The camera reference system has the local z-axis pointing backward\n    vec3 ww = normalize((eye - target));\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    \n    // Ray marching\n    vec3 ray = normalize(vec3(U.x*uu + U.y*vv - (1.5)*ww));\n    Point hit = castRayIntoScene(eye, ray);\n    \n    // Shading\n    vec3 col = vec3(0.0); \n    vec3 N;\n    \n    // Background sky\n    vec3 backgroud_color = vec3(0.4, 0.75, 1.0) - 0.7*ray.y; // Gradient from lighter to darker\n    backgroud_color = mix( backgroud_color, vec3(0.7,0.75,0.8), exp(-3.0*(ray.y+0.05))); // Interpolate with some orange\n    \n    \n    vec3 sky_dir = normalize(vec3(0.0, 1.0, 0.0));\n\tvec3 sky_color = vec3(0.5, 0.8, 0.9); \n    vec3 sun_dir = normalize(vec3(1.0, 0.2, 0.2));\n\tvec3 sun_color = vec3(7.0, 5.0, 3.0); \n    \n    col = backgroud_color;\n    if(hit.d < MAX_MARCHING_DISTANCE) \n    {   \n        vec3 mat = vec3(0.0);\n        if(hit.mat == 1.0)\t\t // Terrain\n        {\n            N = hit.normal;\n           \tmat = terrainMaterial(hit.P, hit.normal);\n        }\n        \n        vec3 sky_diff = sky_color * clamp(0.5 + 0.5*dot(N, sky_dir), 0.0, 1.0);       \n        vec3 sun_diff = sun_color * clamp(dot(N, sun_dir), 0.0, 1.0);  \n        Point S = castRayIntoScene(hit.P+N*0.01, sun_dir);\n        float sun_shadow = (S.d < MAX_MARCHING_DISTANCE ) ? 0.0 : 1.0;\n        col = sky_diff * mat;\n        col += sun_diff*sun_shadow * mat;\n        \n        // Fog\n        col = applyFog(col, hit.d);\n    }\n    \n    // Gamma correction\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0); \n    //fragColor = vec4(texture(iChannel0, fragCoord/iResolution.xy).x);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalize coordinates\n    vec2 U = (fragCoord) / iResolution.xy;   \n    \n    // Noise\n    //fragColor = vec4(noise(U));\n    \n    // Bigger noise nice scaloni\n    //fragColor = vec4(noise(floor(U*5.0)));\n    \n    // Value noise good for desert\n    //fragColor = vec4(valueNoise(U*5.0));\n    \n    // Fractal value noise\n    float scale = 5.0;\n    //fragColor = vec4(fbmValueNoise(U*10.0, 0.5, 6)); \n    \n    // Inigo gradient noise\n    //float f = fbmInigoNoise(U*5.0, 0.7, 6);\n\t//fragColor = vec4(0.5 + 0.5*f);        \n    // Tile noise\n    fragColor = vec4(tiledNoise(U));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noiseInigo( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbmInigoNoise(vec2 v, float H, int nOctaves) \n{\n    float value = 0.0;\n    float G = pow(2.0, -H);\n    float amplitude = 0.5;\n    float frequency = 1.0;\n    \n    for(int i=1; i<=nOctaves; i++) \n    {\n    \tvalue += amplitude*noiseInigo(frequency*v); // Compute noise\n        frequency = frequency * 2.0;\t\t\t\t// Higher frequency octave\n        amplitude *= G;\t\t\t\t\t\t\t\t// Less amplitude on higher octave \n    }\n    return value;\n}\n\n///////////////////\nfloat noise(vec2 v) \n{\n\treturn fract(sin(dot(v, vec2(33.1234, 13.23))) * 34241.3);\n}\n\nfloat valueNoise(vec2 v) \n{\n    vec2 i = floor(v);\n    vec2 f = fract(v);\n    \n    float p00 = noise(vec2(floor(i.x), floor(i.y)));\n    float p01 = noise(vec2(floor(i.x), floor(i.y) + 1.0));\n    float p10 = noise(vec2(floor(i.x) + 1.0, floor(i.y)));\n    float p11 = noise(vec2(floor(i.x) + 1.0, floor(i.y) + 1.0));\n    \n    // Cubic interpolate values\n    vec2 c = smoothstep(0.0, 1.0, f);\n    \n    return p00 * (1.0 - c.x) * (1.0 - c.y) + \n           p10 * c.x * (1.0 - c.y) +\n           p01 * (1.0 - c.x) * c.y +\n           p11 * c.x * c.y;             \n}\n\nfloat fbmValueNoise(vec2 v, float H, int nOctaves) \n{\n    float value = 0.0;\n    float G = pow(2.0, -H);\n    float amplitude = 0.5;\n    float frequency = 1.0;\n    \n    for(int i=1; i<=nOctaves; i++) \n    {\n    \tvalue += amplitude*valueNoise(frequency*v); // Compute noise\n        frequency = frequency * 2.0;\t\t\t\t// Higher frequency octave\n        amplitude *= G;\t\t\t\t\t\t\t\t// Less amplitude on higher octave \n    }\n    return value;\n}\n\nfloat tiledNoise(vec2 v) \n{\n\tvec2 c = 2.0*v-1.0;\t// Transform coordinate to [-1,1] x [-1,1]\n    return fbmValueNoise(abs(c)*2.0, 1.0, 6); // build the tile \n}\n\nfloat simplexNoise(){ return 1.0;}\nfloat gradientNoise(){ return 1.0;}\nfloat fractalGradientNoise(){ return 1.0;}","name":"Common","description":"","type":"common"}]}