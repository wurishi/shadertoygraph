{"ver":"0.1","info":{"id":"ftSfRz","date":"1652437805","viewed":479,"name":"Efficient grass rendering","username":"jaszunio15","description":"I've tried to implement grass rendering based on this blog post: https://gamedev.ru/code/articles/grass_raycast\nThanks to Alexander Sannikov, who designed this technique.\nIt is baking grass raymarching data that is later used to accelerate rendering.","likes":23,"published":1,"flags":16,"usePreview":0,"tags":["volume","grass","fur","efficient","fields","baking"],"hasliked":0,"parentid":"stlfW2","parentname":"Remapping Cubemap to Volume"},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Shader License: CC BY 3.0\n//Author: Jan MrÃ³z (jaszunio15)\n\n/*\n\nI've tried to implement grass rendering based on this blog post: https://gamedev.ru/code/articles/grass_raycast\nThanks to Alexander Sannikov, who designed this technique. I highly recommend to take a look at his article, \nas it describes the idea pretty well.\n\nPress M to switch camera control to mouse.\nPress C to see the baked data on the cubemap.\n\nIn the first frames, shader will bake the raymarching data for the grass into the 3D texture, so the shader in the \nfirst few seconds can be slow. The baking process is in the \"Cube A\" shader. \nI'm baking raymarch distance, normal and grass blade hash value into a single pixel.\n\n\"Image\" shader uses previously baked data to accelerate grass rendering. Instead of performing raymarching, it just does \none texture lookup to know how far the ray will go into the grass. Another lookup is needed for shadow computation.\n\nThere are some parameters of baking and rendering in the Common tab.\n\n*/\n\n#define C_KEY 67\n#define M_KEY 77\n\nstruct Surface\n{\n    vec3 positionWS;\n    vec3 normalWS;\n    vec3 color;\n    float depth;\n    float grassHash;\n    float ao;\n};\n\nSurface InitializeSurface()\n{\n    Surface surface;\n    surface.depth = 999999.0;\n    surface.normalWS = vec3(0.0, 1.0, 0.0);\n    return surface;\n}\n\nstruct GrassParameters\n{\n    mat3 grassRotationOffset;\n    vec2 uvOffset;\n    float height;\n    float scale;\n    vec3 firstColor;\n    vec3 secondColor;\n};\n\nvec3 RaycastYPlane(vec3 rayOrigin, vec3 rayDirection, float planeHeight, inout bool isHit)\n{\n    vec3 ray = rayDirection / rayDirection.y;\n    vec3 hitPoint = rayOrigin + ray * (planeHeight - rayOrigin.y);\n    isHit = dot(hitPoint - rayOrigin, rayDirection) > 0.0;\n\n    return hitPoint;\n}\n\nvec3 CalculateRayDirection(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 rayDirection = normalize(vec3(uv, 1.0));\n    float yaw = -1.2 + sin(iTime * 0.14) * 0.9;\n    float pitch = 0.6 + cos(iTime * 0.18) * 0.4;\n    if (dot(iMouse.xy, iMouse.xy) >= 1.0 &&  texelFetch(iChannel1, ivec2(M_KEY, 2), 0).x > 0.5)\n    {\n        yaw = iMouse.x / iResolution.x * 6.28;\n        pitch = iMouse.y / iResolution.y * 3.0 - 3. * 0.5;\n    }\n    rayDirection = RotationMatrix(vec3(pitch, yaw, 0.0)) * rayDirection;\n    return rayDirection;\n}\n\n// ------------------------ GRASS RENDERING --------------------------\n\n// Renders single grass layer\nvoid RenderGrassLayer(vec3 rayOrigin, vec3 rayDirection, GrassParameters grassParameters, inout Surface surface, inout bool isHit)\n{\n    // Raycast top grass level\n    vec3 hitPoint = RaycastYPlane(rayOrigin, rayDirection, grassParameters.height, isHit);\n    float distanceMultiplier = length(rayDirection / length(rayDirection.xz));\n    \n    if (isHit)\n    {\n        if (distance(hitPoint, rayOrigin) > surface.depth)\n        {\n            isHit = false;\n            return;\n        }\n        \n        // Adjusting raycasted plane uv\n        vec2 planeUV = (hitPoint.xz + grassParameters.uvOffset / grassParameters.scale);\n        planeUV = (grassParameters.grassRotationOffset * vec3(planeUV.x, 0.0, planeUV.y)).xz;\n        planeUV *= grassParameters.scale;\n\n        // Wind simulation\n        float time = iTime;\n        vec3 windDirection = -((Noise32(hitPoint.xz * 0.5 + time)).rrr) * 1.0;          \n        windDirection = sign(windDirection) * clamp(pow(abs(windDirection), vec3(4.0)), 0.0, 1.0) * DISTORTION_STRENGTH;\n\n        // Tangent space conversions\n        mat3 worldToGrassSpace = RotationMatrix(windDirection * vec3(-1.0, 0.0, 1.0)) * grassParameters.grassRotationOffset;\n        mat3 grassToWorldSpace = transpose(worldToGrassSpace);\n        \n        // Adjusting plane UV to make wind bend top of the grass instead of bottom\n        vec3 up = grassToWorldSpace * vec3(0.0, 1.0, 0.0);\n        float distanceToGround = grassParameters.height - GROUND_HEIGHT;\n        planeUV -= up.xz * distanceToGround;\n\n        // Ray direction in tangent space\n        vec3 manipulatedDirection = normalize(worldToGrassSpace * rayDirection);\n        \n        // Raycasting by using lookup texture\n        float slicesCount = ANGLE_PRECISION * VOLUME_RESOLUTION;\n        float volumeSlice = fract((atan(-manipulatedDirection.x, -manipulatedDirection.z) + PI) / (2.0 * PI) * ANGLE_PRECISION);\n        float distanceMultiplier = length(manipulatedDirection / length(manipulatedDirection.xz));\n#ifdef USE_LINEAR_SAMPLER\n        vec4 bakedData = SampleVolumeLinear(iChannel0, vec3(fract(planeUV), volumeSlice));        \n#else\n        vec4 bakedData = SampleVolumePoint(iChannel0, vec3(fract(planeUV), volumeSlice));\n#endif\n        vec2 tracedPlaneUV = planeUV + (manipulatedDirection.xz * bakedData.x);\n        float dist = bakedData.x * distanceMultiplier / grassParameters.scale;\n        \n        // Getting grass blade ID\n        float grassBladeID = SampleVolumePoint(iChannel0, vec3(fract(tracedPlaneUV), volumeSlice)).a;\n        float tileHash = Hash22(floor(tracedPlaneUV)).r * 10.0;\n\n        // Getting grass normal and position in world space\n        vec3 bakedNormalGS = vec3(bakedData.y, 0.0, bakedData.z);\n        if (dot(bakedNormalGS, bakedNormalGS) < 0.1)\n            bakedNormalGS.y = 1.0;\n\n        vec3 normalWS = normalize(grassToWorldSpace * bakedNormalGS);\n        vec3 positionWS = hitPoint + normalize(rayDirection) * dist;\n        \n        // Depth calculation\n        float depth = distance(rayOrigin, positionWS);\n        \n        // AO\n        float ao = pow(smoothstep(AO_HEIGHT, 0.0, abs(hitPoint.y - positionWS.y)), 3.0);\n        \n        // If is on top of other surface, override surface data\n        if (depth < surface.depth)\n        {\n            //surface.color = vec4(1.0, 0.0, 0.0, 1.0);\n            surface.positionWS = positionWS;\n            surface.depth = distance(rayOrigin, surface.positionWS);\n            surface.normalWS = normalWS;\n            surface.ao = ao * 0.75 + 0.25;\n            surface.grassHash = fract(grassBladeID + tileHash);\n            surface.color = mix(grassParameters.firstColor, grassParameters.secondColor, surface.grassHash);\n            isHit = true;\n        }\n        else\n            isHit = false;\n    }\n    else\n        isHit = false;\n}\n\n// Renders stacked grass layers.\nvoid RenderGrass(vec3 rayOrigin, vec3 rayDirection, inout Surface surface, inout bool isHit)\n{\n    GrassParameters grassParameters;\n    vec3 grassRotationAngles = vec3(0.1, 0.0, 0.1);\n    grassParameters.grassRotationOffset = RotationMatrix(vec3(0.1, 0.0, 0.1));\n    grassParameters.uvOffset = vec2(0.0, 0.0);\n    grassParameters.height = -1.0;\n    grassParameters.scale = 1.0;\n    grassParameters.firstColor = FIRST_COLOR;    \n    grassParameters.secondColor = SECOND_COLOR;\n\n    \n    surface = InitializeSurface();\n    Surface tempSurface = surface;\n    mat2 goldenRotation = mat2(cos(GOLDEN_ANGLE), sin(GOLDEN_ANGLE), -sin(GOLDEN_ANGLE), cos(GOLDEN_ANGLE));\n    \n    for (float i = 0.0; i < GRASS_LAYERS_COUNT; i++)\n    {\n        RenderGrassLayer(rayOrigin, rayDirection, grassParameters, tempSurface, isHit);\n        if (isHit)\n            surface = tempSurface;\n        \n        grassRotationAngles.xz = goldenRotation * grassRotationAngles.xz * 1.2;\n        grassParameters.grassRotationOffset = RotationMatrix(grassRotationAngles);\n        grassParameters.scale *= 1.345;        \n        grassParameters.height -= 0.02;\n        grassParameters.uvOffset += vec2(0.135, 0.043534);\n        grassParameters.firstColor *= vec3(0.9);        \n        grassParameters.secondColor *= vec3(0.9);\n    }\n}\n\n// ----------------- LIGHTING -------------------------------\n\nvec3 CalculateAmbientLight(vec3 color, vec3 normal, vec3 viewDir)\n{\n    vec3 reflectDir = reflect(-viewDir, normal);\n    vec3 diffuseAmbient = GammaToLinear(textureLod(iChannel3, normal, 7.0).rgb);\n    vec3 specularAmbient = GammaToLinear(textureLod(iChannel3, reflectDir, mix(5.0, 1.0, SMOOTHNESS) + 2.0).rgb);\n    float fresnel = pow(1.0 - dot(viewDir, normal), mix(5.0, 1.0, SMOOTHNESS)) * 0.8 + 0.2;\n    \n    vec3 skyColor = mix(FIRST_SKY_COLOR, SECOND_SKY_COLOR, DAYTIME);\n    return mix(diffuseAmbient * color, specularAmbient * fresnel, SPECULAR * 0.4) * GammaToLinear(skyColor);\n}\n\nvec3 CalculateDirectionalLight(vec3 color, vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightColor)\n{\n    float ndotl = dot(normal, lightDir);\n    float lambert = max(0.0, ndotl);\n    float translucent = max(0.0, -ndotl);\n    vec3 halfWay = normalize(viewDir + lightDir);\n    float specular = pow(max(0.0, dot(normal, halfWay)), mix(1.0, 16.0, SMOOTHNESS));\n    float fresnel = pow(1.0 - dot(viewDir, normal), mix(5.0, 1.0, SMOOTHNESS));\n    vec3 diffusedLight = mix(color * lambert, color * translucent * 1.5, TRANSLUCENCY);\n    \n    lightColor = GammaToLinear(lightColor);\n    \n    return mix(diffusedLight * lightColor, vec3(specular) * fresnel * lightColor, SPECULAR);\n}\n\nvec3 CalculateGrassLight(vec3 color, vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightColor, float shadow)\n{\n    color = GammaToLinear(color);\n    vec3 ambient = CalculateAmbientLight(color, normal, viewDir);\n    vec3 directional = CalculateDirectionalLight(color, normal, viewDir, lightDir, lightColor) * shadow;\n    return ambient * 0.3 + directional;\n}\n\n// ------------------------ MAIN SHADER --------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    \n    // Preparing ray data\n    bool isHit = false;\n    vec3 rayOrigin = vec3(iTime * 0.4, 0.5 + sin(iTime * 0.4) * 0.5 - 0.4, iTime * 0.4);\n    vec3 rayDirection = CalculateRayDirection(fragCoord);\n    \n    // Rendering grass\n    Surface surface;\n    RenderGrass(rayOrigin, rayDirection, surface, isHit);\n    \n    // Rendering ground\n    vec3 hitPoint = RaycastYPlane(rayOrigin, rayDirection, GROUND_HEIGHT, isHit);\n    if (distance(rayOrigin, hitPoint) < surface.depth && isHit)\n    {\n        surface.positionWS = hitPoint;\n        surface.normalWS = vec3(0.0, 1.0, 0.0);\n        surface.color.rgb = texture(iChannel2, hitPoint.xz).rgb * 0.6;\n        surface.depth = distance(rayOrigin, hitPoint);\n        surface.ao = 1.0;\n    }\n    \n    // Calculating shadows\n    float shadow = 1.0;\n#ifdef ENABLE_SHADOWS\n    if (isHit)\n    {\n        vec3 shadowRayOrigin = surface.positionWS + LIGHT_DIR * 10.0;\n        vec3 shadowRayDirection = normalize(surface.positionWS - shadowRayOrigin);\n        float cleanDepth = distance(surface.positionWS, shadowRayOrigin);\n        Surface shadowSurface;\n        RenderGrass(shadowRayOrigin, shadowRayDirection, shadowSurface, isHit);\n        if (shadowSurface.depth < cleanDepth - SHADOW_BIAS)\n            shadow = 1.0 - SHADOW_STRENGTH;\n    }\n#endif\n\n    // Trying to mipmap the image\n#ifdef ENABLE_DISTANCE_SMOOTHING\n    float mipmapFade = (clamp(pow((fwidth(hitPoint.x) + fwidth(hitPoint.z)), 0.4), 0.0, 1.0));\n    surface.normalWS = mix(surface.normalWS, -normalize(rayDirection), mipmapFade * 0.8);\n    surface.color = mix(surface.color, (FIRST_COLOR + SECOND_COLOR) * 0.5, mipmapFade * 0.8);\n#endif\n\n    // Lighting\n    vec3 grassLighting = LinearToGamma(CalculateGrassLight(surface.color, surface.normalWS, -normalize(rayDirection), normalize(LIGHT_DIR), LIGHT_COLOR, shadow)) * 1.0;\n    grassLighting *= surface.ao;\n    fragColor.rgb = grassLighting;\n    \n    // Sky and fog\n    float sun = pow(max(0.0, dot(normalize(rayDirection), normalize(LIGHT_DIR)) - 0.05), 8.0);\n    vec3 skyColor = SKY_COLOR + sun * 0.7;\n    float fog = max(1.0 - exp(-0.02 * (surface.depth)), 0.0);\n    fragColor.rgb = clamp(mix(fragColor.rgb, skyColor, fog), 0.0, 1.0);\n    \n    // postprocess\n    fragColor = smoothstep(-0.05, 1.0, fragColor.rgba) * 1.0;\n    float vignette = pow(smoothstep(0.77, 0.0, length(uv)), 0.5) * 0.5 + 0.5;\n    fragColor.rgb *= vignette;\n\n    if (texelFetch(iChannel1, ivec2(C_KEY, 2), 0).x > 0.5)\n    {\n        vec3 rayDir = CalculateRayDirection(fragCoord);\n        vec4 volume = texture(iChannel0, rayDir);\n        fragColor = vec4(volume.xyz, 0.0) * volume.w;\n    }\n    \n    //fragColor.rgb += vec3(mipmapFade);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"float SDF(vec2 position, inout float bladeID)\n{\n    return VoronoiSDF(position, GRASS_BLADES_COUNT, bladeID) / GRASS_BLADES_COUNT;\n}\n\nvec2 RayMarch(vec2 rayOrigin, vec2 rayDirection)\n{\n    float distanceAccumulated = 0.0;\n    for (float i = 0.0; i < RAYMARCH_STEPS; i++)\n    {\n        float bladeID;\n        float sdf = SDF(rayOrigin, bladeID) - distanceAccumulated * GRASS_THICKNESS_DIFFERENCE;\n        distanceAccumulated += sdf;\n        rayOrigin += rayDirection * max(sdf, 0.0);\n        \n        if (mod(i, 10.0) <= 1.0 && sdf < 0.00001)\n            break;\n    }\n    \n    return rayOrigin;\n}\n\nvec2 SDFNormal(vec2 position)\n{\n    float bladeID;\n    float eps = GRASS_BLADES_COUNT * 0.01 / VOLUME_RESOLUTION;\n    float sdf00 = SDF(position, bladeID);\n    float sdf10 = SDF(position + vec2(1.0, 0.0) * eps,bladeID);\n    float sdf01 = SDF(position + vec2(0.0, 1.0) * eps, bladeID);\n    return normalize(-vec2(sdf00 - sdf10, sdf00 - sdf01));\n}\n\n// Rendering volume\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    float frame = max(0.0, float(iFrame) - WARM_UP_FRAMES);\n    if (frame <= ANGLE_PRECISION * VOLUME_RESOLUTION)\n    {\n        // Remap ray direction to volume texel coord.\n        vec3 fragCoord3D = CalculateCoord3D(rayDir);\n        \n        // Baking only one volume slice in frame to avoid webgl crash\n        if (floor(fragCoord3D.z) != float(frame))\n        {\n            fragColor = texture(iChannel0, rayDir);\n            return;\n        }\n        \n        vec3 uv3D = fragCoord3D / VOLUME_RESOLUTION;\n        \n        if (uv3D.z >= ANGLE_PRECISION + 0.01)\n             return;\n        float angle = uv3D.z / ANGLE_PRECISION * PI * 2.0;\n        vec2 rayDirection = vec2(sin(angle), cos(angle));\n\n        vec2 uv = uv3D.xy * GRASS_BLADES_COUNT;\n        vec2 hit = RayMarch(uv, rayDirection);\n        float distanceToHit = distance(uv, hit) / GRASS_BLADES_COUNT;\n        float grassBladeID;\n        SDF(hit, grassBladeID);\n\n        // Inserting color into volume\n        fragColor = vec4(distanceToHit, SDFNormal(hit), grassBladeID);\n        return;\n    }\n    else\n    {\n        fragColor = texture(iChannel0, rayDir);\n        return;\n    }\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"// --------------------- BAKING PARAMETERS ---------------------------------\n\n// Each time you change one of those parameters, you must rerun the shader (rewind to beginning) to restart the baking process.\n\n// How many grass blades are in baked tile (in single dimension). Increase value to make grass more dense\n#define GRASS_BLADES_COUNT 10.0\n\n// Minimum width of the grass blade\n#define GRASS_THICKNESS_MIN 0.05\n\n// Maximum width of the grass blade\n#define GRASS_THICKNESS_MAX 0.2\n\n// How grass blade thickness will increase when raymarching takes long distance (used to reduce artifacts and to make raymarching hit the grass sdf faster)\n#define GRASS_THICKNESS_DIFFERENCE 0.001\n\n// How many steps raymarching will do during bake process\n#define RAYMARCH_STEPS 500.0\n\n// Between 0.0 and 1.0. Lower value will increase performance due to better cache hit rate of texture read but artifacts can appear.\n#define ANGLE_PRECISION 1.0\n\n// Grass shapes, switch defines to make the grass shape different. \n#define FLAT_SHAPE\n//#define TRIANGLE_SHAPE\n//#define CIRCLE_SHAPE\n\n\n\n// --------------------- RENDERING PARAMETERS ------------------------------\n\n// Enables rendering directinal light shadow. Disabling the shadows will increase performance.\n#define ENABLE_SHADOWS\n\n#define SHADOW_STRENGTH 0.5\n\n// Enables some mipmapping shenanigans\n#define ENABLE_DISTANCE_SMOOTHING\n\n// Defines shadow depth offset\n#define SHADOW_BIAS 0.09\n\n// Defines ground height\n#define GROUND_HEIGHT -1.5\n\n// Defines depth of AO in the grass\n#define AO_HEIGHT 0.7\n\n// How strong is the wind\n#define DISTORTION_STRENGTH 0.5\n\n// How many grass layers to stack. Less layers will increase performance.\n#define GRASS_LAYERS_COUNT 4.0\n\n// Slower, but can hide some artifacts\n#define USE_LINEAR_SAMPLER\n\n// Seed for randomness (keep around 1.0)\n#define SEED 4.45\n\n// How many frames to wait before baking\n#define WARM_UP_FRAMES 5.0\n\n\n// --------------------- GRASS LIGHTING -------------------------\n\n#define SPECULAR 0.4\n#define SMOOTHNESS 0.5\n#define TRANSLUCENCY 0.65\n\n#define FIRST_LIGHT_DIR normalize(vec3(1.0, 2.12, 0.0))\n#define SECOND_LIGHT_DIR normalize(vec3(1.0, 0.11, 1.0))\n#define FIRST_LIGHT_COLOR vec3(1.0, 1.0, 1.0) * 1.6\n#define SECOND_LIGHT_COLOR vec3(0.8, 0.4, 0.1)\n\n#define FIRST_SKY_COLOR vec3(0.7, 0.9, 1.0) * 0.7\n#define SECOND_SKY_COLOR (vec3(0.8, 0.4, 0.1) * 1.3)\n\n#define DAYTIME (sin(iTime * 0.14) * 0.5 + 0.5)\n\n#define SKY_COLOR mix(FIRST_SKY_COLOR, SECOND_SKY_COLOR, DAYTIME)\n#define LIGHT_DIR mix(FIRST_LIGHT_DIR, SECOND_LIGHT_DIR, DAYTIME)\n#define LIGHT_COLOR mix(FIRST_LIGHT_COLOR, SECOND_LIGHT_COLOR, DAYTIME)\n\n#define FIRST_COLOR vec3(0.5, 0.7, 0.2)\n#define SECOND_COLOR vec3(0.4, 0.8, 0.2)\n\n\n// ------------------- CUBEMAP TO VOLUME MAPPING ---------------------------------------\n// From my other shader that allows to use cubemap as volume: https://www.shadertoy.com/view/stlfW2\n\n// Volume resolution (170.0 is highest possible without loosing data)\n#define VOLUME_RESOLUTION 170.0\n\n// Cubemap resolution must be the same as shadertoy cubemap resolution input\n#define CUBEMAP_RESOLUTION 1024.0\n\n// Returns wall index (0, 1, 2, 3, 4 or 5) and fragCoord of cubemap face.\nfloat CalculateWallProperties(vec3 rayDir, out vec2 fragCoord)\n{\n    vec3 absRayDir = abs(rayDir);\n    float maxRayDir = max(absRayDir.x, max(absRayDir.y, absRayDir.z));\n    vec3 castedRay = rayDir / maxRayDir;\n    float wallIndex = 0.0;\n    if (maxRayDir == absRayDir.x)\n    {\n        wallIndex = 0.0 + sign(rayDir.x) * 0.5 + 0.5;\n        fragCoord = castedRay.yz;\n    }\n    else if (maxRayDir == absRayDir.y)\n    {\n        wallIndex = 2.0 + sign(rayDir.y) * 0.5 + 0.5;\n        fragCoord = castedRay.xz;\n    }\n    else if (maxRayDir == absRayDir.z)\n    {\n        wallIndex = 4.0 + sign(rayDir.z) * 0.5 + 0.5;\n        fragCoord = castedRay.xy;\n    }\n    \n    fragCoord = (fragCoord * 0.5 + 0.5) * CUBEMAP_RESOLUTION;\n        \n    return wallIndex;\n}\n\n// Converts ray direction into volume frag coord.\nvec3 CalculateCoord3D(vec3 rayDir)\n{\n    float slicesOnSingleLine = floor(CUBEMAP_RESOLUTION / VOLUME_RESOLUTION);\n    float slicesOnSingleWall = slicesOnSingleLine * slicesOnSingleLine;\n    \n    vec2 fragCoord;\n    float wallIndex = CalculateWallProperties(rayDir, fragCoord);\n    vec2 tileCoord = floor(fragCoord.xy / VOLUME_RESOLUTION);\n    float tileIndex = tileCoord.y * slicesOnSingleLine + tileCoord.x;\n    vec2 xyCoord = floor(mod(fragCoord.xy, VOLUME_RESOLUTION));\n    float zCoord = wallIndex * slicesOnSingleWall + tileIndex;\n    \n    vec3 coord3D = vec3(xyCoord, zCoord);\n    //coord3D = clamp(coord3D, 0.0, VOLUME_RESOLUTION - 1.0);\n    return vec3(coord3D);\n}\n\n\n// Converts volume frag coord into cubemap ray direction\nvec3 ReconstructRayFromCoord3D(vec3 coord3D)\n{\n    float slicesOnSingleLine = floor(CUBEMAP_RESOLUTION / VOLUME_RESOLUTION);\n    float slicesOnSingleWall = slicesOnSingleLine * slicesOnSingleLine;\n    \n    float wallIndex = floor(floor(coord3D.z) / slicesOnSingleWall);\n    float tileIndex = mod(floor(coord3D.z), slicesOnSingleWall);\n    vec2 tileCoord = vec2(mod(tileIndex, slicesOnSingleLine), floor(tileIndex / slicesOnSingleLine));\n    vec2 cubeCoord = tileCoord * VOLUME_RESOLUTION + (coord3D.xy);\n    \n    vec2 uv = (cubeCoord.xy * 2.0 / CUBEMAP_RESOLUTION) - 1.0;\n    uv += 1.0 / CUBEMAP_RESOLUTION; //monka\n    \n    if (wallIndex == 0.0)\n        return vec3(-1.0, uv.x, uv.y);\n    else if (wallIndex == 1.0)\n        return vec3(1.0, uv.x, uv.y);\n    else if (wallIndex == 2.0)\n        return vec3(uv.x, -1.0, uv.y);\n    else if (wallIndex == 3.0)\n        return vec3(uv.x, 1.0, uv.y);\n    else if (wallIndex == 4.0)\n        return vec3(uv.x, uv.y, -1.0);\n    else if (wallIndex == 5.0)\n        return vec3(uv.x, uv.y, 1.0);\n}\n\nvec4 SampleVolumePoint(samplerCube cube, vec3 uv3D)\n{\n    vec3 coord3D = floor(uv3D * VOLUME_RESOLUTION);\n    vec3 rayDir = ReconstructRayFromCoord3D(coord3D);\n    \n    return texture(cube, rayDir);\n}\n\nvec4 SampleVolumeLinear(samplerCube cube, vec3 uv3D)\n{\n    uv3D = (uv3D - 0.5) * (1.0 - (1.0 / VOLUME_RESOLUTION)) + 0.5;\n    vec3 coord3D = (uv3D * VOLUME_RESOLUTION);\n    float lerpZ = fract(coord3D.z);\n    coord3D.z = floor(coord3D.z);\n    vec4 v0 = texture(cube, ReconstructRayFromCoord3D(coord3D));    \n    vec4 v1 = texture(cube, ReconstructRayFromCoord3D(coord3D + vec3(0.0, 0.0, 1.0)));\n    return mix(v0, v1, lerpZ);\n}\n\n// ------------------------------ UTILITIES ------------------------------\n\nvec3 GammaToLinear(vec3 gammaColor)\n{\n    return pow(gammaColor, vec3(2.2));\n}\n\nvec3 LinearToGamma(vec3 linearColor)\n{\n    return pow(linearColor, vec3(1.0 / 2.2));\n}\n\n#define PI 3.1419\n\nvec2 Hash22(vec2 uv)\n{\n    return fract(sin(mat2(13.486243, 18.378624, 9.376214, 11.786432) * uv) * 435.487221 * SEED);\n}\n\nvec3 Hash32(vec2 uv)\n{\n    return fract(sin(mat2x3(13.486243, 18.378624, 9.376214, 11.786432, 12.534534, 17.487323) * uv) * 436.487321 * SEED);\n}\n\nvec2 Noise22(vec2 uv)\n{\n    vec2 rootUV = floor(uv);\n    vec2 f = smoothstep(0.0, 1.0, uv - rootUV);\n    vec2 v00 = Hash22(rootUV + vec2(0.0, 0.0));    \n    vec2 v10 = Hash22(rootUV + vec2(1.0, 0.0));\n    vec2 v01 = Hash22(rootUV + vec2(0.0, 1.0));\n    vec2 v11 = Hash22(rootUV + vec2(1.0, 1.0));\n    \n    vec2 v0 = mix(v00, v01, f.y);\n    vec2 v1 = mix(v10, v11, f.y);\n    \n    return mix(v0, v1, f.x);\n}\n\nvec3 Noise32(vec2 uv)\n{\n    vec2 rootUV = floor(uv);\n    vec2 f = smoothstep(0.0, 1.0, uv - rootUV);\n    vec3 v00 = Hash32(rootUV + vec2(0.0, 0.0));    \n    vec3 v10 = Hash32(rootUV + vec2(1.0, 0.0));\n    vec3 v01 = Hash32(rootUV + vec2(0.0, 1.0));\n    vec3 v11 = Hash32(rootUV + vec2(1.0, 1.0));\n    \n    vec3 v0 = mix(v00, v01, f.y);\n    vec3 v1 = mix(v10, v11, f.y);\n    \n    return mix(v0, v1, f.x);\n}\n\nmat3 RotationMatrix(vec3 eulerAngles)\n{\n    vec3 s = sin(eulerAngles);\n    vec3 c = cos(eulerAngles);\n    return \n    mat3(c.y, 0.0, s.y, \n        0.0, 1.0, 0.0, \n        -s.y, 0.0, c.y) *\n    mat3(1.0, 0.0, 0.0, \n        0.0, c.x, s.x, \n        0.0, -s.x, c.x) *\n    mat3(c.z, s.z, 0.0, \n        -s.z, c.z, 0.0, \n        0.0, 0.0, 1.0);\n}\n\nfloat SDFSegment(in vec2 position, in vec2 end1, in vec2 end2) {\n\tvec2 ba = end2 - end1;\n\tvec2 pa = position - end1;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\n\nfloat SDFCircle(in vec2 position, in vec2 center, float radius)\n{\n    return distance(position, center) - radius;\n}\n\nfloat SDFTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvec2 GetCellCenter(vec2 cellID, float grassThickness)\n{\n    grassThickness += 0.05;\n    return cellID + Hash22(mod(cellID, GRASS_BLADES_COUNT)) * (1.0 - grassThickness * 2.0) + grassThickness;\n}\n\nfloat GetCellSDF(vec2 cellID, vec2 uv)\n{\n    float thickness = mix(GRASS_THICKNESS_MIN, GRASS_THICKNESS_MAX, Hash22(mod(cellID, GRASS_BLADES_COUNT)).r);\n    vec2 cellCenter = GetCellCenter(cellID, thickness);\n    vec2 cellUV = uv - cellCenter;\n    float dist;\n#ifdef FLAT_SHAPE\n    float angle = Hash22(mod(cellID, GRASS_BLADES_COUNT)).r * 6.28;\n    float s = sin(angle);\n    float c = cos(angle);\n    vec2 bladeNormal = mat2(c, s, -s, c) * vec2(1.0, 0.0);\n    dist = SDFSegment(cellUV, bladeNormal * thickness, -bladeNormal * thickness) - 0.02;\n#elif defined(TRIANGLE_SHAPE)\n    thickness *= 3.0;\n    vec2 v1 = (Hash22(mod(cellID, GRASS_BLADES_COUNT) + 0.243) - 0.5) * thickness;\n    vec2 v2 = (Hash22(mod(cellID, GRASS_BLADES_COUNT) + 1.223) - 0.5) * thickness;\n    vec2 v3 = (Hash22(mod(cellID, GRASS_BLADES_COUNT) + 3.345) - 0.5) * thickness;\n    dist = SDFTriangle(uv, cellCenter + v1, cellCenter + v2, cellCenter + v3) - 0.02;\n#elif defined(CIRCLE_SHAPE)\n    dist = SDFCircle(uv, cellCenter, thickness);\n#endif\n    return dist;\n}\n\n// 1 dot for 1 square unit\nfloat VoronoiSDF(vec2 uv, float tileSize, inout float bladeID)\n{\n    vec2 rootCellID = floor(uv);\n    vec2 cellUV = fract(uv);\n    float closestDistance = 10.0;\n    \n    for (float y = -1.0; y <= 1.0; y++)\n    {\n        for (float x = -1.0; x <= 1.0; x++)\n        {\n            vec2 cellID = rootCellID + vec2(x, y);\n            float dist = GetCellSDF(cellID, uv);\n            if (dist < closestDistance)\n            {\n                closestDistance = dist;\n                bladeID = Hash22(mod(cellID, tileSize)).r;\n            }\n        }\n    }\n    \n    return closestDistance;\n}\n\n#define GOLDEN_ANGLE 2.39996322972\n\n","name":"Common","description":"","type":"common"}]}