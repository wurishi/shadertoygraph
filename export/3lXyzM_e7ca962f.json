{"ver":"0.1","info":{"id":"3lXyzM","date":"1591627909","viewed":186,"name":"Worley Bulb","username":"kesson","description":"3D Worley Noise and raymarching, learning GLSL.\n\nSources:\nhttps://www.youtube.com/watch?v=PGtv-dBi2wE for the Ray Marching tutorial\nhttps://www.youtube.com/watch?v=4066MndcyCk for the Worley Noise tutorial","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","voronoi","noise","worley"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Raymarching and Worley Noise\n * Made while learning some GLSL techniques\n *\n * Thanks to https://www.youtube.com/watch?v=PGtv-dBi2wE for the Ray Marching tutorial\n * Thanks to https://www.youtube.com/watch?v=4066MndcyCk for the Worley Noise tutorial\n *\n */\n\n#define RAYMARCH_MAX_STEPS \t\t100\n#define RAYMARCH_MAX_DIST \t\t50.0\n#define RAYMARCH_SURFACE_DIST \t0.01\n\n// From https://www.youtube.com/watch?v=l-07BXzNdPw\nvec3 randomVector(vec3 p) {\n\tvec3 a = fract(p.xyz*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    vec3 v = fract(vec3(a.x*a.y, a.y*a.z, a.z*a.x));\n    return v;\n}\n\nvec2 worley(vec3 uv, float t, float factor) {\n    vec3 st = uv * factor;\n    vec2 minDist = vec2(1000.0);\n \tvec3 gv = fract(st)-0.5;\n    vec3 id = floor(st);\n\n    for (float z = -1.0; z <= 1.0; z++) {\n        \n        for (float y = -1.0; y <= 1.0; y++) {\n\n            for (float x = -1.0; x <= 1.0; x++) {\n\n                vec3 offs = vec3(x, y, z);\n\n                vec3 n = randomVector(id + offs);\n                vec3 p = offs + sin(n * t) * .5;\n                p -= gv;\n\n                float d = length(p);\n\n                if (d < minDist.x) {\n                    minDist.y = minDist.x;\n                    minDist.x = d;\n                } else if (d < minDist.y) {\n                    minDist.y = d;\n                }\n\n            }\n        }\n        \n    }\n    \n    return minDist;\n}\n\nfloat getDist(vec3 p, float wr) {\n\tvec4 sphere = vec4(0.0, 1.0, 0.0, 1.0 + wr);\n    \n    float sphereDist = length(p - sphere.xyz) - sphere.w;\n    float planeDist = (p.y+0.75) - wr;\n    \n    return min(sphereDist, planeDist);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO = 0.0;\n    \n    for (int i = 0; i < RAYMARCH_MAX_STEPS; i++) {\n\t\tvec3 p = ro + rd * dO;\n        vec2 worleyF = worley(p, iTime, 2.0);\n        float dS = getDist(p, (worleyF.y - worleyF.x)*0.2);\n        dO += dS;\n        if (dO > RAYMARCH_MAX_DIST || dS < RAYMARCH_SURFACE_DIST) break;\n    }\n    \n    vec3 d = ro + rd * dO;\n        \n    return dO;\n}\n\nvec3 getNormal(vec3 p, float wr) {\n\tfloat d = getDist(p, wr);\n    vec2 e = vec2(0.01, 0.0);\n    \n    vec3 n = d - vec3(\n        getDist(p - e.xyy, wr),\n        getDist(p - e.yxy, wr),\n        getDist(p - e.yyx, wr));\n    \n    return normalize(n);\n}\n\nfloat getLight(vec3 p) {\n    float an = iTime*0.1;\n    vec3 lightPos = vec3(sin(an) * 4.0, 4.0, cos(an) * 4.0);\n    vec3 l = normalize(lightPos - p);\n    vec2 worleyF = worley(p, iTime, 2.0);\n    vec3 n = getNormal(p, (worleyF.y-worleyF.x));\n    \n    float dif = dot(n, l);\n    \n    float d = rayMarch(p + RAYMARCH_SURFACE_DIST * 120.0, l);\n    if (d < length(lightPos-p)) dif *= 0.25;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float an = iTime * 0.1;\n    // Camera matrix and movement from https://www.shadertoy.com/view/ldl3Dl\n    vec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );//vec3(0.0, 1.0, 0.0);\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( uv.x*uu + uv.y*vv + 1.5*ww );//normalize(vec3(uv.x, uv.y, 1.0));\n    \n    float d = rayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    vec2 worleyF = worley(p, iTime, 2.0);\n    \n    float dif = clamp(getLight(p), 0.0, 1.0);\n    \n    float distort = worleyF.y - worleyF.x;\n    vec3 col = vec3(dif) * distort;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}