{"ver":"0.1","info":{"id":"3sXGRB","date":"1546594456","viewed":170,"name":"Scriptkiddying guil","username":"JoshScholar","description":"I combined two of guil's fractal scripts, one for a marble one for a 3d mandelbrot.  Looks cool when it comes up close","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["randommath"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n//Try different values for MaxIter from 1 all the way up\nconst int MaxIter = 6;\n\n//Uncomment this to make this a solid ball\n//#define NO_HOLES\n\nfloat preci;\nfloat zoom;\n\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\nvec3 dmul( vec3 a, vec3 b )  {\n    float r = length(a);\n    \n    b.xy=cmul(normalize(a.xy), b.xy);\n    b.yz=cmul(normalize(a.yz), b.yz);\n    b.xz=cmul(normalize(a.xz), b.xz);\n    \n    return r*b;\n}\n\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\n\nvec4 omap( vec3 p)\n{\n\tfloat dr = 1.0;\n\tvec3 ot = vec3(1000.0);\n        float ot1=1.;\n\tfloat r2;\n\n        vec3 c= p;\n\tfor( int i=0; i<MaxIter;i++ )\n\t{            \n            r2 = dot(p,p);\n            if(r2>16.)continue;\n\t\t\n            ot = min( ot, abs(p) );\n            ot1=min(ot1,r2);\n            dr=2.*sqrt(r2)*dr+1.0;\n            p=dmul(p,p)+c;\t\t\t\t\t\t\n\t}\t\n\tfloat d =.5*length(p)*log(length(p))/dr;\t\n        return vec4(ot/(.3+ot1),d);\t\n}\n\nvec4 map(in vec3 p) {\n\t\n\tfloat res = 0.;\n\t//p=.125*.125*p;\n    vec3 c = p;\n\tfor (int i = 0; i < MaxIter; ++i) {\n        p =.7*abs(p)/dot(p,p) -.7;\n        p.yz= csqr(p.yz);\n        p=p.zxy;\n        res += exp(-19. * abs(dot(p,c)));\n        \n\t}\n    float d =.5*length(p)*log(length(p))/res;\n#ifdef NO_HOLES\n    return  vec4(res*.6*normalize(p),-abs(d));\n#else\n    return  vec4(res*.6*normalize(p),d);\n#endif    \n}\n\nvec4 raymarch( in vec3 ro, in vec3 rd , in vec2 tminmax )\n{\n\tvec4 col = vec4(0, 0, 0, 0);\n\n\tfloat t = tminmax.x;\n        float dt = 1.;\n\tfor(int i=0; i<128; i++)\n\t{\n\t\t\n        if( t>tminmax.y || dt<=preci*t ) continue;\n\t\tvec3 pos = ro + t*rd;\t\t\n\t\tcol = map( pos );\n\t\tdt = col.a;\t\t\n                t += dt;                        \t\t\n\t}\n        col =clamp( col, 0.0, 1.0 );\n\tcol.a = min(0.002/col.a,1.);\n\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    float an = 2.0 + 0.2*iTime - mo.x;\n    \n    preci = .3/min(iResolution.x,iResolution.y);\n\tzoom = 2.*(1.+.4*sin(.1*iTime));\n\n    vec3 ro = zoom*3.0*vec3(cos(an), 0.5*cos(2.*an), sin(an));\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize( cross( vec3(0.0,1.0,0.0), ww ) );\n    vec3 vv = normalize( cross(ww,uu) );\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n    vec3 col = vec3(0.08,0.09,0.18);\n    vec2 seg = iSphere( ro, rd, vec4(0.0,0.0,0.0,2.0) );\n\tif( seg.x<0.0 )seg.x=0.;\n    if( seg.y>0.0 )\n\t\t{\n        \tvec4 res = raymarch( ro, rd, seg );\n            vec3 col1 =.5*(res.xyz+res.yxz);\n            col1.r+=.5*col1.g-.3*col1.b;            \n\t    \tcol = mix( col, col1, res.a );\n\t\t}\n\t\n\tcol = pow( col, vec3(0.4) ) * 1.2;\n\n\tcol *= sqrt( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y) );\n\t    \n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}