{"ver":"0.1","info":{"id":"MlcyzN","date":"1531771546","viewed":94,"name":"Capsule waves","username":"toocanzs","description":"One of my first raymarching shaders I had unlisted for a while. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.0001\nconst float radius = 0.25;\nconst float height = 2.;\nconst float scale = 0.5;\n\nvec3 noiseRGB( in vec2 p) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tf = f*f*(3.0-2.0*f);\n    vec4 col = textureLod(iChannel0, (i+f+vec2(0.5))/64.0, 0.0);\n    return col.rgb;\n}\n\nfloat noise( in vec2 p) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tf = f*f*(3.0-2.0*f);\n    vec4 col = textureLod(iChannel0, (i+f+vec2(0.5))/64.0, 0.0);\n    return col.x*2.0 -1.0;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat getHeight(vec2 id)\n{\n    return noise(id*0.2 + vec2(iTime,iTime)*0.6);\n}\nfloat map(vec3 point)\n{\n    \n    point = point*2.0 - 1.0;\n    vec2 id = floor(point.xz/scale)-(scale/2.);\n    float nHeight = height + getHeight(id);\n    point.xz = mod(point.xz,scale)-(scale/2.);\n    \n    \n    float capsule = sdCapsule(point, vec3(0,nHeight,0), vec3(0,-nHeight,0), radius);\n    return capsule;\n}\n\nbool trace(vec3 origin, vec3 ray, out float d)\n{\n    float t = 0.0;\n    \n    for(int i = 0; i < 256; i++)\n    {\n        vec3 samplePoint = origin + ray*t;\n        float dist = map(samplePoint);\n        t += dist*0.1;\n        d = t;\n        if(dist < EPSILON)\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 getNormal(vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nconst vec3 lightDir = normalize(vec3(2,2,-2));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    float ang = cos(iTime*0.4) + sin(sin(iTime*1.2));\n    mat3 rotation = mat3(cos(ang),0,sin(ang),\n                        0,1,0,\n                        -sin(ang),0,cos(ang));\n    \n    vec3 ray = normalize(vec3(uv, 1.0)) * rotation;\n        \n        \n    vec3 origin = vec3(0,2.0,iTime);\n    \n    float dist;\n    float mapDist;\n    bool traced = trace(origin, ray, dist);\n    vec3 hitPos = origin + ray*dist;\n    vec3 normal = getNormal(hitPos);\n    \n    float shadowDist;\n    vec3 shadowRay = lightDir;\n    bool shadow = trace(hitPos+ normal*0.1, shadowRay, shadowDist);\n    \n    float fog = 1.0 / (1.0 + dist*dist * 0.1);\n    vec3 fogColor = vec3(0.7,0.6,0.4);\n    vec3 point = (origin + ray*dist)*2.0 - 1.0;\n    vec2 id = floor(point.xz/scale)-(scale/2.);\n    vec3 diffuseColor = noiseRGB(id);\n    \n    \n    float nDotL = clamp(dot(normal, lightDir),0.,1.);\n    vec3 ambientCol = vec3(0.1);\n    vec3 diffuse = mix(ambientCol, diffuseColor, nDotL* float(!shadow));\n    fogColor = mix(fogColor, vec3(1), pow(clamp(dot(ray, lightDir),0.,1.),10.));\n    vec3 col = mix(fogColor, diffuse,fog);\n   \n    \n    //col = vec3(shadow);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}