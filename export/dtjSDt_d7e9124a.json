{"ver":"0.1","info":{"id":"dtjSDt","date":"1676823199","viewed":127,"name":"Pixel strips","username":"kig","description":"Trying to come up with an effect to make low-res images look more interesting on high-res screens.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["fx","pixels"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// pixelization fx experiment\n\nvec4 warpedMirrors(in vec2 uv) {\n    // Transform the UV to create a distorted pixel grid\n    vec2 tuv = uv;\n    tuv.x += 0.1 * cos(iTime*0.3)*(uv.y*4.0) + 0.2 * sin(iTime*0.4+uv.x*4.0);\n    tuv.y += sin(0.2*iTime) * tuv.x * tuv.x;\n    tuv *= vec2(16.0*(2.0+1.5*cos(0.4*iTime)), 32.0)*(2.0+1.5*sin(0.5*iTime));\n    // Take the in-pixel coordinate.\n    vec2 fuv = fract(tuv);\n    // Invert the transform to find the bottom-left untransformed UV coord\n    // to fill the distorted pixel with the color its bottom-left corner lands on.\n    // This is buggy here.\n    vec2 iuv = floor(tuv);\n    iuv /= vec2(16.0*(2.0+1.5*cos(0.4*iTime)), 32.0)*(2.0+1.5*sin(0.5*iTime));\n    iuv.y -= sin(0.2*iTime) * iuv.x * iuv.x;\n    iuv.x -= 0.1 * cos(iTime*0.3)*(uv.y*4.0) + 0.2 * sin(iTime*0.4+uv.x*4.0);\n    vec4 col = texelFetch(iChannel0, clamp(ivec2(512.0*iuv), ivec2(0), ivec2(511)), 0);\n    // Darken the pixel border to create a more graphic look.\n    if (fuv.x > 0.8+0.2*abs(sin(cos(0.3*iTime)*4.0*uv.x)) || fuv.y > 0.6+0.2*sin(cos(1.0*iTime)+4.0*uv.x)) {\n        col.rgb = 0.25 * col.rgb;\n    }\n    return col;\n}\n\nvec4 pixelStrips(in vec2 uv) {\n    // Transform the UV to create a distorted pixel grid\n    vec2 tuv = uv;\n    tuv.y += sin(0.5*iTime) * tuv.x * tuv.x;\n    tuv *= vec2(32.0*4.0*cos(0.8*iTime), 64.0)*2.0*sin(iTime);\n    // Take the in-pixel coordinate.\n    vec2 fuv = fract(tuv);\n    // Invert the transform to find the bottom-left untransformed UV coord\n    // to fill the distorted pixel with the color its bottom-left corner lands on.\n    vec2 iuv = floor(tuv);\n    iuv /= vec2(32.0*4.0*cos(0.8*iTime), 64.0)*2.0*sin(iTime);\n    iuv.y -= sin(0.5*iTime) * iuv.x * iuv.x;\n    vec4 col = texelFetch(iChannel0, clamp(ivec2(512.0*iuv), ivec2(0), ivec2(511)), 0); //0.5 + 0.5*cos(iTime+ff.xyx+vec3(0,2,3));\n    // Darken the pixel border to create a more graphic look.\n    if (fuv.x > -0.1+0.0*abs(sin(4.0*uv.x)) && fuv.x < 1.0 && fuv.y > 0.2+0.5*uv.x && fuv.y < 1.0) {\n        col.rgb = 0.5 * col.rgb;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = pixelStrips(uv);\n}","name":"Image","description":"","type":"image"}]}