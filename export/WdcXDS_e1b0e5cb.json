{"ver":"0.1","info":{"id":"WdcXDS","date":"1572729888","viewed":428,"name":"Spawn","username":"dyla","description":"After reading some papers about Perlin and curl noise, I had to make my first experiments on them immediately. :)","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["noise","perlin","curl","particles","chaos","spawn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define RES min(iResolution.x, iResolution.y)\n#define ASP (max(iResolution.x, iResolution.y)/min(iResolution.x, iResolution.y))\n#define WIDE (iResolution.x >= iResolution.y)\n#define PX (1.0/RES)\n\n#define CNT 100\n#define CURL_OCTAVES 7.0\n#define AGING_ADD vec4(0.0, 0.0, 0.0, 1.0)\n#define AGING_MUL vec4(1.0, 1.0, 0.99, 1.0)\n\nfloat avg3(vec4 v) {\n    return (v.r+v.g+v.b)/3.0;\n}\n\n#define gridWidth 1.0\nvec4 smoothFetch(sampler2D channel, vec2 uv) {\n    vec2 cres = vec2(textureSize(channel, 0));\n    vec2 tpos = uv*cres + 0.5;\n    vec2 rtpos = floor(tpos);\n\n    vec4 col = vec4(0.0);\n    float w = 0.0;\n    for (float x=-gridWidth; x<=gridWidth; x+=1.0) {\n        for (float y=-gridWidth; y<=gridWidth; y+=1.0) {\n            vec2 spos = rtpos+vec2(x,y);\n            float d = max(1.4-length(spos-tpos+0.5), 0.0);\n            w+=d;\n            col += texelFetch(channel, ivec2(mod(spos,cres)), 0) * d;\n        }\n    }\n    return (col/w);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"bool isReadyToInitialize() {\n   return texelFetch(iChannel2, ivec2(0,0), 0).x > 0.1;\n}\n\nvec4 rnd(vec2 p, float f) {\n    float ff = 1.0*sin(f*1269.3)*3.1415 + iTime*f*0.33;\n    float sf = sin(ff);\n    float cf = cos(ff);\n    mat2 rot = mat2(cf,sf, -sf,cf);\n    vec2 uv = rot*p*f;\n    \n    vec2 cres = vec2(textureSize(iChannel0, 0));\n    vec2 tpos = uv*cres + 0.5;\n    vec2 rtpos = floor(tpos);\n\n    return smoothFetch(iChannel0, uv);\n}\n\nvec4 perlin(vec2 uv, float octaves) {\n    vec4 v = vec4(0.0);\n    float f = 0.05;\n    float m = 1.0;\n    for (float i=0.0; i<octaves; i+=1.0) {\n        v += (rnd(uv, f)-0.5)*m * (i<octaves-1.0 ? 1.0 : fract(octaves));\n        f *= 1.635;\n        m *= 0.34;\n    }\n    return v;\n}\n\n#define EPS 0.0001\nvec2 curl(vec2 uv, float octaves) {\n    vec2 eps = vec2(EPS,0.0);\n    return vec2(\n         (avg3(perlin(uv-eps.yx, octaves)) - avg3(perlin(uv+eps.yx, octaves))),\n        -(avg3(perlin(uv-eps.xy, octaves)) - avg3(perlin(uv+eps.xy, octaves)))\n    )/(2.0*EPS);\n}\n\nvec4 getVelocity(vec2 position)\n{\n    return 0.002*normalize(vec4(curl(position, CURL_OCTAVES), 0.0, 0.0));\n}\n\nvec4 initializeState(int i) {\n    vec2 uv = vec2(float(i)/iResolution.x, 0.0);\n    vec4 val = texture(iChannel0, uv+iTime*0.2);\n    return vec4(val.xyz*vec3(WIDE?ASP:1.0, WIDE?1.0:ASP, 2.6), 0.0);\n}\n\nvec4 updateState(int i) {\n    vec4 currentPos = texelFetch(iChannel1, ivec2(i,0), 0);\n    vec4 velocity = getVelocity(currentPos.xy);\n    vec4 state = (currentPos + velocity)*AGING_MUL + AGING_ADD;\n    if (state.z<0.0125) {\n        state = initializeState(i);\n    }\n    return state;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (fragCoord.y<1.0){\n        if (isReadyToInitialize()) {\n        \tfragColor = initializeState(int(fragCoord.x));\n        } else {\n            fragColor = updateState(int(fragCoord.x));\n        }\n    } else {\n        discard;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec4 getState(int i) {\n\treturn texelFetch(iChannel0, ivec2(i,0), 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/RES;\n    \n    fragColor =  mix(texelFetch(iChannel1, ivec2(fragCoord), 0), vec4(0.5, 0.75, 1.0, 1.0), 0.25);\n    \n    for (int i=0; i<CNT; i++) {\n        vec4 state =  getState(i);\n        float d = length(uv-state.xy);\n        float r = min(state.w*0.0001,  RES/350.0*PX*2.5);\n        if (d<r) {\n            fragColor -= (1.0-smoothstep(r-RES/350.0*2.5*PX, r, d))*smoothstep(0.0, 0.25, state.z);\n        }\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Reading any value greater than 0.001 from this buffer indicates loading random texture is \"just ready\".\n// This is indeed an ugly workaround, but it just works :)\n//\n// Before adding this, I had to wait and restart the shader after noise texture finished loading - \n// othewise particle updates did not start on my mobile.\n// I have no clue why it happens, I've never faced such a problem on desktop.\n//\n// Should rely on procedural perlin noise :)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 ofc = texelFetch(iChannel1, ivec2(0,0), 0);\n    vec4 nfc = texelFetch(iChannel0, ivec2(0,0), 0);\n    \n    if (nfc.x==0.0) {\n        fragColor = vec4(0.0);\n    }\n    else if (ofc.x==0.0 && nfc.x>0.0) { \n        fragColor = vec4(1.0);\n    } else if (ofc.x>0.001) {\n        fragColor = vec4(max(ofc.x*0.5, 0.001));\n    } else {\n        discard;\n    }   \n}","name":"Buffer C","description":"","type":"buffer"}]}