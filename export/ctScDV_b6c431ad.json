{"ver":"0.1","info":{"id":"ctScDV","date":"1692356376","viewed":78,"name":"My Final Fire 2023","username":"DG622","description":"my attempt at fire. So the Raymarched spheres shape is deformed independently from the colour of the fire. Both using the FBM, the inside of the cauldron is animated to add to the effect.\nArt of Code, Indigo Quilez, and xbe are some of my sources,","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarchperlinnoisecurlnoiseflame"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"highp\n\n#define RoomWidth 8.0\n#define RoomDepth 16.0\n#define FAR 60.0\n#define zPos -7.0\n#define xPos 0.0\n#define yPos 4.5\n#define radius 3.0\n#define u_time iTime\n//based on the book of shaders, the art of code as well, \n//article by Inigo Quiles domain warping\n//january 2021. DG updated 2023\n\n//the flame\nfloat randNo (vec2 p){\n \tp = fract(p* vec2( 173.69, 373.47));\n    p+=dot(p, p + 25.397);\n    return fract(p.x*p.y);\n}\n\nvec3 flameDrift (vec3 p){\n       //NB after 800 second the effect has a more vertical separation spoiling it\n         p.y-= u_time * 3.357 ;//0.675) *0.10;//flame moves upwards\n       \n         return p;\n}\nfloat noiseFunction (vec2 uv){// this is essentiually a mixing function /tiling\n       \n    vec2 tileuv = fract(uv);//these 2 go together fract giving the fraction and floor the integer of the cells\n    vec2 tileid = floor(uv);  \n   tileuv = tileuv * tileuv *(3.0 - 2.0 *tileuv);//interpolation for dummies video but this is essentially a smoothstep\n    \t\t\t\t\t\t\t//smoothstep ( 0.0, 1.0, fract(uv * 10)),    \n    float botL = fract(randNo(tileid));//bottom left// fract here to remove the horizontal and vertical plane edges\n    float botR = randNo(tileid + vec2(1, 0));//bottom right\n    float bot = mix( botL, botR, tileuv.x);//so mix them to get the bottom line using the local uv.x              \n    \n    float topL = randNo(tileid + vec2(0, 1));//top left etc\n    float topR = randNo(tileid + vec2(1, 1));\n    float top = mix( topL, topR, tileuv.x);\n    //tileuv = fract(tileuv);\n   // tileuv.y = tileuv.y * tileuv.y *(3.0 - 2.0 *tileuv.y);\n    \n    return mix(bot, top, tileuv.y);    \n}\n\n// the values 8, 2, 0.5, 0.25, 4.0 seems to offer best set gainst the horizontal lines problem\nfloat fractBrownian(vec2 p){//wave = sin(n*frequency) * amplitude\n    p = flameDrift(vec3(p, 1.0)).xy;\n   // p.xy-=iTime *0.675;//flame moves upwards\n    float octaves =2.0;//the number of iterations\n    float freq = 2.0;//value over 1\n    float amp = 0.5;// valuse under 1\n    float gain = 0.25;//the incremental reduction in amplitude. this is also most pipulat mnuber\n    float lacunity = 4.0;//the coresponding incremental increase in frequency\n    float retVal;\n    //the loop\n    for(float i = 0.0; i < octaves; i++){\n            retVal += noiseFunction(p* freq) * amp;\n            freq*= lacunity;\n            amp *=gain;            \n    }     \n    return retVal/2.0;\n}\n\n\nvec2 N22(vec2 p){\n    vec3 a = fract(p.xyx*vec3(123.34,234.34,145.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n  vec2 curlNoise(vec2 uv){//acts a bit like a DuDv map\n    float delta = 0.1;\n    vec2 curlVec;\n    float Nx1 = fractBrownian(vec2(uv.x - delta, uv.y));\n    float Nx2 = fractBrownian(vec2(uv.x + delta, uv.y));\n    float Ny1 = fractBrownian(vec2(uv.x, uv.y - delta));\n    float Ny2 = fractBrownian(vec2(uv.x, uv.y + delta));\n    float slopeX = (Nx2 - Nx1) /0.2;\n    float slopeY = (Ny2 - Ny1)/ 0.2;\n    return vec2(slopeY, - slopeX);\n    } \n     \n\n\n float voronoi (vec2 uv, float t, float numb){\n    ///  t*=0.5;\n        float minDist = 50.0;  \n        uv*= numb;\t\t\t\t// higher the number the more cells       \n        vec2 guv = fract(uv)-0.1 ;//- 0.1;\n        vec2 id = floor(uv);\n     \n        for(float y= - 1.; y<=1.; y++){\n        \tfor(float x= - 1.; x<=1.; x++){\n                vec2 offs = vec2( x, y);//ie the id\n                vec2 n = N22(id+offs);// id is the middle of each box and so in the line below needs to be added               \n                vec2 p = offs+ sin(n*t)* 0.4;//the .5 takes away the distortion mif not added        \t\t\n                float d = length (guv - p);\n                \n                if(d<minDist){\n                 minDist = d;  \n                }        \n            }\n            }        \nreturn minDist;\n    }\n    float sdSphere (vec4 dim, vec3 p){\n\t\t\tfloat retValue = length(p - dim.xyz)-dim.w;\n\t\t\treturn retValue;\n\t\t\t\t}\n\n                   \nvec3 GetRoom(vec3 p, bool flag2){\n       vec2 room;\n       vec3 dF = vec3(0.0);\n       float ht = 0.0; \n       float htback= 0.0;\n      if(flag2){//so only calculate the height map when running the lighting\n        ht = texture(iChannel0, p.yz*0.05).r;\n        ht*=0.25;\n        htback = texture(iChannel0, p.xy*0.05).r;\n        htback*=0.5;\n       }\n       float Floor = dot(vec3(p.x ,p.y   ,p.z), normalize(vec3 (0.0,1.0,0.0))); //looks better without this height adjustment     \n  \n       //frontwall    \n       float FPlanevertF = dot(p-vec3(0.0,0.0 ,RoomDepth ), normalize(vec3 (0.0,0.0,-1.0))); \n         \n       //back wall\n       \n       float FPlanevertB = dot(vec3(p.x,p.y,p.z-htback)-vec3(0.0,0.0,-RoomDepth), normalize(vec3 (0.0,0.0,1.0))); \n        \n        //left wall         \n       float FPlaneleft = dot(vec3(p.x-ht,p.y,p.z)-vec3(-RoomWidth,0.0,0.0), normalize(vec3 (1.0,0.0,0.0))); \n              \n       //right wall            \n       float FPlaneright = dot(vec3(p.x-ht,p.y,p.z)-vec3(RoomWidth,0.0,0.0), normalize(vec3 (-1.0,0.0,0.0))); \n           \n      float Sidewall = min(FPlaneright,FPlaneleft);      \n      float Walls = min(FPlanevertF,FPlanevertB);\n      float AllWalls = min(Walls, Sidewall);\n      \n      if(Walls < Sidewall) dF.y = 2.0;      \n      if(Walls > Sidewall) dF.y = 1.0;\n                 \n     float MainFloor = 1.0;\n      MainFloor = min(AllWalls, Floor);\n                 \n      dF.x = MainFloor;\n      if(Floor < AllWalls) dF.y = 3.0;\n     //cauldron\n           float dSphere = sdSphere(vec4(xPos,yPos,zPos,radius),p);\n          float inside = sdSphere(vec4(xPos,yPos,zPos,radius- 0.1),p);\n           float dPlane = dot(vec3(p.x,p.y-5.4,p.z), normalize(vec3 (0.0,1.0,0.0)));//the vec 3 is the normal of the plane\n         \t\t\t\t\t\n           dSphere = abs(dSphere);// hollows it out the goblet so the fluid sphere shows                 \n           float d = max(dSphere, dPlane) - 0.1;//max gives intersection of a plane, the number: thickness\n\t\t    if(dF.x > d){ dF.y = 5.0; \n                          if(inside< dSphere) dF.z = 1.0;\n           }\n           dF.x = min(dF.x, d);\n          dF.x*=0.7;\n       return dF;//room;\n}\n\n\nvec3 GetDist (vec3 p, bool flag, bool flag2 ){  \n          vec3 st = p;    \n          vec3 dF = vec3(0.0);\n          float dSphere = 1.0;\n          float flamWidth = 0.257;\n          float flamBase = 0.45;\n          //flames    \n        if(flag){  \n        float mflame = sdSphere(vec4(xPos,yPos-flamBase,zPos,radius),vec3(st.x,st.y*flamWidth,st.z));                \n        return vec3(mflame);//*0.7;   \n        }else {     \n               dF= GetRoom(p, flag2);         \n               return dF;\n        }\n          \t\t\t\t\t\t\t               \n}\n\n\n   vec3 RayMarch(vec3 ro, vec3 rd, bool flag, bool flag2){\n           float u_time = iTime;\n           vec3 RetVal;\n           float dO = 0.0;\n           float res = 1.0;\n           float ph = 1e20;\n           vec3  dS;\n           float noise;\n           vec3 p;         \n           for(int i = 0; i < 100; i++){\n                 p = ro + dO * rd;\n                    dS = GetDist(p, flag, flag2);\n                    //add the distortion here, i supose this could be in GetDist\n                   if(flag)dS.x += fractBrownian(p.xy) * 4.0;                \n                   if(flag) dS.x +=voronoi(p.xy, u_time,0.35);\n              \n                    dO += dS.x;\n                if( dS.x < 0.01 || dO > 100.0){\n                    break;\n                    }\n                            \n             }                               \n             RetVal.y = dS.y;\n             RetVal.z = dS.z;              \n          \t RetVal.x = dO; \n             return RetVal;           \n       }\n\t\n\tvec3 GetNormal (vec3 p, bool flag, bool flag2){\n            vec2 e = vec2(0.01, 0.0);\n            float d = GetDist(p, flag, flag2).x;          \t          \n            vec3 n = d - vec3(GetDist(p-e.xyy, flag, flag2).x,GetDist(p-e.yxy, flag, flag2).x, GetDist(p-e.yyx, flag, flag2).x);           \n            n = normalize(n);\n            return n;           \n       }\n    \n            \n       float GetLight(vec3 p, vec3 lightpos, bool flag, bool flag2){ \n         \t//try out some flame flicker\n            lightpos.x+=sin(iTime*3.0)*0.15;\n            lightpos.y+=3.0;\n            lightpos.y+=lightpos.x*sin(iTime*5.0)*0.135 ;\n            lightpos.z-=lightpos.y*sin(iTime*7.0)*lightpos.x;   \n            vec3 light = normalize(lightpos - p );\n            vec3 n = GetNormal(p, flag, flag2);           \n            float dif = clamp(dot(n,light), 0.0, 1.0);// so no negative numbers, dif.y set to 0.0\n            //for the shadow\n          \n           vec3 d  = RayMarch(p + n, light, flag, flag2);//this add6ng the n  is a work around  \n       \n         //ie the walls and floor //derived from IQ soft shadow tutorial\n         if(!flag) if(d.x <length(lightpos - p)) dif= mix(dif, 0.1, smoothstep(0.775, 0.35, d.x/length(lightpos-p)));\n                                                               \n            return dif;\n        }\n        \n\t vec3  GetFlame(vec3 p, vec3 rd){\n     //xxxinddigo queliz domaain warping         \n          vec3 flame;  \n          vec2  uv = p.xy;\n          uv.x-=0.5;//these  move the X Y componeent the Z ismoved by the sphere it is cast on\n          uv.y-=3.9;\n          vec2 q = uv * 0.5;//enlarges it\n          vec2 qv = vec2( fractBrownian( uv + vec2(0.0,0.0) ),\n                          fractBrownian( q + vec2(2.2,1.3) ) );\n          vec2 r = vec2(  fractBrownian( uv + 4.0*qv + vec2(1.7,9.2) ),\n                          fractBrownian( q + 4.0*qv + vec2(1.3,2.8) ) );\n          float n = fractBrownian( q + 4.0*r );\n          \n          float ylimits = 0.05;//if over 0.3 and more then black area narrows vertically     \n          float brightness =2.8;//higher number more yellow than orange\n      //Fire Flame shader snippet by xbe much altered      \n         float c = 1.0 - n;\n         float c1 = n * c * (brightness-pow(ylimits*uv.y,2.0));\n         c1=clamp(c1,0.,1.1);//brightness 0 to 1\n         flame = vec3(2.5*c1, 3.957*c1*c1*c1, 1.7*c1*c1*c1*c1*c1*c1);  //the colour\n         return flame;\n     }\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n     vec2 uv = (fragCoord/iResolution.xy)*2.0-1.0;   \n   \n     vec3 col = vec3(0.0);  \n     float posx;\n     float posz;\n     vec3 lookAt;\n     float angle;\n    // vec4 flame;\n     vec3 lightPos = vec3(5.0,18.0,20.0);\n    vec3 flame = vec3(0.48, 0.1545, 0.0533);\n    vec3 yellow = vec3(0.4596, 0.3570, 0.09); \n     \n    //simple camera care of Art of Code/BigWing\n    posx = xPos;\n    posz = zPos + 14.0;\n    vec3 ro = vec3(posx, 9.0, posz);          \n    lookAt = vec3 (posx, 11.5, zPos - 3.0);\n   \n    //detailed camera\n          //  lookAt.xz *= Rot(-1.0);  //-90\n    float zoom = 1.0;    \n    vec3 f = normalize(lookAt - ro);//forward vector\n    vec3 r = cross(vec3(0.0,1.0,0.0), f);//right vector\n    vec3 u = cross(f, r);//up vector\n    vec3 c = ro + f * zoom;//centre of screen\n    vec3 i = c + uv.x*r + uv.y*u;//intersection point\n    vec3 rd = i - ro;//all above to get the ray direction   \n       \n     vec3 RetVal = RayMarch(ro,rd, false, false);\t     \n     float dist = RetVal.x;    \n     vec3 p= ro+rd*dist; \n     vec3 flamelight = mix(flame,yellow,smoothstep(8.1,22.5,p.y));\n    \n     //apply textures\n           if        (RetVal.y == 3.0){  //floor \n                                   col= texture(iChannel1, p.xz*0.1).rgb; \n                                 \n                                   col*=GetLight(p,vec3(xPos,yPos,zPos),false, true)*1.4+flamelight;//floor too dark without modifyer\n           }else if  (RetVal.y == 2.0){ //back wall  \n                                   col= texture(iChannel0, p.xy*0.05).rgb;                                  \n                                   col*=GetLight(p,vec3(xPos,yPos,zPos),false, true)+flamelight;\n           }else if (RetVal.y == 1.0) { //side walls  \n                                   col= texture(iChannel0, p.yz*0.05).rgb;\n                                   col*=GetLight(p,vec3(xPos,yPos,zPos),false, true)+flamelight;\n           \n           }else if (RetVal.y == 5.0){col= texture(iChannel2, p.xy * 0.025).rgb;//the cauldron\n                                  col*=GetLight(p,vec3(xPos,yPos,zPos),false, true)*5.0 + flamelight;\n          }\n         if(RetVal.z == 1.0) {col= texture(iChannel3, p.xy * 0.025 ).rgb;\n                                col*=max(0.35,abs(sin(iTime*2.0)))+flamelight;         \n        }\n        //Raymarch again for the flame\n        vec3 secPass = RayMarch(ro,rd,true, false);\n        p = ro + rd * secPass.x;             \n        vec3 theFlame = GetFlame(p, rd);     \n        col = mix(col, theFlame,smoothstep(zPos-radius, zPos+radius+3.4,p.z));//1.5\n            \n    fragColor = vec4(col,1.0);\n  \n}","name":"Image","description":"","type":"image"}]}