{"ver":"0.1","info":{"id":"4stczB","date":"1519404606","viewed":258,"name":"Symbol of Chaos (GGX version)","username":"lsdlive","description":"Using a previous shader I did to experiment with new rendering method.\nHere, I tried GGX & bump mapping, mainly following this reference: https://learnopengl.com/PBR/Theory\nBump mapping is from shane.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","bumpmapping","ggx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// GGX/Bump-mapping version of a previous shader:\n// https://www.shadertoy.com/view/XdccD4\n\n\n#define PI 3.14159\n#define TWO_PI 2.*PI\n\n\n// GGX copied from here: http://filmicworlds.com/blog/optimizing-ggx-shaders-with-dotlh/\n// This is not the optimized one, this is the one describe here:\n// http://blog.selfshadow.com/publications/s2013-shading-course/hoffman/s2013_pbs_physics_math_notes.pdf\n// Also explained: https://www.youtube.com/watch?v=j-A0mwsJRmk\n// Notice there is multiple options: http://graphicrants.blogspot.fr/2013/08/specular-brdf-reference.html\n// You can also get additionnal practical information here: https://learnopengl.com/PBR/Theory\n\nfloat G1V(float dotNV, float k) {\n\treturn 1. / (dotNV * (1. - k) + k);\n}\n\nfloat ggx(vec3 n, vec3 v, vec3 l, float roughness, float f0) {\n\tfloat alpha = roughness * roughness;\n\n\tvec3 h = normalize(v + l);\n\n\tfloat dotNL = clamp(dot(n, l), 0., 1.);\n\tfloat dotNV = clamp(dot(n, v), 0., 1.);\n\tfloat dotNH = clamp(dot(n, h), 0., 1.);\n\tfloat dotLH = clamp(dot(l, h), 0., 1.);\n\n\tfloat F, D, vis;\n\n\t// D\n\tfloat alphaSqr = alpha * alpha;\n\tfloat denom = dotNH * dotNH * (alphaSqr - 1.) + 1.;\n\tD = alphaSqr / (PI * denom * denom);\n\n\t// F\n\tfloat dotLH5 = pow(1. - dotLH, 5.);\n\tF = f0 + (1. - f0) * dotLH5;\n\n\t// V\n\tfloat k = alpha / 2.; // filmic\n    //float a = alpha + 1.;\n    //float k = (a*a) / 8.;// learnopengl\n\tvis = G1V(dotNL, k) * G1V(dotNV, k);\n\n    return D * F * vis;// * dotNL // later in the code\n\t//return D * F * vis / 4.;// learnopengl\n}\n\n\n// mercury/iq functions\nvoid amod(inout vec2 p, float c) {\n\tfloat m = TWO_PI / c;\n\tfloat a = mod(atan(p.x, p.y) - m*.5, m) - m*.5;\n\tp = vec2(cos(a), sin(a)) * length(p);\n}\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat cyl(vec3 p, float r, float h) {\n\treturn max(length(p.xz) - r, abs(p.y) - h);\n}\n\nfloat box(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat length8(vec2 p) {\n\tp = pow(p, vec2(8.));\n\treturn pow(p.x + p.y, 1. / 8.);\n}\n\nfloat torus82(vec3 p, vec2 t)\n{\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length8(q) - t.y;\n}\n\n// c is a plane normal\nfloat cone(vec3 p, vec2 c)\n{\n\t// c must be normalized\n\tfloat q = length(p.xy);\n\treturn dot(c, vec2(q, p.z));\n}\n\n// iq via leon/koltes\nfloat smoo(float a, float b, float r) {\n    return clamp(.5 + .5*(b - a) / r, 0., 1.);\n}\n\nfloat smin(float a, float b, float r) {\n    float h = smoo(a, b, r); return mix(b, a, h) - r*h*(1. - h);\n}\n\nvec3 localToWorld(vec3 p) {\n\tp.xz *= r2d(iTime);\n\t//p.zy *= r2d(iTime);\n    \n    // static version\n    //p.xz *= r2d(PI*.2);\n\t//p.zy *= r2d(PI*.8);\n\treturn p;\n}\n\nvec2 de(vec3 p) {\n  \tfloat plane = p.y + 1.8;\n\n\tp = localToWorld(p);\n\n\tfloat d = torus82(p.yzx, vec2(1., .1));\n\n\tamod(p.xy, 8.);\n\td = smin(d, box(p, vec3(1.3, .1, .1)), .1);\n\n\tp.x -= 1.7;\n\tp.xy *= r2d(-PI*.5);\n\n\td = smin(d, max(cone(p.zxy, normalize(vec2(.4, .2))), -p.y - .4), .1);\n    \n\tif (plane < d)\n\t\treturn vec2(1., plane);\n\n\treturn vec2(2., d);\n}\n\nvec3 normal(in vec3 pos)\n{\n\tvec2 e = vec2(1., -1.)*.5773*.0005;\n\treturn normalize(e.xyy*de(pos + e.xyy).y +\n\t\te.yyx*de(pos + e.yyx).y +\n\t\te.yxy*de(pos + e.yxy).y +\n\t\te.xxx*de(pos + e.xxx).y);\n}\n\n// from: https://www.shadertoy.com/view/MtsGWH\n// not used in the final version\n/*vec4 boxmap(sampler2D sam, in vec3 p, in vec3 n, in float k)\n{\n\tvec3 m = pow(abs(n), vec3(k));\n\tvec4 x = texture(sam, p.yz);\n\tvec4 y = texture(sam, p.zx);\n\tvec4 z = texture(sam, p.xy);\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}*/\n\n\n// Tri planar texturing, bump mapping\n// From shane: https://www.shadertoy.com/view/MlXSWX\nfloat getGrey(vec3 p) { return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = 0.001;\n    float ref = getGrey(tex3D(tex,  p , nor));                 \n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor))-ref )/eps;\n             \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// iq's softshadow\nfloat shadow(vec3 ro, vec3 rd) {\n\tfloat t = .01;\n\tfloat s = 1.;\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tfloat d = de(ro + rd * t).y;\n\t\tif (d < .001) return 0.;\n\t\ts = min(s, 4. * d / t);\n\t\tt += d;\n\t}\n\treturn s;\n}\n\n\n// xt95 ao (the simple one)\n#define HASHSCALE1 .1031\nfloat hash(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat ao(in vec3 p, in vec3 n, in float maxDist, in float falloff)\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor (int i = 0; i < nbIte; i++)\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\n\t\tao += (l - max(de(p + rd).y, 0.)) / maxDist * falloff;\n\t}\n\n\treturn clamp(1. - ao / float(nbIte), 0., 1.);\n}\n\nvec3 camera(vec3 ro, vec2 uv, vec3 ta) {\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = cross(vec3(0, 1, 0), fwd);\n\tvec3 up = cross(fwd, left);\n\treturn normalize(fwd + uv.x*left + up*uv.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 uv = (q - .5) * iResolution.xx / iResolution.yx;\n    \n    float dt = iTime * .5;\n\tvec3 ro = vec3(4.  *cos(dt), .5, -4. * sin(dt));\n\t//vec3 ro = vec3(0., .0, -4.);\n    vec3 ta = vec3(0, 0, 0);\n\tvec3 rd;\n\n\trd = camera(ro, uv, ta);\n    \n    vec3 p;\n\tfloat ri, t = 0.;\n\tvec2 d;\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tri = i;\n\t\tp = ro + rd*t;\n\t\td = de(p);\n\t\tif (d.y < .001 || t > 25.) break;\n\t\tt += d.y;\n\t}\n\n\tvec3 bg = vec3(.2, .0, .0);\n    vec3 col = bg;\n\tif (t <= 25.) {\n\t\tvec3 n = normal(p);\n\n        if (d.x == 1.) {\n\t\t\t//col = texture(iChannel1, .3+p.xz*.1*r2d(.4)).rgb;\n            vec3 q = p * .1;\n            q.xz *= r2d(.4);\n            q.xz += .3;\n            n = doBumpMap(iChannel1, q, n, .01);\n            col = tex3D(iChannel1, q, n);\n        } else {\n\t\t\t//col = boxmap(iChannel0, tex_p + .3, tex_n, 32.).rgb;\n            n = doBumpMap(iChannel0, p, n, .008);\n            vec3 tex_p = localToWorld(p);\n\t\t\tvec3 tex_n = localToWorld(n);\n            col = tex3D(iChannel0, tex_p, tex_n);\n        }\n\n\t\tvec3 l = normalize(vec3(1., 1., -2.) - p);\n\t\tvec3 h = normalize(l - rd);\n\t\tfloat dotNL = max(0., dot(n, l));\n        float dotLH = max(0., dot(l, h));\n        float sha = shadow(p, l);\n\t\tfloat occ = ao(p, n, 1., 1.);\n\t\t\n\n\t\t// GGX reference used: https://learnopengl.com/PBR/Lighting\n        float tex_data = smoothstep(0., 1., col.r);\n        float albedo = tex_data;\n        float metallic = tex_data;\n        float roughness = tex_data;\n        float f0 = .04; // dielectric\n        f0 = mix(f0, albedo, metallic);\n\t\tfloat spe = ggx(n, -rd, l, roughness, f0);\n        \n        float dotLH5 = pow(1. - dotLH, 5.);\n\t\tfloat ks = f0 + (1. - f0) * dotLH5;\n        float kd = 1. - ks;\n        kd *= 1. - metallic;\n        \n\t\tcol = vec3(.9, .77, .77) * dotNL * (kd * (col / PI)  + spe);\n\t\tcol *= sha * occ;\n        \n\t\t//col = vec3(roughness);\n\n\t}\n    \n    float dist = length(ro - p);\n\tcol = mix(col, bg, 1. - exp(-.007 * dist*dist));\n    \n    // tone mapping + gamme space\n\tcol /= col + 1.;\n\tcol = pow(col, vec3(.45));\n    \n    // iq's vignetting\n\tcol *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0 - q.x)*(1.0 - q.y), 0.25);\n    \n\tfragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}