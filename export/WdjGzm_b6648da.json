{"ver":"0.1","info":{"id":"WdjGzm","date":"1548545297","viewed":189,"name":"2D texture to 3D","username":"Wuszt","description":"2D texture to 3D","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERATIONS 10000\n#define COLLISION_DISTANCE 0.01f\n#define MAX_DISTANCE 500.0f\n\nfloat Sphere(vec3 p, vec3 pos, float radius)\n{\n    return length(p-pos) - radius;\n}\n\nfloat Union(float a, float b, vec3 colorA, vec3 colorB, out vec3 color)\n{\n    if(a < b)\n    {\n        color = colorA;\n        return a;\n    }\n    \n    color = colorB;\n    return b;\n}\n\nvec3 TransformPoint(vec3 p, vec3 centerOfRotation, vec3 rotation)\n{\n    rotation *= 0.017453292519943295;\n    \n    vec4 p4 = vec4(p - centerOfRotation, 1.0f);\n    \n    mat4 zyxRotation = mat4(\n        vec4(cos(rotation.z) * cos(rotation.y), sin(rotation.z)*cos(rotation.x) + cos(rotation.z)*sin(rotation.y)*(rotation.x), sin(rotation.z)*sin(rotation.x) - cos(rotation.z)*sin(rotation.y)*cos(rotation.x), 0.0f),\n        vec4(-sin(rotation.z)*cos(rotation.y),cos(rotation.z)*cos(rotation.x)-sin(rotation.z)*sin(rotation.y)*sin(rotation.x), cos(rotation.z)*sin(rotation.x) + sin(rotation.z)*sin(rotation.y)*cos(rotation.x), 0.0f),\n        vec4(sin(rotation.y), -sin(rotation.x)*cos(rotation.y), cos(rotation.y)*cos(rotation.x), 0.0f),\n        vec4(0.0f,0.0f, 0.0f, 1.0f)); \n    \n     p4 *= zyxRotation;\n    \n    return p4.xyz + centerOfRotation;          \n}\n\nfloat Test(vec3 p, vec3 piv,sampler2D samp, vec3 rot, out vec3 color)\n{      \n    p = TransformPoint(p, piv, rot);\n    \n    vec2 uv = p.xy - piv.xy;\n    \n    uv/= 5.5f;\n    \n    uv = uv + vec2(1.0f);\n    uv /= 2.0f;\n    \n    vec4 tex = vec4(0.25f);\n    \n    if(abs(uv.x) < 1.0f && abs(uv.y) < 1.0f)\n    \ttex = texture(samp,uv);\n    color = tex.rgb;\n    \n    p.z += 5.0f * (tex.r * 0.3 + tex.g * 0.59 + tex.b * 0.11);\n\n    \n    return Sphere(p, piv, 5.0f);\n}\n\nfloat Scene(vec3 p, out vec3 color)\n{\n    float d = Test(p, vec3(-7.5f,6.0f, 4.0f),iChannel0,vec3(-15.0f, -15.0f, 0.0f), color);\n    \n    vec3 col1;\n    float d1 = Test(p, vec3(7.5f,6.0f, 4.0f),iChannel1,vec3(-15.0f, 15.0f, 0.0f), col1);\n    \n    d = Union(d,d1,color,col1, color);\n    \n    d1 = d1 = Test(p, vec3(7.5f,-6.0f, 4.0f),iChannel3,vec3(15.0f + 2.5f, 15.0f, 0.0f), col1);\n    \n    d = Union(d,d1,color,col1, color);\n    \n    d1 = Test(p, vec3(-7.5f,-6.0f, 4.0f),iChannel2,vec3(15.0f, -15.0f, 0.0f), col1);\n    \n    d = Union(d,d1,color,col1, color);\n    \n    return d;\n}\n\nfloat Raymarching(vec3 cameraPos, vec3 rd, out vec3 color)\n{   \n    float t = 0.0f;\n    for(int i=0;i<MAX_ITERATIONS;++i)\n    {\n        float d = Scene(cameraPos + rd * t, color);\n        \n        t += d;\n        \n        if(t > MAX_DISTANCE || d < COLLISION_DISTANCE)\n            break;\n    }\n    \n    return t;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    vec2 e = vec2(COLLISION_DISTANCE * 0.1f, 0.0f);\n    vec3 color;\n    float d = Scene(p, color);\n    \n    vec3 n = vec3(\n        d - Scene(p-e.xyy, color),\n        d - Scene(p-e.yxy, color),\n        d - Scene(p-e.yyx, color));\n    \n    return normalize(n);\n}\n\nfloat GetDiffuseLight(vec3 p, vec3 pos)\n{\n    vec3 normal = GetNormal(p);\n    \n    vec3 light = pos - p;\n    \n    return dot(normalize(light), normal);\n}\n\nvec3 GetShadow(vec3 p, vec3 light)\n{\n    vec3 dir = normalize(light - p);\n    vec3 color;\n    float d = Raymarching(p, dir, color);\n    \n    if(d < length(light - p))\n        return vec3(0.1f);\n    \n    return vec3(1.0f);\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 pos1 = vec3(8.0f * sin(2.0f * iTime),8.0f * cos(2.0f * iTime), -2.0f); \n    \n    float diff = 0.25f + 0.75f * clamp(GetDiffuseLight(p, pos1), 0.5f, 1.0f);\n    \n    return diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord- 0.5f * iResolution.xy)/iResolution.y;\n    \n    vec3 cameraPos = vec3(0.0f,0.0f, -25.0f);\n    vec3 dir = vec3(normalize(vec3(uv.xy, 1.0f)));\n    vec3 color = vec3(0.0f);\n    float d = Raymarching(cameraPos, dir, color);\n    float light = GetLight(cameraPos + dir * d);\n    \n    fragColor = vec4(color * light, 1.0f);\n}","name":"Image","description":"","type":"image"}]}