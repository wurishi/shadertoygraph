{"ver":"0.1","info":{"id":"tdjyzK","date":"1588872821","viewed":75,"name":"Ambient Occlusion - cis461","username":"sharond106","description":"Ambient occlusion","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["occlusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FOVY = 0.25 * 3.141569;\nconst int RAY_STEPS = 256;\n#define LEFT_WALL_SDF sdfPlane(pos, LEFT_WALL_INVERSE_T)\n#define LEFT_WALL_ID 1\n#define LEFT_WALL_INVERSE_T inverseTransform(vec3(5., 0., 0.), vec3(0., 90., 0.), vec3(20., 20., 1.))\n#define RIGHT_WALL_SDF sdfPlane(pos, RIGHT_WALL_INVERSE_T)\n#define RIGHT_WALL_ID 2\n#define RIGHT_WALL_INVERSE_T inverseTransform(vec3(-5., 0., 0.), vec3(0., 90., 0.), vec3(20., 20., 1.))\n#define BACK_WALL_SDF sdfPlane(pos, BACK_WALL_INVERSE_T)\n#define BACK_WALL_ID 3\n#define BACK_WALL_INVERSE_T inverseTransform(vec3(0., 0., 11.), vec3(0.), vec3(22., 22., 1.))\n#define CEILING_SDF sdfPlane(pos, CEILING_INVERSE_T)\n#define CEILING_ID 4\n#define CEILING_INVERSE_T inverseTransform(vec3(0., 4.95, 0.), vec3(90., 0., 0.), vec3(20., 20., 1.))\n#define FLOOR_SDF sdfPlane(pos, FLOOR_INVERSE_T)\n#define FLOOR_ID 5\n#define FLOOR_INVERSE_T inverseTransform(vec3(0., -4.95, 0.), vec3(90., 0., 0.), vec3(20., 20., 1.))\n\n#define TALL_CUBE_SDF sdfBox(pos, vec3(3., 6, 3), TALL_CUBE_INVERSE_T)\n#define TALL_CUBE_ID 6\n#define TALL_CUBE_INVERSE_T inverseTransform(vec3(2, -2.5, 8), vec3(0, 27.5, 0), vec3(3., 6, 3))\n\n#define SHORT_CUBE_SDF sdfBox(pos, vec3(3.), SHORT_CUBE_INVERSE_T)\n#define SHORT_CUBE_ID 7\n#define SHORT_CUBE_INVERSE_T inverseTransform(vec3(-2, -3.5, 7), vec3(0, -17.5, 0), vec3(3.))\n\n#define SPHERE_SDF sdfSphere(pos, vec3(-2, 0, 0), 1.)\n#define SPHERE_ID 8\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \nmat4 inverseTransform(vec3 translate, vec3 rotate, vec3 scale) {\n    mat4 s;\n    // matrices indexed to columns!\n    s[0] = vec4(scale.x, 0., 0., 0.);\n    s[1] = vec4(0., scale.y, 0., 0.);\n    s[2] = vec4(0., 0., scale.z, 0.);\n\ts[3] = vec4(0., 0., 0., 1.);                                     \n                                    \n    rotate.x = radians(rotate.x);\n    rotate.y = radians(rotate.y);\n    rotate.z = radians(rotate.z);\n      \n    mat4 r_x;\n    r_x[0] = vec4(1., 0., 0., 0.);\n    r_x[1] = vec4(0., cos(rotate.x), sin(rotate.x), 0.);\n    r_x[2] = vec4(0., -sin(rotate.x), cos(rotate.x), 0.);\n    r_x[3] = vec4(0., 0., 0., 1.);\n                                    \n                                    \n    mat4 r_y;\n    r_y[0] = vec4(cos(rotate.y), 0., -sin(rotate.y), 0.);\n    r_y[1] = vec4(0., 1, 0., 0.);\n    r_y[2] = vec4(sin(rotate.y), 0., cos(rotate.y), 0.);\n    r_y[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r_z;\n    r_z[0] = vec4(cos(rotate.z), sin(rotate.z), 0., 0.);\n    r_z[1] = vec4(-sin(rotate.z), cos(rotate.z), 0., 0.);\n    r_z[2] = vec4(0., 0., 1., 0.);\n    r_z[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r = r_x * r_y * r_z;\n    \n    mat4 t;\n    t[0] = vec4(1., 0., 0., 0.);\n    t[1] = vec4(0., 1., 0., 0.);\n    t[2] = vec4(0., 0., 1., 0.);\n    t[3] = vec4(translate.x, translate.y, translate.z, 1.); \n    \n    return inverse(t * r * s);      \n}\n    \nfloat sdfPlane(vec3 p, mat4 inverseT) {\n    p = vec3(inverseT * vec4(p, 1.));\n    float dot = dot(p, vec3(0., 0., 1.));\n    if (abs(dot) < 0.0001) {\n        // n must be normalized\n        if (p.x >= -.5 && p.x <= 0.5 && p.y >= -0.5 && p.y <= 0.5) {\n            return 0.;  \n        }\n        return 324234.;\n    }\n    float dist = 0.f;\n    if (abs(p.x) > 0.5) {\n        dist += ((p.x - 0.5) * (p.x - 0.5));\n    }\n    if (abs(p.y) > 0.5) {\n        dist += ((p.y - 0.5) * (p.y - 0.5));\n    }\n    dist += abs(p.z) * abs(p.z);\n    return sqrt(dist);\n} \n\n// Box with side lengths b\nfloat sdfBox(vec3 p, vec3 scale, mat4 inverseT)\n{\n    p = vec3(inverseT * vec4(p, 1.));\n    vec3 q = vec3(abs(p.x), abs(p.y), abs(p.z)) - vec3(.5);\n    float d = q.x;\n    d = max(d,q.y);\n    d = max(d,q.z);\n    return d * min(min(scale.x, scale.y), scale.z);\n}\n\n\nfloat sdfSphere(vec3 p, vec3 c, float r) {\n    return distance(p, c) - r;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int objectHit) {\n\tt = LEFT_WALL_SDF;\n    objectHit = LEFT_WALL_ID;\n    float t2;\n\n    if ((t2 = RIGHT_WALL_SDF) < t) {\n        t = t2;\n        objectHit = RIGHT_WALL_ID;\n    }\n    if ((t2 = BACK_WALL_SDF) < t) {\n        t = t2;\n        objectHit = BACK_WALL_ID;\n    }\n    if ((t2 = CEILING_SDF) < t) {\n        t = t2;\n        objectHit = CEILING_ID;\n    }\n\tif ((t2 = FLOOR_SDF) < t) {\n        t = t2;\n        objectHit = FLOOR_ID;\n    }\n    if ((t2 = TALL_CUBE_SDF) < t) {\n        t = t2;\n        objectHit = TALL_CUBE_ID;\n    }\n     if ((t2 = SHORT_CUBE_SDF) < t) {\n        t = t2;\n        objectHit = SHORT_CUBE_ID;\n    }\n}\n\n// called by computeNormal\nfloat sceneMap3D(vec3 pos) {\n    float t;\n    int obj;\n    sceneMap3D(pos, t, obj);\n    return t;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int objectHit) {\n    t = 0.001;\n    for (int i = 0; i < RAY_STEPS; i++) {\n        vec3 pos = origin + t * dir;\n        float min;\n        sceneMap3D(pos, min, objectHit);\n        if (min < 0.01) {\n            return;\n        }\n        t += min;\n    }\n    t = -1.;\n    objectHit = -1;\n}\n\nvec3 computeNormal(vec3 p, vec3 lightPos) {\n    vec3 epsilon = vec3(0., .001, 0.);\n    return normalize(vec3(sceneMap3D(p + epsilon.yxx) - sceneMap3D(p - epsilon.yxx),\n                          sceneMap3D(p + epsilon.xyx) - sceneMap3D(p - epsilon.xyx),\n                     \t  sceneMap3D(p + epsilon.xxy) - sceneMap3D(p - epsilon.xxy)));\n}\n\nvec3 computeMaterial(int objectHit, vec3 p, vec3 n, vec3 lightDir, vec3 view) {\n    lightDir = normalize(lightDir - p);\n    float lambert = dot(n, lightDir);\n    vec3 color;\n    switch (objectHit) {\n        case LEFT_WALL_ID:\n        color = vec3(1, 0, 0);\n        break;\n        case RIGHT_WALL_ID:\n        color = vec3(0, 1, 0);\n        break;\n        case BACK_WALL_ID:\n        color = vec3(1);\n        break;\n        case FLOOR_ID:\n        color = vec3(1);\n        break;\n        case CEILING_ID:\n        color = vec3(1);\n        break;\n        case TALL_CUBE_ID:\n        color = vec3(1);\n        break;\n        case SHORT_CUBE_ID:\n        color = vec3(1);\n        break;\n    }\n    return color * lambert;\n}\n\n#define DIST 0.15\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float sum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        sum += coeff * (i * DIST - sceneMap3D(p + n * i * DIST));\n    }\n    return 1.0 - k * sum;\n}\n\nIntersection sdf3D(vec3 eye, vec3 dir) {\n    float t;\n    int objectHit;\n    march(eye, dir, t, objectHit);\n    vec3 isect = eye + t * dir;\n    \n    vec3 nor = computeNormal(isect, vec3(0, 0, 0));\n    \n    vec3 lightDir = vec3(0, 4.9, 3);\n    \n    vec3 color = computeMaterial(objectHit, isect, nor, lightDir, normalize(eye - isect));\n    \n    if (objectHit == -1) {\n        color = vec3(0, 0, 0);\n    }\n    \n\t// Adding ambient occlusion\n    float ao = fiveTapAO(isect, nor, 2.0);    \n    color *= vec3(ao);\n    \n    return Intersection(t, color, isect, objectHit);\n}\n\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc) {\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0., 1., 0.)));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / float(iResolution.y);\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - vec2(1, 1);\n    \n    vec3 eye = vec3(0, 1.5, -11);\n    vec3 ref = vec3(0, 1, 0);\n    vec3 rayDir = rayCast(eye, ref, uv); \n    \n    Intersection isect = sdf3D(eye, rayDir);\n\n    fragColor = vec4(isect.color, 1.0);\n}","name":"Image","description":"","type":"image"}]}