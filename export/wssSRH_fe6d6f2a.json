{"ver":"0.1","info":{"id":"wssSRH","date":"1550639542","viewed":122,"name":"Experimenting with scalar fields","username":"hackpoetic","description":"Yesterday I learned about scalar fields. Today I realized I already knew them from ray marching (sign distance fields) and that in that context I'm just deciding what slice of the field to display. It opened my eyes and now my brain looks like this.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["scalarfields"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fun-alike license - have as much fun freely using/modifying/distributing this as I did.\n// https://www.instagram.com/hackpoetic\n\n\n// 2 * PI. The arc cosine of -1 is PI\n#define TAU (2. * acos(-1.))\n\n#define TIME (iTime / 2.)\n//#define TIME 0.53\n\n// Found this scalar field on wikipedia.\n// It's attractive because it oscilates between values across space and through time! \nfloat field(vec2 p) {\n    p *= 2.; return sin(TAU * (p.x * p.y + TIME));\n}\n\n// This function gives a nice combination of positive and negative values\n// as t increases. Fun fact, add a third component \"t\" and this is\n// a helix!\nvec2 circle(float t) {\n    return vec2(cos(t), sin(t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    fragColor.rgb = vec3(0);\n    for (float i = 0.; i < 100.; i++) {\n        // alternate between color channels, offseting the field a bit each time\n        // this offset is proportional to i and scaled down a bit\n        fragColor[int(i) % 3] += field(uv + circle(i) * i * 0.01);\n    }\n}","name":"Image","description":"","type":"image"}]}