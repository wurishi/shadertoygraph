{"ver":"0.1","info":{"id":"ss23Ry","date":"1618668633","viewed":54,"name":"WITCHNOFORKBOMB","username":"Wrong_Wizzli","description":"exam shader","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["exam"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = texture(iChannel1, uv) / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float GLOBAL_LIGHTER = 1.0;\nvec3 CAMERA_POS = vec3(-2., 1.5, -3.);\n//LIGHT INFO\nconst vec3 LIGHTS_POS[3] = vec3[3](vec3(3., 1., -0.0), vec3(-2.0, 2., 2.), vec3(-2.0, 1.0, -3.0));\nconst vec3 LIGHTS_COLOR[3] = vec3[3](vec3(0.89, 0.85, 0.36), vec3(.0, 1.,1.), vec3(1., 1., 1.));\nconst float LIGHTS_RADIUS[3] = float[3](.5, 0.5, 0.5);\n\n//Pyramid Block\nconst vec3 P_CNTR = vec3(.0, -0.3 + 10e-5, 0.0);\nconst float P_H = 2.;\nconst float P_BASE = 1.;\n\n//Arrays of pyramid points and triangle points and pos offsets of camera\nconst vec3 P_P[5] = vec3[5](P_CNTR + vec3(0, P_H, 0),                   //0\n                            P_CNTR + vec3(P_BASE, 0, -P_BASE),          //1\n                            P_CNTR + vec3(-P_BASE, 0, -P_BASE),         //2\n                            P_CNTR + vec3(P_BASE, 0, P_BASE),           //3\n                            P_CNTR + vec3(-P_BASE, 0, P_BASE));         //4\n                            \nconst vec3 P_T[6] = vec3[6](vec3(3, 1, 0), vec3(2, 3, 4), vec3(0, 4, 2), \n                            vec3(2, 1, 0), vec3(2, 1, 3), vec3(0, 3, 4));\n                        \n//End of Pyramid Block\n\n\nconst vec3 P_CNTR2 = vec3(.0, -0.3 + 10e-5, 0.0);\nconst float P_H2 = 1.9;\nconst float P_BASE2 = .9;\n\n//Arrays of pyramid points and triangle points and pos offsets of camera\nconst vec3 P_P2[5] = vec3[5](P_CNTR2 + vec3(0, P_H2, 0),                   //0\n                            P_CNTR2 + vec3(P_BASE2, 0, -P_BASE2),          //1\n                            P_CNTR2 + vec3(-P_BASE2, 0, -P_BASE2),         //2\n                            P_CNTR2 + vec3(P_BASE2, 0, P_BASE2),           //3\n                            P_CNTR2 + vec3(-P_BASE2, 0, P_BASE2));         //4\n                            \nconst vec3 P_T2[6] = vec3[6](vec3(3, 1, 0), vec3(2, 3, 4), vec3(0, 4, 2), \n                            vec3(2, 1, 0), vec3(2, 1, 3), vec3(0, 3, 4));  \n\n\n//CYLINDER\nconst vec3 CYL = vec3(1.5, -1.0 + 10e-5, 0.7); // vec3(Radius, lowest y of cyl, height of cyl)\n\n//Useful consts\nconst float INF = 10e10;\nconst float EPS = 10e-7;\n\nconst int EMISSION = 0;\nconst int DIFFUSION = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\nconst int FIRE = 4;\n//End of useful consts\n\n\nfloat rand(float frame) {\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\n\nfloat tracePlane(vec3 pos, vec3 dir, float y, float trace_dist, out vec3 normal) {\n    float t = (y - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 WorldPos = t * dir + pos;\n    if (dot(WorldPos.xz, WorldPos.xz) < trace_dist) {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    return INF;\n}  \n   \n   \nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal) {\n    float b = dot(pos, dir);\n    float D = b * b - dot(pos, pos) + r * r;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = (-b-sqrt(D));\n    if (t > 0.0) {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0) {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\n\nfloat traceCylinder(vec3 pos, vec3 dir, vec3 cyl, out vec3 normal) {\n    float t = INF;\n    float temp_t = (cyl.y - pos.y) / dir.y;\n    if (temp_t <= 0.0) {\n        return INF;\n    } else if (temp_t < t) {\n        vec3 P = temp_t * dir + pos;\n        if (dot(P.xz, P.xz) <= cyl.x * cyl.x) {\n            normal = vec3(0, -1, 0);\n            t = temp_t;\n        }\n    }\n    temp_t = (cyl.y + cyl.z - pos.y) / dir.y;\n    if (temp_t > 0.0 && temp_t < t) {\n        vec3 P = temp_t * dir + pos;\n        if (dot(P.xz, P.xz) <= cyl.x * cyl.x) {\n            normal = vec3(0, 1, 0);\n            t = temp_t;\n        }\n    }\n    float a = dot(dir.xz, dir.xz);\n    float b = dot(dir.xz, pos.xz);\n    float c = dot(pos.xz, pos.xz) - cyl.x * cyl.x;\n    float D = b * b - a * c;\n    if (D >= 0.0) {\n        float sq_D = sqrt(D);\n        temp_t = (-b - sq_D) / a;\n        if (temp_t > 0.0 && temp_t < t) {\n            vec3 P = dir * temp_t + pos;\n            if (P.y >= cyl.y && P.y <= cyl.y + cyl.z) {\n                normal = vec3(P.x, 0, P.z);\n                t = temp_t;\n            }\n        }\n        temp_t = (-b + sq_D) / a;\n        if (temp_t > 0.0 && temp_t < t) {\n            vec3 P = dir * temp_t + pos;\n            if (P.y >= cyl.y && P.y <= cyl.y + cyl.z) {\n                normal = vec3(P.x, 0, P.z);\n                t = temp_t;\n            }\n        }\n    }\n    normal = normalize(normal);\n    return t;\n}\n\n\nfloat traceTriangle(vec3 pos, vec3 dir, vec3 v0, vec3 v1, vec3 v2, out vec3 normal) {\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 pvec = cross(dir, e2);\n    float det = dot(e1, pvec);\n\n    if (det < 1e-8 && det > -1e-8) {\n        return INF;\n    }\n\n    float inv_det = 1. / det;\n    vec3 tvec = pos - v0;\n    float u = dot(tvec, pvec) * inv_det;\n    if (u < 0. || u > 1.) {\n        return INF;\n    }\n\n    vec3 qvec = cross(tvec, e1);\n    float v = dot(dir, qvec) * inv_det;\n    if (v < 0. || u + v > 1.) {\n        return INF;\n    }\n    normal = normalize(cross(e1, e2));\n    float D = dot(normal, v0);\n    float t = (D - dot(normal, pos)) / dot(normal, dir);\n    if (t < 0.0) {\n        return INF;\n    }\n    return t;\n}\n\n\nfloat tracePyramid(vec3 pos, vec3 dir, out vec3 normal, out bool base, out float hits) {\n    \n    //out float hits: for light computing. \n    //out bool base: to understand if we move in air or in cylinder\n    vec3 randVals =(vec3(rand(float(iFrame + 5)), rand(float(iFrame + 125)), rand(float(iFrame + 515))) - 0.5) * 0.05;\n    base = false;\n    float t_max = INF;\n    vec3 t_normal;\n    for (int i = 0; i < 6; ++i) {    //Actually tracing 6 triangles of pyramid\n        float t = traceTriangle(pos, dir, P_P[int(P_T[i].x)] + randVals, P_P[int(P_T[i].y)] + randVals, P_P[int(P_T[i].z)] + randVals, t_normal);\n        if (t < INF) {\n            hits += 1.;\n        }\n        if (t < t_max) {\n            t_max = t;\n            normal = t_normal;\n            if (i == 1 || i == 4) {\n                base = true;\n            } else {\n                base = false;\n            }\n        }\n    }\n    return t_max;\n}\n\nfloat tracePyramid2(vec3 pos, vec3 dir, out vec3 normal, out bool base, out float hits) {\n    \n    //out float hits: for light computing. \n    //out bool base: to understand if we move in air or in cylinder\n    vec3 randVals = (vec3(rand(float(iFrame + 5)), rand(float(iFrame + 125)), rand(float(iFrame + 515))) - 0.5) * 0.5;\n    base = false;\n    float t_max = INF;\n    vec3 t_normal;\n    for (int i = 0; i < 6; ++i) {    //Actually tracing 6 triangles of pyramid\n        float t = traceTriangle(pos, dir, P_P2[int(P_T2[i].x)] + randVals, P_P2[int(P_T2[i].y)] + randVals, P_P2[int(P_T2[i].z)] + randVals, t_normal);\n        if (t < INF) {\n            hits += 1.;\n        }\n        if (t < t_max) {\n            t_max = t;\n            normal = t_normal;\n            if (i == 1 || i == 4) {\n                base = true;\n            } else {\n                base = false;\n            }\n        }\n    }\n    return t_max;\n}\n\n\nvec4 fire_color(vec4 colA, vec4 colB, vec2 fragCoord) {\n\n    vec2 uv0 = ((fragCoord.xy - iResolution.xy * .5) / iResolution.y) * 2.0;\n    float angle = 0.79;\n    mat2 rot = mat2(\n        sin(angle), -cos(angle),\n        cos(angle), sin(angle)\n    );\n    vec2 uv1 = uv0 * rot;\n    vec2 uv2 = rot * uv0;\n    vec3 enlarge = 2. - fract(vec3(0., 0.333, 0.667) + 0.5);\n\n    float r = dot(uv0,uv0);\n    float p = (pow(r, 3.) + 0.3);\n    uv0 *= p;\n    uv1 *= p;\n    uv2 *= p;\n    float fire = dot(vec3(\n        texture(iChannel3, uv0 * enlarge.x).x,\n        texture(iChannel3, uv1 * enlarge.y).y,\n        texture(iChannel3, uv2 * enlarge.z).z\n    ), smoothstep(vec3(0.5), vec3(0.0), abs(fract(enlarge)-0.5)));\n    return (mix(colA, colB, fire) - r*r * 1.75) *1.75;\n    \n}\n\n\nfloat Occlusion_debuff(vec3 pos, vec3 target) {\n\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    float c = 0.0;\n    \n    vec3 trNorm;\n    bool base;\n    float hits = 0.;\n    vec3 cylNorm;\n    float cylT = traceCylinder(pos, dir, CYL, cylNorm);\n    if (cylT < dist) {\n        return 0.;\n    }\n    \n    float trT = tracePyramid(pos, dir, trNorm, base, hits);\n    if (trT < dist) {\n        return 1. * (6. - hits) / 6.;\n    }\n    \n    return 1.;\n}\n\n\nvec3 ComputeLight(vec3 pos, vec3 normal, vec3 color, vec2 fragCoord) {\n    vec3 total_color = vec3(0);\n    for (int j = 0; j < 2; ++j) {\n        vec3 LIGHT = LIGHTS_POS[j] - pos;\n        float sqdist = dot(LIGHT,LIGHT);\n        float att = 10.0 / sqdist;\n        float debuff = Occlusion_debuff(pos, LIGHTS_POS[j] + LIGHTS_RADIUS[j] *2.* rand(float(iFrame)));\n        total_color += color * max(0.0, dot(normal, normalize(LIGHT))) * att * LIGHTS_COLOR[j] * debuff;\n    }\n    vec3 randVals = vec3(rand(float(iFrame + 5)), rand(float(iFrame + 125)), rand(float(iFrame + 515)));\n    vec3 LIGHT = vec3(0.0, 0.3, 0.0) + randVals * cos(iTime) * 0.3;\n    float sqdist = dot(LIGHT - pos,LIGHT - pos);\n    float att = 7.0 / sqdist;\n    float debuff = Occlusion_debuff(pos, LIGHT);\n    total_color += color *  max(0.0, dot(normal, normalize(LIGHT - pos))) * att * fire_color(vec4(1.0, 0.0, 0.0, 1.0), vec4(2.0, 1.5, 0.8, 1.0), fragCoord).rgb * 0.1 * debuff;\n    return total_color + texture(iChannel1, normal).rgb * color * 0.1;\n}\n\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2, out bool refl) {\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal) / length(v) / length(normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    if (sinB > 1.) {\n        refl = true;\n        return reflect(v, normal);\n    }\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\n\nvec3 reflection(vec3 v, vec3 normal) {\n    return v - 2.0 * dot(v, normal) * normal;\n}\n\n\nfloat pow2(float a) {\n    return a * a;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 randVals = vec3(rand(float(iFrame + 5)), rand(float(iFrame + 125)), rand(float(iFrame + 515)));\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5) * 2.0) / iResolution.y;\n    \n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    \n    vec3 ViewVector = normalize(front + right * uv.x + up * uv.y);\n    vec3 WorldPos;\n    \n    vec3 CurPos = CAMERA_POS;\n    vec3 CurDir = ViewVector;\n    \n    float air_n = 1.0, glass_n = 1.5;\n    float n1 = 1.0, n = 1.5;\n    \n    float glass_r = pow2(air_n - glass_n) / pow2(air_n + glass_n);\n    \n    vec3 ColorMult = vec3(1.0, 1.0, 1.0);\n    for (int i = 0; i < 40; ++i) {\n\n        float t = INF;\n        \n        int material;\n        vec3 color;\n        vec4 colA, colB;\n        \n        vec3 normal, temp_normal;\n        \n        float curT = t;\n        float PlaneT = tracePlane(CurPos, CurDir, -1., 100.0, temp_normal);\n        if (t > PlaneT) {\n        \n            t = PlaneT;\n            material = DIFFUSION;\n            vec3 WorldPos = t * CurDir + CurPos;\n            \n            ColorMult *= vec3(1.0, 1.0, 1.0);\n            color = texture(iChannel0, WorldPos.xz * 0.5).rgb;\n            \n            normal = temp_normal;\n        }\n        \n        for (int j = 0; j < 2; ++j) {\n\n            float lightT = traceSphere(CurPos - LIGHTS_POS[j] - randVals * 10e-2, CurDir, LIGHTS_RADIUS[j], temp_normal);\n            if (lightT < t) {\n                t = lightT;\n                material = EMISSION;\n                color = LIGHTS_COLOR[j];\n                normal = temp_normal;\n            }\n        }\n        \n        bool base;\n        float hits;\n        \n        float pyramidT = tracePyramid(CurPos, CurDir, temp_normal, base, hits);\n        if (t > pyramidT) {\n        \n            t = pyramidT;\n            if (randVals.x < 3. * glass_r) {\n                material = REFLECTION;\n            } else {\n                material = REFRACTION;\n            }\n            \n            //ColorMult *= vec3(0.67, 0.62, 0.86);\n            //ColorMult *= vec3(0.9, 0.5, 0.5);\n            ColorMult *= vec3(0.8, 0.9, 0.8);\n            \n            normal = temp_normal;\n            if (base) {\n                n = n1;\n            }\n        }\n        \n        vec3 sin_off = (randVals - 0.5);\n        \n        float sphT = traceSphere(CurPos - vec3(0.,0.4,0.) + sin_off / 3., CurDir, .3, temp_normal);\n        if (sphT < t) {\n        \n            t = sphT;\n            material = FIRE;\n            colA = vec4(1.0, 0.0, 0.0, 1.0);\n            colB = vec4(3.0, 2.25, 1.6, 1.0);\n            color = vec3(1., 0.6, 1.);\n            normal = temp_normal;\n        }\n\n        if (iFrame % 3 == 0 || iFrame % 4 == 0) {\n            float pyramid2T = tracePyramid(CurPos -  - vec3(0.,0.4,0.) + sin_off / 3., CurDir, temp_normal, base, hits);\n            if (t > pyramid2T) {\n\n                t = pyramid2T;\n                material = FIRE;\n\n                colA = vec4(0.0, 0.0, 0.0, 1.0);\n                colB = vec4(0.0, 0.5, 0.8, 1.0);\n            \n                normal = temp_normal;\n            }\n       }\n        \n        float cylT = traceCylinder(CurPos, CurDir, CYL, temp_normal);\n        if (cylT < t) {\n        \n            t = cylT;\n            material = DIFFUSION;\n            \n            vec3 WorldPos = t * CurDir + CurPos;\n            ColorMult *= vec3(1.0, 1.0, 1.0);\n            \n            vec3 y_norm = vec3(0,1,0);\n            if (temp_normal == y_norm || temp_normal == -y_norm) {\n                color = texture(iChannel2, WorldPos.xz).rgb;\n            } else {\n                color = texture(iChannel2, WorldPos.yz).rgb;\n            }\n            normal = temp_normal;\n        }\n        \n        if (t != INF) {\n\n            WorldPos = CurPos + CurDir * t;\n\n            if (material == EMISSION) {\n            \n               fragColor.rgb = color * ColorMult * GLOBAL_LIGHTER;\n               break;\n               \n            } else if (material == DIFFUSION) {\n            \n                fragColor.rgb = ComputeLight(WorldPos, normal, color, fragCoord) * ColorMult * GLOBAL_LIGHTER;              \n                break;\n                \n            } else if (material == REFLECTION) {\n            \n                CurDir = reflect(CurDir, normal);\n                CurPos = WorldPos + CurDir * 10e-5;\n                \n            } else if (material == REFRACTION) {\n            \n                bool reflected = false;\n                vec3 temp_cur = refraction(CurDir, normal, n1, n, reflected);\n                CurDir = temp_cur;\n                CurPos = WorldPos + CurDir * 10e-5;\n                if (!reflected) {\n                    n1 = n;\n                }\n                \n            } else if (material == FIRE) {\n            \n                fragColor.rgb = fire_color(colA, colB, fragCoord).rgb * ColorMult;\n                break;\n                \n            }\n        } else {       \n            fragColor.rgb = texture(iChannel1, CurDir).rgb * ColorMult * GLOBAL_LIGHTER;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}