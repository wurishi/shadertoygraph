{"ver":"0.1","info":{"id":"sts3W4","date":"1622137466","viewed":119,"name":"Good Morning, Little Sparrow!","username":"gunthern","description":"2D noise pattern - fullscreen encouraged!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noisecolorful2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random (in vec2 _uv) {\n    return fract(sin(dot(_uv.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _uv) {\n    vec2 i = floor(_uv);\n    vec2 f = fract(_uv);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat circle(in vec2 uv, in float radius, in vec2 center) {\n    vec2 l = uv - center;\n    return 1.0 - smoothstep(radius - (radius * .05),\n                            radius + (radius * .05),\n                            dot(l,l) * 4.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.0);\n\n    // Noise pattern with color\n    float pattern = noise(uv*10.-iTime);\n    pattern *= noise(uv*10. + iTime);\n    pattern = smoothstep(.3 * (abs(sin(iTime*.25))+.1),.3 * (abs(cos(iTime*.25))+.1),fract(pattern*2.));\n    col = vec3(pattern) * vec3(noise(uv*10. + ((abs(cos(iTime*.01))*300.)+100.)),noise(uv*10. * ((abs(sin(iTime))*10.)+200.)), noise(uv*10. - ((abs(sin(iTime*.01))*300.)+100.)));\n\n    // Circle 0\n    vec2 circle0UV = vec2(uv.x, uv.y / sin(uv.y*20.*cos(iTime*.9)));\n    float circle0 = circle(circle0UV / (noise(uv*200.)+0.53), 1.0*(abs(sin(iTime))+.5), vec2(0.));\n    col += circle0 * \n           vec3(1.0, 0.25, 0.1) * \n           clamp(ceil(0.0 - cos(iTime*.5)), 0.0, 1.0) *\n           clamp(abs(0.0 - cos(iTime*2.75)), 0.0, 1.0) * \n           clamp(ceil(0.0 - cos(iTime*1.75)), 0.0, 1.0);\n    \n    // Circle 1\n    vec2 circle1UV = vec2(sin(uv.x*20.*noise(uv*(sin(iTime*1.2)+cos(iTime*.9)))), 0.0);\n    float circle1 = circle(circle1UV / (noise(uv*200.)+0.53), 1.0, vec2(0.));\n    col += circle1 * \n           vec3(0.0, 0.25, 0.53*sin(iTime)) * \n           clamp(ceil(0.0 - cos(iTime*.5)), 0.0, 1.0) *\n           clamp(abs(0.0 - sin(iTime*2.35)), 0.0, 1.0);\n           \n    // Circle 2\n    vec2 circle2UV = vec2(cos(uv.x*100.*(noise(uv*(sin(iTime*0.2)+cos(iTime*.19)))+1.)), sin(uv.y*200.*noise(uv*(cos(iTime*1.2)+sin(iTime*.9)))+.1));\n    float circle2 = circle(circle2UV / (noise(uv*200.)+0.53), 1.0, vec2(0.));\n    col += circle2 * \n           vec3(0.0, 0.1, 0.0) * \n           clamp(ceil(cos(iTime*.5)), 0.0, 1.0) *\n           clamp(abs(0.0 - sin(iTime*1.35)), 0.0, 1.0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}