{"ver":"0.1","info":{"id":"NlB3WK","date":"1624747528","viewed":143,"name":"Cubic Bezier and Derivative","username":"Yusef28","description":"A Cubic Bezier Derviative Visualization\nfor every t it should be 3*([the bezier of p2,p3,p4 at t] minus [the bezier of p1,p2,p3 at t])\nwhere p1,p2,p3,p4 are p's from the cubic. \nCorrect me if I'm wrong anyone.\n\nFrom: https://pomax.github.io/bezierinfo/\n\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["bezier","derivative","cubic","casteljau","hodograph"],"hasliked":0,"parentid":"fljGR3","parentname":"Cubic Bezier 4 Methods"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//I'm learning this stuff from ----> https://pomax.github.io/bezierinfo/\n//For this one I also found this:https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/bezier-der.html\n//to be helpful\n\n//Also this example of a 1 dimentional cubic bezier\n// was very helpful\n//I thought there had to be some mistake when every source\n//said you have to multiply the difference by n because\n//when I did that the curve \"looked wrong\" but it was just scaled\n//properly according to the gradient \n\n\n//Looks Legit according to:\n//https://www.google.com/imgres?imgurl=https%3A%2F%2Fpeople.eecs.berkeley.edu%2F~sequin%2FCS284%2FIMGS%2Fbezier_hodograph.gif&imgrefurl=https%3A%2F%2Fpeople.eecs.berkeley.edu%2F~sequin%2FCS284%2FLECT12%2FL3.html&tbnid=OrMwiwUL8Pr-yM&vet=12ahUKEwiO_YvSxLTxAhXMWKwKHf2jDZcQMygKegUIARDKAQ..i&docid=Mu9GR-_iDH6WNM&w=1083&h=594&q=bezier%20curve%20derivative%20example&ved=2ahUKEwiO_YvSxLTxAhXMWKwKHf2jDZcQMygKegUIARDKAQ\n\n#define numSegments 20.\n#define showSeg\n/*\n//black and light blue\n#define bgCol   vec3(244, 244, 248)/255.\n#define lineCol vec3(254, 215, 102)/255.*0.\n#define segCol vec3(42, 183, 202)/255.\n#define circleCol vec3(42, 183, 202)/255.\n#define segCircleCol vec3(210., 81., 224.)/255.\n#define magikCol vec3(142,142,246)/255.\n*/\n\n\n//Cappacino pallet\n#define bgCol   vec3(60, 47, 47)/255.*0.5\n#define lineCol vec3(133, 68, 66)/255.\n#define segCol vec3(225, 244, 230)/255.\n#define circleCol vec3(255, 244, 230)/255.\n#define segCircleCol vec3(255, 244, 230)/255.\n#define magikCol vec3(60, 47, 47)/255.\n\n#define lineThickness 0.004\n#define gradLineThickness 0.004*3.\n#define segRingRadius 0.006\n#define gradRingRadius 0.03\n#define pointRingRadius 0.01\n\nfloat distToLine(vec2 A, vec2 B, vec2 p){\n    \n    vec2 PA = p - A;\n    vec2 BA = B - A;\n    float d = dot(PA,BA);\n    float t = clamp(d/(length(BA)*length(BA)),0., 1.);//Vektorprodukt\n    vec2 normal = PA - BA*t;\n    return length(normal);\n\n}\n\n\nvec3 drawRing(float radius, float thickness, vec2 p, vec2 off, vec3 col, vec3 ringCol){\n    \n    p -= off;\n    \n    float eps = 1./min(iResolution.x,iResolution.y);\n    \n    float circle = 1.-smoothstep(-eps, eps, \n    abs(radius - length(p))-thickness);\n    \n    col = mix(col, ringCol, circle);\n    \n    return col;\n}\n\nvec3 drawLine(vec2 A, vec2 B, vec2 p, vec3 col, vec3 lineColor, float th){\n\n    //float dist = 1.0-smoothstep(0.004, 0.005, distToLine(A, B, p));\n    float dist = distToLine(A, B, p);\n    dist = 1.0-smoothstep(0., fwidth(dist), dist - th);\n    return mix(col, lineColor, dist);\n}\n\n\n//shorten version thx iapafoto, original version with notes is below\n//but then I went and added a matrix version to it\nvec3 drawSegments(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec2 p4, vec3 col){\n    vec2 g, prev = p4;\n    float dt = 1./numSegments;  \n    \n    for(float t = dt; t <= 1.+dt; t+=dt){   \n    \n    \n        //Matrix Representation\n        vec4 T = vec4(1, t, t*t, t*t*t);\n        \n        //nice looking upper triangular matrix there. \n        \n        mat4 M = mat4(1,0,0,0, \n                     -3,3,0,0, \n                      3,-6,3,0, \n                     -1,3,-3,1);\n                     \n        //I wonder what's gonna happen...             \n        vec4 Px = vec4(p4.x,p3.x,p2.x,p1.x);\n        vec4 Py = vec4(p4.y,p3.y,p2.y,p1.y);\n        \n        //in glsl vector  * vector is component wise so to get the scalar product we need to use dot\n        //when the time comes! After the initial M*T (or P*M apparently?)\n        g.x = dot(M*T,Px); // is the same as dot(P*M,T)\n        g.y = dot(Py*M,T); //I flipped them for y just to show there is no difference\n        \n        \n        //or\n        //Mix functions, much smaller\n        //g = mix(p3,p2,t);\n        //g = mix(mix(mix(p4,p3,t), g, t), \n        //            mix(g, mix(p2,p1,t), t), t);\n        \n        \n        //or \n        //Binomial\n        //g = p1*(t*t*t) + p2*3.*(1.-t)*(t*t) + p3*3.*(1.-t)*(1.-t)*(t) + p4*(1.-t)*(1.-t)*(1.-t);\n        \n        col = drawLine(prev,g,p,col,segCol*vec3(t, .7, .9),lineThickness);\n        col = drawRing(segRingRadius, .003, p, g, col, segCircleCol);\n        prev = g;\n    }\n    return col;\n}\n\n//find tangent\nvec3 drawTangentLine(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec2 p4, float t, vec3 col){\n    vec2 g1,g2,beforeT, afterT;\n    float EPS = 0.001;\n    \n    float t0 = max(t-EPS,0.);\n    float t1 = min(t+EPS,1.);\n    \n    \n    g1 = p1*(t*t) + p2*2.*(1.-t)*t + p3*(1.-t)*(1.-t);\n    g2 = p2*(t*t) + p3*2.*(1.-t)*t + p4*(1.-t)*(1.-t);\n\n\n    //get the direction so I can extend the line\n    vec2 dir = normalize(g2-g1);\n    \n    //extend the line in both directions past the end of screen\n    g1 += dir*10.;\n    g2 += dir*(-10.);\n    \n    //draw that line\n    col = drawLine(g1,g2,p,col,segCol*vec3(t, .7, .9),lineThickness);\n    return col;\n}\n   \n//derivative segment function\n//n-1 order bezier \nvec3 drawBezierDerivative(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec2 p4, vec3 col){\n    vec2 g1,g2,gEnd, prev = p1;\n    float dt = 1./numSegments;  \n    \n    //this could be wrong\n    float t = 0.;\n    //g1 = p1*(t*t) + p2*2.*(1.-t)*t + p3*(1.-t)*(1.-t);\n    //g2 = p2*(t*t) + p3*2.*(1.-t)*t + p4*(1.-t)*(1.-t);\n    //prev = g2-g1;\n    \n    prev = (p2-p1)*(t*t) + (p3-p2)*2.*(1.-t)*t + (p4-p3)*(1.-t)*(1.-t);\n    prev*=3.;\n    for(float t = dt; t <= 1.+dt; t+=dt){   \n    \n        //g1 = p1*(t*t) + p2*2.*(1.-t)*t + p3*(1.-t)*(1.-t);\n        //g2 = p2*(t*t) + p3*2.*(1.-t)*t + p4*(1.-t)*(1.-t);\n\n        gEnd = (p2-p1)*(t*t) + (p3-p2)*2.*(1.-t)*t + (p4-p3)*(1.-t)*(1.-t);\n        //(g2-g1);\n        gEnd*=3.;\n        col = drawLine(prev,gEnd,p,col,segCol*vec3(t, .7, .9),gradLineThickness);\n        col = drawRing(gradRingRadius, .003, p, gEnd, col, segCircleCol);\n        \n        prev = gEnd;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 st = uv;\n    uv.y*=2.;\n    \n    //splitting screen into two sides\n    float side = step(0.,uv.x);\n    uv.x = mod(uv.x*2.,2.)-1.;\n    \n    float x =0.4, y=1.2, z=2.6, w=3.;\n    float eps = 1./min(iResolution.x, iResolution.y);\n    vec2 p1 = vec2(-0.6, -0.3) + vec2(sin(iTime/2.+x),cos(iTime/2.+x))/5.;\n    vec2 p2 = vec2(-0.5, 0.3) + vec2(sin(iTime+y),cos(iTime+y))/10.;\n    vec2 p3 = vec2(0.5, 0.3) + vec2(sin(iTime+z),cos(iTime+z))/7.;\n    vec2 p4 = vec2(0.1, -0.2) + vec2(sin(iTime/2.+w),cos(iTime/2.+w))/2.;\n    \n    float t = sin(iTime)*0.5+0.5;\n    \n    vec2 dLinePoint1 = p1*t + (1.0-t)*p2;\n    vec2 dLinePoint2 = p2*t + (1.0-t)*p3;\n    vec2 dLinePoint3 = p3*t + (1.0-t)*p4;\n    \n    vec2 ddPoint1 = dLinePoint1*t + (1.0-t)*dLinePoint2;\n    vec2 ddPoint2 = dLinePoint2*t + (1.0-t)*dLinePoint3;\n    \n    vec2 dddPoint = ddPoint1*t + (1.0-t)*ddPoint2;\n    \n   \n    \n    vec3 col = bgCol;\n    col = drawLine(vec2(0.,-1.),vec2(0., 1.),st,col,lineCol*0.,lineThickness);\n    //col = drawLine(vec2(-2.,0.),vec2(2.,0.),st,col,lineCol*0.);\n    // Time varying pixel color\n    vec3 magik_farber = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)/4.);\n    \n    if(side == 0.){\n    col = drawLine(p1,p2,uv,col,lineCol*0.5,lineThickness);\n    col = drawLine(p2,p3,uv,col,lineCol*0.5,lineThickness);\n    col = drawLine(p3,p4,uv,col,lineCol*0.5,lineThickness);\n    col = drawLine(dLinePoint1,dLinePoint2,uv,col,lineCol*0.7,lineThickness);\n    col = drawLine(dLinePoint2,dLinePoint3,uv,col,lineCol*0.7,lineThickness);\n    col = drawLine(ddPoint1,ddPoint2,uv,col,lineCol,lineThickness);\n    \n    col = drawRing(0.01, 0.003, uv, p1, col, lineCol);\n    col = drawRing(0.01, 0.003, uv, p2, col, lineCol);\n    col = drawRing(0.01, 0.003, uv, p3, col, lineCol);\n    col = drawRing(0.01, 0.003, uv, p4, col, lineCol);\n    \n    col = drawRing(0.01, 0.003, uv, dLinePoint1, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, dLinePoint2, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, dLinePoint3, col, circleCol);\n    col = drawRing(0.01, 0.003, uv, ddPoint1, col, magikCol);\n    col = drawRing(0.01, 0.003, uv, ddPoint2, col, magikCol);\n    \n    \n    col = drawSegments(uv, p1, p2, p3, p4, col);\n    \n    //Marker\n    col = drawRing(0.02+(0.01+sin(iTime*4.)*0.01), 0.003, uv, dddPoint, col, magik_farber);\n    \n    \n    col = drawTangentLine(uv, p1, p2, p3, p4, t, col);\n   }\n   else{\n   \n   //scaling up the space so all of the derivative shows up\n   uv*=3.;\n   col = vec3(0.1);\n   col = drawBezierDerivative(uv,p1,p2,p3,p4,col);\n   \n   //calculating the derivative again just for the marker\n   vec2 g1 = p1*(t*t) + p2*2.*(1.-t)*t + p3*(1.-t)*(1.-t);\n   vec2 g2 = p2*(t*t) + p3*2.*(1.-t)*t + p4*(1.-t)*(1.-t);\n   \n   //vec2 gEnd = g2-g1; <- this works too btw but you need *3. after!\n   vec2 gEnd; \n   \n   //second more compact way\n   gEnd = (p2-p1)*(t*t) + (p3-p2)*2.*(1.-t)*t + (p4-p3)*(1.-t)*(1.-t);\n   //(g2-g1);\n   \n   gEnd*=3.;\n   \n   col = drawRing(0.02+(0.01+sin(iTime*4.)*0.01), 0.003, uv, gEnd, col, magik_farber);\n    \n   }\n   col = pow(col, vec3(0.75));\n    \n   \n\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    // Output to screen\n    fragColor = vec4(col*vig*1.1,1.0);\n}","name":"Image","description":"","type":"image"}]}