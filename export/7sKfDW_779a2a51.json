{"ver":"0.1","info":{"id":"7sKfDW","date":"1658225887","viewed":39,"name":"Balonsesto","username":"enrique","description":"Balonsesto","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["balonsesto"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Surface {\n  float sd;\n  vec3 color;\n};\nconst float ShootTimeLoop = 3.*3.1416;\nconst float ShootTimeTrigger = 2.*3.1416;\nconst float ShootDuration = 2.55;\nfloat shootiTime = 0.;\nfloat startShootTime = 0.;\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2; // The sd component of the struct holds the \"signed distance\" value\n  return obj1;\n}\n\nSurface maxWithColor(Surface obj1, Surface obj2) {\n  if (obj2.sd > obj1.sd) return obj2; // The sd component of the struct holds the \"signed distance\" value\n  return obj1;\n}\n\nSurface sminWithColor(Surface obj1, Surface obj2, float k, float k2) {\n  float h = clamp(0.5 + 0.5*(obj1.sd-obj2.sd)/k, 0.0, 1.0);\n  return Surface(mix(obj1.sd, obj2.sd, h) - k*h*(1.0-h),mix(obj1.color, obj2.color, h) - vec3(k2*h*(1.0-h)));\n  //vec3 mincolor = obj2.sd < obj1.sd ? obj2.color : obj1.color;\n  //return Surface(mix(obj1.sd, obj2.sd, h) - k*h*(1.0-h),mincolor);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\n\nvec3 rotate(vec3 r, vec3 p)\n{\n    mat3 roll = mat3(vec3(1.0, 0.0, 0.0),\n                   vec3(0.0,cos(r.z),sin(r.z)),\n                   vec3(0.0,-sin(r.z),cos(r.z))\n    );\n    mat3 pitch = mat3(vec3(cos(r.y), 0.0, -sin(r.y)),\n                   vec3(0.0,1.0,0.0),\n                   vec3(sin(r.y),0.0,cos(r.y))\n    );\n    mat3 yaw = mat3(vec3(cos(r.x),sin(r.x), 0.0),\n                   vec3(-sin(r.x),cos(r.x),0.0),\n                   vec3(0.0,0.0,1.0)\n    );\n    \n    return yaw*pitch*roll*p;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 parabolicMovement(vec3 origin, vec3 v0)\n{\n    float t = shootiTime-startShootTime;\n    return vec3(\n    origin.x+(v0.x*t),\n    origin.y+(v0.y*t)+(0.5*9.8*t*t),\n    origin.z+(v0.z*t)\n    );\n}\n\nSurface map(vec3 pos) {    \n    //Ball\n    vec3 ballmovement =  rotate(vec3(0.,0.,2.*iTime),pos + vec3(sin(iTime),-abs(sin(3.*iTime)),0.));\n    if(shootiTime>ShootTimeTrigger && shootiTime<ShootTimeTrigger+ShootDuration)\n    {\n        ballmovement =  rotate(vec3(0.,0.,-5.*iTime),pos+parabolicMovement(vec3(0.,0.,0.),vec3(0.,-13.,3.8)));   \n    }\n    //vec3 ballmovement = pos+vec3(0.,0.,0.);\n    Surface s1 = Surface(sdSphere(ballmovement, .4),vec3(0.98, 0.51, 0.1));\n    Surface toruscut = Surface(sdTorus(ballmovement,vec2(0.4,0.02)),vec3(0., 0., 0.));\n    toruscut = minWithColor(toruscut,Surface(sdTorus(rotate(vec3(90.,0.,0.),ballmovement),vec2(0.4,0.02)),vec3(0., 0., 0.)));\n    toruscut = minWithColor(toruscut,Surface(sdTorus(rotate(vec3(-90.,0.,0.),ballmovement),vec2(0.4,0.02)),vec3(0., 0., 0.)));\n    s1 = maxWithColor(s1,Surface(-toruscut.sd,toruscut.color));\n    //floor\n    vec3 outsidefield = vec3(step(abs(pos).x,5.)*step(abs(pos).z,10.)); \n    vec3 insidefield = vec3(step(abs(pos).x,4.5)*step(abs(pos).z,9.5));\n    vec3 line = outsidefield - insidefield;\n    line += vec3(step(abs(pos).x,5.)*step(abs(pos).z,.1));\n    line += 1.-vec3(step(.1,abs(length(pos)-2.)));\n    line += vec3(step(length(pos),.3));\n    line = clamp(line,0.,1.);\n    vec3 floorcolor = (line*vec3(2.,2.,2.)) + \n                      (insidefield*vec3(0.,0.5,.5*(sin(3.*iTime)+1.5))) +\n                      ((1.-outsidefield)*mix(vec3(.7, 0.1,0.1),vec3(.5, 0.1,0.1),clamp(-pos.z*.05,0.,1.)));\n    Surface p = Surface(sdPlane(pos, normalize(vec3(0.,1.,0\n    )),0.2),floorcolor);\n    //basket\n    vec3 tableropos = (pos+vec3(0.,-4.,9.8))/vec3(1.5,1.,1.);//normalizing x\n    vec3 tablerored = 1.-vec3(step(abs(tableropos).x,.9)*step(abs(tableropos).y,.9));\n    vec3 tablerolineoffset = vec3(0.,0.1,0.);\n    vec3 tablerooutside = vec3(step(abs(tableropos+tablerolineoffset).x,.4)*step(abs(tableropos+tablerolineoffset).y,.4));\n    vec3 tableroinside = vec3(step(abs(tableropos+tablerolineoffset).x,.3)*step(abs(tableropos+tablerolineoffset).y,.3));\n    vec3 tableroline = tablerooutside - tableroinside;\n    tablerored += tableroline;\n    vec3 tablerowhite = 1.-tablerored;\n    \n    vec3 tablerocolor = tablerored * vec3(1.,0.,0.) + tablerowhite* vec3(2.,2.,2.);\n    Surface c1 = Surface(sdCappedCylinder(pos+vec3(0.,0.,10.),.2,4.),vec3(2.,2.,0.));\n    c1 = minWithColor(c1,Surface(sdBox(pos+vec3(0.,-4.,9.8\n    ),vec3(1.6,1.1,0.1)),/*vec3(3.,3.,3.)*/tablerocolor));\n    c1 = minWithColor(c1,Surface(sdTorus(pos+vec3(0.,-3.5,9\n    ),vec2(.7,0.06)),vec3(1.,0.,0.)));\n    \n    \n    return minWithColor(c1,minWithColor(s1,p));\n    //return sminWithColor(p,s1,.1, 1.);\n}\n\nvec3 calcNormal(vec3 pos) {\n    vec2 eps = vec2(0.0001, 0.0);\n    Surface s = map(pos);\n    float h = s.sd;\n    return normalize(vec3(\n        map(pos + eps.xyy).sd - h,\n        map(pos + eps.yxy).sd - h,\n        map(pos + eps.yyx).sd - h\n    ));\n}\n\nvec3 getSky(vec2 uv)\n{\n    float atmosphere = sqrt(1.0-uv.y);\n    vec3 skyColor = vec3(0.2,0.4,0.8);\n    return mix(skyColor,vec3(1.0),atmosphere / 1.3);\n}\n\nSurface rayMarch(vec3 co, vec3 rd)\n{\n    float tot_dist = 0.;    \n    Surface s;\n    for (int t = 0; t < 512; ++t) {\n        vec3 pos = co + tot_dist * rd;\n        s = map(pos);\n        float h = s.sd;\n        tot_dist += h;\n        if (h < 0.0001) {\n            break;\n        }\n    }\n    s.sd = tot_dist;\n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.);\n    \n    vec3 co = vec3(sin(iTime+0.5), .5,1.5);\n    vec3 ct = vec3(0., 1., 0.);\n    vec3 cam_ww = normalize(ct - co);\n    \n    shootiTime = mod(iTime,ShootTimeLoop);\n    vec3 debug = vec3(clamp(5.*((shootiTime/ShootTimeTrigger)-1.),0.,1.));\n    if(shootiTime>ShootTimeTrigger && shootiTime<ShootTimeTrigger+ShootDuration)\n    {\n        startShootTime = ShootTimeTrigger;\n        co = mix(co,-parabolicMovement(vec3(0,-2.,-1.5),vec3(0.,-13.,3.8)),clamp(2.5*((shootiTime/ShootTimeTrigger)-1.),0.,1.));\n        cam_ww =  mix(cam_ww,normalize(vec3(0.,-.5,-1.)),clamp(2.5*((shootiTime/ShootTimeTrigger)-1.),0.,1.));\n    }\n   \n   \n    vec3 cam_uu = normalize(cross(cam_ww, vec3(0., 1., 0.)));\n    vec3 cam_vv = normalize(cross(cam_uu, cam_ww));\n    \n    vec3 rd = normalize(\n        uv.x * cam_uu + \n        uv.y * cam_vv + \n        1.   * cam_ww\n    );\n    \n    float maxRenderDistance = 1000.;\n    \n    Surface hitSurface = rayMarch(co,rd);\n    vec3 skyColor = getSky(uv);\n    if(hitSurface.sd<maxRenderDistance)//max render distance\n    {\n       vec3 color = hitSurface.color;\n       vec3 pos = co + hitSurface.sd * rd;\n       vec3 N = calcNormal(pos);\n       vec3 R = reflect(rd, N);                       \n\n        vec3 L = normalize(vec3( 0.5, -1,-0.5));\n\n        float kA = 1.;\n        vec3 iA = vec3(.01);\n        vec3 cA = kA * iA;\n\n        float kD = 1.;\n        vec3 iD = vec3(0.7, 0.5, 0);\n        vec3 cD = color*kD*vec3(clamp(dot(N, -L), 0.2, 1.));\n        \n        //disclaimer hard shadows no tengo muy claro lo que hago pero mola\n        vec3 shadowOrigin = pos + N * 0.001 * 2.;\n        Surface shadowHit = rayMarch(shadowOrigin, -L);\n        if (shadowHit.sd<maxRenderDistance){\n            cD = cD*vec3(0.5);\n        }\n        \n        vec3 RL = reflect(L, N);\n        vec3 V = -rd;\n        float kS = .2;\n        vec3 cS = kS*vec3(pow(clamp(dot(RL, V), 0., 1.), 300.0));\n\n        float j = 0.01;\n        float ao = clamp(map(pos + N*j).sd/j,0.,1.);\n\n        col = vec3(ao) * (cA+cD+cS);\n        \n    }\n    else\n    {\n        //col = texture(iChannel0, rd).rgb;\n        col = skyColor;\n    }\n    \n   \n    float d = 0.3;\n    vec3 fogcolor = vec3(.7,.7,.9);\n    col = mix( col, skyColor, 1.0-exp( -0.0001*hitSurface.sd*hitSurface.sd*hitSurface.sd ) );\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}