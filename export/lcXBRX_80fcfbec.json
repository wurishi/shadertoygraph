{"ver":"0.1","info":{"id":"lcXBRX","date":"1724120113","viewed":22,"name":"Orbiting Circular Windows 2","username":"trismegistus_shandy","description":"Four circular windows, two onto the function in \"Overlaid Circles\" and two on a simpler variation thereof, varying in size and distance over time, counterrotating, and intermittently overlapping.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","circle","orbit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.1415926535897932;\n\nconst float timescale1 = 3.;\nconst float timescale2 = 5.;\nconst float timescale3 = 11.;\n\n// Return numbers that vary in a sine curve between  0 and 1\nfloat positive_sine( float f )\n{\n    return (sin(f) + 1.0 ) / 2.0;\n}\n\nfloat wobble( float speed ) {\n    return positive_sine( iTime * speed );\n}\n\n\n//https://iquilezles.org/articles/palettes/\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.657);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvec3 wobble_palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3( wobble(2.),\n                   wobble(3.) + pi/3.,\n                   wobble(5.) + pi/5. );\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n\n\n\nvec2 hmirror( in vec2 coord) {\n    vec2 mirrored;\n    if ( coord.x < 0.0 ) {\n        mirrored = vec2(((coord.x + 1.0) / 2.0), coord.y);\n    } else {\n        mirrored = vec2((( 1.0 -coord.x) / 2.0), coord.y);\n    }\n    return mirrored;\n}\n\nvec2 vmirror( in vec2 coord) {\n    vec2 mirrored;\n    if ( coord.y < 0.0 ) {\n        mirrored = vec2(coord.x, ((coord.y + 1.0) / 2.0) );\n    } else {\n        mirrored = vec2(coord.x, (( 1.0 - coord.y) / 2.0) );\n    }\n    return mirrored;\n}\n\n\nvec2 multiply_complex( vec2 p, vec2 q ) {\n    float realpart = p.x * q.x - p.y * q.y;\n    float imaginarypart = p.x * q.y + p.y * q.x;\n    return vec2( realpart, imaginarypart );\n}\n\n\nvec2 rotate( vec2 coord, float angle ) {\n    vec2 rotator = vec2( sin(angle), cos(angle) );\n    vec2 rotated = multiply_complex( coord, rotator );\n    return rotated;\n}\n\n\nvec3 threelayers( vec2 coord ) {\n    vec2 uv = coord;\n    vec2 uv0 = coord;\n    vec3 finalColor = vec3(0.0, 0.0, 0.0 );\n    uv = fract(uv * 2.0) - 0.5;\n    vec2 uv2 = fract(uv0 * 3.5) - 0.5;\n    for ( float f = 0.0; f < 3.0; f += 1.0 ) {\n\n        float d = length( uv );\n        float d0 = length(uv0);\n        float d2 = length(uv2);\n        vec3 color = wobble_palette( d *  (wobble(2./pi) + 1.0) * 7.0 );\n        vec3 color2 = wobble_palette( abs(sin( d0 * (wobble(2./pi) + 1.0)*5.0)  ) );\n        vec3 color3 = wobble_palette( d2 * (wobble(2./pi)+1.0)*3.0 );\n        finalColor += color * color2 * color3;\n    }\n    return finalColor;\n}\n\n\nvec3 twolayers ( vec2 coord ) {\n    vec3 finalColor = vec3(0.0, 0.0, 0.0 );\n    vec2 coord2 = fract( coord * ( 2.0 + wobble(0.7)*3.) ) - 0.5;\n    float d = length(coord);\n    float d2 = length(coord2);\n    finalColor = wobble_palette( (d * wobble(0.15)) + 0.1) \n        * wobble_palette( (d2 * wobble(0.25)) + 0.17 );\n\n    return finalColor;\n\n}\n\n\nvec3 deeplayers ( vec2 coord ) {\n    vec3 finalColor = vec3(0.0, 0.0, 0.0 );\n    vec2 coord1 = fract( coord * ( 3.0 + wobble(0.4)*2.) ) - 0.5;\n    float d1 = length(coord);\n    vec2 coord2 = fract( coord * d1 * ( 6.0 + wobble(0.7)*3.) ) - 0.5;\n    float d2 = length(coord2);\n    finalColor = wobble_palette( d1 * wobble(0.21)) \n        * wobble_palette( d2 * wobble(0.34) );\n\n    return finalColor;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv0 = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    //vec2 uv_rot = rotate( uv0, positive_sine(iTime/timescale1) * pi * 2.);\n    vec2 uv_rot = rotate( uv0, iTime);\n    vec2 uv_rot2 = rotate( uv0, -iTime);\n\n    vec3 finalColor = vec3( 0., 0., 0. );\n\n    float offset = 0.25 + ( wobble(.3 ) * 0.25 );\n    float radius = 0.1  + ( wobble( .1 ) * 0.45 );\n\n    if ( length( uv_rot + offset ) < radius )\n    {\n        finalColor += threelayers( uv0 );\n    } \n\n    if (  length( uv_rot - offset ) < radius )\n    {\n        finalColor += threelayers( uv0 );\n    } \n\n    if ( length( uv_rot2 + offset ) < radius )\n    {\n        finalColor += deeplayers( uv0 );\n    } \n\n    if (  length( uv_rot2 - offset ) < radius )\n    {\n        finalColor += deeplayers( uv0 );\n    } \n\n    // Output to screen\n    fragColor = vec4(finalColor,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}