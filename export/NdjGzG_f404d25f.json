{"ver":"0.1","info":{"id":"NdjGzG","date":"1617570293","viewed":102,"name":"Revision 2021 sunday shader jam","username":"Exca","description":"Shader done for Revision 21 sundays shader jam.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","fft","cubes","revision"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Start the music in Buffer A\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n\tfragColor = texture(iChannel3, uv);\n    \n  \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//smoothing the fft a bit.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float s1 = texture(iChannel0,vec2(0.01,0.0)).r;\n    float s2 = texture(iChannel0,vec2(0.03,0.0)).r;\n    float s3 = texture(iChannel0,vec2(0.05,0.0)).r;\n    float sb = texture(iChannel1,vec2(0.4,0.0)).r*0.015;//decay\n       \n    float s = s1+s2+s3;\n    s*=0.33;\n\n    fragColor = vec4(sb+s,0.0,0.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nfloat fft = 0.0;\nfloat fftS = 0.0;\nfloat fftI = 0.0;\nfloat beat = 0.0;\nfloat beatStep = 0.0;\n\nvec3 repeat( vec3 p, vec3 c)\n{\n  vec3 q = mod( p+0.5*c, c)-0.5*c;\n  return q;\n}\n\nvec3 rotate( vec3 p, float x, float y, float z)\n{\n  mat3 rotx = mat3( 1.0, 0., 0, 0, cos(x), -sin(x),0, sin(x), cos(x));\n  mat3 roty = mat3( cos(y), 0, sin(y), 0,1,0, -sin(y), 0, cos(y));\n  mat3 rotz = mat3( cos(z), -sin(z), 0, sin(z), cos(z), 0,0,0,1);\n  return rotx*roty*rotz*p;\n}\n\nvec3 getcam( vec3 cam, vec3 target, vec2 uv, float fov)\n{\n  vec3 forward = normalize( target - cam );\n  vec3 right = normalize( cross( vec3(0,1,0), forward ));\n  vec3 up = normalize(cross( forward, right) );\n  \n  return normalize(vec3( uv.x * right + uv.y * up + fov*forward));\n}\n\nfloat prism( vec3 p, vec2 h)\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y, max(q.x*0.866025+p.y*0.5, -p.y) -h.x*0.5);\n}\n\nfloat roundcube(vec3 p, vec3 b, float r)\n{\n  vec3 d = abs(p) -b;\n  return min(max(d.x, max(d.y,d.z)),0.0)+length(max(d,0.0))-r;\n}\n\nfloat cube( vec3 p, vec3 size)\n{\n  vec3 q = abs(p)-size;\n  return length( max(q,0.0) + min( max(q.x, max(q.y,q.z) ), 0.0 ));\n}\n\nfloat sphere( vec3 p, float r)\n{\n  return length(p)- r;\n}\n\nvec3 map( vec3 p)\n{\n  float rx =beat*0.7+beatStep*0.1 + fftI*8.0;// smoothstep(0.0,0.85, mod(fftI*10.,1.0))*0.1;\n  float ry =beat*0.5+beatStep*0.1 + fftI*1.0;// smoothstep(0.0,0.85, mod(fftI*20.,1.0))*0.1;\n  float rz =beat*1.0+beatStep*0.1 + fftI*1.0;// smoothstep(0.0,0.85, mod(fftI*10.,1.0))*0.1;\n  \n  vec3 id = floor(p*0.5-0.5);\n  \n  vec3 cp = repeat( p, vec3( 2.0, 2.0, 2.0));\n  cp = rotate(cp, rx+id.x,ry+id.y,rz);\n  \n  float size = fract(id.x*100. + id.z*10.0+ id.y)*0.1;\n  \n  vec3 c =vec3(roundcube(cp,vec3(0.4+size), 0.025));\n  vec3 s = vec3(prism(cp,vec2(0.5+size)));\n  c.x = mix(c.x, s.x, mod(beat,2.0));\n  return c;\n}\n\nvec3 normal( vec3 p)\n{\n  vec3 c = map(p);\n  vec2 e = vec2(0.0001,0.0);\n  return normalize( vec3(\n    map(p+e.xyy).x,\n    map(p+e.yxy).x,\n    map(p+e.yyx).x\n  )-c.x);\n}\n\nfloat diffuse(vec3 p, vec3 l, vec3 n)\n{\n  return max( dot( n, normalize(l-p)), 0.0);\n}\n\nvec3 march( vec3 cam, vec3 rd, out float t)\n{\n  t= 0.0;\n  for(int i = 0; i < 100; i++)\n  {\n    vec3 p = cam + rd*t;\n    vec3 r = map(p);\n    float bx = cube(\n      repeat( p + vec3(1.0), vec3(2.0,0,0)),\n      vec3(0.00001,100,100));\n    float bz = cube(\n      repeat( p + vec3(1.0), vec3(0.0,0,2)),\n      vec3(100,100,0.00001));\n    float by = cube(\n      repeat( p + vec3(1.0), vec3(0.0,2,0)),\n      vec3(100,0.0001,100));\n    \n    float delta = min(max(0.1, bx), r.x);\n    delta = min( max(0.1, bz), delta);\n    delta = min( max(0.1, by), delta);\n    \n    if(r.x < 0.001)\n    {\n      return r;\n    }\n    t+=delta*0.9;\n    if(t> 10.0) return vec3(-1);\n\n  }\n  return vec3(-1);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 suv =fragCoord/iResolution.xy;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  vec4 col = vec4(0.);\n  \n  //For some reason this does not work with repeat on?\n  vec4 previous = texture(iChannel3, 1.-suv );\n  \n  beat = floor( iTime*2.0);\n  beatStep = fract( iTime*2.0);\n  \n  // for now smoothed fft is used for all, as having multiple sounds plays multiple times.\n  fft = texture(iChannel0, vec2(0.05,0.5)).r;\n\tfftS = texture(iChannel0, vec2(0.2,0.5)).r*0.5;\n\t//fftI = texture(iChannel0, vec2(0.1,0.5)).r;\n\t\n  float bm = mod( beat/4.0, 6.0);\n  \n  float time = mod(iTime,100.0);\n  \n  vec3 cam = vec3(1,1,1);\n  float cabeat = floor(beat/8.0);\n  vec3 target = vec3(\n    sin(cabeat*11.4)*10.,\n    sin(cabeat*5.2)*10.,\n    sin(cabeat*3.46)*10.\n  );\n  \n  \n  if(bm < 0.5) {\n    cam.x += time;\n    target.x+=time;\n  }\n  else if(bm < 1.5) {\n    cam.y += time;\n    target.y+=time;\n  }\n  else if(bm < 2.5) {\n    cam.z += time;\n    target.z+=time;\n  }\n  else if(bm < 3.5) {\n    cam.z -= time;\n    target.z-=time;\n  }\n  else if(bm < 4.5) {\n    cam.x -= time;\n    target.x-=time;\n  }\n  \n  vec3 light = vec3(0,4, sin(iTime));\n  vec3 rd = getcam(cam, target, uv, 1.0);\n  \n  vec3 bg = vec3(1.0, 0.7,0.2);\n  if(bm < 0.5) {\n    bg *= 0.0;\n  }\n  else if(bm < 1.5) {\n    bg *= fft;\n  }\n  else if(bm < 2.5) {\n    \n  }\n  else if(bm < 3.5) {\n    cam.z -= time;\n    target.z-=time;\n  }\n  else if(bm < 4.5) {\n    cam.x -= time;\n    target.x-=time;\n  }\n  \n  \n  \n  \n  float travel = 0.0;\n  vec3 r = march(cam, rd, travel);\n  vec3 p = cam + rd*travel;\n  if(r.y < -0.5)\n  {\n    // bg\n    \n  }\n  else if(r.y < 0.5)\n  {\n    vec3 n = normal(p);\n    col.rgb =vec3( 1.0,0.5,0.2) * (0.25+diffuse(p, light, n)) * (fftS+0.2);\n    \n    \n    \n    vec3 refd = reflect( rd, n);\n    float reft = 0.0;\n    vec3 refr = march( p + n*0.1, refd, reft);\n    vec3 refc = vec3(0.0);\n    vec3 refp = reft *refd + p+n*0.1;\n    if(refr.y < -0.5){}\n    else if(refr.y < 0.5){\n      vec3 rn = normal(p);\n      refc.rgb =vec3( 1.0,0.5,0.2) * (0.25+diffuse(refp, light, rn)) * (fftS+0.5);\n      refc.rgb *=1.0+ 15.0 / length(  100.*sin(fftI - refp.x*5.0+time) ) * (0.2+fftS);\n      refc.rgb *=1.0+ 15.0 / length(  100.*sin(fftI - refp.z*5.0-time) ) * (0.2+fftS);\n    }\n    refc.rgb = mix(refc, bg, smoothstep( 8.0, 10.0, reft));\n    col.rgb = mix(col.rgb, refc, 0.5);\n    col.rgb *=1.0+ 15.0 / length(  100.*sin(fftI - p.x*5.0+time) ) * (0.2+fftS);\n    col.rgb *=1.0+ 15.0 / length(  100.*sin(fftI - p.z*5.0-time) ) * (0.2+fftS);\n  }\n  \n  col.rgb = mix(col.rgb, bg, smoothstep( 8.0, 9.0, travel));\n  \n  if(bm < 0.5) col.rgb = col.rbg;\n  else if(bm < 1.5) col.rgb = col.brg;\n  else if(bm < 2.5) col.rgb = col.bgr;\n  else if(bm < 3.5) col.rgb = col.gbr;\n  else if(bm < 4.5) col.rgb = col.grb;\n  \n  col.rgb += previous.rgb*smoothstep(0.5, 0.0, fftS)*0.5;\n  \n\tfragColor = col;\n    \n  \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//continous fft.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float s = texture(iChannel0,uv).r/55.;\n    float sb = texture(iChannel1,uv).r/55.;\n    \n    fragColor = vec4(sb+s,0.0,1.0,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}