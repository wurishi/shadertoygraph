{"ver":"0.1","info":{"id":"M3dSW8","date":"1718988189","viewed":45,"name":"First ShaderToy_","username":"L1x3N","description":"Source : https://www.youtube.com/watch?v=u5HAYVHsasc","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader : prend des paramètres en entrée et renvoie une couleur RGBA pour chaque pixel\n// Prend notamment en paramètre les coordonnées (fragCoord) du pixel, de 0 à 1\n// Compiler le code une fois les modifs effectuées\n\n// Utiliser fragColor pour définir la couleur renvoyée\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Position normalisée (de 0 à 1) des pixels\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    // GESTION DES UVs\n    \n    // Noir (O en R, G et B)\n    // fragColor = vec4(0, 0, 0, 1.0);\n    \n    // Colorisation de la position des pixels en X et Y (0 pas de couleur, 1 pleine couleur)\n    // fragColor = vec4(uv.x, uv.y, 0, 1.0);\n    \n    // Dégradé en x -> position horizontale, en RGB -> blanc\n    // fragColor = vec4(vec3(uv.x), 1.0);\n    \n    \n    // Fraction du temps -> 0 à 1 puis 0\n    // fragColor = vec4(vec3(fract(iTime)), 1.0); \n    \n    \n    // Fraction du temps + position horizontale\n    fragColor = vec4(vec3(fract(iTime + uv.x)), 1.0);\n    \n    // Fraction du temps + position verticale\n    // fragColor = vec4(vec3(fract(iTime + uv.y)), 1.0);\n    \n    // Fraction du temps + position diagonale\n    // fragColor = vec4(vec3(fract(iTime + uv.x + uv.y)), 1.0); \n    \n    \n    // Fraction du temps + position horizontale & verticale séparéees\n    // fragColor = vec4(vec2(fract(iTime + uv.xy)), 0, 1.0);\n    \n    // Fraction du temps + position horizontale & verticale + bleu combiné\n    // fragColor = vec4(vec2(fract(iTime + uv.xy)), fract(iTime + uv.x) + fract(iTime + uv.y), 1.0);\n    \n    // Fraction du temps + position horizontale & verticale + bleu diagonale\n    // fragColor = vec4(vec2(fract(iTime + uv.xy)), fract(iTime + uv.x + uv.y), 1.0); \n    \n    // Fraction du temps + position horizontale & verticale égales (ajout + moyenne)\n    // fragColor = vec4(vec3(fract(iTime + uv.x) + fract(iTime + uv.y)) / 2., 1.0);\n    \n    \n    \n    // DISTANCE DES UVs\n    \n    // Distance au coin haut à droite\n    // fragColor = vec4(vec3(length(uv)), 1.0);\n    \n    // Double coin avec moyenne\n    // fragColor = vec4( (1. - (vec3(length(uv) / 2. + length(1. - uv) / 2.))) * 3., 1.0);\n    \n    \n    // Décalage de la position, de -0.5 à 0.5 (du coin en haut à droite vers le milieu)\n    vec2 newUvs = uv - 0.5;\n    \n    // Aspect ratio avec l'écran\n    newUvs.x *= iResolution.x / iResolution.y;\n    \n    \n    // Distance de cette position avec 0, 0 -> cercle dégradé au milieu\n    // fragColor = vec4(vec3(length(newUvs)), 1.0);\n    \n    // Animation du cercle avec la fraction du temps \n    // fragColor = vec4(animCircle, 1.0);\n    \n    // Smoothstep pour flouter / éclaircir le passage entre les bords noir / blanc\n    // Variable float pour le nombre de cercles\n    \n    float nbCircles = 2.5;\n    vec3 animCircle = vec3(fract( (length(newUvs) + iTime / nbCircles) * nbCircles ));\n    fragColor = vec4( smoothstep(0.25, 1., animCircle), 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}