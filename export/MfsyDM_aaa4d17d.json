{"ver":"0.1","info":{"id":"MfsyDM","date":"1721208290","viewed":84,"name":"Psychedelic Ray Marching","username":"Nykse","description":"A psychedelic visual with ray marching","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","psychedelic","fractals","psy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Credits :\n//      - https://www.shadertoy.com/view/ttKGDt\n//      - https://www.shadertoy.com/view/MtScWW\n\nconst float pi = acos(-1.0);\nconst float pi2 = pi*2.0;\n\n// Rotate with mouse on Y axes\nvec3 rotatevecY( vec3 vec, float angle )\n{\n    vec3 m0 = vec3( -cos( angle ), 0, sin( angle ));\n    vec3 m1 = vec3( 0            , 1.0,   0      );\n    vec3 m2 = vec3( sin( angle ), 0, cos( angle ) );\n    \n    return vec3(  dot( m0, vec ), dot( m1, vec ), dot( m2, vec )) ;\n} \n\n// https://iquilezles.org/articles/palettes/\n// Format : r + g*cos( 6.28318*(b*t+a) );\nvec3 palette(float t) {\n    vec3 r = vec3(0.5);\n    vec3 g = vec3(0.7);\n    vec3 b = vec3(0.75,0.2,0.75);\n    vec3 a = vec3(0.,0.75, 0.);\n    return r+g*cos(6.28318*(b*t+a));\n}\n\n// Rotation matrix\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\n// Angle modulo\nvec2 pmod(vec2 p, float r) {\n    float a = atan(p.x, p.y) + pi/r;\n    float n = pi2 / r;\n    a = floor(a/n)*n;\n    return p*rot(-a);\n}\n\n// Define the shape (see \"Common\")\nfloat SDF( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return sdSphere(d, .5);\n}\n\n// Some functions on rays\nfloat applyRay(vec3 p) {\n    //p.x += sin(iTime);\n    //p.z = smoothstep(-2., 2., p.z);\n    \n    for (int i=0; i<5; i++) {\n        p = abs(p) - 1.0;\n        //p.xy *= rot(iTime*0.15);\n        p.xz *= rot(iTime*0.05);\n    }\n    p.xz *= rot(iTime * .5);\n    return SDF(p, vec3(0.4,0.5,0.3));\n}\n\nfloat map(vec3 p, vec3 cPos) {\n    // Camera on Z axes\n    p.z += iTime * 1.;\n    \n    p.x = mod(p.x-5., 10.) - 5.;\n    p.y = mod(p.y-5., 10.) - 5.;\n    p.z = mod(p.z, 16.)-8.;\n    \n    // Number of fractals branches\n    p.xy = pmod(p.xy, 10.0);\n    \n    return applyRay(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    // Initialize the ray : origin, direction and color\n    vec3 ro = vec3(0., 0., -3.);\n    vec3 rd = normalize(vec3(uv, 1));\n    vec3 col = vec3(0);\n    \n    // If you want to turn one the X axes of the mouse\n    //ro = rotatevecY( ro, iMouse.x / iResolution.x * 8.0 );\n    //rd = rotatevecY( rd, iMouse.x / iResolution.x * 8.0  );\n\n    float t = 0.;\n    float borne = 100.;\n    float offset = -0.1;\n    float acc = 0.0;\n\n    int i; // Raymarching\n    for (i = 0; i < 80; i++) {\n        // Actaul ray position\n        vec3 p = ro + rd * t;\n        \n        // Apply borne\n        if (-borne <= p.x && p.x <= borne)\n            p.x = sin(pi * p.x / 3.);\n        else\n            p.x = 0.;\n            \n        if (-borne <= p.y && p.y <= borne)\n            p.y = sin(pi * p.y / 3.);\n        else\n            p.y = 0.;\n        \n        // Renforce the ray\n        t += cos(t*.2)*.1;\n        \n        // Rotate the ray on Z axes\n        p.xy *= rot(t * .15);\n\n        //p.y += tan(t*(0.+1.)*.5)*.35;\n        //p.x += tan(t*(0.+1.)*.5)*.35;\n        \n        // Phantom mode\n        float d = map(p, ro);\n        d = max(abs(d), 0.03);\n        \n        // March the ray\n        t += d * .5;\n        \n        // Accumulator for the color\n        float a = exp(-d*2.);\n        acc += a;\n        \n        // If the ray touch nothing, we stop\n        if (d < .001 || t > 100.) break;\n    }\n\n    // Apply color with the accumulator\n    col = palette(acc*.05 + float(i)*.006);\n\n    fragColor = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Fonctions SDF utilisables (on peut en ajouter d'autres) : https://iquilezles.org/articles/distfunctions\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n","name":"Common","description":"","type":"common"}]}