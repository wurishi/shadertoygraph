{"ver":"0.1","info":{"id":"4tcBDN","date":"1539880471","viewed":137,"name":"Cartoon Sun","username":"Shadeyboi","description":"Part of our character project, I chose to make a cartoony sun with an orbiting \"planet.\" Any suggestions to improve the code would be appreciated!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["beginner"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n//FUNCTIONS!!!\n//\n//\n    \nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\nfloat sphere(vec3 v, float r){\n  return length(v)-r;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat mixColors(float r, float v, float z){\n    return clamp(.5 + .5 * (v-r) / z, 0., 1.);\n}\n\n//CHARACTER\n//\n//\n\n\nShape character(vec3 c){\n  Shape shape;\n  shape.dist = 1000.; // Draw Distance\n  shape.color = vec4(1.); // Initial Color\n    \n  vec3 w = c; //Torus around sphere of face\n  vec3 h = c; //Head is the sphere in the middle\n  vec3 l = c; //Links/rays around the sun in polar\n  vec3 e = c; //Ellipse eyes for blinking\n  vec3 m = c; //Mouth (a box)\n  vec3 i = c; //Small spheres inside ellipse for eyes\n    \n    //Making the torus face the camera\n    vec4 wColor = vec4(1., .8, 0., 1.); //Yellow-Orange?\n    w.yz *= rot(radians(90.));\n    float wheel = sdTorus(w+vec3(0., 0., 0.), vec2(.75, .4));\n    \n    //Making the head\n    vec4 hColor = vec4(1., .6, 0., 1.); //Dark Orange-y Color\n    float head = sphere(h, .75);\n    \n    //Rotating and duplicating the links into polar\n    vec4 lColor = vec4(1., sin(iTime)*.2+.7, 0., 1.);\n    l.xy *= rot(sin(iTime)*.3);\n    pModPolar(l.yx, 6.);\n    float links = fBox(l-vec3(1., abs(sin(iTime*.75))*1.5, -.1), vec3(.9, .6, .0));\n    \n    //Molding the links/rays into the torus to make a connected figure\n    float unit = fOpUnionRound(wheel, links, .2);\n    \n    //Oscillate blinking eyes & mirror them\n    vec4 eColor = vec4(1., 0., 0., 1.); //Red\n    e.x = abs(e.x)-.3;\n    float eye = sdEllipsoid(e+vec3(.0, -.1, 0.7), vec3(.23, abs(sin(iTime))*.15, .6));\n    \n    //Curve the mouth to look less creepy\n    m.xy *= rot(2.*m.x);\n    float mouth = fBox(m+vec3(0., 0.35, .6), vec3(.1, .02, .2));\n    \n    //Doubling the spheres to make eyes\n    vec4 iColor = vec4(1., 1., 0., 1.);\n    i.x = abs(i.x)-.3;\n    float iris = sphere(i+vec3(.03, -.1, .5), .1);\n    \n    shape.dist = min(unit, head);\n    shape.dist = max(shape.dist, -eye); //Cuts out eye part and mouth\n    shape.dist = max(shape.dist, -mouth);\n    shape.dist = min(shape.dist, iris);\n    \n    shape.color = mix(hColor, wColor*1.4,\n                      mixColors(wheel, head, .6));\n    shape.color = mix(shape.color, eColor,\n                      mixColors(eye, shape.dist, .9));\n    shape.color = mix(shape.color, lColor,\n                      mixColors(links, shape.dist, .1));\n    shape.color = mix(shape.color, iColor*1.6,\n                      mixColors(iris, shape.dist, .1));\n    \n  return shape;\n}\n\nShape bg(vec3 b){\n    Shape shape;\n    shape.dist = 1000.;\n    //shape.color = vec4(1.);\n    \n  vec3 o = b;\n  vec3 r = b; //Circling rays\n    \n    vec4 oColor = vec4(0., abs(cos(iTime*.5))+.6, .7, 0.);\n    float orbit = sphere(o+vec3(sin(iTime)*3., sin(cos(iTime)), cos(iTime)*2.), .3);\n\n    vec4 rColor = vec4(1., 1., 0., 1.);\n    r.xy *= rot(iTime*.1);\n    pModPolar(r.xy, 12.);\n    r.xy *= rot(5.*r.y);\n    float ray = fBox(r-vec3(.4, .5, .5), vec3(1., .5, 0.));\n    \n    shape.dist = min(orbit, ray);\n    shape.color = mix(oColor, rColor,\n                      mixColors(ray, orbit, 0.));\n \treturn shape;   \n}\n\nShape map(vec3 c){\n  Shape face = character(c);\n  Shape background = bg(c);\n    \n    face.dist = min(face.dist, background.dist);\n    face.color = mix(face.color, background.color,\n                     mixColors(background.dist, face.dist, .5));\n    \n  return face;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  vec3 cam = vec3(0., 0., -5.);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.0006){ //Creates the rings of color\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n  }\n}","name":"Image","description":"","type":"image"}]}