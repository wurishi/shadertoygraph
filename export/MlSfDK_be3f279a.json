{"ver":"0.1","info":{"id":"MlSfDK","date":"1517187177","viewed":164,"name":"Mandelbrot Green.","username":"Alazorth","description":"The mandelbrot fragshader is done! \nI am going to add zooming and panning.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//FRAGMENT SHADER\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define RE_START -2.\n//or float x = 2.0;\n//or float x - float(2);\n#define RE_END    1.\n#define IM_START -1.\n#define IM_END    1.\n#define MAX_ITER 64\n//const int MAX_ITER = 359;\n\n//fragCoord is current pixel\n//main loops the entire program every pixel\n\nvec2 simpleComplex(vec2 xy) {\n    vec2 result;\n    result.x = (RE_START + (xy.x/iResolution.x) * float(RE_END - RE_START));\n\tresult.y = (IM_START + (xy.y/iResolution.y) * float(IM_END - IM_START));\n\treturn result;        \n}\n\n//GLSL doesn't support while loops on old versions for some reason... ¯\\_(ツ)_/¯\nfloat fMbrot(vec2 c) {\n\t//vec2 zed;\n    //zed.x = 0.0;\n    //zed.y = 0.0;    \n    int n = 0;\n    float i = 0.;\n    vec2 z;\n    \n    for(i=0.;i<float(MAX_ITER);i++){\n        z = vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y) + c;\n    \tif(length(z)>2.) break;\n    }\n    return i;\n    \n    \n    \n    //https://www.varsitytutors.com/hotmath/hotmath_help/topics/absolute-value-complex-number\n    //for ( i; i < MAX_ITER; i++) {\n    //    if (sqrt(pow(zed.x,2.0) + pow(zed.y,2.0)) <= 2.0){  \n    //    \t//zed = zed*zed + c;\n    //    \tzed = vec2 (pow(zed.x,2.0)-pow(zed.y,2.0),2.0 *zed.x * zed.y);\n    //\t\tzed.x = (zed.x + c.x);\n    //\t\tzed.y = (zed.y + c.y);    \n\t//\t\t//http://mathworld.wolfram.com/ComplexAddition.html        \n\t//\t\tn+=1;\n    //    }\n    //    else {\n    //    \treturn n;\n    //        break;\n    //    }\n    //}\n    //return i;\n}\n    \n\nint wMbrot(vec2 c) { \n    vec2 zed;\n    zed.x = 0.0;\n    zed.y = 0.0;    \n    int n = 0;\n    //https://www.varsitytutors.com/hotmath/hotmath_help/topics/absolute-value-complex-number\n    while (sqrt(pow(zed.x,2.0) + pow(zed.y,2.0)) <= 2.0 && n < MAX_ITER) { \n        //zed = zed*zed + c;\n        zed = vec2 (pow(zed.x,2.0)-pow(zed.y,2.0),2.0 *zed.x * zed.y);\n    \tzed.x = (zed.x + c.x);\n    \tzed.y = (zed.y + c.y);    \n\t\t//http://mathworld.wolfram.com/ComplexAddition.html        \n\t\tn+=1;\n    }\n    return n;\n}\n\nvec4 nmap(float n) {\n\tvec3 colmap;\n    if (float(n) <= float(MAX_ITER)) {\n        float quotient = float(n) / float(MAX_ITER);\n        float color = clamp(quotient,0.,1.);\n        \tif (quotient > 0.5) {\n        \t// Close to the mandelbrot set the color changes from green to white \n \t\t\t\tcolmap = vec3(0.); //(color,1.,color);\n        \t}\n        \telse {\n                colmap = vec3(0.,color,0.);\n            }\n    }\n    return vec4(colmap,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //fragColor = vec4(0.,0.,0.,1.);\n\t\n    //vec2 reim = simpleComplex(fragCoord.xy);\n    //int n = fMbrot(reim);\n    \n    \n    \n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n\tfloat aspect = iResolution.y/iResolution.x;\n\tvec2 p = uv*2.-1.; // transform uv range(0-1) to be centered and normalized(-1-1)\n\tp.y*=aspect;\n    float n = fMbrot(p*2.); // *2. is the zoom value to create a variable for controlled by GUI\n    //float B = float(n)*8./float(MAX_ITER); \n\t//float B = float(n)/float(MAX_ITER);\n\t//vec4 color = hue2rgb(B);\n    float fn = float (n);\n    vec4 preColor = nmap(fn);\n    fragColor = preColor;\n    \n        \n                \n    \n    //fragColor = color;\n}","name":"Image","description":"","type":"image"}]}