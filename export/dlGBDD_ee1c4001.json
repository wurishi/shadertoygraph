{"ver":"0.1","info":{"id":"dlGBDD","date":"1702066981","viewed":123,"name":"ZCAM Tonemapper","username":"justjohn","description":"Experimental tonemapper based on the ZCAM color space. It has no hue shifts, no color clipping, and uses the full sRGB gamut, however this is not a cheap tonemap. It uses binary search to map out of gamut colors back into sRGB.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["hue","tonemapper","tonemap","srgb","clipping","zcam"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    MIT License\n\n    Copyright (c) 2023 John Payne\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n// eotf_pq parameters\nconst float Lp = 10000.0;\nconst float m1 = 2610.0 / 16384.0;\nconst float m2 = 1.7 * 2523.0 / 32.0;\nconst float c1 = 107.0 / 128.0;\nconst float c2 = 2413.0 / 128.0;\nconst float c3 = 2392.0 / 128.0;\n\nvec3 eotf_pq(vec3 x)\n{\n    x = sign(x) * pow(abs(x), vec3(1.0 / m2));\n    x = sign(x) * pow((abs(x) - c1) / (c2 - c3 * abs(x)), vec3(1.0 / m1)) * Lp;\n    return x;\n}\n\nvec3 eotf_pq_inverse(vec3 x)\n{\n    x /= Lp;\n    x = sign(x) * pow(abs(x), vec3(m1));\n    x = sign(x) * pow((c1 + c2 * abs(x)) / (1.0 + c3 * abs(x)), vec3(m2));\n    return x;\n}\n\n// XYZ <-> ICh parameters\nconst float W = 140.0;\nconst float b = 1.15;\nconst float g = 0.66;\n\nvec3 XYZ_to_ICh(vec3 XYZ)\n{\n    XYZ *= W;\n    XYZ.xy = vec2(b, g) * XYZ.xy - (vec2(b, g) - 1.0) * XYZ.zx;\n    \n    const mat3 XYZ_to_LMS = transpose(mat3(\n         0.41479,   0.579999, 0.014648,\n\t\t-0.20151,   1.12065,  0.0531008,\n\t\t-0.0166008, 0.2648,   0.66848));\n    \n    vec3 LMS = XYZ_to_LMS * XYZ;\n    LMS = eotf_pq_inverse(LMS);\n    \n    const mat3 LMS_to_Iab = transpose(mat3(\n        0.0,       1.0,      0.0,\n\t\t3.524,    -4.06671,  0.542708,\n\t\t0.199076,  1.0968,  -1.29588));\n    \n    vec3 Iab = LMS_to_Iab * LMS;\n    \n    float I = eotf_pq(vec3(Iab.x)).x / W;\n    float C = length(Iab.yz);\n    float h = atan(Iab.z, Iab.y);\n    return vec3(I, C, h);\n}\n\nvec3 ICh_to_XYZ(vec3 ICh)\n{\n    vec3 Iab;\n    Iab.x = eotf_pq_inverse(vec3(ICh.x * W)).x;\n    Iab.y = ICh.y * cos(ICh.z);\n    Iab.z = ICh.y * sin(ICh.z);\n    \n    const mat3 Iab_to_LMS = transpose(mat3(\n        1.0, 0.2772,  0.1161,\n\t\t1.0, 0.0,     0.0,\n\t\t1.0, 0.0426, -0.7538));\n    \n    vec3 LMS = Iab_to_LMS * Iab;\n    LMS = eotf_pq(LMS);\n    \n    const mat3 LMS_to_XYZ = transpose(mat3(\n         1.92423, -1.00479,  0.03765,\n\t\t 0.35032,  0.72648, -0.06538,\n\t\t-0.09098, -0.31273,  1.52277));\n    \n    vec3 XYZ = LMS_to_XYZ * LMS;\n    XYZ.x = (XYZ.x + (b - 1.0) * XYZ.z) / b;\n    XYZ.y = (XYZ.y + (g - 1.0) * XYZ.x) / g;\n    return XYZ / W;\n}\n\nconst mat3 XYZ_to_sRGB = transpose(mat3(\n     3.2404542, -1.5371385, -0.4985314,\n\t-0.9692660,  1.8760108,  0.0415560,\n\t 0.0556434, -0.2040259,  1.0572252));\n\nconst mat3 sRGB_to_XYZ = transpose(mat3(\n    0.4124564, 0.3575761, 0.1804375,\n\t0.2126729, 0.7151522, 0.0721750,\n\t0.0193339, 0.1191920, 0.9503041));\n\nbool in_sRGB_gamut(vec3 ICh)\n{\n    vec3 sRGB = XYZ_to_sRGB * ICh_to_XYZ(ICh);\n    return all(greaterThanEqual(sRGB, vec3(0.0))) && all(lessThanEqual(sRGB, vec3(1.0)));\n}\n\nvec3 tonemap(vec3 sRGB)\n{\n    vec3 ICh = XYZ_to_ICh(sRGB_to_XYZ * sRGB);\n    \n    const float s0 = 0.71;\n    const float s1 = 1.04;\n    const float p = 1.40;\n    const float t0 = 0.01;\n    float n = s1 * pow(ICh.x / (ICh.x + s0), p);\n    ICh.x = clamp(n * n / (n + t0), 0.0, 1.0);\n    \n    if (!in_sRGB_gamut(ICh))\n    {\n        float C = ICh.y;\n        ICh.y -= 0.5 * C;\n        \n        for (float i = 0.25; i >= 1.0 / 256.0; i *= 0.5)\n        {\n            ICh.y += (in_sRGB_gamut(ICh) ? i : -i) * C;\n        }\n    }\n    \n    return XYZ_to_sRGB * ICh_to_XYZ(ICh);\n}\n\nvec3 gamma_correct(vec3 linear)\n{\n\tbvec3 cutoff = lessThan(linear, vec3(0.0031308));\n\tvec3 higher = 1.055 * pow(linear, vec3(1.0 / 2.4)) - 0.055;\n\tvec3 lower = linear * 12.92;\n\treturn mix(higher, lower, cutoff);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n    vec2 position = vec2(uv.x - iTime * 0.2, uv.y);\n\n\tvec3 ICh = vec3(exp(position.y * 3.0) - 1.0, 0.07, position.x * 5.0);\n    vec3 sRGB = max(vec3(0.0), XYZ_to_sRGB * ICh_to_XYZ(ICh));\n\n    sRGB = uv.x < 0.5 ? sRGB : tonemap(sRGB);\n\n\tfragColor = vec4(gamma_correct(sRGB), 1.0);\n}","name":"Image","description":"","type":"image"}]}