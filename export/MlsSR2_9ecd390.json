{"ver":"0.1","info":{"id":"MlsSR2","date":"1438224169","viewed":182,"name":"Nano Hummus","username":"chronokun","description":"obligatory 3d ray march of an infinite lattice of balls floating in space with deliberately low iteration count for soupy look.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","balls"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//\n// Note: Made some changes suggested by FabriceNeyret2\n//\n\n// FabriceNeyret2 suggested 447 char version:\n/*\nfloat t = iTime;\n\nfloat dist(vec3 d)  {\n    vec3 c = d-d; float f;  \n    \n    for(int i = 0; i < 16; i++)\n    \tf = length( mod(c + vec3(cos(t),sin(t),t*5.), 4.) - 2.) - .8,\n        f > 0. ? c += d*f : c;\n    \n    return length(c*10.);\n}\n\n#define dir(p)     normalize(vec3((p)*R/R.y, 1))\n#define Q(s)       dir(p+s/R) * dist(dir(p+s/R))\n// #define Q(s)       dir(p+s/R) * sample(p+s/R)\n// #define sample(p)  dist(dir(p))\n\nvoid mainImage( out vec4 o, vec2 p ) {\n\tvec2 R = iResolution.xy, e=vec2(1,0);\n    \n    o = vec4(5.*sin(t)+5., 2.5, 0, 0) \n        * 5./dist(dir(p=p/R*2.-1.)) // sample(p)\n        * dot( .5+.5*normalize(cross(Q(-e.yx)-Q(e.yx), Q(-e)-Q(e))) , \n               vec3(1,2,.5)/2.3\n             ); \n}\n*/\n\n//\n\nfloat sSphere(vec3 p, vec3 o, float r)\n{\n\treturn(length(p-o)-r);   \n}\n\nfloat sScene(vec3 p)\n{\n    /*\n    p += vec3(cos(iTime)*10.0, sin(iTime) * 10.0, iTime * 50.0);\n    p = mod(p, vec3(40.0, 40.0, 40.0)) - vec3(20.0, 20.0, 20.0);\n \treturn(sSphere(p, vec3(0.0, 0.0, 0.0), 8.0));\n\t*/\n    \n    p += vec3(cos(iTime), sin(iTime), iTime * 5.);\t//\n    p = mod(p, vec3(4)) - vec3(2);\t\t\t\t\t\t\t\t\t\t// Scaled values to smaller numbers and\n \treturn(sSphere(p, vec3(0), .8));\t\t\t\t\t\t// more readable initializers\n}\n\nvec3 march(vec3 s, vec3 d, float t)\n{\n    return(s + (d*t));\n}\n\nfloat dist(vec3 s, vec3 d)\n{\n    //vec3 c = vec3(0.0, 0.0, 0.0);\n    vec3 c = s; // fixed s being unused, was supposed to be start location\n    \n    float l;\n    for(int i = 0; i < 16; ++i)\n    {\n    \tfloat f = sScene(c);\n        c = march(c, d, max(f, 1e-4));\n        l = length(c);\n        if(f < 0.0) break;\n    }\n    return(l);\n}\n\nvec3 dir(vec2 p)\n{\n    p.x *= iResolution.x / iResolution.y;\n\treturn(normalize(vec3(p, 1.0)));    \n}\n\nfloat sam(vec2 p)\n{\n    return(dist(vec3(p, 1.0), dir(p)));\n}\n\nvec3 draw(vec2 p)\n{\n    //vec2 e = vec2(1.0/iResolution.x, 1.0/iResolution.y);\n    vec2 e = 1./iResolution.xy; // shortened\n    \n    vec2 s[4];\n    s[0] = p + vec2(e.x, 0.0);\n    s[1] = p + vec2(0.0, e.y);\n    s[2] = p + vec2(-e.x, 0.0);\n    s[3] = p + vec2(0.0, -e.y);\n    vec3 q[4];\n    for(int i = 0; i < 4; ++i)\n    {\n    \tq[i] = dir(s[i]) * sam(s[i]);\n    }\n    //vec3 a = normalize(q[2]-q[0]);\n    //vec3 b = normalize(q[3]-q[1]);\n    vec3 a = (q[2]-q[0]); // removed redundant normalize\n    vec3 b = (q[3]-q[1]); // ''\n    vec3 n = (normalize(cross(b, a)) + vec3(1.0, 1.0, 1.0)) / 2.0;\n    \n    float l = dot(n, normalize(vec3(1.0, 2.0, 0.5)));\n    \n    vec3 c = vec3((sin(iTime)+1.0)/2.0, 0.25, 0.0) * l;\n    //c *= 50.0/sample(p);\n    c *= 5./sam(p); // scaled to match new smaller coords\n    \n    return(c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0) - vec2(1.0, 1.0);\n    \n    vec3 c = draw(uv);\n    \n    \n\tfragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}