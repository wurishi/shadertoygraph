{"ver":"0.1","info":{"id":"ssVGWW","date":"1631584228","viewed":32,"name":"French alien","username":"MrNegawisp","description":"CG MIPT course task1","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3  eye      = vec3 ( 0, 0, 5 );\nconst vec3  light    = vec3  ( 0.0, 1.50, 3.0 );\nconst int   maxSteps = 100;\nconst float eps      = 0.01;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat dSphere ( vec3 p, in vec3 c, in float r )\n{\n\treturn length ( p - c ) - r; // + 0.03 * sin(20.0*p.x + iTime);\n}\n\nfloat dEllips ( vec3 p, in vec3 c, in vec3 r)\n{\n    p = p-c;\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat dChin ( vec3 p, in vec3 c, in vec3 r1, in vec3 r2 )\n{\n    p = p-c;\n    vec3 r = r1 + p.y*r2;\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat dTorus ( vec3 p, float r, float width )\n{\n\tvec2\tq = vec2 ( length ( p.xz ) - r, p.y );\t\n\treturn length ( q ) - width;\n}\n\nfloat dVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\nfloat smax (float a, float b, float k)\n{\n    float f = pow(max(k - abs(a-b), 0.), 3.) / 6.*k*k;\n    return max(a, b) + f;\n}\n\nfloat sdf ( in vec3 p, in mat3 m )\n{\n    vec3 q = m * p;\n    \n    float headBase = dSphere(q, vec3(0,0,0), 0.9);\n    float mouth = dSphere(q, vec3(0, -0.6, 0.7), 0.08);\n    float chin  = dChin(q, vec3(0.,-0.56, 0.1), vec3(0.65, 0.5, 0.6), vec3(0.2, -0.1, 0.1));\n    \n    float hat1  =   dChin(q, vec3(0.,+0.80,-0.1), vec3(0.95, 0.6, 0.96), vec3(-0.1, 0.1, -0.1));\n    float hat2  =   dChin(q, vec3(0.,+1.27,-0.15), vec3(0.95, 0.3, 0.96), vec3(-0.1, 0.1, -0.1));\n    float hat3  = dSphere(q, vec3(0.,+0.92,-0.10), 0.3);\n    \n    float rightEyeSocket1 = dEllips(q, vec3(-0.6, -0.1, 0.7), vec3(0.3, 0.14, 0.15));\n    float  leftEyeSocket1 = dEllips(q, vec3(+0.6, -0.1, 0.7), vec3(0.3, 0.14, 0.15));\n    \n    float rightEye = dSphere(q, vec3(-0.2,-0.1,0.3), 0.4);\n    float  leftEye = dSphere(q, vec3(+0.2,-0.1,0.3), 0.4);\n    \n    float body = dVerticalCapsule(q-vec3(0.0, -2, -1.3), 2.5, 1.5);\n    \n\treturn\n        min(\n            smax(\n                min(\n                    max(\n                        min(\n                            smax(\n                                smin(headBase, chin, 10.),\n                                -min(leftEyeSocket1, rightEyeSocket1),\n                                0.99),\n                            min(rightEye, leftEye)\n                        ),\n                        -mouth\n                    ),\n                    hat1\n                ),\n                -hat2,\n                0.999\n            ),\n            hat3\n        );\n}\n\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m );\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5, iMouse.z - 0.5);\n    mat3 rttnM = rotateX ( -6.0*mouse.y ) * rotateY ( 6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 1, 1, 1, 1 );\n    vec3 p     = trace ( eye, dir, hit, rttnM );\n\n\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, rttnM );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 200.0 );\n\t\t\n\t\tcolor = 0.5*vec4 (nl) + 0.0 * sp * vec4 ( 1, 1, 1, 1 );\n\t} \n\n    // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}