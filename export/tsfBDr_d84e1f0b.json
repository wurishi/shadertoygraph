{"ver":"0.1","info":{"id":"tsfBDr","date":"1588054935","viewed":93,"name":"sgasket","username":"blepfo","description":"Testing a function for mapping plane rectangles to the biunit square","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["ifs","sierpinski"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI (3.141)\n#define MAX_ITERATIONS  (128)\n\n// Translate\nvec2 translate(vec2 uv, vec2 t) {\n    return uv - t;\n}\n\n// 2d rotation matrix\nmat2 rotate2d(float theta) {\n    return mat2(cos(theta), -sin(theta),\n                sin(theta), cos(theta));\n}\n\n// Rectangle centered at (0, 0)\nfloat rectSdf(vec2 uv, vec2 halfSize) {\n    vec2 edgeDist = abs(uv) - halfSize;\n    float inDist = min(max(edgeDist.x, edgeDist.y), 0.);\n    float outDist = length(max(edgeDist, 0.));\n    return inDist + outDist;\n}\n\n// 1. if x in [a, b], else 0.\nfloat inInterval(float x, float a, float b) {\n    return step(a, x) - step(b, x);\n}\n\n// 1 if p in box centered at c, else 0.\nfloat inBox(vec2 p, vec2 c, vec2 halfSize) {\n    float xInBox = inInterval(p.x, c.x - halfSize.x, c.x + halfSize.x);\n    float yInBox = inInterval(p.y, c.y - halfSize.y, c.y + halfSize.y);\n    return xInBox * yInBox;\n}\n\nfloat AND(float a, float b) {\n    return a*b;\n}\n\nfloat NOT(float a) {\n    return 1. - a;\n}\n\n// Remap a square centered at c with given scale to the unit square\n// Useful for creating scaled replicas around the plane\nvec2 mapToUnitSquare(vec2 uv, vec2 c, vec2 scale) {\n    // Rescale so entire replication square maps to biunit square\n    vec2 scaleUv = uv.xy / scale.xy;\n    // Remap if in target square, but preserve biunit square\n    float inRemapBox = inBox(\n        scaleUv,\n        c,\n        vec2(1.)\n    );\n    float inUnitSquare = inBox(\n    \tuv,\n        vec2(0.), \n        vec2(1.)\n    );\n    float shouldRemap = AND(inRemapBox, NOT(inUnitSquare));\n    return\n        // If should remap, move back to origin\n        (shouldRemap * translate(scaleUv, c))\n        // Else return original coordinate for points outside biunit square\n        + (NOT(shouldRemap) * uv);\n}\n\n// Single Sierpinski IFS iteration\n// Scale space by 0.5, create 3 copies in triangle\nvec2 sierpinski1(vec2 uv) {\n    vec2 scaledCoords = (2.*uv) + vec2(0., -1.);\n    vec2 withIdentifiedBl = mapToUnitSquare(\n        scaledCoords,\n        vec2(-1, -2),\n        vec2(1.)\n    );\n    vec2 withIdentifiedBr = mapToUnitSquare(\n        withIdentifiedBl,\n        vec2(1, -2),\n        vec2(1.)\n    );\n    return withIdentifiedBr;\n}\n\n// N iterations of Sierpinski IFS\nvec2 sierpinskiCoords(vec2 uv, int iterations) {\n    for(int i = 0; i < MAX_ITERATIONS; i++) {\n        if (i >= iterations) { break; }\n        uv = sierpinski1(uv);\n    }\n    return uv;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    // Center at (0, 0) \n    uv = translate(uv, vec2(.5));\n    // Normalize dimensions\n    uv.x *= iResolution.x/iResolution.y;\n    // Rescale to unit square\n    uv = 2.*uv;\n    \n    float time = iTime * 1.5;\n    time = mod(time, PI*2.);\n    // Remap to [-globalScale -globalScale] x [globalScale, globalScale]\n    float globalScale = time;\n    vec2 scaleLayer = uv * globalScale;\n    scaleLayer *= rotate2d(time);\n    scaleLayer = fract(scaleLayer);\n    \n    scaleLayer = translate(scaleLayer, vec2(0.5,1.));\n    \n    // Mirror [0, 0] x [1, 1] in tiles acrros scaleLayer\n    vec2 tileLayer = fract(scaleLayer);\n   \n    vec2 sCoords = sierpinskiCoords(scaleLayer, 7);\n    float unitSquare = rectSdf(sCoords, vec2(1.));\n    float shape = step(0., unitSquare);\n\n    vec3 color = vec3(0.026,0.027,0.200);\n\tcolor = mix(color, vec3(0.374,0.541,0.990), (1.-shape));\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}