{"ver":"0.1","info":{"id":"WtBfDw","date":"1599044361","viewed":117,"name":"Broken-ass raymarching terrain","username":"Tatti","description":"Broken attempt at a raymarching terrain","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void rotate(inout vec3 vector, vec2 angle){\n\tvector.yz = cos(angle.y) * vector.yz + sin(angle.y) * vec2(-1, 1) * vector.zy;\n    vector.xz = cos(angle.x) * vector.xz + sin(angle.x) * vec2(-1, 1) * vector.zx;\n}\n\nfloat smoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sphereSdf(vec3 center, float radius, vec3 pos){\n\treturn length(center - pos) - radius;\n}\n\nfloat planeSdf(vec3 normal, float height, vec3 pos)\n{\n  \treturn dot(pos, normal) + height;\n}\n\nfloat repeatedSpheresSdf(float radius, vec3 pos) {\n    pos.x = mod(pos.x, 1.) - .5;\n    pos.z = mod(pos.z, 1.) - .5;\n    return sphereSdf(vec3(0), radius, pos);\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\nfloat noise(vec3 pos){\n    vec3 a = floor(pos);\n    vec3 d = pos - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat terrainSdf(vec3 pos) {\n    float r = 0.0;\n    float amp = 1.0;\n    float freq = 1.0;\n    for(int i = 0; i < 8; i++) {\n        r += amp * noise(freq*pos);\n        amp *= 0.5;\n        freq *= 1.0/0.5;\n    }\n    float d = planeSdf(vec3(0, 1, 0), 1., pos);\n    return d - 0.5*pow(r, 2.0);\n}\n\nfloat sceneSdf(vec3 pos){\n    float sphere = sphereSdf(vec3(sin(-iTime * 3.) * 2., -1, cos(-iTime * 3.) * 2.), 1., pos);\n    return smoothUnion(sphere, terrainSdf(pos), 1.);\n}\n\nfloat superellipsoidSdf(vec3 centre, float radius, float power, vec3 pos)\n{\n    pos = abs(pos-centre)/radius; // scale and sign-flip pos into a [0,1] range\n    pos = pow(pos,vec3(power)); // apply power before summing components\n    float d = dot(pos,vec3(1)); // add the components together\n\td = pow(d,1./power); // apply inverse power so SDF is well behaved\n    float fix = min(1.,.5+.5*(power-1.)); // corrective factor for lower powers, ensure gradient of SDF doesn't exceed 1.\n    return fix*(d-1.)*radius; // undo the scaling, to hit the desired radius\n}\n\nvec3 ray1(vec3 ray, vec3 pos){\n\tvec3 clearColor = vec3(0.55);\n\tvec3 colorToReturn = clearColor;\n    \n    for(int i = 0; i < 200; i++){\n    \tfloat h = sceneSdf(pos);\n        \n        if(length(pos) > 25.){\n            break;\n        }\n        \n        if(h < .01){\n        \tcolorToReturn = vec3(0);\n            break;\n        }\n        \n        pos += ray * h;\n    }\n    \n    if(sceneSdf(pos) < .01){\n    \tvec3 normal;\n        normal.x = sceneSdf(pos + vec3(.01, 0, 0)) - sceneSdf(pos - vec3(.01, 0, 0));\n        normal.y = sceneSdf(pos + vec3(0, .01, 0)) - sceneSdf(pos - vec3(0, .01, 0));\n        normal.z = sceneSdf(pos + vec3(0, 0, .01)) - sceneSdf(pos - vec3(0, 0, .01));\n        normal = normalize(normal);\n        \n        vec3 lightSource = vec3(4, 4, -4);\n        float light = max(.0, dot(normal, normalize(lightSource - pos)));\n        \n        vec3 ambient = vec3(.05, .1, .15);\n        vec3 lightCol = vec3(1., .9, .8);\n        \n        vec4 textureColor = texture(iChannel0, pos.xz);\n        colorToReturn = (light* .4 * lightCol + ambient) * 0.7;\n    }\n    \n    return pow(colorToReturn, vec3(1.0 / 2.2));\n}\n\nvec3 ray2(vec3 ray, vec3 pos){\n\tvec3 clearColor = vec3(0);\n\tvec3 colorToReturn = clearColor;\n    \n    for(int i = 0; i < 200; i++){\n    \tfloat h = repeatedSpheresSdf(0.02, pos);\n          \n        if(length(pos) > 10.){\n            break;\n        }\n        \n        if(h < .01){\n        \tcolorToReturn = vec3(0, 1, 1);\n            break;\n        }\n        \n        pos += ray * h;\n    }\n    \n    return colorToReturn;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ray = normalize(vec3((fragCoord-iResolution.xy * .5) / iResolution.x, 1.));\n    vec3 pos = vec3(0, 0, -8);\n    \n\tvec2 angle = vec2(iTime, .3);\n    \n    rotate(ray, angle);\n   \trotate(pos, angle);\n    \n    fragColor.rgb = ray1(ray, pos);\n    \n    vec3 ray2 = ray2(ray, pos);\n    \n    if(ray2 != vec3(0)){\n        fragColor.rgb = ray2;\n    }\n    \n    for(int i = 0; i < 200; i++){\n        float sprEl = superellipsoidSdf(vec3(0, 1, 0), .7,1. / (.5 + .48 * sin(iTime * 1.3)), pos);\n    \tfloat h = smoothUnion(sprEl, sphereSdf(vec3(0, sin(iTime) * 2., 0), .5, pos), 1.);\n       \n        if(h < .01){\n        \tfragColor.rgb *= vec3(.5, 2., 2.) * \n                texture(iChannel1, (fragCoord.xy / iResolution.xy)).xyz;\n            break;\n        }\n        \n        pos += ray * h;\n    }\n}","name":"Image","description":"","type":"image"}]}