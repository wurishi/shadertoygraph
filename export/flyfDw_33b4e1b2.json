{"ver":"0.1","info":{"id":"flyfDw","date":"1672763573","viewed":240,"name":"Aquatic Theme - JellyFish","username":"lz","description":"If the graphic permits it - go full screen. \nNumber of leg sections can be modified and antialiasing is by default off to benefit the frame rate.\nStarts dark but gets brighter. Takes about 2 minutes for the loop - though it never fully repeats itself.","likes":23,"published":1,"flags":96,"usePreview":0,"tags":["3d","raymarching","bezier","lod","jellyfish"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Aquatic Theme - JellyFish. \n    Leonid Zaides.\n    --\n    Buffer A contains the textures of the belly shape (I called it cap in the shader), the constants and per-frame parameters of the different types.\n    Buffer B performs the ray-tracing and the rendering.\n    \n    The tentacles of the jellyfish are made from bezier (2D). The maximum number of sections in the curve is defined in N_LEG_POINTS. The sections are\n    precomputed and stored in buffer A (one sequence per type). The actual number of sections used during ray tracing decreases with ray distance (LOD).\n    \n    The multi-sampling for AA was too heavy for full screen and for the most part I didnt' see any major issues with it so by default it is off.\n    Can be used if set to AA = 2 or above. AA = 1 and AA = 0 are equivalent in quality but AA = 1 uses the anti-aliasing function which takes more time\n    to compile so the default is AA = 0. \n    \n    First implementation used buffers for the per-frame parameters. Moving most of those to texture (in buffer A) significantly reduced the compilation time.\n    \n    The background is 2D. Shifting texture on move and for 3D feel. Applied motion blur on jump.\n*/\n\n// postprocessing and output\n\n#define TFC(CRD) texelFetch(iChannel1, ivec2(CRD),0)\n#define TEX(UV)  texture(iChannel1, UV)\n#define MAX_KRN_SIZE 6.\n\n// not used\nvec3 directionalSmooth(in vec2 uv, in ivec2 coords, out vec2 slope)\n{\n  vec3 col;\n  float kernel = 1.;\n  float sw = 0.;\n  vec2 dv;\n  \n  if (coords.x == 0 || coords.y == int(iResolution.x) - 1 ||\n      coords.y == 0 || coords.y == int(iResolution.y) - 1)\n      return col;\n  \n  if (TFC(coords + ivec2(1, 0)).a - TFC(coords - ivec2(1,0)).a < 0.25)\n      return col;\n      \n  if (TFC(coords + ivec2(0, 1)).a - TFC(coords - ivec2(0,1)).a < 0.25)\n      return col;\n  \n  for (float r = -kernel; r <= kernel; r++)\n      for (float c = -kernel; c <= kernel; c++)\n      {\n          float v = TFC(coords + ivec2(r, c)).w;\n          float w = 1./(1. + length(vec2(r,c)));\n          dv += w * v * vec2(r,c);\n          sw += w;\n      }\n  dv /= sw;\n  slope = vec2(-dv.y, dv.x);\n  //col = vec3(slope.x, slope.y, 0.);\n  \n  float nsmp = 3.;\n  float dt = 0.3;\n  sw = 0.;\n  for (float is = 1.; is <= nsmp; is++)\n  {\n      float w = 1./(1. + length(slope * is));\n      sw += w;\n      col += 0.5 * w * (TEX(uv + slope * is).rgb + TEX(uv - slope * is).rgb);\n  }\n  \n  col /= sw;\n      \n  return col;\n}\n\nvec3 distanceBasedSmooth(in float _dist, in vec3 _col, in ivec2 frag)\n{\n  float krnSize = floor(smoothstep(0., 0.25, _dist) * MAX_KRN_SIZE);\n  vec3 scol;\n  float sw = 0.;\n  float w = 0.;\n  for (int i = -int(krnSize); i <= int(krnSize); i++)\n  {\n      for (int j = -int(krnSize); j <= int(krnSize); j++)\n      {\n         vec3 ncol = TFC(frag + ivec2(i, j)).rgb;\n         w = 1.;\n         sw += w;\n         scol += w * ncol;\n      }\n  }\n  \n  scol /= sw;\n  \n  vec3 res = mix(_col, scol, krnSize/MAX_KRN_SIZE);\n  //res = vec3(krnSize/MAX_KRN_SIZE);\n  //res = _col;\n  return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    bool debugTexture = false;\n    vec4 col;\n    if (debugTexture)\n    {\n      col.rgb = texture(iChannel0, fragCoord.xy/iResolution.xy).rgb;\n    }\n    else\n    {\n        col = texture(iChannel1, fragCoord.xy/iResolution.xy);\n#ifndef _DEBUG\n        // still has a few bugs, so currently it's out\n        //vec2 slope;\n        //vec3 scol = directionalSmooth(uv, ivec2(fragCoord), slope);\n        //col.rgb = distanceBasedSmooth(col.w * col.w * col.w, col.rgb, ivec2(fragCoord));\n#endif\n        //col.rgb = (col.www);\n    }\n    \n    fragColor = col; \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n \n*/\n\n#define PI 3.14159265359\n#define PIH 1.57079632679\n#define PIQ 0.78539816339\n#define PIHX 0.19634954084\n#define PI2 6.28318530718\n#define SQRT3H 0.8660254037 \n\n// Number of sections in a tentacle\n#define N_LEG_POINTS 11\n\n// Number of different types of JellyFish\n#define N_CONFIGS 5\n\n// Max hits across a single ray\n#define MAX_TRANSPARENCY_LEVEL 4\n\n#define ROT2D(p2d, ang) (cos(ang) * p2d.xy + sin(ang) * vec2(p2d.y, -p2d.x))\n\n#define ANIM_T(_t, _e, _p) (smoothstep(_p - _e, _p, _t) - smoothstep(_p, _p + _e, _t))\n#define PULSE_T(_t, _e, _pa, _pb) (smoothstep(_pa - _e, _pa, _t) - smoothstep(_pb, _pb + _e, _t))\n#define ASYM_PULSE_T(_t, _ea, _pa, _eb, _pb) (smoothstep(_pa - _ea, _pa, _t) - smoothstep(_pb, _pb + _eb, _t))\n\n\n// The block (0,0) - (0.25, 0.25) in Buffer A is reserved for the precomputation of model parameters\n// The other space in the texture is for the CAP textures.\n#define U_JPARAMS_TBOUND 0.25\n// The nubmer below represent BufferA texture x-coordinate\n// Texture C column definitions\n#define TNT_CLR_0    0\n#define TNT_CLR_1    1\n#define CAP_TEX_CRD  2\n#define JLIGHT       3\n#define BCUP_COL     4\n\n// capHeight, blend, time, config\n#define JCAP_PARAMS  10\n#define JRIB_PARAMS  11\n#define JTNT_PARAMS  12\n#define JTIME_STATE  13\n#define JCAP_ANIM    14\n\n// \n#define JTLEG_START  15\n\n//\n//#define _DEBUG\n#define AA 0\n\nconst float cycleLen = 2.5;\nconst float waveLen = PI2 / cycleLen;\n\n// random\nfloat hash(in float s) {\n  return fract(5313.235 * mod(s, 0.78182) * mod(s, 0.1242));\n}\n\n// random 2 -> 1. take from somewhere here.\nfloat hash2(in vec2 st) {\n    return fract(sin(dot(st.xy,\n        vec2(113.9928,1178.243)))\n            * 4358.5475123);\n}\n\n// noise 1 -> 1\nfloat noise(in float s)\n{\n  float i = floor(s);\n  float f = fract(s);\n  \n  return mix(hash(i), hash(i + 1.0), f * f* (3.0 - 2.0 * f));\n}\n\n// noise 2 -> 1\nfloat noise (in vec2 st) {\nvec2 i = floor(st);\nvec2 f = fract(st);\n\n// Four corners in 2D of a tile\nfloat a = hash2(i);\nfloat b = hash2(i + vec2(1.0, 0.0));\nfloat c = hash2(i + vec2(0.0, 1.0));\nfloat d = hash2(i + vec2(1.0, 1.0));\n\n// Smooth Interpolation\n\n// Cubic Hermine Curve. Same as SmoothStep()\nvec2 u = f*f*(3.0-2.0*f);\n// u = smoothstep(0.,1.,f);\n\n// Mix 4 coorners porcentages\nreturn mix(a, b, u.x) +\n(c - a)* u.y * (1.0 - u.x) +\n(d - b) * u.x * u.y;\n}\n\n// random 3 -> 1 \n// (taken from somewhere here)\nfloat hash(in vec3 p)\n{\nreturn fract(sin(dot(p,\nvec3(12.6547, 765.3648, 78.653)))*43749.535);\n}\n\n// noise 3 -> 1\nfloat noise3(in vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = fract(p);\n\n    pf = pf*pf*(3.-2.*pf);\n\n    float a = hash(pi + vec3(0., 0., 0.));\n    float b = hash(pi + vec3(1., 0., 0.));\n    float c = hash(pi + vec3(0., 1., 0.));\n    float d = hash(pi + vec3(1., 1., 0.));\n\n    float e = hash(pi + vec3(0., 0., 1.));\n    float f = hash(pi + vec3(1., 0., 1.));\n    float g = hash(pi + vec3(0., 1., 1.));\n    float h = hash(pi + vec3(1., 1., 1.));\n\n    return mix(mix(mix(a,b,pf.x),mix(c,d,pf.x),pf.y),\n    mix(mix(e,f,pf.x),mix(g,h,pf.x),pf.y), pf.z);\n}\n\n\n\n// signed distance functions\n// most were taken from iq:\n// https://iquilezles.org/articles/distfunctions/\n//\nfloat sdShell( in float _f, in float _h)\n{\n  return max(_f, -_f - _h);\n}\n\nfloat sdSphere( vec3 _p, float _r )\n{\n  return length(_p)-_r;\n}\n\nfloat sdPlane(in vec3 _p, in vec3 _pp, in vec3 _n)\n{\n  return dot(_p - _pp, _n);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdToothYPlane(in vec3 _p, in vec3 _pp, in float _shift, in float _scl)\n{\n  float fpln = dot(_p - _pp, vec3(0., -1., 0.));\n  fpln -= _shift;\n  return fpln / (1. + 2. * _scl);\n}\n\nfloat sdIntersect(in float _f0, in float _f1)\n{\n  return max(_f0, _f1);\n}\n\nfloat sdUnion(in float _f0, in float _f1)\n{\n  return min(_f0, _f1);\n}\n\n// polynomial\nfloat sdSmUnion( float _f0, float _f1, float _k )\n{\n    float h = max( _k-abs(_f0-_f1), 0.0 )/_k;\n    return min( _f0, _f1 ) - h*h*_k*(1.0/4.0);\n}\n\nfloat sdExpSmin( float _f0, float _f1, float _k )\n{\n    float res = exp2( -_k*_f0 ) + exp2( -_k*_f1 );\n    return -log2( res )/_k;\n}\n\nfloat sdMax(in float _f1, in float _f2, in float _k)\n{\n  float df = _f1 - _f2;\n  return 0.5 * (_f1 + _f2 + sqrt(df * df + _k));\n}\n\n// returns distance from center of angular sections, radius, angle, ID\nvec4 sdAngularPattern(in vec2 _uv, in float _N, in float _phase)\n{\n  float alpha = _phase + atan(_uv.y, _uv.x);\n  float r = length(_uv);\n  vec2 uvec = vec2(cos(-PI/_N), sin(-PI/_N));\n  alpha = mix(alpha, -PI-(PI-alpha), step(0., alpha));\n  \n  float ialpha = floor((-alpha / PI2) * _N) / _N;\n  float falpha = -mod(abs(alpha), PI2/_N);\n  vec2 op = r*vec2(cos(falpha), sin(falpha));\n  \n  float dvec = dot(op, uvec);\n  float d = sqrt(r * r - dvec * dvec);\n  return vec4(d, r, falpha, ialpha);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// helpers\n// get tangent and bitangent. _hv assumed to be normalized\n/*void getTangents(in vec3 _n, in vec3 _hv, out vec3 _t, out vec3 _bt)\n{\n  vec3 hv = _hv;\n  if (dot(hv, _n) > 0.999)\n  {\n     hv = _hv.zxy;\n  }\n  \n  _t = normalize(cross(_n, hv));\n  _bt = normalize(cross(_bt, _t));\n}*/\n\n// _lookDir assumed to be normalized\n// returns cos phi and sin theta\nvoid getThetaPhi(in vec3 _lookDir, out float _th, out float _phi)\n{\n  const vec3 yAxis = vec3(0., 1., 0.);\n  const vec3 zAxis = vec3(0., 0., 1.);\n  \n  _phi = dot(_lookDir, yAxis);\n  vec3 xzDir = cross(zAxis, _lookDir - _phi * yAxis);\n  _th = dot(xzDir, yAxis);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"lljSzd","filepath":"https://soundcloud.com/novator_bez_agressii/timecop1983-it-was-only-a","previewfilepath":"https://soundcloud.com/novator_bez_agressii/timecop1983-it-was-only-a","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// precomputed buffers\n// Texture containing constant or per frame variables of the Jellies.\n// Precomputed shader constants such as tentacle colors to reduce compilation time.\n\nconst mat2 rot45 = mat2(0.70710678, 0.70710678, -0.70710678, 0.70710678);\n\nvec4 jellyfishCapTexture1(in vec2 _uv)\n{\n  vec4 c;\n  float r = length(_uv);\n  float t = atan(_uv.y, _uv.x);\n  \n  float rc = ANIM_T(r + 0.025*hash(t), 0.025, 0.275);\n  float rc1 = 0.16 * rc * noise(_uv * 100.);\n  float rc2 = 0.16 * rc * noise(vec2(_uv + vec2(23.,1.83)) * 64.);\n  float rc3 = 0.16 * rc * noise(vec2(_uv + vec2(11.,103.83)) * 32.);\n  rc = 2. * (rc2 + rc1 + rc3);\n  \n  vec4 angPattern = sdAngularPattern(_uv, 17., 0.);\n  float angLines = smoothstep(0., 0.1, angPattern.x);\n  float nfc = noise(sin(angPattern.xy)*100.) * noise(sin(angPattern.xy) * 27. + 32.) * noise(vec2(noise(angPattern.zx * 13.), noise(angPattern.zw * 57.)));\n  // basic color\n  vec3 col = vec3(1., 0.91, 0.95);\n  col.rgb -= rc * vec3(0.1, 0.9, 0.6); \n  \n  // Time enabled\n  float emissive = max(2.* ANIM_T(mod(iTime * 0.5, 2.5), 0.2, angPattern.y) * nfc * angPattern.y, 0.);\n  //float emissive = smoothstep(0., , angPattern.y);\n  col.rgb += emissive;\n  \n  float alpha = clamp(0.1 + rc + nfc + emissive + 0.2 * (angLines), 0., 1.);\n\n  return vec4(col, alpha);\n}\n\nvec4 jellyfishCapTexture2(in vec2 _uv)\n{\n  vec4 col = vec4(1.0, 0.2, 0.85, 0.35);\n  float r = length(_uv);\n  \n  col *= sqrt(1. - r);\n  \n   // circles \n  // first quarter + translate to origin.\n  vec2 cc = abs(_uv) - vec2(0.25);\n  \n  float tanim = ANIM_T(mod(iTime * 0.5, 2.5), 0.75, 1.25);\n  \n  // scale circle alog (1,1) to get an ellipse.\n  vec2 scc = rot45 * cc * vec2(1.5, 1.) * transpose(rot45) + vec2(0.25);\n  float lc = length(scc - vec2(0.25));\n  lc = ANIM_T(lc, 0.075, 0.23) + ANIM_T(lc, 0.075, 0.27);\n  col += (.5 + 3. * tanim) * col * lc * smoothstep(0.025, 0.5, r);\n  \n  return col;\n}\n\nvec4 jellyfishCapTexture3(in vec2 _uv)\n{\n  vec4 col = vec4(1.0, 0.5, 0.0, 0.5);\n  float r = length(_uv*.5);\n  \n  col *= (1. - r);\n\n  // animation timer\n  float at = mod(iTime*0.5, 5.);\n  \n  // circles\n  vec2 cc = abs(_uv);  \n  // the distance field (not precise).\n  float lc = dot(vec2(cc - 0.25) * mat2(5.5, 5.5, -2.5, 2.5), vec2(cc - 0.25));\n  \n  // thin contour\n  float thnCnt = ANIM_T(lc * lc, 0.05, 0.1);\n  \n  // thick contour\n  float thkCnt = ANIM_T(lc * lc, 0.085, 0.1);\n \n  vec2 ruv = vec2(abs(_uv.x), _uv.y) - vec2(0.3, 0.);\n  \n  // scale angle to range (1, 2)\n  float rang = atan(ruv.y, ruv.x)/PI + 1.5;\n  \n  // interpolated contour\n  float intCnt = thnCnt + (thkCnt - thnCnt) * PULSE_T(rang, 0.05, 1.05, 1.95);\n  \n  //    \n  col = mix(col, 2. * col, thnCnt) + intCnt * ANIM_T(rang, 0.2, at) * (col);\n  \n  return col;\n}\n\n#define CAP_TEX4_SECTIONS 12.0\nvec4 jellyfishCapTexture4(in vec2 _uv)\n{\n  float r = length(_uv*.5);\n  \n  vec4 col = mix(vec4(0.450383,0.29803,0.527975, 0.75), vec4(0.640015,0.375158,0.531326, 0.75), 1. - r);\n  \n  vec4 pat = sdAngularPattern(_uv, CAP_TEX4_SECTIONS, 0.);\n  vec2 fuv = pat.y * vec2(cos(pat.z), sin(pat.z));\n  \n  // triangle base point\n  vec2 suv = 0.7 * vec2(cos(-PI/CAP_TEX4_SECTIONS), sin(-PI/CAP_TEX4_SECTIONS));\n  \n  // triangle tip point\n  vec2 suv2 = 0.2 * vec2(cos(-PI/CAP_TEX4_SECTIONS), sin(-PI/CAP_TEX4_SECTIONS));\n  \n  float f1 = clamp(-3.*dot(fuv - suv, normalize(vec2(1., -PI/(CAP_TEX4_SECTIONS - 0.5)))), 0., 1.);\n  float f2 = clamp(3.*dot(fuv - suv2, normalize(vec2(1., -PI/(CAP_TEX4_SECTIONS - 0.5)))), 0., 1.);\n  float f3 = dot(normalize(fuv), normalize(suv - suv2));\n  \n  // random triangle id shift\n  float hid = floor(hash2(vec2(floor(iTime*4.), pat.w)) * CAP_TEX4_SECTIONS) / CAP_TEX4_SECTIONS;\n  \n  // updated from incoming sound.\n  float amp = 0.5 * texture(iChannel1, vec2(hid, 0.0)).x;\n  \n  float f = smoothstep(0.93, 1., f3)*f1*f2*amp;\n  col += vec4(1.)*f;\n  \n  return col;\n}\n\n\nvec4 jellyfishCapTexture5(in vec2 _uv)\n{\n  vec4 col = vec4(0.03137254901960784,0.18823529411764706,0.4196078431372549, 0.9);\n  float r = length(_uv*.5);\n  //col.rgb *= 1.5;\n  //col.rgb *= (1. - 0.75*r);\n  col.rgb = 2.2*(col*col).rgb;\n  col.a *= (0.9 + 0.1 * r);\n  \n  return col;\n}\n\nconst vec4 jFishCapTextureBounds1 = vec4(1.0, 0.5, 1.5, 1.0);\nconst vec4 jFishCapTextureBounds2 = vec4(0.5, 0.0, 1.0, 0.5);\nconst vec4 jFishCapTextureBounds3 = vec4(1.0, 0.0, 1.5, 0.5);\nconst vec4 jFishCapTextureBounds4 = vec4(0.0, 0.5, 0.5, 1.0);\nconst vec4 jFishCapTextureBounds5 = vec4(0.5, 0.5, 1.0, 1.0);\n\n// tentacle computation code\n\nstruct JFParams\n{\n  float capHeight;\n  float cpBlend;\n  float time;\n  int   config;\n  vec2  ribParams;\n  vec4  tentacles; // number, height, topWidth, bottomWidth\n  vec4  timeStates;\n  vec4  capParams; // top cap radius, top cap height from origin, side cap height, side cap radius\n  vec2  tCtrlPnts[4];\n  vec2  tPoints[N_LEG_POINTS];\n};\n\n#define SET_UJF_PARAMS(_cph, _blend0, _time, _cfg, _ribParams, _tentacles)   \\\n    jp.capHeight = _cph; jp.cpBlend = _blend0;              \\\n    jp.time = _time; jp.ribParams = _ribParams;             \\\n    jp.config = _cfg;                                              \\\n    jp.tentacles = _tentacles;                                     \\\n    jp.timeStates = vec4(ASYM_PULSE_T(mod(_time, 2.5), 1.75, 1.75, 0.75, 1.5),ASYM_PULSE_T(mod(_time - 0.025, 2.5), 1.75, 1.75, 0.75, 1.5),ASYM_PULSE_T(mod(_time - 0.5, 2.5), 1.75, 1.75, 0.75, 1.5),ASYM_PULSE_T(mod(_time - 0.75, 2.5), 1.75, 1.75, 0.75, 1.5));  \\\n    jp.capParams = vec4(2.5 + 1.2 * jp.timeStates[0], 1.5 + 1.6 * jp.timeStates[1],_cph + 0.3 * jp.timeStates[1], 0.); \\\n    jp.capParams.w = sqrt(jp.capParams.x * jp.capParams.x - jp.capParams.y * jp.capParams.y); \n\n\n\nvoid bezier(in vec2 _p0, in vec2 _p1, in vec2 _p2, in vec2 _p3, out vec2[N_LEG_POINTS] _sections)\n{\n  for (int i_sec = 0; i_sec < N_LEG_POINTS; i_sec++)\n  {\n    float t = float(i_sec) / float(N_LEG_POINTS - 1);\n\n    float negt = 1. - t;\n    \n    _sections[i_sec] = negt * negt * negt * _p0 + \n                       3. * t * negt * negt * _p1 +\n                       3. * t * t * negt * _p2 + \n                       t * t * t * _p3;\n                       \n  }\n}\n\nvoid bezierCoeffs(out vec4[N_LEG_POINTS] _coeffs)\n{\n  for (int i_sec = 0; i_sec < N_LEG_POINTS; i_sec++)\n  {\n    float t = float(i_sec) / float(N_LEG_POINTS - 1);\n\n    float negt = 1. - t;\n    \n    _coeffs[i_sec][0] = negt * negt * negt; \n    _coeffs[i_sec][1] = 3. * t * negt * negt;\n    _coeffs[i_sec][2] = 3. * t * t * negt; \n    _coeffs[i_sec][3] = t * t * t;\n                       \n  }\n}\n\nvoid bezierSections(in vec4[N_LEG_POINTS] _coeffs, in vec4 _px, in vec4 _py, out vec2[N_LEG_POINTS] _sections)\n{\n  for (int i_sec = 0; i_sec < N_LEG_POINTS; i_sec++)\n  {\n    _sections[i_sec].x = dot(_px, _coeffs[i_sec]);\n    _sections[i_sec].y = dot(_py, _coeffs[i_sec]);\n  }\n}\n\n#define c0(_t, _clen) vec2(r2, -h2 + 0.085 * ASYM_PULSE_T(mod(_t, _clen), 1.75, 1.75, 0.75, 1.5) )\n#define c1(_t, _tentLen, _c) vec2(r2 + 0. - _c*sin((waveLen)*_t + 0.15), -h2 -(0.4 + 0.3*cos((waveLen)*(-_t))) * _tentLen)\n#define c2(_t, _tentLen, _d, _e) vec2(r2 - (-_d - _d*sin((waveLen)*(_t + 1.))), -h2 -(_e - 0.2*cos((waveLen)*(_t + 1.))) * _tentLen)\n#define c3(_t, _tentLen, _a, _b) vec2(r2 + _a + _b * sin((waveLen)*(_t + 1.0)), -h2 - _tentLen *(1. - 0.2*ASYM_PULSE_T(mod(_t, cycleLen), 1.5, 1.5, 0.5, 1.5)) )\n\nvoid computeTntclsControlPoints(inout JFParams jp)\n{\n  for (int it = 0; it < N_CONFIGS; it++)\n  {\n    float h2 = jp.capParams.z;\n    float r2 = jp.capParams.w;\n    float scl = 0.3 * h2 * jp.timeStates.z;\n    r2 *= (1. + 0.5*scl);\n\n    float t = jp.time;\n    float tentLen = jp.tentacles.y;\n    \n    float as = 0.25 * tentLen, bs = 0.5 * tentLen, cs = 0.75 * tentLen;\n    float ds = 0.125 * tentLen, es = 0.175 * tentLen;\n    jp.tCtrlPnts[0] = c0(t, cycleLen);\n    jp.tCtrlPnts[1] = 0.5 * (c1(t, tentLen, cs) + c1(t - 0.1, tentLen, cs));\n    jp.tCtrlPnts[2] = 0.5 * (c2(t, tentLen, ds, es) + c2(t - 0.15, tentLen, ds, es));\n    jp.tCtrlPnts[3] = 0.5 * (c3(t, tentLen, as, bs) + c3(t - 0.25, tentLen, as, bs));\n  }\n}\n\n//\nvoid computeTntclsSpline(inout JFParams jp)\n{\n    for (int it = 0; it < N_CONFIGS; it++)\n    {\n        vec2 ctrlPnts[4] = jp.tCtrlPnts;\n        bezier(ctrlPnts[0], ctrlPnts[1], ctrlPnts[2], ctrlPnts[3], jp.tPoints);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float ratio = iResolution.x / iResolution.y;\n    float invRatio = 1./ratio;\n    vec2 rawUV = fragCoord/iResolution.y;\n    \n    //\n    ivec2 c = ivec2(fragCoord);\n    vec4 col;\n    JFParams jp;\n    \n    vec2 in_jfTexture1 = step(jFishCapTextureBounds1.xy, rawUV) - step(jFishCapTextureBounds1.zw, rawUV);\n    vec2 in_jfTexture2 = step(jFishCapTextureBounds2.xy, rawUV) - step(jFishCapTextureBounds2.zw, rawUV);\n    vec2 in_jfTexture3 = step(jFishCapTextureBounds3.xy, rawUV) - step(jFishCapTextureBounds3.zw, rawUV);\n    vec2 in_jfTexture4 = step(jFishCapTextureBounds4.xy, rawUV) - step(jFishCapTextureBounds4.zw, rawUV);\n    vec2 in_jfTexture5 = step(jFishCapTextureBounds5.xy, rawUV) - step(jFishCapTextureBounds5.zw, rawUV);\n    \n    col = vec4(0., 0., 0., 1.);\n    \n    if (in_jfTexture1.x * in_jfTexture1.y > 0.5)\n    {\n      vec2 tuv = 2. * (rawUV - jFishCapTextureBounds1.xy) / (jFishCapTextureBounds1.zw - jFishCapTextureBounds1.xy) - 1.;\n      col = jellyfishCapTexture1(tuv);\n    }\n    else if (in_jfTexture2.x * in_jfTexture2.y > 0.5)\n    {\n      vec2 tuv = 2. * (rawUV - jFishCapTextureBounds2.xy) / (jFishCapTextureBounds2.zw - jFishCapTextureBounds2.xy) - 1.;\n      col = jellyfishCapTexture2(tuv);\n    }\n    else if (in_jfTexture3.x * in_jfTexture3.y > 0.5)\n    {\n      vec2 tuv = 2. * (rawUV - jFishCapTextureBounds3.xy) / (jFishCapTextureBounds3.zw - jFishCapTextureBounds3.xy) - 1.;\n      col = jellyfishCapTexture3(tuv);\n    }\n    else if (in_jfTexture4.x * in_jfTexture4.y > 0.5)\n    {\n      vec2 tuv = 2. * (rawUV - jFishCapTextureBounds4.xy) / (jFishCapTextureBounds4.zw - jFishCapTextureBounds4.xy) - 1.;\n      col = jellyfishCapTexture4(tuv);\n    }\n    else if (in_jfTexture5.x * in_jfTexture5.y > 0.5)\n    {\n      vec2 tuv = 2. * (rawUV - jFishCapTextureBounds5.xy) / (jFishCapTextureBounds5.zw - jFishCapTextureBounds5.xy) - 1.;\n      col = jellyfishCapTexture5(tuv);\n    }\n    \n    //\n    if (c.x == TNT_CLR_0 && c.y == 0)\n      col.rgb = vec3(1., 0.91, 0.95);\n    else if (c.x == TNT_CLR_1 && c.y == 0)\n      col.rgb = vec3(0.55, 0.14, 0.51);\n    if (c.x == TNT_CLR_0 && c.y == 1)\n      col.rgb = vec3(0.0, 0.5, 1.0);\n    else if (c.x == TNT_CLR_1 && c.y == 1)\n      col.rgb = vec3(0.0, 0.25, 0.5);\n    if (c.x == TNT_CLR_0 && c.y == 2)\n      col.rgb = vec3(0.450383,0.29803,0.527975);\n    else if (c.x == TNT_CLR_1 && c.y == 2)\n      col.rgb = vec3(0.640015,0.375158,0.531326);\n    if (c.x == TNT_CLR_0 && c.y == 3)\n      col.rgb = vec3(1.0, 0.2, 0.85);\n    else if (c.x == TNT_CLR_1 && c.y == 3)\n      col.rgb = vec3(0.3, 0.05, 0.35);\n    if (c.x == TNT_CLR_0 && c.y == 4)\n      col.rgb = vec3(1.0, 0.5, 0.0);\n    else if (c.x == TNT_CLR_1 && c.y == 4)\n      col.rgb = vec3(1.0, 0.5, 0.0);\n    else if (c.x == CAP_TEX_CRD && c.y == 0)\n      col.rg = vec2(1.25, 0.75);\n    else if (c.x == CAP_TEX_CRD && c.y == 1)\n      col.rg = vec2(0.75, 0.75);\n     else if (c.x == CAP_TEX_CRD && c.y == 2)\n      col.rg = vec2(0.25, 0.75);\n    else if (c.x == CAP_TEX_CRD && c.y == 3)\n      col.rg = vec2(0.75, 0.25);\n    else if (c.x == CAP_TEX_CRD && c.y == 4)\n      col.rg = vec2(1.25, 0.25);\n    else if (c.x == JLIGHT && c.y == 0)\n      col = vec4(0., 0.25, 0.2, 0.);\n    else if (c.x == JLIGHT && c.y == 1)\n      col = vec4(0., 0.25, 0.1, 0.3);\n     else if (c.x == JLIGHT && c.y == 2)\n      col = vec4(0., 0.3, 0.3, 0.05);\n    else if (c.x == JLIGHT && c.y == 3)\n      col = vec4(0., 0.3, 0.15, 0.3);\n    else if (c.x == JLIGHT && c.y == 4)\n      col = vec4(0., 0.3, 0.3, 0.05);\n    else if (c.x == BCUP_COL && c.y == 1)\n      col = vec4(0.1, 0.41, 0.95, 1.0);\n    else if (c.x == BCUP_COL && c.y == 0)\n      col = vec4(1., 0.91, 0.95, 0.25);\n    else if (c.x == BCUP_COL && c.y == 2)\n      col = vec4(0.640015,0.375158,0.531326, 0.25);\n    else if (c.x == BCUP_COL && c.y == 4)\n      col = vec4(1.0, 0.5, 0.0, 0.25);\n    \n    if (c.y == 0)\n    {\n      SET_UJF_PARAMS(0.7, 0.25, iTime, 2, vec2(0.15, 4.0), vec4(7., 4., 0.07, 0.03));\n    }\n    else if (c.y == 1)\n    {\n      SET_UJF_PARAMS(0.7, 0.25, iTime * 0.75, 3, vec2(0.15, 2.0), vec4(27., 2.5, 0.06, 0.025));\n    }\n    else if (c.y == 2)\n    {\n      SET_UJF_PARAMS(0.8, 0.25, iTime * 1.25, 1, vec2(0.15, 3.5), vec4(5., 4.5, 0.07, 0.03));\n    }\n    else if (c.y == 3)\n    {\n      SET_UJF_PARAMS(0.7, 0.15, iTime * 3., 0, vec2(0.15, 4.0), vec4(79., .75, 0.06, 0.02));\n    }\n    else if (c.y == 4)\n    {\n      SET_UJF_PARAMS(0.75, 0.25, iTime * 0.9, 1, vec2(0.15, 2.6), vec4(17., 3., 0.09, 0.05));\n    }\n    \n    if (c.y < N_CONFIGS && rawUV.x < U_JPARAMS_TBOUND)\n    {\n      if (c.x == JCAP_PARAMS)\n          col = vec4(jp.capHeight, jp.cpBlend, jp.time, jp.config);\n      else if (c.x == JRIB_PARAMS)\n          col.rg = jp.ribParams;\n      else if (c.x == JTNT_PARAMS)\n          col = jp.tentacles;\n      else if (c.x == JTIME_STATE)\n          col = jp.timeStates;\n      else if (c.x == JCAP_ANIM)\n          col = jp.capParams;\n      \n      computeTntclsControlPoints(jp);\n      computeTntclsSpline(jp);\n      \n      if (c.x >= JTLEG_START && c.x < JTLEG_START + N_LEG_POINTS)\n          col.rg = jp.tPoints[c.x - JTLEG_START];\n    }\n\n    fragColor = vec4(col);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define M_ITER 256\n#define M_LIGHT_ITER 16\n#define T_EPS 0.0001\n#define FAR 60.\n#define N_EPS 0.0001\n\n#define TF(_R, _C) texelFetch(iChannel0, ivec2(_R, _C),0)\n\nmat4 baseMtx;\nmat4 invBaseMtx;\n\n// General per frame parameters\nvec3 jgrid;\nfloat hShift;\nfloat resRatio;\nfloat invResY;\nvec3 lookAt;\nfloat zoom;\n\nint getCellID(vec2 _cell)\n{\n  return int(hash2(_cell * 7.) * 4.9999);\n}\n\nvec4 jpattern(in vec3 _p, out int _cellID)\n{\n  vec3 c = jgrid;\n  // iq\n  vec2 ixz = floor((_p.xz + 0.5*c.xz) / (c.xz));\n  _cellID = getCellID(ixz);\n  \n  // y shift of each y column.\n  float yPhase = hash2(ixz * 123.461);\n  \n  // move speed of each y column.\n  float speedPhase = hash2(ixz * 2.9);\n\n  // time phase of each y column.\n  float timePhase = hash2(ixz * 131.345) * cycleLen;\n  \n  float cycleLen = 2.5;\n  float _t = TF(JCAP_PARAMS, _cellID).z;\n  \n  float iCycle = floor((_t + timePhase)/ cycleLen);\n  float fCycle = fract((_t + timePhase) / cycleLen);\n  \n  float move =  yPhase * jgrid.y + (1. + speedPhase) * (iCycle + 1.1 * smoothstep(0.2, 1., fCycle * fCycle) - 0.1 * smoothstep(0., 0.2, fCycle));\n\n  vec3 q = vec3(_p.x, _p.y - move, _p.z);\n  \n  vec3 p = mod(q+0.5*c,c)-0.5*c;\n  \n  return vec4(p, 0.);\n}\n\nfloat jellyfishCap(in vec3 _p, in int _cellID)\n{\n  vec4 capParams = TF(JCAP_ANIM, _cellID);\n  vec4 timeParams = TF(JTIME_STATE, _cellID);\n  \n  float r1 = capParams.x;\n  float h1 = capParams.y;\n  float h2 = capParams.z;\n  const float shellWidth = 0.001;\n  float scl = 0.3 * h2 * timeParams.y;\n  float scl2 = 0.3 * h2 * timeParams.z;\n  \n  float c = sdSphere(_p - vec3(0., -h1, 0.), r1);\n  float topSec = sdPlane(_p, vec3(0.), vec3(0., -1., 0.));\n  \n  float r2 = capParams.w * (1. + 0.5 * scl);\n  vec3  scl_p = _p;\n  \n  scl_p.xz *= (1. - scl2 * abs(_p.y));\n  \n  float c2 = sdSphere(scl_p, r2)/(1. + scl);\n  \n  // cap bottom waves\n  float tshift = 0.04 * (sin(8. * _p.x + 0.) + sin(8. * _p.z + 0.)); \n  float midSec = sdToothYPlane(scl_p, vec3(0., -h2, 0.), tshift, 0.04);\n  \n  c2 = sdMax(c, c2, 0.02);\n  c2 = sdShell(c2, shellWidth);\n  c2 = sdSmUnion(c2, -midSec, TF(JCAP_PARAMS, _cellID).y + 0.25 * timeParams.y);  \n  c2 = sdIntersect(c2, midSec + 0.15);\n  \n  return c2;\n}\n\nfloat jellyfishBCup(in vec3 _p, in int _cellID)\n{\n  float rxz = length(_p.xz);\n  vec4 capParams = TF(JCAP_ANIM, _cellID);\n  vec4 timeStates = TF(JTIME_STATE, _cellID);\n  float h2 = capParams.z;\n  float h2anim = h2 * timeStates.x * 0.15;\n  float scl = 3. * h2anim; \n  float r2 = capParams.w * (h2anim + 0.9);\n  _p.y += 0.25 * timeStates.y;\n  if (TF(JCAP_PARAMS, _cellID).w > 1.5)\n  {\n    _p.xz = ROT2D(_p.xz, rxz);\n    _p.y += max(0., 1.5 - rxz * (1.0 - scl)) * .025 * (sin(12. * _p.x + 0.) + 0.5 * sin(12. * _p.z + 0.));\n  }\n  \n  float f = sdEllipsoid(_p, vec3(r2, 0.18 + scl, r2));\n  \n  return 0.9* (f);\n}\n\nfloat jellyfishRibbons(in vec3 _p, in int _cellID, in bool _render)\n{\n  vec3 orig = _p;\n  vec2 ribParams = TF(JRIB_PARAMS, _cellID).rg;\n  float jtime = TF(JCAP_PARAMS, _cellID).z;\n  _p.y += ribParams.x;\n  // scale xz plane towards the center\n  _p.xz *= (1. + 1.*abs(_p.y)/ribParams.y);\n  float bAngRibbons = 5.;\n  float bRibDist = 0.6;\n  vec4 fAngRib = sdAngularPattern(_p.xz, bAngRibbons, PI2 / 5.);\n  vec2 sAngRibDir = vec2(cos(-PI/bAngRibbons), sin(-PI/bAngRibbons));\n  vec2 sPntRibDir = vec2(cos(fAngRib.z), sin(fAngRib.z));\n  \n  float dSide = (sAngRibDir.x * sPntRibDir.y - sPntRibDir.x * sAngRibDir.y) * 4.5;\n  \n  vec2 ribp = (fAngRib.y + 0.3 * sin(_p.y * 2. + jtime * waveLen) +  dSide * 0.1 * sin(_p.y*2.)) * sPntRibDir;\n  float frib = sdBox(vec3(ribp.x, _p.y, ribp.y) - vec3(bRibDist * sAngRibDir.x, -ribParams.y * 0.5 + 0.2, bRibDist * sAngRibDir.y),\n                     vec3(0.2, ribParams.y * 0.5, 0.005));\n  \n  float ribBox = sdBox(vec3(orig) - vec3(0., -ribParams.y * 0.5 + 0.1, 0.), vec3(0.8, ribParams.y*0.5, 0.8)) - 0.01;\n  return frib * 0.3;//step(-0.0001, ribBox));\n}\n\n//for static arclen\n//float legu;\n\n//\n// the _tDist parameters is the ray travel distance\nfloat jellyfishTentacles(in vec3 _p, in float _tDist, in int cID)\n{\n  vec4 tentacles = TF(JTNT_PARAMS, cID);\n  float n_legs = tentacles.x;\n  vec4 fAngLegs = sdAngularPattern(_p.xz, n_legs, 0.);\n  \n  vec2 trp = fAngLegs.y*vec2(cos(fAngLegs.z), sin(fAngLegs.z));\n  \n  vec2 angDir = vec2(cos(-PI/n_legs), sin(-PI/n_legs));\n  \n  float flegs = 10.;\n  float rootWidth = tentacles.z;\n  float footWidth = tentacles.w;\n  float ldWidth = rootWidth - footWidth;\n  \n  //int inc = 1;\n  // LOD\n  // number of sections decreases with distance\n  int inc = int(mix(1., float(N_LEG_POINTS/3), clamp((_tDist - 10.) / FAR, 0., 1.)));\n  for (int i_sec = 0; i_sec < N_LEG_POINTS - 1; i_sec += inc)\n  {\n    int legIdx = i_sec;\n    float alphaLen = (float(legIdx) / float(N_LEG_POINTS - 2));\n    float legWidth = rootWidth - ldWidth * alphaLen;\n    vec2 leg0 = TF(JTLEG_START + legIdx, cID).rg;\n    vec2 leg1 = TF(JTLEG_START + min(legIdx + inc, N_LEG_POINTS - 1), cID).rg;\n    \n    vec2 xz0 = leg0.x * angDir;\n    vec2 xz1 = leg1.x * angDir;\n    \n    vec3 tp = vec3(trp.x, _p.y, trp.y);\n    vec3 pa = vec3(xz0.x, leg0.y, xz0.y);\n    vec3 pb = vec3(xz1.x, leg1.y, xz1.y);\n    float fSec = sdCapsule(tp, pa, pb, legWidth);\n    \n    // A proxy for normalized arclen\n    /*if (fSec < flegs && fSec < _tDist * T_EPS)\n    {\n      legu = (float(legIdx) + dot(tp - pa, pb - pa)) / float(N_LEG_POINTS);\n    }*/\n    \n    flegs = sdSmUnion(flegs, fSec, 0.001);\n  }\n  \n  return flegs;\n}\n\n///\nfloat JFHits[10];\n\nfloat jellyfish(in vec3 _p, in float _t, in int _cellID, in bool _render)\n{\n  // cap\n  float jcfg = TF(JCAP_PARAMS, _cellID).w;\n  \n  JFHits[0] = jellyfishCap(_p, _cellID);\n  JFHits[1] = jcfg > 0.5 ? jellyfishBCup(_p, _cellID) : 100.;\n  JFHits[2] = jcfg > 0.5 && jcfg < 2.5 ? jellyfishRibbons(_p, _cellID, _render) : 100.;\n  JFHits[3] = jellyfishTentacles(_p, _t, _cellID);\n  \n  JFHits[4] = sdSmUnion(JFHits[0], JFHits[1], 0.001);\n  JFHits[5] = sdSmUnion(JFHits[1], JFHits[2], 0.02);\n  JFHits[6] = sdSmUnion(JFHits[3], JFHits[2], 0.005);\n  JFHits[7] = sdSmUnion(JFHits[0], JFHits[3], 0.35);\n  \n  float f = min(min(JFHits[0], JFHits[1]), min(JFHits[2], JFHits[3]));\n  float fsm = min(min(JFHits[4], JFHits[5]), min(JFHits[6], JFHits[7]));\n  \n  f = min(f, fsm);\n  \n  return f;\n}\n\nfloat jellyfish(in vec3 _p, in float _t, in vec3 _d)\n{\n  int cellID;\n  _p = jpattern(_p, cellID).xyz;\n  float f = jellyfish(_p, _t, cellID, false);\n  \n  // test hitting the next cell wall\n  vec3 next = sign(_d) * 0.5 * jgrid;\n  vec3 ht = (next - _p) / _d;\n  // 0.5 should be safe margin between a wall and jellyfish\n  f = min(min(ht.x, min(ht.y, ht.z)) + 0.5, f);\n  \n  return f;\n}\n\n/*\n// Too heavy, especially for the compilation.\nvec3 norm(in vec3 _p, in int cellID)\n{\n  vec3 n;\n  vec2 e = vec2(N_EPS, 0.0);\n\n  n.x = jellyfish(_p + e.xyy, cellID, true) - jellyfish(_p - e.xyy, cellID, true);\n  n.y = jellyfish(_p + e.yxy, cellID, true) - jellyfish(_p - e.yxy, cellID, true);\n  n.z = jellyfish(_p + e.yyx, cellID, true) - jellyfish(_p - e.yyx, cellID, true);\n\n  return normalize(n);\n}*/\n\nvec3 norm(in vec3 _p, in float _t, in float ep, in int cellID)\n{\n  vec3 n;\n  vec2 e = vec2(N_EPS, 0.0);\n\n  n.x = jellyfish(_p + e.xyy, _t, cellID, true) - ep;\n  n.y = jellyfish(_p + e.yxy, _t, cellID, true) - ep;\n  n.z = jellyfish(_p + e.yyx, _t, cellID, true) - ep;\n\n  return normalize(n);\n}\n\nvec4 jfCapRender(in vec3 _p, in int _cellID)\n{\n  vec4 capParams = TF(JCAP_ANIM, _cellID);\n  float r1 = capParams.x;\n  float h1 = capParams.y;\n  float h2 = capParams.z;\n  float r2 = capParams.w;\n  \n  vec2 cTexture = TF(CAP_TEX_CRD, _cellID).rg;\n  float ch1 = distance(_p, vec3(0., r1 - h1, 0.));\n  \n  /* CAP MID SECTION\n  float a1 = 2. * r1 * asin(ch1 / (2. * r1));\n  vec3  scl_p = _p;\n  float scl = 0.21 * TF(JCAP_PARAMS, _cellID).z;\n  scl_p.xz *= (1. - scl * abs(_p.y));\n  float ch2 = distance(vec2(length(_p.xz), _p.y), vec2(r2, 0.));\n  */\n  \n  float ja = atan(_p.z, _p.x);\n  \n  vec2  offset = clamp(0.08 * ch1, 0., 1.) * vec2(cos(ja), sin(ja));\n  vec2 coords = cTexture + offset;\n  coords.x *= resRatio;\n  vec4 col = texture(iChannel0, coords);\n  \n  return col;\n}\n\nvec4 jfRibbonsRender(in vec3 _p)\n{\n  return vec4(1.5*TF(BCUP_COL, 0).rgb, 0.25);\n}\n\nvec4 jfBCapRenderer(in vec3 _p, in int _cellID)\n{\n  return TF(BCUP_COL, _cellID);\n}\n\nvec4 jfBCapRenderer(in vec3 _p, in vec3 _n, in int _cellID, inout float _ao)\n{\n  // doesn't add much.\n  /*vec3 tn, btn;\n  getTangents(_n, normalize(vec3(_p.x, 0., _p.z)), tn, btn);\n  float eps = 0.1;\n  float f = step(0., jellyfishBCup(_p + tn * eps, _cellID));\n  f += step(0., jellyfishBCup(_p + 0.707 * (tn + btn) * eps, _cellID));\n  f += step(0., jellyfishBCup(_p + btn * eps, _cellID));\n  f += step(0., jellyfishBCup(_p + 0.707 * (btn - tn) * eps, _cellID));\n  f += step(0., jellyfishBCup(_p - tn * eps, _cellID));\n  f += step(0., jellyfishBCup(_p - 0.707 * (tn + btn) * eps, _cellID));\n  f += step(0., jellyfishBCup(_p - btn * eps, _cellID));\n  f += step(0., jellyfishBCup(_p - 0.707 * (btn - tn) * eps, _cellID));\n  \n  \n  _ao = 0.5 + f * 0.5;\n  \n  //_ao = 1.0;\n  */\n  vec4 col = TF(BCUP_COL, _cellID);\n  return col;\n}\n\nvec4 jfTentaclesAlpha(in vec3 _p, in int _cellID)\n{\n  return vec4(0.5);\n}\n\nvec4 jfTentaclesRender(in vec3 _p, in int _cellID)\n{\n  float th = TF(JTNT_PARAMS, _cellID).y;\n  vec3 col = mix(TF(TNT_CLR_0, _cellID).rgb, TF(TNT_CLR_1, _cellID).rgb,-_p.y / th); \n  col.rgb *= (1. + 3.*col.rgb * ANIM_T(abs(_p.y), 1.0, th * (mod(TF(JCAP_PARAMS, _cellID).z, 5.) * 0.4)));\n  return vec4(col, 0.5);\n}\n\nvec4 jellyFishRender(in vec3 _p, in vec3 _d, in float _minf, out int _hg, out int _cellID)\n{\n  int cellID;\n  _p = jpattern(_p, cellID).xyz;\n \n  vec4 col = vec4(1.);\n  \n  if (_minf == JFHits[1])\n  {\n    col = jfBCapRenderer(_p, cellID);\n    _hg = 4;\n  }\n  else if (_minf == JFHits[0] || _minf == JFHits[4])\n  {\n    col = jfCapRender(_p, cellID);\n    _hg = 1;\n  }\n  else if (_minf == JFHits[2])\n  {\n    col = jfRibbonsRender(_p);\n    _hg = 2;\n  }\n  else if (_minf == JFHits[3] || _minf == JFHits[7])\n  {\n    col = jfTentaclesAlpha(_p, cellID);\n    _hg = 3;\n  }\n  else if (_minf == JFHits[5])\n  {\n    col = jfBCapRenderer(_p, cellID);\n    _hg = 4;\n  }\n  \n  return col;\n}\n\nvec4 jellyFishRender(in vec3 _p, in vec3 _d, in float _t, in int _hg, in float _ep, in float _glow)\n{\n  vec4 lights[2] = vec4[2](vec4(0., 1., 0., 1.), vec4(0., 0.0, 1., 0.1));\n  int cellID;\n  _p = jpattern(_p, cellID).xyz;\n  vec3 n = norm(_p, _t, _ep, cellID);\n  float ao = 1.0;\n  vec2 gf = TF(JLIGHT, cellID).yz;\n  vec4 col = vec4(1.) * dot(-_d, n);\n  \n  if (_hg == 1)\n  {\n    col = jfCapRender(_p, cellID);\n  }\n  else if (_hg == 2)\n  {\n    col = jfRibbonsRender(_p);\n  }\n  else if (_hg == 3)\n  {\n    col = jfTentaclesRender(_p, cellID);\n  }\n  else if (_hg == 4)\n  {\n    col = jfBCapRenderer(_p, n, cellID, ao);\n  }\n  else \n  {\n    col = vec4(0., 1., 0., 1.);\n    n = vec3(-_d);\n  }\n  \n  \n  col = max(col, 0.);\n  // add inner illumination\n  \n  // animation timer\n  float time = TF(JCAP_PARAMS, cellID).z;\n  \n  vec4 ldir = lights[0];\n  vec4 ldir2 = lights[1];\n        \n  vec4 jlight = TF(JLIGHT, cellID); \n  \n  float glassFact = jlight.w * max(1. - pow(dot(-_d, n), 4.), 0.);\n  float spec = ldir.w * col.a * max(pow(dot(reflect(ldir.xyz, n), _d), 4.), 0.);\n  float diffuse = ldir.w * max(dot(ldir.xyz, n), 0.);\n  float spec2 = ldir2.w * col.a * max(pow(dot(reflect(ldir2.xyz, n), _d), 4.), 0.);\n  float diffuse2 = ldir2.w * max(dot(ldir2.xyz, n), 0.);\n  float ambient = 0.15;\n  \n  col.rgb = col.rgb * (glassFact + ambient + diffuse + diffuse2 + (spec + spec2) * vec3(0.9, 0.9, 1.));\n  col.rgb *= ao;\n  \n  // inverse normalized distance\n  float ndist = 1. - _t/FAR;\n  // glow distance factor\n  float gfDistFact = (ndist + 0.01) * 13. * exp(-5. * ndist);\n  // glow look up factor\n  float gfUpFact = clamp(_d.y + gf.x, 0., 0.3);\n  col.rgb += clamp(_glow*gf.y*gfDistFact*gfUpFact, 0., 1.);\n  // debug coloring\n  //col.rgb = vec3(1.)*(0.7 + 0.3*dot(-_d, n));\n  \n  // modify transparency by viewing angle.\n  col.a = clamp(col.a + (1. - pow(dot(-_d, n), 0.5)), col.a, 1.);\n  return col;\n}\n\nstruct TraceHit\n{\n  float t;\n  float ht;\n  int   i; // section\n  vec3  p;\n  float g; // glow\n};\n\n\nvec4 render(in vec3 _o, in vec3 _d, in TraceHit[MAX_TRANSPARENCY_LEVEL] _res, in vec3 _mdist, in vec3 back)\n{\n  vec4 col;\n  vec4 fog;\n\n  // previous hit distance;\n  float pht = 0.;\n  \n  for (int it = 0; it < min(int(_mdist.y), MAX_TRANSPARENCY_LEVEL); it++)\n  {\n    TraceHit val = _res[it];\n    \n    vec3 p = val.p;\n\n    vec4 gcol = jellyFishRender(p, _d, val.t, val.i, val.ht, val.g);\n    \n    float dt = val.t - pht;\n    \n    // it should be val.t instead of dt, but dt looks more colorful.\n    gcol = mix(vec4(back, 1.), gcol, clamp(exp(1. - dt*0.05), 0., 1.));\n    col.rgb += (1. - col.a) * (gcol.a * gcol.rgb);\n    col.a += (1.-col.a)*gcol.a;\n    pht = val.t;\n    \n    if (col.a > 0.99)\n        break;\n  }\n  \n  return col;\n}\n\nconst float shellSize[5] = float[5](0., 0.1, 0.05, 0.25, 0.1);\nvoid trace(in vec3 _o, in vec3 _d, out TraceHit[MAX_TRANSPARENCY_LEVEL] _res, out vec3 _mdist, in float _far)\n{\n  vec3 p = _o; float t = 0., ft = 0., ihit = 0., tAlpha = 0., shSize = 0.075;\n  float gf = 0.;\n  int jid = 0;\n  _mdist.x = 10.;\n  \n  for (int it = 0; it < M_ITER; it++)\n  {\n    p = _o + _d * t;\n        \n    ft = jellyfish(p, t, _d);\n    \n    float isHit = step(abs(ft), t * T_EPS);\n    \n    if (isHit > 0.5)\n    {\n      _res[int(ihit)].t = t;\n      _res[int(ihit)].p = p;\n      _res[int(ihit)].ht = ft;\n      tAlpha += jellyFishRender(p, vec3(0.), ft, _res[int(ihit)].i, jid).w;\n      shSize = shellSize[_res[int(ihit)].i];\n       ihit++;\n    }\n    \n    // NOT USED\n    if (isHit < 0.5)\n    {\n      _mdist.x = min(abs(ft), _mdist.x);\n      _res[int(ihit)].g += 0.1 / (0.1 + ft * ft);\n      //_mdist.z = t;\n    }\n    \n    if (tAlpha >= 0.98 || int(ihit) == MAX_TRANSPARENCY_LEVEL || t > _far)\n        break;\n\n    t += ft + isHit * shSize;\n#ifdef _DEBUG\n    _mdist.z = float(it);\n#endif\n  }\n  \n  _mdist.y = ihit;\n}\n\n\nvec3 cameraOrigin(in float _t)\n{\n   return vec3(jgrid.x * 0.5, 13. + hShift, jgrid.z * 0.5);\n}\n\nvec3 target(in float _t)\n{\n  return vec3(0., 6. + hShift + lookAt.y, lookAt.z);\n}\n\nvec3 camera(in vec3 o, in vec3 d, in vec3 tar) {\n  vec3 dir = normalize(o - tar);\n  vec3 up = abs(dot(vec3(0., 1., 0.), dir)) < 0.98 ? vec3(0., 1., 0.) : vec3(0., 0., 1.);\n  vec3 right = cross(up,dir);\n  up = cross(dir,right);\n\n  mat3 view = mat3(right,up,dir);\n  return view*d;\n}\n\nvec4 getWindow(in float _t)\n{\n  float t60 = mod(_t, 60.);\n  \n  float x = -0.75 + 0.25 * PULSE_T(t60, 1., 10., 50.) + 0.75 * PULSE_T(t60, 1., 25., 40.);\n  float y = -0.75 + 0.25 * PULSE_T(t60, 1., 20., 50.) + 0.75 * PULSE_T(t60, 1., 25., 40.);\n  float l = 1. - 0.5 * PULSE_T(t60, 1., 35., 55.);\n  \n  return vec4(x, y, l, l);\n}\n\nvec3 background(in vec2 _uv, in vec4 _wnd, in float _t)\n{\n    float th, phi, fct = FAR * 0.5;\n    vec3 o = cameraOrigin(_t);\n    vec3 d = normalize(target(_t) - o);\n    \n    vec3 ls = vec3(0., 100., 0.);\n    getThetaPhi(d, th, phi);\n    vec2 texNoise = vec2(0.5*noise(vec2(_uv.x+_t*0.25, _uv.y)), 0.5*noise(vec2(_uv.x, _t*0.25 + _uv.y)));\n    vec2 coords = 0.2*vec2(texNoise.x + th * fct, phi * fct + hShift + texNoise.y);\n    \n    vec2 rawUv = (_uv * 0.5 + 0.5) * 1.3;\n    float tex = texture(iChannel1, zoom * (rawUv + coords)).r;\n    \n    vec3 dtex = vec3(dFdx(tex), dFdy(tex), 1.);\n    dtex = normalize(dtex);\n    \n    // motion blur\n    float onMove = smoothstep(0.0001, 0.2, 0.5 - abs(hShift*0.02 - 0.5));\n    tex += texture(iChannel1, zoom * (rawUv + coords + vec2(0., hShift*onMove*invResY*1.))).r;\n    tex += texture(iChannel1, zoom * (rawUv + coords + vec2(0., hShift*onMove*invResY*2.))).r;\n    tex += texture(iChannel1, zoom * (rawUv + coords + vec2(0., hShift*onMove*invResY*3.))).r;  \n    tex *= 0.25;\n    \n    float fh = 1. - length(ls - o) * 0.01;\n    float heightFactor = mix(1., 1.2, fh * fh);\n    float dirFactor = 0.9 + max(0.35 * dot(normalize(ls - o), d), -0.2);\n    vec3 back = mix(vec3(0.1, 0.23, 0.37), vec3(0.36, 0.57, 0.79), 0.5 + 0.5*_uv.y);\n    back = mix(back, vec3(0.55, 0.57, 0.5)*(tex), 0.1);\n    back = mix(back, 0.5 * back, pow(abs(_uv.x*0.5), 1.));\n    back *= 1.5 * heightFactor * dirFactor;\n    \n    //spec = pow(spec, vec3(2.2));\n    // day/night\n    back = (1.0 + 1.0 * PULSE_T(mod(_t, 120.), 10., 60., 110.) * vec3(0.5, 0.5, 0.5)) * pow(back.rgb, vec3(2.2));\n    float dTexDy = abs(dFdy(tex) / (invResY * 20.)) * smoothstep(2., 2.15, dirFactor + heightFactor);\n    \n    // total fabrication\n    // give the bubles/rocks some edginess.\n    vec3 spec = vec3(1.) * abs(dTexDy);\n    back = mix(back, back*0.97 + 0.03 * pow(spec, vec3(2.2)), dTexDy);\n    \n    back = clamp(back, 0., 1.);\n    return vec3(back);\n}\n\nvec4 drawAAPass(int _aa, vec2 _uv, vec4 _wnd, float _time, in vec3 back, out TraceHit res[MAX_TRANSPARENCY_LEVEL], out float _traceIter)\n{\n    vec4 col3d;\n    // taken from iq\n    for (int ii = 0; ii < _aa; ii++)\n    for (int jj = 0; jj < _aa; jj++)\n    {\n      vec2 off = (1./float(_aa + 1)) * vec2(float(ii + 1), float(jj + 1))/iResolution.y;\n      vec2 vuv = 2.*(_uv + off - _wnd.xy)/(_wnd.z) - 1.;\n      vec3 o = cameraOrigin(_time);\n      vec3 d = normalize(vec3(vuv.xy * zoom, -1.));\n\n      d = camera(o, d, target(_time));\n\n      // need to fix clipping of jellyfish\n      float far = min((FAR - mod(o.z, jgrid.z)) / abs(max(d.z, d.x)), FAR * 1.5);\n\n      vec3 mdist;\n      trace(o, d, res, mdist, far);\n\n      col3d += render(o, d, res, mdist, back);\n    }\n    col3d /= float(_aa*_aa);\n    \n    return col3d;\n}\n\nvec4 drawPass(vec2 _uv, vec4 _wnd, float _time, in vec3 back, out TraceHit res[MAX_TRANSPARENCY_LEVEL], out float _traceIter)\n{\n  vec2 off = vec2(0.5) / iResolution.y;\n  vec2 vuv = 2.*(_uv + off - _wnd.xy)/(_wnd.z) - 1.;\n  vec3 o = cameraOrigin(_time);\n  vec3 d = normalize(vec3(vuv.xy * zoom, -1.));\n  vec4 col3d;\n  \n  d = camera(o, d, target(_time));\n\n  // need to fix clipping of jellyfish\n  float far = min((FAR - mod(o.z, jgrid.z*0.5)) / max(abs(d.z), abs(d.x)), FAR * 1.5);\n\n  vec3 mdist;\n  trace(o, d, res, mdist, far);\n  _traceIter = mdist.z;\n  col3d = render(o, d, res, mdist, back);\n\n  return col3d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 muv = (2.0*iMouse.xy - iResolution.xy) / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col;\n    vec4 col3d;\n    vec3 o, d;\n    bool draw3D = true;\n    float time = iTime;\n    float miss = 100.;\n    float alpha = 0.;\n\n    // initalize frame constants\n    jgrid = vec3(10., 35., 10.);\n    // height jump\n    hShift = 50.*PULSE_T(mod(time, 120.), 4., 52., 80.);\n    resRatio = iResolution.y/iResolution.x;\n    invResY = 1./iResolution.y;\n    \n    // target point change\n    lookAt.z = 0.1 * noise(time) + (noise(time * 0.1 + 23.981) - 0.5) * 3.;\n    lookAt.y = 0.1 * noise(time*0.5 + 93.13) + noise(time * 0.05 + 171.18) * 10.;\n    // this is actually scale\n    zoom = 1.3 - 0.3 * noise(time * 0.05 + 56.24);\n    \n#ifdef _DEBUG\n    if (iMouse.z > 0.5)\n    {\n        lookAt.z = muv.x * 3.;\n        lookAt.y = muv.y * 10.;\n    }\n#endif\n    \n    TraceHit res[MAX_TRANSPARENCY_LEVEL];\n    res[0].t = FAR;\n    \n    float traceIter = 0.;\n    float ratio = iResolution.x/iResolution.y;\n    vec4 wnd = vec4(-ratio, -1., 2. * ratio, 2.);\n    \n    vec3 back = background(uv, wnd, iTime);\n\n// for some reason single - no loop - function compiled faster than using the loop with AA = 1.\n// So kept it to decrease compilation time.\n#if AA==0\n    col3d = drawPass(uv, wnd, time, back, res, traceIter);\n#elif AA > 0\n    col3d = drawAAPass(AA, uv, wnd, time, back, res, traceIter);\n#endif\n\n    col = mix(back, col3d.rgb, col3d.a * step(0.01, float(iFrame)));\n    col = pow(col, vec3(2.2));\n\n#ifdef _DEBUG\n    alpha = traceIter/float(M_ITER);\n#else\n    alpha = res[0].t / FAR;\n#endif\n    fragColor = vec4(col,alpha);\n}","name":"Buffer B","description":"","type":"buffer"}]}