{"ver":"0.1","info":{"id":"DddBRj","date":"1697395701","viewed":156,"name":"BFD","username":"MV10","description":"Yet another public Britney melt-down. (If it's any consolation, I do feel slightly bad about abusing cornusammonis' super-awesome [url=https://www.shadertoy.com/view/wdVSR3]Faster Multiscale MIP Fluid[/url] for this nonsense...)","likes":14,"published":1,"flags":48,"usePreview":0,"tags":["fluid","mipmap","dynamics","mip","multiscale","cfd"],"hasliked":0,"parentid":"wdVSR3","parentname":"Faster Multiscale MIP Fluid"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// See BufferA for all the interesting comments.\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,1.0/iResolution.y),120.0);\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,36.0)*1.0;\n    //spec=0.0;\n\tfragColor = texture(iChannel0,uv)*vec4(diff)+vec4(spec);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n/*\n See original for other credits and commentary:\n https://www.shadertoy.com/view/wdVSR3\n\n I was thinking about using this as a post-FX on other shaders,\n and the best way to test here is to use a video. The mixing was\n interesting, but applying chroma-key is even better since less\n of the melty content is wipedout whenever we hit a Nth frame and\n mix in more video.\n \n Updated to use OKLab-based perceptual color matching (change the\n \"method\" flag below for the YCC chroma-key approach).\n*/\n\n// 0 = chroma-key (typical YCC green-screen)\n// 1 = perceptual similiarity (OKLab color)\n#define method 1\n\n/////////////////////////////////////////////////////////////////////\n// Chroma-key begins\n// Comments in source: https://www.shadertoy.com/view/ldVyRW\n\nvec3 YCbCr (vec3 rgb) {\n\treturn vec3(\n        dot(rgb, vec3(.299, .587, .114)), // y\n        .5 + dot(rgb, vec3(-.169, -.331, .5)), // Cb\n\t\t.5 + dot(rgb, vec3(.5, -.419, -.081)) // Cr\n    );\n}\n\nvec4 CK (vec3 f, vec3 b, vec3 k) {\n    vec3 v = YCbCr(f);\n    float l = length((v - YCbCr(k)).gb);\n    float m = 1. - smoothstep(.075, .225, l);\n    vec3 s = (1. - m) * vec3(v.r);\n    return vec4(mix(s, f - m * k, smoothstep(.125, .275, l)) + m * b, 1.);\n}\n\n// Chroma-key ends\n\n\n/////////////////////////////////////////////////////////////////////\n// OKLab begins\n// For credits and details: https://www.shadertoy.com/view/cdcBDs\n\nvec3 rgb_gradient(float x)\n{\n    float t = x / iResolution.x;\n    vec3 p = abs(fract(t + vec3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0);\n    return clamp(p - 1.0, 0.0, 1.0);\n}\n\nfloat halley_cube_root(float x)\n{\n    float y = sign(x) * uintBitsToFloat(floatBitsToUint(abs(x)) / 3u + 0x2a514067u);\n    for( int i = 0; i < 4; ++i )\n    {\n        float y3 = y * y * y;\n        y *= ( y3 + 2. * x ) / ( 2. * y3 + x );\n    }\n    return y;\n}\n\nvec3 rgb2oklab(vec3 c)\n{\n    float l = 0.4122214708 * c.r + 0.5363325363 * c.g + 0.0514459929 * c.b;\n\tfloat a = 0.2119034982 * c.r + 0.6806995451 * c.g + 0.1073969566 * c.b;\n\tfloat b = 0.0883024619 * c.r + 0.2817188376 * c.g + 0.6299787005 * c.b;\n\n    float lr = halley_cube_root(l);  // pow(l, 1.0 / 3.0)\n    float ar = halley_cube_root(a);  // pow(a, 1.0 / 3.0)\n    float br = halley_cube_root(b);  // pow(b, 1.0 / 3.0)\n\n    return vec3 (\n        0.2104542553 * lr + 0.7936177850 * ar - 0.0040720468 * br,\n        1.9779984951 * lr - 2.4285922050 * ar + 0.4505937099 * br,\n        0.0259040371 * lr + 0.7827717662 * ar - 0.8086757660 * br);\n}\n\nfloat color_difference(vec3 rgb1, vec3 rgb2)\n{\n    vec3 oklab1 = rgb2oklab(rgb1);\n    vec3 oklab2 = rgb2oklab(rgb2);\n    return distance(oklab1, oklab2);\n}\n\n// OKLab ends\n\n\n/////////////////////////////////////////////////////////////////////\nbool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\n#define C(x,y) textureLod(iChannel0, t*(U+float(1<<s)*vec2(x,y)),float(s))\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    O = O-O;\n    vec2 t = 1./iResolution.xy, q = U*t - .5;\n    int s = 10;\n    for (; s > 0; s--)\n        O.xy -= 2.0 * vec2(C(0,1).x + C(0,-1).x, C(1,0).y + C(-1,0).y)\n            -4.0 * C(0,0).xy + (C(1,-1) - C(1,1) - C(-1,-1) + C(-1,1)).yx;\n    O = (C(O.x,O.y) + vec4(5e-4*q / (dot(q,q)+.01),0,0));\n    \n    // mix in some new content every few frames\n    if(iFrame % 2 == 0)\n    {\n        vec3 fluid = texture(iChannel0, U*t).rgb;\n        vec3 britney = texture(iChannel1,U*t).rgb;\n        \n        vec3 key_rgb = vec3(.176, .627, .176);\n\n        // My original attempt (below) was to just mix 15% of the\n        // original video every 4th frame. Obviously that wasn't\n        // as smooth, and the large green background mostly wiped\n        // out the interesting \"melty\" effects.\n        //O = vec4(mix(fluid, britney, 0.15), 1.0);\n\n        // YCC key\n        if(method == 0)\n        {\n            O = CK(britney, fluid, key_rgb);\n        }\n        \n        // perceptual similarity\n        if(method == 1)\n        {\n            float similarity = color_difference(key_rgb, britney);\n            float tolerance = 0.1;\n            float pct = (similarity - tolerance <= 0.0) ? 0.0 : 0.15;\n\n            O = vec4(mix(fluid, britney, pct), 0.0);\n        }\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}