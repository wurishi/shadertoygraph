{"ver":"0.1","info":{"id":"7dVcRc","date":"1655413238","viewed":122,"name":"Overlapping Shape Thing","username":"viprevipre","description":"My first post! Just a random experiment one day that turned out looking cool. I changed it into a cell-based method in an attempt to reduce the iterations required, but it didn't help the GPU usage very much. Optimization help is still appreciated!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["simple","kaleidoscope","cells","tiles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fun to mess around with\n#define ITERATIONS 7\n#define SCALE 5.0\n\nfloat HexDist(vec2 st) { // The Art of Code/BigWIngs - hexagon distance function - https://www.youtube.com/watch?v=VmrIDyYiJBA\n    st = abs(st);\n    float c = dot(st, vec2(0.5, 0.866));\n    c = max(c, st.x);\n    \n    return c;\n}\n\nfloat TriDist(vec2 st) { // pulled this out of thin air, but it looks like a equilateral triangle so we'll go with it\n    float m = max(dot(st, vec2(0.866, 0.5)), dot(st, vec2(-0.866, 0.5)));\n    return max(m, -st.y) * 1.8; \n}\n\n// just returns 0 or 1 depending on if the shape overlaps uv or not\n// can be a triangle or a hexagon\nfloat drawShape(vec2 uv, vec2 coord, float size, float angle, float shape) {\n    uv = uv - coord;\n    \n    float s = sin(angle);\n    float c = cos(angle);\n    mat2 rot = mat2(c, s, -s, c);\n    uv = uv * rot;\n    \n    return step((shape > 0.5) ? TriDist(uv) : HexDist(uv), size);\n}\n\n\n// Dave Hoskins - Hash Without Sine - https://www.shadertoy.com/view/4djSRW\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat randomDir(float p) { // returns either 1 or -1\n    return (step(0.5, hash11(p)) - 0.5) * 2.0;\n}\n\n// IQ - Smooth HSV to RGB conversion - https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb_smooth( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 st = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y; // normalize coordinates\n\t\n    st *= SCALE; // split the coordinate system into repeating cells, each with it's own \"ID\" in the form of ist\n    vec2 ist = floor(st);\n    vec2 fst = fract(st) - 0.5;\n    \n    \n    float t = (iTime + 5.0) * 0.6;\n    \n    float rng; //        each shape to get unique rng in different cells\n    float spiraling; //  a very slow oscillation so that the coordinates rotate in a spiral instead of a circle\n    vec2 coordinate; //  coordinate of each shape\n    float size; //       size of eaach shape\n    float angle; //      angle of each shape rotation, will have a random speed as well\n    float shapeHash; //  a triangle or a hexagon\n    float id; //         how many shapes overlap the current pixel\n    \n    \n    // check surrounding cells for shapes\n    for(int ix = -1; ix < 2; ix++) {\n       for(int iy = -1; iy < 2; iy++) {\n            for (int i = 1; i < ITERATIONS; i++) {\n            \n                rng = floor(hash13(vec3(float(i), float(ix) + ist.x, float(iy) + ist.y)) * 130.0); // each shape in each cell gets its very own rng\n                \n                spiraling = sin(t * 0.3 * hash11(rng)) * 0.2 + 0.4; // 0 <> 0.4\n                \n                \n                coordinate.x = cos(t * hash11(rng + 78.0)) * randomDir(rng + 59.0) * spiraling; // move in a circle\n                coordinate.y = sin(t * hash11(rng + 78.0)) * randomDir(rng + 59.0) * spiraling;\n                coordinate += vec2(ix, iy); // make sure we are checking the shape in the proper cell\n                \n                size = hash11(rng + 43.0) * 0.65 + 0.1; // 0.10 <> 0.75\n                angle = hash11(rng + 453.0) * t * randomDir(rng + 598.0) * 5.0;\n                shapeHash = hash11(rng + 601.0);\n\n                \n                // these numbers were just chosen by hand, they might be able to lead to shapes overlapping 2 cells\n                \n                \n                // id is only increased when drawShape returns 1\n                // if the current shape doesn't overlap, id won't change\n                id += rng * drawShape(fst, coordinate, size, angle, shapeHash);\n           }\n       }\n   }\n    \n    // random number 0 - 1 based on the amount of overlapping shapes, mixed with a gradual rainbow\n\tvec3 color = hash11(id) * hsv2rgb_smooth(vec3(t * 0.1, 0.6, 1.0));\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n","name":"Image","description":"","type":"image"}]}