{"ver":"0.1","info":{"id":"flGBRt","date":"1664991304","viewed":105,"name":"Purple Sky Clouds","username":"kaffelon","description":"My first time doing clouds","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["cloud","sky","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float N31(vec3 p) {\n    return fract(sin(p.x*100.+p.y*1254.+p.z*89603.)*3671.);\n}\n\nfloat smooth_noise(vec3 x)\n{\n    vec3 f = fract(x);\n    vec3 p = floor(x);\n    f = f * f * (3.0 - 2.0 * f);\n    float bl = N31(p);\n    float br = N31(p+vec3(1,0,0));\n    float b = mix(bl, br, f.x);\n    \n    float tl = N31(p+vec3(0,1,0));\n    float tr = N31(p+vec3(1,1,0));\n    float t = mix(tl, tr, f.x);\n    \n    float fbl = N31(p+vec3(0,0,1));\n    float fbr = N31(p+vec3(1,0,1));\n    float fb = mix(fbl,fbr,f.x);\n    \n    float ftl = N31(p+vec3(0,1,1));\n    float ftr = N31(p+vec3(1,1,1));\n    float ft = mix(ftl, ftr, f.x);\n    \n    float back = mix(b,t,f.y);\n    float front = mix(fb,ft,f.y);\n    \n    float entire = mix(back,front,f.z);\n    \n    return entire;\n}\n\nfloat planeSDF(vec3 p)\n{\n    vec3 n = vec3(0.0, -1.0, 0.0);\n    float height = 4.;\n    return (dot(p,n) + height);\n}\n\n\nfloat fractal_noise(vec3 p)\n{\n    float f = 0.0;\n    p = 2. * p;\n    f  = 0.50000*smooth_noise( p ); p = p*2.0;    \n    f += 0.25000*smooth_noise( p ); p = p*2.0;    \n    f += 0.12500*smooth_noise( p ); p = p*2.0;   \n    f += 0.03125*smooth_noise( p );  \n    return f * 5.0;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n    \n}\n\nconst int STEPS_OUTSIDE = 64;\nconst int STEPS_INSIDE = 56;\nconst float STEP_SIZE = .7;\nconst float CLOSE_ENOUGH = .001;\nconst float DENSITY_SCALE = .002;\n\n\nconst float COVERAGE = .18;\nfloat MarchCloud(vec3 p, vec3 rd)\n{\n    float density = 0.0;\n    for (int i = 0; i < STEPS_INSIDE; i++)\n    {\n        p += (rd * STEP_SIZE);\n        float sampleDensity = fractal_noise((p + vec3(iTime * 3.0,0.0,0.0)) /10.) * DENSITY_SCALE;\n        density += sampleDensity;\n    } \n    density = density * step(COVERAGE, density);\n    density = smoothstep(0.0,1.0,(density-COVERAGE) * (1.0/COVERAGE));\n    \n    return 1.0-density;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float cloud_dist = 1000.0;\n    vec3 p = ro;\n\n    for(int i = 0; i < STEPS_OUTSIDE; i++)\n    {\n        if(cloud_dist < CLOSE_ENOUGH)break;\n        cloud_dist = planeSDF(p);\n        p += rd * cloud_dist;\n    }\n    if (cloud_dist<= CLOSE_ENOUGH)\n    {\n        return MarchCloud(p,rd);\n    }\n    return 0.0;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n    vec2 pMouse = iMouse.xy / iResolution.xy;\n    vec2 uv = p;\n    vec3 ro = vec3(0.0,0.0,0.0);\n    vec3 rd = vec3(1.0,.2,0.0);\n    if(iMouse.z > 0.0)\n    {\n        rd = vec3(1.0 - 2.0*cos(pMouse.x), sin(pMouse.y) *3.14 - 1.0, 1.0 - 2.0 *sin(pMouse.x));\n    }\n    rd = normalize(setCamera(ro,rd,0.) * vec3(p.xy,2.));\n    \n    vec3 background = vec3(.8,.7,1.0);\n    vec3 cloud_color = vec3(1.0,1.0,1.0);\n    \n    float cloud_alpha = RayMarch(ro,rd);\n    \n    float rd_height = (rd.y + 1.0)/2.0;\n    vec3 bg_start = vec3(0.1,.4,0.);\n    vec3 bg_end = vec3(.35,.2,.74);\n    \n    vec3 bright = vec3(.75,.75,.75);\n    \n    background = mix(bg_start,bg_end,rd_height);\n    background += bright * smoothstep(1.0,0.0, abs(rd.y - .1) * 9.);\n   \n    \n    vec3 mixed = (cloud_color * cloud_alpha) + (background * (1.0-cloud_alpha));\n    \n    \n    // Output to screen\n    fragColor = vec4(mixed,1.0);\n}","name":"Image","description":"","type":"image"}]}