{"ver":"0.1","info":{"id":"DdjXWd","date":"1677530122","viewed":41,"name":"Noise line landscape","username":"remilanza","description":"Example of 1d noise as a line","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","1d","curve"],"hasliked":0,"parentid":"DsjSW3","parentname":"Noise line with offset"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int N_VALUES = 30;\nconst float LINE_THK = 0.005;\nconst vec4 COL_BLACK = vec4(0., 0., 0., 1.0);\nconst vec4 COL_WHITE = vec4(1., 1., 1., 1.0);\nconst vec4 COL_GREEN = vec4(0., 1., 0., 1.0);\nconst vec4 COL_BLUE = vec4(0., 0., 1., 1.0);\nconst vec4 COL_RED = vec4(1., 0., 0., 1.0);\n\n\nfloat randValues[N_VALUES] = float[](\n    /*0.0               --------------->             1.0*/\n    0.4, -0.2, 0.2, 0.4, 0.6, 0.1, -0.5, -0.8, -0.9, 0.9,\n    0.1, -0.5, 0.2, 0.8, 0.1, -0.6, 0.5, 0.8,   0.2, -0.9,\n    0.1, 0.2, 0.3, 0.4, -0.6, -0.6, -0.5, 0.8,  0.9, 0.8\n);\n\nfloat noiseEval(float x){        \n    int index = int(float(N_VALUES) * x) % N_VALUES;\n    \n    float diff = float(int(x));\n    x = x - diff;\n    \n    float dx = x - float(index)/float(N_VALUES + 0);\n    dx *= float(N_VALUES);\n    \n    dx = smoothstep(0., 1., dx);\n    int nextIndex = index < (N_VALUES - 1) ? index + 1 : 0;    \n    return mix(randValues[index], randValues[nextIndex], dx);\n}\n\n\nfloat noise(float x){\n    const float scale = 0.75;\n    const float stretch = 0.2;\n    return scale * noiseEval(stretch*x) +\n           scale/4.0  * noiseEval(stretch*2.0*x) +\n           scale/8.0  * noiseEval(stretch*4.0*x) +\n           scale/16.0  * noiseEval(stretch*8.0*x) +\n           scale/32.0 * noiseEval(stretch*16.0*x);    \n}\n\nvec2 noiseTangent(float x){\n    const float dxnorm = 0.00001;\n    float x0 = x - dxnorm;\n    float x1 = x + dxnorm;\n    float y0 = noise(x0);\n    float y1 = noise(x1);\n    return normalize(vec2(x1 - x0, y1 - y0));\n    \n}\n\nvec2 noiseNormal(float x){\n    vec2 tangent = noiseTangent(x);\n    return vec2(-tangent.y, tangent.x);    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = COL_WHITE;\n   \n    vec2 uv = fragCoord/iResolution.xy;\n               \n    float x = uv.x * 1.7 + iTime/2.;\n    float y1 = noise(x);        \n    float y = 0.5*y1 + 0.5;\n    vec2 norm = noiseNormal(x);\n    \n\n    const float smoothTHK = 0.05;\n    const float snowLIM = 0.6;\n    if(uv.y < y){\n               \n        bool topHasSnow = y > snowLIM;\n               \n        if(topHasSnow){\n            \n            float snowThk = 0.15 * smoothstep(snowLIM, y, uv.y) + 0.1*noise(x*0.123213);\n            \n            float dsnow = 0.16*(y - snowLIM);\n            if(uv.y > (y - snowThk)){\n                fragColor = COL_WHITE;\n            }\n            else{\n                fragColor = COL_GREEN;\n            }\n        \n        }\n        else{       \n            if(uv.y > (y - smoothTHK)){\n                float step = pow(smoothstep(y - smoothTHK, y, uv.y),4.);\n                fragColor = mix(COL_GREEN, COL_BLUE, step); \n            }              \n            else{\n                fragColor = COL_GREEN;\n            }\n        }\n    }\n    else{\n        fragColor = COL_BLUE;\n    }\n    \n    //debug\n    //float debX = x;\n    //vec2 debNorm = noiseNormal(debX);\n    //if(uv.y > (debNorm.y - 0.005) && uv.y < (debNorm.y + 0.005)){\n    //    fragColor = COL_RED;\n    //}\n\n}","name":"Image","description":"","type":"image"}]}