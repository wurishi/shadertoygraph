{"ver":"0.1","info":{"id":"mdfGDB","date":"1666782277","viewed":114,"name":"Planar Voxel - intersection","username":"EisernSchild","description":"Here is a simplified planar voxel intersection. Should be quite fast.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","simple","intersector"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Planar Voxel - intersection\n// Copyright (c) 2022 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n/*\n    Here is a simplified planar voxel ray intersection. \n    \n    Should be quite fast, since with a pure top-down \n    view we can limit the maximum grid intersections \n    down to 2-3 (uMaxSteps). For far-sighted view we\n    need to increase them, here we take 5.\n    \n    Don't get too far from view space center (0.,0.,0.),\n    otherwise you get flaws due to float numeric space\n    restrictions.\n    \n    other simplified intersections:\n    https://www.shadertoy.com/view/slyyWW - Cylinder aligned\n*/\n\n#define PI 3.141592654\n\n// ray hit attribute\nstruct PosNorm\n{\n\tvec3 vPosition;\n\tvec3 vNormal;\n};\n\n// max ray steps\nconst uint uMaxSteps = uint(5);\n// ray min/max distance\nconst float fTMin = 0.f, fTMax = 50.f;\n// adjust raysteps to avoid flaws\nconst float fStepAdjust = 0.0001f;\n\n// simple hash float1<-float2\nfloat hash12(vec2 vP)\n{\n\tvec3 vP3  = fract(vec3(vP.xyx) * .1031);\n    vP3 += dot(vP3, vP3.yzx + 33.33);\n    return fract((vP3.x + vP3.y) * vP3.z);\n}\n\n// function from : https://www.shadertoy.com/view/4dsSzr\n// By Morgan McGuire @morgan3d, http://graphicscodex.com\n// Reuse permitted under the BSD license.\nvec3 hueGradient(float t) {\n    vec3 p = abs(fract(t + vec3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0);\n\treturn (clamp(p - 1.0, 0.0, 1.0));\n}\n\n// planar voxel intersector\n// @returns: T hit distance, normal, origin as destination point\nvec4 iVoxelPlanar(inout vec3 vOri, in vec3 vDir)\n{\n    // set grain from 0.0 to 1.0.. more is more blocks\n    // const float fGrain = 0.4f;    \n    float fGrain = abs(sin(iTime * .2));\n    \n    // back up origin\n    vec3 vOriB = vOri;\n    \n    // top / bottom plane intersection\n    float fTHit = -vOri.y/vDir.y;\n    float fTHitB = -(vOri.y + .5)/vDir.y;\n\n    // set bottom plane hit, set origin to top plane hit\n    vec3 vPntB = vOri + fTHitB * vDir;\n    vOri = vOri + fTHit * vDir;\n    \n    // get level data top (hash meanwhile)\n    float fHT = hash12(floor(vOri.xz * 2.));\n\n    if (fHT < fGrain)\n        // top hit\n        return vec4(fTHit, 0., 1., 0.);\n    else\n    {\n        // march through the space\n        uint uI = uint(0);\n        while ((uI++ < uMaxSteps) && (fTHit < fTHitB))\n        { \n            // move to next intersection, wether X or Z grid plane\n            vec3 vPTB = vPntB - vOri;\n            float fIX = (vOri.x > vPntB.x) ? mod(vOri.x, .5) : -mod(vOri.x, .5) + .5;\n            float fIZ = (vOri.z > vPntB.z) ? mod(vOri.z, .5) : -mod(vOri.z, .5) + .5;\n            vec2 vTHit = vec2(fTHit + abs(fIX / vPTB.x) * length(vPTB) + fStepAdjust,\n                              fTHit + abs(fIZ / vPTB.z) * length(vPTB) + fStepAdjust);\n            bool bXZ = vTHit.x < vTHit.y;\n            fTHit = bXZ ? vTHit.x : vTHit.y;\n            vOri = vOriB + fTHit * vDir;\n\n            if (fTHit < fTHitB)\n            {\n                // get current level data (hash meanwhile)\n                float fHB = hash12(floor(vOri.xz * 2.));\n\n                // side hit ?\n                if (fHB < fGrain)\n                {\n                    // set normal wether X or Z grid plane, return\n                    return bXZ ? vec4(fTHit, -sign(vDir.x), 0., 0.) : vec4(fTHit, 0., 0., -sign(vDir.z));\n                }\n            }\n        }\n        \n        // bottom hit / no hit\n        vOri = vOriB + fTHitB * vDir;\n        return (vDir.y > 0.f) ? vec4(-1.) : vec4(fTHitB, 0., 1., 0.);\n    }\n}\n\n\n// provide a lookat matrix\nmat4x4 LookAtLH(vec3 vCam, vec3 vTar, vec3 vUp)\n{\n    mat4x4 avLookAt;\n    vec3 vZ = normalize(vTar - vCam);\n    vec3 vX = normalize(cross(vUp, vZ));\n    vec3 vY = cross(vZ, vX);\n       \n    avLookAt = \n    mat4x4(\n        vec4(1., 0., 0., -vCam.x),\n        vec4(0., 1., 0., -vCam.y),\n        vec4(0., 0., 1., -vCam.z),\n        vec4(0., 0., 0., 1.)\n    ) *\n    mat4x4(\n        vec4(vX.x, vX.y, vX.z, 0.),\n        vec4(vY.x, vY.y, vY.z, 0.),\n        vec4(vZ.x, vZ.y, vZ.z, 0.),\n        vec4(0., 0., 0., 1.)\n    );\n    \n    return avLookAt;\n}\n\n// provide a perspective projection matrix\nmat4x4 PerspectiveLH(vec2 vFov, vec2 vZnf)\n{\n    float fW = tan(vFov.x*0.5),\n          fH = tan(vFov.y*0.5);\n    \n    mat4x4 avProj = mat4x4( 0.0 );\n    avProj[0][0] = 2. * vZnf.x / fW;\n    avProj[1][1] = 2. * vZnf.x / fH;\n    avProj[2][2] = vZnf.y / (vZnf.y - vZnf.x);\n    avProj[3][2] = 1.;\n    avProj[2][3] = vZnf.x*vZnf.y/(vZnf.x - vZnf.y);\n    \n    return avProj;  \n}\n\n// transform a ray based on screen position, camera position and inverse wvp matrix - Microsoft method\nvoid TransformRay(in uvec2 sIndex, in vec2 sScreenSz, in vec4 vCamPos, in mat4x4 sWVPrInv,\n\tout vec3 vOrigin, out vec3 vDirection)\n{\n\t// center in the middle of the pixel, get screen position\n\tvec2 vXy = vec2(sIndex.xy) + 0.5f;\n\tvec2 vUv = vXy / sScreenSz.xy * 2.0 - 1.0;\n\t\n\t// unproject by inverse wvp\n\tvec4 vWorld = vec4(vUv, 0, 1) * sWVPrInv;\n\n\tvWorld.xyz /= vWorld.w;\n\tvOrigin = vCamPos.xyz;\n\tvDirection = normalize(vWorld.xyz - vOrigin);\n}\n\n// simple checkers\nfloat checkers_001(vec2 vUv, float fDist)\n{\n    return mix(0.3, smoothstep(0.005, 0.005 + fDist * 0.005, min(fract(vUv.x), fract(vUv.y))) * (max(mod(floor(vUv.x), 2.), mod(floor(vUv.y), 2.)) * .25 + .75),\n        (1. - smoothstep(0.995 - fDist * 0.005, 0.995, max(fract(vUv.x), fract(vUv.y)))));\n}\n\n#define AA 3\n\nvoid mainImage(out vec4 cOut, in vec2 vXY )\n{\n    // get current camera position and lookat matrix\n    float fCamDist = 2.6f + sin(iTime * .8);\n    float fOff = sin(iTime) * 2.;\n    vec4 vCamPos = vec4(sin(iTime) * fCamDist, 4.75f, \n                        cos(iTime) * fCamDist + fOff, 0.f);\n    mat4x4 avLookAt = LookAtLH(vCamPos.xyz, vec3(0., 0.45, fOff), vec3(0.f, 1.f, 0.f));\n    \n    // get projection matrix\n    mat4x4 avProj = PerspectiveLH(vec2(radians(90.), radians(60.)), vec2(1., 1000.));\n    \n    cOut = vec4(0.);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    // pixel coordinates\n    vec2 vOff = vec2(float(m),float(n)) / float(AA) - 0.5;\n    vec2 vXYo = vXY + vOff;\n    #else\n    vec2 vXYo = vXY;\n    #endif\n    \n    // get ray\n    vec3 vOri, vDir;\n    TransformRay(uvec2(vXY), iResolution.xy, \n        vCamPos, inverse(avLookAt * avProj), vOri, vDir);\n    \n    // do raytracing\n    float fTHit = -1.f, fTDist = 0.f, fB = 1.f;\n    vec4 vTHitNor;\n    PosNorm sAttr;\n    \n    // intersect primitives\n    vec3 vNor = normalize(vec3(sin(iTime * .3), cos(iTime * .2), sin(iTime * .4)));\n    vec3 vOriT = vOri;\n    vTHitNor = iVoxelPlanar(vOriT, vDir);\n    fTHit = vTHitNor.x;           \n    \n    // skip far/no hit\n    if ((fTHit < 0.) || (fTHit > 16.)) return;\n    \n    // get lit position + normal (hit attributes)\n    sAttr.vPosition = vOriT;\n    sAttr.vNormal = vTHitNor.yzw;\n    \n    // get tex uv\n    vec2 vUv = sAttr.vPosition.xz;\n             \n    // simple checkers\n    const vec3 vLight = normalize(vec3(-.4f, .2f, -.3f)); \n    float fOcc = 0.7 + 0.3*sAttr.vNormal.y;\n    fB *= (1. - fTHit * .1) * checkers_001(vUv * 2., fTHit) * fOcc;\n    \n    // set color (hue gradient)\n    float fTile = hash12(floor(vOriT.xz * 2.));\n    vec3 cLit = mix(vec3(.1f, .1f, .2f), hueGradient(fTile), fB);\n\t\n    // set lighting\n    float fDist = length(sAttr.vPosition.xyz - vOri);\n\tvec3 vRef = normalize(reflect(vDir, sAttr.vNormal));\n\tfloat fFresnel = max(dot(sAttr.vNormal, -vDir), 0.0);\n    float fSpecular = max(dot(vRef, vLight), 0.0);\n\tfFresnel = pow(fFresnel, .3) * 1.1;\n\tcLit = mix(cLit * .5, cLit * max(dot(sAttr.vNormal, vLight), 1.), min(fFresnel, 1.0));\n    cLit += pow(fSpecular, 100.) * .3;\n\tcLit = clamp(cLit, 0.f, 1.f);    \n\t                \n    cOut += vec4(cLit, 1.);\n                \n    #if AA>1\n    }\n    cOut /= float(AA*AA);\n    cOut.a = 1.f;\n    #endif\n}","name":"Image","description":"","type":"image"}]}