{"ver":"0.1","info":{"id":"Nd2fDD","date":"1646331748","viewed":98,"name":"Distorted Menger 3","username":"lwswl","description":"A Menger Sponge distorted.\nY axis | of mouse to zoom in.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","distortion","menger","sponge"],"hasliked":0,"parentid":"ssBBDD","parentname":"Distorted Menger 1"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n *  by Louis Sarwal\n *\n**/\n\n#if HW_PERFORMANCE==1\n//uncomment this if you have a decent GPU. It improves the sponge s lot.\n//#define AA\n#endif\n//the max steps\n#define MAX_STEPS 65536\n//only used for computing normals\n#define near 0.000001\n#define far 100.\n//this number defines the number of subdivisions in the menger cube when computed for light. When not computing lights, the number of subdivions is infinite, and is only not sampled when epsilon has been reached, which is set dynamically based on the distance of the ray to the cube after the first epsilon(for the non-menger) has been reached, and the screen resolution.\n#define MENGER_LIGHT_DENSITY 3.0\n#define lerp(a, b, k,) a*(k-1.0)+b*k\n\nfloat cubeSDF(vec3 p,float f){\n    vec3 v = abs(p) - vec3(f);\n    return length(max(v,0.0)) + min(max(v.x,max(v.y,v.z)),0.0);\n}\n\nfloat mengerSDF(vec3 p, float limit){\n    float r=1.;\n    float II=0.;\n    vec3 o=vec3(0);\n    float d=0.0;\n    \n    float f;\n    \n    if(II==0.)d=cubeSDF(p+o,r);\n    if (d>r*1.414213562)return d;//1.414213562=sqrt(2)\n    vec3 no=vec3(0);\n    \n    r/=3.;\n    while (d<r*1.414213562&&(II<limit||limit==0.)){\n        \n        d=far;\n        f=cubeSDF(p+o+vec3(2.*r,2.*r,0),r);if(f<d){d=f;no=o+vec3(2.*r,2.*r,0);}\n        f=cubeSDF(p+o+vec3(2.*r,0,2.*r),r);if(f<d){d=f;no=o+vec3(2.*r,0,2.*r);}\n        f=cubeSDF(p+o+vec3(0,2.*r,2.*r),r);if(f<d){d=f;no=o+vec3(0,2.*r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*r,0),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*r,0);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*-r,0),r);if(f<d){d=f;no=o+vec3(2.*r,2.*-r,0);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*-r,0),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*-r,0);}\n        f=cubeSDF(p+o+vec3(2.*-r,0,2.*r),r);if(f<d){d=f;no=o+vec3(2.*-r,0,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,0,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*r,0,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,0,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*-r,0,2.*-r);}\n        f=cubeSDF(p+o+vec3(0,2.*-r,2.*r),r);if(f<d){d=f;no=o+vec3(0,2.*-r,2.*r);}\n        f=cubeSDF(p+o+vec3(0,2.*r,2.*-r),r);if(f<d){d=f;no=o+vec3(0,2.*r,2.*-r);}\n        f=cubeSDF(p+o+vec3(0,2.*-r,2.*-r),r);if(f<d){d=f;no=o+vec3(0,2.*-r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*-r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*-r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*-r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*-r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*-r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*-r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*-r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*-r,2.*-r);}\n        if(limit!=0.)II++;\n        o=no;\n        r/=3.;\n        \n        \n    }\n    //if(II>limit){\n    //    return cubeSDF(p+o,r);\n    //}\n    return d;\n    \n    \n    \n     \n}\n\nbool PLANE=false;\nfloat planeSDF( vec3 p, vec3 n,float d){\n  return dot(p,n)+d;\n}\nvec3 PLANE_NORMAL=vec3(0);\nfloat n(float t){\n    float x=fract(t);\n    return (1.-x)*(1.-x)+x*x;\n}\nvec2 sceneSDF(vec3 p, float limit){\n    vec3 distort=vec3(\n    2.-n(p.y*4.-0.5)*0.2-n(p.z*2.)*0.4,\n    4.-n(p.x*0.5+0.5)-n(p.z*0.5+0.5),\n    2.-n(p.y*8.+0.5)*0.2-n(p.x*2.)*0.4\n    );\n    distort*=vec3(n(p.y+0.5),0.9,n(p.y+0.5));\n    float mng=mengerSDF(p*distort,limit);\n    \n    return vec2(mng,0.);\n}\nfloat getEplison(float dist,float R){\n    return clamp(5.*pow(dist*0.1,1.1)*R,0.00000001,0.1);\n}\nvec3 rayMarch(vec3 o, vec3 d, float start, float end, int max_steps, bool for_lights){\n    float R=1.0/length(iResolution.xy);\n    float depth = start;\n    float fd= 0.0005;\n    float limit=0.0;\n    bool a_bool=false;\n    if(for_lights)limit=MENGER_LIGHT_DENSITY;\n    for (int i = 0; i < max_steps; i++) {\n        \n        vec2 dist = sceneSDF(o + depth * d, limit);\n        if(dist.y==0.&&!a_bool&&dist.x<0.0005){\n            fd=getEplison(depth+dist.x,R);\n            a_bool=true;\n            //fd=0.0001;\n            //if(!for_lights)limit=round(2./dist.x);\n        }\n        else if (dist.x < fd){\n            //if(dist.y>0.9)\n            return vec3(depth,dist.y,fd);\n        }\n        depth += dist.x*0.3;//bad, but it gets around the broken distance field\n        if (depth >= end)return vec3(end,0,fd);\n    }\n    return vec3(end,0,fd);\n}\n\n\nvec3 normal(vec3 p, float n){\n    return normalize(vec3(sceneSDF(vec3(p.x+n,p.yz),0.).x-sceneSDF(vec3(p.x-n,p.yz),0.).x,\n                sceneSDF(vec3(p.x,p.y+n,p.z),0.).x-sceneSDF(vec3(p.x,p.y-n,p.z),0.).x,\n                sceneSDF(vec3(p.xy,p.z+n),0.).x-sceneSDF(vec3(p.xy,p.z-n),0.).x\n           ));\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = sceneSDF(ro + rd*t, MENGER_LIGHT_DENSITY).x;\n        if( h<mint*0.1 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n        \n    }\n    return res;\n}\nfloat light_func(vec3 p, vec3 light, bool shadows){\n    float len=dot(light-p,light-p);\n    float f=1.0/len;\n    //f.rgb=N;\n    if(shadows){\n        float y=rayMarch(p,normalize(light-p),0.01,100.,128,true).x;\n        if(y<len)return 0.;\n    }\n    if(f<0.)return 0.;\n    return f;\n}\nfloat dist_light_func(vec3 p, vec3 normal, vec3 light,bool shadows){\n    light.xyz=normalize(light);\n    float len=dot(normal,light);\n    float f=len;\n    if(PLANE)f+=10.*pow(len,15.);\n    //f.rgb=N;\n    if(shadows){\n        float k=4.;\n        if(PLANE)k=64.;\n        f*=softShadow(p,light.xyz, 4.,128.,k);\n    }\n    if(f<0.)return 0.;\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.rgb=vec3(0);\n    //this gives it time\n    if(iTime>0.1){\n        vec2 mouse=iMouse.xy/iResolution.xy;\n        if(iMouse.x==0.)mouse+=0.9;\n        \n        float dist=(sin(0.25*iTime)*0.3+0.7)*7.3*(mouse.y*mouse.y+0.1);\n        vec3 o=vec3(sin(iTime-mouse.x*6.)*dist,0,cos(iTime-mouse.x*6.)*dist);\n\n#ifdef AA\n\n        \n        for(int i=0;i<4;i++){\n            vec2 uv = ((fragCoord+0.5*vec2(i/2,i%2))/iResolution.xy-0.5)*normalize(iResolution.xy);\n#else\n            vec2 uv = (fragCoord/iResolution.xy-0.5)*normalize(iResolution.xy);\n#endif\n\n\n            vec3 d=normalize(vec3(uv,1.1));\n            vec3 f=vec3(0.5,uv.y+0.3+0.5,uv.y+0.5)*0.1;\n            vec3 a = normalize(vec3(0,0,0)-o);\n            vec3 b = cross(a, vec3(0,1,0));\n            vec3 c = cross(b, a);\n            mat3 cm=mat3(b,c,a);\n            d*=cm;\n            d=normalize(d);\n            vec3 t=rayMarch(o,d,0.0018,far,MAX_STEPS, false);\n            if (t.x<far){\n                vec3 p=o+d*t.x;\n                vec3 N;\n                vec3 albedo=vec3(0);\n                \n                if(t.y>0.9){\n                    albedo=vec3(0.04,0.06,0.14)+clamp(-p.y*0.1-0.2,0.0,1.0);\n                    N=PLANE_NORMAL;\n                }\n                else {\n                    albedo=vec3(0.4);\n                    N=normal(o+d*t.x,t.z);\n                }\n\n                f.rgb*=albedo;//*vec3(dot(N,vec3(0,1,-1)));\n                t.z=clamp(t.z,0.01,0.1);\n                f.rgb+=albedo*dist_light_func(p,N,vec3(0.5,0.5,0.5),true)*vec3(0.9,0.5,0.4);\n                f.rgb+=albedo*light_func(p,vec3(0,0,0),true)*vec3(1,0,0);\n\n\n            }\n            #ifdef AA\n            fragColor.rgb+=f*0.25;\n            #else\n            fragColor.rgb=f;\n            #endif\n\n#ifdef AA\n        }\n#endif\n\n        fragColor.rgb=sqrt(fragColor.rgb);\n    }\n}","name":"Image","description":"","type":"image"}]}