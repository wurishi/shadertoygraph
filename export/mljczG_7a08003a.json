{"ver":"0.1","info":{"id":"mljczG","date":"1692115738","viewed":54,"name":"RayMarchLighting Learning","username":"thekiross","description":" :D","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarchlighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//code uses references from following shader https://www.shadertoy.com/view/3styDs\n//also from following resource https://iquilezles.org/articles/distfunctions/\n#define LIGHT_MODEL 4\n//Note 1 - Phong Light Model\n//     2 - Blinn-Phong \n//     3 - Diffuse + Ambient Light\n//     4 - Diffuse + Ambient + Rim Light\n\nvec3 getLightPos(){\n    return vec3(20.0,40.0,-30.0);\n}\n\n//structs\n\n\nSurface Union(in Surface surface1, in Surface surface2) {\n    Surface surfaceUnion = surface1;\n    if (surface2.signedDistance < surfaceUnion.signedDistance) {\n        surfaceUnion = surface2;\n    }\n\n    return surfaceUnion;\n}\nMaterial materialBlend(Material material1,Material material2 ,float t ){\n    Material smoothUnion = Material(\n       mix(material1.color,material2.color,t),\n       mix(material1.specular,material2.specular,t),\n       mix(material1.ambient,material2.ambient,t),\n       mix(material1.rim,material2.rim,t),\n       mix(material1.rimColor,material2.rimColor,t)\n       );\n    return smoothUnion;\n}\n//Mix between two surfaces\nSurface BlendSurface (in Surface surface1, in Surface surface2, float t){\n    float blendDistance = mix( surface1.signedDistance, surface2.signedDistance, t );\n    Surface surfaceBlend = Surface(blendDistance, materialBlend(surface1.material,surface2.material,t));\n    return surfaceBlend;\n}\n//Smooth Union Function\nSurface SmoothUnion (in Surface surface1, in Surface surface2, float k){\n    \n    float h = clamp( 0.5 + 0.5*(surface2.signedDistance - surface1.signedDistance)/k, 0.0, 1.0 );\n    float smoothDistance = mix( surface2.signedDistance, surface1.signedDistance, h ) - k*h*(1.0-h);\n    Surface surfaceUnionSmooth = Surface(smoothDistance, materialBlend(surface1.material,surface2.material,h));\n    return surfaceUnionSmooth;\n} \n\n\nMaterial getMaterial(float id){\n    Material mat = Material(vec3 (1.0),1.,1.,1.,vec3(1.0));\n    switch(int(id)){\n    case 1: break;\n    case 2: mat.color = vec3(0.7,0.0,0.0); mat.specular = 0.5; mat.ambient = 0.1; mat.rim =0.7;mat.rimColor = vec3(214.0/255., 126.0/255.0, 21.0/255.0);break;\n    case 3: mat.color = vec3 (1.0); mat.specular = 0.2;mat.rim = 0.1; mat.rimColor = vec3(0.0);mat.ambient = 0.2; break;\n    case 4: mat.color = vec3(0.0,0.7,0.0); mat.specular = 0.5; mat.ambient = 0.1; mat.rim =0.7;mat.rimColor = vec3(21.0/255.0, 214.0/255.0, 148.0/255.0);break;\n    }\n    return mat;\n}\n\n//SCENE SURFACE\nSurface mapScene(in vec3 p){\n\n    Surface result; \n    Material checkBoardMat = getMaterial(3.0);\n    vec3 sphereOffset = vec3(p.x+sin(iTime)*3.+3.0,p.y,p.z),\n         sphereOffset2 = vec3(p.x+sin(-iTime)*3.0-3.0,p.y,p.z);\n         \n    Surface sphere = Surface(sdSphere(sphereOffset,2.0),getMaterial(2.0)); \n    Surface sphere2 = Surface(sdSphere(sphereOffset2,2.0),getMaterial(2.0));\n    \n    Surface sphereSmoothUnion = SmoothUnion(sphere,sphere2,0.3);\n    \n    Surface box = Surface(sdRoundBox(p,vec3(1.5,4.0,1.5),0.3),getMaterial(4.0));\n    Surface box2 = Surface(sdRoundBox(p,vec3(4.0,1.5,1.5),0.3),getMaterial(4.0));\n    Surface box3 = Surface(sdRoundBox(p,vec3(1.5,1.5,4.0),0.3),getMaterial(4.0));\n    \n    Surface octahedron  = Surface(sdOctahedron(p, 4.), getMaterial(2.0));\n    checkBoardMat.color = vec3 (.2 + .4 * mod(floor(p.x)+floor(p.z),2.0));\n    \n    Surface plane = Surface(sdPlane(p,vec3(0.,1.,0.),5.),checkBoardMat);\n    result = Union(BlendSurface(BlendSurface(SmoothUnion(SmoothUnion(box,box2,0.3),box3,0.3),sphereSmoothUnion,clamp(sin(iTime+2.5),0.0,1.0)),octahedron,clamp(sin(iTime+.5),0.0,1.0)),plane);\n    return result;\n}\nvec3 getNormal(vec3 p){\n     vec3 v1 = vec3 (\n   mapScene(p + vec3(EPSILON,0.0,0.0)).signedDistance,\n   mapScene(p + vec3(0.0,EPSILON,0.0)).signedDistance,\n   mapScene(p + vec3(0.0,0.0,EPSILON)).signedDistance);\n   \n     vec3 v2  = vec3(\n   mapScene(p - vec3(EPSILON,0.0,0.0)).signedDistance,\n   mapScene(p - vec3(0.0,EPSILON,0.0)).signedDistance,\n   mapScene(p - vec3(0.0,0.0,EPSILON)).signedDistance);\n   \n   return normalize(v1-v2);\n \n}\n\nfloat mapShadow(in vec3 p, in vec3 normal, in float softness) {\n    float softShadow = 1.0;\n    vec3 lightDirection = normalize(getLightPos()-p);\n    p += normal * SHADOW_BIAS;\n    float shadowDistance = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; iterations++) {\n        vec3 shadowTestPosition = p + lightDirection * shadowDistance;\n        Surface occluderSurface = mapScene(shadowTestPosition);\n        if (abs(occluderSurface.signedDistance) < MIN_DIST) {\n            return 0.0;\n        }\n\n        if (shadowDistance > MAX_DIST) {\n            break;\n        }\n\n        shadowDistance += occluderSurface.signedDistance;\n        softShadow = min(softShadow, softness * occluderSurface.signedDistance / shadowDistance);\n    }\n\n    return softShadow;\n}\n//Lambert lighting diffuse model\nvec3 getDiffuse(in vec3 lightVector,in vec3 normalVector,in Material mat){\n    return clamp(dot(lightVector,normalVector),0.0,1.0)*mat.color;\n}\n//Base Phong light model\nvec3 getPhongSpecular(in vec3 normalVector,in vec3 eyeVector,in vec3 lightVector,in Material mat){\n    vec3 reflection = normalize(-reflect(lightVector,normalVector));\n    return max(dot(reflection,eyeVector),0.0)*mat.specular*mat.color;\n}\nvec3 getBlinnSpecular(in vec3 normalVector,in vec3 eyeVector,in vec3 lightVector,in Material mat){\n    vec3 halfway = normalize(lightVector+eyeVector);\n    return dot(normalVector,halfway) * mat.specular*mat.color;\n}\nvec3 getRimLight(in vec3 normalVector,in vec3 eyeVector,in vec3 lightVector,in Material mat){\n    float  rimLightIntensity = dot(eyeVector,normalVector);\n    rimLightIntensity = 1.0 - rimLightIntensity;\n    rimLightIntensity = max(0.0, rimLightIntensity);\n    \n    return mat.rimColor*pow(rimLightIntensity,mat.rim);\n}\nvec3 getFog(vec3 mapCol,vec3 backColor, float d){\n        float fogFactor  = 1. - exp(-FOG_DENSITY*FOG_DENSITY*d*d);\n        \n        return mix(mapCol,backColor, fogFactor);\n}\nvec3 getLighting (in vec3 p,in Ray ray,in Material mat){\n    vec3 resultLight = vec3(0.0);\n    vec3 unitLight = normalize(getLightPos()-p);\n    vec3 normal = getNormal(p);\n    vec3 eye = - ray.direction;\n    \n    vec3 diffuse = getDiffuse(unitLight,normal, mat);\n    vec3 specular = vec3(0.0);\n    vec3 ambient = vec3 (0.0);\n    vec3 rim = vec3 (0.0);\n    \n    switch (LIGHT_MODEL){\n        //simple Phong\n        case 1: \n        specular = getPhongSpecular(normal,eye,unitLight,mat);\n        ambient = mat.color* mat.ambient;\n        break;\n        //Blinn-Phong\n        case 2: \n        specular = getBlinnSpecular(normal,eye,unitLight,mat);\n        ambient = mat.color*mat.ambient;\n        break;\n        //Diffuse+Ambient\n        case 3:\n        ambient = mat.color* mat.ambient;\n        break;\n        //Diffuse+Ambient+Rim\n        case 4:\n        rim  = getRimLight(normal,eye,unitLight,mat);\n        ambient = mat.color* mat.ambient;\n        break;\n    }\n    \n    return  mapShadow(p, normal, 2.0)*(diffuse+specular)+ambient+rim;\n}\n\n\nvec3 rayMarch(in Ray ray){\n    float distanceTraveled = 0.0;\n    vec3 resultColor = vec3(0.0);\n    for(int i=0;i<MAX_STEPS;i++)\n    {\n        vec3 p = ray.origin + ray.direction*distanceTraveled;\n        Surface map = mapScene(p);\n        if(abs(map.signedDistance)<MIN_DIST){\n            resultColor += getLighting(p, ray, map.material);\n            \n            //resultColor+= getFog(resultColor,backColor,map.signedDistance);\n            return resultColor;\n        }\n        if(distanceTraveled>MAX_DIST){ break;}\n        \n        distanceTraveled += map.signedDistance;\n        \n    }\n    resultColor+=backColor - max(.9*ray.direction.y,0.);\n    return resultColor;\n}\n\nmat3 getCam(vec3 ro, vec3 lookAt){\n    vec3 camF = normalize(vec3(lookAt - ro));\n    vec3 camR = normalize(cross(vec3(0.,1.,0.),camF));\n    vec3 camU = cross(camF,camR);\n    return mat3(camR,camU,camF);\n}\nvoid mouseControl(inout vec3 ro){\n    vec2 m = 2.* iMouse.xy/iResolution.xy;\n    pR(ro.yz,m.y * PI*0.5-0.5);\n    pR(ro.xz,m.x * TAU);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec3 ro = vec3(15.,15.,-15.);\n    vec3 lookAt = vec3(0.);\n    mouseControl(ro);\n    vec3 rd = getCam(ro,lookAt) * normalize(vec3(uv,CAMERA_FOV));\n    Ray ray = Ray(ro,rd);\n    vec3 col = rayMarch(ray);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_STEPS 256\n#define MIN_DIST .005\n#define MAX_DIST 500.\n#define CAMERA_FOV 1.\n#define PI 3.1415926535897932384626433832795\n#define TAU (2.*PI)\n#define PHI (sqrt(5.)*0.5+0.5)\n#define saturate(x) calmp(x,0,1)\n#define EPSILON .001\n#define FOG_DENSITY 1.\n#define SHADOW_BIAS (MIN_DIST * 2.0)\n\n\nconst vec3 backColor = vec3 (.5,.8,1.);\nstruct Material{\n    vec3 color;\n    float specular;\n    float ambient;\n    float rim;\n    vec3 rimColor;\n};\nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Surface{\n    float signedDistance;\n    Material material;\n};\n\nfloat sdSphere (in vec3 p,in float r){\n    return length (p)-r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdOctahedron( vec3 p, float s )\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\nfloat sdPlane(vec3 p, vec3 n, float distanceFromOrigin){\n    return dot(p,n) + distanceFromOrigin;\n}\nvoid pR(inout vec2 p, float a){\n    p = cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n","name":"Common","description":"","type":"common"}]}