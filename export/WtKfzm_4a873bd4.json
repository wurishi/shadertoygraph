{"ver":"0.1","info":{"id":"WtKfzm","date":"1614113960","viewed":70,"name":"exoRaymarching","username":"Corentin","description":"apprentissage","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//thanks remy\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n//thanks iq\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nvec3 opRep(vec3 p, vec3 bound)//to repeat\n{\n    return mod( p+0.5*bound,bound)-0.5*bound;\n    \n}\n\nfloat map(vec3 pos)\n{\n    pos = opRep(pos,vec3(3.0,10.0,6.50));//to repeat\n\n    pos.yz *= rot(sin(abs(iTime*5.)*0.1)*4.);\n\n    float world = sdRoundBox(pos, vec3(0.5),0.5);\n    world = opSmoothUnion(world, sdRoundBox(pos, vec3(0.5),0.5),0.5);\n    return world;\n}\nfloat CastRay(vec3 ro, vec3 rd)\n{\n    float c = 0.0; // c = contact, pret a stocker la distance\n    \n    for(int i=0; i<64; i++) //64 = nbre de marche\n    {\n        float ray = map(ro + rd * c);\n        \n        if(ray < (0.0001*c)) //proximitÃ© avec l'objet\n        {\n            return float(i)/32.;            \n        }\n        \n        c += ray; // sinon, si trop loin, on avance d'une marche\n    }\n    \n    // no contact after march\n    return -1.0;\n}\n\n\nvec3 render(vec3 ro, vec3 rd)// ray origin et ray direction\n{\n    float contact = CastRay(ro,rd); //simulation de raymarching\n    \n    vec3 col = vec3(0.0);\n    \n    if(contact == -1.0)\n    {\n        //no contact\n        col = vec3(0.0);\n    }\n    else\n    {\n        //contact\n        col = vec3(1.0-contact);\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * fragCoord/iResolution.xy -1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //camera\n    vec3 cameraPos = vec3(0.0,10.0+iTime,5.0);\n    vec3 cameraTar = vec3(0.0);\n\n    //ray direction\n    vec3 forward = normalize(cameraTar - cameraPos);\n    vec3 right = normalize(cross(vec3(5.0,sin(10.*360.)*10., 0.0),forward));\n    vec3 up = cross(right, forward);\n    vec3 viewDir = normalize(uv.x * right + uv.y * up + forward * 2.0);\n    \n    \n    // Time varying pixel color\n    vec3 col = vec3(uv.x, uv.y, 0.0);\n    \n    vec3 color = vec3(0.2,0.7,.55)*0.5;\n    \n    col = render(cameraPos , viewDir);\n\n    // Output to screen\n    fragColor = vec4( (col-0.3) + color,1.0);\n}","name":"Image","description":"","type":"image"}]}