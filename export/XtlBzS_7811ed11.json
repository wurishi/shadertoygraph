{"ver":"0.1","info":{"id":"XtlBzS","date":"1512308607","viewed":395,"name":"Digital waterfall","username":"kobilica","description":"Playing around with noise functions and pixels. ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["noise","square","digital","8bit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat random(in float x){\n    return fract(sin(x)*43758.5453);\n}\n\nfloat random(in vec2 st){\n    return fract(sin(dot(st.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat randomColor(in vec2 st) {\n \n    return fract(random(st.x + st.y*st.x + st.y) - st.y + st.x);\n}\n\nvec3 matrix(in vec2 st) {\n    \n    float rows = 128.0;\n    \n    //integer positions\n    vec2 ipos = floor(st * rows);\n    \n    //this is where dancing happens, I am just shifting rows and columns of matrix. Looks very nice.\n    //also when I say shifting, it's not really shifting, since there is sin function in it. It's shifting only on some places. \n    ipos.y += floor(2.5*iTime + 1.5*sin(random(ipos.x)*iTime)*random(ipos.y));\n    \n    return vec3(randomColor(ipos));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //normalizing\n\tvec2 st = fragCoord.xy / iResolution.x;\n    \n\tfragColor = vec4(vec3(matrix(st)), 1.0);\n}","name":"Image","description":"","type":"image"}]}