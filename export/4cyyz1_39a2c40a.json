{"ver":"0.1","info":{"id":"4cyyz1","date":"1731453479","viewed":50,"name":"Diamond Pixel Sorting","username":"Janniboy","description":"Showcases pixel sorting based on grayscale values. Due to the specific sorting rules this leads to a diamond shape in the center where the pixels move in a loop.\nLeft Click to reset the simulation!","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["automata","sorting","pixelsorting"],"hasliked":0,"parentid":"4fGcR1","parentname":"Basic Pixel Sorting"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int size = 150;\n\nvec4 getColor(vec2 coords) {\n    return texelFetch(iChannel0, ivec2(coords),0);\n}\n\nfloat metric(vec2 coords) {\n    vec4 color = getColor(coords);\n    return (color.r + color.g + color.b) / 3.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if (iFrame == 0 || iMouse.z > 0.) {\n        fragColor = texture(iChannel1, uv);\n    } else {\n        vec2 offset = vec2(0);\n        \n        vec2 posDiff = iResolution.xy / 2. - fragCoord;\n        \n        if (abs(int(posDiff.x)) + abs(int(posDiff.y)) < size) {\n            offset = vec2(0,1);\n            \n            if (uv.x > 0.5) {\n                if (uv.y > 0.5) {\n                    offset = vec2(-1, 1);\n                } else {\n                    offset = vec2( 1, 1);\n                }\n            } else {\n                if (uv.y > 0.5) {\n                    offset = vec2(-1,-1);\n                } else {\n                    offset = vec2( 1,-1);\n                }\n                \n            }\n        }\n        \n        bool evenRound = iFrame % 2 == 0;\n        bool evenPixel = int(fragCoord.y) % 2 == 0;\n        bool isFirstPixel = evenRound == evenPixel;\n        \n        vec2 firstPixel;\n        vec2 secondPixel;\n        \n        if (isFirstPixel) {\n            // compare with next\n            firstPixel = fragCoord;\n            secondPixel = fragCoord + offset;\n        } else {\n            // compare with previous\n            firstPixel = fragCoord - offset;\n            secondPixel = fragCoord;\n        }\n        \n        if (firstPixel.x >= 0. && firstPixel.y >= 0. && secondPixel.x < iResolution.x && secondPixel.y < iResolution.y) {\n            bool sorted = metric(firstPixel) < metric(secondPixel);\n            if (sorted == isFirstPixel) {\n                fragColor = getColor(firstPixel);\n            } else {\n                fragColor = getColor(secondPixel);\n            }\n        } else {\n            fragColor = getColor(fragCoord);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}