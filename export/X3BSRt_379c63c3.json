{"ver":"0.1","info":{"id":"X3BSRt","date":"1710911350","viewed":52,"name":"triangle_dot_cross_noise","username":"yufengjie","description":"triangle_dot_cross_noise","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["triangle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand(float x) {\n  return fract(sin(x) * 0.5 + 0.5);\n  //return fract(sin(x * 5682.4585) * 0.5 + 0.5);\n}\n\nfloat noise(float x) {\n // 其实没必要用noise，用noise能给加一丢丢的变化\n // return sin(x) * 0.5 + 0.5;\n\n  float i = floor(x);\n  float f = fract(x);\n  return mix(rand(i), rand(i+1.), smoothstep(0.,1.,f));\n  \n}\n\nvec3 palette(float t) {\n  vec3 a = vec3(0.613, 0.232, 0.012);\n  vec3 b = vec3(0.780, 0.265, 0.388);\n  vec3 c = vec3(0.066, 1.535, 0.275);\n  vec3 d = vec3(2.145, 3.592, 1.964);\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\n// p 屏幕坐标 abc三角形顶点坐标\nfloat getTriangle(vec2 p,vec2 a,vec2 b, vec2 c) {\n    // 按照顺时针/逆时针定义向量方向\n    vec2 ab = b-a;\n    vec2 bc = c-b;\n    vec2 ca = a-c;\n    \n    // 法向量\n    vec2 abf = vec2(ab.y,-ab.x);\n    vec2 bcf = vec2(bc.y,-bc.x);\n    vec2 caf = vec2(ca.y,-ca.x);\n    \n    // 从顶点到屏幕坐标的向量\n    vec2 ap = p-a;\n    vec2 bp = p-b;\n    vec2 cp = p-c;\n    \n    // 点乘用来判断p点是否在三角形中\n    float va = dot(abf, ap);\n    float vb = dot(bcf, bp);\n    float vc = dot(caf, cp);\n    \n    float triangle = 0.;\n    \n    // 全都整数/负数代表着p点是否在三角形之内\n    if(va>0.&&vb>0.&&vc>0.) {\n        triangle = 1.;\n    }\n    \n    if(va<0.&&vb<0.&&vc<0.) {\n        triangle = 1.;\n    }\n    \n    return triangle;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float t = iTime;\n    \n    vec3 fin_col = vec3(0.);\n\n    for(float i=0.;i<10.;i+=.1) {\n        float v = i;\n        // 顶点的初始值xy加点偏移值，能看到更多的变化，让他们随着时间改变顶点坐标\n        vec2 a = vec2(noise(0.1 + v + t), noise(0.9 + v));\n        vec2 b = vec2(noise(0.9 + v), noise(0.1 + v + t));\n        vec2 c = vec2(noise(0.5 + v + t), noise(0.5 + v));\n\n        float triangle = getTriangle(uv, a, b, c);\n        vec3 col = palette(i+t);\n        \n        // fin_col = mix(fin_col, col, 1. - i / 10.) * triangle;\n        fin_col += col * triangle;\n    }\n    \n\n    fragColor = vec4(fin_col,1.0);\n}","name":"Image","description":"","type":"image"}]}