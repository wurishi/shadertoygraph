{"ver":"0.1","info":{"id":"wtdSWr","date":"1580797732","viewed":101,"name":"Mandelbort Lesson 2","username":"LiorZar","description":"Mandelbort fractals","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["mandelbort"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int MandelBrot(vec2 uv) \n{\n    vec2 Z = uv, T;\n    \n    for( int i = 0; i < 200; ++i)\n    {\n        if( dot(Z, Z) > 4.0 )\n            return i;\n        \n        Z = vec2(Z.x * Z.x - Z.y * Z.y, 2.0 * Z.x * Z.y) + uv;\n    }\n    return 0;\n} \nvoid mainImage( out vec4 O, vec2 u )\n{\n    //O -=O;\n    vec3 data = T(2).xyz;    \n    vec2 uv = toUV(u, iResolution);\n    \n    vec2 pt = toPoint( data, uv );\n    float ret = float(MandelBrot(pt));\n    \n    //pt /= data.z;\n    // Turn the iteration count into a color.\n    O = vec4(sin(vec3(0.1, 0.2, 0.5) * ret), 1);\n    //O = vec4(pt,0.,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 O, in vec2 U )\n{\n    if(U==vec2(2.5))\n    {\n        if( iFrame < 10 )\n            O = vec4(0.0,0.0,2.0,0.0);\n        else\n            O = T(2);\n    }\n    if ( U==vec2(.5) ) \n        O = iMouse;                                                 // previous mouse state\n\n    if ( U==vec2(1.5) )\n        O = vec4( iMouse.w > 0.,                                    // down event\n                  iMouse.z < 0. && T(0).z > 0.,                     // up event\n                  iMouse.w > 0. && iTime -T(1).w < BICLICK_DELAY,   // bi-click-event\n                  T(1).y > 0. ? iTime : T(1).w );                   // time of last up event\n                  \n    if( U==vec2(2.5) && mouse_up )\n    {     \n         vec3 data = T(2).xyz;\n         vec2 uv = toUV(iMouse.xy, iResolution);\n         vec2 pt = toPoint( data, uv );\n         O = vec4(pt, data.z*0.15,0.0);        \n     }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define T(U) texelFetch(iChannel0, ivec2(U), 0 )\n\n#define mouse_down     T(1).x > 0. \n#define mouse_up       T(1).y > 0. \n#define mouse_biclick  T(1).z > 0. \n\n#define BICLICK_DELAY   .3\n\nvec2 toUV( vec2 u, vec3 R )\n{\n    vec2 uv = u.xy/R.y;\n    uv = uv*2.0 - vec2(1.0); // [-1,1]\n    return uv;\n}\nvec2 toPoint( vec3 data, vec2 uv )\n{\n    vec2 center = data.xy;\n    float zoom = data.z;\n    return center + uv*zoom;\n}\n","name":"Common","description":"","type":"common"}]}