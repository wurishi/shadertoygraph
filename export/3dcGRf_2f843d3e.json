{"ver":"0.1","info":{"id":"3dcGRf","date":"1578366574","viewed":180,"name":"Untitled 0x00000008","username":"harry7557558","description":"test 100% reflective surface","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["temp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n#define Unit 0.5*length(iResolution.xy)\n\n\n// Modeling\n\n#define MIN_D 1e-2\n#define MAX_D 1e+3\n#define RTMinD 1e-2\n#define RTMaxD 1e+12\n\nconst float h=0.5, h1=0.51, w=1.618, s=10.0, wp=1.0;\nconst vec2 r = vec2(s,s*w);\n\nfloat surf(vec3 p, out vec3 grad) {\n    float m=length(p.xy), n=m-iTime;\n    float r=h*sin(n);\n    m=h*cos(n)/m;\n    grad.x=p.x*m;\n    grad.y=p.y*m;\n    grad.z=1.0;\n    //return (p.z+r)/sqrt(dot(grad,grad)+1.0);\n    return 0.9*(p.z+r)/length(grad);\n}\nbool surfint(vec3 p, vec3 d, out float t, out vec3 n){\n    if (d.z>0.0 && p.z>h1) return false;\n    float sd;\n    t=10.0*MIN_D;\n    if (d.z<0.0&&p.z>h1) t=-(p.z-1.0)/d.z;\n    for (int i=0;i<100;i++){\n        sd=surf(p+t*d,n);\n        if (sd<-MIN_D) return false;\n        t+=sd;\n        if (t>MAX_D) return false;\n        if (t<MIN_D) break;\n    }\n    return true;\n}\n\nbool sphint(vec3 p, vec3 d, out float t, out vec3 n){\n    p.z-=h1+1.0;\n    if (dot(p, d) >= 0.0) return false;\n\tvec3 k = cross(p, d); float rd2 = dot(k,k); if (rd2 >= 1.0) return false;\n\tt = sqrt(dot(p,p) - rd2) - sqrt(1.0 - rd2); if (t < RTMinD) return false;\n\tn = p + t * d; return true;\n}\n\n// a debugging function, it looks nice so I decide to keep it\n// example image at iTime=1.90 see https://i.imgur.com/flZjpMR.png\n/*bool trackint(vec3 p, vec3 d, out float t, out vec3 n){\n    const float s=3.0;\n    float t1 = d.x+d.y/w, t2 = p.x+p.y/w, delta=4.0*s;\n    float a=2.*t1*t1, b=2.*t1*t2-delta*d.z, c=t2*t2+delta*(h1-p.z);\n    delta=sqrt(b*b-2.*a*c); if (delta<0.) return false;\n    delta=sqrt(delta)/a; b=-b/a;\n    t1=b+delta,t2=b-delta;\n    if (t1<RTMinD) t1=RTMaxD; if (t2<RTMinD) t2=RTMaxD;\n    t=min(t1,t2); if (t>=RTMaxD) return false;\n    vec3 q=p+t*d;\n    t1=0.5/s*(q.x+q.y/w), n=vec3(t1,t1/w,-1.);\n    t1=length(n.xy/vec2(1.,w)), t2=length(n.xy/vec2(1./w*w));\n  \tdelta=t1*(t1-1.0)/t2/length(n.xy);\n    if (abs(delta)>0.1) return false;\n    n=normalize(n);\n    return true;\n}*/\nbool trackint(vec3 p, vec3 d, out float t, out vec3 n){\n    float t1 = d.x+d.y/w, t2 = p.x+p.y/w, delta=4.0*s;\n    float a=t1*t1, b=2.*t1*t2-delta*d.z, c=t2*t2+delta*(h1-p.z);\n    delta=b*b-4.*a*c; if (delta<0.) return false;\n    a*=2.0,delta=sqrt(delta)/a; b=-b/a;\n    t1=b+delta,t2=b-delta;\n    vec3 q;\n#define Test(t0) q=p+t0*d; \\\n  a=0.5/s*(q.x+q.y/w), n=vec3(a,a/w,-1.); \\\n  b=length(q.xy/r), c=length(q.xy/(r*r)), a=b*(b-1.0)/c*length(n); \\\n  if (abs(a)<wp) t=t0;\n    t=RTMaxD;\n    if (t1>RTMinD) {Test(t1)}\n    if (t2>RTMinD&&t2<t) {Test(t2)}\n    if (t==RTMaxD) return false;\n    q=p+t*d;\n    a=0.5/s*(q.x+q.y/w), n=normalize(vec3(a,a/w,-1.));\n    return true;\n}\n\n\n// Rendering\n\n#define sunpos normalize(vec3(1.0,-1.0,0.5))\n#define fogcol vec3(1.0,0.7,0.4)\n#define skycol vec3(0.6,0.8,1.0)\n#define suncol vec3(0.9,0.8,0.5)\n#define fogD 0.008\n\nvec3 skycolor(vec3 d){\n    vec3 col;\n    float sky=(0.2-0.8)*max(d.z,0.0)+0.8;\n    col=sky*skycol;\n    float horizon=pow(1.0-d.z*d.z,100.0);\n    col=mix(col,vec3(1.0),horizon);\n    float sun=max(dot(d,sunpos),0.0);\n    col+=pow(sun,150.0)*suncol;\n    return col;\n}\nfloat fog(vec3 d){\n    if (d.z<=0.0) return 1.0;\n    return pow(1.0-d.z*d.z,200.0);\n}\n\nvec3 calcCol(vec3 p, vec3 d){\n    float a=0.0;\n    for (int i=0;i<16;i++){\n    \tfloat t=0.0, mt=MAX_D; vec3 n, mn; bool r=false;\n        if (sphint(p,d,t,n)) r=true, mn=n, mt=t; \t// vec3(135,250,206)/256.0;\n        if (trackint(p,d,t,n) && t<mt) r=true, mn=n, mt=t; \t// vec3(250,206,135)/256.0\n        if (surfint(p,d,t,n) && t<mt) mt=t, mn=normalize(n), r=true; \t// vec3(135,206,250)/256.0\n        if (r) {\n            p+=mt*d;\n            d-=2.0*dot(mn,d)*mn;\n        \ta+=mt;\n        }\n        else { // calculate sky color as final output\n            a=exp(-fogD*a);\n            vec3 sky=skycolor(d);\n            sky=mix(sky,fogcol,fog(d));\n            return mix(fogcol,sky,a);\n        }\n    }\n    return fogcol;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = cos(0.4*iTime)+2.0;\n    float r = 0.5*(cos(iTime)+1.0) + 10.0;\n    vec3 pos = 5.0*cos(0.5*iTime)*vec3(r*cos(iTime), r*sin(iTime), h);\n    vec3 dir = vec3(0.0,0.0,1.0+h1)-pos;\n\n    float rz=atan(dir.x,-dir.y), rx=atan(length(dir.xy),dir.z);\n    mat3 M=mat3(cos(rz),sin(rz),0,-sin(rz),cos(rz),0,0,0,1)*mat3(1,0,0,0,cos(rx),sin(rx),0,-sin(rx),cos(rx));\n\n    vec3 col = vec3(0.0,0.0,0.0), ecol;\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec3 d = M*vec3(0.5*iResolution.x-(fragCoord.x+float(i)/float(AA)),-0.5*iResolution.y+(fragCoord.y+float(j)/float(AA)),Unit);\n        ecol = calcCol(pos,normalize(d));\n    \tif (dot(ecol,vec3(0.3,0.59,0.11))<0.1) ecol=fogcol;\n        col+=ecol;\n    }\n\n    fragColor = vec4(col/float(AA*AA),1.0);\n}\n","name":"Image","description":"","type":"image"}]}