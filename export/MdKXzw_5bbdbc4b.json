{"ver":"0.1","info":{"id":"MdKXzw","date":"1463608819","viewed":1473,"name":"ReactionDiffusion","username":"DanielPettersso","description":"learning reaction diffusion. Try drawing on shader..\nEmbossing from https://www.shadertoy.com/view/XdlGz8\n","likes":31,"published":1,"flags":32,"usePreview":0,"tags":["feedback","reactiondiffusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct C_Sample\n{\n\tvec3 vAlbedo;\n\tvec3 vNormal;\n};\n\t\nC_Sample SampleMaterial(const in vec2 vUV, sampler2D sampler,  const in vec2 vTextureSize, const in float fNormalScale)\n{\n\tC_Sample result;\n\t\n\tvec2 vInvTextureSize = vec2(1.0) / vTextureSize;\n\t\n\tvec3 cSampleNegXNegY = clamp(texture(sampler, vUV + (vec2(-1.0, -1.0)) * vInvTextureSize.xy).ggb*2., 0., 1.);\n\tvec3 cSampleZerXNegY = clamp(texture(sampler, vUV + (vec2( 0.0, -1.0)) * vInvTextureSize.xy).ggb*2., 0., 1.);\n\tvec3 cSamplePosXNegY = clamp(texture(sampler, vUV + (vec2( 1.0, -1.0)) * vInvTextureSize.xy).ggb*2., 0., 1.);\n\t\n\tvec3 cSampleNegXZerY = clamp(texture(sampler, vUV + (vec2(-1.0, 0.0)) * vInvTextureSize.xy).ggb*2., 0., 1.);\n\tvec3 cSampleZerXZerY = clamp(texture(sampler, vUV + (vec2( 0.0, 0.0)) * vInvTextureSize.xy).ggb*2., 0., 1.);\n\tvec3 cSamplePosXZerY = clamp(texture(sampler, vUV + (vec2( 1.0, 0.0)) * vInvTextureSize.xy).ggb*2., 0., 1.);\n\t\n\tvec3 cSampleNegXPosY = clamp(texture(sampler, vUV + (vec2(-1.0,  1.0)) * vInvTextureSize.xy).ggb*2., 0., 1.);\n\tvec3 cSampleZerXPosY = clamp(texture(sampler, vUV + (vec2( 0.0,  1.0)) * vInvTextureSize.xy).ggb*2., 0., 1.);\n\tvec3 cSamplePosXPosY = clamp(texture(sampler, vUV + (vec2( 1.0,  1.0)) * vInvTextureSize.xy).ggb*2., 0., 1.);\n\n\t// convert to linear\t\n\tvec3 cLSampleNegXNegY = cSampleNegXNegY * cSampleNegXNegY;\n\tvec3 cLSampleZerXNegY = cSampleZerXNegY * cSampleZerXNegY;\n\tvec3 cLSamplePosXNegY = cSamplePosXNegY * cSamplePosXNegY;\n\n\tvec3 cLSampleNegXZerY = cSampleNegXZerY * cSampleNegXZerY;\n\tvec3 cLSampleZerXZerY = cSampleZerXZerY * cSampleZerXZerY;\n\tvec3 cLSamplePosXZerY = cSamplePosXZerY * cSamplePosXZerY;\n\n\tvec3 cLSampleNegXPosY = cSampleNegXPosY * cSampleNegXPosY;\n\tvec3 cLSampleZerXPosY = cSampleZerXPosY * cSampleZerXPosY;\n\tvec3 cLSamplePosXPosY = cSamplePosXPosY * cSamplePosXPosY;\n\n\tresult.vAlbedo = cLSampleNegXNegY;\t\n\t\n\tvec3 vScale = vec3(0.3333);\n\t\n    float fSampleNegXNegY = dot(cLSampleNegXNegY, vScale);\n    float fSampleZerXNegY = dot(cLSampleZerXNegY, vScale);\n    float fSamplePosXNegY = dot(cLSamplePosXNegY, vScale);\n\n    float fSampleNegXZerY = dot(cLSampleNegXZerY, vScale);\n    float fSampleZerXZerY = dot(cLSampleZerXZerY, vScale);\n    float fSamplePosXZerY = dot(cLSamplePosXZerY, vScale);\n\n    float fSampleNegXPosY = dot(cLSampleNegXPosY, vScale);\n    float fSampleZerXPosY = dot(cLSampleZerXPosY, vScale);\n    float fSamplePosXPosY = dot(cLSamplePosXPosY, vScale);\n\t\n\t\n\t// Sobel operator - http://en.wikipedia.org/wiki/Sobel_operator\n\t\n\tvec2 vEdge;\n\tvEdge.x = (fSampleNegXNegY - fSamplePosXNegY) * 0.25 \n\t\t\t+ (fSampleNegXZerY - fSamplePosXZerY) * 0.5\n\t\t\t+ (fSampleNegXPosY - fSamplePosXPosY) * 0.25;\n\n\tvEdge.y = (fSampleNegXNegY - fSampleNegXPosY) * 0.25 \n\t\t\t+ (fSampleZerXNegY - fSampleZerXPosY) * 0.5\n\t\t\t+ (fSamplePosXNegY - fSamplePosXPosY) * 0.25;\n\n\tresult.vNormal = normalize(vec3(vEdge * fNormalScale, 1.0));\t\n\t\n\treturn result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n\t\n\tC_Sample materialSample;\n\t\t\n\tfloat fNormalScale = 10.0;\n\tmaterialSample = SampleMaterial( vUV, iChannel0, iChannelResolution[0].xy, fNormalScale );\n\t\n\tfloat fLightHeight = 0.5;\n\tfloat fViewHeight = 2.0;\n\t\n\tvec3 vSurfacePos = vec3(vUV, 0.0);\n\t\n\tvec3 vViewPos = vec3(0.5, 0.5, fViewHeight);\n\t\t\t\n\tvec3 vLightPos = vec3( vec2(sin(iTime*.5),cos(iTime*.5)) * 0.25 + 0.5 , fLightHeight);\n\t\t\n\tvec3 vDirToView = normalize( vViewPos - vSurfacePos );\n\tvec3 vDirToLight = normalize( vLightPos - vSurfacePos );\n\t\t\n\tfloat fNDotL = clamp( dot(materialSample.vNormal, vDirToLight), 0.0, 1.0);\n\tfloat fDiffuse = fNDotL;\n\t\n\tvec3 vHalf = normalize( vDirToView + vDirToLight );\n\tfloat fNDotH = clamp( dot(materialSample.vNormal, vHalf), 0.0, 1.0);\n\tfloat fSpec = pow(fNDotH, 10.0) * fNDotL * 0.5;\n\t\n\tvec3 vResult = materialSample.vAlbedo * fDiffuse + fSpec;\n\t\n\tvResult = sqrt(vResult);\n\t\n\tfragColor = vec4(vResult,1.0);\n}\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 vv(vec2 uv, vec2 duv, vec2 texel) { \n    return texture(iChannel0, uv + (duv * texel)).xy; \n}\n\nvec2 laplacian(vec2 ab, vec2 uv, vec2 texel) {\n    return \n        ab * -1. +\n        vv(uv, vec2(0., -1.), texel) * .2 +\n        vv(uv, vec2(0., 1.), texel) * .2 +\n        vv(uv, vec2(1., 0.), texel) * .2 +\n        vv(uv, vec2(-1., 0.), texel) * .2 +\n        vv(uv, vec2(-1., -1.), texel) * .05 +\n        vv(uv, vec2(-1., 1.), texel) * .05 +\n        vv(uv, vec2(1., -1.), texel) * .05 +\n        vv(uv, vec2(1., 1.), texel) * .05;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    vec4 m = iMouse / iResolution.xyxy;\n    \n    vec2 c = vec2(.5+cos(iTime)*0.4,.5+sin(iTime)*0.3);\n    float lc = length(uv-c);\n    \n    if (lc < 0.1-iTime*0.02) {\n         fragColor = vec4(0., 1., 0., .01);\n        return;\n    }\n    \n    float f = .028+(uv.y+c.y)*.001;\n    float k = .055+(uv.x+c.x)*.001;\n    \n    float ml = length(m.xy-uv);\n    if (m.z > 0. && ml < .1) {\n        f *= (1.1-ml);\n        k *= (.9+ml);\n    } \n    if (lc < .05) {\n        f *= 1.5-lc*10.;\n        k *= .5+lc*10.;\n    }\n    \n    vec2 ab = vv(uv, vec2(0., 0.), texel);\n    vec2 lp = laplacian(ab, uv, texel);\n    float a = ab.x;\n    float b = ab.y;\n    float la = lp.x;\n    float lb = lp.y;\n    float dx = mod((uv.x+uv.y)*.2, .8);\n    float da = .4+dx;\n    float db = .2+dx*.5;\n\n\n    float na = a + (da * la - a*b*b + f*(1.-a));\n    float nb = b + (db * lb + a*b*b - (k+f)*b);\n\n    fragColor = vec4(na, nb, 0., .01);\n    \n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec2 vv(vec2 uv, vec2 duv, vec2 texel) { \n    return texture(iChannel0, uv + (duv * texel)).xy; \n}\n\nvec2 laplacian(vec2 ab, vec2 uv, vec2 texel) {\n    return \n        ab * -1. +\n        vv(uv, vec2(0., -1.), texel) * .2 +\n        vv(uv, vec2(0., 1.), texel) * .2 +\n        vv(uv, vec2(1., 0.), texel) * .2 +\n        vv(uv, vec2(-1., 0.), texel) * .2 +\n        vv(uv, vec2(-1., -1.), texel) * .05 +\n        vv(uv, vec2(-1., 1.), texel) * .05 +\n        vv(uv, vec2(1., -1.), texel) * .05 +\n        vv(uv, vec2(1., 1.), texel) * .05;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    vec4 m = iMouse / iResolution.xyxy;\n    \n    vec2 c = vec2(.5+cos(iTime*.9)*0.2,.5+sin(iTime*.7)*0.25);\n    float lc = length(uv-c);\n    \n\tfloat f = .028+(uv.y+c.y)*.001;\n    float k = .055+(uv.x+c.x)*.001;\n    \n    float ml = length(m.xy-uv);\n    if (m.z > 0. && ml < .1) {\n        f *= (1.1-ml);\n        k *= (.9+ml);\n    } \n    if (lc < .05) {\n        f *= 1.5-lc*10.;\n        k *= .5+lc*10.;\n    }\n    \n    vec2 ab = vv(uv, vec2(0., 0.), texel);\n    vec2 lp = laplacian(ab, uv, texel);\n    float a = ab.x;\n    float b = ab.y;\n    float la = lp.x;\n    float lb = lp.y;\n    float dx = mod((uv.x+uv.y)*.2, .8);\n    float da = .4+dx;\n    float db = .2+dx*.5;\n\n\n    float na = a + (da * la - a*b*b + f*(1.-a));\n    float nb = b + (db * lb + a*b*b - (k+f)*b);\n\n    fragColor = vec4(na, nb, 0., .01);\n    \n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec2 vv(vec2 uv, vec2 duv, vec2 texel) { \n    return texture(iChannel0, uv + (duv * texel)).xy; \n}\n\nvec2 laplacian(vec2 ab, vec2 uv, vec2 texel) {\n    return \n        ab * -1. +\n        vv(uv, vec2(0., -1.), texel) * .2 +\n        vv(uv, vec2(0., 1.), texel) * .2 +\n        vv(uv, vec2(1., 0.), texel) * .2 +\n        vv(uv, vec2(-1., 0.), texel) * .2 +\n        vv(uv, vec2(-1., -1.), texel) * .05 +\n        vv(uv, vec2(-1., 1.), texel) * .05 +\n        vv(uv, vec2(1., -1.), texel) * .05 +\n        vv(uv, vec2(1., 1.), texel) * .05;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    vec4 m = iMouse / iResolution.xyxy;\n    \n    vec2 c = vec2(.5+cos(iTime*.5)*0.35,.5+sin(iTime*.7)*0.28);\n    float lc = length(uv-c);\n    \n\tfloat f = .028+(uv.y+c.y)*.001;\n    float k = .055+(uv.x+c.x)*.001;\n   \t \n   \tfloat ml = length(m.xy-uv);\n    if (m.z > 0. && ml < .1) {\n        f *= (1.1-ml);\n        k *= (.9+ml);\n    } \n    if (lc < .05) {\n        f *= 1.5-lc*10.;\n        k *= .5+lc*10.;\n    }\n    \n    vec2 ab = vv(uv, vec2(0., 0.), texel);\n    vec2 lp = laplacian(ab, uv, texel);\n    float a = ab.x;\n    float b = ab.y;\n    float la = lp.x;\n    float lb = lp.y;\n    float dx = mod((uv.x+uv.y)*.2, .8);\n    float da = .4+dx;\n    float db = .2+dx*.5;\n\n\n    float na = a + (da * la - a*b*b + f*(1.-a));\n    float nb = b + (db * lb + a*b*b - (k+f)*b);\n\n    fragColor = vec4(na, nb, 0., .01);\n\n    \n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"vec2 vv(vec2 uv, vec2 duv, vec2 texel) { \n    return texture(iChannel0, uv + (duv * texel)).xy; \n}\n\nvec2 laplacian(vec2 ab, vec2 uv, vec2 texel) {\n    return \n        ab * -1. +\n        vv(uv, vec2(0., -1.), texel) * .2 +\n        vv(uv, vec2(0., 1.), texel) * .2 +\n        vv(uv, vec2(1., 0.), texel) * .2 +\n        vv(uv, vec2(-1., 0.), texel) * .2 +\n        vv(uv, vec2(-1., -1.), texel) * .05 +\n        vv(uv, vec2(-1., 1.), texel) * .05 +\n        vv(uv, vec2(1., -1.), texel) * .05 +\n        vv(uv, vec2(1., 1.), texel) * .05;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 texel = 1. / iResolution.xy;\n    vec4 m = iMouse / iResolution.xyxy;\n    \n    vec2 c = vec2(.5+cos(iTime*.9)*0.3,.5+sin(iTime*1.2)*0.2);\n    float lc = length(uv-c);\n    \n\tfloat f = .028+(uv.y+c.y)*.001;\n    float k = .055+(uv.x+c.x)*.001;\n    \n    float ml = length(m.xy-uv);\n    if (m.z > 0. && ml < .1) {\n        f *= (1.1-ml);\n        k *= (.9+ml);\n    } \n    if (lc < .05) {\n        f *= 1.5-lc*10.;\n        k *= .5+lc*10.;\n    }\n    \n    vec2 ab = vv(uv, vec2(0., 0.), texel);\n    vec2 lp = laplacian(ab, uv, texel);\n    float a = ab.x;\n    float b = ab.y;\n    float la = lp.x;\n    float lb = lp.y;\n    float dx = mod((uv.x+uv.y)*.2, .8);\n    float da = .4+dx;\n    float db = .2+dx*.5;\n\n\n    float na = a + (da * la - a*b*b + f*(1.-a));\n    float nb = b + (db * lb + a*b*b - (k+f)*b);\n\n    fragColor = vec4(na, nb, 0., .01);\n\n}\n","name":"Buffer D","description":"","type":"buffer"}]}