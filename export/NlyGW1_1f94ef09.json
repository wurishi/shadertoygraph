{"ver":"0.1","info":{"id":"NlyGW1","date":"1637646866","viewed":102,"name":"3D cos(x) cos(y) cos(z)","username":"LuncyTB","description":"Raymarching a volume.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"stGGWR","parentname":"Golden COW"},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n/*\n * Copyright (c) 2021 LuncyTB. All rights reserved.\n */\n\n\n#define MAX_DIS 100.0\n#define MAX_STEP 328\n#define MIN_DIS 0.01\n\n// #define ROUGH_SUF\n\nvec3 sun = normalize(vec3(-3., -8., 4.));\nvec3 sunCol = vec3(1., .97, .92) * 1.2;\n\nstruct mater\n{\n    vec3 col;\n    float smoth;\n    float metlc; // Not supported\n    vec3 emiss; // Not supported\n};\n\nstruct idf\n{\n    float f;\n    int id;\n};\n\nfloat sdSphere2(in vec3 pos, float r)\n{\n    float a1 = length(pos) - r;\n    float a2 = length(pos + vec3(0.5, 0.2, 1.) * r) - 0.5 * r;\n    return max(a1, a1 - a2);\n}\n\nfloat sdSphere1(in vec3 pos, float r)\n{\n    return max(length(pos) - r, length(pos + vec3(0.5, 0.2, 1.) * r) - 0.5 * r);\n}\n\nfloat sdSphere(in vec3 pos, float r)\n{\n    return length(pos) - r;\n}\n\nfloat sdDnut(in vec3 pos, float r, float r2)\n{\n    return length(vec2(length(pos.xy) - r, pos.z)) - r2;\n}\n\nfloat sdDnut2(in vec3 pos, float r, float r2)\n{\n    return length(vec2(length(pos.xy) - r, pos.z)) + min(abs(pow(pos.y + 1., 2.0)), 1.1) * r2 - r2;\n}\n\nfloat sdClind(in vec3 pos, float r, float h)\n{\n    float l = length(pos.xz);\n    float t = abs(pos.y);\n    if (t < h)\n    {\n        if (l > r)\n        {\n            return l - r;\n        }\n        else\n        {\n            return max(l - r, t - h);\n        }\n    }\n    else\n    {\n        if (l > r)\n        {\n            return length(vec2(l - r, t - h));\n        }\n        else\n        {\n            return t - h;\n        }\n    }\n}\n\nfloat sdNoise(vec3 pos, float r)\n{\n    float scale = 0.32;\n    float f = cos(pos.x * scale) + cos(pos.y * scale + 0.3) + cos(pos.z * scale - 0.12) + 3.0;\n    f /= 2.;\n    \n    f = f * acos(-1.) / scale;\n    \n    f = f - 12.94;\n    \n    return f;\n}\n\nfloat mmin(float a, float b, float soft)\n{\n    float diff = (b - a) * soft;\n    float lerp = a > b ? pow(2.0, diff) / 2. : 1. - pow(2.0, -diff) / 2.;\n    return mix(b, a, lerp);\n}\n\nfloat mmax(float a, float b, float soft)\n{\n    float diff = (b - a) * soft;\n    float lerp = a > b ? pow(2.0, diff) / 2. : 1. - pow(2.0, -diff) / 2.;\n    return mix(a, b, lerp);\n}\n\nfloat uand(float a, float b, float s)\n{\n    return mmax(a, b, s);\n}\n\nfloat uor(float a, float b, float s)\n{\n    return mmin(a, b, s);\n}\n\nfloat uminus(float a, float b, float s)\n{\n    return mmax(a, a - b, s);\n}\n\nidf idmin(in idf a, in idf b)\n{\n    idf c;\n    if (a.f < b.f) c = a;\n    else c = b;\n    return c;\n}\n\nfloat scene(in vec3 pos)\n{\n    float d = MAX_DIS;\n    \n    d = mmin(sdSphere(pos - vec3(0.4, 0.4, 2.), 0.3), d, 1e3);\n    d = mmin(sdClind(pos - vec3(1.5, -0.2, 2.4), 0.4, 0.6), d, 1e3);\n    d = mmin(sdClind(pos - vec3(0.4, 0.05, 2.), 0.1, 0.6), d, 1e3);\n    d = mmin(sdSphere(pos - vec3(-0.4, 0.1, 2.), 0.3), d, 1e3);\n    \n    d = mmin(sdNoise(pos - vec3(-1.0, -0.3, 4.2), 0.9), d, 1e3);\n    \n    return d;\n}\n\nidf getId(in vec3 pos)\n{\n    idf d = idf(MAX_DIS, 0);\n    \n    d = idmin(idf(sdSphere(pos - vec3(0.4, 0.4, 2.), 0.3), 1), d);\n    d = idmin(idf(sdClind(pos - vec3(1.5, -0.2, 2.4), 0.4, 0.6), 2), d);\n    d = idmin(idf(sdClind(pos - vec3(0.4, 0.05, 2.), 0.1, 0.6), 3), d);\n    d = idmin(idf(sdSphere(pos - vec3(-0.4, 0.1, 2.), 0.3), 4), d);\n    \n    d = idmin(idf(sdNoise(pos - vec3(-1.0, -0.3, 4.2), 0.9), 5), d);\n    \n\n    return d;\n}\n\nfloat rayMarch(in vec3 org, in vec3 dir, in float min_dis, in int steps)\n{\n    float d = min_dis * 3.;\n    for (int i = 0; i < 114; i++)\n    {\n        float space = scene(org + dir * d);\n        d += space / 3.;\n        if (space < min_dis) break;\n    }\n    return d;\n}\n\nvec3 calNormal(in vec3 pos)\n{\n    vec2 e = vec2(MIN_DIS, 0.);\n    return normalize(\n        scene(pos) - vec3(scene(pos - e.xyy), scene(pos - e.yxy), scene(pos - e.yyx))\n        );\n}\n\nfloat random(float n) {\n    return fract(iTime * 0.23781 + sin(n) * 1000000.);\n}\n\nvec3 rand3(vec3 pos)\n{\n#ifndef ROUGH_SUF\n    return vec3(0.);\n#endif\n    return normalize(vec3(random(pos.x + cos(pos.z) + sin(pos.y)) - 0.5, \n        random(pos.y + cos(pos.x) + sin(pos.z)) - 0.5, \n        random(pos.z + cos(pos.y) + sin(pos.x)) - 0.5));\n}\n\nfloat calSun(in vec3 pos)\n{\n    float z = rayMarch(pos, -sun + rand3(pos) * 0.1, MIN_DIS * 4., MAX_STEP / 4);\n    if (z < MAX_DIS)\n        return z / MAX_DIS;\n    else return 1.0;\n}\n\nmater getMater(in int id)\n{\n    if (id == 0) return mater(vec3(1., 0.6, 0.4), 0.19, 0.1, vec3(0.));\n    if (id == 1) return mater(vec3(1., 0.6, 0.4), 0.19, 0.1, vec3(0.));\n    if (id == 2) return mater(vec3(0.4, 0.6, 0.97), 0.968, 0.1, vec3(0.));\n    if (id == 3) return mater(vec3(0.98, 0.87, 0.71), 0.07, 0.1, vec3(0.));\n    if (id == 4) return mater(vec3(0.98, 0.07, 0.71), 0.967, 0.1, vec3(1.0, 1.0, 1.0) * 0.1);\n    if (id == 5) return mater(vec3(0.98, 0.97, 0.91), 0.87, 0.1, vec3(1.0, 1.0, 1.0) * 0.1);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.) / min(iResolution.x, iResolution.y);\n    vec3 ray = normalize(vec3(uv, 0.7));\n    vec3 eye = vec3(0.0, cos(iTime), 0.0);\n    \n    \n    float z = rayMarch(eye, ray, MIN_DIS, MAX_STEP);\n    vec3 col;\n    if (z >= MAX_DIS) col = texture(iChannel0, ray).xyz;\n    else\n    {\n        \n        vec3 normal = calNormal(eye + ray * z);\n        mater mid = getMater(getId(eye + ray * z).id);\n        vec3 pos = eye + ray * z;\n        vec3 ref = reflect(ray, normal + (1. - mid.smoth) * rand3(pos));\n        \n        float z2 = rayMarch(pos, ref, MIN_DIS * 2., MAX_STEP / 2);\n        col = 0.8 * max(0., dot(sun, -normal)) * sunCol * mid.col * calSun(eye + ray * z);\n        if (z2 >= MAX_DIS / 2.) col += texture(iChannel0, ref).xyz * mid.col;\n        else\n        {\n            vec3 normal2 = calNormal(pos + ref * z2);\n            mater mid2 = getMater(getId(pos + ref * z2).id);\n            vec3 ref2 = reflect(ref, normal2 + (1. - mid2.smoth) * rand3(pos + ref * z2));\n            col += max(0., dot(sun, -normal2)) * sunCol * mid2.col * mid.col * 0.5;\n            col += texture(iChannel0, ref2).xyz * mid2.col * mid.col * 0.5;\n            col += mid2.emiss;\n        }\n        \n        \n    }\n    \n    col.r = pow(col.r, 1.5);\n    col.g = pow(col.g, 1.3);\n    col.b = pow(col.b, 1.3);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}