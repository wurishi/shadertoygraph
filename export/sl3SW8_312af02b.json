{"ver":"0.1","info":{"id":"sl3SW8","date":"1638991550","viewed":185,"name":"That Time It Snowed Gunpowder","username":"Quinchilion","description":"\"Snow\" particles that can catch fire and burn. Air temperature simulation that can heat up the particles. Combine the two and you get one warm Christmas.\n\nClick for flame, press space to extinguish everything. Best in full-screen.","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["2d","christmas","simulation","fire","particles","snow","flames","temperature"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// By Quinchilion (Dolkar) in 2021\n// See Common tab for tweakable constants\n\n// Stars from https://www.shadertoy.com/view/ll3yDr\nfloat stars(vec2 fragCoord) {\n    float value = 0.0;\n    \n    for (int i = 0; i < 8; i++) {\n        // calculate a value to multiply UVs by to guarantee square cell shapes.\n        float screenRatio = iResolution.x/iResolution.y;\n        vec2 ratioScale = vec2(1.0 * screenRatio, 1);\n        vec2 uvScale = vec2(float(i) * 1.0 + 100.0);\n        vec2 uv = (fragCoord * ratioScale / iResolution.xy) * uvScale;\n        \n        // get random 2d cell noise\n        vec2 CellUVs = floor(uv + float(i * 1199));\n\t    vec2 hash = (hash22(CellUVs) * 2.0 - 1.0) * 2.0;\n        float hash_magnitude =(1.0-length(hash));\n    \n        // calculate uv cell grid.\n        vec2 UVgrid = fract(uv) - 0.5;\n    \n        float radius = clamp(hash_magnitude - 0.5, 0.0, 1.0);\n        float radialGradient = length(UVgrid - hash) / radius;\n        radialGradient = clamp(1.0 - radialGradient, 0.0, 1.0);\n        \n        value += pow(radialGradient, 20.0);\n    }\n    \n    return value;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos = vec2(fragCoord.x, float(textureSize(iChannel0, 0).y) - fragCoord.y);\n\n    // Draw background and stars\n    float y = fragCoord.y / iResolution.y;\n    vec3 col = mix(vec3(0.01, 0.02, 0.07), vec3(0.0), pow(y, 1.0 / 3.0) + hash12(fragCoord) / 64.0);\n    col += stars(fragCoord);\n\n    // Draw particles\n    vec4 particles = drawParticles(pos, MaxParticleSize, iChannel0);\n    col = col * (1.0 - particles.a) + particles.rgb;\n    \n    // Draw temperature as flames\n    float ambientTemp = sampleAmbientTemperature(pos, iChannel1);\n    col += colorizeTemperature(ambientTemp);\n\n    fragColor = vec4(pow(col, vec3(1.0 / 2.2)), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Each row of buffer contains a list of particles in that row of image, scaled by VerticalScaling\n// Each frame, new particles are generated in the first row and the rest of the rows are shifted by 1\n// The state of all particles also gets updated:\n// - X position based on the random horizontal movement\n// - If temperature is above a threshold, the particle has ignited, decreasing its size and further increasing temperature\n// - Simulates temperature transfer between a particle and its surrounding space\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 coord = ivec2(fragCoord);\n    float maxParticlesPerRow = iResolution.x * ParticleDensity;\n\n    if (coord.y == 0) {\n        // Generate particles\n        int partN = int(round(hash11(float(iFrame)) * maxParticlesPerRow));\n        \n        int partI = coord.x;\n        if (partI < partN) {\n            fragColor = genParticle(iFrame, partI, iResolution.x);\n        } else {\n            fragColor = vec4(0.0, 0.0, -1.0, 0.0);\n        }\n    } else {\n        // Update particles\n        vec4 particle = texelFetch(iChannel0, coord - ivec2(0, 1), 0);\n        \n        if (particle.z > 0.0) {\n            // Update particles motion\n            float mass = particle.z;\n            particle.x += sin(particle.y + float(coord.y) / 25.0) * ParticleSway / (mass + 0.25);\n            vec2 pos = getParticlePos(particle, coord.y - 1);\n            vec2 size = sqrt(mass) * MaxParticleSize;\n            \n            // Sample air and update temperature. Particles never cool down and can only heat up.\n            float airTemp = 0.0;\n            for (int i = 0; i < 8; i++) {\n                vec2 rand = hash23(vec3(particle.x, iFrame, i));\n                vec2 disc = sampleDisc(rand) * size;\n                airTemp += sampleAmbientTemperature(pos + disc, iChannel1) / 8.0;\n            }\n            float tempDiff = max(airTemp - particle.w, 0.0);\n            // Make smaller particles heat up faster\n            particle.w = particle.w + tempDiff * (1.0 - mass * 0.9) * AirToParticleTempRate;\n            \n            // Decrease mass and increase temperature if burning\n            if (particle.w > IgnitionTemperature) {\n                float massDiff = min(BurningRate, mass);\n                particle.z -= massDiff;\n                \n                if (particle.z > 0.0) {\n                    // Distribute energy between the remaining mass\n                    float energyGain = massDiff * BurningEnergy;\n                    particle.w += energyGain / mass;\n                }\n            }\n            \n            if (isPressed(KeySpace, iChannel2))\n                particle.w = 0.0;\n        }\n        \n        fragColor = particle;\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float Pi = 3.1415927;\nconst int KeySpace = 32;\n\n// If true, the simulation will be seeded with a flame at the start, otherwise only mouse input starts a fire\nconst bool StartWithFlame = true;\n// Controls the vertical speed of particles as well as vertical density\nconst float VerticalScaling = 5.0;\n// Particle density multiplier\nconst float ParticleDensity = 1.0 / 150.0;\n// Maximum size of particles\nconst vec2 MaxParticleSize = vec2(10.0, 10.0);\n// Amount of horizontal sway of particles\nconst float ParticleSway = 2.0;\n// The temperature at which particles ignite\nconst float IgnitionTemperature = 400.0;\n// The multiplier of temperature decay of flames\nconst float TemperatureDecay = 0.985;\n// The rate at which particles heat up or cool down air\nconst float ParticleToAirTempRate = 0.3;\n// The rate at which air heats up particles\nconst float AirToParticleTempRate = 0.12;\n// The rate at which particles burn, decreasing their size\nconst float BurningRate = 0.006;\n// The amount of energy given off by burning particles\nconst float BurningEnergy = 6000.0;\n\n// Hash without sine from https://www.shadertoy.com/view/4djSRW\n// Copyright (c)2014 David Hoskins. MIT License\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash23(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n// Gaussian random distribution\nfloat gaussy(float p) {\n    const int N = 4;\n\tfloat v = 0.0;\n    for (int i = 0; i < N; i++) {\n        v += hash11(p + float(i) * 1.234567);\n    }\n    return v / float(N);\n}\n\nvec2 sampleDisc(vec2 rand) {\n    float r = sqrt(rand.x);\n    float t = rand.y * 2.0 * Pi;\n    return vec2(r * cos(t), r * sin(t));\n}\n\nbool isPressed(int keyCode, sampler2D keyboardSampler) {\n    float x = (float(keyCode) + 0.5) / 256.0;\n    return texture(keyboardSampler, vec2(x, 0.25)).r > 0.0;\n}\n\nvec3 blackBody(float t) {\n    float h = 6.6e-34; // Planck constant\n    float k = 1.4e-23; // Boltzmann constant\n    float c = 3e8;     // Speed of light\n\n    vec3 w = vec3( 610.0, 549.0, 468.0 ) / 1e9; // sRGB approximate wavelength of primaries\n    vec3 w5 = w*w*w*w*w;\n    return 2.0*h*(c*c) / (pow(w, vec3(5.0)) * (exp(h*c/(w*k*t)) - 1.0)); // Planck's law https://en.wikipedia.org/wiki/Planck%27s_law\n}\n\nfloat tonemapping(float y) {\n    return log(y + 1.0);\n}\n\nvec3 colorizeTemperature(float t) {\n    if (t < 500.0) return vec3(0.0,0.0,0.0);\n    \n    vec3 bb = blackBody(t);\n    float intensity = length(bb);\n    float whitePoint = length(blackBody(5000.0));\n    \n    float brightness = max(tonemapping(intensity) / tonemapping(whitePoint), 0.0);\n    \n    return (bb / intensity) * brightness * length(vec3(1.0));\n}\n\n// Generates a random particle:\n// - X: x position\n// - Y: random movement phase\n// - Z: mass\n// - W: temperature\nvec4 genParticle(int iFrame, int particleIndex, float xResolution) {\n    vec3 hash = hash32(vec2(iFrame, particleIndex));\n    \n    // To give a smoothly changing nonuniform distribution, choose between three moving gaussians and one uniform\n    float xPos;\n    int gaussIndex = int(hash.x * 4.0);\n    if (gaussIndex > 0) {\n        float t = float(iFrame) / 100.0;\n        float v1 = hash12(vec2(gaussIndex, floor(t)));\n        float v2 = hash12(vec2(gaussIndex, floor(t) + 1.0));\n        float gaussOffset = mix(v1, v2, smoothstep(0.0, 1.0, fract(t)));;\n        xPos = (gaussOffset + (gaussy(hash.x * 123.4) - 0.5) * 0.75) * xResolution;\n    } else {\n        xPos = hash11(hash.x * 123.4) * xResolution;\n    }\n    \n    float phase = hash.y * (2.0 * Pi);\n    float mass = hash.z * hash.z * 0.8 + 0.2;\n    float startTemperature = 0.0;\n    \n    return vec4(xPos, phase, mass, startTemperature);\n}\n\nvec2 getParticlePos(vec4 particle, int row) {\n    return vec2(particle.x, float(row) * VerticalScaling);\n}\n\n// Iterates over all particles and returns (weight, avg temperature)\nvec2 accumParticles(vec2 position, vec2 sampleSize, sampler2D particleBuf) {\n    int maxParticlesPerRow = int(ceil(float(textureSize(particleBuf, 0).x) * ParticleDensity));\n    \n    float rowY = position.y / VerticalScaling;\n    float rowSampleSize = sampleSize.y / VerticalScaling;\n    int firstRow = int(floor(rowY - rowSampleSize));\n    int lastRow = int(ceil(rowY + rowSampleSize));\n    if (firstRow < 0) firstRow = 0;\n    \n    vec2 accum = vec2(0.0);\n    for (int row = firstRow; row <= lastRow; row++) {\n        for (int i = 0; i < maxParticlesPerRow; i++) {\n            vec4 particle = texelFetch(particleBuf, ivec2(i, row), 0);\n            if (particle.z <= -1.0)\n                break;\n                \n            vec2 particlePos = getParticlePos(particle, row);\n            vec2 sampleVec = (position - particlePos) / sampleSize;\n            float dist = length(sampleVec) / sqrt(particle.z);\n            float weight = sqrt(max(1.0 - dist, 0.0));\n            accum += vec2(1.0, particle.w) * weight;\n        }\n    }\n    \n    // Calculate average temperature\n    if (accum.x > 0.0001)\n        accum.y /= accum.x;\n    return accum;\n}\n\n// Iterates over all particles and draws them, returning premultiplied RGBA\nvec4 drawParticles(vec2 position, vec2 sampleSize, sampler2D particleBuf) {\n    int maxParticlesPerRow = int(ceil(float(textureSize(particleBuf, 0).x) * ParticleDensity));\n    \n    float rowY = position.y / VerticalScaling;\n    float rowSampleSize = sampleSize.y / VerticalScaling;\n    int firstRow = int(floor(rowY - rowSampleSize));\n    int lastRow = int(ceil(rowY + rowSampleSize));\n    if (firstRow < 0) firstRow = 0;\n    \n    vec4 color = vec4(0.0);\n    for (int row = firstRow; row <= lastRow; row++) {\n        for (int i = 0; i < maxParticlesPerRow; i++) {\n            vec4 particle = texelFetch(particleBuf, ivec2(i, row), 0);\n            if (particle.z <= -1.0)\n                break;\n                \n            vec2 particlePos = getParticlePos(particle, row);\n            vec2 sampleVec = (position - particlePos) / sampleSize;\n            float dist = length(sampleVec) / sqrt(particle.z);\n            float weight = sqrt(max(1.0 - dist, 0.0));\n            vec2 normal = normalize(position - particlePos);\n            \n            // Star-ish shape\n            float angle = atan(normal.y, normal.x) + particle.y;\n            float shape = sin(angle * 7.0 + position.y / 60.0) * 0.15 + 0.15;\n            float alpha = sqrt(max(weight * weight - shape, 0.0));\n            alpha = smoothstep(0.0, 1.0, alpha);\n            vec3 albedo = pow(weight, 3.0) + colorizeTemperature(particle.w);\n            \n            color = color * (1.0 - alpha) + vec4(albedo, 1.0) * alpha;\n        }\n    }\n    \n    return color;\n}\n\nfloat sampleAmbientTemperature(vec2 position, sampler2D temperatureBuf) {\n    vec2 texSize = vec2(textureSize(temperatureBuf, 0));\n    vec2 samplePos = (position + texSize * 0.5) / (2.0 * texSize);\n    return texture(temperatureBuf, samplePos).x;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Image contains 1/2 resolution ambient temperature map\n// Mouse input can increase temperature enough to ignite particles\n// Every frame:\n// - The ambient temperature is spread upwards and outwards, simulating hot gases rising\n// - Simulates temperature transfer between a particle and its surrounding space\n\n// Velocity from noise\nvec2 sampleFlowVelocity(vec2 pos) {\n    const int levels = 4;\n    const float levelScale = 1.5;\n    const float levelStrength = 1.5;\n\n    vec2 noiseTexelSize = 1.0 / vec2(textureSize(iChannel2, 0));\n    \n    vec2 timeOffset = vec2(0.0, 1.5 * float(iFrame));\n    vec2 samplePos = pos / (2.0 * pow(levelScale, float(levels)));\n    \n    vec2 velocity = vec2(0.0, -3.0);\n    float strength = 1.0;\n    for (int i = 0; i < levels; i++) {\n        vec4 noise = texture(iChannel2, (samplePos + timeOffset) * noiseTexelSize) * 2.0 - 1.0;\n        velocity += noise.xy * strength;\n        strength *= levelStrength;\n        samplePos *= levelScale;\n    }\n    \n    return velocity;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos = fragCoord * 2.0 - iResolution.xy * 0.5;\n\n    // Add mouse input and initial flame\n    float d = 1.0e8;\n    if (iMouse.z > 0.0) {\n        vec2 mousePos = vec2(iMouse.x, iResolution.y - iMouse.y);\n        d = distance(mousePos, pos);\n    } else if (iTime < 10.0 && StartWithFlame) {\n        d = distance(vec2(iResolution.x / 2.0, iResolution.y - 150.0), pos);\n    }\n    if (d < 10.0) {\n        fragColor = vec4(4000.0, 0.0, 0.0, 0.0); \n        return;\n    }\n    \n    // Backwards time step to get last frame's temperature\n    vec2 velocity = sampleFlowVelocity(pos);    \n    vec2 samplePos = pos - velocity;\n    float sampleTemp = sampleAmbientTemperature(samplePos, iChannel1);\n    \n    // Sample nearby particles and update temperature\n    vec2 particles = accumParticles(pos, MaxParticleSize, iChannel0);\n    float tempDiff = particles.y - sampleTemp;\n    float temp = sampleTemp * TemperatureDecay + tempDiff * particles.x * ParticleToAirTempRate;\n\n    if (isPressed(KeySpace, iChannel3))\n        temp = 0.0;\n    fragColor = vec4(temp, 0.0, 0.0, 0.0);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}