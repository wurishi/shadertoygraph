{"ver":"0.1","info":{"id":"Wt2fz1","date":"1599194505","viewed":60,"name":"Nested Donuts","username":"j91000","description":"raymarching render based on the articles some of the articles here: https://iquilezles.org/www/index.htm","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//THANKS IQ.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor=texture(iChannel0,fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define pi atan(1.0) * 4.0\n#define tau = atan(1.0) * 8.0\nvec2 balluv(vec3 pos){\n    pos=normalize(pos);\n    float x=pos.x;\n    float y=pos.y;\n    float z=pos.z;\n    float u=.5+atan(z,x)/8./pi;\n    float v=.5-asin(y)/pi/4.;\n    return vec2(u,v);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define K 3.\n#define MAXSTEPS 60*int(K)\n#define HITDIST 1.e-1\n#define MAXDIST 95.\n#define delta 0.01\n#define CAMDIST 50.\n#define AMBIENT 0.05\n#define ZERO min(iFrame,0)\n#define STEPSCAL 1.\n#define SHADSMOOTH 50.\n//uncomment this line to enable fakey ambient occlusion\n//#define AO 1\n#define AODIST .02\n#define AOSTEPS 6.\n#define AOPOW 60.\nvec3 ballCenter=vec3(0.,0.,0.);\nstruct CastResult\n{\n    vec3 pos;\n    vec3 norm;\n    vec3 surf;\n};\nstruct PointLight\n{\n    vec3 pos;\n    vec3 col;\n};\nstruct DirLight\n{\n  vec3 dir;\n    vec3 col;\n};\n// Polynomial smooth minimum by iq\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n  return mix(a, b, h) - k*h*(1.0-h);\n}\nfloat smax(float a,float b,float k){\n return -smin(-a,-b,k);   \n}\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{angles=angles.yxz;\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n        return rotX*rotY*rotZ;\n    }\nmat3 camRotation(vec3 dir){\n    dir=normalize(dir);\n    float xRot=atan(dir.z,dir.x)-pi/2.;\n    float yRot=atan(dir.y,length(dir.xz));\n    return Rotate(vec3(xRot,yRot,0));\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )//.x is the distance, .y is the iteration\n{p.y=p.y+length(p.yx+p.xz)*1.-1.5;\n t.x*=5.;\n t.y*=1.9;\n    vec2 iq = vec2(length(p.xz)-t.x,p.y);\n    float result=length(iq)-t.y;\n for(float i=1.;i<45.;i++){\n       t.y=t.y*.96+max(0.,i-40.)/2000.;\n  t.x=t.x*.95+.02*max(0.,i-20.)-(i-20.)*(i-((sin(iTime/2.)))*90.)/1000.;\n  p=p-vec3(0.,.35,0.);\n  p=p*Rotate(vec3(0.5,.2*sin(float(iFrame)/70.),0.));\n  \n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  result=smin(result, length(q)-t.y,.5);\n\n }\n return result;\n}\n\nfloat distToScene(vec3 pos){\n    float ball1= length(pos-ballCenter)-5.;\n    float ball2=length(pos-ballCenter-vec3(sin(4.)*4.,cos(4.)*4.,2.))-4.9;\n    float plane=pos.y+25.;\n    //return ball1*ball2/((ball1*ball1)+(ball2*ball2));//smin(ball1,ball2,.5);\n    float result= sdTorus(pos-ballCenter,vec2(2.5,.5));//,-ball2,1.);\n    result=min(result,plane);\n    return result;//min(pos.y+5.,smin(length(pos-vec3(cos(iTime)-3.,-.2,2.))-2.,smax(ball2,ball1,.5),.2));//min(max(ball1,ball2),pos.y+5.);\n}\nvec3 calcNorm(vec3 pos){\n    //estimate normal by finding the gradient of the distance field\n    /*\n    vec3 dx=vec3(delta,0.,0.);\n    vec3 dy=vec3(0.,delta,0.);\n    vec3 dz=vec3(0.,0.,delta);\n    float gradx=(distToScene(pos+dx)-distToScene(pos-dx));\n    float grady=(distToScene(pos+dy)-distToScene(pos-dy));\n    float gradz=(distToScene(pos+dz)-distToScene(pos-dz));\n    return normalize(vec3(gradx,grady,gradz));\n*/\n        vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 1.*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*distToScene(pos+0.00005*e);\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n}\nCastResult castRay(vec3 rayOri,vec3 rayVec){\n    \n    bool hit=false;\n    vec3 rayPos=rayOri;\n    for(int steps=0;steps<MAXSTEPS&&hit==false&&length(rayPos-rayOri)<MAXDIST;steps++){\n        float dts=distToScene(rayPos);//calc dist to scene.\n        if(dts<HITDIST){//if it's less than HITDIST \n        hit=true;//break out\n        //get some properties about the collision?\n        }\n        else{ //otherwise, step the ray forward by distToScene\n        rayPos+=rayVec*dts/K;\n        }\n    }\n    vec3 norm=calcNorm(rayPos);\n    vec3 hitSurf=texture(iChannel0,balluv(norm)).xyz;\n    if(length(rayPos-rayOri)>=MAXDIST){rayPos=normalize(rayPos-rayOri)*MAXDIST+rayOri;hitSurf=vec3(0.);}\n    return CastResult(rayPos,norm,hitSurf);\n}\nfloat ambientOcclusion(vec3 pos,vec3 normal){\n    float occlusion=0.;\n    for(float i=1.;i<AOSTEPS;i++){\n     float term=i*AODIST-distToScene(pos+normal*AODIST*i);\n        occlusion+=1./pow(2.,i)*term;\n    }\n    return 1.-AOPOW*occlusion;\n}\nfloat occlusion(CastResult surface,vec3 lightDir){\n    lightDir=normalize(lightDir);\n    vec3 rayOri=surface.pos+surface.norm*HITDIST*2.;//the ray starts from just above the surface of the hit.\n    vec3 rayPos=rayOri;\n    bool hit=false;\n    float result=1.;\n        for(int steps=0;steps<MAXSTEPS&&hit==false&&length(rayPos-rayOri)<MAXDIST;steps++){\n            float dts=distToScene(rayPos);\n            if(dts<HITDIST){\n                hit=true;\n            }\n            else{\n                result=min(result,SHADSMOOTH*dts/length(rayPos-rayOri));\n                rayPos-=lightDir*dts*STEPSCAL;\n                \n            }\n        }\n    if(hit){return 0.;}\n    #ifdef AO\n    return min(result,ambientOcclusion(surface.pos,surface.norm));\n    #else\n    return result;\n    #endif\n}\n\n////////LIGHTS \n//  the sum of all the lightOn(LIGHT)s for a given castresult being \n//  illuminated by LIGHTS is the total quantity of light that:\n//    a.    hits the surface\n//and b.    reflects to the camera\nvec3 lightOn(CastResult hit,PointLight sun){//point light.    LINKED TO vvvvvvv\n    float dist=.0000001+length(hit.pos-sun.pos);\n    return max(0.,(-dot(hit.norm,hit.pos-sun.pos)))*hit.surf*sun.col/(dist*dist)*occlusion(hit,hit.pos-sun.pos);\n}\nvec3 lightOn(CastResult hit,DirLight sun){//directional light. LINKED TO ^^^^^^\n    #ifdef AO\n    return max(0.,(-dot(hit.norm,sun.dir)))*hit.surf*sun.col*occlusion(hit,sun.dir)+AMBIENT*hit.surf*ambientOcclusion(hit.pos,hit.norm);\n    #else\n    return max(0.,(-dot(hit.norm,sun.dir)))*hit.surf*sun.col*occlusion(hit,sun.dir)+AMBIENT*hit.surf;\n    #endif\n}\nvec3 lightOn(CastResult hit,vec3 lightDir,vec3 lightCol){\n    return max(0.,(-dot(hit.norm,lightDir)))*hit.surf*lightCol*occlusion(hit,lightDir);\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mou=iMouse.xy/iResolution.xy-.5;\n    mou*=vec2(2.*pi,30.);\n    vec3 camPos=vec3(cos(mou.x)*CAMDIST,mou.y+17.,CAMDIST*sin(mou.x));\n    vec3 camTarget=vec3(0.,5.,0.);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tPointLight spot;\n    DirLight sun;\n    sun.dir=vec3(1.,-1.,0.)*Rotate(vec3(10./5.,0.,0.));\n    spot.pos=vec3(6.,6.,40.);\n    sun.col=vec3(2.)*vec3(1.,.7,.1);\n    spot.col=vec3(40.);\n    vec3 finalC=vec3(0);\n    \n    vec3 rayOri=camPos;\n    vec3 rayVec=normalize(vec3(uv.x,uv.y,1.)*camRotation(camTarget-camPos));//*Rotate(vec3(3.1415926,0.,0.));\n    CastResult cRay=castRay(rayOri,rayVec);\n    if(length(cRay.pos-rayOri)<MAXDIST*.999){\n    finalC=lightOn(cRay,sun);//+lightOn(cRay,spot);//vec3(length(cRay.pos-rayOri)/100.);\n    //finalC.xyz+=cRay.norm;\n    // Output to screen\n    //finalC.xyz+=calcNorm(cRay.pos);\n    //finalC.xyz*=\n    }\n    fragColor = vec4(finalC,1.0);\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}