{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec3 skyColor = vec3(0.65, 0.28, 0.1);\nvec3 sunColor = vec3(1.8, 1.0, 0.6);\nvec3 sunLightColor = vec3(1.7, 1.25, 0.9);\nvec3 skyLightColor = vec3(0.8, 0.35, 0.15);\nvec3 indLightColor = vec3(0.4, 0.3, 0.2);\nvec3 horizonColor = vec3(0.85, 0.35, 0.15);\nvec3 sunDirection = normalize(vec3(0.6, 0.4, 0.9));\n\nfloat noise(in vec2 p) {\n    p += vec2(16.6, 17.0);\n    return texture(iChannel0, p / 256.0, -100.0).x;\n}\n\nfloat noise3d(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+.5)/256., 0.).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\nfloat fBm(in vec2 p) {\n    float sum = 0.0;\n    float amp = 1.0;\n    for(int i = 0; i < 4; i++) {\n        sum += amp * noise(p);\n        amp *= 0.5;\n        p *= 2.5;\n    }\n    return sum * 0.5 + 0.15;\n}\n\nfloat fBm3d(in vec3 p) {\n    float sum = 0.0;\n    float amp = 1.0;\n    for(int i = 0; i < 4; i++) {\n        sum += amp * noise3d(p);\n        amp *= 0.5;\n        p *= 2.0;\n    }\n    return sum;\n}\n\nfloat warp(in vec3 p) {\n    vec3 q, r;\n    q.x = fBm3d(p);\n    q.y = fBm3d(p + vec3(5.2,1.3,8.4));\n    q.z = fBm3d(p + vec3(2.2,5.4,7.9));\n    r.x = fBm3d(p + 2.0 * q + vec3(1.7,9.2,5.2));\n    r.y = fBm3d(p + 2.0 * q + vec3(8.3,2.8,4.8));\n    r.z = fBm3d(p + 2.0 * q + vec3(5.7,4.3,2.4));\n    return fBm3d(p + 4.0 * r);\n}\n\nfloat length2(in vec2 p) {\n    return sqrt(p.x*p.x + p.y*p.y);\n}\n\nfloat length8(in vec2 p) {\n    p = p*p; p = p*p; p = p*p;\n    return pow(p.x + p.y, 1.0 / 8.0);\n}\n\nfloat sdTorus82(in vec3 p, in vec2 t) {\n    vec2 q = vec2(length2(p.xz) - t.x, p.y);\n    return length8(q) - t.y;\n}\n\nfloat sdBox(in vec3 p, in vec3 box) {\n    vec3 d = abs(p) - box;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdTriPrism(in vec3 p, vec2 h) {\n    vec3 q = abs(p);\n    return max(q.z - h.y, max(q.x * 0.866025 + p.y * 0.5, -p.y) - h.x * 0.5);\n}\n\nfloat smin(float a, float b, float k) {\n    float res = exp(-k * a) + exp(-k * b);\n    return -log(res) / k;\n}\n\nvec3 rotateX(in vec3 p, float an) {\n    float c = cos(an);\n    float s = sin(an);\n    return vec3(p.x, c * p.y - s * p.z, s * p.y + c * p.z);\n}\n\nvec3 rotateY(in vec3 p, float an) {\n    float c = cos(an);\n    float s = sin(an);\n    return vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);\n}\n\nvec3 rotateZ(in vec3 p, float an) {\n    float c = cos(an);\n    float s = sin(an);\n    return vec3(c * p.x - s * p.y, s * p.x + c * p.y, p.z);\n}\n\nvec2 map(in vec3 p, bool frame) {\n    vec2 res = vec2(0.0, p.y - fBm(p.xz));\n    if (frame) {\n        float d1 = sdBox(rotateX(rotateY(p - vec3(0.0, 1.0, 0.0), -1.25), 1.58), vec3(0.5, 0.0, 0.5));\n        vec2 obj = vec2(1.0, max(d1, sdSphere(p - vec3(0.0, 1.0, 0.0), 0.5)));\n        if (obj.y < res.y) res = obj;\n    }\n    float d2 = sdTriPrism(rotateX(rotateY(p - vec3(0.0, 1.51, 0.0), -1.25), 3.14159), vec2(0.025, 0.055));\n    float d3 = sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(-0.112, 0.635, 0.35), -1.25), 3.14159), 2.35), vec2(0.025, 0.055));\n    float d4 = sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(0.112, 0.635, -0.35), -1.25), 3.14159), -2.35), vec2(0.025, 0.055));\n    vec2 obj = vec2(2.0, smin(smin(smin(sdTorus82(rotateX(rotateY(p - vec3(0.0, 1.0, 0.0), -1.25), 1.58), vec2(0.5, 0.05)), d2, 16.0), d3, 16.0), d4, 16.0));\n    if (obj.y < res.y) res = obj;\n    obj = vec2(3.0, sdTriPrism(rotateX(rotateY(p - vec3(0.0, 1.51, 0.0), -1.25), 3.14159), vec2(0.025, 0.1)));\n    if (obj.y < res.y) res = obj;\n    obj = vec2(3.1, sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(-0.122, 1.36, 0.35), -1.25), 3.14159), 0.84), vec2(0.025, 0.055)));\n    if (obj.y < res.y) res = obj;\n    obj = vec2(3.2, sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(0.117, 1.36, -0.35), -1.25), 3.14159), -0.84), vec2(0.025, 0.055)));\n    if (obj.y < res.y) res = obj;\n    obj = vec2(3.3, sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(-0.162, 1.0, 0.49), -1.25), 3.14159), 1.6), vec2(0.025, 0.055)));\n    if (obj.y < res.y) res = obj;\n    obj = vec2(3.4, sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(0.162, 1.0, -0.49), -1.25), 3.14159), -1.6), vec2(0.025, 0.055)));\n    if (obj.y < res.y) res = obj;\n    obj = vec2(3.5, sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(-0.112, 0.635, 0.35), -1.25), 3.14159), 2.35), vec2(0.025, 0.1)));\n    if (obj.y < res.y) res = obj;\n    obj = vec2(3.6, sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(0.115, 0.635, -0.35), -1.25), 3.14159), -2.35), vec2(0.025, 0.1)));\n    if (obj.y < res.y) res = obj;\n\n    return res;\n}\n\nvec2 map(in vec3 p) {\n    return map(p, true);\n}\n\nvec3 raymarchTerrain(in vec3 ro, in vec3 rd, in float tmin, in float tmax) {\n    float t = tmin;\n    vec3 res = vec3(-1.0);\n    float breakOut = 0.0;\n    int i = 0;\n    while (i < 10 && breakOut != 1.0) {\n        vec3 p = ro + rd * t;\n        res = vec3(map(p), t);\n        float d = res.y;\n        if (d < (0.001 * t) || t > tmax)\n            breakOut = 1.0;\n        t += 0.5 * d;\n        i++;\n    }\n    return res;\n}\n\nvec3 getTerrainNormal(in vec3 p) {\n    float eps = 0.025;\n    return normalize(vec3(fBm(vec2(p.x - eps, p.z)) - fBm(vec2(p.x + eps, p.z)),\n                          2.0 * eps,\n                          fBm(vec2(p.x, p.z - eps)) - fBm(vec2(p.x, p.z + eps))));\n}\n\nvec3 getGateNormal(in vec3 p, float e) {\n    vec2 eps = vec2(e, 0.0);\n    return normalize(vec3(map(p + eps.xyy).y - map(p - eps.xyy).y,\n                          2.0 * eps.x,\n                          map(p + eps.yyx).y - map(p - eps.yyx).y));\n}\n\nvec3 getGateBump(in vec3 p, float e) {\n    vec2 eps = vec2(e, 0.0);\n    return normalize(vec3(fBm3d(p + eps.xyy) - fBm3d(p - eps.xyy),\n                          fBm3d(p + eps.yxy) - fBm3d(p - eps.yxy),\n                          fBm3d(p + eps.yyx) - fBm3d(p - eps.yyx)));\n}\n\n\nfloat raymarchAO(in vec3 ro, in vec3 rd, float tmin) {\n    float ao = 0.0;\n    for (float i = 0.0; i < 5.0; i++) {\n        float t = tmin + pow(i / 5.0, 2.0);\n        vec3 p = ro + rd * t;\n        float d = p.y - fBm(p.xz);\n        ao += max(0.0, t - 0.5 * d - 0.05);\n    }\n    return 1.0 - 0.4 * ao;\n}\n\nfloat raymarchShadow(in vec3 ro, in vec3 rd, float tmin, float tmax) {\n    float sh = 1.0;\n    float t = tmin;\n    float breakOut = 0.0;\n    int i = 0;\n    while (i < 40 && breakOut != 1.0) {\n        vec3 p = ro + rd * t;\n        float d = p.y - fBm(p.xz);\n        sh = min(sh, 16.0 * d / t);\n        t += 0.5 * d;\n        if (d < (0.001 * t) || t > tmax)\n            breakOut = 1.0;\n        i++;\n    }\n    return sh;\n}\n\n\nfloat raymarchGateShadow(in vec3 ro, in vec3 rd, float tmin, float tmax) {\n    float sh = 1.0;\n    float t = tmin;\n    float breakOut = 0.0;\n    int i = 0;\n    while (i < 80 && breakOut != 1.0) {\n        vec3 p = ro + rd * t;\n        float d = map(p, false).y;\n        sh = min(sh, 16.0 * d / t);\n        t += 0.5 * d;\n        if (d < (0.001 * t) || t > tmax)\n            breakOut = 1.0;\n        i++;\n    }\n    return sh;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n\n    vec3 eye = vec3(0.0, 1.25, 1.5);\n    vec2 rot = 6.2831 * (vec2(-0.05 + iTime * 0.025, 0.0 - sin(iTime * 0.5) * 0.01) + vec2(1.0, 0.0) * (iMouse.xy - iResolution.xy * 0.25) / iResolution.x);\n    eye.yz = cos(rot.y) * eye.yz + sin(rot.y) * eye.zy * vec2(-1.0, 1.0);\n    eye.xz = cos(rot.x) * eye.xz + sin(rot.x) * eye.zx * vec2(1.0, -1.0);\n\n    vec3 ro = eye;\n    vec3 ta = vec3(0.5, 1.0, 0.0);\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(vec3(0.0, 1.0, 0.0), cw));\n    vec3 cv = normalize(cross(cw, cu));\n    mat3 cam = mat3(cu, cv, cw);\n\n    vec3 rd = cam * normalize(vec3(p.xy, 1.0));\n\n    // background\n    vec3 color = skyColor;\n\n    // terrain marching\n    float tmin = 0.1;\n    float tmax = 20.0;\n    vec3 res = raymarchTerrain(ro, rd, tmin, tmax);\n    float t = res.z;\n    if (t < tmax) {\n        vec3 pos = ro + rd * t;\n        vec3 nor;\n        // add bumps\n        if (res.x == 0.0) {\n            nor = getTerrainNormal(pos);\n            nor = normalize(nor + 0.5 * getTerrainNormal(pos * 8.0));\n        } else if (res.x == 1.0){\n            nor = getGateNormal(pos, 0.1);\n            nor = normalize(nor + 0.05 * getGateBump(pos * 4.0 + vec3(iTime * 0.25, 1.0, 1.0), 0.005));\n        } else if (res.x == 2.0){\n            nor = getGateNormal(pos, 0.005);\n            nor = normalize(nor + 0.25 * getGateBump(pos * 32.0, 0.005));\n        } else {\n            nor = getGateNormal(pos, 0.005);\n            nor = normalize(nor + 0.1 * getGateBump(pos * 16.0, 0.005));\n        }\n\n        // 3 lights rig\n        float sun = clamp(dot(sunDirection, nor), 0.0, 1.0);\n        float sky = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n        float ind = clamp(dot(vec3(-sunDirection.x, 0.0, -sunDirection.z), nor), 0.0, 1.0);\n        float occ = clamp(raymarchAO(pos, nor, 0.1), 0.0, 1.0);\n        float sha1 = clamp(raymarchShadow(pos, sunDirection, 0.25, tmax), 0.0, 1.0);\n        float sha2 = clamp(raymarchGateShadow(pos, sunDirection, 0.05, tmax), 0.0, 1.0);\n\n        vec3 lightColor = 1.0 * sun * sunLightColor;\n        lightColor *= pow(vec3(sha1), vec3(1.0, 1.2, 1.5));\n        lightColor *= pow(vec3(sha2), vec3(1.0, 1.2, 1.5));\n        lightColor += 0.7 * sky * skyLightColor * occ;\n        lightColor += 0.3 * ind * indLightColor * occ;\n\n        if (res.x == 1.0) {\n            vec3 h = normalize(-rd + sunDirection);\n            float spe = pow(clamp(dot(h, nor), 0.0, 1.0), 2.0);\n            float fresnel = 1.0;\n            float fre = fresnel + (1.0 - fresnel) * pow(1.0 - dot(nor, -rd), 5.0);\n            lightColor += 32.0 * spe * sun * occ;\n            color = vec3(0.05, 0.2, 0.8) * 2.0 * warp(pos * 2.0 + vec3(iTime * 0.15, 1.0, 1.0));\n            lightColor *= pow(indLightColor, vec3(1.0)) * fre;\n        } else if (res.x == 2.0) {\n            vec3 ref = reflect(rd, -sunDirection);\n            float spe = pow(clamp(dot(ref, nor), 0.0, 1.0), 2.0);\n            float fresnel = 1.0;\n            float fre = fresnel + (1.0 - fresnel) * pow(1.0 - dot(nor, -rd), 5.0);\n            lightColor += 32.0 * spe * sun * occ;\n            color = vec3(0.1, 0.11, 0.15) * 0.05;\n            lightColor *= pow(indLightColor, vec3(1.0)) * fre;\n        } else if (res.x > 2.0) {\n            vec3 ref = reflect(rd, -sunDirection);\n            float spe = pow(clamp(dot(ref, nor), 0.0, 1.0), 2.0);\n            float fresnel = 1.0;\n            float fre = fresnel + (1.0 - fresnel) * pow(1.0 - dot(nor, -rd), 5.0);\n            lightColor += 16.0 * spe * sun * occ;\n            color = vec3(0.2, 0.1, 0.01);\n            lightColor *= pow(indLightColor, vec3(1.0)) * fre;\n        }\n\n        color *= 0.8 * lightColor;\n\n        // there no air on mars but a bit of fog is better\n        color = mix(color, horizonColor, 1.0 - exp(-0.01 * t * t));\n    } else {\n        float sunDot = clamp(dot(sunDirection, rd), 0.0, 1.0);\n        float sky = clamp(0.8 * (1.0 - 0.8 * rd.y), 0.0, 1.0);\n        float diffuse = clamp(0.4 * sunDot, 0.0, 1.0);\n        color = sky * skyColor + pow(sunDot, 2000.0) * sunColor;\n\n        // horizon\n        color = mix(color, horizonColor, pow(1.0 - rd.y, 4.0));\n    }\n\n    // gamma correction\n    vec3 gamma = vec3(1.0 / 2.2);\n    fragColor = vec4(pow(color, gamma), 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MlB3zh","date":"1426800418","viewed":3443,"name":"[NV15] The Barsoom Gate","username":"jimmikaelkael","description":"Somewhere on the red planet an ancient interstellar gate has been found.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","warping","domain","mars","gate"],"hasliked":0,"parentid":"","parentname":""}}