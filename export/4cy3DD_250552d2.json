{"ver":"0.1","info":{"id":"4cy3DD","date":"1712869270","viewed":66,"name":"The rotating polyhedron","username":"ArtemZh","description":".","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["2d3dmoving"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s = sin(a), c = cos(a); // Рассчитывает синус и косинус угла a, которые используются для матрицы поворота.\n    return mat2(c, -s, s, c); // Возвращает матрицу поворота\n}\n\nmat2 RotX(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c); \n}\n\nfloat PolyhedronDist(vec3 p, float scale) {\n    p /= scale; \n    float c = cos(PI / 5.0), s = sqrt(0.75 - c * c);\n    vec3 n = vec3(-0.5, -c, s);\n\n    p = abs(p); \n    p -= 2.0 * min(0.0, dot(p, n)) * n;\n    p.xy = abs(p.xy);\n    p -= 2.0 * min(0.0, dot(p, n)) * n;\n    p.xy = abs(p.xy);\n    p -= 2.0 * min(0.0, dot(p, n)) * n;\n\n    return (p.z - 1.0) * scale;\n}\n\n/*\np /= scale;: Масштабирует позицию p для упрощения расчёта расстояний\nfloat c = cos(PI / 5.0), s = sqrt(0.75 - c * c);: Вычисляет косинус и синус угла, используемые для определения направления нормали n\nvec3 n = vec3(-0.5, -c, s);: Определяет нормаль к одной из граней многогранника\np -= 2.0 * min(0.0, dot(p, n)) * n;: Выполняет ряд операций для \"обрезки\" точки p относительно многогранника, симулируя его поверхности\np.xy = abs(p.xy);: Берёт абсолютные значения для координат x и y после предыдущего шага\nreturn (p.z - 1.0) * scale;: Возвращает финальное расстояние до многогранника, масштабированное обратно к исходному размеру\n*/\n\nfloat GetDist(vec3 p) {\n    float timeFactor = .5; // Задаёт скорость изменения анимации\n    float scale = 1.0 + 0.5 * sin(iTime * timeFactor); // Изменение размера фигуры в зависимости от времени\n    vec3 pOrig = p;\n\n    \n    p.xz *= Rot(iTime * 0.5); // Поворот по осям X и Z, проворачивает вокруг оси Y\n    float d1 = PolyhedronDist(p, scale); // Получние расстояния до фигуры\n    \n    return d1; // Возвращает расстояние\n   \n    /*\n    p = pOrig;\n    p.yz *= RotX(PI / 4.0); \n    p.xz *= Rot(iTime * 0.3);\n    float d2 = PolyhedronDist(p, scale);\n    return min(d1, d2); // Возвращает наименьшее расстояние из двух рассчитанных\n    */\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float side) {\n    float dO = 0.0; // Инициализация переменнной (накопленное расстояние)\n\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO; // На каждом шаге текущая позиция p обновляется. Она рассчитывается как начальная точка ro плюс направление rd, умноженное на накопленное расстояние dO\n        float dS = GetDist(p) * side; // Расстояние до ближайшего объекта от точки p\n        dO += dS; // К накопленному расстоянию dO добавляется дистанция dS, полученная на текущем шаге\n        if (dO > MAX_DIST || abs(dS) < SURF_DIST) break; // Цикл прерывается, если луч прошёл больше максимально допустимого расстояния MAX_DIST или если расстояние до поверхности (dS) становится меньше минимального порога SURF_DIST\n    }\n\n    return dO; // Возвращается общее расстояние dO, которое луч преодолел от начальной точки ro до момента выхода из цикла\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(0.03, 0);\n    vec3 n = GetDist(p) - vec3(GetDist(p - e.xyy), GetDist(p - e.yxy), GetDist(p - e.yyx));\n\n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n/*\n    uv — нормализованные координаты на экране\n    p — позиция камеры,\n    l — look-at point\n    z — zoom\n*/\n    vec3 \n        f = normalize(l - p), // Рассчитывает направленный от камеры к точке взгляда вектор\n        r = cross(vec3(0, 1, 0), f), // Определяет right vector путём взятия произведения вектора vec3(0, 1, 0) и вектора взгляда f. \n        u = cross(f, r), // Up vector камеры получается взятием произведения вектора взгляда f и вектора r, формируя третью ось системы координат камеры.\n        c = f * z, //  Умножение вектора f на расстояние z дает координаты центра проекции относительно позиции камеры\n        i = c + uv.x * r + uv.y * u; // К центральной точке проекции c добавляются смещения вдоль осей r и u, масштабированные соответственно значениями uv.x и uv.y. Это определяет точку на экране, куда будет направлен луч, исходя из начальной позиции p\n    return normalize(i); // Возвращает нормализованный вектор, который указывает направление луча от камеры к пикселю на экране\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y; // Сдвигает координаты фрагмента так, чтобы центр экрана находился в (0,0)\n    vec2 m = iMouse.xy / iResolution.xy; // Движение мыши \n    vec3 ro = vec3(0, 3, -3); // Вектор ray origin определяет положение камеры в пространстве, 3 по y, -3 по Z\n    ro.yz *= Rot(-m.y * PI + 1.); // Задается поворот камеры вдоль оси YZ\n    ro.xz *= Rot(-m.x * TAU); // поворот камеры вдоль оси XZ\n\n    vec3 rd = GetRayDir(uv, ro, vec3(0, 0.0, 0), 1.0); // Вычисление направления луча, GetRayDir вычисляет направление ray direction из точки ro через пиксель экрана, определяемый координатами uv\n    vec3 col = texture(iChannel0, rd).rgb; // Получает цвет из текстуры iChannel0, используя направление rd как координаты текстуры\n    float d = RayMarch(ro, rd, 1.0); // Вызывает функцию RayMarch, которая ищет ближайший объект в направлении rd от точки ro. Возвращает расстояние d до этого объекта\n\n    float IOR = 1.2; // Индекс приломления \n\n    if (d < MAX_DIST) { //  Проверяет, был ли найден объект на расстоянии меньше максимально допустимого, указанного константой MAX_DIST \n        vec3 p = ro + rd * d; // Расчитваются точки пересечения: вычисляет точное местоположение p на поверхности объекта, где луч столкнулся с ним. Это делается путем перемещения от начальной точки ro вдоль направления rd на расстояние d\n        vec3 n = GetNormal(p); // Вычисление нормали в точке пересечения: получение вектора n к поверхности в точке p с помощью функции GetNormal. Для вычисления приломления и отражения\n        vec3 r = reflect(rd, n); // Вычисление отраженный луч: определение направления r отраженного луча на основе исходного направления луча rd и нормали n в точке пересечения\n        vec3 rdIn = refract(rd, n, 1.0 / IOR); // Вычисление преломленного луча: Рассчитывает направление преломленного луча rdIn, используя исходное направление rd, нормаль n и отношение индексов преломления. 1.0 / IOR. из более плотной среды в менее плотную\n        vec3 refOutside = texture(iChannel0, r).rgb; // \n        vec3 pEN = p - n * SURF_DIST * 3.0; // Это нужно для предотвращения артефактов самопересечения, точка p смещается назад от поверхности по нормали n на утроенное значение SURF_DIST\n        float dIn = RayMarch(pEN, rdIn, -1.0); // Трассировка луча: выполняет ray marching для преломленного луча rdIn начиная с смещенной точки pEN в направлении, противоположном поверхности\n\n        vec3 pEx = pEN + rdIn * dIn; // Расчет выходной точки преломленного луча: определяет положение pEx, где преломленный луч покидает объект, используя начальную точку pEN и направление rdIn, перемещенное на расстояние dIn\n        vec3 nEx = -GetNormal(pEx); // Вычисление нормали на выходе: получает нормаль nEx на новой выходной точке pEx и инвертирует ее\n\n        vec3 refltex = vec3(0); \n        vec3 rdOut = vec3(0); // Инициализация векторов для цветов и направлений: устанавливает начальные значения для текстуры отражения refltex и направления исходящего луча rdOut\n\n        float ab = 0.01; // Задаем значение хроматической абберации\n\n        rdOut = refract(rdIn, nEx, IOR - ab); \n        if (length(rdOut) == 0.) rdOut = reflect(rdIn, nEx); // Вычисление выходного луча с аберрацией: пытается преломить rdIn на выходе с учетом измененного индекса преломления. Если преломление невозможно, использует отражение\n        refltex.rgb = texture(iChannel0, rdOut).rgb; // Извлекает красный цвет из текстуры iChannel0, используя направление rdOut для этого компонента\n\n       /* rdOut = refract(rdIn, nEx, IOR);\n        if (length(rdOut) == 0.) rdOut = reflect(rdIn, nEx); \n        refltex.g = texture(iChannel0, rdOut).g; // Извлекает зеленый цвет из текстуры\n\n        rdOut = refract(rdIn, nEx, IOR);\n        if (length(rdOut) == 0.) rdOut = reflect(rdIn, nEx);\n        refltex.b = texture(iChannel0, rdOut).b; // // Извлекает синий цвет из текстуры*/\n\n                        \n        col = vec3(refltex); //Устанавливает окончательный цвет фрагмента, с использованием полученных цветов отраженного или преломленного луча\n\n        //col = n * 0.5 + 0.5;\n    }\n\n    /*\n    float cd = dot(uv, uv); //  Рассчитывает квадрат расстояния от центра UV-координат до текущего пикселя, используя скалярное произведение, создает эффект освещения\n    float light = 0.0005 / cd * sin(T) * 6.0; //  Рассчитывает значение освещенности на основе времени и расстояния от центра\n    col += light * S(0., 0.5, d - 1.0); // Модифицирует окончательный цвет col, добавляя вычисленное освещение\n    */ \n    \n    \n    \n    col = pow(col, vec3(.4545)); // Корритировка гаммы к цвету, используя обратное значение гаммы 2.2 (приблизительно 0.4545), необходимо для правильного отображения цветов\n    \n    \n    \n    \n    /*vec4 overlayColor = texture(iChannel1, fragCoord / iResolution.xy);\n\n    if (overlayColor.a > 0.0) {\n        col = mix(col, overlayColor.rgb, overlayColor.a);\n    }*/\n\n    fragColor = vec4(col, 1.0); // Установка окончательного цвета и задает полную непрозрачность\n}\n ","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define S smoothstep\n#define T iTime\n\n\nvec3 rotateY(vec3 v, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(c*v.x + s*v.z, v.y, -s*v.x + c*v.z);\n} //  Функция rotateY: Принимает вектор v и угол angle, возвращает вектор, повёрнутый вокруг оси Y.\nfloat DistLine(vec3 ro, vec3 rd, vec3 p) {\n    return length(cross(p - ro, rd)) / length(rd);\n} //  Вычисляет минимальное расстояние от точки p до линии, заданной начальной точкой ro и направлением rd.\n\n// Функция для рисования точки в пространстве с использованием гладкого перехода цвета\nvec4 DrawPoint(vec3 ro, vec3 rd, vec3 p, float time) {\n    float d = DistLine(ro, rd, p); // Расстояние от точки до луча\n    d = S(0.08, 0.01, d) * 0.7; // Применение функции smoothstep для сглаживания краев и уменьшение яркости\n    \n    // Динамическое изменение цвета точки в зависимости от времени и её положения в пространстве\n    float r = sin(p.x * 0.5 + time) * 0.5 + 0.5;\n    float g = sin(p.y * 0.5 + time) * 0.5 + 0.5;\n    float b = sin(p.z * 0.5 + time) * 0.5 + 0.5;\n    \n    return vec4(vec3(r, g, b) * d, d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Вычисление положения и направления взгляда камеры\n    vec3 ro = vec3(3.0 * sin(T), 2.0, -3.0 * cos(T)); // Положение камеры, вращающееся вокруг сцены\n    vec3 lookat = vec3(0.5); // Точка, на которую камера смотрит\n    float zoom = 1.7; // Приближение\n    \n    vec3 f = normalize(lookat - ro); //Вычисление направления взгляда\n    vec3 r = cross(vec3(0.0, 1.0, 0.0), f); // Правый вектор камеры: Вектор r вычисляется как перекрестное произведение вектора \"вверх\" мира (vec3(0.0, 1.0, 0.0)) и направления взгляда (f). Это дает вектор, перпендикулярный обоим, указывающий в \"правую\" сторону от камеры.\n    vec3 u = cross(f, r); // Вектор верха камеры: Вектор u — это результат перекрестного произведения вектора взгляда и правого вектора, указывающий \"вверх\" относительно камеры.\n    \n    vec3 c = ro + f * zoom; // Вычисление центра экрана: c представляет собой центральную точку экрана, получаемую путем перемещения от начальной точки камеры (ro) в направлении взгляда (f), умноженного на коэффициент увеличения (zoom).\n    vec3 i = c + uv.x * r + uv.y * u; // Расчет позиции пересечения луча с экраном: i является точкой на экране, где должен проходить луч, вычисляемый путем добавления к центру экрана смещений по осям x и y, умноженных на соответствующие векторы правой и верхней стороны.\n    vec3 rd = i - ro; // Направление луча\n    \n    vec4 finalColor = vec4(0.0);\n    \n    // Рисование точек в пространстве с динамическим изменением цвета и альфа-канала\n    finalColor += DrawPoint(ro, rd, vec3(0.0, 1.0, 0.0), T);\n    finalColor += DrawPoint(ro, rd, vec3(0.0, 1.0, 1.0), T);\n    finalColor += DrawPoint(ro, rd, vec3(1.0, 1.0, 0.0), T);\n    finalColor += DrawPoint(ro, rd, vec3(1.0, 1.0, 1.0), T);\n    \n    finalColor.a = min(finalColor.a, 1.0);\n    \n    fragColor = finalColor;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}