{"ver":"0.1","info":{"id":"7tB3Rm","date":"1623562643","viewed":48,"name":"Raymarch baby-steps","username":"muio","description":"My first try at raymarching on shadertoy.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCH_STEPS (1<<7)\n#define MAX_MARCH_DIST 100.\n#define SURF_DIST_MARCH .01\n#define EULER_APPROX_OFFSET .003\n\nstruct Sphere {\n    vec3 o;\n    float r;\n};\n\n\nconst Sphere s = Sphere(vec3(0, 1, 6), 1.);\nconst vec3 lightPos = vec3(0, 5, 6);\n\n\nfloat SphereSDF(vec3 p, Sphere s) {\n    return length(p - s.o) - s.r;\n}\n\nfloat GetDist(vec3 p) { // sdf for the scene.\n    float sphereDist = SphereSDF(p, s);\n    float planeDist = p.y; // ground\n    \n    float d = min(planeDist, sphereDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.; // Distance I've marched from origin\n\n    for (int i = 0; i < MAX_MARCH_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += dS;  // Safe distance to march with\n        if (dO > MAX_MARCH_DIST || // Far-plane clipping\n            dS < SURF_DIST_MARCH)  // Did we hit anything?\n            break;\n    }\n\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) { // get surface normal using euler approx. method\n    vec2 e = vec2(EULER_APPROX_OFFSET, 0);\n    \n    vec3 left = vec3(GetDist(p - e.xyy),\n                     GetDist(p - e.yxy),\n                     GetDist(p - e.yyx)),\n        right = vec3(GetDist(p + e.xyy),\n                     GetDist(p + e.yxy),\n                     GetDist(p + e.yyx));\n        \n    vec3 n = normalize(-left + right);\n    return n;\n}\n\nfloat GetLight(vec3 p) { // using diffuse lighting model\n    vec3 lightPosOffset = vec3(sin(2. * iTime), 0, cos(2. * iTime)) * 3.;\n    vec3 lightPos = lightPos + lightPosOffset;\n    vec3 l = normalize(lightPos - p); // light vector\n    vec3 n = GetNormal(p); // get normal of p\n    \n    float dif = clamp(dot(l, n), 0., 1.);\n    \n    // shadow stuff\n    vec3 pOffset = n * SURF_DIST_MARCH * 1.2; // move the point above a little\n    float d = RayMarch(p + pOffset, l);\n    if (d < length(lightPos - p)) // If true then we've shaded a point on some object before, \n                                  // so shade the currnet point as shodow.\n        dif *= .1; // no half-shadow because the light source is a point.\n    \n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5 ) / iResolution.y; // center around origin\n    \n    // simplest camera\n    vec3 ro = vec3(0, 1, 3);\n    vec3 rd = normalize(vec3(uv.xy, 1));\n    \n    // RayMarching stuff\n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    float dif = GetLight(p); // diffuse lighting\n    \n    vec3 col = vec3(dif); // gray\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}