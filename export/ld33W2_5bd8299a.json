{"ver":"0.1","info":{"id":"ld33W2","date":"1452208253","viewed":248,"name":"Shapes Morphing","username":"TambakoJaguar","description":"Use your mouse to morph between sphere, torus and cube (and a bit over!)\nOn this one, I used Fresnel reflection for fun and made a simple \"world landscape\".\nYou can also hit S to switch between normal and stereo (red-cyan anaglyph)","likes":4,"published":1,"flags":16,"usePreview":0,"tags":["3d","raymarching","mouse","torus","cube","sphere","landscape","primitives","morphing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/*\n\"Shapes Morphing\" by Emmanuel Keller aka Tambako - January 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n\nLamp lamps[3];\n    \nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  int objnr;\n};\n\nvec3 campos = vec3(0., 0.5, 5.);\nvec3 camdir = vec3(0., -0.1, -1.);\nfloat eye_dist = 0.25;\nbool stereo = false;\nfloat fov = 2.8;\n\nconst vec3 ambientColor = vec3(0.1, 0.4, 0.9);\nconst float ambientint = 0.08;\n\nvec3 colors[3];\n\n//#define shadow\n#define ambocc\n#define specular\nconst float specint = 0.2;\nconst float specshin = 30.;\nconst float aoint = 0.6;\nconst float shi = 0.8;\nconst float shf = 0.5;\n\nconst float normdelta = 0.0001;\nconst float maxdist = 55.;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.9;\nconst int aasamples = 2;\n\nconst int KEY_S = 83;\n\n// From https://www.shadertoy.com/view/4dsGRl\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel2, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\n    return rv;\n}\n\nfloat map(vec3 pos)\n{\n    float angle = mod(iTime*.8, 2.*pi);\n    vec3 posr = vec3(pos.x*cos(angle) + pos.z*sin(angle), pos.y, pos.x*sin(angle) - pos.z*cos(angle));\n    \n    float d1 = length(posr) - 1.35;\n    float d2 = pow(1.1 - sqrt(pow(posr.x, 2.)+pow(posr.y, 2.)), 2.) + pow(posr.z, 2.) - 0.1;\n    float d3 = max(max(abs(posr.y), abs(posr.z)), abs(posr.x)) - 1.;\n    float mx = iMouse.x/iResolution.x*1.2 - 0.3;\n    float my = iMouse.y/iResolution.y*1.6 -  0.3;\n    return mix(mix(d1, d2, mx), d3, my);\n    return d3;\n}\n\nfloat trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 3.2;\n  \tfor (int i = 0; i < 180; ++i)\n    {\n    \tvec3 pos = ray*t + cam;\n    \tfloat dist = map(pos);\n        if (dist>maxdist || abs(dist)<0.0003)\n            break;\n        t+= dist*0.4;\n  \t}\n  \treturn t;\n}\n\n// From https://www.shadertoy.com/view/MstGDM\nvec3 getNormal(vec3 pos, float e)\n{\n    vec2 q = vec2(0, e);\n    return normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),\n                          map(pos + q.xyx) - map(pos - q.xyx),\n                          map(pos + q.xxy) - map(pos - q.xxy)));\n}\n\nvec3 obj_color(vec3 norm, vec3 pos)\n{\n    return mix(vec3(1., 0.5, 0.2), vec3(0.5, 0.1, 0.9), dot(cross(norm.xyz, norm.zxy), norm.yzx));\n}\n\nvec3 sky_color(vec3 ray)\n{\n    float elev = atan(ray.y);\n \n    const float cloudsize = 0.25;\n    vec3 sky = ambientColor + vec3(0.4, 0.3, 0.05)*2.8*(0.65-elev);\n    float cloudst = smoothstep(-0.2, 0.5, elev)*texture(iChannel0, cloudsize*ray.xy).r;\n    sky = mix(sky, 0.45 + 0.6*vec3(cloudst), smoothstep(0.12, 0.5, cloudst)) + 0.3*vec3(smoothstep(0.2, 0.8, cloudst));\n    \n    vec3 grass = vec3(0.0, 0.35, 0.25) + vec3(0.22, 0.16, -0.03)*2.8*(0.65-elev);\n    grass = grass*(0.6 + 2.*abs(elev)*texture(iChannel1, 4.*ray.xy).rgb);\n    \n    return mix(grass, sky, smoothstep(-0.001, 0.001, elev)); \n}\n\n// From https://www.shadertoy.com/view/Xds3zN;\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i=0; i<16; i++)\n    {\n    \tfloat h = map(ro + rd*t);\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// From https://www.shadertoy.com/view/Xds3zN;\nfloat calcAO(vec3 pos, vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 0.8;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        \n    \tfloat dd = map(aopos);\n        \n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.5*occ, 0.0, 1.0 );    \n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = clamp(acos(-dot(ray, norm)), -pi/2.15, pi/2.15);\n   float r0 = pow((n1-n2)/(n1+n2), 2.);\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(0., 0.9, r);\n}\n\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol)\n{\n\tvec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n      \n    // Diffuse shading\n    float diff = clamp(dot(norm, pli), 0., 1.);\n    vec3 col = ocol*normalize(lamp.color)*lamp.intensity*smoothstep(0., 1.04, pow(diff, 0.78));\n    //vec3 col = ocol*normalize(lamp.color)*lamp.intensity*diff;\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.position - pos) > 0.0)\n        col+= vec3(1., 0.7, 0.3)*normalize(lamp.color)*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    col*= shi*softshadow(pos, normalize(lamp.position-pos), shf, 50.) + 1. - shi;\n    #endif\n    \n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\nRenderData trace0(vec3 tpos, vec3 ray)\n{\n    float tx = trace(tpos, ray, maxdist);\n    vec3 col;\n    int objnr;\n    \n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    if (tx<10.)\n    {\n        norm = getNormal(pos, normdelta);\n\n        // Coloring\n        col = obj_color(norm, pos);\n        objnr = 1;\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col);\n        \n        // Sky reflection\n        float r = fresnel(ray, norm, 2.3);\n        col = mix(col, sky_color(reflect(ray, norm)), r);\n        \n        // Ambient occlusion\n        #ifdef ambocc\n        col*= 1. - aoint + 1.25*aoint*vec3(calcAO(pos, norm));\n        //col = vec3(calcAO(pos, norm));\n        #endif\n  }\n  else\n  {\n      // Sky\n      col = sky_color(ray);\n      objnr = 3;\n  }\n  return RenderData(col, pos, norm, objnr);\n}\n\nvec4 render(vec2 fragCoord, vec3 campos)\n{\n  lamps[0] = Lamp(vec3(0., 4.5, 10.), vec3(1., 1., 1.), 6., 0.1);\n  lamps[1] = Lamp(vec3(12., -0.5, 6.), vec3(.9, 0.98, 1.), 4., 0.1);\n  lamps[2] = Lamp(vec3(-9., 1.8, -5. + iTime), vec3(1.0, 0.7, 0.7), 3., 0.1);\n    \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  RenderData traceinf = trace0(campos, ray);\n  vec3 col = traceinf.col;\n\n  return vec4(col, 1.0);\n}\n\nvec4 render_aa(vec2 fragCoord, vec3 campos)\n{\n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy), campos);\n       }\n    }\n    return vs/vec4(aasamples*aasamples);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (ReadKey(83, true))\n        stereo = !stereo;\n\n    if (stereo)\n    {\n       vec4 im_l = render_aa(fragCoord, campos + vec3(eye_dist/2., 0., 0.));\n       vec4 im_r = render_aa(fragCoord, campos + vec3(-eye_dist/2., 0., 0.)); \n       fragColor = vec4(im_l.r, 0, 0, 0) + vec4(0, im_r.gb, 0);\n    }\n    else \n       fragColor = render_aa(fragCoord, campos);    \n}","name":"","description":"","type":"image"}]}