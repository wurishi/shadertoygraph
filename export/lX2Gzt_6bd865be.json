{"ver":"0.1","info":{"id":"lX2Gzt","date":"1708903167","viewed":34,"name":"nose","username":"echelon0","description":"nose","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["nose"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"nose\" by echelon0. https://shadertoy.com/view/lX2Gzt\n// 2024-02-25 23:22:09\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sd_elipsoid(in vec3 p, in vec3 r) {\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sd_sphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n//https://iquilezles.org/articles/distfunctions/\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = pow(clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 ),2.0);\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n//https://iquilezles.org/articles/distfunctions/\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat sd_eyes(in vec3 p) {\n    vec3 left_p = vec3(-0.5, 0.5, 0.0);\n    float r = 0.4;\n    return sd_sphere(p - left_p, r);\n}\n\nfloat sd_nose(in vec3 p) {\n    vec3 r = vec3(0.34,0.2,0.25);\n    float base = opSmoothUnion(sd_elipsoid(p, r), sd_sphere(p+vec3(0.,0.02,0.), 0.22), 0.1);\n    vec3 nostril_r = vec3(0.05,0.2,0.1);\n    float left_nostril = sd_elipsoid(p+vec3(0.14, 0.2, 0.1), nostril_r);\n    float right_nostril = sd_elipsoid(p+vec3(-0.14, 0.2, 0.1), nostril_r);\n    return opSmoothSubtraction(right_nostril, opSmoothSubtraction(left_nostril, base, 0.01), 0.01);\n}\n\nfloat map(in vec3 p) {\n    return min(sd_nose(p), sd_eyes(p));\n}\n\nvec3 normal(in vec3 p) {\n    float c = 0.0001;\n    vec3 dx = vec3(p.x + c, p.y, p.z);\n    vec3 dy = vec3(p.x, p.y + c, p.z);\n    vec3 dz = vec3(p.x, p.y, p.z + c);\n    float dist_p = map(p);\n    return normalize(vec3(map(dx) - dist_p, map(dy) - dist_p, map(dz) - dist_p));\n}\n\nvec3 color(in vec3 p) {\n    vec3 l0 = normalize(vec3(1.,1.,-1.));\n    float c = max(0.1,dot(normal(p), l0));\n    return vec3(c,c,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5,0.5);\n    uv.x *= (iResolution.x/iResolution.y);\n    vec3 col = vec3(1.,1.,1.);\n    \n    vec3 ro = vec3(0., 0., -2.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    float t = 0.;\n    \n    int max_steps = 100;\n    for (int i = 0; i < max_steps; i++) {\n        vec3 p = ro + t*rd;\n        float d = map(p);\n        if (abs(d) <= 0.001) {\n            col = color(p);\n            break;\n        }\n        t += d;\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}