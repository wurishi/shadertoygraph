{"ver":"0.1","info":{"id":"MX2yW3","date":"1727817476","viewed":18,"name":"Perlin Noise - PuzzleAndy","username":"PuzzleAndy","description":"Perlin noise","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License: CC0\n// https://puzzleandy.com\n\nfloat lerp(float p0, float p1, float x)\n{\n\treturn (1. - x) * p0 + x * p1;\n}\n\nfloat bilerp(\n\tfloat p00, float p10, float p01, float p11,\n\tfloat x, float y)\n{\n\tfloat q0 = lerp(p00, p10, x);\n\tfloat q1 = lerp(p01, p11, x);\n\treturn lerp(q0, q1, y);\n}\n\nfloat random (vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec2 random_unit(vec2 st)\n{\n    float angle = random(st) * 6.28;\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat noise (in vec2 st)\n{\n    // Integer and fractional parts\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Grid points\n    vec2 pa = i + vec2(0, 0);\n    vec2 pb = i + vec2(1, 0);\n    vec2 pc = i + vec2(0, 1);\n    vec2 pd = i + vec2(1, 1);\n    \n    // Gradient vectors\n    vec2 ga = random_unit(pa);\n    vec2 gb = random_unit(pb);\n    vec2 gc = random_unit(pc);\n    vec2 gd = random_unit(pd);\n    \n    // Offset vectors\n    vec2 oa = st - pa;\n    vec2 ob = st - pb;\n    vec2 oc = st - pc;\n    vec2 od = st - pd;\n\n    // Dot products\n    float da = dot(ga, oa);\n    float db = dot(gb, ob);\n    float dc = dot(gc, oc);\n    float dd = dot(gd, od);\n    \n    // Interpolation\n    vec2 t = smoothstep(0., 1., f);\n    return bilerp(da, db, dc, dd, t.x, t.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float scalar = 40.;\n    uv.x *= iResolution.x / scalar;\n    uv.y *= iResolution.y / scalar;\n    fragColor = vec4(vec3((noise(uv) + 1.) / 2.), 1);\n}","name":"Image","description":"","type":"image"}]}