{"ver":"0.1","info":{"id":"st3BW7","date":"1663169087","viewed":103,"name":"Tetrahedron Pl端cker","username":"spalmer","description":"simple ray tracing on triangles using Pl端cker-style techniques","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["line","raytrace","tetrahedra","pluecker"],"hasliked":0,"parentid":"Ndt3WX","parentname":"Tetrahedron in cube fork1"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// major fork, only kept the camera ray setup, mouselook of my fork of Fabrice's tet toy\n// http://shadertoy.com/view/Ndt3WX\n// original by http://shadertoy.com/user/FabriceNeyret2\n// http://shadertoy.com/view/7s33Df\n// this one does something completely different, draws the tetrahedron\n// as a polygonal model of triangles, utilizing a\n// quickly whipped together Pl端cker line intersection technique\n// http://wikipedia.org/wiki/Pl%C3%BCcker_coordinates\n// don't ask me what got into me this morning,\n// I haven't done polygons in idk how long!  ;)\n// Felt like brushing up on my Pl端cker math I guess.  Enjoy!\n// I just threw this together, there may still be\n// major goofs left like doubled up sign errors lol\n\n// this is most likely not the absolute fastest ray vs. triangle test.\n\n// rotation                  \n#define rot(a)   mat2(cos(a+vec4(0,11,33,0)))\n\nvec3 V[4] = vec3[]( vec3(1,1,-1),vec3(1,-1,1),vec3(-1,1,1),vec3(-1,-1,-1) ); // tet vertices\nint I[3*4] = int[]( 0,2,1, 0,1,3, 0,3,2, 1,2,3 ); // premade indexed triangle list\n// I think I got all the tris facing the right way!  :)\nfloat sgn(float x) { return x < 0. ? -1. : 1.; }\nfloat sum(vec3 v) { return v.x + v.y + v.z; } //dot(v, vec3(1)); } //\n// given triangle abc and ray from origin 0 + d*t, does it intersect? if so, return normal\nbool itri(vec3 d, vec3 a, vec3 b, vec3 c, out vec3 n, out float t)\n{\n    n = cross(b - c, a - c);\n    float x = dot(n, c);\n    if (x > 0.)\n        return false; // ray starts behind triangle plane\n    float y = dot(n, d);\n    if (y > 0.)\n        return false; // ray aiming wrong direction vs triangle plane normal (must be backfacing)\n    vec3 ud = d\n      //, vd = vec3(0)\n      //, ua = b - a\n      , va = cross(a, b) // same as cross(a, ua) but less instruction level dependency\n      //, ub = c - b\n      , vb = cross(b, c) // same as cross(b, ub)\n      //, uc = a - c\n      , vc = cross(c, a) // same as cross(c, uc)\n      ;\n    float sa = sum(ud * va) // + vd * ua) // commented 2nd term since vd is zero\n        , sb = sum(ud * vb) // + vd * ub)\n        , sc = sum(ud * vc) // + vd * uc)\n        ;\n    if (/*abs*/(sgn(sa) + sgn(sb) + sgn(sc)) < 3.) \n        return false; // not all same winding! so must not actually intersect, it's outside at least one edge\n    // but if it's close enough to zero, we may want to say it hit anyway and do antialiasing\n    t = x / y; // intersection time\n    return true;\n}\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    float t = 1e9;\n    vec3 r = iResolution,\n         d = normalize(vec3(u+u, -3.5*r.y) - r),     // ray direction\n         p = 7./r,\n         n = vec3(0),\n         m = iMouse.z > 0. ? iMouse.xyz/r -.5 : vec3(20,8,0)/1e2*cos(iTime+vec3(0,11,0)); // auto thumbnail\n    o = vec4(0);\n    for (int j = V.length(); --j >= 0; )\n        V[j].yz *= rot(.5-6.*m.y),\n        V[j].xz *= rot(2.-6.*m.x),\n        V[j] -= p; // model relative to ray origin\n    int i = I.length();\n    while ((i -= 3) >= 0) // take indices in groups of 3, aka triangles\n    {\n        vec3 h; float f;\n        if (itri(d, V[I[i]], V[I[i+1]], V[I[i+2]], h, f))\n            if (f < t)\n                t = f, n = h;\n    }\n    if (dot(n, n) > 0.) // hit anything?\n        o = vec4(sqrt(dot(normalize(n), vec3(-.57)) * .5 + .5)); // 'shading'\n}","name":"Image","description":"","type":"image"}]}