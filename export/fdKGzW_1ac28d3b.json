{"ver":"0.1","info":{"id":"fdKGzW","date":"1631188896","viewed":134,"name":"try3: ^3 Hermite spline path","username":"yunhai","description":"satisfy GC1 ,much nicer than last times :D","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["spline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float dVec(vec2 uv,vec2 dir)\n{\n    float t=clamp(dot(uv,dir)/dot(dir,dir),0.,1.);\n    t=SS(.05,.05-PIXW,length(uv-dir*t));\n    float o=.8,ang=60.*DTA,ldir=length(dir);\n    vec2 op=dir*o;\n    vec2 r=dir/ldir,\n         l=getRot(ang)*r;r=getRot(-ang)*r;\n    float a=ldir*(1.01-o)*cos(ang)*1.4;\n    float tri=\n    min(min(SS(a,a-PIXW,dot(r,uv-op)),\n        SS(a,a-PIXW,dot(l,uv-op))),\n        SS(ldir*o,ldir*o+PIXW,dot(uv,dir/ldir)));\n    return max(t,tri);\n}\nvoid drawPV(vec2 C,inout vec4 tarCol)\n{\n\n    \n    for(int i=0;i<psCount;i++)\n    {\n        tarCol.rgb=mix(tarCol.rgb,vec3(1),SS(.13,.13-2.*PIXW,length(UV-getPoint(i))));\n        tarCol.rgb=mix(tarCol.rgb,vec3(1),dVec(UV-getPoint(i),tangents[i]));\n    }\n        \n}\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    O.rgb=cartesian(UV);    \n    drawPV(C,O);\n    float fadePoint=cycle*.7;\n    O=O*SS(fadePoint*1.5+.5,fadePoint-.5,iT)+texture(iChannel0,C/iR);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define SS(a,b,t) smoothstep(a,b,t)\n#define SL(d) smoothstep(HLW,HLW-.005,d)\nconst float PI=3.14159265;\nconst int MAX_FUNCTION_NUM=10;\n//---------------------Lines-------------------\nconst float HLW=.05;//half line width\nconst float MSI=2.;//mesh space interval\nfloat line(vec2 uv,vec2 ori,vec2 dir)\n{\n    vec2 sp=uv-ori;\n    vec2 closp=dot(sp,dir)*dir+ori;\n    return SL(length(uv-closp));\n}\n//----------------------------------------------\nvec3 cartesian(vec2 uv)\n{\n    vec3 col=vec3(0.);\n    float msp=MSI;\n    float lhlw=HLW/2.;//local HLW\n    vec3 mesh=vec3(SS(lhlw,lhlw-.005,abs(uv.x-round(uv.x/msp)*msp)));\n    mesh+=vec3(SS(lhlw,lhlw-.005,abs(uv.y-round(uv.y/msp)*msp)));\n    col+=mesh*.5;\n    //col=mix(col,vec3(0.,1.,0.),line(uv,vec2(0.),vec2(1.,0.)));\n    //col=mix(col,vec3(0.,1.,0.),line(uv,vec2(0.),vec2(0.,1.)));\n    return col;\n}\nvec3 palette(float t)//Color Palette\n{\n    t*=1.732;\n    return vec3(.5,.7,.9)+vec3(.4,.3,.1)*cos(2.*PI*(vec3(.71,.81,.791)*t+vec3(.2,.4,.6)));\n}\n\n//-------------------experiment-----------------\nconst int psCount=6;\nvec2 points[]=vec2[](vec2(-8,-2),vec2(-6,3),vec2(5,-2),vec2(3,3),\n                     vec2(-3.5,-1.5),vec2(-8,-2));\nconst float R=4.;\nvec2 tangents[]=vec2[](vec2(-1,1),vec2(1,-.3),vec2(1,1),vec2(-1,0),\n                     vec2(-1,-.60)*1.5,vec2(-1,1));\nvec2 getPoint(int idx)\n{\n    return points[idx]+vec2(1.,0.);\n}\nconst float EPSILON=1e-3;\nconst float DTA=PI/180.;\n#define iR iResolution.xy\n#define PIXW (20./iR.y)\n#define UV ((C-.5*iR)*PIXW)\nconst float cycle=float(psCount)-1.;\nconst float restTime=3.;\n#define iT mod(iTime,cycle+restTime)\nmat2 getRot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 cubicHermite(vec2 p1,vec2 p2,vec2 t1,vec2 t2,float time)\n{\n    //define p:\n    //p(t)=a*t^3+b*t^2+c*t+d\n    //p'(t)=3*a*t^2+2*b*t+c\n    \n    //so let:\n    //p(0)=p1,p'(0)=t1\n    //p(1)=p2,p'(1)=t2\n    \n    //then we have\n    //[p1,p2,t1,t2]=[a,b,c,d]*M\n    //which\n    //     M=[0,1,0,3]\n    //       [0,1,0,2]\n    //       [0,1,1,1]\n    //       [1,1,0,0]\n    //inv(M)=[ 2,-3,0,1]\n    //       [-2, 3,0,0]\n    //       [ 1,-2,1,0]\n    //       [ 1,-1,0,0]\n\n    //so the p(t)=[a,b,c,d]*[ttt,tt,t,1]^T\n    //               =[p1,p2,t1,t2]*inv(M)*[ttt,tt,t,1]^T\n    //                   =[p1,p2,t1,t2]*H(t)\n    float t=time,tt=t*time,ttt=tt*time;\n    float a=2.*ttt-3.*tt+1.,\n          b=-2.*ttt+3.*tt,\n          c=ttt-2.*tt+t,\n          d=ttt-tt;\n    return a*p1+b*p2+c*t1+d*t2;           \n}\nvec2 mapTime(float t)\n{\n    float tf=fract(t);\n    int ti=int(floor(t)),tin=ti+1;\n    ti%=psCount;tin%=psCount;\n    return cubicHermite(getPoint(ti),getPoint(tin),tangents[ti]*R,R*tangents[tin],tf);\n}\nfloat dot2(vec2 v){return dot(v,v);}\nfloat dLineSegSqr(vec2 uv,vec2 start,vec2 end)\n{\n    vec2 sp=uv-start;\n    vec2 se=end-start;\n    vec2 closp=clamp(dot(sp,se)/dot(se,se),0.,1.)*se+start;\n    return dot2(uv-closp);\n}\nfloat dCurve(vec2 p)\n{\n    float minDD=1e20;vec2 resP;\n    float times=100.,stepLength=cycle/(times);\n    vec2 smp1=mapTime(0.);\n    for(float f=1.;f<=times;f++)\n    {\n        vec2 smp2=mapTime(f*stepLength);\n        float lenn=dLineSegSqr(p,smp1,smp2);\n        minDD=min(minDD,lenn);\n        smp1=smp2;\n    }\n    return sqrt(minDD);\n    \n}\nvoid mainImage( out vec4 O, in vec2 C )\n{\n\n    \n    vec2 uv=UV;\n    \n    if(iT>cycle)\n    {\n        vec3 curve=palette(.05*(uv.x+uv.y+1.))*SS(.1,.1-PIXW,dCurve(uv));\n        O.rgb=mix(texelFetch(iChannel0,ivec2(C),0).rgb,curve,SS(0.,-5.*PIXW,C.x-.5)+iT-cycle);\n    }\n    else\n    {\n        vec2 p=mapTime(iT);\n        O.rgb=iT<.1?vec3(0):texelFetch(iChannel0,ivec2(C),0).rgb;\n        O.rgb+=palette(iT)*SS(.1,.1-2.*PIXW,length(UV-p));\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}