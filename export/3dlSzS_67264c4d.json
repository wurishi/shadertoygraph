{"ver":"0.1","info":{"id":"3dlSzS","date":"1552233181","viewed":74,"name":"hometask1_Artem_Maksimov_316","username":"AddWard","description":"Допы описаны в readme.txt","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["hometask"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 100\n#define MAX_DIST 100.\n#define EPS .01\n#define SPECULAR_CONST 32\n#define AMBIENT 0.1\n#define SHADOW_CONST 0.1\n\nmat3 rotation(float yaw, float pitch) \n{ \n    return mat3(cos(yaw), 0, -sin(yaw), 0, 1, 0, sin(yaw), 0, cos(yaw)) * mat3(1, 0, 0, 0, cos(pitch), sin(pitch), 0, -sin(pitch), cos(pitch)); \n}\n \nfloat pow1(float a) {\n    float s = a;\n    for(int i=0; i<SPECULAR_CONST; i++) {\n        s *= a;\n    }\n    return s;\n}\n \nfloat opS( float d1, float d2 ) {\n    return max(-d1,d2);\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox1( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n \nvec2 GetDist(vec3 p, int fl) {\n    vec4 s1 = vec4(5, 1, 2, 1);\n    vec4 s2 = vec4(-3, 0.6, 6, 0.5);\n    vec4 s3 = vec4(3, 0.5, 1, 0.64);\n    float sd3 = length(p-s3.xyz) - s3.w;\n    vec2 tor = vec2(1, 0.3);\n    float planeDist = p.y;\n    float boxDist = sdBox(p - vec3(-2, 0.3, 3), vec3(0.5, 0.5, 0.5));\n    float mirror = sdBox(p-vec3(0, 0, 9), vec3(3, 7, 0.001));\n    float subtract_box = opS(sd3, sdBox(p-vec3(3, 0.5, 1), vec3(0.5, 0.5, 0.5)));\n    float sphereDist = length(p-s1.xyz) - s1.w;\n    float sd2 = length(p-s2.xyz) - s2.w;\n    float dist = min(sphereDist, sd2);\n    float torDist = sdTorus(p - vec3(0, 0.3, 5), tor);\n    dist = min(dist, planeDist);\n    dist= min(dist, sdTorus(p - vec3(0, 0.3, 5), tor));\n    dist = min(dist, boxDist);\n    dist = min(dist, subtract_box);\n    if(fl == 0) {\n    \tdist = min(dist, mirror);\n    }\n    if(dist == planeDist) {\n        return vec2(dist, 0.0);\n    }\n    if(dist == sphereDist) {\n        return vec2(dist, 1.0);\n    }\n    if(dist == sd2) {\n        return vec2(dist, 2.0);\n    }\n    if(dist == torDist) {\n        return vec2(dist, 3.0);\n    }\n    if(dist == boxDist) {\n        return vec2(dist, 4.0);\n    }\n    if(dist == subtract_box) {\n        return vec2(dist, 6.0);\n    }\n    if(fl == 0) {\n    \tif(dist == mirror) {\n        \treturn vec2(dist, 5.0);\n    \t}\n    }\n}\n \nvec3 GetNormal(vec3 p) {\n    float dist = GetDist(p, 0).x;\n    vec2 e = vec2(EPS, 0);   \n    return normalize(dist - vec3(GetDist(p-e.xyy, 0).x, GetDist(p-e.yxy, 0).x, GetDist(p-e.yyx, 0).x));   \n}\n \nvec2 RayMarching(vec3 RayOrigin, vec3 RayDirection, int fl) {\n    float dO=0.;\n    vec2 dS = vec2(0);\n    for(int i=0; i<STEPS; i++) {\n        vec3 p = RayOrigin + RayDirection*dO;\n        dS = GetDist(p, fl);\n        dO += dS.x;\n        if(dO>MAX_DIST || dS.x<EPS) {\n            break;\n        }\n    }\n   \n    return vec2(dO, dS.y);\n}\n \nfloat PhongLight(vec3 p, float fl) {\n    vec3 lightPos1 = vec3(3, 5, -3);\n    vec3 l1 = normalize(lightPos1-p);\n    vec3 lightPos2 = vec3(-3, 5, 5);\n    vec3 l2 = normalize(lightPos2-p); \n    vec3 n = GetNormal(p);   \n    float dif1 = clamp(dot(n, l1), 0., 1.);\n    dif1 = dif1 * 15./(length(lightPos1 - p)*length(lightPos1-p));\n\n    float d1 = RayMarching(p+n*EPS*2., l1, 0).x;\n    if(d1<length(lightPos1-p)) {\n        dif1 *= SHADOW_CONST;\n    }\n    float dif2 = clamp(dot(n, l2), 0., 1.);\n    float d2 = RayMarching(p+n*EPS*2., l2, 0).x;\n    if(d2<length(lightPos2-p)) dif2 *= .1;\n    dif2 = dif2 * 15./(length(lightPos2 - p)*length(lightPos2-p));\n    //specular\n    float specularStrength;\n    if(fl == 0.0) {\n        specularStrength = 0.0;\n    }\n    if(fl == 1.0) {\n        specularStrength = 0.5;\n    }\n    if(fl == 2.0) {\n        specularStrength = 0.0;\n    }\n    if(fl == 3.0) {\n        specularStrength = 0.3;\n    }\n    if(fl == 4.0) {\n        specularStrength = 0.7;\n    }\n    vec3 viewDir = normalize(p);\n    vec3 reflectDir = reflect(l1, GetNormal(p));\n    float spec = pow1(max(dot(viewDir, reflectDir), 0.0));\n    float specular1 = specularStrength * spec;   \n    viewDir = normalize(p);\n    reflectDir = reflect(l2, GetNormal(p));\n    spec = pow1(max(dot(viewDir, reflectDir), 0.0));\n    float specular2 = specularStrength * spec;\n    return clamp(dif2 + AMBIENT + dif1 + specular1 + specular2, 0., 1.);\n   \n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y; \n    vec3 col = vec3(1, 1, 1);\n    float yaw = 0.4;\n    vec3 RayOrigin = vec3(-1, 2, -3);\n    vec3 RayDirection = rotation(yaw, 0.0) * normalize(vec3(uv.x, uv.y, 1));\n    vec2 dist = RayMarching(RayOrigin, RayDirection, 0);\n   \n    vec3 p = RayOrigin + RayDirection * dist.x;\n    float dif;\n    if(dist.y == 0.0) {\n        col = vec3(1, 1, 1);\n    }\n    if(dist.y == 1.0) {\n        col = vec3(1, 0, 0);\n    }\n    if(dist.y == 2.0) {\n        col = vec3(0, 1, 0);\n    }\n    if(dist.y == 3.0) {\n        col = vec3(0, 0, 1);\n    }\n    if(dist.y == 4.0) {\n        col = vec3(1, 0, 1);\n    }\n    if(dist.y == 6.0) {\n        col = vec3(1, 0.5, 0);\n    }\n    if(dist.y == 5.0) {\n        col = vec3(1, 1, 1);\n        RayOrigin = p;\n        RayDirection = normalize(reflect(p, GetNormal(p)));\n        vec2 refld = RayMarching(RayOrigin, RayDirection, 1);\n        vec3 p1 = RayOrigin + RayDirection * refld.x;\n        if(refld.y == 0.0) {\n        \tcol = vec3(1, 1, 1);\n    \t}\n    \tif(refld.y == 1.0) {\n        \tcol = vec3(1, 0, 0);\n    \t}\n    \tif(refld.y == 2.0) {\n        \tcol = vec3(0, 1, 0);\n    \t}\n    \tif(refld.y == 3.0) {\n        \tcol = vec3(0, 0, 1);\n    \t}\n    \tif(refld.y == 4.0) {\n        \tcol = vec3(1, 0, 1);\n    \t}\n\n        if(refld.y == 6.0) {\n            col = vec3(1, 0.5, 0);\n        }\n        dif = PhongLight(p1, refld.y);\n        col *= dif;\n\n    } else {\n        float dif = PhongLight(p, dist.y);\n        col *= dif;\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}