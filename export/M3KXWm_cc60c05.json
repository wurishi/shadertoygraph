{"ver":"0.1","info":{"id":"M3KXWm","date":"1720062038","viewed":249,"name":"2D raytraced lighting","username":"lucysir","description":"2D colored lights and shadows\n\nMove the light source with your mouse.\nSettings are in common buffer.","likes":7,"published":1,"flags":48,"usePreview":1,"tags":["2d","raytracing","shadow","light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\n        fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Circle {\n    vec2 pos;\n    float radius;\n    vec3 color;\n};\n\n#define CIRCLES 6\n\nbool intersect_circle(vec2 origin, vec2 direction, Circle circle) {\n    vec2 l = circle.pos - origin;\n    float dc = dot(l, direction);\n    if (dc < 0.0) return false;\n    \n    float d2 = dot(l, l) - dc * dc;\n    if (d2 > circle.radius * circle.radius) return false;\n    return true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y;\n    float aspect = iResolution.x / iResolution.y;\n\n    vec2 mouse = iMouse.xy / iResolution.xy * vec2(aspect, 1.0);\n    \n    Circle[CIRCLES] circles = Circle[](\n        Circle(vec2(0.2, 0.2), 0.05, vec3(0.0)),\n        Circle(vec2(0.8, 0.23), 0.1, vec3(1.0, 0.0, 1.0)),\n        Circle(vec2(1.2, 0.19), 0.04, vec3(1.0)),\n        Circle(vec2(0.5, 0.5), 0.01, vec3(0.0)),\n        Circle(vec2(0.45, 0.65), 0.07, vec3(1.0, 1.0, 0.0)),\n        Circle(vec2(1.55, 0.7), 0.10, vec3(0.0, 1.0, 1.0))\n    );\n    \n    circles[5].pos = mouse;\n    \n    //circles[5].pos.y = 0.5 + sin(iTime*1.1) * 0.2;\n    \n    Circle obstacle = Circle(vec2(0.88, 0.7), 0.12, vec3(1.0));\n    \n    //obstacle.pos = mouse;\n    \n    fragColor = vec4(0.0);\n    \n    int samples = SAMPLES;\n    int steps = RAYS;\n    float step_ = (TAU) / float(steps);\n    int lights_hit = 0;\n    vec3 acc_color = vec3(0.0);\n    \n    int NRAYS = RAYS;\n    \n    vec2 ray_lut[RAYS * SAMPLES];\n    for (int i = 0; i < NRAYS * SAMPLES; i++) {\n        float angle = float(i % NRAYS) * (TAU / float(NRAYS));\n        float scatter = rand(uv * iTime * float(i+1)) * TAU;\n        ray_lut[i] = rotate(vec2(0.0, 1.0), angle + scatter);\n    }\n    \n    for (int s = 0; s < samples; s++) {\n        for (int j = 0; j < NRAYS; j++) {\n            vec2 ray = ray_lut[j + s * RAYS];\n\n            for (int i = 0; i < CIRCLES; i++) {\n                if (intersect_circle(uv, ray, circles[i])) {\n\n                    float d0 = distance(circles[i].pos, uv);\n                    float d1 = distance(obstacle.pos, uv);\n\n                    if ((d0 > d1) && intersect_circle(uv, ray, obstacle)) {\n                        //lights_hit -= 1;\n                        //acc_color -= obstacle.color;\n                    }\n\n                    else {\n                        lights_hit += 1;\n                        acc_color += circles[i].color;\n                    }\n                }\n            }\n        }\n    }\n    \n    vec4 base = vec4(1.0);\n    float light_intensity = LIGHT_INTENSITY;\n    \n    float light_factor = float(lights_hit) / float(steps);\n    vec3 light_color = (acc_color / float(max(lights_hit, 1)) / float(samples)) * light_factor * light_intensity;\n   \n    vec3 color = base.rgb * light_color;\n    \n    if (distance(uv, obstacle.pos) < obstacle.radius){\n        color = vec3(0.0);\n    }\n    \n    // Thanks to \"Casual Shadertoy Path Tracing\" article for frame accumulating\n    bool spacePressed = (texture(iChannel2, vec2(32.5/256.0,0.25)).x > 0.1) || (iMouse.z > 0.0);\n    \n    vec4 lastFrameColor = texture(iChannel1, fragCoord / iResolution.xy);\n    float blend = (lastFrameColor.a == 0.0 || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    vec4 final = mix(lastFrameColor, vec4(color, 1.0), blend);\n    \n    fragColor = vec4(final.rgb, blend);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/* SETTINGS */\n\n\n// Number of samples per frame\n#define SAMPLES 8\n\n// Number of rays sent for every pixel\n#define RAYS 5\n\n// Accumulated light color multiplier\n#define LIGHT_INTENSITY 1.65\n\n\n/* SETTINGS */\n\n\n\n#define PI 3.14159265359\n#define TAU 6.28318530717\n\nfloat rand(vec2 co){\n    // https://stackoverflow.com/a/4275343\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 rotate(vec2 v, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec2(\n        c * v.x - s * v.y,\n        s * v.x + c * v.y\n    );\n}","name":"Common","description":"","type":"common"}]}