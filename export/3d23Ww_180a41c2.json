{"ver":"0.1","info":{"id":"3d23Ww","date":"1549031047","viewed":143,"name":"cloud_003","username":"kuma720","description":"cloud","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["cloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(vec3 uv) {\n  return fract( sin( dot( uv ,vec3(123.,65.,44.) ) ) * 4811.424 );\n}\n\nfloat pnoise(vec3 uv,float f) {\n\n  vec3 t = uv * f;\n  vec3 v1 = floor(t);\n  vec3 v2 = fract(t);\n\n  float a0 = hash(v1 + vec3(0.,0.,0.));\n  float b0 = hash(v1 + vec3(1.,0.,0.));\n  float c0 = hash(v1 + vec3(0.,1.,0.));\n  float d0 = hash(v1 + vec3(1.,1.,0.));\n\n  float a1 = hash(v1 + vec3(0.,0.,1.));\n  float b1 = hash(v1 + vec3(1.,0.,1.));\n  float c1 = hash(v1 + vec3(0.,1.,1.));\n  float d1 = hash(v1 + vec3(1.,1.,1.));\n\n  float o1 = mix(a0,b0,v2.x);\n  float o2 = mix(c0,d0,v2.x);\n  float o3 = mix(o1,o2,v2.y);\n\n  float o4 = mix(a1,b1,v2.x);\n  float o5 = mix(c1,d1,v2.x);\n  float o6 = mix(o4,o5,v2.y);\n\n  float o7 = mix(o3,o6,v2.z);\n  \n  return o7;\n}\n\nfloat fbm(vec3 uv) {\n  float o = 0.;\n  float n = 1.;\n  float f = 2.5;\n  \n  for ( int i = 0 ; i < 4 ; ++ i ) {\n    o += pnoise( uv , f ) * n ;\n    f *= 2.; \n    n *= 0.5;\n  }\n\n  return o ;\n}\n\nfloat map( in vec3 p )\n{\n  float f = fbm( p * 0.7 + sin(iTime * 0.1) ) ;\n  float s1 = cos( f * 4.5);\n\treturn min( max(0.0, s1 ), 1.0 );\n}\n\nfloat sdf(vec3 p) {\n  \n  float l0 = dot ( p , vec3(0.,1.,0.));\n  float l1 = length( p ) - 3.0;\n  float l2 = max( -l0 , l1 );\n\n  if ( l2 < 0.01 ) {\n    float CLOUD_DENSITY = 5.5;\n    return map( p ) * CLOUD_DENSITY ;\n  }\n\n  return 0.;\n}\n\n\nmat4 createVTW(vec3 eye,vec3 center,vec3 up) {\n  vec3 f = normalize( center - eye );\n  vec3 s = normalize( cross(f,up) );\n  vec3 u = cross(s,f);\n  return mat4(\n    vec4(s,0.),\n    vec4(u,0.),\n    vec4(-f,0.),\n    vec4(0.,0.,0.,1)\n  );\n}\n\n\nvec3 rayDirection(float fieldofView,vec2 size,vec2 fragCoord) {\n  vec2 xy = fragCoord - size / 2.0;\n  float z = size.y / tan(radians(fieldofView) / 2.0 );\n  return normalize(vec3(xy,-z));\n}\n\n\n\n\n\nvec4 render( vec2 uv , vec3 eye , vec3 worldDir ) {\n\n  vec3 sky = vec3(0.1 - uv.y ,0.0,0.7 + uv.y ) ;\n\n  vec3 cloudColor = vec3( 1.0 , 1.0 , 1.0 );\n  vec3 lightVec = normalize ( vec3( 0.5 , 1. , 0.5 ) );\n\n  int steps = 40;\n  int shadowSteps = 30;\n\n  float invSteps = 1. / float(steps);\n  float invShadowSteps = 1. / float(shadowSteps);\n  float stepDistance = 2. * invSteps;\n  float shadowStepSize = 2. * invShadowSteps;\n\n  vec3 lightColor = vec3(0.,0.,0.);\n  float lightPower = 1.;\n\n  float dist = length ( eye ) - 1.2;\n  vec3 start = worldDir * dist ;\n  vec3 CurPos = eye + start ;\n  int flg = 0;\n  for(int I=0;I<steps;++I) {\n\n    float cursample = sdf( CurPos ) * 3.;\n    if ( cursample > 0.01 ) {\n\n      vec3 lpos = CurPos;\n\n      float shadowDist = 0.;\n      for ( int S = 0 ; S< shadowSteps ; ++S ) {\n        lpos += lightVec * shadowStepSize ;\n        float lsample = sdf( lpos );\n        shadowDist += lsample;\n      }\n\n      float curdensity = clamp( cursample * invSteps , 0. , 1. );\n      lightColor += exp( - shadowDist * invShadowSteps ) * curdensity * cloudColor * lightPower;\n      lightPower *= (1. - curdensity) ;\n      \n      if ( lightPower < 0.001 ) {\n        break;\n      }\n    }\n\n    CurPos += worldDir * stepDistance;\n  }\n\n  vec3 o = sky + lightColor ;\n  return vec4( o , 1. );\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord * (1.0/iResolution.x) - vec2(0.5, 0.5);\n\n    float t = iTime * .5;\n    vec3 eye = vec3( cos(t) * 5. , 3.2 , sin(t) * 5. );\n\n\n    vec3 center = vec3(0.,0.,0.);\n    vec3 up = vec3(0.,1.,0.);\n    mat4 vtw = createVTW(eye,center,up);\n\n    vec3 viewDir = rayDirection(90.,iResolution.xy,fragCoord);\n    vec3 worldDir = (vtw * vec4(viewDir,0.)).xyz;\n\n    fragColor = render( uv , eye , worldDir );\n}","name":"Image","description":"","type":"image"}]}