{"ver":"0.1","info":{"id":"ddBSWK","date":"1670878373","viewed":100,"name":"Hyperloop c64","username":"Mojomajor","description":"the 90ies are back\n\nEDIT: stole the c64 colors here https://www.shadertoy.com/view/Mll3DH\n\n\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["hazynineties"],"hasliked":0,"parentid":"DsBSDV","parentname":"Hazy Color (Hyper-)Loop Warp"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define chillTime iTime/90.\n// best between 60 and 140 seconds\n\n#define C64_COLOR 0\n#define AMIGA_COLOR 1\n\n\n\n//-------------------------------------------------------------------\n//--------------------------Effects----------------------------------\n//-------------------------------------------------------------------\n\nfloat tri(in float x){return abs(fract(x)-0.5);}\n\n//from iq\nvec3 hsl2rgb(in vec3 c){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 hsv2rgb(in vec3 c){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\t\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 fx1(in vec2 p)\n{\n    return hsl2rgb(clamp(vec3(p.x,p.y,p.y),0.,1.));\n}\n\n\n//-------------------------------------------------------------------\n//---------------------------RGB to C64------------------------------\n//-------------------------------------------------------------------\n\nvec3 pal[16];  //Palette from: http://www.pepto.de/projects/colorvic/\nvoid setpal()\n{\n    pal[0]=vec3(0),pal[1]=vec3(1),pal[2]=vec3(0.4530,0.2611,0.2089),pal[3]=vec3(0.4845,0.6764,0.7286), pal[4]=vec3(0.4825,0.2829,0.5663),pal[5]=vec3(0.3925,0.5921,0.3087),\n    pal[6]=vec3(0.2500,0.1972,0.5206), pal[7]=vec3(0.7500,0.8028,0.4794),pal[8]=vec3(0.4825,0.3576,0.1837),pal[9]=vec3(0.3082,0.2691,0.0000),pal[10]=vec3(0.6405,0.4486,0.3964),\n    pal[11]=vec3(0.3125,0.3125,0.3125),pal[12]=vec3(0.4688,0.4688,0.4688),pal[13]=vec3(0.6425,0.8421,0.5587),pal[14]=vec3(0.4688,0.4159,0.7393),pal[15]=vec3(0.6250,0.6250,0.6250);\n}\n\nfloat rectify(in float f){ return mix(pow(((f + 0.055)/1.055), 2.4), f / 12.92, step(f, 0.04045))*100.; }\nfloat pivot(in float x){ return mix(pow(x,0.3333), (903.3*x + 16.)/116., step(x,216.0/24389.0)); }\n//RGB to Lab (for color differencing) https://github.com/THEjoezack/ColorMine\nvec3 rgb2lab(in vec3 c)\n{\n\tc.r = rectify(c.r);\n\tc.g = rectify(c.g);\n\tc.b = rectify(c.b);\n\tc  *= mat3( 0.4124, 0.3576, 0.1805,\n          \t\t0.2126, 0.7152, 0.0722,\n                0.0193, 0.1192, 0.9505);\n\tvec3 w = normalize(vec3(1.3,1.33,1.1));\n\tc.x = pivot(c.x/w.x);\n\tc.y = pivot(c.y/w.y);\n\tc.z = pivot(c.z/w.z);\n\t\n\treturn vec3(max(0.,116.*c.y-16.), 500.*(c.x-c.y), 200.*(c.y-c.z));\n}\n\nfloat hash(in float n){return fract(sin(n)*43758.5453);}\n//Using CIE76 for color difference, mainly because it is much cheaper\nvec3 c64(in vec3 c, in vec2 p)\n{\n    c = clamp(c,.0,1.);\n    \n    vec3 hsv = rgb2lab(c);\n    float d = 100000.;\n    float d2 = 100000.;\n    vec3 c2 = vec3(0);\n    for(int i=0;i<16;i++)\n    {\n        vec3 ch = rgb2lab(pal[i]);\n        float cd = distance(hsv,ch);\n        if (cd < d)\n        {\n            d2 = d;\n            c2 = c;\n            d = cd;\n            c = pal[i];\n        }\n        else if(cd < d2)\n        {\n            d2 = cd;\n            c2 = pal[i];\n        }\n    }\n    \n    const float sclx = 320.;\n    const float scly = 200.;\n    float id = floor(p.x*sclx)*1.1+floor(p.y*scly)*2.;\n    float px = mod(floor(p.x*sclx)+floor(p.y*scly),2.);\n#ifdef AUTO_DITHER\n    float rn = hash(id);\n    if (rn < smoothstep(d2*0.96, d2*1., d*1.01) && (px ==0.))c=c2;\n#endif\n    return pow(abs(c),vec3(1.136));  //correct gamma\n}\n\nfloat inverseLerp(float v, float minValue, float maxValue) {\n  return (v - minValue) / (maxValue - minValue);\n}\n\nfloat remap(float v, float inMin, float inMax, float outMin, float outMax) {\n  float t = inverseLerp(v, inMin, inMax);\n  return mix(outMin, outMax, t);\n}\n\nvec3 vignette(vec2 uv) {\n  float distFromCenter = length(abs(uv));\n\n  float vignette = 1.0 - distFromCenter;\n  vignette = smoothstep(0.0, 0.7, vignette);\n  vignette = remap(vignette, 0.0, 1.0, 0.3, 1.0);\n\n  return vec3(vignette);\n\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n/*\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}*/\nfloat noise(vec2 st){\n    return fract(sin(dot(vec2(12.23,74.343),st))*43254.);  \n}\n\n#define pi acos(-1.)\nfloat noise2D(vec2 st){\n  \n  //id,fract\n  vec2 id =floor(st);\n  vec2 f = fract(st);\n  \n  //nachbarn\n  float a = noise(id);\n  float b = noise(id + vec2(1.,0.));\n  float c = noise(id + vec2(0.,1.));\n  float d = noise(id + vec2(1.));\n  \n  \n  //f\n  f = smoothstep(0.,1.,f);\n  \n  //mix\n  float ab = mix(a,b,f.x);\n  float cd = mix(c,d,f.x);\n  return mix(ab,cd,f.y);\n}\n\nmat2 rot45 = mat2(0.707,-0.707,0.707,0.707);\n\nmat2 rot(float a){\n  float s = sin(a); float c = cos(a);\n  return mat2(c,-s,s,c);\n}\nfloat fbm(vec2 st, float N, float rt,float time){\n    st*=3.;\n \n  float s = .5;\n  float ret = 0.;\n  for(float i = 0.; i < N; i++){\n     \n      ret += noise2D(st)*s; st *= 2.9; s/=2.; st *= rot((pi*(i+1.)/N)+rt*8.);\n      st.x += time/10.;\n  }\n  return ret;\n \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    setpal();\n    //C64 native resolution (320x200)\n    vec2 p = fragCoord.xy / iResolution.xy;\n    vec2 bp = p;\n    \n    float time = remap(sin(chillTime)*3.*cos(chillTime),-1.,1.,10., 70.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv2 = fragCoord/iResolution.xy;\n\n    vec2 position = - 1.0 + 2.0 * uv2;\n    position.x +=sin(time)*0.5;\n\n    \n    //space odyssey final scene\n    //position*=sin(time)/30.*0.5+0.5 * 30.;\n    \n    float a = atan( position.y, position.x );\n\tfloat r = sqrt( dot( position, position ) );\n\n\n    vec2 uv;\n\tuv.x = cos( a ) / r;\n\tuv.y = sin( a ) / r;\n\tuv /= 5.0;\n\tuv += time/4. ;\n    \n\t/*vec2 uv;\n\tuv.x = cos( a ) / r;\n\tuv.y = sin( a ) / r;\n\tuv /= 1.025+sin(time/6.)/6.;\n    uv*=6.5;*/\n\t//uv += time/30.;\n    \n    // fbm it\n    uv*=rot(sin(fbm(uv,10.,sin(time/4000.),time)));\n    \n    // more granularity\n    uv=uv*rot(time/4.);    \n    \n    float red = abs( sin( uv.x * uv.y + time / 5.0) );\n\tfloat green = abs( sin( uv.x * uv.y + time / 4.0 ) );\n\tfloat blue = abs( sin( uv.x * uv.y + time /3.0) );\n\tfragColor = vec4( red, green, blue, 1.0 );\n    \n    // trip clouds\n    fragColor.xyz = 0.5 + 0.5*cos(time+uv.xyx+vec3(0,2,4));\n    //clamp(0.5,0.0,1.0);\n    float factor = cos(uv.x+uv.y/4.)*0.5+0.5;\n\n    fragColor.xyz = mix(0.5 + 0.5*cos(time+uv.xyx+vec3(0,2,4)),fragColor.xyz, factor);\n    //vec3 result = clamp(texCol0.rgb - Density*(texCol1.rgb), 0.0, 1.0);\n    // flashes?\n    \n    vec3 hsvCol = rgb2hsv(fragColor.xyz);\n    //hsvCol.r = (sin(time/3.)*0.5+0.5);\n    #if AMIGA_COLOR == 1\n    hsvCol.g += 0.618; // saturation\n    hsvCol.b -= .1; // brightness\n    #endif\n\n    #if C64_COLOR == 1\n    hsvCol.g -= 0.5; // saturation\n    hsvCol.b += .1; // brightness\n\n    #endif\n    fragColor.xyz= hsv2rgb(hsvCol);\n    \n    \n    #if AMIGA_COLOR == 1\n    // Simulate Amiga's color palette containing no less than 4096 colors (RGB444)\n    fragColor.r = ceil(fragColor.r * 255.0 / 16.0) * 16.0 / 256.0;\n    fragColor.g = ceil(fragColor.g * 255.0 / 16.0) * 16.0 / 256.0;\n    fragColor.b = ceil(fragColor.b * 255.0 / 16.0) * 16.0 / 256.0;\n    #endif\n    \n    #if C64_COLOR == 1\n    //vec2 p = fragCoord.xy / iResolution.xy;\n    vec3 col = fx1(uv); \n    //vec2 bp = p;\n    fragColor.xyz = c64(fragColor.xyz,uv);\n    #endif\n    \n    // create a circle mask\n    //vec3 mask = vignette(uv*0.5);\n\n    // apply the mask to the fragment color\n    //fragColor.xyz+=vec3(mask);\n    //gl_FragColor = vec4(vec3(mask), 1.0);\n    \n    \n\n}","name":"Image","description":"","type":"image"}]}