{"ver":"0.1","info":{"id":"lddXRr","date":"1457474918","viewed":781,"name":"iq's school of terrain","username":"revers","description":"This shader is based on iq's brilliant [url=https://www.shadertoy.com/view/MdX3Rr]Elevated[/url], but I've used my own terrain heightmap (without derivatives), added water and own version of clouds. I've also tried to use own texture patterns. ","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Created by Kamil Kolaczynski (revers) - 2016\n *\n * Licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * This shader is based on iq's brilliant \"Elevated\" (https://www.shadertoy.com/view/MdX3Rr), \n * but I've used my own terrain heightmap (without derivatives), added water and own version of clouds.\n * I've also tried to use own texture patterns. \n * The rest of code is created by iq. Notably: hash and noise functions, raymarching, great outdoors lighting\n * (see also https://iquilezles.org/articles/outdoorslighting )\n * \n * It is great pleasure to learn from the best. Thanks for sharing your code, iq!\n * \n * The shader was created and exported from Synthclipse (http://synthclipse.sourceforge.net/)\n */\n\nconst vec3 LightDir = vec3(0.15037532, -0.31434754, -0.93732226);\nconst float MarchDumping = 0.39999998;\nconst float Far = 864.20496;\nconst int MaxSteps = 156;\nconst vec2 PulseSize = vec2(431.0138, 311.53772);\nconst float PulseHeight = 111.24439;\nconst float PulseProbability = 0.6;\nconst float MaxTerrainMul = 60.88;\nconst float MinTerrainMul = 0.0;\nconst float TerrainPower = 0.85950005;\nconst float TerrainHeightMul = 1.838;\nconst float WaterLevel = -9.119999;\nconst float WaterWaveHeight = 0.24681002;\nconst float WaterMaxVisibleDepth = 12.8991;\nconst vec3 WaterColor = vec3(0.007843138, 0.0627451, 0.09019608);\nconst float NormalFactor = 0.399;\n\n#define TIME_SHIFT 30.0\n\n#define M_NONE -1.0\n#define M_TERRAIN 1.0\n#define M_WATER 3.0\n\nvec3 lig = vec3(0.0, -1.0, 0.0);\nfloat TerrainParam = 0.0;\n\nfloat hash(vec2 n) {\n\treturn fract(sin(dot(n, vec2(1.0, 113.0))) * 43758.5453123);\n}\n\n/**\n * From \"Hash-without-Sine\" by Dave Hoskins\n * https://www.shadertoy.com/view/4djSRW\n */\nvec2 hash22(vec2 p) {\n\tp = fract(p * vec2(5.3983, 5.4427));\n\tp += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\nfloat noise(vec2 p) {\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n\tvec2 a = vec2(0.0, 0.0);\n\tvec2 b = vec2(1.0, 0.0);\n\tvec2 c = vec2(0.0, 1.0);\n\tvec2 d = vec2(1.0, 1.0);\n\n\tfloat n0 = hash(i + a);\n\tfloat n1 = hash(i + b);\n\tfloat n2 = hash(i + c);\n\tfloat n3 = hash(i + d);\n\n\tfloat ix0 = mix(n0, n1, u.x);\n\tfloat ix1 = mix(n2, n3, u.x);\n\n\treturn mix(ix0, ix1, u.y);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n\treturn a.x < b.x ? a : b;\n}\n\n/**\n * https://iquilezles.org/articles/functions\n */\nfloat cubicPulse(float w, float x) {\n\tx = abs(x);\n\tif (x > w)\n\t\treturn 0.0;\n\tx /= w;\n\treturn 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\nfloat pulse(vec2 p) {\n\tvec2 q = mod(p, 2.0 * PulseSize) - PulseSize;\n\tvec2 id = floor(p / (2.0 * PulseSize));\n\n\tvec2 r2 = hash22(id);\n\tfloat r = step(PulseProbability, r2.x) * step(PulseProbability, r2.y);\n\n\tfloat h = cubicPulse(PulseSize.x, q.x) * cubicPulse(PulseSize.y, q.y) * PulseHeight;\n\treturn mix(h, 0.0, r);\n}\n\nfloat fbmL(vec2 p, float baseAmplitude) {\n\tfloat f = 0.0;\n\tfloat a = baseAmplitude;\n\tfor (int i = 0; i < 2; i++) {\n\t\tf += a * noise(p);\n\t\tp *= 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn f;\n}\n\nfloat fbmM(vec2 p, float baseAmplitude) {\n\tfloat f = 0.0;\n\tfloat a = baseAmplitude;\n\tfor (int i = 0; i < 4; i++) {\n\t\tf += a * noise(p);\n\t\tp *= 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn f;\n}\n\nfloat fbmH(vec2 p, float baseAmplitude) {\n\tfloat f = 0.0;\n\tfloat a = baseAmplitude;\n\tfor (int i = 0; i < 7; i++) {\n\t\tf += a * noise(p);\n\t\tp *= 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn f;\n}\n\nfloat hole(vec2 p) {\n\tfloat f = noise(p);\n\tp *= 2.01;\n\tf += 0.5 * noise(p);\n\tp *= 2.02;\n\tf += 0.25 * noise(p);\n\tp *= 2.00;\n\tf += 0.125 * noise(p);\n\n\treturn f;\n}\n\nfloat terrainL(vec2 p) {\n\tvec2 g = vec2(0.01, 0.012);\n\tvec2 q = p * g;\n\n\tfloat a = 0.5;\n\tfloat f0 = noise(q);\n\ta *= 0.5;\n\tq *= 2.0;\n\n\tfloat f = fbmL(q, a);\n\tfloat t = smoothstep(0.5, 1.0, TerrainParam);\n\tf = pow(f, TerrainPower + t * 2.0);\n\n\tfloat k = smoothstep(TerrainParam, 1.0, f0);\n\tfloat res = mix(f * MinTerrainMul, f * MaxTerrainMul, k) * TerrainHeightMul;\n\n\tfloat m = smoothstep(0.0, 0.4, k);\n\tres = mix(res - hole(q) * 12.0, res, m);\n\n\tres += pulse(p) * fbmM(p * 0.01 + 452.15, 0.5);\n\treturn res;\n}\n\nfloat terrainM(vec2 p) {\n\tvec2 g = vec2(0.01, 0.012);\n\tvec2 q = p * g;\n\n\tfloat a = 0.5;\n\tfloat f0 = noise(q);\n\ta *= 0.5;\n\tq *= 2.0;\n\n\tfloat f = fbmM(q, a);\n\tfloat t = smoothstep(0.5, 1.0, TerrainParam);\n\tf = pow(f, TerrainPower + t * 2.0);\n\n\tfloat k = smoothstep(TerrainParam, 1.0, f0);\n\tfloat res = mix(f * MinTerrainMul, f * MaxTerrainMul, k) * TerrainHeightMul;\n\n\tfloat m = smoothstep(0.0, 0.4, k);\n\tres = mix(res - hole(q) * 12.0, res, m);\n\n\tres += pulse(p) * fbmM(p * 0.01 + 452.15, 0.5);\n\treturn res;\n}\n\nfloat terrainH(vec2 p) {\n\tvec2 g = vec2(0.01, 0.012);\n\tvec2 q = p * g;\n\n\tfloat a = 0.5;\n\tfloat f0 = noise(q);\n\ta *= 0.5;\n\tq *= 2.0;\n\n\tfloat f = fbmH(q, a);\n\tfloat t = smoothstep(0.5, 1.0, TerrainParam);\n\tf = pow(f, TerrainPower + t * 2.0);\n\n\tfloat k = smoothstep(TerrainParam, 1.0, f0);\n\tfloat res = mix(f * MinTerrainMul, f * MaxTerrainMul, k) * TerrainHeightMul;\n\n\tfloat m = smoothstep(0.0, 0.4, k);\n\tres = mix(res - hole(q) * 12.0, res, m);\n\n\tres += pulse(p) * fbmH(p * 0.01 + 333452.15, 0.5);\n\treturn res;\n}\n\nvec2 map(vec3 p) {\n\tvec2 res = vec2(p.y - terrainM(p.xz), M_TERRAIN);\n\treturn res;\n}\n\nvec2 castRay(vec3 ro, vec3 rd) {\n\tfloat tmin = 0.0;\n\tfloat tmax = Far;\n\n\tfloat precis = 0.002;\n\tfloat t = tmin;\n\tfloat m = -1.0;\n\n\tfor (int i = 0; i < MaxSteps; i++) {\n\t\tvec2 res = map(ro + rd * t);\n\t\tif (res.x < precis || t > tmax) {\n\t\t\tbreak;\n\t\t}\n\t\tt += res.x * MarchDumping;\n\t\tm = res.y;\n\t}\n\tif (t > tmax) {\n\t\tm = -1.0;\n\t}\n\treturn vec2(t, m);\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\n\tfor (int i = 0; i < 16; i++) {\n\t\tfloat h = map(ro + rd * t).x;\n\n\t\tres = min(res, 8.0 * h / t);\n\t\tt += clamp(h, 0.02, 0.10);\n\n\t\tif (h < 0.001 || t > tmax) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(vec3 pos) {\n\tfloat t = 0.1;\n\tvec2 eps = vec2(0.02 * t, 0.0);\n\n\treturn normalize(\n\t\t\tvec3(terrainH(pos.xz - eps.xy) - terrainH(pos.xz + eps.xy),\n\t\t\t\t\t2.0 * eps.x,\n\t\t\t\t\tterrainH(pos.xz - eps.yx) - terrainH(pos.xz + eps.yx)));\n}\n\n#define lodbias -100.0\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n) {\n\tvec4 x = texture(sam, p.yz, lodbias);\n\tvec4 y = texture(sam, p.zx, lodbias);\n\tvec4 z = texture(sam, p.xy, lodbias);\n\treturn x * abs(n.x) + y * abs(n.y) + z * abs(n.z);\n}\n\nfloat water(vec2 q) {\n\tfloat f;\n\tf = 0.5000 * noise(q);\n\tq = q * 2.02;\n\tf += 0.2500 * noise(q);\n\tq -= iTime * 0.3;\n\tq = q * 2.03;\n\tf += 0.1250 * noise(q);\n\tq -= iTime * 2.0;\n\tq = q * 2.01;\n\tf += 0.0625 * noise(q);\n\n\treturn f * WaterWaveHeight;\n}\n\nvec3 waterBottomColor(vec3 ro, vec3 rd, float t) {\n\tvec3 pos = ro + t * rd;\n\tvec3 nor = calcNormal(pos);\n\n\tvec3 bn = -1.0 + 2.0 * texcube(iChannel0, pos * 0.3, nor).xyz;\n\tnor = normalize(nor + 0.2 * bn);\n\n\tvec3 col = vec3(0.009);\n\tfloat hh = smoothstep(0.0, 10.0, pos.y);\n\n\tcol += 2.0 * vec3(0.722, 0.396, 0.165)\n\t\t\t* texcube(iChannel1, pos * vec3(0.1, 0.3, 0.1), nor).rgb;\n\n\tfloat dif = max(dot(nor, lig), 0.0);\n\treturn dif * col * 0.5;\n}\n\nfloat clouds(vec3 ro, vec3 rd) {\n\tvec2 uv = rd.xz / rd.y;\n\tuv *= 70.0;\n\n\tuv *= vec2(3.0, 3.0) * 0.005;\n\tvec2 st = uv;\n\n\tuv.x += iTime * 0.2;\n\n\tfloat f = 0.5 * noise(uv);\n\tuv *= 2.04;\n\tf += 0.25 * noise(uv);\n\tuv *= 2.01;\n\tf += 0.125 * noise(uv);\n\tfloat res = f;\n\tres = smoothstep(0.4, 1.0, res);\n\n\tst += vec2(12.0, 34.5);\n\tst.x += iTime * 0.3;\n\tfloat g = 0.5 * noise(st);\n\tst *= 2.00;\n\tg += 0.25 * noise(st);\n\tst *= 2.03;\n\tg += 0.125 * noise(st);\n\tst *= 2.04;\n\tg += 0.0625 * noise(st);\n\n\tres += 0.5 * smoothstep(0.5, 0.9, g);\n\n\treturn res * 0.8;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n\tfloat sundot = max(0.0, dot(rd, lig));\n\tvec3 col = vec3(0.396, 0.678, 0.878) * (0.9 - 0.9 * rd.y) * 1.5;\n\tcol += pow(sundot, 120.0) * vec3(1.0, 0.937, 0.71) * 0.75;\n\n\tcol = mix(col, vec3(2.0), clouds(ro, rd) * rd.y);\n\treturn col;\n}\n\n#define OFFSET 10.0\n#define GROUND_LEVEL_MIN (-20.0 + OFFSET)\n#define GROUND_LEVEL_MAX (-5.0 + OFFSET)\n\n#define GRASS_LEVEL_MIN (-5.0 + OFFSET)\n#define GRASS_LEVEL_MAX (25.0 + OFFSET)\n\n#define SNOW_LEVEL_MIN (20.0 + OFFSET)\n#define SNOW_LEVEL_MAX (60.0 + OFFSET)\n\nvec3 terrainColor(vec3 ro, vec3 rd, vec3 pos, vec3 nor) {\n\tvec3 col = vec3(0.009);\n\n\tvec3 rock = 1.0 * vec3(0.5)\n\t\t\t* texcube(iChannel1, pos * vec3(0.1, 0.4, 0.1) * 0.2, nor).rgb;\n\tfloat rockFactor = (1.0 - nor.y);\n\tcol += mix(rock, vec3(0.01), rockFactor);\n\n\tfloat r = texture(iChannel0, pos.xz * 0.1).r;\n\n\tvec3 ground = 0.1 * vec3(0.7, 0.4, 0.2);\n\tfloat k = texture(iChannel0, pos.xz * 0.0005).r * 10.0;\n\tfloat groundFactor = (1.0 - smoothstep(GROUND_LEVEL_MIN, GROUND_LEVEL_MAX, pos.y - k));\n\tcol = mix(col, ground, groundFactor);\n\n\tvec3 grass = 0.4 * mix(vec3(0.04, 0.3, 0.0), vec3(0.0, 0.1, 0.0),\n\t\t\tsmoothstep(0.0, 0.5, texcube(iChannel2, pos * 0.04 + r, nor).r));\n\tfloat grassFactor = (0.6 + 0.4 * r) * groundFactor;\n\tcol = mix(col, grass, grassFactor);\n\n\tgrass = vec3(0.02, 0.06, 0.0);\n\tgrassFactor = smoothstep(NormalFactor, 1.0, nor.y)\n\t\t\t* (1.0 - smoothstep(GRASS_LEVEL_MIN, GRASS_LEVEL_MAX, pos.y))\n\t\t\t* (1.0 - groundFactor);\n\tcol = mix(col, grass, grassFactor);\n\n\tvec3 snow = vec3(1.0);\n\tfloat snowFactor = smoothstep(SNOW_LEVEL_MIN, SNOW_LEVEL_MAX, pos.y)\n\t\t\t* smoothstep(0.1, 1.0, nor.y);\n\tcol = mix(col, snow, snowFactor);\n\n\treturn col;\n}\n\nvec3 doLighting(vec3 rd, vec3 pos, vec3 nor) {\n\tvec3 ref = reflect(rd, nor);\n\n\tfloat amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n\tfloat dif = clamp(dot(nor, lig), 0.0, 1.0);\n\tfloat bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0,\n\t\t\t1.0) * clamp(1.0 - pos.y, 0.0, 1.0);\n\tfloat dom = smoothstep(-0.1, 0.1, ref.y);\n\tfloat fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n\tfloat spe = pow(clamp(dot(ref, lig), 0.0, 1.0), 16.0);\n\n\tdif *= softshadow(pos, lig, 0.02, 2.5);\n\tdom *= softshadow(pos, ref, 0.02, 2.5);\n\n\tvec3 brdf = vec3(0.0);\n\tbrdf += 1.20 * dif * vec3(1.00, 0.90, 0.60);\n\tbrdf += 1.20 * spe * vec3(1.00, 0.90, 0.60) * dif;\n\tbrdf += 0.30 * amb * vec3(0.50, 0.70, 1.00);\n\tbrdf += 0.40 * dom * vec3(0.50, 0.70, 1.00);\n\tbrdf += 0.30 * bac * vec3(0.25, 0.25, 0.25);\n\tbrdf += 0.20 * fre * vec3(1.00, 1.00, 1.00);\n\tbrdf += 0.02;\n\n\treturn brdf;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tvec3 col = vec3(0.0);\n\n\tvec2 res = castRay(ro, rd);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\n\tfloat wt = (WaterLevel - ro.y) / rd.y;\n\n\tbool isWater = false;\n\tfloat waterBlendFactor = 1.0;\n\tvec3 bottomColor = vec3(0.0);\n\n\tif (wt > 0.0 && wt < t) {\n\t\t// water\n\t\tfloat k = (t - wt) / WaterMaxVisibleDepth;\n\t\twaterBlendFactor = min(k * k, 1.0);\n\t\tvec3 pos = ro + wt * rd;\n\n\t\tvec2 e = vec2(wt * 0.05, 0.0);\n\t\tvec2 p = pos.xz * 2.0;\n\t\tfloat x0 = water(p);\n\t\tvec2 grad = vec2(water(p + e.xy) - x0,\n\t\t\t\t\t\t water(p + e.yx) - x0) / e.x;\n\n\t\tvec3 nor = normalize(vec3(grad.x, 1.0, grad.y));\n\t\tbottomColor = waterBottomColor(ro, rd, t);\n\n\t\trd = reflect(rd, nor);\n\t\tro = pos + rd * 0.2;\n\n\t\tres = castRay(ro, rd);\n\t\tt = res.x;\n\t\tm = res.y;\n\n\t\tisWater = true;\n\t}\n\n\tif (m > M_NONE) {\n\t\tvec3 pos = ro + t * rd;\n\t\tvec3 nor = calcNormal(pos);\n\n\t\tcol = terrainColor(ro, rd, pos, nor);\n\t\tvec3 brdf = doLighting(rd, pos, nor);\n\n\t\tcol = col * brdf;\n\n\t\tif (isWater) {\n\t\t\tcol += bottomColor * (1.0 - waterBlendFactor);\n\t\t\tcol += WaterColor * 0.5;\n\t\t}\n\t\t// fog\n\t\tcol = mix(col, vec3(0.5), 1.0 - exp(-0.000001 * t * t));\n\t} else {\n\t\tcol = skyColor(ro, rd);\n\t\tif (isWater) {\n\t\t\tcol += bottomColor * (1.0 - waterBlendFactor);\n\t\t\tcol += WaterColor * 0.1;\n\n\t\t}\n\t}\n\treturn vec3(clamp(col, 0.0, 1.0));\n}\n\nvec3 camPath(float time) {\n\ttime *= 2.0;\n\treturn 1100.0 * vec3(cos(0.0 + 0.23 * time), 0.0, cos(1.5 + 0.21 * time));\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    lig = normalize(-LightDir);\n    TerrainParam = (sin(iTime * 0.2 + TIME_SHIFT) * 0.5 + 0.5);\n    \n    vec2 q = fragCoord / iResolution.xy;\n\tvec2 xy = -1.0 + 2.0 * q;\n\tvec2 s = xy * vec2(iResolution.x / iResolution.y, 1.0);\n\n\tfloat time = iTime * 0.15 + 0.3 + TIME_SHIFT + 4.0 * iMouse.x / iResolution.x;\n\n\tvec3 ro = camPath(time);\n\tvec3 ta = camPath(time + 3.0);\n\tro.y = terrainL(ro.xz) + 11.0;\n\tta.y = ro.y - 20.0;\n\tfloat cameraRoll = 0.2 * cos(0.1 * time);\n\n\t// camera2world transform\n\tmat3 cam = setCamera(ro, ta, cameraRoll);\n\n\t// camera ray\n\tvec3 rd = cam * normalize(vec3(s.xy, 1.5));\n\tvec3 col = render(ro, rd);\n\n    col = pow(col, vec3(0.4545));\n    col += 0.07;\n    // vignette\n\t//col *= 0.25 + 0.75 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.07);\n\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}