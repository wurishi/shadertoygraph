{"ver":"0.1","info":{"id":"Wltczr","date":"1608387551","viewed":89,"name":"Random sketch .01","username":"julianlumia","description":"I started out testing out some ideas to make water but then it turned into this :p","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["sea","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 90\n#define MAX_DIST 100.\n#define SURF_DIST .0001\n#define PI 3.14159\n\nfloat smin (float a, float b, float r)\n{\n float h = clamp(.5+.5*(b-a)/r,0.,1.);\n return mix(b, a, h) - r*h*(1.-h);\n}\n\nvec3 spherepos;\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n p = abs(p);\n return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\n\nfloat sdSphere(vec3 p, float s)\n{\n return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n p = abs(p)-s;\n return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat g4 = 0.;\nfloat T = 0.;\n\nvec2 GetDist(vec3 p) {\n float the;\n\n vec3 p7 = p;\n\n spherepos =  vec3(-1.5,1.,-1.);\n vec3 p5 = p;\n the = (sin((p5.z*5.)+iTime*.5)*.01);\n p5.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n the = (sin((p5.y*5.)+iTime*.25)*.01);\n p5.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n the = (sin((p5.z*5.)+iTime*.5)*.01);\n p5.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n the = (sin((p5.y*5.)+iTime*.5)*.03);\n p5.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n p5 -=vec3(.8,1.0,2.9);\n the = iTime*.15;\n p5.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n\n vec2 box = vec2(sdBox(p5, vec3(.015,1.5,1.5)),9);\n \n float h = texture(iChannel1, p.xy).r;\n  box.x += h; \n \n vec2 two = vec2(((dot(sin(p.zxy)*.1, cos(p.zxy*4.+iTime)))),2.);\n box.x = mix(box.x,two.x,.1);\n \n\n the =  floor(iTime*.5)+smoothstep(0.,.4,fract(iTime*.5));\n\n p7-=vec3(1.,1.01,2.5);\n  the = iTime*0.25;\n  p7.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n\n the = iTime*0.5;\n the =  floor(iTime*.5)+smoothstep(0.,.4,fract(iTime*.5));\n p7.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n the =  floor(iTime*.5)+smoothstep(0.,.4,fract(iTime*.5));\n p7.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n vec2 dbox9 =vec2( sdOctahedron( p7,1.),5);   \n\n g4 +=1./(.005+pow(abs(dbox9.x),1.5));\n vec2 ebox = box;\n ebox = condmin(ebox,dbox9);\n return ebox ;\n}\n\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\nvec2 h, t=vec2( 0.);   \nfor (int i=0; i<MAX_STEPS; i++) \n{   \nh = GetDist(ro + t.x * rd);\nif(h.x<SURF_DIST*(1.+t.x)||abs(t.x)>MAX_DIST) break;\nt.x+=h.x *1.;\nt.y=h.y;\n}\nif(t.x>MAX_DIST) \nt.x=0.;\nt.x +=h.x*1.;\nreturn t;\n}\nfloat marchCount;\n\n\nfloat traceRef(vec3 o, vec3 r){\n    \n float t = 0.0;\n marchCount = 0.0;\n float dO = 0.;  \n for (int i = 0; i <50; i++)\n {\n  vec3 p = o + r * t;   \n  float d = GetDist (p).x;\n  if(d<.0001 || abs(t)>10.) break;\n  t += d * 1.;\n  marchCount+= 1./d*1.;\n }    \n return t;\n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n vec3 f = normalize(l-p),\n r = normalize(cross(vec3(0,1,0), f)),\n u = cross(f,r),\n c = p+f*z,\n i = c + uv.x*r + uv.y*u,\n d = normalize(i-p);\n return d;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n vec3 cw = normalize(ta-ro);\n vec3 cp = vec3(sin(cr), cos(cr),0.0);\n vec3 cu = normalize( cross(cw,cp) );\n vec3 cv = cross(cu,cw);\n return mat3( cu, cv, cw );\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(.00035, -.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\n\n// from: XT95\n//https://www.shadertoy.com/view/4sdGWN\n\nconst float PI2 = 3.14159265359;\n#define HASHSCALE1 .1031\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n\tconst int nbIte = 32;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal\n        \t\t\t\t\t\t\t\t\t\t\t\t\t    // for self occlusion problems!\n        \n        ao += (l - max(GetDist( p + rd ),0.).x) / maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n//-----------------\n\n\n\nfloat shadow(vec3 r0, vec3 rd, float maxDist)\n{\n    float d = .001;\n    float shadow = .4;\n    while(d < maxDist)\n    {\n        float t = GetDist(r0 + d * rd).x;\n        if(t < 0.01) return 0.0;\n        d += t;\n        shadow = min(shadow,5.0 * (t / d));\n    }\n    return shadow;\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(spherepos);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*1., l).x;\n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv =( 2. * fragCoord.xy - iResolution.xy ) / iResolution.y;\n\n vec3 eye = 1.0*vec3(-0.,3,5.5);   \n float the =(eye.z*.5);\n vec3 hoek = vec3(1,0.,1);  \n the = (T*.2)-2.5;\n mat3 camera = setCamera( eye, hoek,4.7);\n float fov = 1.5;\n vec3 dir = camera * normalize(vec3(uv, fov));\n vec3 focalPoint = eye + (dir );\n vec3 shiftedRayOrigin = eye;\n vec3 shiftedRay = (focalPoint - shiftedRayOrigin);\n vec3 shiftedRay2 = (focalPoint - shiftedRayOrigin);\n vec2 d = RayMarch(shiftedRayOrigin, shiftedRay);\n float t =d.x *1.;\n vec3  shiftedRayOrigin2 = shiftedRayOrigin;\n vec3 col;\n vec3 baseColor = vec3(0.,0.,0.);\n float a;\n if(t<MAX_DIST) {\n  shiftedRayOrigin2 += shiftedRay2 * t;\n  vec3 sn = GetNormal(shiftedRayOrigin);\n  vec3 sn2 = GetNormal(shiftedRayOrigin2);\n  shiftedRay2 = refract(shiftedRay2, sn2,.85);\n  if(d.y==9.) traceRef(shiftedRayOrigin2 +  shiftedRay2*.4, shiftedRay2);\n  if(d.y==9.) baseColor = vec3(0.0,0.2,0.4);\n\n  vec3 p = shiftedRayOrigin + shiftedRay * t;\n  vec3 n= GetNormal(p.xyz);\n  float accum = 0.0;\n  vec3 lp =  vec3(spherepos);\n  const int numIter =4;\n  vec3 vD = shiftedRay;\n  vD = normalize(vD);\n  float stepSize = length(p - shiftedRayOrigin) / float(numIter);\n  vec3 vO = shiftedRayOrigin + stepSize * vD;\n  for(int i = 0; i  < numIter; ++i)\n   {\n \tvec3 ld = normalize(lp - vO);\n    float shad = shadow(vO, ld,5.);\n\tfloat d = dot(vO, vO);\n\taccum += (5./ d ) * shad;\n\tvO += stepSize * vD;\n   }\n  col += baseColor;\n  col += accum*vec3(1.,2.,1.)*1.;\n  float a = ambientOcclusion(p,n, .12,2.5);\n  col +=g4*vec3(0.003)*vec3(.5,.4,.0);    \n  col *= GetLight(p);\n col *= (a+.25);   \n  shiftedRayOrigin += shiftedRay * t;\n  col *= GetLight(shiftedRayOrigin)*4.;\n  col += marchCount * vec3(.003) * 1.;\n }\n vec3 sky = vec3(uv.y+1.,.6,.5);\n col = mix(sky, col, 1./(d.x*d.x/1./1.+.0)); \n col=pow(col, vec3(1.5));\n fragColor = vec4(col,t);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat noise( vec2 v ) {\n  return fract( sin ( dot( v , vec2( 78.123 , 36.1226 ) ) ) * 64.314 );\n}\n\nfloat pnoise( vec2 uv ) {\n\n  vec2 a = fract( uv );\n  a = a * a * ( 3. - 2. * a );\n\n  //dirc\n  vec2 uv2 = floor( uv );\n  float w0 = noise ( uv2 ) ;\n  float w1 = noise ( uv2 + vec2( 1. , 0. ) ) ;\n  float w2 = noise ( uv2 + vec2( 0. , 1. ) ) ;\n  float w3 = noise ( uv2 + vec2( 1. , 1. ) ) ;\n\n  float g0 = dot( vec2(w0) , ( a - vec2(0.,0.) ) ) ;\n  float g1 = dot( vec2(w1) , ( a - vec2(1.,0.) ) ) ;\n  float g2 = dot( vec2(w2) , ( a - vec2(0.,1.) ) ) ;\n  float g3 = dot( vec2(w3) , ( a - vec2(1.,1.) ) ) ;\n\n  float h0 = mix( g0 , g1 , a.x );\n  float h1 = mix( g2 , g3 , a.x );\n  float h2 = mix( h0 , h1 , a.y );\n\n  float h = h2 + .1;\n\n  return h;\n}\n\nfloat fbm( vec2 uv ) {\n  float a = pnoise( uv + iTime * .4 );\n  a += pnoise( uv * 2. ) * 1.5 ;\n  a += pnoise( uv * 2. ) * 0.25 ;\n  a += pnoise( uv * 4. ) * 0.125 ;\n  a += pnoise( uv * 16. ) * 0.0625 ;\n  a += pnoise( uv * 32. ) * 0.03125 ;\n  return a;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 6.;\n    \n    float E = .001;\n    float l = fbm(uv + vec2( -E , 0. ) );\n    float r = fbm(uv + vec2(  E , 0. ) );\n    float u = fbm(uv + vec2( 0. , -E ) );\n    float d = fbm(uv + vec2( 0. ,  E ) );\n    float h = fbm(uv);\n    fragColor = vec4( r - l , h , d - u , 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}