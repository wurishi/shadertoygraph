{"ver":"0.1","info":{"id":"MXfXDB","date":"1709992361","viewed":100,"name":"Mysterical Field","username":"andreibazzaev","description":"Small relaxing mysterious shader I made over evening","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","grass","sky","field"],"hasliked":0,"parentid":"Mf2Szd","parentname":"Learn Ray Marching P4"},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nstruct Camera{\n    float fov;\n    vec3 pos;\n};\n\nstruct Ray{\n    vec3 o;\n    vec3 d;\n};\n\nconst int MaxSteps = 255;\nconst float MinDist = 0.f;\nconst float MaxDist = 100.f;\nconst float epsilon = 0.0001f;\nvec3 InterId = vec3(0.f, 0.f, 0.f);\nvec3 FinalId = vec3(0.f, 0.f, 0.f);\nfloat GlowVal = 0.f;\nfloat WindMult = 0.1f;\n\nfloat GrassSDF(vec3 pos, vec3 id){\n    vec3 size = vec3(1.2, 1.2, 1.2);\n    float height = textureLod(iChannel0, vec2(id.x / 100.f, id.z / 45.f), 0.f).r * 3.0f;\n    mat4 testTrans = TranslateMatrix(RotateMatrix(vec2(3.1f, 3.14 * abs(sin(id.x * 122.f + id.z * 1003.5)))), vec3(sin(id.x * 13.f + id.z * 37.f) * 0.3f, height, sin(id.x * 137.f + id.z * 3.f)* 0.3f));\n    mat4 inverseTrans = inverse(testTrans);\n    \n    pos.y += sin((pos.x) * 3.f + 0.3) / 5.f * sin(iTime * clamp(WindMult, 1.f, 20.f) +id.x * 13.f + id.z * 37.f);\n    float sdf = RhombusSDF((inverseTrans * vec4(pos, 1.f)).xyz / size,  1.f + abs(sin(id.x * 13.f + id.z * 37.f)) * 0.5, 0.2) * min(size.x, min(size.y, size.z));\n   \n    return sdf;\n}\n\nfloat GetDistInfiniteSDF(vec3 pos, vec3 spacing, vec3 size){\n        size = abs(size - 1.f);\n        vec3 id = round(pos / spacing);\n        vec3 off = sign(pos - spacing * id);\n        \n        float d = 1e20;\n        \n        for(int w = 0; w < 2; w++)\n        for(int j = 0; j < 2; j++)\n        for(int i = 0; i < 2; i++)\n        {\n            vec3 rid = id + vec3(i,j, w)*off;\n            rid = clamp(rid,-size,size);\n            vec3 r = pos - spacing*rid;\n           if(GrassSDF(r,rid) < d){\n               d = GrassSDF(r,rid);\n               InterId = id;\n           }\n        }\n        return d;\n}\n\nfloat SceneSDF(vec3 pos){\n    vec3 size = vec3(0.8, 0.8, 0.8);\n    vec3 sizeBelow = vec3(2.8, 1.8, 2.8);\n    vec3 spherePos = pos + vec3(sin(iTime / 4.f) * 6.f, -5.f, 10.f + sin(iTime / 4.f) * 10.f + cos(iTime / 6.f) * 5.f);\n    float spSDF =  SphereSDF((spherePos / size) * min(size.x, min(size.y, size.z)));\n    float belowSDF =  SphereSDF((spherePos + vec3(0.f, 3.5f, 0.f)) / sizeBelow) * min(sizeBelow.x, min(sizeBelow.y, sizeBelow.z));\n    GlowVal += 0.1 / (0.1 + spSDF * spSDF);\n    \n     if(belowSDF < epsilon){\n         WindMult = 10.f ;\n        }\n    else{\n       WindMult = clamp(5.f / (belowSDF *belowSDF), 1.f, 5.f);\n        }\n   \n    return Union(spSDF, (GetDistInfiniteSDF(pos, vec3(1.f), vec3(100.f, 1.f, 100.f))));\n}\n\n// Ray Generation\nRay GetRay(Camera cam, vec2 fragCoord, vec2 resolution){\n    vec2 xy = fragCoord - resolution / 2.f;\n    float z = resolution.y / tan(radians(cam.fov) / 2.f);\n    Ray ray = Ray(cam.pos, normalize(vec3(xy, -z)));\n    return ray;\n}\n\nfloat GetShortestSceneDistID(Ray ray){\n    float depth = MinDist;\n    for (int i = 0; i < MaxSteps; i++){\n        vec3 ckeckPos = ray.o + ray.d * depth;\n        float dist = SceneSDF(ckeckPos);\n        if(dist < epsilon){\n            FinalId = InterId;\n            return depth;\n        }\n        else{\n            depth += dist;\n            if(depth >= MaxDist){\n                return MaxDist;\n            }\n        }\n    }\n    return MaxDist;\n}\n\nvec3 GetColor(Ray ray, vec2 coord){\n    float dist = GetShortestSceneDistID(ray);\n    \n    float skyY = 2.* coord.y / iResolution.y;\n    float skyX = 2.* coord.x / iResolution.x - 1.f; \n    // Miss\n    if (dist> MaxDist - epsilon){\n    //https://www.shadertoy.com/view/MlcGD7\n    return skyY > 0.85f ? (pow(vec4(.1, .7, .8, 1), vec4(4.*skyY - 3.5f))).xyz : (pow(vec4(.1, .7, .1, 1), vec4(4.f - 4.*skyY))).xyz * (1.f - abs(skyX * 0.75f));\n    }\n    // Hit\n    else{\n       vec3 randGrassCol = vec3(abs(sin(FinalId.x * 11.f)) * 0.2, abs(sin(FinalId.x * 17.f + FinalId.z * 13.f + 137.f))* 0.5 + 0.5, abs(sin(FinalId.z * 37.f)) * 0.3);\n       randGrassCol *= clamp(skyY, 0.f, 0.2) * 5.f * (1.f - abs(skyX * 0.75f));\n       return randGrassCol;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Camera cam = Camera(45.f, vec3(0.f, 4.f,10.f));\n    Ray ray = GetRay(cam, fragCoord, iResolution.xy);\n    fragColor = vec4(GetColor(ray, fragCoord), 1.f) + max(GlowVal, 0.f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// SDFs\n// --------------------------------------------\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat RhombusSDF(vec3 p, float sx, float sy)\n{\n    p = abs(p);\n    vec2 b = vec2(sx,sy);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y), p.y);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat SphereSDF(vec3 pos){\n    return length(pos) - 1.0f;\n}\n//---------------------------------------------------------\n// Transforms\nmat3 RotateMatrix(vec2 axis) {\n    // Normalize the axis of rotation\n    axis = normalize(axis);\n    \n    // Extract the components of the axis\n    float y = axis.x;\n    float z = axis.y;\n    \n    // Compute sine and cosine of the angle\n    float c = cos(1.f);\n    float s = sin(1.f);\n    \n    // Compute 1 - cos(angle)\n    float t = 1.0 - c;\n    \n    // Construct the rotation matrix\n    mat3 rotMat = mat3(\n        c, - s * z, s * y,\n        s * z, t * y * y + c, t * y * z,\n        - s * y, t * y * z, t * z * z + c\n    );\n    \n    // Multiply the original matrix by the rotation matrix\n    return rotMat;\n}\n\nmat4 TranslateMatrix(mat3 mat, vec3 translation) {\n    mat4 translateMat = mat4(mat);\n    translateMat[3] = vec4(translation.x, translation.y, translation.z, 1.0);\n    return translateMat;\n}\n\nfloat Union(float d1, float d2) {\n    return min(d1, d2);\n}\n","name":"Common","description":"","type":"common"}]}