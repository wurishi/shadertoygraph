{"ver":"0.1","info":{"id":"4ldyDn","date":"1533895082","viewed":438,"name":"[SH18] Lost humanity","username":"NuSan","description":"SDF is rendered in a pseudo volume texture to speed up raymarching. Toggle with USE_3D_VOLUME in Common\nBest viewed in fullscreen, as the added resolution improve the quality of the volume.\nI made an interactive SDF editor in Unity to shape the SDF.","likes":17,"published":1,"flags":32,"usePreview":1,"tags":["3d","human","sh18"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat mapdist(vec3 p, vec3 div) {\n \n    p=clamp((p/3.0)*0.5+0.5,0.0,0.999);\n    float idz1 = floor((p.z+0.0001)*div.x*div.y)/div.x;\n    vec2 uvz1 = vec2(fract(idz1),floor(idz1)/div.y);\n    vec2 uv1 = p.xy/div.xy+uvz1;\n    float idz2 = floor((p.z+0.0001)*div.x*div.y+1.0)/div.x;\n    vec2 uvz2 = vec2(fract(idz2),floor(idz2)/div.y);\n    vec2 uv2 = p.xy/div.xy+uvz2;\n    \n    float d1 = texture(iChannel0, uv1).r;\n    float d2 = texture(iChannel0, uv2).r;\n    \n    return mix(d1, d2, fract((p.z+0.0001)*div.x*div.y));\n}\n\nfloat mapmask(vec3 p, vec3 div) {\n    vec3 cp=clamp((p/3.0),-1.0,1.0)*3.0;\n    return clamp(length(p-cp)*100.0,0.0,1.0);\n}\n\nfloat background(vec3 p) {\n    p.z += 1.0;\n \tfloat p1 = pln(p + vec3(0.0,2.0,0.0), vec3(0.0,1.0,0.0));   \n    \n    vec3 rp = p;\n    rp.xz = rep(rp.xz, vec2(4.0));\n    rp.y += 1.0;\n    \n    float c1 = cyl(rp, 0.3, 5.0, 0.0);\n    c1 = min(c1,cyl(rp, 0.7, 0.2, 0.0));\n    c1 = min(c1,cyl(rp + vec3(0.0,-5.0,0.0), 0.7, 0.2, 0.0));\n    //c1 = min(c1, pln(p + vec3(0.0,-5.0,0.0), vec3(0.0,-1.0,0.0)));\n    \n    float c2 = cyl(p, 10.0, 20.0, 0.0);\n    float c3 = cyl(p+vec3(0.0,2.5,0.0), 2.0, 1.5, 0.0);\n    float b1 = box(p+vec3(0.0,2.0,0.0), vec3(1.0,1.0,5.0), 0.1);\n    c1 = max(c1,-c2);\n    c1 = min(c1,c3);\n    c1 = min(c1, b1);\n    \n    vec3 rp2 = p;\n    rp2.xz = rep(rp2.xz, vec2(2.0));\n    float b2 = box(rp2, vec3(0.7,10.0,0.7), 0.4);\n    b2 = smax(b2, p1-0.8, 0.3);\n    \n    c1 = min(c1, b2);\n    \n    return min(c1,p1);\n}\n\nfloat limit(vec3 p) {\n    return box(p-vec3(0.0,0.5,-0.5), vec3(1.5), 0.0);\n}\n\nfloat map2(vec3 p, vec3 div) {\n \n    #if USE_3D_VOLUME\n    \tfloat d = mapdist(p, div);\n    #else\n    \tfloat d = map(p, time);\n    #endif\n    \n    d=max(d, limit(p));\n    d=smin(d, background(p), 0.2);\n    return d;\n}\n\nfloat mapn(vec3 p, vec3 div) {\n    #if USE_3D_VOLUME_NORMAL\n    \tfloat d = map2(p, div);\n    #else\n    \tfloat d = map(p, time);\n    #endif\n    \n    d=max(d, limit(p));\n    d=smin(d, background(p), 0.2);\n    return d;\n}\n\t\nvec3 norm(vec3 p, vec3 div) {\n    #if USE_3D_VOLUME_NORMAL\n    \tvec2 off=vec2(0.033, 0.0);\n    #else\n    \tvec2 off=vec2(0.01, 0.0);\n    #endif\n    return normalize(vec3(mapn(p-off.xyy, div)-mapn(p+off.xyy, div),mapn(p-off.yxy, div)-mapn(p+off.yxy, div),mapn(p-off.yyx, div)-mapn(p+off.yyx, div)));\n}\n\n\nfloat ambient(vec3 p, vec3 n, vec3 div) {\n\n    float scale = 0.1;\n    float d = scale;\n    vec3 pos = p - n * d;\n\n    float fac = 1.0;\n\n    for( int i=0; i<5; ++i) {\n\n        float str = 3.0/float(1+i);\n        fac *= 1.0-clamp((d-map2(pos, div))*str,0.0,1.0);\n        pos -= n * scale;\n        d += scale;\n\n    }\n\n    return fac;\n}\n\nvec2 rnd2(vec2 uv) {\n    return fract(sin(uv*vec2(134.187,364.321)+uv.yx*vec2(472.514,287.214)+vec2(1.7412,0.8742))*vec2(15.7421,37.984)+vec2(0.4137,0.8749));\n}\n\nfloat rnd(vec2 uv) {\n    return fract(dot(sin(uv*vec2(134.187,364.321)+uv.yx*vec2(472.514,287.214)+vec2(1.7412,0.8742)),vec2(15.7421,37.984))+0.4137);\n}\n\nfloat rnd(float t) {\n  return fract(dot(sin(t*vec2(421.124,745.135)+vec2(1.743,2.971)),vec2(342.6418,241.2154))+0.41754);\n}\n\nfloat shadow(vec3 ro, vec3 rd, vec3 div, float rand) {\n    float md=1.0;\n    int steps=MAX_STEPS_SHADOWS;\n    float s=5.0/float(steps);\n    float t=0.01;//+rand*s;\n    for(int i=0; i<steps; ++i) {\n        float d=map2(ro+rd*t, div);\n        md=min(md,5.0*d/t);\n        if(d<-0.0) {\n            //md=0.0;\n            break;\n        } \n        t+=s;\n    }\n\n    return clamp(md,0.0,1.0);\n}\n\nfloat curve(float t, float s) {\n  float p=floor(t/s);\n  float f=fract(t/s);\n  f=pow(smoothstep(0.0,1.0,f),10.0);\n  return mix(rnd(p),rnd(p+1.0),f);\n}\n                                        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 div = getdiv(iResolution.xy);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float rand=rnd(uv);\n\n    float gtime = time;\n    gtime += (rand*0.5)*0.05; // motion blur\n   \tfloat t1=gtime*0.3;\n    float t2=gtime;\n    float s1 = curve(t2+354.0, 0.7);\n    float s2 = curve(t1, 0.9)*3.0-0.7;\n    float s3 = curve(t2, 0.5)*0.8;\n    float fov = 2.5;\n    if(iMouse.z>0.5) {\n        s1 = -iMouse.y/iResolution.y*2.0+1.0;\n        s2 = (iMouse.x/iResolution.x*2.0-0.5)*PI;\n        s3 = 0.0;\n    }\n    /*\n    float dof = 0.1;\n    s2 += (rand.x-0.5)*0.03*dof;\n    s3 += (rand.y-0.5)*0.3*dof;\n    */\n    float camd=6.0+s1*4.0;\n    vec3 s=vec3(cos(s2)*camd,1.5+s3,sin(s2)*camd);    \n    vec3 t=vec3(0.0,0.4,0.0);\n    vec3 cz=normalize(t-s);\n    vec3 cx=normalize(cross(cz, vec3(0,1,0)));\n    vec3 cy=normalize(cross(cz, cx));\n    vec3 r=normalize(uv.x*cx-uv.y*cy+cz*fov);\n    vec3 p=s;\n                     \n\tfloat dd=0.0;\n    for(int i=0; i<MAX_STEPS; ++i) {\n        if(dd>100.0) {\n            dd=10000.0;\n        \tbreak;   \n        }\n\t\tfloat d=map2(p, div);\n        if(d<0.001) {\n        \tbreak;   \n        }\n        p+=r*d;\n        dd+=d;\n    }\n    \n    vec3 n=norm(p, div);\n    vec3 light1=normalize(vec3(-1));\n    //float l1 = curve(t2+974.0, 0.7);\n    //light1.xz *= rot(l1*3.0);\n    //light1.yz *= rot(l1*1.0-1.0);\n    vec3 h=normalize(r+light1);\n    float ao = ambient(p, n, div);\n    \n\tfloat shad=shadow(p,-light1, div, rand) * ao;\n\tvec3 col=vec3(0);\n    \n    float lum = max(0.0,dot(light1,n));\n    float lumup = -n.y*0.5+0.5;\n    float fres = 1.0-max(0.0, dot(r,n));\n                     \n    col += vec3(0.8,0.9,0.7) * 0.4 * lum * shad;\n\n    col += pow(max(0.0, dot(n,h)),8.0) * lum * 0.5 * shad;\n\n    col += vec3(0.4,0.5,1.0) * 1.0 * lumup * (pow(fres,4.0) + 0.4) * ao * ao;\n    \n    col *= 10.0/max(10.0,dd);\n    \n    float atm = 0.5 * 0.1 / exp(-dd*0.07);\n    col += vec3(0.4,0.5,1.0) * atm;\n    col = mix(clamp(col,0.0,1.0), vec3(0.2,2.0,2.1), max(0.0, r.y));\n    \n    float vignet=length(uv*vec2(0.4,1.0))*0.8;\n    col *= 1.0-vignet*vignet*vignet;\n        \n    //col = mix(col, vec3(0.0,0.0,0.0), max(mapmask(p, div), clamp((-0.8-p.y)*3.0,0.0,1.0)));\n                     \n\t//col *= vec3(min(1.0,10.0/dd));\n    \n    //col = vec3(ao);\n    \n    /*vec3 backcol = mix(vec3(0.1,0.4,1.0), vec3(0.5,0.8,0.1), -r.y*0.5+0.5);\n    float t3 = time;\n    backcol.xy *= rot(t3*0.3);\n    backcol.yz *= rot(t3*0.5);\n    backcol.zx *= rot(t3*0.7);\n    backcol=abs(backcol);*/\n    //col += backcol*0.1/exp(-1.0*dd);\n        \n    col = pow(col, vec3(0.4545));\n    \n    #if VISUALIZE_3D_VOLUME\n    \tcol = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    #endif\n    //vec3 test=uvtomap(fragCoord/iResolution.xy, div);\n    //col = vec3(maptouv(test, div),0.0);\n    //col = vec3(rand);\n                     \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 div = getdiv(iResolution.xy);\n    vec3 p = uvtomap(uv, div);\n    \n    #if USE_3D_VOLUME\n    float d = map(p, time);\n    #else\n    float d = 0.0;\n    #endif\n    \n    fragColor = vec4(d,0,0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define MAX_STEPS 100\n#define MAX_STEPS_SHADOWS 20\n#define USE_3D_VOLUME 1\n#define USE_3D_VOLUME_NORMAL 0\n#define VISUALIZE_3D_VOLUME 0\n#define SIMPLE_HEAD 0\n\n#define time iTime\n#define PI 3.14159265\n\nfloat smin(float a, float b, float k) {\n    float h=clamp((a-b)/k*0.5+0.5,0.0,1.0);\n    return mix(a,b,h) - h*(1.0-h)*k;\n}\n\nfloat smax(float a, float b, float k) {\n    float h=clamp((b-a)/k*0.5+0.5,0.0,1.0);\n    return mix(a,b,h) + h*(1.0-h)*k;\n}\n\nfloat sph(vec3 p, float r) { return length(p)-r; }\nfloat cyl(vec3 p, float r1, float r2, float b) { vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r1,r2); return min(max(d.x,d.y),0.0) + length(max(d,0.0))-b; }\nfloat capsSimple(vec3 p, float r1, float r2) { p.y -= clamp(p.y,-r2,r2); return length(p)-r1; }\nfloat caps(vec3 p, vec3 a, vec3 b, float r) { vec3 pa = p-a; vec3 ba = b-a; float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0); return length(pa - ba*h) - r; }\nfloat conecaps(vec3 p, vec3 a, vec3 b, float r1, float r2) {\n\n    vec3 ba = b-a;\n    vec3 dir = ba;\n    vec3 pa = p-a;\n\n    float len2 = dot(dir,dir);\n    float len = sqrt(len2);\n    dir /= len;\n\n    float diff = (r1-r2);\n\n    float secproj = dot(pa,dir);\n    vec3 tp2 = a + dir*secproj;\n    float mm = length(tp2-p);\n\n    float extside = max(0.001,sqrt(len2-diff*diff));\n    float nn = mm*diff/extside;\n    float finalprog = (secproj-nn)/len;\n\n    finalprog = clamp(finalprog,0.0,1.0);\n\n    float dist = length(pa-ba*finalprog) - mix(r1,r2,finalprog);\n\n    return dist;\n}\nfloat box(vec3 p, vec3 s, float b) { vec3 ap = abs(p)-s; return min(max(ap.x,max(ap.y,ap.z)),0.0) + length(max(ap,0.0))-b; }\nfloat donut(vec3 p, float r1, float r2) { vec2 q = vec2(length(p.xz)-r1,p.y); return length(q)-r2; }\nfloat pln(vec3 p, vec3 n) { return dot(p,n); }\n\nvec3 mirror(vec3 p) { return vec3(abs(p.x), p.y, p.z); }\nvec3 rep(vec3 p, vec3 s) { return (fract(p/s-0.5)-0.5)*s; }\nvec2 rep(vec2 p, vec2 s) { return (fract(p/s-0.5)-0.5)*s; }\n\nmat2 rot(float a) { float ca=cos(a); float sa=sin(a); return mat2(ca,sa,-sa,ca); }\n\nfloat map(vec3 p, float t) {\n    float globalScale = 1.0;\n    p/=globalScale;\n    p+=vec3(0,0,0);\n    \n#if SIMPLE_HEAD\n    \n vec3 TPos_0=mirror(p-vec3(0, 0, 0));\n\n  float res = smin(smin(smin(smin(smin(smin(smin(conecaps(TPos_0, vec3(0, 0, 0), vec3(0, 0.8981191, -0.2021628), 0.65, 0.8194701),\n caps(TPos_0, vec3(0, 0.885, -0.359), vec3(0, 0.6657753, -0.8952476), 0.90), 0.3),\n sph(TPos_0-vec3(0, 1.058, -0.7920001), 0.86), 0.3),\n conecaps(TPos_0, vec3(0, -1.343, -1.035), vec3(0, -0.01590037, -1.035), 0.65, 0.4129604), 0.3),\n conecaps(TPos_0, vec3(0.448, 0.493, 0.413), vec3(0.0964303, 0.4929999, 0.6215981), 0.25, 0.07000001), 0.3),\n conecaps(TPos_0, vec3(0, 0.731, 0.899), vec3(0, 0.9994185, 0.6862392), 0.08, -0.04511364), 0.3),\n conecaps(TPos_0, vec3(0, -0.388, 0.524), vec3(0, 0.2982672, 0.6916121), 0.36, 0.1544515), 0.3),\n conecaps(TPos_0, vec3(0, -1.4863, -0.585), vec3(0, -0.4297584, -0.1084773), 0.28, 0.1755086), 0.3);\n    \n#else\n vec3 TPos_0=mirror(p-vec3(0, 0, 0));\n\n  float res = min(smax(smin(sph(p-vec3(-0.014, 0.87, -0.641), 1.20),\n sph(p-vec3(0.031, 1.05, -0.291), 0.89), 0.2),\n smin(smin(smin(conecaps(p, vec3(0.06, 1.785, -0.043), vec3(-0.06637037, 1.56574, 0.3384626), 0.15, 0.04923537),\n conecaps(p, vec3(0.197, 1.788, 0.109), vec3(0.4121402, 1.385284, 0.392923), 0.12, 0.03994529), 0.1),\n conecaps(p, vec3(-0.147, 1.735, 0.115), vec3(-0.5633237, 1.244842, 0.6771756), 0.12, -0.01053677), 0.1),\n conecaps(p, vec3(0.373, 1.719, 0.078), vec3(0.7583238, 1.083739, 0.3566932), 0.11, 0.002208568), 0.1), 0.1),\n min(smax(smin(sph(TPos_0-vec3(-0.014, 0.87, -0.641), 1.20),\n sph(TPos_0-vec3(0.031, 0.237, -1.288), 0.68), 0.2),\n smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(conecaps(TPos_0, vec3(0.18, 1.84, 0), vec3(0.9947872, 1.059192, 0), 0.20, 0.080608),\n conecaps(TPos_0, vec3(0.457, 1.778, -0.233), vec3(1.218826, 0.6229788, -0.233), 0.20, 0.06851683), 0.1),\n conecaps(TPos_0, vec3(0.475, 1.751, -0.502), vec3(1.163649, 0.834214, -0.5103351), 0.20, 0.06247119), 0.1),\n conecaps(TPos_0, vec3(0.501, 1.644, -0.687), vec3(1.324742, 0.4498808, -0.815752), 0.20, 0.0), 0.1),\n conecaps(TPos_0, vec3(0.438, 1.681, -0.818), vec3(1.25843, 0.5285492, -1.07989), 0.20, 0.05239521), 0.1),\n conecaps(TPos_0, vec3(0.4150705, 1.692155, -0.892), vec3(0.977915, 0.8010392, -1.295309), 0.20, 0.080608), 0.1),\n conecaps(TPos_0, vec3(0.4665176, 1.612289, -1.137529), vec3(0.9487399, 0.3972942, -1.591065), 0.20, 0.06851687), 0.1),\n conecaps(TPos_0, vec3(0.3073766, 1.580032, -1.345637), vec3(0.6488477, 0.554816, -1.729217), 0.20, 0.0624712), 0.1),\n conecaps(TPos_0, vec3(0.2050478, 1.472336, -1.527339), vec3(0.5545081, 0.120172, -1.940346), 0.20, 0.0), 0.1),\n conecaps(TPos_0, vec3(0.1044063, 1.466208, -1.451), vec3(0.2097557, 0.2754359, -2.251505), 0.20, 0.05239522), 0.1),\n conecaps(TPos_0, vec3(0.87, 0.82, -0.9), vec3(0.4488406, -0.6502159, -0.9097424), 0.20, -0.03828883), 0.1),\n conecaps(TPos_0, vec3(0.828, 0.657, -1.139), vec3(0.3844372, -0.6142089, -1.146863), 0.20, -0.0463496), 0.1),\n conecaps(TPos_0, vec3(0.873, 0.646, -1.581), vec3(0.1269265, -0.3829435, -1.104255), 0.20, 0.09471444), 0.1),\n conecaps(TPos_0, vec3(0.441, 0.689, -1.627), vec3(0.3258284, -0.4353262, -1.433523), 0.20, 0.06247126), 0.1),\n conecaps(TPos_0, vec3(0.258, 0.693, -1.761), vec3(0.02478147, -0.7067026, -1.433148), 0.20, 0.0), 0.1),\n conecaps(TPos_0, vec3(0, 0.874, -1.885), vec3(0, -0.5986498, -1.709854), 0.20, 0.008060798), 0.1),\n conecaps(TPos_0, vec3(0.842, 0.572, -0.745), vec3(0.6800996, -0.4511317, -0.438101), 0.14, -0.0270476), 0.1),\n conecaps(TPos_0, vec3(0.208, 1.842, -0.244), vec3(0.583753, 1.851966, -1.308072), 0.20, 0.080608), 0.1),\n conecaps(TPos_0, vec3(0.098, 1.844, -0.505), vec3(0.3196597, 1.71843, -1.604381), 0.20, 0.080608), 0.1),\n conecaps(TPos_0, vec3(0, 1.844, -0.84), vec3(0, 1.584119, -1.938181), 0.20, 0.08060801), 0.1), 0.1),\n smax(smin(smax(smin(smin(smin(smin(smin(smin(smin(smin(smin(conecaps(TPos_0, vec3(0, 0, 0), vec3(0, 0.8981191, -0.2021628), 0.65, 0.8194701),\n caps(TPos_0, vec3(0, 0.885, -0.359), vec3(0, 0.6657753, -0.8952476), 0.90), 0.3),\n sph(TPos_0-vec3(0, 1.058, -0.7920001), 0.86), 0.3),\n conecaps(TPos_0, vec3(0, -1.343, -1.035), vec3(0, -0.01590037, -1.035), 0.65, 0.4129604), 0.3),\n conecaps(TPos_0, vec3(0.448, 0.493, 0.413), vec3(0.0964303, 0.4929999, 0.6215981), 0.25, 0.07000001), 0.3),\n conecaps(TPos_0, vec3(0, 0.731, 0.899), vec3(0, 0.9994185, 0.6862392), 0.08, -0.04511364), 0.3),\n conecaps(TPos_0, vec3(0, -0.388, 0.524), vec3(0, 0.2982672, 0.6916121), 0.36, 0.1544515), 0.3),\n conecaps(TPos_0, vec3(0.793, 0.575, -0.45), vec3(0.9685718, 0.8660991, -0.5075423), 0.18, 0.07538141), 0.3),\n conecaps(TPos_0, vec3(0.651, -1.4863, -0.585), vec3(0.4176198, -0.006287336, -1.020103), 0.28, -0.2256553), 0.3),\n conecaps(TPos_0, vec3(0, -1.4863, -0.585), vec3(0, -0.4297584, -0.1084773), 0.28, 0.1755086), 0.3),\n -min(min(min(min(conecaps(TPos_0, vec3(0.39, 1.001, 0.687), vec3(0.760278, 1.001, 0.4733404), 0.25, 0.0725),\n conecaps(TPos_0, vec3(0.063, -0.031, 0.736), vec3(0.3386817, -0.03100006, 0.5769249), 0.19, 0.05397813)),\n conecaps(TPos_0, vec3(-0.014, -0.095, 0.604), vec3(0.2963244, -0.09500001, 0.4122402), 0.24, 0.06858408)),\n caps(TPos_0, vec3(0.149, -0.406, 0.994), vec3(0.01727781, -0.406, 0.994), 0.13)),\n conecaps(TPos_0, vec3(0.986, 0.769, -0.405), vec3(0.9680421, 0.520758, -0.405), 0.15, 0.04220953)), 0.1),\n smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(smin(smax(caps(TPos_0, vec3(0.143, 1.041, 0.541), vec3(0.4671654, 1.005373, 0.3770713), 0.07),\n -conecaps(TPos_0, vec3(0.274, 0.946, 0.563), vec3(0.4998161, 0.9211818, 0.448806), 0.10, 0.06821328), 0.02),\n smax(smax(caps(TPos_0, vec3(0.175, 0.877, 0.58), vec3(0.5016567, 0.8574979, 0.4183209), 0.07),\n -conecaps(TPos_0, vec3(0.239, 0.967, 0.568), vec3(0.5910456, 1.022967, 0.4102298), 0.07, 0.04818002), 0.04),\n -conecaps(TPos_0, vec3(0.408, 0.945, 0.483), vec3(0.06001997, 0.9721231, 0.6565917), 0.07, 0.04818002), 0.04), 0.05),\n conecaps(TPos_0, vec3(0.41, 0.757, 0.531), vec3(0.07579309, 0.8708386, 0.6575592), 0.08, -0.02930647), 0.05),\n conecaps(TPos_0, vec3(0.855, 0.689, -0.37), vec3(0.837042, 0.4407571, -0.37), 0.15, 0.04220968), 0.05),\n smin(sph(TPos_0-vec3(0, 0.718, 0.877), 0.10),\n conecaps(TPos_0, vec3(0.1, 0.677, 0.783), vec3(-0.05059213, 0.9789532, 0.6192493), 0.08, -0.02930725), 0.05), 0.05),\n conecaps(TPos_0, vec3(0.051, -0.267, 0.751), vec3(0.0411847, -0.1742215, 0.7390867), 0.06, 0.02549449), 0.05),\n conecaps(TPos_0, vec3(0.13, -0.257, 0.691), vec3(0.1219919, -0.1634887, 0.6848335), 0.06, 0.025494), 0.05),\n conecaps(TPos_0, vec3(0.198, -0.22, 0.608), vec3(0.1968478, -0.1176157, 0.6248499), 0.06, 0.015782), 0.05),\n conecaps(TPos_0, vec3(0.04392957, 0.1199243, 0.7371331), vec3(0.04759543, 0.03143565, 0.7688017), 0.06, 0.02549401), 0.05),\n conecaps(TPos_0, vec3(0.094312, 0.12868, 0.65904), vec3(0.1271792, 0.01363337, 0.6877561), 0.06, 0.02549402), 0.05),\n conecaps(TPos_0, vec3(0.1845542, 0.105525, 0.5969098), vec3(0.1959237, 0.002555117, 0.6028855), 0.06, 0.01578201), 0.05),\n smax(sph(TPos_0-vec3(0.28, 0.937, 0.422), 0.12),\n -sph(TPos_0-vec3(0.391, 0.937, 0.672), 0.17), 0.03), 0.05), 0.05),\n -caps(TPos_0, vec3(0.092, 0.6, 0.822), vec3(0.03096008, 0.7223915, 0.7556266), 0.02), 0.05)));\n#endif\n    //res = min(res, pln(p-vec3(0,-3,0), vec3(0,1,0)));\n    \n    return res*globalScale;\n}\n/*\nfloat mapOLD(vec3 p, float t) {\n    p+=vec3(0,2,0);\n    float s1 = sph(p, 0.8);\n    float s2 = sph(p+vec3(0,0.5,0), 0.8);\n    float c1 = cyl2(p.xzy,0.3);\n    float base = smax(smin(s1,s2,0.1),-c1,0.2);\n    \n    for(int i=0; i<200; ++i) {\n        float t3 = t+float(i);\n        vec3 off=vec3(sin(t3), cos(t3), cos(t3*1.42));\n    \tbase=smax(base, -sph(p+off, 0.5),  0.05);   \n    }\n    \n    for(int i=0; i<200; ++i) {\n        float t3 = t*0.2+float(i);\n        vec3 off=vec3(sin(t3)*2.0, cos(t3)*1.5, cos(t3*1.42)*2.2);\n    \tbase=smin(base, sph(p+off, 0.2),  0.05);   \n    }\n    \n    return base;\n    //return sph(p, 0.5);\n}\n*/\nvec3 getdiv(vec2 res)\n{\n    float opti=(pow(res.x*res.y,1.0/6.0));\n    float ratio=res.y/res.x;\n    float dy = ceil(opti*sqrt(ratio));\n    float dx = ceil(dy/ratio);\n    return vec3(dx,dy,dx*dy);\n}\n\nvec3 uvtomap(vec2 uv, vec3 div) {\n    vec2 fuv=floor(uv*div.xy);\n    float pz=fuv.x+fuv.y*div.x;\n    return vec3(fract(uv*div.xy)*vec2(2.0)-vec2(1.0),(pz/(div.x*div.y))*2.0-1.0)*3.0;\n}\n\nvec2 maptouv(vec3 p, vec3 div) {\n    p=clamp((p/3.0)*0.5+0.5,0.0,0.999);\n    float idz=floor((p.z+0.00001)*div.x*div.y)/div.x;\n    vec2 uvz=vec2(fract(idz),floor(idz)/div.y);\n    return p.xy/div.xy+uvz;\n}\n","name":"Common","description":"","type":"common"}]}