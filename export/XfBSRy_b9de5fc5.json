{"ver":"0.1","info":{"id":"XfBSRy","date":"1706455241","viewed":232,"name":"Stop using IGN!","username":"MartyMcFly","description":"Interleaved Gradient Noise | Interleaved Gradient Noise at a high coordinate offset\nGolden Ratio Integer Noise | Golden Ratio Integer Noise at a high coordinate offset","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["random","hash","golden","interleavedgradientnoise","ign"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// --------------------------------------------------------------------------------\n\n//   Replace Interleaved Gradient Noise in your renderer with this!\n//   Similar spectral properties and numerically stable for high input values.\n\n// --------------------------------------------------------------------------------\n\n// Background:\n//\n// Interleaved Gradient Noise by Jimenez is a float based LCG with desirable properties\n// such that the values within a 3x3 window are /somewhat/ repeating, which makes the resulting\n// output good for TAA when used in a renderer.\n//\n// It is incredibly sensitive to tiny changes in its input, and thus the quantization\n// of float values above a certain range can be problematic. \n//\n// To avoid such issues, programmers commonly do:\n//\n//  fract(x * k)   ---->    float(uint(x * 2^32) * uint(k * 2^32)) / 2^32\n//\n// which enhances precision if x was an integer to begin with (e.g. texel coord) and k can\n// be precomputed to a sufficient precision.\n//\n// I tried doing so with the IGN coefficients but the rounding broke the pattern.\n// However, Martin Roberts' generalized golden ratio coefficients yield similar results\n// with better discrepancy and similar spectral properties.\n\n// TinyTexel did figure this out 3 years ago ( https://www.shadertoy.com/view/fdl3zn ) but\n// giving this another round of attention does not hurt.\n\n#define LARGE_FLOAT_OFFSET  11111111.0\n#define ZOOM                2\n\nfloat InterleavedGradientNoise(uvec2 p)\n{  \n    vec3 magic = vec3( 0.06711056f, 0.00583715f, 52.9829189f );   \n    return fract(magic.z * fract(dot(vec2(p), magic.xy)));   \n}\n\nfloat GoldenRatioIntegerIGN(uvec2 p)\n{  \n    uvec2 umagic = uvec2(3242174889u, 2447445413u); //1/phi, 1/phiÂ² * 2^32, replaces frac() with a static precision method     \n    return float(p.x * umagic.x + p.y * umagic.y) * exp2(-32.0);   \n}\n\nvoid mainImage( out vec4 o, in vec2 vpos )\n{\n    vec2 uv = vpos/iResolution.xy * 2.0 - 1.0;\n    uv *= iResolution.xy;\n    \n    uvec2 p = uvec2(vpos);\n    \n    float rand = 0.0;\n    \n    if(uv.x < 0.0 && uv.y > 0.0) \n    {\n        rand = InterleavedGradientNoise(p>>ZOOM);\n    }\n    if(uv.x < 0.0 && uv.y < 0.0)\n    {\n        rand = GoldenRatioIntegerIGN(p>>ZOOM);\n    }\n    if(uv.x > 0.0 && uv.y > 0.0) \n    {\n        p = uvec2(vpos + LARGE_FLOAT_OFFSET);\n        rand = InterleavedGradientNoise(p>>ZOOM);\n    }\n    if(uv.x > 0.0 && uv.y < 0.0)\n    {\n        p = uvec2(vpos + LARGE_FLOAT_OFFSET);\n        rand = GoldenRatioIntegerIGN(p>>ZOOM);\n    }   \n    \n    o = vec4(rand);\n    \n    if(min(abs(uv.x), abs(uv.y)) < 3.5) o = vec4(0.0);\n    \n    \n    \n    \n}","name":"Image","description":"","type":"image"}]}