{"ver":"0.1","info":{"id":"l3SfDW","date":"1729453736","viewed":676,"name":" Concrete","username":"kishimisu","description":"But where did I park my car?","likes":59,"published":1,"flags":32,"usePreview":1,"tags":["pathtracing","tracing","path","brutalist","liminal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    A path-traced infinite complex made of concrete, inspired by brutalist architecture.\n    \n      > Add some fantasy with the mouse!\n      \n    In order to increase performance while doing many samples per frame, I tried to\n    only compute the scene intersection once with a larger number of iterations.\n    Each of the following sample then starts bouncing from this intersection \n    with a random direction and a lower number of iterations.\n    \n    This avoid computing the first ray for each sample as it's always the same and \n    improves fps quite a lot when increasing the quality.\n*/\n\nvoid mainImage(out vec4 O, vec2 F) \n{\n    O = texture(iChannel0, F/iResolution.xy);\n    O = pow(O, vec4(.45));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define QUALITY 8  // lower = more fps,  higher = less noise\n\n\n// fract noise - https://www.shadertoy.com/view/4djSRW\nvec2 hash(vec3 p) {\n\tp = fract(p * vec3(.1031, .103, .0973));\n    p += dot(p, p.yzx+33.33);\n    return fract((p.xx+p.yz)*p.zy);\n}\n\n// 2D rotation\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n// 2D rectangle SDF\nfloat rect(vec2 p, vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.)) + min(max(p.x,p.y), 0.);\n}\n\n// hemisphere sampling\nvec3 bounce(vec2 seed, vec3 n) {\n    vec3 t = vec3(1.+n.z-n.xy*n.xy, -n.x*n.y)/(1.+n.z);\n    vec3 u = vec3(t.xz, -n.x);\n    vec3 v = vec3(t.zy, -n.y);\n    float a = 6.283185 * seed.y;\n    return sqrt(seed.x) * (cos(a)*u + sin(a)*v) + sqrt(1.-seed.x)*n;\n}\n\nfloat cut;\n\nfloat map(vec3 p) {\n    p.x = mod(p.x, 7.) - 3.5;\n\n    vec3 q = p;\n    q.y = mod(q.y, 4.) - 2.;\n    \n    float z = rect(q.xy, vec2(1.2 + sin(p.z*.25) * step(p.y, 0.)*.75, .6))*.97;\n    cut = abs(abs(q.y) - .2) - .1;\n    \n    p.z = mod(p.z, 7.) - 3.5;\n    \n    float x = rect(p.yz - vec2(2, 1), vec2(.45, 1));\n    float y = rect(p.xz, vec2(.5));\n    \n    float d = min(x, z);\n          d = max(d,-cut);\n          d = min(d, y);\n            \n    return d;\n}\n\nvec3 normal(vec3 p) {\n    const vec2 e = vec2(1,-1)*.0001;\n    return normalize(e.xyy*map(p + e.xyy) + e.yyx*map(p + e.yyx) + \n\t\t\t\t\t e.yxy*map(p + e.yxy) + e.xxx*map(p + e.xxx));\n}\n\nfloat raymarch(vec3 ro, vec3 rd, int S) {\n    vec3 p;\n    float d, t = 0.;\n\n    for (int i = 0; i < S; i++) {\n        p = ro + t*rd;\n        if (p.y > 3.) break;\n\n        d = map(p);\n        if (d < .01) break;\n        \n        t += d; \n    }\n    return t;\n}\n\nvoid mainImage(out vec4 O, vec2 F) {\n    vec2 R = iResolution.xy, \n         seed = hash(vec3(F, iTime)),\n         uv = ((F+seed-.5)*2.-R)/R.y;\n         \n    float M = step(0., iMouse.z) * iMouse.x/R.x;\n         \n    // Starting ray direction & origin\n    vec3 r0 = normalize(vec3(uv, 2));\n    vec3 p0 = vec3(0, 0, -29) + r0 * 1.5;\n    \n    // Alternate viewpoints\n    float scene  = floor(iTime/8.), \n          scene2 = floor(mod(scene, 4.)*.5);\n          \n    vec2 V = (mod(scene, 2.) == 0.)\n            ? vec2(0, cos(floor(iTime/16.)*1.57+1.3)*.25+.25)\n            : vec2(scene2*1.16-.58, .5-scene2*.2);\n    \n    mat2 Vx = rot(V.x), Vy = rot(V.y);\n    p0.zy *= Vy; r0.zy *= Vy;\n    p0.zx *= Vx; r0.zx *= Vx;\n    \n    p0.z += iTime * .5;\n\n    // Precompute first ray\n    float t = raymarch(p0, r0, 120);\n    p0 += r0 * (t - .01);\n    \n    // Accumulate samples\n    vec3 acc = vec3(0); \n    for (int k = 0; k < QUALITY; k++) \n    {\n        vec3 col  = vec3(0),\n             mask = vec3(1),\n             p = p0; // start at first ray intersection\n\n        // bounce twice\n        for (int b = 0; b < 2; b++) {\n            seed = hash(vec3(seed*9., k));\n            \n            // random bounce direction\n            vec3 n  = normal(p);\n            vec3 rd = bounce(seed, n*.999);\n            \n            float t = raymarch(p, rd, 40);\n            p += rd * (t - .01);\n\n            // ceiling light\n            if (p.y > 3.) {\n                col += mask*1.5;\n                break;\n            }\n            \n            // other materials\n            vec4 c = mix(\n                vec4(.4, .4, .4, 0), \n                vec4(1. + cos(length(p)*.01 + iTime + vec3(0,1,2)), 1), \n                step(cut, 0.) * M\n            );\n\n            mask *= c.rgb;\n            col += mask * c.a;\n        }\n    \n        acc += col; \n    }\n    \n    // Fog\n    acc /= float(QUALITY) * exp(t*.01);\n    \n    // Texture details\n    vec2 tuv = abs(p0.zx) + p0.y*.25;\n    acc *= mix(texture(iChannel1, tuv*.25).rgb*.4+.6, vec3(1), step(2.9, p0.y));\n    \n    // Blend with previous frame\n    vec4 prev = iFrame < 3 ? vec4(0) : texture(iChannel0, F/R);\n    O = mix(prev, acc.rgbb, .08);\n}","name":"Buffer A","description":"","type":"buffer"}]}