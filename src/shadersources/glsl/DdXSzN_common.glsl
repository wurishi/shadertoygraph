#define ROUNDS 512.0
#define RADIUS_X 7
#define RADIUS_Y 3

const float EPSILON = 1e-5;


// sRGB color transform and inverse from 
// https://bottosson.github.io/posts/colorwrong/#what-can-we-do%3F

vec3 linear_srgb_from_srgb(vec3 x) {

    vec3 xlo = x / 12.92;
    vec3 xhi = pow((x + 0.055)/(1.055), vec3(2.4));
    
    return mix(xlo, xhi, step(vec3(0.04045), x));

}


vec3 srgb_from_linear_srgb(vec3 x) {

    vec3 xlo = 12.92*x;
    vec3 xhi = 1.055 * pow(x, vec3(0.4166666666666667)) - 0.055;
    
    return mix(xlo, xhi, step(vec3(0.0031308), x));

}



vec3 SRGBtoRGB(vec3 srgb) {
    // See http://chilliant.blogspot.co.uk/2012/08/srgb-approximations-for-hlsl.html
    // This is a better approximation than the common "pow(rgb, 2.2)"
    // return pow(srgb, vec3(2.1632601288));
    return linear_srgb_from_srgb(srgb);
}

vec3 RGBtoSRGB(vec3 rgb) {
    // This is a better approximation than the common "pow(rgb, 0.45454545)"
    // return pow(rgb, vec3(0.46226525728));
    return srgb_from_linear_srgb(rgb);
}


vec3 HUEtoRGB(in float hue)
{
    // Hue [0..1] to RGB [0..1]
    // See http://www.chilliant.com/rgb2hsv.html
    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);
    return clamp(rgb, 0., 1.);
}

vec3 RGBtoHCV(in vec3 rgb)
{
    // RGB [0..1] to Hue-Chroma-Value [0..1]
    // Based on work by Sam Hocevar and Emil Persson
    vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1., 2. / 3.) : vec4(rgb.gb, 0., -1. / 3.);
    vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);
    float c = q.x - min(q.w, q.y);
    float h = abs((q.w - q.y) / (6. * c + EPSILON) + q.z);
    return vec3(h, c, q.x);
}

vec3 HSVtoRGB(in vec3 hsv)
{
    // Hue-Saturation-Value [0..1] to RGB [0..1]
    vec3 rgb = HUEtoRGB(hsv.x);
    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;
}

vec3 HSLtoRGB(in vec3 hsl)
{
    // Hue-Saturation-Lightness [0..1] to RGB [0..1]
    vec3 rgb = HUEtoRGB(hsl.x);
    float c = (1. - abs(2. * hsl.z - 1.)) * hsl.y;
    return (rgb - 0.5) * c + hsl.z;
}

vec3 RGBtoHSV(in vec3 rgb)
{
    // RGB [0..1] to Hue-Saturation-Value [0..1]
    vec3 hcv = RGBtoHCV(rgb);
    float s = hcv.y / (hcv.z + EPSILON);
    return vec3(hcv.x, s, hcv.z);
}

vec3 RGBtoHSL(in vec3 rgb)
{
    // RGB [0..1] to Hue-Saturation-Lightness [0..1]
    vec3 hcv = RGBtoHCV(rgb);
    float z = hcv.z - hcv.y * 0.5;
    float s = hcv.y / (1. - abs(z * 2. - 1.) + EPSILON);
    return vec3(hcv.x, s, z);
}


// LAB/RGB converstions - https://code.google.com/archive/p/flowabs/
// HSV/RGB conversion - http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl

vec3 rgb2xyz( vec3 c ) {
    vec3 tmp;
    tmp.x = ( c.r > 0.04045 ) ? pow( ( c.r + 0.055 ) / 1.055, 2.4 ) : c.r / 12.92;
    tmp.y = ( c.g > 0.04045 ) ? pow( ( c.g + 0.055 ) / 1.055, 2.4 ) : c.g / 12.92,
    tmp.z = ( c.b > 0.04045 ) ? pow( ( c.b + 0.055 ) / 1.055, 2.4 ) : c.b / 12.92;
    return 100.0 * tmp *
        mat3( 0.4124, 0.3576, 0.1805,
              0.2126, 0.7152, 0.0722,
              0.0193, 0.1192, 0.9505 );
}

vec3 xyz2lab( vec3 c ) {
    vec3 n = c / vec3( 95.047, 100, 108.883 );
    vec3 v;
    v.x = ( n.x > 0.008856 ) ? pow( n.x, 1.0 / 3.0 ) : ( 7.787 * n.x ) + ( 16.0 / 116.0 );
    v.y = ( n.y > 0.008856 ) ? pow( n.y, 1.0 / 3.0 ) : ( 7.787 * n.y ) + ( 16.0 / 116.0 );
    v.z = ( n.z > 0.008856 ) ? pow( n.z, 1.0 / 3.0 ) : ( 7.787 * n.z ) + ( 16.0 / 116.0 );
    return vec3(( 116.0 * v.y ) - 16.0, 500.0 * ( v.x - v.y ), 200.0 * ( v.y - v.z ));
}

vec3 rgb2lab(vec3 c) {
    vec3 lab = xyz2lab( rgb2xyz( c ) );
    return vec3( lab.x / 100.0, 0.5 + 0.5 * ( lab.y / 127.0 ), 0.5 + 0.5 * ( lab.z / 127.0 ));
}

vec3 lab2xyz( vec3 c ) {
    float fy = ( c.x + 16.0 ) / 116.0;
    float fx = c.y / 500.0 + fy;
    float fz = fy - c.z / 200.0;
    return vec3(
         95.047 * (( fx > 0.206897 ) ? fx * fx * fx : ( fx - 16.0 / 116.0 ) / 7.787),
        100.000 * (( fy > 0.206897 ) ? fy * fy * fy : ( fy - 16.0 / 116.0 ) / 7.787),
        108.883 * (( fz > 0.206897 ) ? fz * fz * fz : ( fz - 16.0 / 116.0 ) / 7.787)
    );
}

vec3 xyz2rgb( vec3 c ) {
    vec3 v =  c / 100.0 * mat3( 
        3.2406, -1.5372, -0.4986,
        -0.9689, 1.8758, 0.0415,
        0.0557, -0.2040, 1.0570
    );
    vec3 r;
    r.x = ( v.r > 0.0031308 ) ? (( 1.055 * pow( v.r, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.r;
    r.y = ( v.g > 0.0031308 ) ? (( 1.055 * pow( v.g, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.g;
    r.z = ( v.b > 0.0031308 ) ? (( 1.055 * pow( v.b, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.b;
    return r;
}

vec3 lab2rgb(vec3 c) {
    return xyz2rgb( lab2xyz( vec3(100.0 * c.x, 2.0 * 127.0 * (c.y - 0.5), 2.0 * 127.0 * (c.z - 0.5)) ) );
}

vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

// oklab transform and inverse from
// https://bottosson.github.io/posts/oklab/


const mat3 fwdA = mat3(1.0, 1.0, 1.0,
                       0.3963377774, -0.1055613458, -0.0894841775,
                       0.2158037573, -0.0638541728, -1.2914855480);
                       
const mat3 fwdB = mat3(4.0767245293, -1.2681437731, -0.0041119885,
                       -3.3072168827, 2.6093323231, -0.7034763098,
                       0.2307590544, -0.3411344290,  1.7068625689);

const mat3 invB = mat3(0.4121656120, 0.2118591070, 0.0883097947,
                       0.5362752080, 0.6807189584, 0.2818474174,
                       0.0514575653, 0.1074065790, 0.6302613616);
                       
const mat3 invA = mat3(0.2104542553, 1.9779984951, 0.0259040371,
                       0.7936177850, -2.4285922050, 0.7827717662,
                       -0.0040720468, 0.4505937099, -0.8086757660);

vec3 oklab_from_linear_srgb(vec3 c) {

    vec3 lms = invB * c;
            
    return invA * (sign(lms)*pow(abs(lms), vec3(0.3333333333333)));
    
}

vec3 linear_srgb_from_oklab(vec3 c) {

    vec3 lms = fwdA * c;
    
    return fwdB * (lms * lms * lms);
    
}




#define M_PI 3.14159265358979323846264338327954

float cbrt( float x )
{
    return sign(x)*pow(abs(x),1.0f/3.0f);
}


vec3 linear_srgb_to_oklab(vec3 c)
{
	float l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;
	float m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;
	float s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;

	float l_ = cbrt(l);
	float m_ = cbrt(m);
	float s_ = cbrt(s);

	return vec3(
		0.2104542553f * l_ + 0.7936177850f * m_ - 0.0040720468f * s_,
		1.9779984951f * l_ - 2.4285922050f * m_ + 0.4505937099f * s_,
		0.0259040371f * l_ + 0.7827717662f * m_ - 0.8086757660f * s_
	);
}

vec3 oklab_to_linear_srgb(vec3 c)
{
	float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;
	float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;
	float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;

	float l = l_ * l_ * l_;
	float m = m_ * m_ * m_;
	float s = s_ * s_ * s_;

	return vec3(
		+4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,
		-1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,
		-0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s
	);
}


// Finds the maximum saturation possible for a given hue that fits in sRGB
// Saturation here is defined as S = C/L
// a and b must be normalized so a^2 + b^2 == 1
float compute_max_saturation(float a, float b)
{
	// Max saturation will be when one of r, g or b goes below zero.

	// Select different coefficients depending on which component goes below zero first
	float k0, k1, k2, k3, k4, wl, wm, ws;

	if (-1.88170328f * a - 0.80936493f * b > 1.f)
	{
		// Red component
		k0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;
		wl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;
	}
	else if (1.81444104f * a - 1.19445276f * b > 1.f)
	{
		// Green component
		k0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;
		wl = -1.2684380046f; wm = +2.6097574011f; ws = -0.3413193965f;
	}
	else
	{
		// Blue component
		k0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;
		wl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;
	}

	// Approximate max saturation using a polynomial:
	float S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;

	// Do one step Halley's method to get closer
	// this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite
	// this should be sufficient for most applications, otherwise do two/three steps 

	float k_l = +0.3963377774f * a + 0.2158037573f * b;
	float k_m = -0.1055613458f * a - 0.0638541728f * b;
	float k_s = -0.0894841775f * a - 1.2914855480f * b;

	{
		float l_ = 1.f + S * k_l;
		float m_ = 1.f + S * k_m;
		float s_ = 1.f + S * k_s;

		float l = l_ * l_ * l_;
		float m = m_ * m_ * m_;
		float s = s_ * s_ * s_;

		float l_dS = 3.f * k_l * l_ * l_;
		float m_dS = 3.f * k_m * m_ * m_;
		float s_dS = 3.f * k_s * s_ * s_;

		float l_dS2 = 6.f * k_l * k_l * l_;
		float m_dS2 = 6.f * k_m * k_m * m_;
		float s_dS2 = 6.f * k_s * k_s * s_;

		float f = wl * l + wm * m + ws * s;
		float f1 = wl * l_dS + wm * m_dS + ws * s_dS;
		float f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;

		S = S - f * f1 / (f1 * f1 - 0.5f * f * f2);
	}

	return S;
}

// finds L_cusp and C_cusp for a given hue
// a and b must be normalized so a^2 + b^2 == 1
vec2 find_cusp(float a, float b)
{
	// First, find the maximum saturation (saturation S = C/L)
	float S_cusp = compute_max_saturation(a, b);

	// Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:
	vec3 rgb_at_max = oklab_to_linear_srgb(vec3( 1, S_cusp * a, S_cusp * b ));
	float L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));
	float C_cusp = L_cusp * S_cusp;

	return vec2( L_cusp , C_cusp );
}

// Finds intersection of the line defined by 
// L = L0 * (1 - t) + t * L1;
// C = t * C1;
// a and b must be normalized so a^2 + b^2 == 1
float find_gamut_intersection(float a, float b, float L1, float C1, float L0, vec2 cusp)
{
	// Find the intersection for upper and lower half seprately
	float t;
	if (((L1 - L0) * cusp.y - (cusp.x - L0) * C1) <= 0.f)
	{
		// Lower half

		t = cusp.y * L0 / (C1 * cusp.x + cusp.y * (L0 - L1));
	}
	else
	{
		// Upper half

		// First intersect with triangle
		t = cusp.y * (L0 - 1.f) / (C1 * (cusp.x - 1.f) + cusp.y * (L0 - L1));

		// Then one step Halley's method
		{
			float dL = L1 - L0;
			float dC = C1;

			float k_l = +0.3963377774f * a + 0.2158037573f * b;
			float k_m = -0.1055613458f * a - 0.0638541728f * b;
			float k_s = -0.0894841775f * a - 1.2914855480f * b;

			float l_dt = dL + dC * k_l;
			float m_dt = dL + dC * k_m;
			float s_dt = dL + dC * k_s;


			// If higher accuracy is required, 2 or 3 iterations of the following block can be used:
			{
				float L = L0 * (1.f - t) + t * L1;
				float C = t * C1;

				float l_ = L + C * k_l;
				float m_ = L + C * k_m;
				float s_ = L + C * k_s;

				float l = l_ * l_ * l_;
				float m = m_ * m_ * m_;
				float s = s_ * s_ * s_;

				float ldt = 3.f * l_dt * l_ * l_;
				float mdt = 3.f * m_dt * m_ * m_;
				float sdt = 3.f * s_dt * s_ * s_;

				float ldt2 = 6.f * l_dt * l_dt * l_;
				float mdt2 = 6.f * m_dt * m_dt * m_;
				float sdt2 = 6.f * s_dt * s_dt * s_;

				float r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.f;
				float r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;
				float r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;

				float u_r = r1 / (r1 * r1 - 0.5f * r * r2);
				float t_r = -r * u_r;

				float g = -1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s - 1.f;
				float g1 = -1.2684380046f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;
				float g2 = -1.2684380046f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;

				float u_g = g1 / (g1 * g1 - 0.5f * g * g2);
				float t_g = -g * u_g;

				float b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.f;
				float b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;
				float b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;

				float u_b = b1 / (b1 * b1 - 0.5f * b * b2);
				float t_b = -b * u_b;

				t_r = u_r >= 0.f ? t_r : 10000.f;
				t_g = u_g >= 0.f ? t_g : 10000.f;
				t_b = u_b >= 0.f ? t_b : 10000.f;

				t += min(t_r, min(t_g, t_b));
			}
		}
	}

	return t;
}

float find_gamut_intersection(float a, float b, float L1, float C1, float L0)
{
	// Find the cusp of the gamut triangle
	vec2 cusp = find_cusp(a, b);

	return find_gamut_intersection(a, b, L1, C1, L0, cusp);
}

vec3 gamut_clip_preserve_chroma(vec3 rgb)
{
	if (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)
		return rgb;

	vec3 lab = linear_srgb_to_oklab(rgb);

	float L = lab.x;
	float eps = 0.00001f;
	float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));
	float a_ = lab.y / C;
	float b_ = lab.z / C;

	float L0 = clamp(L, 0.f, 1.f);

	float t = find_gamut_intersection(a_, b_, L, C, L0);
	float L_clipped = L0 * (1.f - t) + t * L;
	float C_clipped = t * C;

	return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));
}

vec3 gamut_clip_project_to_0_5(vec3 rgb)
{
	if (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)
		return rgb;

	vec3 lab = linear_srgb_to_oklab(rgb);

	float L = lab.x;
	float eps = 0.00001f;
	float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));
	float a_ = lab.y / C;
	float b_ = lab.z / C;

	float L0 = 0.5;

	float t = find_gamut_intersection(a_, b_, L, C, L0);
	float L_clipped = L0 * (1.f - t) + t * L;
	float C_clipped = t * C;

	return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));
}

vec3 gamut_clip_project_to_L_cusp(vec3 rgb)
{
	if (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)
		return rgb;

	vec3 lab = linear_srgb_to_oklab(rgb);

	float L = lab.x;
	float eps = 0.00001f;
	float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));
	float a_ = lab.y / C;
	float b_ = lab.z / C;

	// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.
	vec2 cusp = find_cusp(a_, b_);

	float L0 = cusp.x;

	float t = find_gamut_intersection(a_, b_, L, C, L0);

	float L_clipped = L0 * (1.f - t) + t * L;
	float C_clipped = t * C;

	return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));
}

vec3 gamut_clip_adaptive_L0_0_5(vec3 rgb, float alpha)
{
	if (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)
		return rgb;

	vec3 lab = linear_srgb_to_oklab(rgb);

	float L = lab.x;
	float eps = 0.00001f;
	float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));
	float a_ = lab.y / C;
	float b_ = lab.z / C;

	float Ld = L - 0.5f;
	float e1 = 0.5f + abs(Ld) + alpha * C;
	float L0 = 0.5f * (1.f + sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * abs(Ld))));

	float t = find_gamut_intersection(a_, b_, L, C, L0);
	float L_clipped = L0 * (1.f - t) + t * L;
	float C_clipped = t * C;

	return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));
}

vec3 gamut_clip_adaptive_L0_L_cusp(vec3 rgb, float alpha)
{
	if (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)
		return rgb;

	vec3 lab = linear_srgb_to_oklab(rgb);

	float L = lab.x;
	float eps = 0.00001f;
	float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));
	float a_ = lab.y / C;
	float b_ = lab.z / C;

	// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.
	vec2 cusp = find_cusp(a_, b_);

	float Ld = L - cusp.x;
	float k = 2.f * (Ld > 0.f ? 1.f - cusp.x : cusp.x);

	float e1 = 0.5f * k + abs(Ld) + alpha * C / k;
	float L0 = cusp.x + 0.5f * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * k * abs(Ld))));

	float t = find_gamut_intersection(a_, b_, L, C, L0);
	float L_clipped = L0 * (1.f - t) + t * L;
	float C_clipped = t * C;

	return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));
}

float toe(float x)
{
	float k_1 = 0.206f;
	float k_2 = 0.03f;
	float k_3 = (1.f + k_1) / (1.f + k_2);
	return 0.5f * (k_3 * x - k_1 + sqrt((k_3 * x - k_1) * (k_3 * x - k_1) + 4.f * k_2 * k_3 * x));
}

float toe_inv(float x)
{
	float k_1 = 0.206f;
	float k_2 = 0.03f;
	float k_3 = (1.f + k_1) / (1.f + k_2);
	return (x * x + k_1 * x) / (k_3 * (x + k_2));
}

vec2 to_ST(vec2 cusp)
{
	float L = cusp.x;
	float C = cusp.y;
	return vec2( C / L, C / (1.f - L) );
}

// Returns a smooth approximation of the location of the cusp
// This polynomial was created by an optimization process
// It has been designed so that S_mid < S_max and T_mid < T_max
vec2 get_ST_mid(float a_, float b_)
{
	float S = 0.11516993f + 1.f / (
		+7.44778970f + 4.15901240f * b_
		+ a_ * (-2.19557347f + 1.75198401f * b_
			+ a_ * (-2.13704948f - 10.02301043f * b_
				+ a_ * (-4.24894561f + 5.38770819f * b_ + 4.69891013f * a_
					)))
		);

	float T = 0.11239642f + 1.f / (
		+1.61320320f - 0.68124379f * b_
		+ a_ * (+0.40370612f + 0.90148123f * b_
			+ a_ * (-0.27087943f + 0.61223990f * b_
				+ a_ * (+0.00299215f - 0.45399568f * b_ - 0.14661872f * a_
					)))
		);

	return vec2( S, T );
}

vec3 get_Cs(float L, float a_, float b_)
{
	vec2 cusp = find_cusp(a_, b_);

	float C_max = find_gamut_intersection(a_, b_, L, 1.f, L, cusp);
	vec2 ST_max = to_ST(cusp);
	
	// Scale factor to compensate for the curved part of gamut shape:
	float k = C_max / min((L * ST_max.x), (1.f - L) * ST_max.y);

	float C_mid;
	{
		vec2 ST_mid = get_ST_mid(a_, b_);

		// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
		float C_a = L * ST_mid.x;
		float C_b = (1.f - L) * ST_mid.y;
		C_mid = 0.9f * k * sqrt(sqrt(1.f / (1.f / (C_a * C_a * C_a * C_a) + 1.f / (C_b * C_b * C_b * C_b))));
	}

	float C_0;
	{
		// for C_0, the shape is independent of hue, so vec2 are constant. Values picked to roughly be the average values of vec2.
		float C_a = L * 0.4f;
		float C_b = (1.f - L) * 0.8f;

		// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
		C_0 = sqrt(1.f / (1.f / (C_a * C_a) + 1.f / (C_b * C_b)));
	}

	return vec3( C_0, C_mid, C_max );
}



vec3 okhsl_to_oklab(vec3 hsl)
{
	float h = hsl.x;
	float s = hsl.y;
	float l = hsl.z;

	if (l == 1.0f)
	{
		return vec3( 1.f, 1.f, 1.f );
	}

	else if (l == 0.f)
	{
		return vec3( 0.f, 0.f, 0.f );
	}

	float a_ = cos(2.f * M_PI * h);
	float b_ = sin(2.f * M_PI * h);
	float L = toe_inv(l);

	vec3 cs = get_Cs(L, a_, b_);
	float C_0 = cs.x;
	float C_mid = cs.y;
	float C_max = cs.z;

	float mid = 0.8f;
	float mid_inv = 1.25f;

	float C, t, k_0, k_1, k_2;

	if (s < mid)
	{
		t = mid_inv * s;

		k_1 = mid * C_0;
		k_2 = (1.f - k_1 / C_mid);

		C = t * k_1 / (1.f - k_2 * t);
	}
	else
	{
		t = (s - mid)/ (1.f - mid);

		k_0 = C_mid;
		k_1 = (1.f - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;
		k_2 = (1.f - (k_1) / (C_max - C_mid));

		C = k_0 + t * k_1 / (1.f - k_2 * t);
	}
    
    return vec3( L, C * a_, C * b_ );
}
    
    
vec3 okhsl_to_linear_srgb(vec3 hsl)
{
   vec3 lab = okhsl_to_oklab(hsl);
	return oklab_to_linear_srgb(lab);
}

vec3 oklab_to_okhsl(vec3 lab)
{
	float C = sqrt(lab.y * lab.y + lab.z * lab.z);
	float a_ = lab.y / C;
	float b_ = lab.z / C;

	float L = lab.x;
	float h = 0.5f + 0.5f * atan(-lab.z, -lab.y) / M_PI;

	vec3 cs = get_Cs(L, a_, b_);
	float C_0 = cs.x;
	float C_mid = cs.y;
	float C_max = cs.z;

	// Inverse of the interpolation in okhsl_to_srgb:

	float mid = 0.8f;
	float mid_inv = 1.25f;

	float s;
	if (C < C_mid)
	{
		float k_1 = mid * C_0;
		float k_2 = (1.f - k_1 / C_mid);

		float t = C / (k_1 + k_2 * C);
		s = t * mid;
	}
	else
	{
		float k_0 = C_mid;
		float k_1 = (1.f - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;
		float k_2 = (1.f - (k_1) / (C_max - C_mid));

		float t = (C - k_0) / (k_1 + k_2 * (C - k_0));
		s = mid + (1.f - mid) * t;
	}

	float l = toe(L);
	return vec3( h, s, l );
}

vec3 linear_srgb_to_okhsl(vec3 rgb)
{
	vec3 lab = linear_srgb_to_oklab(rgb);
    return oklab_to_okhsl(lab);
}





vec3 paletteFull[256] =
vec3[256](
vec3(000.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(015.0/256.0,  015.0/256.0,  015.0/256.0),
vec3(031.0/256.0,  031.0/256.0,  031.0/256.0),
vec3(047.0/256.0,  047.0/256.0,  047.0/256.0),
vec3(063.0/256.0,  063.0/256.0,  063.0/256.0),
vec3(075.0/256.0,  075.0/256.0,  075.0/256.0),
vec3(091.0/256.0,  091.0/256.0,  091.0/256.0),
vec3(107.0/256.0,  107.0/256.0,  107.0/256.0),
vec3(123.0/256.0,  123.0/256.0,  123.0/256.0),
vec3(139.0/256.0,  139.0/256.0,  139.0/256.0),
vec3(155.0/256.0,  155.0/256.0,  155.0/256.0),
vec3(171.0/256.0,  171.0/256.0,  171.0/256.0),
vec3(187.0/256.0,  187.0/256.0,  187.0/256.0),
vec3(203.0/256.0,  203.0/256.0,  203.0/256.0),
vec3(219.0/256.0,  219.0/256.0,  219.0/256.0),
vec3(235.0/256.0,  235.0/256.0,  235.0/256.0),

vec3(015.0/256.0,  011.0/256.0,  007.0/256.0),
vec3(023.0/256.0,  015.0/256.0,  011.0/256.0),
vec3(031.0/256.0,  023.0/256.0,  011.0/256.0),
vec3(039.0/256.0,  027.0/256.0,  015.0/256.0),
vec3(047.0/256.0,  035.0/256.0,  019.0/256.0),
vec3(055.0/256.0,  043.0/256.0,  023.0/256.0),
vec3(063.0/256.0,  047.0/256.0,  023.0/256.0),
vec3(075.0/256.0,  055.0/256.0,  027.0/256.0),
vec3(083.0/256.0,  059.0/256.0,  027.0/256.0),
vec3(091.0/256.0,  067.0/256.0,  031.0/256.0),
vec3(099.0/256.0,  075.0/256.0,  031.0/256.0),
vec3(107.0/256.0,  083.0/256.0,  031.0/256.0),
vec3(115.0/256.0,  087.0/256.0,  031.0/256.0),
vec3(123.0/256.0,  095.0/256.0,  035.0/256.0),
vec3(131.0/256.0,  103.0/256.0,  035.0/256.0),
vec3(143.0/256.0,  111.0/256.0,  035.0/256.0),

vec3(011.0/256.0,  011.0/256.0,  015.0/256.0),
vec3(019.0/256.0,  019.0/256.0,  027.0/256.0),
vec3(027.0/256.0,  027.0/256.0,  039.0/256.0),
vec3(039.0/256.0,  039.0/256.0,  051.0/256.0),
vec3(047.0/256.0,  047.0/256.0,  063.0/256.0),
vec3(055.0/256.0,  055.0/256.0,  075.0/256.0),
vec3(063.0/256.0,  063.0/256.0,  087.0/256.0),
vec3(071.0/256.0,  071.0/256.0,  103.0/256.0),
vec3(079.0/256.0,  079.0/256.0,  115.0/256.0),
vec3(091.0/256.0,  091.0/256.0,  127.0/256.0),
vec3(099.0/256.0,  099.0/256.0,  139.0/256.0),
vec3(107.0/256.0,  107.0/256.0,  151.0/256.0),
vec3(115.0/256.0,  115.0/256.0,  163.0/256.0),
vec3(123.0/256.0,  123.0/256.0,  175.0/256.0),
vec3(131.0/256.0,  131.0/256.0,  187.0/256.0),
vec3(139.0/256.0,  139.0/256.0,  203.0/256.0),

vec3(000.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(007.0/256.0,  007.0/256.0,  000.0/256.0),
vec3(011.0/256.0,  011.0/256.0,  000.0/256.0),
vec3(019.0/256.0,  019.0/256.0,  000.0/256.0),
vec3(027.0/256.0,  027.0/256.0,  000.0/256.0),
vec3(035.0/256.0,  035.0/256.0,  000.0/256.0),
vec3(043.0/256.0,  043.0/256.0,  007.0/256.0),
vec3(047.0/256.0,  047.0/256.0,  007.0/256.0),
vec3(055.0/256.0,  055.0/256.0,  007.0/256.0),
vec3(063.0/256.0,  063.0/256.0,  007.0/256.0),
vec3(071.0/256.0,  071.0/256.0,  007.0/256.0),
vec3(075.0/256.0,  075.0/256.0,  011.0/256.0),
vec3(083.0/256.0,  083.0/256.0,  011.0/256.0),
vec3(091.0/256.0,  091.0/256.0,  011.0/256.0),
vec3(099.0/256.0,  099.0/256.0,  011.0/256.0),
vec3(107.0/256.0,  107.0/256.0,  015.0/256.0),

vec3(007.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(015.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(023.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(031.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(039.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(047.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(055.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(063.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(071.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(079.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(087.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(095.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(103.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(111.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(119.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(127.0/256.0,  000.0/256.0,  000.0/256.0),

vec3(019.0/256.0,  019.0/256.0,  000.0/256.0),
vec3(027.0/256.0,  027.0/256.0,  000.0/256.0),
vec3(035.0/256.0,  035.0/256.0,  000.0/256.0),
vec3(047.0/256.0,  043.0/256.0,  000.0/256.0),
vec3(055.0/256.0,  047.0/256.0,  000.0/256.0),
vec3(067.0/256.0,  055.0/256.0,  000.0/256.0),
vec3(075.0/256.0,  059.0/256.0,  007.0/256.0),
vec3(087.0/256.0,  067.0/256.0,  007.0/256.0),
vec3(095.0/256.0,  071.0/256.0,  007.0/256.0),
vec3(107.0/256.0,  075.0/256.0,  011.0/256.0),
vec3(119.0/256.0,  083.0/256.0,  015.0/256.0),
vec3(131.0/256.0,  087.0/256.0,  019.0/256.0),
vec3(139.0/256.0,  091.0/256.0,  019.0/256.0),
vec3(151.0/256.0,  095.0/256.0,  027.0/256.0),
vec3(163.0/256.0,  099.0/256.0,  031.0/256.0),
vec3(175.0/256.0,  103.0/256.0,  035.0/256.0),

vec3(035.0/256.0,  019.0/256.0,  007.0/256.0),
vec3(047.0/256.0,  023.0/256.0,  011.0/256.0),
vec3(059.0/256.0,  031.0/256.0,  015.0/256.0),
vec3(075.0/256.0,  035.0/256.0,  019.0/256.0),
vec3(087.0/256.0,  043.0/256.0,  023.0/256.0),
vec3(099.0/256.0,  047.0/256.0,  031.0/256.0),
vec3(115.0/256.0,  055.0/256.0,  035.0/256.0),
vec3(127.0/256.0,  059.0/256.0,  043.0/256.0),
vec3(143.0/256.0,  067.0/256.0,  051.0/256.0),
vec3(159.0/256.0,  079.0/256.0,  051.0/256.0),
vec3(175.0/256.0,  099.0/256.0,  047.0/256.0),
vec3(191.0/256.0,  119.0/256.0,  047.0/256.0),
vec3(207.0/256.0,  143.0/256.0,  043.0/256.0),
vec3(223.0/256.0,  171.0/256.0,  039.0/256.0),
vec3(239.0/256.0,  203.0/256.0,  031.0/256.0),
vec3(255.0/256.0,  243.0/256.0,  027.0/256.0),

vec3(011.0/256.0,  007.0/256.0,  000.0/256.0),
vec3(027.0/256.0,  019.0/256.0,  000.0/256.0),
vec3(043.0/256.0,  035.0/256.0,  015.0/256.0),
vec3(055.0/256.0,  043.0/256.0,  019.0/256.0),
vec3(071.0/256.0,  051.0/256.0,  027.0/256.0),
vec3(083.0/256.0,  055.0/256.0,  035.0/256.0),
vec3(099.0/256.0,  063.0/256.0,  043.0/256.0),
vec3(111.0/256.0,  071.0/256.0,  051.0/256.0),
vec3(127.0/256.0,  083.0/256.0,  063.0/256.0),
vec3(139.0/256.0,  095.0/256.0,  071.0/256.0),
vec3(155.0/256.0,  107.0/256.0,  083.0/256.0),
vec3(167.0/256.0,  123.0/256.0,  095.0/256.0),
vec3(183.0/256.0,  135.0/256.0,  107.0/256.0),
vec3(195.0/256.0,  147.0/256.0,  123.0/256.0),
vec3(211.0/256.0,  163.0/256.0,  139.0/256.0),
vec3(227.0/256.0,  179.0/256.0,  151.0/256.0),

vec3(171.0/256.0,  139.0/256.0,  163.0/256.0),
vec3(159.0/256.0,  127.0/256.0,  151.0/256.0),
vec3(147.0/256.0,  115.0/256.0,  135.0/256.0),
vec3(139.0/256.0,  103.0/256.0,  123.0/256.0),
vec3(127.0/256.0,  091.0/256.0,  111.0/256.0),
vec3(119.0/256.0,  083.0/256.0,  099.0/256.0),
vec3(107.0/256.0,  075.0/256.0,  087.0/256.0),
vec3(095.0/256.0,  063.0/256.0,  075.0/256.0),
vec3(087.0/256.0,  055.0/256.0,  067.0/256.0),
vec3(075.0/256.0,  047.0/256.0,  055.0/256.0),
vec3(067.0/256.0,  039.0/256.0,  047.0/256.0),
vec3(055.0/256.0,  031.0/256.0,  035.0/256.0),
vec3(043.0/256.0,  023.0/256.0,  027.0/256.0),
vec3(035.0/256.0,  019.0/256.0,  019.0/256.0),
vec3(023.0/256.0,  011.0/256.0,  011.0/256.0),
vec3(015.0/256.0,  007.0/256.0,  007.0/256.0),

vec3(187.0/256.0,  115.0/256.0,  159.0/256.0),
vec3(175.0/256.0,  107.0/256.0,  143.0/256.0),
vec3(163.0/256.0,  095.0/256.0,  131.0/256.0),
vec3(151.0/256.0,  087.0/256.0,  119.0/256.0),
vec3(139.0/256.0,  079.0/256.0,  107.0/256.0),
vec3(127.0/256.0,  075.0/256.0,  095.0/256.0),
vec3(115.0/256.0,  067.0/256.0,  083.0/256.0),
vec3(107.0/256.0,  059.0/256.0,  075.0/256.0),
vec3(095.0/256.0,  051.0/256.0,  063.0/256.0),
vec3(083.0/256.0,  043.0/256.0,  055.0/256.0),
vec3(071.0/256.0,  035.0/256.0,  043.0/256.0),
vec3(059.0/256.0,  031.0/256.0,  035.0/256.0),
vec3(047.0/256.0,  023.0/256.0,  027.0/256.0),
vec3(035.0/256.0,  019.0/256.0,  019.0/256.0),
vec3(023.0/256.0,  011.0/256.0,  011.0/256.0),
vec3(015.0/256.0,  007.0/256.0,  007.0/256.0),

vec3(219.0/256.0,  195.0/256.0,  187.0/256.0),
vec3(203.0/256.0,  179.0/256.0,  167.0/256.0),
vec3(191.0/256.0,  163.0/256.0,  155.0/256.0),
vec3(175.0/256.0,  151.0/256.0,  139.0/256.0),
vec3(163.0/256.0,  135.0/256.0,  123.0/256.0),
vec3(151.0/256.0,  123.0/256.0,  111.0/256.0),
vec3(135.0/256.0,  111.0/256.0,  095.0/256.0),
vec3(123.0/256.0,  099.0/256.0,  083.0/256.0),
vec3(107.0/256.0,  087.0/256.0,  071.0/256.0),
vec3(095.0/256.0,  075.0/256.0,  059.0/256.0),
vec3(083.0/256.0,  063.0/256.0,  051.0/256.0),
vec3(067.0/256.0,  051.0/256.0,  039.0/256.0),
vec3(055.0/256.0,  043.0/256.0,  031.0/256.0),
vec3(039.0/256.0,  031.0/256.0,  023.0/256.0),
vec3(027.0/256.0,  019.0/256.0,  015.0/256.0),
vec3(015.0/256.0,  011.0/256.0,  007.0/256.0),

vec3(111.0/256.0,  131.0/256.0,  123.0/256.0),
vec3(103.0/256.0,  123.0/256.0,  111.0/256.0),
vec3(095.0/256.0,  115.0/256.0,  103.0/256.0),
vec3(087.0/256.0,  107.0/256.0,  095.0/256.0),
vec3(079.0/256.0,  099.0/256.0,  087.0/256.0),
vec3(071.0/256.0,  091.0/256.0,  079.0/256.0),
vec3(063.0/256.0,  083.0/256.0,  071.0/256.0),
vec3(055.0/256.0,  075.0/256.0,  063.0/256.0),
vec3(047.0/256.0,  067.0/256.0,  055.0/256.0),
vec3(043.0/256.0,  059.0/256.0,  047.0/256.0),
vec3(035.0/256.0,  051.0/256.0,  039.0/256.0),
vec3(031.0/256.0,  043.0/256.0,  031.0/256.0),
vec3(023.0/256.0,  035.0/256.0,  023.0/256.0),
vec3(015.0/256.0,  027.0/256.0,  019.0/256.0),
vec3(011.0/256.0,  019.0/256.0,  011.0/256.0),
vec3(007.0/256.0,  011.0/256.0,  007.0/256.0),

vec3(255.0/256.0,  243.0/256.0,  027.0/256.0),
vec3(239.0/256.0,  223.0/256.0,  023.0/256.0),
vec3(219.0/256.0,  203.0/256.0,  019.0/256.0),
vec3(203.0/256.0,  183.0/256.0,  015.0/256.0),
vec3(187.0/256.0,  167.0/256.0,  015.0/256.0),
vec3(171.0/256.0,  151.0/256.0,  011.0/256.0),
vec3(155.0/256.0,  131.0/256.0,  007.0/256.0),
vec3(139.0/256.0,  115.0/256.0,  007.0/256.0),
vec3(123.0/256.0,  099.0/256.0,  007.0/256.0),
vec3(107.0/256.0,  083.0/256.0,  000.0/256.0),
vec3(091.0/256.0,  071.0/256.0,  000.0/256.0),
vec3(075.0/256.0,  055.0/256.0,  000.0/256.0),
vec3(059.0/256.0,  043.0/256.0,  000.0/256.0),
vec3(043.0/256.0,  031.0/256.0,  000.0/256.0),
vec3(027.0/256.0,  015.0/256.0,  000.0/256.0),
vec3(011.0/256.0,  007.0/256.0,  000.0/256.0),

vec3(000.0/256.0,  000.0/256.0,  255.0/256.0),
vec3(011.0/256.0,  011.0/256.0,  239.0/256.0),
vec3(019.0/256.0,  019.0/256.0,  223.0/256.0),
vec3(027.0/256.0,  027.0/256.0,  207.0/256.0),
vec3(035.0/256.0,  035.0/256.0,  191.0/256.0),
vec3(043.0/256.0,  043.0/256.0,  175.0/256.0),
vec3(047.0/256.0,  047.0/256.0,  159.0/256.0),
vec3(047.0/256.0,  047.0/256.0,  143.0/256.0),
vec3(047.0/256.0,  047.0/256.0,  127.0/256.0),
vec3(047.0/256.0,  047.0/256.0,  111.0/256.0),
vec3(047.0/256.0,  047.0/256.0,  095.0/256.0),
vec3(043.0/256.0,  043.0/256.0,  079.0/256.0),
vec3(035.0/256.0,  035.0/256.0,  063.0/256.0),
vec3(027.0/256.0,  027.0/256.0,  047.0/256.0),
vec3(019.0/256.0,  019.0/256.0,  031.0/256.0),
vec3(011.0/256.0,  011.0/256.0,  015.0/256.0),

vec3(043.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(059.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(075.0/256.0,  007.0/256.0,  000.0/256.0),
vec3(095.0/256.0,  007.0/256.0,  000.0/256.0),
vec3(111.0/256.0,  015.0/256.0,  000.0/256.0),
vec3(127.0/256.0,  023.0/256.0,  007.0/256.0),
vec3(147.0/256.0,  031.0/256.0,  007.0/256.0),
vec3(163.0/256.0,  039.0/256.0,  011.0/256.0),
vec3(183.0/256.0,  051.0/256.0,  015.0/256.0),
vec3(195.0/256.0,  075.0/256.0,  027.0/256.0),
vec3(207.0/256.0,  099.0/256.0,  043.0/256.0),
vec3(219.0/256.0,  127.0/256.0,  059.0/256.0),
vec3(227.0/256.0,  151.0/256.0,  079.0/256.0),
vec3(231.0/256.0,  171.0/256.0,  095.0/256.0),
vec3(239.0/256.0,  191.0/256.0,  119.0/256.0),
vec3(247.0/256.0,  211.0/256.0,  139.0/256.0),

vec3(167.0/256.0,  123.0/256.0,  059.0/256.0),
vec3(183.0/256.0,  155.0/256.0,  055.0/256.0),
vec3(199.0/256.0,  195.0/256.0,  055.0/256.0),
vec3(231.0/256.0,  227.0/256.0,  087.0/256.0),

vec3(127.0/256.0,  191.0/256.0,  255.0/256.0),
vec3(171.0/256.0,  231.0/256.0,  255.0/256.0),
vec3(215.0/256.0,  255.0/256.0,  255.0/256.0),

vec3(103.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(139.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(179.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(215.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(255.0/256.0,  000.0/256.0,  000.0/256.0),

vec3(255.0/256.0,  243.0/256.0,  147.0/256.0),
vec3(255.0/256.0,  247.0/256.0,  199.0/256.0),
vec3(255.0/256.0,  255.0/256.0,  255.0/256.0),

vec3(159.0/256.0,  091.0/256.0,  083.0/256.0)
);

vec3 palette[47] =
vec3[47](

vec3(000.0/256.0,  000.0/256.0,  000.0/256.0),

vec3(187.0/256.0,  187.0/256.0,  187.0/256.0),

vec3(115.0/256.0,  087.0/256.0,  031.0/256.0),

vec3(115.0/256.0,  115.0/256.0,  163.0/256.0),

vec3(083.0/256.0,  083.0/256.0,  011.0/256.0),

vec3(103.0/256.0,  000.0/256.0,  000.0/256.0),

vec3(139.0/256.0,  091.0/256.0,  019.0/256.0),

vec3(207.0/256.0,  143.0/256.0,  043.0/256.0),

vec3(183.0/256.0,  135.0/256.0,  107.0/256.0),

vec3(139.0/256.0,  103.0/256.0,  123.0/256.0),

vec3(151.0/256.0,  087.0/256.0,  119.0/256.0),

vec3(175.0/256.0,  151.0/256.0,  139.0/256.0),

vec3(087.0/256.0,  107.0/256.0,  095.0/256.0),

vec3(203.0/256.0,  183.0/256.0,  015.0/256.0),

vec3(027.0/256.0,  027.0/256.0,  207.0/256.0),

vec3(043.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(059.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(075.0/256.0,  007.0/256.0,  000.0/256.0),
vec3(095.0/256.0,  007.0/256.0,  000.0/256.0),
vec3(111.0/256.0,  015.0/256.0,  000.0/256.0),
vec3(127.0/256.0,  023.0/256.0,  007.0/256.0),
vec3(147.0/256.0,  031.0/256.0,  007.0/256.0),
vec3(163.0/256.0,  039.0/256.0,  011.0/256.0),
vec3(183.0/256.0,  051.0/256.0,  015.0/256.0),
vec3(195.0/256.0,  075.0/256.0,  027.0/256.0),
vec3(207.0/256.0,  099.0/256.0,  043.0/256.0),
vec3(219.0/256.0,  127.0/256.0,  059.0/256.0),
vec3(227.0/256.0,  151.0/256.0,  079.0/256.0),
vec3(231.0/256.0,  171.0/256.0,  095.0/256.0),
vec3(239.0/256.0,  191.0/256.0,  119.0/256.0),
vec3(247.0/256.0,  211.0/256.0,  139.0/256.0),

vec3(167.0/256.0,  123.0/256.0,  059.0/256.0),
vec3(183.0/256.0,  155.0/256.0,  055.0/256.0),
vec3(199.0/256.0,  195.0/256.0,  055.0/256.0),
vec3(231.0/256.0,  227.0/256.0,  087.0/256.0),

vec3(127.0/256.0,  191.0/256.0,  255.0/256.0),
vec3(171.0/256.0,  231.0/256.0,  255.0/256.0),
vec3(215.0/256.0,  255.0/256.0,  255.0/256.0),

vec3(103.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(139.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(179.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(215.0/256.0,  000.0/256.0,  000.0/256.0),
vec3(255.0/256.0,  000.0/256.0,  000.0/256.0),

vec3(255.0/256.0,  243.0/256.0,  147.0/256.0),
vec3(255.0/256.0,  247.0/256.0,  199.0/256.0),
vec3(255.0/256.0,  255.0/256.0,  255.0/256.0),

vec3(159.0/256.0,  091.0/256.0,  083.0/256.0)
);


vec3 paletteDoomFull[249] =
vec3[249](
vec3(0.0/256.0,0.0/256.0,0.0/256.0),
vec3(31.0/256.0,23.0/256.0,11.0/256.0),
vec3(23.0/256.0,15.0/256.0,7.0/256.0),
vec3(75.0/256.0,75.0/256.0,75.0/256.0),
vec3(255.0/256.0,255.0/256.0,255.0/256.0),
vec3(27.0/256.0,27.0/256.0,27.0/256.0),
vec3(19.0/256.0,19.0/256.0,19.0/256.0),
vec3(11.0/256.0,11.0/256.0,11.0/256.0),
vec3(7.0/256.0,7.0/256.0,7.0/256.0),
vec3(47.0/256.0,55.0/256.0,31.0/256.0),
vec3(35.0/256.0,43.0/256.0,15.0/256.0),
vec3(23.0/256.0,31.0/256.0,7.0/256.0),
vec3(15.0/256.0,23.0/256.0,0.0/256.0),
vec3(79.0/256.0,59.0/256.0,43.0/256.0),
vec3(71.0/256.0,51.0/256.0,35.0/256.0),
vec3(63.0/256.0,43.0/256.0,27.0/256.0),
vec3(255.0/256.0,183.0/256.0,183.0/256.0),
vec3(247.0/256.0,171.0/256.0,171.0/256.0),
vec3(243.0/256.0,163.0/256.0,163.0/256.0),
vec3(235.0/256.0,151.0/256.0,151.0/256.0),
vec3(231.0/256.0,143.0/256.0,143.0/256.0),
vec3(223.0/256.0,135.0/256.0,135.0/256.0),
vec3(219.0/256.0,123.0/256.0,123.0/256.0),
vec3(211.0/256.0,115.0/256.0,115.0/256.0),
vec3(203.0/256.0,107.0/256.0,107.0/256.0),
vec3(199.0/256.0,99.0/256.0,99.0/256.0),
vec3(191.0/256.0,91.0/256.0,91.0/256.0),
vec3(187.0/256.0,87.0/256.0,87.0/256.0),
vec3(179.0/256.0,79.0/256.0,79.0/256.0),
vec3(175.0/256.0,71.0/256.0,71.0/256.0),
vec3(167.0/256.0,63.0/256.0,63.0/256.0),
vec3(163.0/256.0,59.0/256.0,59.0/256.0),
vec3(155.0/256.0,51.0/256.0,51.0/256.0),
vec3(151.0/256.0,47.0/256.0,47.0/256.0),
vec3(143.0/256.0,43.0/256.0,43.0/256.0),
vec3(139.0/256.0,35.0/256.0,35.0/256.0),
vec3(131.0/256.0,31.0/256.0,31.0/256.0),
vec3(127.0/256.0,27.0/256.0,27.0/256.0),
vec3(119.0/256.0,23.0/256.0,23.0/256.0),
vec3(115.0/256.0,19.0/256.0,19.0/256.0),
vec3(107.0/256.0,15.0/256.0,15.0/256.0),
vec3(103.0/256.0,11.0/256.0,11.0/256.0),
vec3(95.0/256.0,7.0/256.0,7.0/256.0),
vec3(91.0/256.0,7.0/256.0,7.0/256.0),
vec3(83.0/256.0,7.0/256.0,7.0/256.0),
vec3(79.0/256.0,0.0/256.0,0.0/256.0),
vec3(71.0/256.0,0.0/256.0,0.0/256.0),
vec3(67.0/256.0,0.0/256.0,0.0/256.0),
vec3(255.0/256.0,235.0/256.0,223.0/256.0),
vec3(255.0/256.0,227.0/256.0,211.0/256.0),
vec3(255.0/256.0,219.0/256.0,199.0/256.0),
vec3(255.0/256.0,211.0/256.0,187.0/256.0),
vec3(255.0/256.0,207.0/256.0,179.0/256.0),
vec3(255.0/256.0,199.0/256.0,167.0/256.0),
vec3(255.0/256.0,191.0/256.0,155.0/256.0),
vec3(255.0/256.0,187.0/256.0,147.0/256.0),
vec3(255.0/256.0,179.0/256.0,131.0/256.0),
vec3(247.0/256.0,171.0/256.0,123.0/256.0),
vec3(239.0/256.0,163.0/256.0,115.0/256.0),
vec3(231.0/256.0,155.0/256.0,107.0/256.0),
vec3(223.0/256.0,147.0/256.0,99.0/256.0),
vec3(215.0/256.0,139.0/256.0,91.0/256.0),
vec3(207.0/256.0,131.0/256.0,83.0/256.0),
vec3(203.0/256.0,127.0/256.0,79.0/256.0),
vec3(191.0/256.0,123.0/256.0,75.0/256.0),
vec3(179.0/256.0,115.0/256.0,71.0/256.0),
vec3(171.0/256.0,111.0/256.0,67.0/256.0),
vec3(163.0/256.0,107.0/256.0,63.0/256.0),
vec3(155.0/256.0,99.0/256.0,59.0/256.0),
vec3(143.0/256.0,95.0/256.0,55.0/256.0),
vec3(135.0/256.0,87.0/256.0,51.0/256.0),
vec3(127.0/256.0,83.0/256.0,47.0/256.0),
vec3(119.0/256.0,79.0/256.0,43.0/256.0),
vec3(107.0/256.0,71.0/256.0,39.0/256.0),
vec3(95.0/256.0,67.0/256.0,35.0/256.0),
vec3(83.0/256.0,63.0/256.0,31.0/256.0),
vec3(75.0/256.0,55.0/256.0,27.0/256.0),
vec3(63.0/256.0,47.0/256.0,23.0/256.0),
vec3(51.0/256.0,43.0/256.0,19.0/256.0),
vec3(43.0/256.0,35.0/256.0,15.0/256.0),
vec3(239.0/256.0,239.0/256.0,239.0/256.0),
vec3(231.0/256.0,231.0/256.0,231.0/256.0),
vec3(223.0/256.0,223.0/256.0,223.0/256.0),
vec3(219.0/256.0,219.0/256.0,219.0/256.0),
vec3(211.0/256.0,211.0/256.0,211.0/256.0),
vec3(203.0/256.0,203.0/256.0,203.0/256.0),
vec3(199.0/256.0,199.0/256.0,199.0/256.0),
vec3(191.0/256.0,191.0/256.0,191.0/256.0),
vec3(183.0/256.0,183.0/256.0,183.0/256.0),
vec3(179.0/256.0,179.0/256.0,179.0/256.0),
vec3(171.0/256.0,171.0/256.0,171.0/256.0),
vec3(167.0/256.0,167.0/256.0,167.0/256.0),
vec3(159.0/256.0,159.0/256.0,159.0/256.0),
vec3(151.0/256.0,151.0/256.0,151.0/256.0),
vec3(147.0/256.0,147.0/256.0,147.0/256.0),
vec3(139.0/256.0,139.0/256.0,139.0/256.0),
vec3(131.0/256.0,131.0/256.0,131.0/256.0),
vec3(127.0/256.0,127.0/256.0,127.0/256.0),
vec3(119.0/256.0,119.0/256.0,119.0/256.0),
vec3(111.0/256.0,111.0/256.0,111.0/256.0),
vec3(107.0/256.0,107.0/256.0,107.0/256.0),
vec3(99.0/256.0,99.0/256.0,99.0/256.0),
vec3(91.0/256.0,91.0/256.0,91.0/256.0),
vec3(87.0/256.0,87.0/256.0,87.0/256.0),
vec3(79.0/256.0,79.0/256.0,79.0/256.0),
vec3(71.0/256.0,71.0/256.0,71.0/256.0),
vec3(67.0/256.0,67.0/256.0,67.0/256.0),
vec3(59.0/256.0,59.0/256.0,59.0/256.0),
vec3(55.0/256.0,55.0/256.0,55.0/256.0),
vec3(47.0/256.0,47.0/256.0,47.0/256.0),
vec3(39.0/256.0,39.0/256.0,39.0/256.0),
vec3(35.0/256.0,35.0/256.0,35.0/256.0),
vec3(119.0/256.0,255.0/256.0,111.0/256.0),
vec3(111.0/256.0,239.0/256.0,103.0/256.0),
vec3(103.0/256.0,223.0/256.0,95.0/256.0),
vec3(95.0/256.0,207.0/256.0,87.0/256.0),
vec3(91.0/256.0,191.0/256.0,79.0/256.0),
vec3(83.0/256.0,175.0/256.0,71.0/256.0),
vec3(75.0/256.0,159.0/256.0,63.0/256.0),
vec3(67.0/256.0,147.0/256.0,55.0/256.0),
vec3(63.0/256.0,131.0/256.0,47.0/256.0),
vec3(55.0/256.0,115.0/256.0,43.0/256.0),
vec3(47.0/256.0,99.0/256.0,35.0/256.0),
vec3(39.0/256.0,83.0/256.0,27.0/256.0),
vec3(31.0/256.0,67.0/256.0,23.0/256.0),
vec3(23.0/256.0,51.0/256.0,15.0/256.0),
vec3(19.0/256.0,35.0/256.0,11.0/256.0),
vec3(11.0/256.0,23.0/256.0,7.0/256.0),
vec3(191.0/256.0,167.0/256.0,143.0/256.0),
vec3(183.0/256.0,159.0/256.0,135.0/256.0),
vec3(175.0/256.0,151.0/256.0,127.0/256.0),
vec3(167.0/256.0,143.0/256.0,119.0/256.0),
vec3(159.0/256.0,135.0/256.0,111.0/256.0),
vec3(155.0/256.0,127.0/256.0,107.0/256.0),
vec3(147.0/256.0,123.0/256.0,99.0/256.0),
vec3(139.0/256.0,115.0/256.0,91.0/256.0),
vec3(131.0/256.0,107.0/256.0,87.0/256.0),
vec3(123.0/256.0,99.0/256.0,79.0/256.0),
vec3(119.0/256.0,95.0/256.0,75.0/256.0),
vec3(111.0/256.0,87.0/256.0,67.0/256.0),
vec3(103.0/256.0,83.0/256.0,63.0/256.0),
vec3(95.0/256.0,75.0/256.0,55.0/256.0),
vec3(87.0/256.0,67.0/256.0,51.0/256.0),
vec3(83.0/256.0,63.0/256.0,47.0/256.0),
vec3(159.0/256.0,131.0/256.0,99.0/256.0),
vec3(143.0/256.0,119.0/256.0,83.0/256.0),
vec3(131.0/256.0,107.0/256.0,75.0/256.0),
vec3(119.0/256.0,95.0/256.0,63.0/256.0),
vec3(103.0/256.0,83.0/256.0,51.0/256.0),
vec3(91.0/256.0,71.0/256.0,43.0/256.0),
vec3(79.0/256.0,59.0/256.0,35.0/256.0),
vec3(67.0/256.0,51.0/256.0,27.0/256.0),
vec3(123.0/256.0,127.0/256.0,99.0/256.0),
vec3(111.0/256.0,115.0/256.0,87.0/256.0),
vec3(103.0/256.0,107.0/256.0,79.0/256.0),
vec3(91.0/256.0,99.0/256.0,71.0/256.0),
vec3(83.0/256.0,87.0/256.0,59.0/256.0),
vec3(71.0/256.0,79.0/256.0,51.0/256.0),
vec3(63.0/256.0,71.0/256.0,43.0/256.0),
vec3(55.0/256.0,63.0/256.0,39.0/256.0),
vec3(255.0/256.0,255.0/256.0,115.0/256.0),
vec3(235.0/256.0,219.0/256.0,87.0/256.0),
vec3(215.0/256.0,187.0/256.0,67.0/256.0),
vec3(195.0/256.0,155.0/256.0,47.0/256.0),
vec3(175.0/256.0,123.0/256.0,31.0/256.0),
vec3(155.0/256.0,91.0/256.0,19.0/256.0),
vec3(135.0/256.0,67.0/256.0,7.0/256.0),
vec3(115.0/256.0,43.0/256.0,0.0/256.0),
vec3(255.0/256.0,219.0/256.0,219.0/256.0),
vec3(255.0/256.0,187.0/256.0,187.0/256.0),
vec3(255.0/256.0,155.0/256.0,155.0/256.0),
vec3(255.0/256.0,123.0/256.0,123.0/256.0),
vec3(255.0/256.0,95.0/256.0,95.0/256.0),
vec3(255.0/256.0,63.0/256.0,63.0/256.0),
vec3(255.0/256.0,31.0/256.0,31.0/256.0),
vec3(255.0/256.0,0.0/256.0,0.0/256.0),
vec3(239.0/256.0,0.0/256.0,0.0/256.0),
vec3(227.0/256.0,0.0/256.0,0.0/256.0),
vec3(215.0/256.0,0.0/256.0,0.0/256.0),
vec3(203.0/256.0,0.0/256.0,0.0/256.0),
vec3(191.0/256.0,0.0/256.0,0.0/256.0),
vec3(179.0/256.0,0.0/256.0,0.0/256.0),
vec3(167.0/256.0,0.0/256.0,0.0/256.0),
vec3(155.0/256.0,0.0/256.0,0.0/256.0),
vec3(139.0/256.0,0.0/256.0,0.0/256.0),
vec3(127.0/256.0,0.0/256.0,0.0/256.0),
vec3(115.0/256.0,0.0/256.0,0.0/256.0),
vec3(103.0/256.0,0.0/256.0,0.0/256.0),
vec3(91.0/256.0,0.0/256.0,0.0/256.0),
vec3(231.0/256.0,231.0/256.0,255.0/256.0),
vec3(199.0/256.0,199.0/256.0,255.0/256.0),
vec3(171.0/256.0,171.0/256.0,255.0/256.0),
vec3(143.0/256.0,143.0/256.0,255.0/256.0),
vec3(115.0/256.0,115.0/256.0,255.0/256.0),
vec3(83.0/256.0,83.0/256.0,255.0/256.0),
vec3(55.0/256.0,55.0/256.0,255.0/256.0),
vec3(27.0/256.0,27.0/256.0,255.0/256.0),
vec3(0.0/256.0,0.0/256.0,255.0/256.0),
vec3(0.0/256.0,0.0/256.0,227.0/256.0),
vec3(0.0/256.0,0.0/256.0,203.0/256.0),
vec3(0.0/256.0,0.0/256.0,179.0/256.0),
vec3(0.0/256.0,0.0/256.0,155.0/256.0),
vec3(0.0/256.0,0.0/256.0,131.0/256.0),
vec3(0.0/256.0,0.0/256.0,107.0/256.0),
vec3(0.0/256.0,0.0/256.0,83.0/256.0),
vec3(255.0/256.0,235.0/256.0,219.0/256.0),
vec3(255.0/256.0,215.0/256.0,187.0/256.0),
vec3(255.0/256.0,199.0/256.0,155.0/256.0),
vec3(255.0/256.0,179.0/256.0,123.0/256.0),
vec3(255.0/256.0,163.0/256.0,91.0/256.0),
vec3(255.0/256.0,143.0/256.0,59.0/256.0),
vec3(255.0/256.0,127.0/256.0,27.0/256.0),
vec3(243.0/256.0,115.0/256.0,23.0/256.0),
vec3(235.0/256.0,111.0/256.0,15.0/256.0),
vec3(223.0/256.0,103.0/256.0,15.0/256.0),
vec3(215.0/256.0,95.0/256.0,11.0/256.0),
vec3(203.0/256.0,87.0/256.0,7.0/256.0),
vec3(195.0/256.0,79.0/256.0,0.0/256.0),
vec3(183.0/256.0,71.0/256.0,0.0/256.0),
vec3(175.0/256.0,67.0/256.0,0.0/256.0),
vec3(255.0/256.0,255.0/256.0,215.0/256.0),
vec3(255.0/256.0,255.0/256.0,179.0/256.0),
vec3(255.0/256.0,255.0/256.0,143.0/256.0),
vec3(255.0/256.0,255.0/256.0,107.0/256.0),
vec3(255.0/256.0,255.0/256.0,71.0/256.0),
vec3(255.0/256.0,255.0/256.0,35.0/256.0),
vec3(255.0/256.0,255.0/256.0,0.0/256.0),
vec3(167.0/256.0,63.0/256.0,0.0/256.0),
vec3(159.0/256.0,55.0/256.0,0.0/256.0),
vec3(147.0/256.0,47.0/256.0,0.0/256.0),
vec3(135.0/256.0,35.0/256.0,0.0/256.0),
vec3(79.0/256.0,59.0/256.0,39.0/256.0),
vec3(67.0/256.0,47.0/256.0,27.0/256.0),
vec3(55.0/256.0,35.0/256.0,19.0/256.0),
vec3(47.0/256.0,27.0/256.0,11.0/256.0),
vec3(0.0/256.0,0.0/256.0,71.0/256.0),
vec3(0.0/256.0,0.0/256.0,59.0/256.0),
vec3(0.0/256.0,0.0/256.0,47.0/256.0),
vec3(0.0/256.0,0.0/256.0,35.0/256.0),
vec3(0.0/256.0,0.0/256.0,23.0/256.0),
vec3(0.0/256.0,0.0/256.0,11.0/256.0),
vec3(255.0/256.0,159.0/256.0,67.0/256.0),
vec3(255.0/256.0,231.0/256.0,75.0/256.0),
vec3(255.0/256.0,123.0/256.0,255.0/256.0),
vec3(255.0/256.0,0.0/256.0,255.0/256.0),
vec3(207.0/256.0,0.0/256.0,207.0/256.0),
vec3(159.0/256.0,0.0/256.0,155.0/256.0),
vec3(111.0/256.0,0.0/256.0,107.0/256.0),
vec3(167.0/256.0,107.0/256.0,107.0/256.0)
);


float getMatchDistanceHue(vec3 c, vec3 p_c) {
   return min(abs(c.x - p_c.x), abs(c.x + 1.0 - p_c.x ));
}


float getMatchDistanceW(vec3 c, vec3 p_c, vec3 w) {
    vec3 d = vec3(getMatchDistanceHue(c, p_c),abs(c.y-p_c.y),abs(c.z-p_c.z))*w;
    vec3 d2 = d*d;
    return sqrt(d.x+d.y+d.z);
}


vec3 defaultW = vec3(8.0,3.0,0.0);


float getMatchDistance(vec3 c, vec3 p_c) {
    return getMatchDistanceW(c,p_c,defaultW);
}


vec3 createFromMatch(vec3 c, vec3 p_c) {
  float w_s = clamp(mix(0.0,0.99,1.-c.y*2.0),0.0,1.0);
  return vec3(mix(p_c.x,c.x,0.0), mix(p_c.y,c.y,w_s), mix(p_c.z,c.z,0.99));
}

vec3 mixLAB(vec3 p_A, float distA, vec3 p_B, float distB) {
  float m = clamp((distB+EPSILON)/(distA+distB+EPSILON),0.0,1.0);
  return mix(p_A,p_B,m);
}

vec3 getPaletteMatchLABSimpleCore(vec3 lab, vec3 w) {
    vec3 c = oklab_to_okhsl(lab);
    float dist = 1000.0;
    vec3 match = vec3(0.0,0.0,0.0);;

    for(int i = 0; i < 256; i++) {
        vec3 p_rgb = SRGBtoRGB(paletteFull[i]);
        vec3 p_lab = linear_srgb_to_oklab(p_rgb);
        vec3 p_c =  oklab_to_okhsl(p_lab);
   
        float p_dist = getMatchDistanceW(c, p_c, w);
        
        if(p_dist < dist) {
            dist = p_dist;
            match = p_lab;
        }
    }
    
    return match;
}

vec3 getPaletteMatchLABSimpleCore(vec3 lab) {
    return  getPaletteMatchLABSimpleCore(lab, defaultW);
}

vec3 getPaletteMatchLABCore(vec3 lab) {

    vec3 c = oklab_to_okhsl(lab);
    
    float distA = 1000.0;
    vec3 p_A = vec3(0.0,0.0,0.0);
    float distB = 1000.0;
    vec3 p_B = vec3(-1.0,-1.0,-1.0);

    for(int i = 0; i < 256; i++) {
        vec3 p_rgb = SRGBtoRGB(paletteFull[i]);
        vec3 p_lab = linear_srgb_to_oklab(p_rgb);
        vec3 p_c =  oklab_to_okhsl(p_lab);
   
        float p_dist = getMatchDistance(c, p_c);
        float p_distA = getMatchDistance(p_A, p_c);
        float p_distB = getMatchDistance(p_B, p_c);
        float distAB = getMatchDistance(p_A, p_B);
        
        if(p_dist-EPSILON < distA // closer than current match
        && distAB+EPSILON >= p_dist  // A/B not on same side
        ){ 
            distA = p_dist;
            p_A = p_lab;
        }
        else 
        if(p_dist-EPSILON < distB // closer than current match
        && p_dist-EPSILON < distA*2.0 // not farther than 2xA
        //&& distAB+EPSILON >= p_distA  // old span bigger than new span
        && p_distA+EPSILON >= p_dist  // A/B not on same side
        ){ 
            distB = p_dist;
            p_B = p_lab;
        }
        
    }
    
    if(p_B.x < 0.0)
        p_B = p_A;
    
    vec3 match = mixLAB(p_A, distA, p_B, distB);
    return match;
}


vec3 getPaletteMatchLAB(vec3 rgb) {
    vec3 lab = linear_srgb_to_oklab(rgb);
    
    vec3 match = getPaletteMatchLABSimpleCore((lab));
    
    /*
    float d = 0.001;
    vec3 match1 = getPaletteMatchLABCore((lab+vec3(0,0,1)*d));
    vec3 match2 = getPaletteMatchLABCore((lab+vec3(0,0,-1)*d));
    vec3 match3 = getPaletteMatchLABCore((lab+vec3(0,1,0)*d));
    vec3 match4 = getPaletteMatchLABCore((lab+vec3(0,-1,0)*d));
    
    
    match = match*0.6+match1*0.1+match1*0.1+match1*0.1+match1*0.1;
    */
    
    match = oklab_to_okhsl(match);
    
    vec3 c = oklab_to_okhsl(lab);
    c = createFromMatch(c, match);
    return okhsl_to_linear_srgb(c);
}



vec3 getPaletteMatchHSL(vec3 rgb) {
    vec3 c = RGBtoHSL(rgb);
    float dist = 1000.0;
    vec3 match = vec3(0,0,0);

    for(int i = 0; i < 256; i++) {
        vec3 p_rgb = SRGBtoRGB(paletteFull[i]);
        vec3 p_c = RGBtoHSV(p_rgb);
   
        float p_dist = getMatchDistance(c, p_c);
        
        if(p_dist-EPSILON < dist) {
            dist = p_dist;
            match = p_c;
        }
        
    }
    c = createFromMatch(c, match);
    return HSLtoRGB(c);
}


